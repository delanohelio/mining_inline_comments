{"pr_number": 4545, "pr_title": "NXP-29978: add support for idempotency key in request controller filter", "pr_createdAt": "2020-12-15T12:52:24Z", "pr_url": "https://github.com/nuxeo/nuxeo/pull/4545", "timeline": [{"oid": "d653e8b3c91494a9e193fe40f9bcfe075c19623c", "url": "https://github.com/nuxeo/nuxeo/commit/d653e8b3c91494a9e193fe40f9bcfe075c19623c", "message": "NXP-29978: add support for idempotency key in request controller filter", "committedDate": "2020-12-15T12:53:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMyODE0Mw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r543328143", "bodyText": "Could we use something more generic, like Idempotency-Key or X-Idempotency-Key maybe?", "author": "BoboTiG", "createdAt": "2020-12-15T13:10:52Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/NuxeoRequestControllerFilter.java", "diffHunk": "@@ -70,13 +72,36 @@\n \n     protected static final int LOCK_TIMEOUT_S = 120;\n \n+    protected static final String IDEMPOTENCY_KEY = \"NuxeoIdempotencyKey\";", "originalCommit": "d653e8b3c91494a9e193fe40f9bcfe075c19623c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMzMzYyNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r543333625", "bodyText": "Of course, I was not sure if we wanted this header to be Nuxeo-specific so i just went with this value for now", "author": "atchertchian", "createdAt": "2020-12-15T13:18:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMyODE0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4MzgyOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r544883829", "bodyText": "I moved the key in the code but we should still discuss naming, so keeping this conversation open", "author": "atchertchian", "createdAt": "2020-12-17T08:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMyODE0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjgyNTc0OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r546825749", "bodyText": "Idempotency-Key is good it's what's in the draft RFC and used by lots of organizations already.", "author": "efge", "createdAt": "2020-12-21T17:11:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMyODE0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMzMzMyMw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r543333323", "bodyText": "https://github.com/paypal/api-standards/blob/master/patterns.md#idempotency explains that should return HTTP 200 + the result.\nWhen it is a new request, it should return HTTP 201  + the result.\nI am not familiar with the code here, does that return such HTTP codes?", "author": "BoboTiG", "createdAt": "2020-12-15T13:18:29Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/NuxeoRequestControllerFilter.java", "diffHunk": "@@ -295,4 +319,34 @@ protected void addCacheHeaders(HttpServletResponse response, RequestFilterConfig\n         }\n     }\n \n+    protected void handleRequest(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        if (request.getMethod().equals(\"GET\") || request.getMethod().equals(\"POST\")) {\n+            String key = request.getHeader(IDEMPOTENCY_KEY);\n+            if (key != null) {\n+                KeyValueService kvs = Framework.getService(KeyValueService.class);\n+                KeyValueStore store = kvs.getKeyValueStore(idempotencyStoreName);\n+                String value = store.getString(key);\n+                if (value == null) {\n+                    // new request\n+                    store.put(key, IDEMPOTENCY_INPROGRESS_MARKER, idempotencyTTLSeconds);\n+                    CopyingHttpServletResponse wrapper = new CopyingHttpServletResponse(response);\n+                    chain.doFilter(request, wrapper);\n+                    store.put(key, wrapper.getCopy(), idempotencyTTLSeconds);\n+                } else if (IDEMPOTENCY_INPROGRESS_MARKER.equals(value)) {\n+                    // request already in progress -> conflict (?) any content?\n+                    response.sendError(HttpServletResponse.SC_CONFLICT);\n+                } else {\n+                    // request already done: return stored result\n+                    // XXX get back status code?", "originalCommit": "d653e8b3c91494a9e193fe40f9bcfe075c19623c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMzNTYyNg==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r543335626", "bodyText": "I went with conflict because that's what's documented here https://tools.ietf.org/html/draft-idempotency-header-01.\nAs for 201, this filter cannot know this is for creation so not sure 201 applies here, and the code is left unchanged compared to a request that would go through without idempotency.", "author": "atchertchian", "createdAt": "2020-12-15T13:21:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMzMzMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMzNzU2Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r543337567", "bodyText": "Conflict seems the good error to throw.\n200 or 201, I would say this is fine as-is. As soon as this is not an error code :)", "author": "BoboTiG", "createdAt": "2020-12-15T13:24:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMzMzMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM0NTI3Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r543345276", "bodyText": "Well it will be an error code if there's indeed an error while processing the request.\nThat's also why we may want the code to be stored too when the request is processed, so that is can be returned again in case a request with the same key has already gone through.", "author": "atchertchian", "createdAt": "2020-12-15T13:35:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMzMzMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM1MTgzOA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r543351838", "bodyText": "Hmm how would you make the difference between an HTTP 500 error and a \"valid\" error like a 404? The 500 error should not be cached as another call may unlock the real result. And a 404 now may not be revelant 2 minutes later. Same for 401 and 403 errors for example.", "author": "BoboTiG", "createdAt": "2020-12-15T13:44:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMzMzMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM1MzA4MA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r543353080", "bodyText": "Ok so maybe the code should be checked before storing the result, and key removed from the store in this case?", "author": "atchertchian", "createdAt": "2020-12-15T13:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMzMzMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4NDM0MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r544884341", "bodyText": "I changed the processing so that in case of error, store content is nullified for this key", "author": "atchertchian", "createdAt": "2020-12-17T08:02:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMzMzMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMzNjEzMA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r543336130", "bodyText": "5 minutes seems quite small, no?", "author": "BoboTiG", "createdAt": "2020-12-15T13:22:35Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/NuxeoRequestControllerFilter.java", "diffHunk": "@@ -70,13 +72,36 @@\n \n     protected static final int LOCK_TIMEOUT_S = 120;\n \n+    protected static final String IDEMPOTENCY_KEY = \"NuxeoIdempotencyKey\";\n+\n+    protected static final String IDEMPOTENCY_STORE_NAME_PROPERTY = \"idempotency_keyvaluestore\";\n+\n+    protected static final String IDEMPOTENCY_TTL_SECONDS_PARAM = \"idempotency_ttl_seconds\";\n+\n+    protected static final String IDEMPOTENCY_INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    protected int idempotencyTTLSeconds = 300;", "originalCommit": "d653e8b3c91494a9e193fe40f9bcfe075c19623c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMzNzEzNw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r543337137", "bodyText": "I put a (quite) low TTL for testing, we can set a better default value indeed.", "author": "atchertchian", "createdAt": "2020-12-15T13:24:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMzNjEzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4NDY0Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r544884647", "bodyText": "I moved these values but we should still discuss the default value for TTL", "author": "atchertchian", "createdAt": "2020-12-17T08:03:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMzNjEzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjgyNjA1Mw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r546826053", "bodyText": "The base default should be at least one day I think. Some organizations use 30 days as TTL!", "author": "efge", "createdAt": "2020-12-21T17:11:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMzNjEzMA=="}], "type": "inlineReview"}, {"oid": "cf967f5f08327996543e3dd55c662b66b9f7ef0f", "url": "https://github.com/nuxeo/nuxeo/commit/cf967f5f08327996543e3dd55c662b66b9f7ef0f", "message": "NXP-29978: add support for idempotency key in request controller filter", "committedDate": "2020-12-17T07:58:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4NDkzNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r544884935", "bodyText": "Only handling POST requests --> to be discussed, maybe", "author": "atchertchian", "createdAt": "2020-12-17T08:03:38Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */\n+    public static final String HEADER_KEY = \"NuxeoIdempotencyKey\";\n+\n+    /** @since 11.5 */\n+    public static final String STORE_PROPERTY = \"idempotency_keyvaluestore\";\n+\n+    /** @since 11.5 */\n+    public static final String TTL_SECONDS_PROPERTY = \"idempotency_ttl_seconds\";\n+\n+    /** @since 11.5 */\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    /** @since 11.5 */\n+    public static final String STATUS_PREFIX = \"s_\";\n+\n+    /** @since 11.5 */\n+    public static final String CONTENT_PREFIX = \"c_\";\n+\n+    protected final String store;\n+\n+    protected final int ttl;\n+\n+    public IdempotentRequestHandler(FilterConfig filterConfig) {\n+        // default values\n+        int ttl = 330;\n+        String store = \"requestcontroller\";\n+        // retrieve potential configuration from filter\n+        String ttlConfig = filterConfig.getInitParameter(IdempotentRequestHandler.TTL_SECONDS_PROPERTY);\n+        if (ttlConfig != null) {\n+            try {\n+                ttl = Integer.valueOf(ttlConfig);\n+            } catch (NumberFormatException e) {\n+                log.error(e, e);\n+            }\n+        }\n+        String storeConfig = filterConfig.getInitParameter(IdempotentRequestHandler.STORE_PROPERTY);\n+        if (storeConfig != null) {\n+            store = storeConfig;\n+        }\n+        this.store = store;\n+        this.ttl = ttl;\n+    }\n+\n+    public IdempotentRequestHandler(String storename, int ttl) {\n+        this.store = storename;\n+        this.ttl = ttl;\n+    }\n+\n+    public void handle(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        if (!\"POST\".equals(request.getMethod())) {", "originalCommit": "cf967f5f08327996543e3dd55c662b66b9f7ef0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc3ODcxNw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r546778717", "bodyText": "We should activate the filter for all methods except GET/HEAD/OPTIONS/TRACE, which are the \"safe methods\" per RFC 7231 \u00a74.2.1, and PUT/DELETE which are the \"idempotent methods\" per RFC 7231 \u00a74.2.2. So in practice it's mostly POST yes, but maybe we use the RFC list instead to be clean.", "author": "efge", "createdAt": "2020-12-21T15:45:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4NDkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjgxNjI0MA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r546816240", "bodyText": "I'm not sure if you mean is should filter out all of these instead of accepting just POST?\nAlso javax.ws.rs.HttpMethod declares these as constants, except TRACE, so not sure the full list is already available somewhere else?", "author": "atchertchian", "createdAt": "2020-12-21T16:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4NDkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjgyNTM5OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r546825399", "bodyText": "Yes I mean filter out all these.\nSee what NuxeoCorsCsrfFilter does for the constants.", "author": "efge", "createdAt": "2020-12-21T17:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4NDkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4NTE5NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r544885195", "bodyText": "Maybe should retrieve configuration from the ConfigurationService instead?", "author": "atchertchian", "createdAt": "2020-12-17T08:04:09Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */\n+    public static final String HEADER_KEY = \"NuxeoIdempotencyKey\";\n+\n+    /** @since 11.5 */\n+    public static final String STORE_PROPERTY = \"idempotency_keyvaluestore\";\n+\n+    /** @since 11.5 */\n+    public static final String TTL_SECONDS_PROPERTY = \"idempotency_ttl_seconds\";\n+\n+    /** @since 11.5 */\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    /** @since 11.5 */\n+    public static final String STATUS_PREFIX = \"s_\";\n+\n+    /** @since 11.5 */\n+    public static final String CONTENT_PREFIX = \"c_\";\n+\n+    protected final String store;\n+\n+    protected final int ttl;\n+\n+    public IdempotentRequestHandler(FilterConfig filterConfig) {\n+        // default values\n+        int ttl = 330;\n+        String store = \"requestcontroller\";\n+        // retrieve potential configuration from filter", "originalCommit": "cf967f5f08327996543e3dd55c662b66b9f7ef0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjgyNjM1MA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r546826350", "bodyText": "Yes it'd be easier to change through contributions rather than changing a filter config.", "author": "efge", "createdAt": "2020-12-21T17:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4NTE5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4NjIyNA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r544886224", "bodyText": "Using CONFLICT status + mentioning key in the response body -> to be discussed, maybe?", "author": "atchertchian", "createdAt": "2020-12-17T08:06:07Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */\n+    public static final String HEADER_KEY = \"NuxeoIdempotencyKey\";\n+\n+    /** @since 11.5 */\n+    public static final String STORE_PROPERTY = \"idempotency_keyvaluestore\";\n+\n+    /** @since 11.5 */\n+    public static final String TTL_SECONDS_PROPERTY = \"idempotency_ttl_seconds\";\n+\n+    /** @since 11.5 */\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    /** @since 11.5 */\n+    public static final String STATUS_PREFIX = \"s_\";\n+\n+    /** @since 11.5 */\n+    public static final String CONTENT_PREFIX = \"c_\";\n+\n+    protected final String store;\n+\n+    protected final int ttl;\n+\n+    public IdempotentRequestHandler(FilterConfig filterConfig) {\n+        // default values\n+        int ttl = 330;\n+        String store = \"requestcontroller\";\n+        // retrieve potential configuration from filter\n+        String ttlConfig = filterConfig.getInitParameter(IdempotentRequestHandler.TTL_SECONDS_PROPERTY);\n+        if (ttlConfig != null) {\n+            try {\n+                ttl = Integer.valueOf(ttlConfig);\n+            } catch (NumberFormatException e) {\n+                log.error(e, e);\n+            }\n+        }\n+        String storeConfig = filterConfig.getInitParameter(IdempotentRequestHandler.STORE_PROPERTY);\n+        if (storeConfig != null) {\n+            store = storeConfig;\n+        }\n+        this.store = store;\n+        this.ttl = ttl;\n+    }\n+\n+    public IdempotentRequestHandler(String storename, int ttl) {\n+        this.store = storename;\n+        this.ttl = ttl;\n+    }\n+\n+    public void handle(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        if (!\"POST\".equals(request.getMethod())) {\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        String key = request.getHeader(IdempotentRequestHandler.HEADER_KEY);\n+        if (key == null) {\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        KeyValueStore store = Framework.getService(KeyValueService.class).getKeyValueStore(this.store);\n+        String storedContent = store.getString(IdempotentRequestHandler.CONTENT_PREFIX + key);\n+        if (storedContent == null) {\n+            // new request\n+            boolean cleanup = false;\n+            store.put(IdempotentRequestHandler.CONTENT_PREFIX + key, IdempotentRequestHandler.INPROGRESS_MARKER, ttl);\n+            try {\n+                CopyingResponseWrapper wrapper = new CopyingResponseWrapper(response);\n+                chain.doFilter(request, wrapper);\n+                store.put(IdempotentRequestHandler.CONTENT_PREFIX + key, wrapper.getCaptureAsString(), ttl);\n+                store.put(IdempotentRequestHandler.STATUS_PREFIX + key, String.valueOf(wrapper.getStatus()), ttl);\n+            } catch (IOException | ServletException e) {\n+                cleanup = true;\n+                throw e;\n+            } finally {\n+                if (cleanup || response.getStatus() >= 400) {\n+                    // error request: cleanup store\n+                    store.put(IdempotentRequestHandler.CONTENT_PREFIX + key, (String) null, ttl);\n+                    store.put(IdempotentRequestHandler.STATUS_PREFIX + key, (String) null, ttl);\n+                }\n+            }\n+        } else if (IdempotentRequestHandler.INPROGRESS_MARKER.equals(storedContent)) {\n+            // request already in progress -> conflict\n+            response.sendError(HttpServletResponse.SC_CONFLICT,", "originalCommit": "cf967f5f08327996543e3dd55c662b66b9f7ef0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjgyNjc4MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r546826781", "bodyText": "I don't think it'll help clients, they won't read the body in case of 409. Just debug logs is enough.", "author": "efge", "createdAt": "2020-12-21T17:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4NjIyNA=="}], "type": "inlineReview"}, {"oid": "98570dca813bcc2e332d4b811353ead76b00072a", "url": "https://github.com/nuxeo/nuxeo/commit/98570dca813bcc2e332d4b811353ead76b00072a", "message": "NXP-29978: add support for idempotency key in request controller filter", "committedDate": "2020-12-17T08:33:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc3OTgwMQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r546779801", "bodyText": "It's worth adding log.debug calls in all the places where we have some logic to allow debugging, see what I did in NuxeoCorsCsrfFilter", "author": "efge", "createdAt": "2020-12-21T15:46:55Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */\n+    public static final String HEADER_KEY = \"NuxeoIdempotencyKey\";\n+\n+    /** @since 11.5 */\n+    public static final String STORE_PROPERTY = \"idempotency_keyvaluestore\";\n+\n+    /** @since 11.5 */\n+    public static final String TTL_SECONDS_PROPERTY = \"idempotency_ttl_seconds\";\n+\n+    /** @since 11.5 */\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    /** @since 11.5 */\n+    public static final String STATUS_PREFIX = \"s_\";\n+\n+    /** @since 11.5 */\n+    public static final String CONTENT_PREFIX = \"c_\";\n+\n+    protected final String store;\n+\n+    protected final int ttl;\n+\n+    public IdempotentRequestHandler(FilterConfig filterConfig) {\n+        // default values\n+        int ttl = 330;\n+        String store = \"requestcontroller\";\n+        // retrieve potential configuration from filter\n+        String ttlConfig = filterConfig.getInitParameter(IdempotentRequestHandler.TTL_SECONDS_PROPERTY);\n+        if (ttlConfig != null) {\n+            try {\n+                ttl = Integer.valueOf(ttlConfig);\n+            } catch (NumberFormatException e) {\n+                log.error(e, e);\n+            }\n+        }\n+        String storeConfig = filterConfig.getInitParameter(IdempotentRequestHandler.STORE_PROPERTY);\n+        if (storeConfig != null) {\n+            store = storeConfig;\n+        }\n+        this.store = store;\n+        this.ttl = ttl;\n+    }\n+\n+    public IdempotentRequestHandler(String storename, int ttl) {\n+        this.store = storename;\n+        this.ttl = ttl;\n+    }\n+\n+    public void handle(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        if (!\"POST\".equals(request.getMethod())) {\n+            chain.doFilter(request, response);", "originalCommit": "98570dca813bcc2e332d4b811353ead76b00072a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIwODMwNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r547208305", "bodyText": "I added a number of debug logs, let me know if they should be changed.", "author": "atchertchian", "createdAt": "2020-12-22T10:52:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc3OTgwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc4MDkxNw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r546780917", "bodyText": "The store name should default to a more explicit idempotentrequest for instance", "author": "efge", "createdAt": "2020-12-21T15:48:47Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */\n+    public static final String HEADER_KEY = \"NuxeoIdempotencyKey\";\n+\n+    /** @since 11.5 */\n+    public static final String STORE_PROPERTY = \"idempotency_keyvaluestore\";\n+\n+    /** @since 11.5 */\n+    public static final String TTL_SECONDS_PROPERTY = \"idempotency_ttl_seconds\";\n+\n+    /** @since 11.5 */\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    /** @since 11.5 */\n+    public static final String STATUS_PREFIX = \"s_\";\n+\n+    /** @since 11.5 */\n+    public static final String CONTENT_PREFIX = \"c_\";\n+\n+    protected final String store;\n+\n+    protected final int ttl;\n+\n+    public IdempotentRequestHandler(FilterConfig filterConfig) {\n+        // default values\n+        int ttl = 330;\n+        String store = \"requestcontroller\";", "originalCommit": "98570dca813bcc2e332d4b811353ead76b00072a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc4MTczNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r546781735", "bodyText": "You should protect against NPEs here, for the service and the store. Filters may be called very early/late and independently of Nuxeo startup itself.", "author": "efge", "createdAt": "2020-12-21T15:50:06Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */\n+    public static final String HEADER_KEY = \"NuxeoIdempotencyKey\";\n+\n+    /** @since 11.5 */\n+    public static final String STORE_PROPERTY = \"idempotency_keyvaluestore\";\n+\n+    /** @since 11.5 */\n+    public static final String TTL_SECONDS_PROPERTY = \"idempotency_ttl_seconds\";\n+\n+    /** @since 11.5 */\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    /** @since 11.5 */\n+    public static final String STATUS_PREFIX = \"s_\";\n+\n+    /** @since 11.5 */\n+    public static final String CONTENT_PREFIX = \"c_\";\n+\n+    protected final String store;\n+\n+    protected final int ttl;\n+\n+    public IdempotentRequestHandler(FilterConfig filterConfig) {\n+        // default values\n+        int ttl = 330;\n+        String store = \"requestcontroller\";\n+        // retrieve potential configuration from filter\n+        String ttlConfig = filterConfig.getInitParameter(IdempotentRequestHandler.TTL_SECONDS_PROPERTY);\n+        if (ttlConfig != null) {\n+            try {\n+                ttl = Integer.valueOf(ttlConfig);\n+            } catch (NumberFormatException e) {\n+                log.error(e, e);\n+            }\n+        }\n+        String storeConfig = filterConfig.getInitParameter(IdempotentRequestHandler.STORE_PROPERTY);\n+        if (storeConfig != null) {\n+            store = storeConfig;\n+        }\n+        this.store = store;\n+        this.ttl = ttl;\n+    }\n+\n+    public IdempotentRequestHandler(String storename, int ttl) {\n+        this.store = storename;\n+        this.ttl = ttl;\n+    }\n+\n+    public void handle(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        if (!\"POST\".equals(request.getMethod())) {\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        String key = request.getHeader(IdempotentRequestHandler.HEADER_KEY);\n+        if (key == null) {\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        KeyValueStore store = Framework.getService(KeyValueService.class).getKeyValueStore(this.store);", "originalCommit": "98570dca813bcc2e332d4b811353ead76b00072a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc4MjE1Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r546782152", "bodyText": "For the content stored/returned we should manipulate only bytes, not a string representation.", "author": "efge", "createdAt": "2020-12-21T15:50:56Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */\n+    public static final String HEADER_KEY = \"NuxeoIdempotencyKey\";\n+\n+    /** @since 11.5 */\n+    public static final String STORE_PROPERTY = \"idempotency_keyvaluestore\";\n+\n+    /** @since 11.5 */\n+    public static final String TTL_SECONDS_PROPERTY = \"idempotency_ttl_seconds\";\n+\n+    /** @since 11.5 */\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    /** @since 11.5 */\n+    public static final String STATUS_PREFIX = \"s_\";\n+\n+    /** @since 11.5 */\n+    public static final String CONTENT_PREFIX = \"c_\";\n+\n+    protected final String store;\n+\n+    protected final int ttl;\n+\n+    public IdempotentRequestHandler(FilterConfig filterConfig) {\n+        // default values\n+        int ttl = 330;\n+        String store = \"requestcontroller\";\n+        // retrieve potential configuration from filter\n+        String ttlConfig = filterConfig.getInitParameter(IdempotentRequestHandler.TTL_SECONDS_PROPERTY);\n+        if (ttlConfig != null) {\n+            try {\n+                ttl = Integer.valueOf(ttlConfig);\n+            } catch (NumberFormatException e) {\n+                log.error(e, e);\n+            }\n+        }\n+        String storeConfig = filterConfig.getInitParameter(IdempotentRequestHandler.STORE_PROPERTY);\n+        if (storeConfig != null) {\n+            store = storeConfig;\n+        }\n+        this.store = store;\n+        this.ttl = ttl;\n+    }\n+\n+    public IdempotentRequestHandler(String storename, int ttl) {\n+        this.store = storename;\n+        this.ttl = ttl;\n+    }\n+\n+    public void handle(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        if (!\"POST\".equals(request.getMethod())) {\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        String key = request.getHeader(IdempotentRequestHandler.HEADER_KEY);\n+        if (key == null) {\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        KeyValueStore store = Framework.getService(KeyValueService.class).getKeyValueStore(this.store);\n+        String storedContent = store.getString(IdempotentRequestHandler.CONTENT_PREFIX + key);", "originalCommit": "98570dca813bcc2e332d4b811353ead76b00072a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc4NDQ4Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r546784487", "bodyText": "400 -> HttpServletResponse .SC_BAD_REQUEST", "author": "efge", "createdAt": "2020-12-21T15:54:55Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */\n+    public static final String HEADER_KEY = \"NuxeoIdempotencyKey\";\n+\n+    /** @since 11.5 */\n+    public static final String STORE_PROPERTY = \"idempotency_keyvaluestore\";\n+\n+    /** @since 11.5 */\n+    public static final String TTL_SECONDS_PROPERTY = \"idempotency_ttl_seconds\";\n+\n+    /** @since 11.5 */\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    /** @since 11.5 */\n+    public static final String STATUS_PREFIX = \"s_\";\n+\n+    /** @since 11.5 */\n+    public static final String CONTENT_PREFIX = \"c_\";\n+\n+    protected final String store;\n+\n+    protected final int ttl;\n+\n+    public IdempotentRequestHandler(FilterConfig filterConfig) {\n+        // default values\n+        int ttl = 330;\n+        String store = \"requestcontroller\";\n+        // retrieve potential configuration from filter\n+        String ttlConfig = filterConfig.getInitParameter(IdempotentRequestHandler.TTL_SECONDS_PROPERTY);\n+        if (ttlConfig != null) {\n+            try {\n+                ttl = Integer.valueOf(ttlConfig);\n+            } catch (NumberFormatException e) {\n+                log.error(e, e);\n+            }\n+        }\n+        String storeConfig = filterConfig.getInitParameter(IdempotentRequestHandler.STORE_PROPERTY);\n+        if (storeConfig != null) {\n+            store = storeConfig;\n+        }\n+        this.store = store;\n+        this.ttl = ttl;\n+    }\n+\n+    public IdempotentRequestHandler(String storename, int ttl) {\n+        this.store = storename;\n+        this.ttl = ttl;\n+    }\n+\n+    public void handle(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        if (!\"POST\".equals(request.getMethod())) {\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        String key = request.getHeader(IdempotentRequestHandler.HEADER_KEY);\n+        if (key == null) {\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        KeyValueStore store = Framework.getService(KeyValueService.class).getKeyValueStore(this.store);\n+        String storedContent = store.getString(IdempotentRequestHandler.CONTENT_PREFIX + key);\n+        if (storedContent == null) {\n+            // new request\n+            boolean cleanup = false;\n+            store.put(IdempotentRequestHandler.CONTENT_PREFIX + key, IdempotentRequestHandler.INPROGRESS_MARKER, ttl);\n+            try {\n+                CopyingResponseWrapper wrapper = new CopyingResponseWrapper(response);\n+                chain.doFilter(request, wrapper);\n+                store.put(IdempotentRequestHandler.CONTENT_PREFIX + key, wrapper.getCaptureAsString(), ttl);\n+                store.put(IdempotentRequestHandler.STATUS_PREFIX + key, String.valueOf(wrapper.getStatus()), ttl);\n+            } catch (IOException | ServletException e) {\n+                cleanup = true;\n+                throw e;\n+            } finally {\n+                if (cleanup || response.getStatus() >= 400) {", "originalCommit": "98570dca813bcc2e332d4b811353ead76b00072a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzE4MDYwMA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r547180600", "bodyText": "? this is still an error response that KV should not store, right?", "author": "atchertchian", "createdAt": "2020-12-22T09:56:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc4NDQ4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIwNjU5Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r547206597", "bodyText": "Yes I just mean use the constant instead of a number.", "author": "efge", "createdAt": "2020-12-22T10:48:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc4NDQ4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIwNzM2OA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r547207368", "bodyText": "ah ok \ud83d\udc4d", "author": "atchertchian", "createdAt": "2020-12-22T10:50:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc4NDQ4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc4ODQ3OA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r546788478", "bodyText": "One of them, probably the content, could have no prefix at all. And for the other I would have used a suffix, to make listings/dumps easier to read.", "author": "efge", "createdAt": "2020-12-21T16:01:52Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */\n+    public static final String HEADER_KEY = \"NuxeoIdempotencyKey\";\n+\n+    /** @since 11.5 */\n+    public static final String STORE_PROPERTY = \"idempotency_keyvaluestore\";\n+\n+    /** @since 11.5 */\n+    public static final String TTL_SECONDS_PROPERTY = \"idempotency_ttl_seconds\";\n+\n+    /** @since 11.5 */\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    /** @since 11.5 */\n+    public static final String STATUS_PREFIX = \"s_\";\n+\n+    /** @since 11.5 */\n+    public static final String CONTENT_PREFIX = \"c_\";\n+\n+    protected final String store;\n+\n+    protected final int ttl;\n+\n+    public IdempotentRequestHandler(FilterConfig filterConfig) {\n+        // default values\n+        int ttl = 330;\n+        String store = \"requestcontroller\";\n+        // retrieve potential configuration from filter\n+        String ttlConfig = filterConfig.getInitParameter(IdempotentRequestHandler.TTL_SECONDS_PROPERTY);\n+        if (ttlConfig != null) {\n+            try {\n+                ttl = Integer.valueOf(ttlConfig);\n+            } catch (NumberFormatException e) {\n+                log.error(e, e);\n+            }\n+        }\n+        String storeConfig = filterConfig.getInitParameter(IdempotentRequestHandler.STORE_PROPERTY);\n+        if (storeConfig != null) {\n+            store = storeConfig;\n+        }\n+        this.store = store;\n+        this.ttl = ttl;\n+    }\n+\n+    public IdempotentRequestHandler(String storename, int ttl) {\n+        this.store = storename;\n+        this.ttl = ttl;\n+    }\n+\n+    public void handle(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        if (!\"POST\".equals(request.getMethod())) {\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        String key = request.getHeader(IdempotentRequestHandler.HEADER_KEY);\n+        if (key == null) {\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        KeyValueStore store = Framework.getService(KeyValueService.class).getKeyValueStore(this.store);\n+        String storedContent = store.getString(IdempotentRequestHandler.CONTENT_PREFIX + key);\n+        if (storedContent == null) {\n+            // new request\n+            boolean cleanup = false;\n+            store.put(IdempotentRequestHandler.CONTENT_PREFIX + key, IdempotentRequestHandler.INPROGRESS_MARKER, ttl);\n+            try {\n+                CopyingResponseWrapper wrapper = new CopyingResponseWrapper(response);\n+                chain.doFilter(request, wrapper);\n+                store.put(IdempotentRequestHandler.CONTENT_PREFIX + key, wrapper.getCaptureAsString(), ttl);\n+                store.put(IdempotentRequestHandler.STATUS_PREFIX + key, String.valueOf(wrapper.getStatus()), ttl);", "originalCommit": "98570dca813bcc2e332d4b811353ead76b00072a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc4OTc4OA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r546789788", "bodyText": "Don't use a TTL when putting null", "author": "efge", "createdAt": "2020-12-21T16:04:10Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */\n+    public static final String HEADER_KEY = \"NuxeoIdempotencyKey\";\n+\n+    /** @since 11.5 */\n+    public static final String STORE_PROPERTY = \"idempotency_keyvaluestore\";\n+\n+    /** @since 11.5 */\n+    public static final String TTL_SECONDS_PROPERTY = \"idempotency_ttl_seconds\";\n+\n+    /** @since 11.5 */\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    /** @since 11.5 */\n+    public static final String STATUS_PREFIX = \"s_\";\n+\n+    /** @since 11.5 */\n+    public static final String CONTENT_PREFIX = \"c_\";\n+\n+    protected final String store;\n+\n+    protected final int ttl;\n+\n+    public IdempotentRequestHandler(FilterConfig filterConfig) {\n+        // default values\n+        int ttl = 330;\n+        String store = \"requestcontroller\";\n+        // retrieve potential configuration from filter\n+        String ttlConfig = filterConfig.getInitParameter(IdempotentRequestHandler.TTL_SECONDS_PROPERTY);\n+        if (ttlConfig != null) {\n+            try {\n+                ttl = Integer.valueOf(ttlConfig);\n+            } catch (NumberFormatException e) {\n+                log.error(e, e);\n+            }\n+        }\n+        String storeConfig = filterConfig.getInitParameter(IdempotentRequestHandler.STORE_PROPERTY);\n+        if (storeConfig != null) {\n+            store = storeConfig;\n+        }\n+        this.store = store;\n+        this.ttl = ttl;\n+    }\n+\n+    public IdempotentRequestHandler(String storename, int ttl) {\n+        this.store = storename;\n+        this.ttl = ttl;\n+    }\n+\n+    public void handle(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        if (!\"POST\".equals(request.getMethod())) {\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        String key = request.getHeader(IdempotentRequestHandler.HEADER_KEY);\n+        if (key == null) {\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        KeyValueStore store = Framework.getService(KeyValueService.class).getKeyValueStore(this.store);\n+        String storedContent = store.getString(IdempotentRequestHandler.CONTENT_PREFIX + key);\n+        if (storedContent == null) {\n+            // new request\n+            boolean cleanup = false;\n+            store.put(IdempotentRequestHandler.CONTENT_PREFIX + key, IdempotentRequestHandler.INPROGRESS_MARKER, ttl);\n+            try {\n+                CopyingResponseWrapper wrapper = new CopyingResponseWrapper(response);\n+                chain.doFilter(request, wrapper);\n+                store.put(IdempotentRequestHandler.CONTENT_PREFIX + key, wrapper.getCaptureAsString(), ttl);\n+                store.put(IdempotentRequestHandler.STATUS_PREFIX + key, String.valueOf(wrapper.getStatus()), ttl);\n+            } catch (IOException | ServletException e) {\n+                cleanup = true;\n+                throw e;\n+            } finally {\n+                if (cleanup || response.getStatus() >= 400) {\n+                    // error request: cleanup store\n+                    store.put(IdempotentRequestHandler.CONTENT_PREFIX + key, (String) null, ttl);\n+                    store.put(IdempotentRequestHandler.STATUS_PREFIX + key, (String) null, ttl);", "originalCommit": "98570dca813bcc2e332d4b811353ead76b00072a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc5MDUwMA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r546790500", "bodyText": "For in-progress it's better to use a special status value (negative?) instead of the content. This way the content is pure content and not mixed with other logic.", "author": "efge", "createdAt": "2020-12-21T16:05:25Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */\n+    public static final String HEADER_KEY = \"NuxeoIdempotencyKey\";\n+\n+    /** @since 11.5 */\n+    public static final String STORE_PROPERTY = \"idempotency_keyvaluestore\";\n+\n+    /** @since 11.5 */\n+    public static final String TTL_SECONDS_PROPERTY = \"idempotency_ttl_seconds\";\n+\n+    /** @since 11.5 */\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    /** @since 11.5 */\n+    public static final String STATUS_PREFIX = \"s_\";\n+\n+    /** @since 11.5 */\n+    public static final String CONTENT_PREFIX = \"c_\";\n+\n+    protected final String store;\n+\n+    protected final int ttl;\n+\n+    public IdempotentRequestHandler(FilterConfig filterConfig) {\n+        // default values\n+        int ttl = 330;\n+        String store = \"requestcontroller\";\n+        // retrieve potential configuration from filter\n+        String ttlConfig = filterConfig.getInitParameter(IdempotentRequestHandler.TTL_SECONDS_PROPERTY);\n+        if (ttlConfig != null) {\n+            try {\n+                ttl = Integer.valueOf(ttlConfig);\n+            } catch (NumberFormatException e) {\n+                log.error(e, e);\n+            }\n+        }\n+        String storeConfig = filterConfig.getInitParameter(IdempotentRequestHandler.STORE_PROPERTY);\n+        if (storeConfig != null) {\n+            store = storeConfig;\n+        }\n+        this.store = store;\n+        this.ttl = ttl;\n+    }\n+\n+    public IdempotentRequestHandler(String storename, int ttl) {\n+        this.store = storename;\n+        this.ttl = ttl;\n+    }\n+\n+    public void handle(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        if (!\"POST\".equals(request.getMethod())) {\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        String key = request.getHeader(IdempotentRequestHandler.HEADER_KEY);\n+        if (key == null) {\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        KeyValueStore store = Framework.getService(KeyValueService.class).getKeyValueStore(this.store);\n+        String storedContent = store.getString(IdempotentRequestHandler.CONTENT_PREFIX + key);\n+        if (storedContent == null) {\n+            // new request\n+            boolean cleanup = false;\n+            store.put(IdempotentRequestHandler.CONTENT_PREFIX + key, IdempotentRequestHandler.INPROGRESS_MARKER, ttl);\n+            try {\n+                CopyingResponseWrapper wrapper = new CopyingResponseWrapper(response);\n+                chain.doFilter(request, wrapper);\n+                store.put(IdempotentRequestHandler.CONTENT_PREFIX + key, wrapper.getCaptureAsString(), ttl);\n+                store.put(IdempotentRequestHandler.STATUS_PREFIX + key, String.valueOf(wrapper.getStatus()), ttl);\n+            } catch (IOException | ServletException e) {\n+                cleanup = true;\n+                throw e;\n+            } finally {\n+                if (cleanup || response.getStatus() >= 400) {\n+                    // error request: cleanup store\n+                    store.put(IdempotentRequestHandler.CONTENT_PREFIX + key, (String) null, ttl);\n+                    store.put(IdempotentRequestHandler.STATUS_PREFIX + key, (String) null, ttl);\n+                }\n+            }\n+        } else if (IdempotentRequestHandler.INPROGRESS_MARKER.equals(storedContent)) {", "originalCommit": "98570dca813bcc2e332d4b811353ead76b00072a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA2OTgxMw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548069813", "bodyText": "I kept this key as is in place of json serialization of response headers + status, let me know if you still think I should change this marker (sorry, renamed and moved all classes...)", "author": "atchertchian", "createdAt": "2020-12-23T17:27:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc5MDUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc5MTc4Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r546791786", "bodyText": "As mentioned you should use bytes, not string. So use getOutputStream here instead of getWriter.", "author": "efge", "createdAt": "2020-12-21T16:07:41Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */\n+    public static final String HEADER_KEY = \"NuxeoIdempotencyKey\";\n+\n+    /** @since 11.5 */\n+    public static final String STORE_PROPERTY = \"idempotency_keyvaluestore\";\n+\n+    /** @since 11.5 */\n+    public static final String TTL_SECONDS_PROPERTY = \"idempotency_ttl_seconds\";\n+\n+    /** @since 11.5 */\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    /** @since 11.5 */\n+    public static final String STATUS_PREFIX = \"s_\";\n+\n+    /** @since 11.5 */\n+    public static final String CONTENT_PREFIX = \"c_\";\n+\n+    protected final String store;\n+\n+    protected final int ttl;\n+\n+    public IdempotentRequestHandler(FilterConfig filterConfig) {\n+        // default values\n+        int ttl = 330;\n+        String store = \"requestcontroller\";\n+        // retrieve potential configuration from filter\n+        String ttlConfig = filterConfig.getInitParameter(IdempotentRequestHandler.TTL_SECONDS_PROPERTY);\n+        if (ttlConfig != null) {\n+            try {\n+                ttl = Integer.valueOf(ttlConfig);\n+            } catch (NumberFormatException e) {\n+                log.error(e, e);\n+            }\n+        }\n+        String storeConfig = filterConfig.getInitParameter(IdempotentRequestHandler.STORE_PROPERTY);\n+        if (storeConfig != null) {\n+            store = storeConfig;\n+        }\n+        this.store = store;\n+        this.ttl = ttl;\n+    }\n+\n+    public IdempotentRequestHandler(String storename, int ttl) {\n+        this.store = storename;\n+        this.ttl = ttl;\n+    }\n+\n+    public void handle(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        if (!\"POST\".equals(request.getMethod())) {\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        String key = request.getHeader(IdempotentRequestHandler.HEADER_KEY);\n+        if (key == null) {\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        KeyValueStore store = Framework.getService(KeyValueService.class).getKeyValueStore(this.store);\n+        String storedContent = store.getString(IdempotentRequestHandler.CONTENT_PREFIX + key);\n+        if (storedContent == null) {\n+            // new request\n+            boolean cleanup = false;\n+            store.put(IdempotentRequestHandler.CONTENT_PREFIX + key, IdempotentRequestHandler.INPROGRESS_MARKER, ttl);\n+            try {\n+                CopyingResponseWrapper wrapper = new CopyingResponseWrapper(response);\n+                chain.doFilter(request, wrapper);\n+                store.put(IdempotentRequestHandler.CONTENT_PREFIX + key, wrapper.getCaptureAsString(), ttl);\n+                store.put(IdempotentRequestHandler.STATUS_PREFIX + key, String.valueOf(wrapper.getStatus()), ttl);\n+            } catch (IOException | ServletException e) {\n+                cleanup = true;\n+                throw e;\n+            } finally {\n+                if (cleanup || response.getStatus() >= 400) {\n+                    // error request: cleanup store\n+                    store.put(IdempotentRequestHandler.CONTENT_PREFIX + key, (String) null, ttl);\n+                    store.put(IdempotentRequestHandler.STATUS_PREFIX + key, (String) null, ttl);\n+                }\n+            }\n+        } else if (IdempotentRequestHandler.INPROGRESS_MARKER.equals(storedContent)) {\n+            // request already in progress -> conflict\n+            response.sendError(HttpServletResponse.SC_CONFLICT,\n+                    String.format(\"Idempotent request already in progress for key '%s'\", key));\n+        } else {\n+            // request already done: return stored result\n+            response.getWriter().write(storedContent);", "originalCommit": "98570dca813bcc2e332d4b811353ead76b00072a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc5NDUyMg==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r546794522", "bodyText": "In addition to the status we must also save/restore all headers (which will include cookies and values like content-type and content-length).\nSo the whole status key in the k/v store could contain some JSON with this info (+ the http status)", "author": "efge", "createdAt": "2020-12-21T16:12:48Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */\n+    public static final String HEADER_KEY = \"NuxeoIdempotencyKey\";\n+\n+    /** @since 11.5 */\n+    public static final String STORE_PROPERTY = \"idempotency_keyvaluestore\";\n+\n+    /** @since 11.5 */\n+    public static final String TTL_SECONDS_PROPERTY = \"idempotency_ttl_seconds\";\n+\n+    /** @since 11.5 */\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    /** @since 11.5 */\n+    public static final String STATUS_PREFIX = \"s_\";\n+\n+    /** @since 11.5 */\n+    public static final String CONTENT_PREFIX = \"c_\";\n+\n+    protected final String store;\n+\n+    protected final int ttl;\n+\n+    public IdempotentRequestHandler(FilterConfig filterConfig) {\n+        // default values\n+        int ttl = 330;\n+        String store = \"requestcontroller\";\n+        // retrieve potential configuration from filter\n+        String ttlConfig = filterConfig.getInitParameter(IdempotentRequestHandler.TTL_SECONDS_PROPERTY);\n+        if (ttlConfig != null) {\n+            try {\n+                ttl = Integer.valueOf(ttlConfig);\n+            } catch (NumberFormatException e) {\n+                log.error(e, e);\n+            }\n+        }\n+        String storeConfig = filterConfig.getInitParameter(IdempotentRequestHandler.STORE_PROPERTY);\n+        if (storeConfig != null) {\n+            store = storeConfig;\n+        }\n+        this.store = store;\n+        this.ttl = ttl;\n+    }\n+\n+    public IdempotentRequestHandler(String storename, int ttl) {\n+        this.store = storename;\n+        this.ttl = ttl;\n+    }\n+\n+    public void handle(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        if (!\"POST\".equals(request.getMethod())) {\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        String key = request.getHeader(IdempotentRequestHandler.HEADER_KEY);\n+        if (key == null) {\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        KeyValueStore store = Framework.getService(KeyValueService.class).getKeyValueStore(this.store);\n+        String storedContent = store.getString(IdempotentRequestHandler.CONTENT_PREFIX + key);\n+        if (storedContent == null) {\n+            // new request\n+            boolean cleanup = false;\n+            store.put(IdempotentRequestHandler.CONTENT_PREFIX + key, IdempotentRequestHandler.INPROGRESS_MARKER, ttl);\n+            try {\n+                CopyingResponseWrapper wrapper = new CopyingResponseWrapper(response);\n+                chain.doFilter(request, wrapper);\n+                store.put(IdempotentRequestHandler.CONTENT_PREFIX + key, wrapper.getCaptureAsString(), ttl);\n+                store.put(IdempotentRequestHandler.STATUS_PREFIX + key, String.valueOf(wrapper.getStatus()), ttl);\n+            } catch (IOException | ServletException e) {\n+                cleanup = true;\n+                throw e;\n+            } finally {\n+                if (cleanup || response.getStatus() >= 400) {\n+                    // error request: cleanup store\n+                    store.put(IdempotentRequestHandler.CONTENT_PREFIX + key, (String) null, ttl);\n+                    store.put(IdempotentRequestHandler.STATUS_PREFIX + key, (String) null, ttl);\n+                }\n+            }\n+        } else if (IdempotentRequestHandler.INPROGRESS_MARKER.equals(storedContent)) {\n+            // request already in progress -> conflict\n+            response.sendError(HttpServletResponse.SC_CONFLICT,\n+                    String.format(\"Idempotent request already in progress for key '%s'\", key));\n+        } else {\n+            // request already done: return stored result\n+            response.getWriter().write(storedContent);\n+            response.setStatus(Integer.valueOf(store.getString(IdempotentRequestHandler.STATUS_PREFIX + key)));", "originalCommit": "98570dca813bcc2e332d4b811353ead76b00072a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA3MDM1OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548070359", "bodyText": "Added a serialization of response status + headers as the stored json in the additional \"info\".", "author": "atchertchian", "createdAt": "2020-12-23T17:28:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc5NDUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc5NTczNw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r546795737", "bodyText": "In addition to this base test we should test for content that is not representable as a string, and headers (content type, custom headers, cookies).", "author": "efge", "createdAt": "2020-12-21T16:14:56Z", "path": "modules/platform/nuxeo-platform-web-common/src/test/java/org/nuxeo/ecm/platform/web/requestcontroller/filter/TestIdempotentRequestFilter.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.requestcontroller.filter;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static javax.servlet.http.HttpServletResponse.SC_OK;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyInt;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+\n+import javax.inject.Inject;\n+import javax.servlet.FilterChain;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.nuxeo.ecm.platform.web.common.requestcontroller.filter.IdempotentRequestHandler;\n+import org.nuxeo.ecm.platform.web.common.requestcontroller.filter.NuxeoRequestControllerFilter;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStoreProvider;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.RuntimeFeature;\n+\n+/**\n+ * Checks idempotent requests management.\n+ *\n+ * @since 11.5\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(RuntimeFeature.class)\n+@Deploy(\"org.nuxeo.runtime.kv\")\n+@Deploy(\"org.nuxeo.ecm.platform.web.common:OSGI-INF/web-request-controller-framework.xml\")\n+public class TestIdempotentRequestFilter {\n+\n+    protected static final int TTL = 30;\n+\n+    protected static final String KV_STORE_NAME = \"requestcontroller\";\n+\n+    protected static final String KEY = \"mykey\";\n+\n+    protected static final String CONTENT = \"test content\";\n+\n+    protected NuxeoRequestControllerFilter filter;\n+\n+    protected FilterChain chain;\n+\n+    protected HttpServletRequest request;\n+\n+    protected MockResponse mockResponse;\n+\n+    @Inject\n+    protected KeyValueService kvs;\n+\n+    protected KeyValueStoreProvider store;\n+\n+    protected static class MockResponse {\n+\n+        protected HttpServletResponse response;\n+\n+        protected int status;\n+\n+        protected OutputStream output;\n+\n+        public MockResponse() throws IOException {\n+            super();\n+            response = mock(HttpServletResponse.class);\n+            output = new ByteArrayOutputStream();\n+            ServletOutputStream servletOutput = mock(ServletOutputStream.class);\n+            doAnswer(invocation -> {\n+                output.write((byte[]) invocation.getArguments()[0]);\n+                return null;\n+            }).when(servletOutput).write(any(byte[].class));\n+            doAnswer(invocation -> {\n+                output.write((Integer) invocation.getArguments()[0]);\n+                return null;\n+            }).when(servletOutput).write(anyInt());\n+            when(response.getOutputStream()).thenReturn(servletOutput);\n+            PrintWriter writer = mock(PrintWriter.class);\n+            doAnswer(invocation -> {\n+                output.write(((String) invocation.getArguments()[0]).getBytes());\n+                return null;\n+            }).when(writer).write(anyString());\n+            doAnswer(invocation -> {\n+                return writer;\n+            }).when(response).getWriter();\n+            when(response.getCharacterEncoding()).thenReturn(UTF_8.name());\n+            doAnswer(invocation -> {\n+                return status;\n+            }).when(response).getStatus();\n+            doAnswer(invocation -> {\n+                status = (Integer) invocation.getArguments()[0];\n+                return null;\n+            }).when(response).setStatus(anyInt());\n+            doAnswer(invocation -> {\n+                status = (Integer) invocation.getArguments()[0];\n+                output.write(((String) invocation.getArguments()[1]).getBytes());\n+                return null;\n+            }).when(response).sendError(anyInt(), anyString());\n+        }\n+\n+        public int getStatus() {\n+            return status;\n+        }\n+\n+        public HttpServletResponse getResponse() {\n+            return response;\n+        }\n+\n+        public OutputStream getOutput() {\n+            return output;\n+        }\n+\n+    }\n+\n+    @Before\n+    public void setUp() throws IOException {\n+        filter = new NuxeoRequestControllerFilter();\n+        FilterConfig config = mock(FilterConfig.class);\n+        when(config.getInitParameter(IdempotentRequestHandler.TTL_SECONDS_PROPERTY)).thenReturn(String.valueOf(TTL));\n+        when(config.getInitParameter(IdempotentRequestHandler.STORE_PROPERTY)).thenReturn(KV_STORE_NAME);\n+        filter.init(config);\n+        chain = mock(FilterChain.class);\n+        request = mock(HttpServletRequest.class);\n+        mockResponse = new MockResponse();\n+        // handle store\n+        store = (KeyValueStoreProvider) kvs.getKeyValueStore(KV_STORE_NAME);\n+        store.clear();\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        if (filter != null) {\n+            filter.destroy();\n+        }\n+        if (store != null) {\n+            store.clear();\n+        }\n+    }\n+\n+    protected void checkResponse(MockResponse mockResponse, Integer status, String content) {\n+        assertEquals(status, (Integer) mockResponse.getStatus());\n+        assertEquals(content, mockResponse.getOutput().toString());\n+    }\n+\n+    protected void checkStore(Integer status, String content) {\n+        assertEquals(content, store.getString(IdempotentRequestHandler.CONTENT_PREFIX + KEY));\n+        String skey = IdempotentRequestHandler.STATUS_PREFIX + KEY;\n+        if (status == null) {\n+            assertNull(store.getString(skey));\n+        } else {\n+            assertEquals(String.valueOf(status), store.getString(skey));\n+        }\n+    }\n+\n+    @Test\n+    public void testGetRequestWithoutKey() throws Exception {\n+        when(request.getMethod()).thenReturn(\"GET\");\n+        verify(chain, times(0)).doFilter(any(), any());\n+        filter.doFilter(request, mockResponse.getResponse(), chain);\n+        verify(chain, times(1)).doFilter(any(), any());\n+        checkStore(null, null);\n+    }\n+\n+    @Test\n+    public void testPostRequestWithoutKey() throws Exception {\n+        when(request.getMethod()).thenReturn(\"POST\");\n+        verify(chain, times(0)).doFilter(any(), any());\n+        filter.doFilter(request, mockResponse.getResponse(), chain);\n+        verify(chain, times(1)).doFilter(any(), any());\n+        checkStore(null, null);\n+    }\n+\n+    @Test\n+    public void testGetRequest() throws Exception {\n+        when(request.getMethod()).thenReturn(\"GET\");\n+        when(request.getHeader(IdempotentRequestHandler.HEADER_KEY)).thenReturn(KEY);\n+        verify(chain, times(0)).doFilter(any(), any());\n+        filter.doFilter(request, mockResponse.getResponse(), chain);\n+        verify(chain, times(1)).doFilter(any(), any());\n+        checkStore(null, null);\n+    }\n+\n+    protected void setResult(HttpServletResponse response, int status, String content) throws IOException {\n+        response.setStatus(status);\n+        response.getWriter().write(content);\n+    }\n+\n+    @Test\n+    public void testPostRequest() throws Exception {", "originalCommit": "98570dca813bcc2e332d4b811353ead76b00072a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA3MTczMw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548071733", "bodyText": "I added quick mock headers, as for the content, not sure if this would belong in this test as everything here is actually mocked... to be discussed again, keeping this conversation open for this.", "author": "atchertchian", "createdAt": "2020-12-23T17:30:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc5NTczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjgzMDUzNw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r546830537", "bodyText": "Good for an initial prototype, but in general we can't buffer in memory.", "author": "efge", "createdAt": "2020-12-21T17:20:56Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/CopyingServletOutputStream.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.WriteListener;\n+\n+/**\n+ * Captures content written to the target stream.\n+ *\n+ * @since 11.5\n+ */\n+public class CopyingServletOutputStream extends ServletOutputStream {\n+\n+    protected final ServletOutputStream output;\n+\n+    protected final ByteArrayOutputStream capture;", "originalCommit": "98570dca813bcc2e332d4b811353ead76b00072a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA3MjM0Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548072346", "bodyText": "Reworked to rely on apache DeferredFileOutputStream", "author": "atchertchian", "createdAt": "2020-12-23T17:30:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjgzMDUzNw=="}], "type": "inlineReview"}, {"oid": "38bd3fe74aa5a433ab06987e66ed875bd4ef1d8f", "url": "https://github.com/nuxeo/nuxeo/commit/38bd3fe74aa5a433ab06987e66ed875bd4ef1d8f", "message": "NXP-29978: add support for idempotency key in request controller filter", "committedDate": "2020-12-22T11:28:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIzNzU4Mw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r547237583", "bodyText": "You already have @since 11.5 on the class, no need for it on all constants", "author": "efge", "createdAt": "2020-12-22T11:58:57Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */", "originalCommit": "38bd3fe74aa5a433ab06987e66ed875bd4ef1d8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg1Mzk0OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r547853949", "bodyText": "Will update this if/when merging code with filter code.", "author": "atchertchian", "createdAt": "2020-12-23T09:28:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIzNzU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIzODY5MA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r547238690", "bodyText": "FYI for new code I'm trying to use the idiom long DEFAULT_TTL_SECONDS = Duration.ofDays(1).toSeconds() to be explicit. And make the ttl a long everywhere", "author": "efge", "createdAt": "2020-12-22T12:01:33Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    /** @since 11.5 */\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.controller.keyvaluestore.name\";\n+\n+    protected static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    /** 1 day */\n+    protected static final int DEFAULT_TTL_SECONDS = 86400;", "originalCommit": "38bd3fe74aa5a433ab06987e66ed875bd4ef1d8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIzOTAzNw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r547239037", "bodyText": "This should mention request idempotency instead of request.controller (which is an implementation detail)", "author": "efge", "createdAt": "2020-12-22T12:02:24Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    /** @since 11.5 */\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.controller.keyvaluestore.name\";\n+\n+    protected static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    /** 1 day */\n+    protected static final int DEFAULT_TTL_SECONDS = 86400;\n+\n+    /** @since 11.5 */\n+    public static final String TTL_SECONDS_PROPERTY = \"org.nuxeo.request.controller.ttl.seconds\";", "originalCommit": "38bd3fe74aa5a433ab06987e66ed875bd4ef1d8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIzOTQ3MA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r547239470", "bodyText": "Do we plan on backporting? Otherwise Set.of() is simpler", "author": "efge", "createdAt": "2020-12-22T12:03:27Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    /** @since 11.5 */\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.controller.keyvaluestore.name\";\n+\n+    protected static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    /** 1 day */\n+    protected static final int DEFAULT_TTL_SECONDS = 86400;\n+\n+    /** @since 11.5 */\n+    public static final String TTL_SECONDS_PROPERTY = \"org.nuxeo.request.controller.ttl.seconds\";\n+\n+    /** @since 11.5 */\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    /** @since 11.5 */\n+    public static final String STATUS_SUFFIX = \"_status\";\n+\n+    // safe methods according to RFC 7231 4.2.1\n+    protected static final Set<String> SAFE_METHODS = new HashSet<>(\n+            Arrays.asList(HttpGet.METHOD_NAME, HttpHead.METHOD_NAME, HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME));", "originalCommit": "38bd3fe74aa5a433ab06987e66ed875bd4ef1d8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MDE4Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r547240182", "bodyText": "Suggest shouldIgnore -> isIdempotentMethod", "author": "efge", "createdAt": "2020-12-22T12:05:02Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    /** @since 11.5 */\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.controller.keyvaluestore.name\";\n+\n+    protected static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    /** 1 day */\n+    protected static final int DEFAULT_TTL_SECONDS = 86400;\n+\n+    /** @since 11.5 */\n+    public static final String TTL_SECONDS_PROPERTY = \"org.nuxeo.request.controller.ttl.seconds\";\n+\n+    /** @since 11.5 */\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    /** @since 11.5 */\n+    public static final String STATUS_SUFFIX = \"_status\";\n+\n+    // safe methods according to RFC 7231 4.2.1\n+    protected static final Set<String> SAFE_METHODS = new HashSet<>(\n+            Arrays.asList(HttpGet.METHOD_NAME, HttpHead.METHOD_NAME, HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME));\n+\n+    // idempotent methods according to RFC 7231 4.2.2\n+    protected static final Set<String> IDEMPOTENT_METHODS = new HashSet<>(\n+            Arrays.asList(HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME));\n+\n+    protected int getTTLSeconds() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getInteger(TTL_SECONDS_PROPERTY, DEFAULT_TTL_SECONDS);\n+        }\n+        return DEFAULT_TTL_SECONDS;\n+    }\n+\n+    protected String getStoreName() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getString(STORE_PROPERTY, DEFAULT_STORE);\n+        }\n+        return DEFAULT_STORE;\n+    }\n+\n+    protected boolean shouldIgnore(String method) {", "originalCommit": "38bd3fe74aa5a433ab06987e66ed875bd4ef1d8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MTM1Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r547241356", "bodyText": "Add detail: No idempotent processing done: method is already idempotent (the request isn't really ignored)\nI would actually log the method here and not in a separate line.", "author": "efge", "createdAt": "2020-12-22T12:07:37Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    /** @since 11.5 */\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.controller.keyvaluestore.name\";\n+\n+    protected static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    /** 1 day */\n+    protected static final int DEFAULT_TTL_SECONDS = 86400;\n+\n+    /** @since 11.5 */\n+    public static final String TTL_SECONDS_PROPERTY = \"org.nuxeo.request.controller.ttl.seconds\";\n+\n+    /** @since 11.5 */\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    /** @since 11.5 */\n+    public static final String STATUS_SUFFIX = \"_status\";\n+\n+    // safe methods according to RFC 7231 4.2.1\n+    protected static final Set<String> SAFE_METHODS = new HashSet<>(\n+            Arrays.asList(HttpGet.METHOD_NAME, HttpHead.METHOD_NAME, HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME));\n+\n+    // idempotent methods according to RFC 7231 4.2.2\n+    protected static final Set<String> IDEMPOTENT_METHODS = new HashSet<>(\n+            Arrays.asList(HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME));\n+\n+    protected int getTTLSeconds() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getInteger(TTL_SECONDS_PROPERTY, DEFAULT_TTL_SECONDS);\n+        }\n+        return DEFAULT_TTL_SECONDS;\n+    }\n+\n+    protected String getStoreName() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getString(STORE_PROPERTY, DEFAULT_STORE);\n+        }\n+        return DEFAULT_STORE;\n+    }\n+\n+    protected boolean shouldIgnore(String method) {\n+        return SAFE_METHODS.contains(method) || IDEMPOTENT_METHODS.contains(method);\n+    }\n+\n+    public void handle(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        String method = request.getMethod();\n+        log.debug(\"Method: \" + method);\n+        if (shouldIgnore(method)) {\n+            log.debug(\"Request ignored\");", "originalCommit": "38bd3fe74aa5a433ab06987e66ed875bd4ef1d8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MjExNg==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r547242116", "bodyText": "No idempotent processing done: no Idempotent-Key present", "author": "efge", "createdAt": "2020-12-22T12:09:29Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    /** @since 11.5 */\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.controller.keyvaluestore.name\";\n+\n+    protected static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    /** 1 day */\n+    protected static final int DEFAULT_TTL_SECONDS = 86400;\n+\n+    /** @since 11.5 */\n+    public static final String TTL_SECONDS_PROPERTY = \"org.nuxeo.request.controller.ttl.seconds\";\n+\n+    /** @since 11.5 */\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    /** @since 11.5 */\n+    public static final String STATUS_SUFFIX = \"_status\";\n+\n+    // safe methods according to RFC 7231 4.2.1\n+    protected static final Set<String> SAFE_METHODS = new HashSet<>(\n+            Arrays.asList(HttpGet.METHOD_NAME, HttpHead.METHOD_NAME, HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME));\n+\n+    // idempotent methods according to RFC 7231 4.2.2\n+    protected static final Set<String> IDEMPOTENT_METHODS = new HashSet<>(\n+            Arrays.asList(HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME));\n+\n+    protected int getTTLSeconds() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getInteger(TTL_SECONDS_PROPERTY, DEFAULT_TTL_SECONDS);\n+        }\n+        return DEFAULT_TTL_SECONDS;\n+    }\n+\n+    protected String getStoreName() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getString(STORE_PROPERTY, DEFAULT_STORE);\n+        }\n+        return DEFAULT_STORE;\n+    }\n+\n+    protected boolean shouldIgnore(String method) {\n+        return SAFE_METHODS.contains(method) || IDEMPOTENT_METHODS.contains(method);\n+    }\n+\n+    public void handle(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        String method = request.getMethod();\n+        log.debug(\"Method: \" + method);\n+        if (shouldIgnore(method)) {\n+            log.debug(\"Request ignored\");\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        String key = request.getHeader(IdempotentRequestHandler.HEADER_KEY);\n+        if (key == null) {\n+            log.debug(\"No idempotent request key\");", "originalCommit": "38bd3fe74aa5a433ab06987e66ed875bd4ef1d8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MjYyMw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r547242623", "bodyText": "KeyValueService not present", "author": "efge", "createdAt": "2020-12-22T12:10:43Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    /** @since 11.5 */\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.controller.keyvaluestore.name\";\n+\n+    protected static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    /** 1 day */\n+    protected static final int DEFAULT_TTL_SECONDS = 86400;\n+\n+    /** @since 11.5 */\n+    public static final String TTL_SECONDS_PROPERTY = \"org.nuxeo.request.controller.ttl.seconds\";\n+\n+    /** @since 11.5 */\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    /** @since 11.5 */\n+    public static final String STATUS_SUFFIX = \"_status\";\n+\n+    // safe methods according to RFC 7231 4.2.1\n+    protected static final Set<String> SAFE_METHODS = new HashSet<>(\n+            Arrays.asList(HttpGet.METHOD_NAME, HttpHead.METHOD_NAME, HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME));\n+\n+    // idempotent methods according to RFC 7231 4.2.2\n+    protected static final Set<String> IDEMPOTENT_METHODS = new HashSet<>(\n+            Arrays.asList(HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME));\n+\n+    protected int getTTLSeconds() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getInteger(TTL_SECONDS_PROPERTY, DEFAULT_TTL_SECONDS);\n+        }\n+        return DEFAULT_TTL_SECONDS;\n+    }\n+\n+    protected String getStoreName() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getString(STORE_PROPERTY, DEFAULT_STORE);\n+        }\n+        return DEFAULT_STORE;\n+    }\n+\n+    protected boolean shouldIgnore(String method) {\n+        return SAFE_METHODS.contains(method) || IDEMPOTENT_METHODS.contains(method);\n+    }\n+\n+    public void handle(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        String method = request.getMethod();\n+        log.debug(\"Method: \" + method);\n+        if (shouldIgnore(method)) {\n+            log.debug(\"Request ignored\");\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        String key = request.getHeader(IdempotentRequestHandler.HEADER_KEY);\n+        if (key == null) {\n+            log.debug(\"No idempotent request key\");\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        log.debug(\"Idempotent request key: \" + key);\n+        KeyValueService kvs = Framework.getService(KeyValueService.class);\n+        if (kvs == null) {\n+            log.debug(\"KeyValueStore not present\");", "originalCommit": "38bd3fe74aa5a433ab06987e66ed875bd4ef1d8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MjkxMg==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r547242912", "bodyText": "Check store is not null otherwise log and skip idempotent processing.", "author": "efge", "createdAt": "2020-12-22T12:11:31Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    /** @since 11.5 */\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.controller.keyvaluestore.name\";\n+\n+    protected static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    /** 1 day */\n+    protected static final int DEFAULT_TTL_SECONDS = 86400;\n+\n+    /** @since 11.5 */\n+    public static final String TTL_SECONDS_PROPERTY = \"org.nuxeo.request.controller.ttl.seconds\";\n+\n+    /** @since 11.5 */\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    /** @since 11.5 */\n+    public static final String STATUS_SUFFIX = \"_status\";\n+\n+    // safe methods according to RFC 7231 4.2.1\n+    protected static final Set<String> SAFE_METHODS = new HashSet<>(\n+            Arrays.asList(HttpGet.METHOD_NAME, HttpHead.METHOD_NAME, HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME));\n+\n+    // idempotent methods according to RFC 7231 4.2.2\n+    protected static final Set<String> IDEMPOTENT_METHODS = new HashSet<>(\n+            Arrays.asList(HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME));\n+\n+    protected int getTTLSeconds() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getInteger(TTL_SECONDS_PROPERTY, DEFAULT_TTL_SECONDS);\n+        }\n+        return DEFAULT_TTL_SECONDS;\n+    }\n+\n+    protected String getStoreName() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getString(STORE_PROPERTY, DEFAULT_STORE);\n+        }\n+        return DEFAULT_STORE;\n+    }\n+\n+    protected boolean shouldIgnore(String method) {\n+        return SAFE_METHODS.contains(method) || IDEMPOTENT_METHODS.contains(method);\n+    }\n+\n+    public void handle(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        String method = request.getMethod();\n+        log.debug(\"Method: \" + method);\n+        if (shouldIgnore(method)) {\n+            log.debug(\"Request ignored\");\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        String key = request.getHeader(IdempotentRequestHandler.HEADER_KEY);\n+        if (key == null) {\n+            log.debug(\"No idempotent request key\");\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        log.debug(\"Idempotent request key: \" + key);\n+        KeyValueService kvs = Framework.getService(KeyValueService.class);\n+        if (kvs == null) {\n+            log.debug(\"KeyValueStore not present\");\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        KeyValueStore store = kvs.getKeyValueStore(getStoreName());", "originalCommit": "38bd3fe74aa5a433ab06987e66ed875bd4ef1d8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1MDgzOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r547250839", "bodyText": "Alright but that's actually something i found quite strange in the KeyValueService implementation: even when the store with given name is not present, a store is instantiated from the default definition (and an exception is thrown if there is no default definition).", "author": "atchertchian", "createdAt": "2020-12-22T12:30:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MjkxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1MzA3Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r547253076", "bodyText": "Ah I see. Yes in that case no need for a check you're right.\nThis behavior is done to avoid explicit definitions of lots of stores in XML.", "author": "efge", "createdAt": "2020-12-22T12:35:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MjkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NDE3Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r547244177", "bodyText": "You have many if (...) { chain.doFilter(request, response); return; } so maybe let the caller do the chain call if this method returns a boolean false.", "author": "efge", "createdAt": "2020-12-22T12:14:44Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/IdempotentRequestHandler.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.requestcontroller.filter;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Handles idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class IdempotentRequestHandler {\n+\n+    private static final Logger log = LogManager.getLogger(IdempotentRequestHandler.class);\n+\n+    /** @since 11.5 */\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    /** @since 11.5 */\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.controller.keyvaluestore.name\";\n+\n+    protected static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    /** 1 day */\n+    protected static final int DEFAULT_TTL_SECONDS = 86400;\n+\n+    /** @since 11.5 */\n+    public static final String TTL_SECONDS_PROPERTY = \"org.nuxeo.request.controller.ttl.seconds\";\n+\n+    /** @since 11.5 */\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    /** @since 11.5 */\n+    public static final String STATUS_SUFFIX = \"_status\";\n+\n+    // safe methods according to RFC 7231 4.2.1\n+    protected static final Set<String> SAFE_METHODS = new HashSet<>(\n+            Arrays.asList(HttpGet.METHOD_NAME, HttpHead.METHOD_NAME, HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME));\n+\n+    // idempotent methods according to RFC 7231 4.2.2\n+    protected static final Set<String> IDEMPOTENT_METHODS = new HashSet<>(\n+            Arrays.asList(HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME));\n+\n+    protected int getTTLSeconds() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getInteger(TTL_SECONDS_PROPERTY, DEFAULT_TTL_SECONDS);\n+        }\n+        return DEFAULT_TTL_SECONDS;\n+    }\n+\n+    protected String getStoreName() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getString(STORE_PROPERTY, DEFAULT_STORE);\n+        }\n+        return DEFAULT_STORE;\n+    }\n+\n+    protected boolean shouldIgnore(String method) {\n+        return SAFE_METHODS.contains(method) || IDEMPOTENT_METHODS.contains(method);\n+    }\n+\n+    public void handle(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        String method = request.getMethod();\n+        log.debug(\"Method: \" + method);\n+        if (shouldIgnore(method)) {\n+            log.debug(\"Request ignored\");\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        String key = request.getHeader(IdempotentRequestHandler.HEADER_KEY);\n+        if (key == null) {\n+            log.debug(\"No idempotent request key\");\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        log.debug(\"Idempotent request key: \" + key);\n+        KeyValueService kvs = Framework.getService(KeyValueService.class);\n+        if (kvs == null) {\n+            log.debug(\"KeyValueStore not present\");\n+            chain.doFilter(request, response);", "originalCommit": "38bd3fe74aa5a433ab06987e66ed875bd4ef1d8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA3Mjg5OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548072899", "bodyText": "I did not change this, but since in the end there is a dedicated filter maybe it's alright as is?", "author": "atchertchian", "createdAt": "2020-12-23T17:31:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NDE3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NDU2Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r547244567", "bodyText": "handler -> idempotentRequestHandler", "author": "efge", "createdAt": "2020-12-22T12:15:40Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/requestcontroller/filter/NuxeoRequestControllerFilter.java", "diffHunk": "@@ -70,13 +70,15 @@\n \n     protected static final int LOCK_TIMEOUT_S = 120;\n \n+    protected IdempotentRequestHandler handler;", "originalCommit": "38bd3fe74aa5a433ab06987e66ed875bd4ef1d8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA3MzA5Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548073097", "bodyText": "As discussed, moved this handler to a dedicated filter class.", "author": "atchertchian", "createdAt": "2020-12-23T17:31:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NDU2Nw=="}], "type": "inlineReview"}, {"oid": "6862e80459534c763a5c14930e00290b00fc7482", "url": "https://github.com/nuxeo/nuxeo/commit/6862e80459534c763a5c14930e00290b00fc7482", "message": "NXP-29978: add idempotent request filter", "committedDate": "2020-12-23T17:25:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA3OTc3MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548079771", "bodyText": "You must also override the other write(byte b[]) and write(byte b[], int off, int len) methods from the base OutputStream otherwise performance will be horrible.", "author": "efge", "createdAt": "2020-12-23T17:40:09Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/CopyingServletOutputStream.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.WriteListener;\n+\n+import org.apache.commons.io.output.DeferredFileOutputStream;\n+\n+/**\n+ * Captures content written to the target stream.\n+ *\n+ * @since 11.5\n+ */\n+public class CopyingServletOutputStream extends ServletOutputStream {\n+\n+    protected final ServletOutputStream output;\n+\n+    protected final DeferredFileOutputStream capture;\n+\n+    public CopyingServletOutputStream(ServletOutputStream output, DeferredFileOutputStream capture) {\n+        this.output = output;\n+        this.capture = capture;\n+    }\n+\n+    @Override\n+    public void write(int b) throws IOException {", "originalCommit": "6862e80459534c763a5c14930e00290b00fc7482", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA5MTcyNw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548091727", "bodyText": "Maybe put new CopyingServletOutputStream(getResponse().getOutputStream(), capture) in a helper method as it's used twice.", "author": "efge", "createdAt": "2020-12-23T17:55:03Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/CopyingResponseWrapper.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpServletResponseWrapper;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.output.DeferredFileOutputStream;\n+\n+/**\n+ * Response wrapper that can capture response result, using a {@link DeferredFileOutputStream}.\n+ *\n+ * @since 11.5\n+ */\n+public class CopyingResponseWrapper extends HttpServletResponseWrapper {\n+\n+    private final DeferredFileOutputStream capture;\n+\n+    private ServletOutputStream output;\n+\n+    private PrintWriter writer;\n+\n+    public CopyingResponseWrapper(int threshold, HttpServletResponse response) {\n+        super(response);\n+        capture = new DeferredFileOutputStream(threshold, response.getBufferSize(), \"nxidem\", null, null);\n+    }\n+\n+    @Override\n+    public ServletOutputStream getOutputStream() throws IOException {\n+        if (writer != null) {\n+            throw new IllegalStateException(\"getWriter() has already been called on this response.\");\n+        }\n+\n+        if (output == null) {\n+            output = new CopyingServletOutputStream(getResponse().getOutputStream(), capture);", "originalCommit": "6862e80459534c763a5c14930e00290b00fc7482", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA5Mzk5NA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548093994", "bodyText": "It shouldn't be this method's responsibility to do the underlying close() as you can't guarantee it's going to be called in case of exceptions.\nYou should do a capture.flush() before reading the file.\nAlso you need to deal with tmp file deletion, maybe make CopyingResponseWrapper implement AutoCloseable and do the cleanup (underlying close + tmp file delete) in the close method. Then the filter can use a try-with-resources to make sure it's always closed.", "author": "efge", "createdAt": "2020-12-23T17:57:46Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/CopyingResponseWrapper.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpServletResponseWrapper;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.output.DeferredFileOutputStream;\n+\n+/**\n+ * Response wrapper that can capture response result, using a {@link DeferredFileOutputStream}.\n+ *\n+ * @since 11.5\n+ */\n+public class CopyingResponseWrapper extends HttpServletResponseWrapper {\n+\n+    private final DeferredFileOutputStream capture;\n+\n+    private ServletOutputStream output;\n+\n+    private PrintWriter writer;\n+\n+    public CopyingResponseWrapper(int threshold, HttpServletResponse response) {\n+        super(response);\n+        capture = new DeferredFileOutputStream(threshold, response.getBufferSize(), \"nxidem\", null, null);\n+    }\n+\n+    @Override\n+    public ServletOutputStream getOutputStream() throws IOException {\n+        if (writer != null) {\n+            throw new IllegalStateException(\"getWriter() has already been called on this response.\");\n+        }\n+\n+        if (output == null) {\n+            output = new CopyingServletOutputStream(getResponse().getOutputStream(), capture);\n+        }\n+\n+        return output;\n+    }\n+\n+    @Override\n+    public PrintWriter getWriter() throws IOException {\n+        if (output != null) {\n+            throw new IllegalStateException(\"getOutputStream() has already been called on this response.\");\n+        }\n+\n+        if (writer == null) {\n+            writer = new PrintWriter(new OutputStreamWriter(\n+                    new CopyingServletOutputStream(getResponse().getOutputStream(), capture), getCharacterEncoding()));\n+        }\n+\n+        return writer;\n+    }\n+\n+    @Override\n+    public void flushBuffer() throws IOException {\n+        super.flushBuffer();\n+\n+        if (writer != null) {\n+            writer.flush();\n+        } else if (output != null) {\n+            output.flush();\n+        }\n+    }\n+\n+    public byte[] getCaptureAsBytes() throws IOException {\n+        if (writer != null) {\n+            writer.close();\n+        } else if (output != null) {\n+            output.close();\n+        }\n+\n+        if (capture.isInMemory()) {\n+            return capture.getData();\n+        } else {\n+            return FileUtils.readFileToByteArray(capture.getFile());", "originalCommit": "6862e80459534c763a5c14930e00290b00fc7482", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzNTc4MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r551235781", "bodyText": "added a call to wrapper#flushBuffer before calling wrapper#getCaptureAsBytes, still kept a call to capture#flush before calling capture#getFile, please tell if that's what it expected here.", "author": "atchertchian", "createdAt": "2021-01-04T10:34:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA5Mzk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODEwMDIxMg==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548100212", "bodyText": "Probably better to use getDuration here, it's more flexible for users. And rename the property to not have \"seconds\" in the name or value. Then DEFAULT_TTL_SECONDS can be just a duration too, and you only convert to seconds at the last moment: long ttl = getTTLSeconds() -> long ttl = getTTL().toSeconds().", "author": "efge", "createdAt": "2020-12-23T18:05:44Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentFilter.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Set;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Filter handling an idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentFilter implements Filter {\n+\n+    private static final Logger log = LogManager.getLogger(NuxeoIdempotentFilter.class);\n+\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.idempotency.keyvaluestore.name\";\n+\n+    public static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    protected static final long DEFAULT_TTL_SECONDS = Duration.ofDays(1).toSeconds();\n+\n+    public static final String TTL_SECONDS_PROPERTY = \"org.nuxeo.request.idempotency.ttl.seconds\";\n+\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    public static final String INFO_SUFFIX = \"_info\";\n+\n+    protected static final int DEFERRED_OUTPUT_STREAM_THRESHOLD = 1024 * 1024; // 1 MB\n+\n+    // safe methods according to RFC 7231 4.2.1\n+    protected static final Set<String> SAFE_METHODS = Set.of(HttpGet.METHOD_NAME, HttpHead.METHOD_NAME,\n+            HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME);\n+\n+    // idempotent methods according to RFC 7231 4.2.2\n+    protected static final Set<String> IDEMPOTENT_METHODS = Set.of(HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME);\n+\n+    protected long getTTLSeconds() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getLong(TTL_SECONDS_PROPERTY, DEFAULT_TTL_SECONDS);", "originalCommit": "6862e80459534c763a5c14930e00290b00fc7482", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODEwMTE0OA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548101148", "bodyText": "You could have a single set with everything in it.", "author": "efge", "createdAt": "2020-12-23T18:06:48Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentFilter.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Set;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Filter handling an idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentFilter implements Filter {\n+\n+    private static final Logger log = LogManager.getLogger(NuxeoIdempotentFilter.class);\n+\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.idempotency.keyvaluestore.name\";\n+\n+    public static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    protected static final long DEFAULT_TTL_SECONDS = Duration.ofDays(1).toSeconds();\n+\n+    public static final String TTL_SECONDS_PROPERTY = \"org.nuxeo.request.idempotency.ttl.seconds\";\n+\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    public static final String INFO_SUFFIX = \"_info\";\n+\n+    protected static final int DEFERRED_OUTPUT_STREAM_THRESHOLD = 1024 * 1024; // 1 MB\n+\n+    // safe methods according to RFC 7231 4.2.1\n+    protected static final Set<String> SAFE_METHODS = Set.of(HttpGet.METHOD_NAME, HttpHead.METHOD_NAME,\n+            HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME);\n+\n+    // idempotent methods according to RFC 7231 4.2.2\n+    protected static final Set<String> IDEMPOTENT_METHODS = Set.of(HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME);\n+\n+    protected long getTTLSeconds() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getLong(TTL_SECONDS_PROPERTY, DEFAULT_TTL_SECONDS);\n+        }\n+        return DEFAULT_TTL_SECONDS;\n+    }\n+\n+    protected String getStoreName() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getString(STORE_PROPERTY, DEFAULT_STORE);\n+        }\n+        return DEFAULT_STORE;\n+    }\n+\n+    protected boolean isIdempotentMethod(String method) {\n+        return SAFE_METHODS.contains(method) || IDEMPOTENT_METHODS.contains(method);", "originalCommit": "6862e80459534c763a5c14930e00290b00fc7482", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODEwMTg0MA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548101840", "bodyText": "With log4j2 you should use {} in the log message, not string concatenation.", "author": "efge", "createdAt": "2020-12-23T18:07:34Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentFilter.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Set;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Filter handling an idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentFilter implements Filter {\n+\n+    private static final Logger log = LogManager.getLogger(NuxeoIdempotentFilter.class);\n+\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.idempotency.keyvaluestore.name\";\n+\n+    public static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    protected static final long DEFAULT_TTL_SECONDS = Duration.ofDays(1).toSeconds();\n+\n+    public static final String TTL_SECONDS_PROPERTY = \"org.nuxeo.request.idempotency.ttl.seconds\";\n+\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    public static final String INFO_SUFFIX = \"_info\";\n+\n+    protected static final int DEFERRED_OUTPUT_STREAM_THRESHOLD = 1024 * 1024; // 1 MB\n+\n+    // safe methods according to RFC 7231 4.2.1\n+    protected static final Set<String> SAFE_METHODS = Set.of(HttpGet.METHOD_NAME, HttpHead.METHOD_NAME,\n+            HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME);\n+\n+    // idempotent methods according to RFC 7231 4.2.2\n+    protected static final Set<String> IDEMPOTENT_METHODS = Set.of(HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME);\n+\n+    protected long getTTLSeconds() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getLong(TTL_SECONDS_PROPERTY, DEFAULT_TTL_SECONDS);\n+        }\n+        return DEFAULT_TTL_SECONDS;\n+    }\n+\n+    protected String getStoreName() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getString(STORE_PROPERTY, DEFAULT_STORE);\n+        }\n+        return DEFAULT_STORE;\n+    }\n+\n+    protected boolean isIdempotentMethod(String method) {\n+        return SAFE_METHODS.contains(method) || IDEMPOTENT_METHODS.contains(method);\n+    }\n+\n+    @Override\n+    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)\n+            throws IOException, ServletException {\n+        HttpServletRequest request = (HttpServletRequest) servletRequest;\n+        HttpServletResponse response = (HttpServletResponse) servletResponse;\n+        String method = request.getMethod();\n+        if (isIdempotentMethod(method)) {\n+            log.debug(\"No idempotent processing done: method is already idempotent: \" + method);", "originalCommit": "6862e80459534c763a5c14930e00290b00fc7482", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODEwMzU0NA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548103544", "bodyText": "No need for NuxeoIdempotentFilter. in front of all your local constants.", "author": "efge", "createdAt": "2020-12-23T18:09:41Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentFilter.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Set;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Filter handling an idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentFilter implements Filter {\n+\n+    private static final Logger log = LogManager.getLogger(NuxeoIdempotentFilter.class);\n+\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.idempotency.keyvaluestore.name\";\n+\n+    public static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    protected static final long DEFAULT_TTL_SECONDS = Duration.ofDays(1).toSeconds();\n+\n+    public static final String TTL_SECONDS_PROPERTY = \"org.nuxeo.request.idempotency.ttl.seconds\";\n+\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    public static final String INFO_SUFFIX = \"_info\";\n+\n+    protected static final int DEFERRED_OUTPUT_STREAM_THRESHOLD = 1024 * 1024; // 1 MB\n+\n+    // safe methods according to RFC 7231 4.2.1\n+    protected static final Set<String> SAFE_METHODS = Set.of(HttpGet.METHOD_NAME, HttpHead.METHOD_NAME,\n+            HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME);\n+\n+    // idempotent methods according to RFC 7231 4.2.2\n+    protected static final Set<String> IDEMPOTENT_METHODS = Set.of(HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME);\n+\n+    protected long getTTLSeconds() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getLong(TTL_SECONDS_PROPERTY, DEFAULT_TTL_SECONDS);\n+        }\n+        return DEFAULT_TTL_SECONDS;\n+    }\n+\n+    protected String getStoreName() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getString(STORE_PROPERTY, DEFAULT_STORE);\n+        }\n+        return DEFAULT_STORE;\n+    }\n+\n+    protected boolean isIdempotentMethod(String method) {\n+        return SAFE_METHODS.contains(method) || IDEMPOTENT_METHODS.contains(method);\n+    }\n+\n+    @Override\n+    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)\n+            throws IOException, ServletException {\n+        HttpServletRequest request = (HttpServletRequest) servletRequest;\n+        HttpServletResponse response = (HttpServletResponse) servletResponse;\n+        String method = request.getMethod();\n+        if (isIdempotentMethod(method)) {\n+            log.debug(\"No idempotent processing done: method is already idempotent: \" + method);\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        String key = request.getHeader(NuxeoIdempotentFilter.HEADER_KEY);", "originalCommit": "6862e80459534c763a5c14930e00290b00fc7482", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODEwMzg0NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548103845", "bodyText": "Please do static imports of HttpServletResponse.SC_* constants", "author": "efge", "createdAt": "2020-12-23T18:09:59Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentFilter.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Set;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Filter handling an idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentFilter implements Filter {\n+\n+    private static final Logger log = LogManager.getLogger(NuxeoIdempotentFilter.class);\n+\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.idempotency.keyvaluestore.name\";\n+\n+    public static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    protected static final long DEFAULT_TTL_SECONDS = Duration.ofDays(1).toSeconds();\n+\n+    public static final String TTL_SECONDS_PROPERTY = \"org.nuxeo.request.idempotency.ttl.seconds\";\n+\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    public static final String INFO_SUFFIX = \"_info\";\n+\n+    protected static final int DEFERRED_OUTPUT_STREAM_THRESHOLD = 1024 * 1024; // 1 MB\n+\n+    // safe methods according to RFC 7231 4.2.1\n+    protected static final Set<String> SAFE_METHODS = Set.of(HttpGet.METHOD_NAME, HttpHead.METHOD_NAME,\n+            HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME);\n+\n+    // idempotent methods according to RFC 7231 4.2.2\n+    protected static final Set<String> IDEMPOTENT_METHODS = Set.of(HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME);\n+\n+    protected long getTTLSeconds() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getLong(TTL_SECONDS_PROPERTY, DEFAULT_TTL_SECONDS);\n+        }\n+        return DEFAULT_TTL_SECONDS;\n+    }\n+\n+    protected String getStoreName() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getString(STORE_PROPERTY, DEFAULT_STORE);\n+        }\n+        return DEFAULT_STORE;\n+    }\n+\n+    protected boolean isIdempotentMethod(String method) {\n+        return SAFE_METHODS.contains(method) || IDEMPOTENT_METHODS.contains(method);\n+    }\n+\n+    @Override\n+    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)\n+            throws IOException, ServletException {\n+        HttpServletRequest request = (HttpServletRequest) servletRequest;\n+        HttpServletResponse response = (HttpServletResponse) servletResponse;\n+        String method = request.getMethod();\n+        if (isIdempotentMethod(method)) {\n+            log.debug(\"No idempotent processing done: method is already idempotent: \" + method);\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        String key = request.getHeader(NuxeoIdempotentFilter.HEADER_KEY);\n+        if (key == null) {\n+            log.debug(\"No idempotent processing done: no Idempotent-Key present\");\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        log.debug(\"Idempotent request key: \" + key);\n+        KeyValueService kvs = Framework.getService(KeyValueService.class);\n+        if (kvs == null) {\n+            log.debug(\"KeyValueService not present\");\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        KeyValueStore store = kvs.getKeyValueStore(getStoreName());\n+        String status = store.getString(key + NuxeoIdempotentFilter.INFO_SUFFIX);\n+        if (status == null) {\n+            log.debug(\"Handle new request for key: \" + key);\n+            long ttl = getTTLSeconds();\n+            store.put(key + NuxeoIdempotentFilter.INFO_SUFFIX, NuxeoIdempotentFilter.INPROGRESS_MARKER, ttl);\n+            try {\n+                CopyingResponseWrapper wrapper = new CopyingResponseWrapper(DEFERRED_OUTPUT_STREAM_THRESHOLD, response);\n+                chain.doFilter(request, wrapper);\n+                store.put(key, wrapper.getCaptureAsBytes(), ttl);\n+                store.put(key + NuxeoIdempotentFilter.INFO_SUFFIX, NuxeoIdempotentResponse.write(wrapper), ttl);\n+                log.debug(\"Stored response for key: \" + key);\n+            } catch (IOException | ServletException e) {\n+                response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);", "originalCommit": "6862e80459534c763a5c14930e00290b00fc7482", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODExMDQ4Mw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548110483", "bodyText": "You should put the mapper in a static final field instead of constructing it every time.", "author": "efge", "createdAt": "2020-12-23T18:18:27Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentResponse.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+\n+/**\n+ * POJO representing response to be serialized and served by {@link NuxeoIdempotentFilter}.\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentResponse {\n+\n+    protected int status;\n+\n+    protected Map<String, Collection<String>> headers = new LinkedHashMap<>();\n+\n+    public int getStatus() {\n+        return status;\n+    }\n+\n+    public void setStatus(int status) {\n+        this.status = status;\n+    }\n+\n+    public Map<String, Collection<String>> getHeaders() {\n+        return headers;\n+    }\n+\n+    public void setHeader(String name, Collection<String> value) {\n+        headers.put(name, value);\n+    }\n+\n+    protected static final ObjectMapper getMapper() {", "originalCommit": "6862e80459534c763a5c14930e00290b00fc7482", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODExMzAzOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548113039", "bodyText": "I think stored.getHeaders().forEach(response::addHeader) will work as well.", "author": "efge", "createdAt": "2020-12-23T18:22:20Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentResponse.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+\n+/**\n+ * POJO representing response to be serialized and served by {@link NuxeoIdempotentFilter}.\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentResponse {\n+\n+    protected int status;\n+\n+    protected Map<String, Collection<String>> headers = new LinkedHashMap<>();\n+\n+    public int getStatus() {\n+        return status;\n+    }\n+\n+    public void setStatus(int status) {\n+        this.status = status;\n+    }\n+\n+    public Map<String, Collection<String>> getHeaders() {\n+        return headers;\n+    }\n+\n+    public void setHeader(String name, Collection<String> value) {\n+        headers.put(name, value);\n+    }\n+\n+    protected static final ObjectMapper getMapper() {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        mapper.configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, true)\n+              .configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS, true);\n+        return mapper;\n+    }\n+\n+    public static final void restore(HttpServletResponse response, byte[] bytes) throws IOException {\n+        NuxeoIdempotentResponse stored = getMapper().readerFor(NuxeoIdempotentResponse.class)\n+                                                    .withoutRootName()\n+                                                    .without(JsonParser.Feature.AUTO_CLOSE_SOURCE)\n+                                                    .readValue(bytes);\n+        response.setStatus(stored.getStatus());\n+        stored.getHeaders().forEach((name, values) -> {\n+            boolean isFirst = true;\n+            for (String value : values) {\n+                if (isFirst) {\n+                    response.setHeader(name, value);\n+                } else {\n+                    response.addHeader(name, value);\n+                    isFirst = false;\n+                }\n+            }\n+        });", "originalCommit": "6862e80459534c763a5c14930e00290b00fc7482", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTE5MjI0MA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r551192240", "bodyText": "response does not have a addHeader(String, Collection) api, but i can remove the \"isFirst\" and setHeader call (making sure header value is \"reset\") if unnecessary", "author": "atchertchian", "createdAt": "2021-01-04T09:10:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODExMzAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODExNTc3OA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548115778", "bodyText": "You should do this first, and if there's an IOException (due to errors parsing the JSON) log it but abandon everything and process normally the chain.", "author": "efge", "createdAt": "2020-12-23T18:25:27Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentFilter.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Set;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Filter handling an idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentFilter implements Filter {\n+\n+    private static final Logger log = LogManager.getLogger(NuxeoIdempotentFilter.class);\n+\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.idempotency.keyvaluestore.name\";\n+\n+    public static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    protected static final long DEFAULT_TTL_SECONDS = Duration.ofDays(1).toSeconds();\n+\n+    public static final String TTL_SECONDS_PROPERTY = \"org.nuxeo.request.idempotency.ttl.seconds\";\n+\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    public static final String INFO_SUFFIX = \"_info\";\n+\n+    protected static final int DEFERRED_OUTPUT_STREAM_THRESHOLD = 1024 * 1024; // 1 MB\n+\n+    // safe methods according to RFC 7231 4.2.1\n+    protected static final Set<String> SAFE_METHODS = Set.of(HttpGet.METHOD_NAME, HttpHead.METHOD_NAME,\n+            HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME);\n+\n+    // idempotent methods according to RFC 7231 4.2.2\n+    protected static final Set<String> IDEMPOTENT_METHODS = Set.of(HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME);\n+\n+    protected long getTTLSeconds() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getLong(TTL_SECONDS_PROPERTY, DEFAULT_TTL_SECONDS);\n+        }\n+        return DEFAULT_TTL_SECONDS;\n+    }\n+\n+    protected String getStoreName() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getString(STORE_PROPERTY, DEFAULT_STORE);\n+        }\n+        return DEFAULT_STORE;\n+    }\n+\n+    protected boolean isIdempotentMethod(String method) {\n+        return SAFE_METHODS.contains(method) || IDEMPOTENT_METHODS.contains(method);\n+    }\n+\n+    @Override\n+    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)\n+            throws IOException, ServletException {\n+        HttpServletRequest request = (HttpServletRequest) servletRequest;\n+        HttpServletResponse response = (HttpServletResponse) servletResponse;\n+        String method = request.getMethod();\n+        if (isIdempotentMethod(method)) {\n+            log.debug(\"No idempotent processing done: method is already idempotent: \" + method);\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        String key = request.getHeader(NuxeoIdempotentFilter.HEADER_KEY);\n+        if (key == null) {\n+            log.debug(\"No idempotent processing done: no Idempotent-Key present\");\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        log.debug(\"Idempotent request key: \" + key);\n+        KeyValueService kvs = Framework.getService(KeyValueService.class);\n+        if (kvs == null) {\n+            log.debug(\"KeyValueService not present\");\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        KeyValueStore store = kvs.getKeyValueStore(getStoreName());\n+        String status = store.getString(key + NuxeoIdempotentFilter.INFO_SUFFIX);\n+        if (status == null) {\n+            log.debug(\"Handle new request for key: \" + key);\n+            long ttl = getTTLSeconds();\n+            store.put(key + NuxeoIdempotentFilter.INFO_SUFFIX, NuxeoIdempotentFilter.INPROGRESS_MARKER, ttl);\n+            try {\n+                CopyingResponseWrapper wrapper = new CopyingResponseWrapper(DEFERRED_OUTPUT_STREAM_THRESHOLD, response);\n+                chain.doFilter(request, wrapper);\n+                store.put(key, wrapper.getCaptureAsBytes(), ttl);\n+                store.put(key + NuxeoIdempotentFilter.INFO_SUFFIX, NuxeoIdempotentResponse.write(wrapper), ttl);\n+                log.debug(\"Stored response for key: \" + key);\n+            } catch (IOException | ServletException e) {\n+                response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n+                throw e;\n+            } finally {\n+                if (response.getStatus() >= HttpServletResponse.SC_BAD_REQUEST) {\n+                    // error request: cleanup store\n+                    store.put(key, (String) null);\n+                    store.put(key + NuxeoIdempotentFilter.INFO_SUFFIX, (String) null);\n+                    log.debug(\"Cleanup store: error for key: \" + key);\n+                }\n+            }\n+        } else if (NuxeoIdempotentFilter.INPROGRESS_MARKER.equals(status)) {\n+            // request already in progress -> conflict\n+            // Don't call response.sendError, because it commits the response\n+            // which prevents NuxeoExceptionFilter from returning a custom error page.\n+            response.setStatus(HttpServletResponse.SC_CONFLICT);\n+            log.debug(\"Conflict response for key: \" + key);\n+        } else {\n+            // request already done: return stored result\n+            response.getOutputStream().write(store.get(key));\n+            NuxeoIdempotentResponse.restore(response, store.get(key + NuxeoIdempotentFilter.INFO_SUFFIX));", "originalCommit": "6862e80459534c763a5c14930e00290b00fc7482", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODExODE4MA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548118180", "bodyText": "I'd prefer all the repeated chain.doFilter(request, response) in a caller method. So rename the current method to doFilterIdempotent and then have:\n@Override \npublic void doFilter(...) throws ... {\n    if (!doFilterIdempotent()) {\n        chain.doFilter(request, response);\n    }\n}\n\nAnd return false from doFilterIdempotent whenever you haven't done any processing.", "author": "efge", "createdAt": "2020-12-23T18:28:29Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentFilter.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Set;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Filter handling an idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentFilter implements Filter {\n+\n+    private static final Logger log = LogManager.getLogger(NuxeoIdempotentFilter.class);\n+\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.idempotency.keyvaluestore.name\";\n+\n+    public static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    protected static final long DEFAULT_TTL_SECONDS = Duration.ofDays(1).toSeconds();\n+\n+    public static final String TTL_SECONDS_PROPERTY = \"org.nuxeo.request.idempotency.ttl.seconds\";\n+\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    public static final String INFO_SUFFIX = \"_info\";\n+\n+    protected static final int DEFERRED_OUTPUT_STREAM_THRESHOLD = 1024 * 1024; // 1 MB\n+\n+    // safe methods according to RFC 7231 4.2.1\n+    protected static final Set<String> SAFE_METHODS = Set.of(HttpGet.METHOD_NAME, HttpHead.METHOD_NAME,\n+            HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME);\n+\n+    // idempotent methods according to RFC 7231 4.2.2\n+    protected static final Set<String> IDEMPOTENT_METHODS = Set.of(HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME);\n+\n+    protected long getTTLSeconds() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getLong(TTL_SECONDS_PROPERTY, DEFAULT_TTL_SECONDS);\n+        }\n+        return DEFAULT_TTL_SECONDS;\n+    }\n+\n+    protected String getStoreName() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getString(STORE_PROPERTY, DEFAULT_STORE);\n+        }\n+        return DEFAULT_STORE;\n+    }\n+\n+    protected boolean isIdempotentMethod(String method) {\n+        return SAFE_METHODS.contains(method) || IDEMPOTENT_METHODS.contains(method);\n+    }\n+\n+    @Override\n+    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)\n+            throws IOException, ServletException {\n+        HttpServletRequest request = (HttpServletRequest) servletRequest;\n+        HttpServletResponse response = (HttpServletResponse) servletResponse;\n+        String method = request.getMethod();\n+        if (isIdempotentMethod(method)) {\n+            log.debug(\"No idempotent processing done: method is already idempotent: \" + method);\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        String key = request.getHeader(NuxeoIdempotentFilter.HEADER_KEY);\n+        if (key == null) {\n+            log.debug(\"No idempotent processing done: no Idempotent-Key present\");\n+            chain.doFilter(request, response);", "originalCommit": "6862e80459534c763a5c14930e00290b00fc7482", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODEyMDU4Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548120586", "bodyText": "Extend HttpFilter instead, which gives you doFilter methods overrides with parameters already converted to HttpServletRequest/HttpServletResponse.", "author": "efge", "createdAt": "2020-12-23T18:31:30Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentFilter.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Set;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Filter handling an idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentFilter implements Filter {", "originalCommit": "6862e80459534c763a5c14930e00290b00fc7482", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODEyMzc5MA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548123790", "bodyText": "We should have a protection here against captures that are too big, as the k/v store is not designed to store arbitrarily big payloads.", "author": "efge", "createdAt": "2020-12-23T18:35:27Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentFilter.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Set;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Filter handling an idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentFilter implements Filter {\n+\n+    private static final Logger log = LogManager.getLogger(NuxeoIdempotentFilter.class);\n+\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.idempotency.keyvaluestore.name\";\n+\n+    public static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    protected static final long DEFAULT_TTL_SECONDS = Duration.ofDays(1).toSeconds();\n+\n+    public static final String TTL_SECONDS_PROPERTY = \"org.nuxeo.request.idempotency.ttl.seconds\";\n+\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    public static final String INFO_SUFFIX = \"_info\";\n+\n+    protected static final int DEFERRED_OUTPUT_STREAM_THRESHOLD = 1024 * 1024; // 1 MB\n+\n+    // safe methods according to RFC 7231 4.2.1\n+    protected static final Set<String> SAFE_METHODS = Set.of(HttpGet.METHOD_NAME, HttpHead.METHOD_NAME,\n+            HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME);\n+\n+    // idempotent methods according to RFC 7231 4.2.2\n+    protected static final Set<String> IDEMPOTENT_METHODS = Set.of(HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME);\n+\n+    protected long getTTLSeconds() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getLong(TTL_SECONDS_PROPERTY, DEFAULT_TTL_SECONDS);\n+        }\n+        return DEFAULT_TTL_SECONDS;\n+    }\n+\n+    protected String getStoreName() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getString(STORE_PROPERTY, DEFAULT_STORE);\n+        }\n+        return DEFAULT_STORE;\n+    }\n+\n+    protected boolean isIdempotentMethod(String method) {\n+        return SAFE_METHODS.contains(method) || IDEMPOTENT_METHODS.contains(method);\n+    }\n+\n+    @Override\n+    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)\n+            throws IOException, ServletException {\n+        HttpServletRequest request = (HttpServletRequest) servletRequest;\n+        HttpServletResponse response = (HttpServletResponse) servletResponse;\n+        String method = request.getMethod();\n+        if (isIdempotentMethod(method)) {\n+            log.debug(\"No idempotent processing done: method is already idempotent: \" + method);\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        String key = request.getHeader(NuxeoIdempotentFilter.HEADER_KEY);\n+        if (key == null) {\n+            log.debug(\"No idempotent processing done: no Idempotent-Key present\");\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        log.debug(\"Idempotent request key: \" + key);\n+        KeyValueService kvs = Framework.getService(KeyValueService.class);\n+        if (kvs == null) {\n+            log.debug(\"KeyValueService not present\");\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        KeyValueStore store = kvs.getKeyValueStore(getStoreName());\n+        String status = store.getString(key + NuxeoIdempotentFilter.INFO_SUFFIX);\n+        if (status == null) {\n+            log.debug(\"Handle new request for key: \" + key);\n+            long ttl = getTTLSeconds();\n+            store.put(key + NuxeoIdempotentFilter.INFO_SUFFIX, NuxeoIdempotentFilter.INPROGRESS_MARKER, ttl);\n+            try {\n+                CopyingResponseWrapper wrapper = new CopyingResponseWrapper(DEFERRED_OUTPUT_STREAM_THRESHOLD, response);\n+                chain.doFilter(request, wrapper);\n+                store.put(key, wrapper.getCaptureAsBytes(), ttl);", "originalCommit": "6862e80459534c763a5c14930e00290b00fc7482", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODEyNDI5Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548124297", "bodyText": "I'd like to see the response size in bytes logged as well, and the status (here and in the \"return stored result\" case)", "author": "efge", "createdAt": "2020-12-23T18:36:04Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentFilter.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Set;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Filter handling an idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentFilter implements Filter {\n+\n+    private static final Logger log = LogManager.getLogger(NuxeoIdempotentFilter.class);\n+\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.idempotency.keyvaluestore.name\";\n+\n+    public static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    protected static final long DEFAULT_TTL_SECONDS = Duration.ofDays(1).toSeconds();\n+\n+    public static final String TTL_SECONDS_PROPERTY = \"org.nuxeo.request.idempotency.ttl.seconds\";\n+\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";\n+\n+    public static final String INFO_SUFFIX = \"_info\";\n+\n+    protected static final int DEFERRED_OUTPUT_STREAM_THRESHOLD = 1024 * 1024; // 1 MB\n+\n+    // safe methods according to RFC 7231 4.2.1\n+    protected static final Set<String> SAFE_METHODS = Set.of(HttpGet.METHOD_NAME, HttpHead.METHOD_NAME,\n+            HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME);\n+\n+    // idempotent methods according to RFC 7231 4.2.2\n+    protected static final Set<String> IDEMPOTENT_METHODS = Set.of(HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME);\n+\n+    protected long getTTLSeconds() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getLong(TTL_SECONDS_PROPERTY, DEFAULT_TTL_SECONDS);\n+        }\n+        return DEFAULT_TTL_SECONDS;\n+    }\n+\n+    protected String getStoreName() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getString(STORE_PROPERTY, DEFAULT_STORE);\n+        }\n+        return DEFAULT_STORE;\n+    }\n+\n+    protected boolean isIdempotentMethod(String method) {\n+        return SAFE_METHODS.contains(method) || IDEMPOTENT_METHODS.contains(method);\n+    }\n+\n+    @Override\n+    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)\n+            throws IOException, ServletException {\n+        HttpServletRequest request = (HttpServletRequest) servletRequest;\n+        HttpServletResponse response = (HttpServletResponse) servletResponse;\n+        String method = request.getMethod();\n+        if (isIdempotentMethod(method)) {\n+            log.debug(\"No idempotent processing done: method is already idempotent: \" + method);\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        String key = request.getHeader(NuxeoIdempotentFilter.HEADER_KEY);\n+        if (key == null) {\n+            log.debug(\"No idempotent processing done: no Idempotent-Key present\");\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        log.debug(\"Idempotent request key: \" + key);\n+        KeyValueService kvs = Framework.getService(KeyValueService.class);\n+        if (kvs == null) {\n+            log.debug(\"KeyValueService not present\");\n+            chain.doFilter(request, response);\n+            return;\n+        }\n+        KeyValueStore store = kvs.getKeyValueStore(getStoreName());\n+        String status = store.getString(key + NuxeoIdempotentFilter.INFO_SUFFIX);\n+        if (status == null) {\n+            log.debug(\"Handle new request for key: \" + key);\n+            long ttl = getTTLSeconds();\n+            store.put(key + NuxeoIdempotentFilter.INFO_SUFFIX, NuxeoIdempotentFilter.INPROGRESS_MARKER, ttl);\n+            try {\n+                CopyingResponseWrapper wrapper = new CopyingResponseWrapper(DEFERRED_OUTPUT_STREAM_THRESHOLD, response);\n+                chain.doFilter(request, wrapper);\n+                store.put(key, wrapper.getCaptureAsBytes(), ttl);\n+                store.put(key + NuxeoIdempotentFilter.INFO_SUFFIX, NuxeoIdempotentResponse.write(wrapper), ttl);\n+                log.debug(\"Stored response for key: \" + key);", "originalCommit": "6862e80459534c763a5c14930e00290b00fc7482", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODEyNjM5Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548126392", "bodyText": "Let's make this {\"inprogress\":true} so that it's at least valid JSON.", "author": "efge", "createdAt": "2020-12-23T18:38:46Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentFilter.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Set;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Filter handling an idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentFilter implements Filter {\n+\n+    private static final Logger log = LogManager.getLogger(NuxeoIdempotentFilter.class);\n+\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.idempotency.keyvaluestore.name\";\n+\n+    public static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    protected static final long DEFAULT_TTL_SECONDS = Duration.ofDays(1).toSeconds();\n+\n+    public static final String TTL_SECONDS_PROPERTY = \"org.nuxeo.request.idempotency.ttl.seconds\";\n+\n+    public static final String INPROGRESS_MARKER = \"IDEMPOTENCY_INPROGRESS_MARKER\";", "originalCommit": "6862e80459534c763a5c14930e00290b00fc7482", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODEzMDUwMw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r548130503", "bodyText": "Could you add case with a multi-value header? For example Set-Cookie and Accept are common headers seen multiple times.", "author": "efge", "createdAt": "2020-12-23T18:44:04Z", "path": "modules/platform/nuxeo-platform-web-common/src/test/java/org/nuxeo/ecm/platform/web/requestcontroller/filter/TestNuxeoIdempotentFilter.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.requestcontroller.filter;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static javax.servlet.http.HttpServletResponse.SC_OK;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyInt;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.nuxeo.ecm.platform.web.common.idempotency.NuxeoIdempotentFilter;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStoreProvider;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.RuntimeFeature;\n+\n+/**\n+ * Checks idempotent requests management.\n+ *\n+ * @since 11.5\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(RuntimeFeature.class)\n+@Deploy(\"org.nuxeo.runtime.kv\")\n+@Deploy(\"org.nuxeo.ecm.platform.web.common:OSGI-INF/web-request-controller-framework.xml\")\n+public class TestNuxeoIdempotentFilter {\n+\n+    protected static final String KEY = \"mykey\";\n+\n+    protected static final String CONTENT = \"test content\";\n+\n+    protected static final Map<String, Collection<String>> RESPONSE_HEADERS = new LinkedHashMap<>();\n+    static {\n+        RESPONSE_HEADERS.put(\"Connection\", List.of(\"Keep-Alive\"));\n+        RESPONSE_HEADERS.put(\"Content-Encoding\", List.of(\"gzip\"));\n+        RESPONSE_HEADERS.put(\"Content-Type\", List.of(\"text/html; charset=utf-8\"));\n+    }\n+\n+    protected NuxeoIdempotentFilter filter;\n+\n+    protected FilterChain chain;\n+\n+    protected HttpServletRequest request;\n+\n+    protected MockResponse mockResponse;\n+\n+    @Inject\n+    protected KeyValueService kvs;\n+\n+    protected KeyValueStoreProvider store;\n+\n+    protected static class MockResponse {\n+\n+        protected HttpServletResponse response;\n+\n+        protected int status;\n+\n+        protected Map<String, Collection<String>> headers = new LinkedHashMap<>();\n+\n+        protected OutputStream output;\n+\n+        public MockResponse() throws IOException {\n+            super();\n+            response = mock(HttpServletResponse.class);\n+            // output mock\n+            output = new ByteArrayOutputStream();\n+            ServletOutputStream servletOutput = mock(ServletOutputStream.class);\n+            doAnswer(invocation -> {\n+                output.write((byte[]) invocation.getArguments()[0]);\n+                return null;\n+            }).when(servletOutput).write(any(byte[].class));\n+            doAnswer(invocation -> {\n+                output.write((Integer) invocation.getArguments()[0]);\n+                return null;\n+            }).when(servletOutput).write(anyInt());\n+            when(response.getOutputStream()).thenReturn(servletOutput);\n+            PrintWriter writer = mock(PrintWriter.class);\n+            doAnswer(invocation -> {\n+                output.write(((String) invocation.getArguments()[0]).getBytes());\n+                return null;\n+            }).when(writer).write(anyString());\n+            doAnswer(invocation -> {\n+                return writer;\n+            }).when(response).getWriter();\n+            when(response.getCharacterEncoding()).thenReturn(UTF_8.name());\n+            // status mock\n+            doAnswer(invocation -> {\n+                return status;\n+            }).when(response).getStatus();\n+            doAnswer(invocation -> {\n+                status = (Integer) invocation.getArguments()[0];\n+                return null;\n+            }).when(response).setStatus(anyInt());\n+            // headers mock\n+            when(response.getHeaderNames()).thenReturn(headers.keySet());\n+            doAnswer(invocation -> {\n+                return headers.get(invocation.getArguments()[0]).stream().findFirst().get();\n+            }).when(response).getHeader(anyString());\n+            doAnswer(invocation -> {\n+                return headers.get(invocation.getArguments()[0]);\n+            }).when(response).getHeaders(anyString());\n+            doAnswer(invocation -> {\n+                headers.put((String) invocation.getArguments()[0], List.of((String) invocation.getArguments()[1]));\n+                return null;\n+            }).when(response).setHeader(anyString(), anyString());\n+            doAnswer(invocation -> {\n+                headers.computeIfAbsent((String) invocation.getArguments()[0], k -> new ArrayList<>())\n+                       .add((String) invocation.getArguments()[1]);\n+                return null;\n+            }).when(response).addHeader(anyString(), anyString());\n+        }\n+\n+        public int getStatus() {\n+            return status;\n+        }\n+\n+        public HttpServletResponse getResponse() {\n+            return response;\n+        }\n+\n+        public OutputStream getOutput() {\n+            return output;\n+        }\n+\n+    }\n+\n+    @Before\n+    public void setUp() throws IOException {\n+        filter = new NuxeoIdempotentFilter();\n+        chain = mock(FilterChain.class);\n+        request = mock(HttpServletRequest.class);\n+        mockResponse = new MockResponse();\n+        // handle store\n+        store = (KeyValueStoreProvider) kvs.getKeyValueStore(NuxeoIdempotentFilter.DEFAULT_STORE);\n+        store.clear();\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        if (filter != null) {\n+            filter.destroy();\n+        }\n+        if (store != null) {\n+            store.clear();\n+        }\n+    }\n+\n+    protected void checkResponse(MockResponse mockResponse, Integer status, String content, boolean hasHeaders) {\n+        assertEquals(status, (Integer) mockResponse.getStatus());\n+        assertEquals(content, mockResponse.getOutput().toString());\n+        if (hasHeaders) {\n+            assertEquals(RESPONSE_HEADERS.keySet(), mockResponse.getResponse().getHeaderNames());\n+            RESPONSE_HEADERS.forEach((k, v) -> {\n+                assertEquals(v, mockResponse.getResponse().getHeaders(k));\n+            });\n+        } else {\n+            assertTrue(mockResponse.getResponse().getHeaderNames().isEmpty());\n+        }\n+    }\n+\n+    protected void checkStore(String status, String content) {\n+        assertEquals(content, store.getString(KEY));\n+        String ikey = KEY + NuxeoIdempotentFilter.INFO_SUFFIX;\n+        if (status == null) {\n+            assertNull(store.getString(ikey));\n+        } else {\n+            if (NuxeoIdempotentFilter.INPROGRESS_MARKER.equals(status)) {\n+                assertEquals(status, store.getString(ikey));\n+            } else {\n+                String info = \"{\\\"headers\\\":\" //\n+                        + \"{\\\"Connection\\\":[\\\"Keep-Alive\\\"],\" //\n+                        + \"\\\"Content-Encoding\\\":[\\\"gzip\\\"],\" //\n+                        + \"\\\"Content-Type\\\":[\\\"text/html; charset=utf-8\\\"]\" //", "originalCommit": "6862e80459534c763a5c14930e00290b00fc7482", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI0NzY5MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r551247691", "bodyText": "Fixed the \"isFirst\" buggy logic with these additional checks \ud83d\udc4d", "author": "atchertchian", "createdAt": "2021-01-04T10:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODEzMDUwMw=="}], "type": "inlineReview"}, {"oid": "83df4398363ae990615b619ee63a2300c81b5477", "url": "https://github.com/nuxeo/nuxeo/commit/83df4398363ae990615b619ee63a2300c81b5477", "message": "NXP-29978: add idempotent request filter", "committedDate": "2021-01-04T11:00:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ1ODUwMg==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r552458502", "bodyText": "Any point making these protected?", "author": "ataillefer", "createdAt": "2021-01-06T09:23:13Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/CopyingResponseWrapper.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpServletResponseWrapper;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.output.DeferredFileOutputStream;\n+\n+/**\n+ * Response wrapper that can capture response result, using a {@link DeferredFileOutputStream}.\n+ *\n+ * @since 11.5\n+ */\n+public class CopyingResponseWrapper extends HttpServletResponseWrapper implements AutoCloseable {\n+\n+    private final DeferredFileOutputStream capture;\n+\n+    private ServletOutputStream output;\n+\n+    private PrintWriter writer;", "originalCommit": "83df4398363ae990615b619ee63a2300c81b5477", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUwOTY3MA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r552509670", "bodyText": "I can make that change", "author": "atchertchian", "createdAt": "2021-01-06T11:04:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ1ODUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ2MzI1Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r552463257", "bodyText": "You can use:\nFiles.delete(file.toPath());\n\nto fix the Sonar warning: Use \"java.nio.file.Files#delete\" here for better messages on error conditions.", "author": "ataillefer", "createdAt": "2021-01-06T09:32:39Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/CopyingResponseWrapper.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpServletResponseWrapper;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.output.DeferredFileOutputStream;\n+\n+/**\n+ * Response wrapper that can capture response result, using a {@link DeferredFileOutputStream}.\n+ *\n+ * @since 11.5\n+ */\n+public class CopyingResponseWrapper extends HttpServletResponseWrapper implements AutoCloseable {\n+\n+    private final DeferredFileOutputStream capture;\n+\n+    private ServletOutputStream output;\n+\n+    private PrintWriter writer;\n+\n+    public CopyingResponseWrapper(int threshold, HttpServletResponse response) {\n+        super(response);\n+        capture = new DeferredFileOutputStream(threshold, response.getBufferSize(), \"nxidem\", null, null);\n+    }\n+\n+    protected CopyingServletOutputStream getCopyingOutputStream() throws IOException {\n+        return new CopyingServletOutputStream(getResponse().getOutputStream(), capture);\n+    }\n+\n+    @Override\n+    public ServletOutputStream getOutputStream() throws IOException {\n+        if (writer != null) {\n+            throw new IllegalStateException(\"getWriter() has already been called on this response.\");\n+        }\n+\n+        if (output == null) {\n+            output = getCopyingOutputStream();\n+        }\n+\n+        return output;\n+    }\n+\n+    @Override\n+    public PrintWriter getWriter() throws IOException {\n+        if (output != null) {\n+            throw new IllegalStateException(\"getOutputStream() has already been called on this response.\");\n+        }\n+\n+        if (writer == null) {\n+            writer = new PrintWriter(new OutputStreamWriter(getCopyingOutputStream(), getCharacterEncoding()));\n+        }\n+\n+        return writer;\n+    }\n+\n+    @Override\n+    public void flushBuffer() throws IOException {\n+        super.flushBuffer();\n+\n+        if (writer != null) {\n+            writer.flush();\n+        } else if (output != null) {\n+            output.flush();\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        if (writer != null) {\n+            writer.close();\n+        } else if (output != null) {\n+            output.close();\n+        }\n+        if (!capture.isInMemory()) {\n+            // tmp file cleanup\n+            File file = capture.getFile();\n+            if (file != null) {\n+                file.delete();", "originalCommit": "83df4398363ae990615b619ee63a2300c81b5477", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ2Nzk0NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r552467945", "bodyText": "Can it be null without getService throwing or an exception having been thrown before?", "author": "ataillefer", "createdAt": "2021-01-06T09:38:41Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentFilter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Set;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpFilter;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Filter handling an idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentFilter extends HttpFilter {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private static final Logger log = LogManager.getLogger(NuxeoIdempotentFilter.class);\n+\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.idempotency.keyvaluestore.name\";\n+\n+    public static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    protected static final Duration DEFAULT_TTL = Duration.ofDays(1);\n+\n+    public static final String TTL_DURATION_PROPERTY = \"org.nuxeo.request.idempotency.ttl.duration\";\n+\n+    public static final String INPROGRESS_MARKER = \"{\\\"inprogress\\\":true}\";\n+\n+    public static final String INFO_SUFFIX = \"_info\";\n+\n+    protected static final int DEFERRED_OUTPUT_STREAM_THRESHOLD = 1024 * 1024; // 1 MB\n+\n+    protected static final int MAX_CONTENT_SIZE = 1024 * 1024 * 5; // 5 MB\n+\n+    protected static final Set<String> IDEMPOTENT_METHODS = Set.of(\n+            // safe methods according to RFC 7231 4.2.1\n+            HttpGet.METHOD_NAME, HttpHead.METHOD_NAME, HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME,\n+            // idempotent methods according to RFC 7231 4.2.2\n+            HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME);\n+\n+    protected Duration getTTL() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {", "originalCommit": "83df4398363ae990615b619ee63a2300c81b5477", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxMDk5OA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r552510998", "bodyText": "getService will throw an error only if the runtime is not initialized, otherwise it could return null until the target component is activated (which can in theory happen as the servlet can be called regardless of the runtime status, especially during hot reload, but at startup too)", "author": "atchertchian", "createdAt": "2021-01-06T11:07:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ2Nzk0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ2ODM2OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r552468369", "bodyText": "Same remark as above, can this happen?", "author": "ataillefer", "createdAt": "2021-01-06T09:39:33Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentFilter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Set;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpFilter;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Filter handling an idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentFilter extends HttpFilter {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private static final Logger log = LogManager.getLogger(NuxeoIdempotentFilter.class);\n+\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.idempotency.keyvaluestore.name\";\n+\n+    public static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    protected static final Duration DEFAULT_TTL = Duration.ofDays(1);\n+\n+    public static final String TTL_DURATION_PROPERTY = \"org.nuxeo.request.idempotency.ttl.duration\";\n+\n+    public static final String INPROGRESS_MARKER = \"{\\\"inprogress\\\":true}\";\n+\n+    public static final String INFO_SUFFIX = \"_info\";\n+\n+    protected static final int DEFERRED_OUTPUT_STREAM_THRESHOLD = 1024 * 1024; // 1 MB\n+\n+    protected static final int MAX_CONTENT_SIZE = 1024 * 1024 * 5; // 5 MB\n+\n+    protected static final Set<String> IDEMPOTENT_METHODS = Set.of(\n+            // safe methods according to RFC 7231 4.2.1\n+            HttpGet.METHOD_NAME, HttpHead.METHOD_NAME, HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME,\n+            // idempotent methods according to RFC 7231 4.2.2\n+            HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME);\n+\n+    protected Duration getTTL() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getDuration(TTL_DURATION_PROPERTY, DEFAULT_TTL);\n+        }\n+        return DEFAULT_TTL;\n+    }\n+\n+    protected String getStoreName() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getString(STORE_PROPERTY, DEFAULT_STORE);\n+        }\n+        return DEFAULT_STORE;\n+    }\n+\n+    @Override\n+    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        if (!doFilterIdempotent(request, response, chain)) {\n+            chain.doFilter(request, response);\n+        }\n+    }\n+\n+    protected boolean doFilterIdempotent(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        String method = request.getMethod();\n+        if (IDEMPOTENT_METHODS.contains(method)) {\n+            log.debug(\"No idempotent processing done: method is already idempotent: {}\", method);\n+            return false;\n+        }\n+        String key = request.getHeader(HEADER_KEY);\n+        if (key == null) {\n+            log.debug(\"No idempotent processing done: no {} header present\", HEADER_KEY);\n+            return false;\n+        }\n+        log.debug(\"Idempotent request key: {}\", key);\n+        KeyValueService kvs = Framework.getService(KeyValueService.class);\n+        if (kvs == null) {", "originalCommit": "83df4398363ae990615b619ee63a2300c81b5477", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxMzI1Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r552513256", "bodyText": "In theory yes (and Florent stated earlier \"You should protect against NPEs here, for the service and the store. Filters may be called very early/late and independently of Nuxeo startup itself.\")", "author": "atchertchian", "createdAt": "2021-01-06T11:12:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ2ODM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ3NTcwOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r552475709", "bodyText": "Why don't we need chain.doFilter(request, wrapper); in this block?", "author": "ataillefer", "createdAt": "2021-01-06T09:53:34Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentFilter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Set;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpFilter;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Filter handling an idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentFilter extends HttpFilter {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private static final Logger log = LogManager.getLogger(NuxeoIdempotentFilter.class);\n+\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.idempotency.keyvaluestore.name\";\n+\n+    public static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    protected static final Duration DEFAULT_TTL = Duration.ofDays(1);\n+\n+    public static final String TTL_DURATION_PROPERTY = \"org.nuxeo.request.idempotency.ttl.duration\";\n+\n+    public static final String INPROGRESS_MARKER = \"{\\\"inprogress\\\":true}\";\n+\n+    public static final String INFO_SUFFIX = \"_info\";\n+\n+    protected static final int DEFERRED_OUTPUT_STREAM_THRESHOLD = 1024 * 1024; // 1 MB\n+\n+    protected static final int MAX_CONTENT_SIZE = 1024 * 1024 * 5; // 5 MB\n+\n+    protected static final Set<String> IDEMPOTENT_METHODS = Set.of(\n+            // safe methods according to RFC 7231 4.2.1\n+            HttpGet.METHOD_NAME, HttpHead.METHOD_NAME, HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME,\n+            // idempotent methods according to RFC 7231 4.2.2\n+            HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME);\n+\n+    protected Duration getTTL() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getDuration(TTL_DURATION_PROPERTY, DEFAULT_TTL);\n+        }\n+        return DEFAULT_TTL;\n+    }\n+\n+    protected String getStoreName() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getString(STORE_PROPERTY, DEFAULT_STORE);\n+        }\n+        return DEFAULT_STORE;\n+    }\n+\n+    @Override\n+    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        if (!doFilterIdempotent(request, response, chain)) {\n+            chain.doFilter(request, response);\n+        }\n+    }\n+\n+    protected boolean doFilterIdempotent(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        String method = request.getMethod();\n+        if (IDEMPOTENT_METHODS.contains(method)) {\n+            log.debug(\"No idempotent processing done: method is already idempotent: {}\", method);\n+            return false;\n+        }\n+        String key = request.getHeader(HEADER_KEY);\n+        if (key == null) {\n+            log.debug(\"No idempotent processing done: no {} header present\", HEADER_KEY);\n+            return false;\n+        }\n+        log.debug(\"Idempotent request key: {}\", key);\n+        KeyValueService kvs = Framework.getService(KeyValueService.class);\n+        if (kvs == null) {\n+            log.debug(\"KeyValueService not present\");\n+            return false;\n+        }\n+        KeyValueStore store = kvs.getKeyValueStore(getStoreName());\n+        String status = store.getString(key + INFO_SUFFIX);\n+        if (status == null) {\n+            log.debug(\"Handle new request for key: {}\", key);\n+            long ttl = getTTL().toSeconds();\n+            store.put(key + INFO_SUFFIX, INPROGRESS_MARKER, ttl);\n+            try {\n+                try (CopyingResponseWrapper wrapper = new CopyingResponseWrapper(DEFERRED_OUTPUT_STREAM_THRESHOLD,\n+                        response)) {\n+                    chain.doFilter(request, wrapper);\n+                    wrapper.flushBuffer();\n+                    byte[] content = wrapper.getCaptureAsBytes();\n+                    if (content.length > MAX_CONTENT_SIZE) {\n+                        log.debug(\n+                                \"Not storing response for key: {} (status: {}, size in bytes: {}), max content size exceeded: {}\",\n+                                key, wrapper.getStatus(), content.length, MAX_CONTENT_SIZE);\n+                        return true;\n+                    }\n+                    store.put(key, content, ttl);\n+                    store.put(key + INFO_SUFFIX, NuxeoIdempotentResponse.write(wrapper), ttl);\n+                    log.debug(\"Stored response for key: {} (status: {}, size in bytes: {})\", key, wrapper.getStatus(),\n+                            content.length);\n+                    return true;\n+                }\n+            } catch (IOException | ServletException e) {\n+                response.setStatus(SC_INTERNAL_SERVER_ERROR);\n+                throw e;\n+            } finally {\n+                if (response.getStatus() >= SC_BAD_REQUEST) {\n+                    // error request: cleanup store\n+                    store.put(key, (String) null);\n+                    store.put(key + INFO_SUFFIX, (String) null);\n+                    log.debug(\"Cleanup store: error for key: {}\", key);\n+                }\n+            }\n+        } else if (INPROGRESS_MARKER.equals(status)) {\n+            // request already in progress -> conflict", "originalCommit": "83df4398363ae990615b619ee63a2300c81b5477", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxNDc4NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r552514785", "bodyText": "That's the goal of idempotent processing: we want to protect against the request to be processed (here because it is already being processed)", "author": "atchertchian", "createdAt": "2021-01-06T11:16:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ3NTcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ3NTk5MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r552475991", "bodyText": "Same remark: why don't we need chain.doFilter(request, wrapper); in this block?", "author": "ataillefer", "createdAt": "2021-01-06T09:54:03Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentFilter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Set;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpFilter;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Filter handling an idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentFilter extends HttpFilter {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private static final Logger log = LogManager.getLogger(NuxeoIdempotentFilter.class);\n+\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.idempotency.keyvaluestore.name\";\n+\n+    public static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    protected static final Duration DEFAULT_TTL = Duration.ofDays(1);\n+\n+    public static final String TTL_DURATION_PROPERTY = \"org.nuxeo.request.idempotency.ttl.duration\";\n+\n+    public static final String INPROGRESS_MARKER = \"{\\\"inprogress\\\":true}\";\n+\n+    public static final String INFO_SUFFIX = \"_info\";\n+\n+    protected static final int DEFERRED_OUTPUT_STREAM_THRESHOLD = 1024 * 1024; // 1 MB\n+\n+    protected static final int MAX_CONTENT_SIZE = 1024 * 1024 * 5; // 5 MB\n+\n+    protected static final Set<String> IDEMPOTENT_METHODS = Set.of(\n+            // safe methods according to RFC 7231 4.2.1\n+            HttpGet.METHOD_NAME, HttpHead.METHOD_NAME, HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME,\n+            // idempotent methods according to RFC 7231 4.2.2\n+            HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME);\n+\n+    protected Duration getTTL() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getDuration(TTL_DURATION_PROPERTY, DEFAULT_TTL);\n+        }\n+        return DEFAULT_TTL;\n+    }\n+\n+    protected String getStoreName() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getString(STORE_PROPERTY, DEFAULT_STORE);\n+        }\n+        return DEFAULT_STORE;\n+    }\n+\n+    @Override\n+    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        if (!doFilterIdempotent(request, response, chain)) {\n+            chain.doFilter(request, response);\n+        }\n+    }\n+\n+    protected boolean doFilterIdempotent(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        String method = request.getMethod();\n+        if (IDEMPOTENT_METHODS.contains(method)) {\n+            log.debug(\"No idempotent processing done: method is already idempotent: {}\", method);\n+            return false;\n+        }\n+        String key = request.getHeader(HEADER_KEY);\n+        if (key == null) {\n+            log.debug(\"No idempotent processing done: no {} header present\", HEADER_KEY);\n+            return false;\n+        }\n+        log.debug(\"Idempotent request key: {}\", key);\n+        KeyValueService kvs = Framework.getService(KeyValueService.class);\n+        if (kvs == null) {\n+            log.debug(\"KeyValueService not present\");\n+            return false;\n+        }\n+        KeyValueStore store = kvs.getKeyValueStore(getStoreName());\n+        String status = store.getString(key + INFO_SUFFIX);\n+        if (status == null) {\n+            log.debug(\"Handle new request for key: {}\", key);\n+            long ttl = getTTL().toSeconds();\n+            store.put(key + INFO_SUFFIX, INPROGRESS_MARKER, ttl);\n+            try {\n+                try (CopyingResponseWrapper wrapper = new CopyingResponseWrapper(DEFERRED_OUTPUT_STREAM_THRESHOLD,\n+                        response)) {\n+                    chain.doFilter(request, wrapper);\n+                    wrapper.flushBuffer();\n+                    byte[] content = wrapper.getCaptureAsBytes();\n+                    if (content.length > MAX_CONTENT_SIZE) {\n+                        log.debug(\n+                                \"Not storing response for key: {} (status: {}, size in bytes: {}), max content size exceeded: {}\",\n+                                key, wrapper.getStatus(), content.length, MAX_CONTENT_SIZE);\n+                        return true;\n+                    }\n+                    store.put(key, content, ttl);\n+                    store.put(key + INFO_SUFFIX, NuxeoIdempotentResponse.write(wrapper), ttl);\n+                    log.debug(\"Stored response for key: {} (status: {}, size in bytes: {})\", key, wrapper.getStatus(),\n+                            content.length);\n+                    return true;\n+                }\n+            } catch (IOException | ServletException e) {\n+                response.setStatus(SC_INTERNAL_SERVER_ERROR);\n+                throw e;\n+            } finally {\n+                if (response.getStatus() >= SC_BAD_REQUEST) {\n+                    // error request: cleanup store\n+                    store.put(key, (String) null);\n+                    store.put(key + INFO_SUFFIX, (String) null);\n+                    log.debug(\"Cleanup store: error for key: {}\", key);\n+                }\n+            }\n+        } else if (INPROGRESS_MARKER.equals(status)) {\n+            // request already in progress -> conflict\n+            // Don't call response.sendError, because it commits the response\n+            // which prevents NuxeoExceptionFilter from returning a custom error page.\n+            response.setStatus(SC_CONFLICT);\n+            log.debug(\"Conflict response for key: {}\", key);\n+            return true;\n+        } else {\n+            try {\n+                // request already done: return stored result", "originalCommit": "83df4398363ae990615b619ee63a2300c81b5477", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxNDcwMw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r552514703", "bodyText": "Here because it was already processed: if we called the filter chain, the request would be processed again and potentially break idempotency (for Drive use case, the file would be imported again, and a new document would be created again)", "author": "atchertchian", "createdAt": "2021-01-06T11:15:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ3NTk5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ3ODE0Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r552478142", "bodyText": "Do we need to handle the edge case where the entry would expire between the previous call to store.getString(key + INFO_SUFFIX) and this call: store.get(key), in which case the latter would return null?", "author": "ataillefer", "createdAt": "2021-01-06T09:58:18Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentFilter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Set;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpFilter;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Filter handling an idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentFilter extends HttpFilter {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private static final Logger log = LogManager.getLogger(NuxeoIdempotentFilter.class);\n+\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.idempotency.keyvaluestore.name\";\n+\n+    public static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    protected static final Duration DEFAULT_TTL = Duration.ofDays(1);\n+\n+    public static final String TTL_DURATION_PROPERTY = \"org.nuxeo.request.idempotency.ttl.duration\";\n+\n+    public static final String INPROGRESS_MARKER = \"{\\\"inprogress\\\":true}\";\n+\n+    public static final String INFO_SUFFIX = \"_info\";\n+\n+    protected static final int DEFERRED_OUTPUT_STREAM_THRESHOLD = 1024 * 1024; // 1 MB\n+\n+    protected static final int MAX_CONTENT_SIZE = 1024 * 1024 * 5; // 5 MB\n+\n+    protected static final Set<String> IDEMPOTENT_METHODS = Set.of(\n+            // safe methods according to RFC 7231 4.2.1\n+            HttpGet.METHOD_NAME, HttpHead.METHOD_NAME, HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME,\n+            // idempotent methods according to RFC 7231 4.2.2\n+            HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME);\n+\n+    protected Duration getTTL() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getDuration(TTL_DURATION_PROPERTY, DEFAULT_TTL);\n+        }\n+        return DEFAULT_TTL;\n+    }\n+\n+    protected String getStoreName() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getString(STORE_PROPERTY, DEFAULT_STORE);\n+        }\n+        return DEFAULT_STORE;\n+    }\n+\n+    @Override\n+    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        if (!doFilterIdempotent(request, response, chain)) {\n+            chain.doFilter(request, response);\n+        }\n+    }\n+\n+    protected boolean doFilterIdempotent(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        String method = request.getMethod();\n+        if (IDEMPOTENT_METHODS.contains(method)) {\n+            log.debug(\"No idempotent processing done: method is already idempotent: {}\", method);\n+            return false;\n+        }\n+        String key = request.getHeader(HEADER_KEY);\n+        if (key == null) {\n+            log.debug(\"No idempotent processing done: no {} header present\", HEADER_KEY);\n+            return false;\n+        }\n+        log.debug(\"Idempotent request key: {}\", key);\n+        KeyValueService kvs = Framework.getService(KeyValueService.class);\n+        if (kvs == null) {\n+            log.debug(\"KeyValueService not present\");\n+            return false;\n+        }\n+        KeyValueStore store = kvs.getKeyValueStore(getStoreName());\n+        String status = store.getString(key + INFO_SUFFIX);\n+        if (status == null) {\n+            log.debug(\"Handle new request for key: {}\", key);\n+            long ttl = getTTL().toSeconds();\n+            store.put(key + INFO_SUFFIX, INPROGRESS_MARKER, ttl);\n+            try {\n+                try (CopyingResponseWrapper wrapper = new CopyingResponseWrapper(DEFERRED_OUTPUT_STREAM_THRESHOLD,\n+                        response)) {\n+                    chain.doFilter(request, wrapper);\n+                    wrapper.flushBuffer();\n+                    byte[] content = wrapper.getCaptureAsBytes();\n+                    if (content.length > MAX_CONTENT_SIZE) {\n+                        log.debug(\n+                                \"Not storing response for key: {} (status: {}, size in bytes: {}), max content size exceeded: {}\",\n+                                key, wrapper.getStatus(), content.length, MAX_CONTENT_SIZE);\n+                        return true;\n+                    }\n+                    store.put(key, content, ttl);\n+                    store.put(key + INFO_SUFFIX, NuxeoIdempotentResponse.write(wrapper), ttl);\n+                    log.debug(\"Stored response for key: {} (status: {}, size in bytes: {})\", key, wrapper.getStatus(),\n+                            content.length);\n+                    return true;\n+                }\n+            } catch (IOException | ServletException e) {\n+                response.setStatus(SC_INTERNAL_SERVER_ERROR);\n+                throw e;\n+            } finally {\n+                if (response.getStatus() >= SC_BAD_REQUEST) {\n+                    // error request: cleanup store\n+                    store.put(key, (String) null);\n+                    store.put(key + INFO_SUFFIX, (String) null);\n+                    log.debug(\"Cleanup store: error for key: {}\", key);\n+                }\n+            }\n+        } else if (INPROGRESS_MARKER.equals(status)) {\n+            // request already in progress -> conflict\n+            // Don't call response.sendError, because it commits the response\n+            // which prevents NuxeoExceptionFilter from returning a custom error page.\n+            response.setStatus(SC_CONFLICT);\n+            log.debug(\"Conflict response for key: {}\", key);\n+            return true;\n+        } else {\n+            try {\n+                // request already done: return stored result\n+                NuxeoIdempotentResponse.restore(response, store.get(key + INFO_SUFFIX));\n+                byte[] content = store.get(key);", "originalCommit": "83df4398363ae990615b619ee63a2300c81b5477", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxNzQyNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r552517425", "bodyText": "In practice it would be very bad luck but maybe this can be made safer indeed", "author": "atchertchian", "createdAt": "2021-01-06T11:22:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ3ODE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ4MDIxMA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r552480210", "bodyText": "There are quite a few Sonar warnings about:\n\nRemove useless curly braces around statement.\nRemove useless curly braces around statement and then remove useless return keyword.\nDefine and throw a dedicated exception instead of using a generic one.\n\nEasy to fix if you can take the time!", "author": "ataillefer", "createdAt": "2021-01-06T10:02:39Z", "path": "modules/platform/nuxeo-platform-web-common/src/test/java/org/nuxeo/ecm/platform/web/idempotency/TestNuxeoIdempotentFilter.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.idempotency;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static javax.servlet.http.HttpServletResponse.SC_OK;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyInt;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.nuxeo.ecm.platform.web.common.idempotency.NuxeoIdempotentFilter;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStoreProvider;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.RuntimeFeature;\n+\n+/**\n+ * Checks idempotent requests management.\n+ *\n+ * @since 11.5\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(RuntimeFeature.class)\n+@Deploy(\"org.nuxeo.runtime.kv\")\n+@Deploy(\"org.nuxeo.ecm.platform.web.common:OSGI-INF/idempotency-configuration.xml\")\n+public class TestNuxeoIdempotentFilter {", "originalCommit": "83df4398363ae990615b619ee63a2300c81b5477", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjYyMjc0MA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r552622740", "bodyText": "I fixed a few, please tell if you see remaining ones.", "author": "atchertchian", "createdAt": "2021-01-06T13:42:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ4MDIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ4MTI0NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r552481245", "bodyText": "missing blank line", "author": "ataillefer", "createdAt": "2021-01-06T10:04:52Z", "path": "modules/platform/nuxeo-platform-web-common/src/test/java/org/nuxeo/ecm/platform/web/idempotency/TestNuxeoIdempotentFilter.java", "diffHunk": "@@ -93,6 +93,12 @@\n         RESPONSE_HEADERS.put(\"Set-Cookie\", List.of(\"sessionId=38afes7a8\", \"id=a3fWa; Max-Age=2592000\"));\n     }\n \n+    protected static final Map<String, Collection<String>> FINAL_RESPONSE_HEADERS = new LinkedHashMap<>();\n+    static {", "originalCommit": "ed65a6ea0c759429287d826238d59aa99c165dcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ4MjU5Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r552482592", "bodyText": "Cant this call and the subsequent ones be factorized? Or is there a case where we don't want to set this header?", "author": "ataillefer", "createdAt": "2021-01-06T10:07:19Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentFilter.java", "diffHunk": "@@ -149,13 +149,15 @@ protected boolean doFilterIdempotent(HttpServletRequest request, HttpServletResp\n                                 key, wrapper.getStatus(), content.length, MAX_CONTENT_SIZE);\n                         return true;\n                     }\n+                    response.setHeader(HEADER_KEY, key);", "originalCommit": "ed65a6ea0c759429287d826238d59aa99c165dcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjYxNDc5Mw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r552614793", "bodyText": "I did not find any better way to handle it given the fact that response is wrapped when being processed (for response copy) and because of the pattern to return a boolean, as asked by Florent, to avoid repeating calls to chain.doFilter whenever the request is not handled.\nNote I did not set this header either when the response is too big to be stored in the KV store (maybe it should still be added ?)", "author": "atchertchian", "createdAt": "2021-01-06T13:33:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ4MjU5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjY0NzIwOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r552647209", "bodyText": "OK.\n\nmaybe it should still be added ?\n\nI'd say yes", "author": "ataillefer", "createdAt": "2021-01-06T14:10:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ4MjU5Mg=="}], "type": "inlineReview"}, {"oid": "a02e7409545f25c9fbee8a10090b53a2469fde9c", "url": "https://github.com/nuxeo/nuxeo/commit/a02e7409545f25c9fbee8a10090b53a2469fde9c", "message": "NXP029978: add back Idempotency-Key header in response for convenience", "committedDate": "2021-01-06T13:41:26Z", "type": "forcePushed"}, {"oid": "fddddefe874307227da00f92c4054a9aa51c2fa4", "url": "https://github.com/nuxeo/nuxeo/commit/fddddefe874307227da00f92c4054a9aa51c2fa4", "message": "NXP029978: add back Idempotency-Key header in response for convenience", "committedDate": "2021-01-06T14:14:24Z", "type": "forcePushed"}, {"oid": "7ae0349aa89c74c4e9eb6bcde0e34b001e05e5b0", "url": "https://github.com/nuxeo/nuxeo/commit/7ae0349aa89c74c4e9eb6bcde0e34b001e05e5b0", "message": "NXP029978: add back Idempotency-Key header in response for convenience", "committedDate": "2021-01-06T14:21:58Z", "type": "forcePushed"}, {"oid": "8a55e5ef9162a52843cff1644557f9f1ecc731a6", "url": "https://github.com/nuxeo/nuxeo/commit/8a55e5ef9162a52843cff1644557f9f1ecc731a6", "message": "NXP029978: add back Idempotency-Key header in response for convenience", "committedDate": "2021-01-06T14:23:28Z", "type": "forcePushed"}, {"oid": "60b9d9884031ab0dbd8e68fd9d1867d05da526cc", "url": "https://github.com/nuxeo/nuxeo/commit/60b9d9884031ab0dbd8e68fd9d1867d05da526cc", "message": "NXP029978: add back Idempotency-Key header in response for convenience", "committedDate": "2021-01-06T14:28:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4NzAzNw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r553487037", "bodyText": "Can you call this copy instead? Same in CopyingServletOutputStream.\nAlso, detail, define that field last like in CopyingServletOutputStream. Or both first, but be consistent.", "author": "efge", "createdAt": "2021-01-07T17:51:51Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/CopyingResponseWrapper.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.nio.file.Files;\n+\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpServletResponseWrapper;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.output.DeferredFileOutputStream;\n+\n+/**\n+ * Response wrapper that can capture response result, using a {@link DeferredFileOutputStream}.\n+ *\n+ * @since 11.5\n+ */\n+public class CopyingResponseWrapper extends HttpServletResponseWrapper implements AutoCloseable {\n+\n+    protected final DeferredFileOutputStream capture;", "originalCommit": "60b9d9884031ab0dbd8e68fd9d1867d05da526cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4NzgwMA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r553487800", "bodyText": "Could you add a comment: // invariant: only one of output or writer may be non-null, never both at the same time", "author": "efge", "createdAt": "2021-01-07T17:53:18Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/CopyingResponseWrapper.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.nio.file.Files;\n+\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpServletResponseWrapper;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.output.DeferredFileOutputStream;\n+\n+/**\n+ * Response wrapper that can capture response result, using a {@link DeferredFileOutputStream}.\n+ *\n+ * @since 11.5\n+ */\n+public class CopyingResponseWrapper extends HttpServletResponseWrapper implements AutoCloseable {\n+\n+    protected final DeferredFileOutputStream capture;\n+\n+    protected ServletOutputStream output;\n+\n+    protected PrintWriter writer;", "originalCommit": "60b9d9884031ab0dbd8e68fd9d1867d05da526cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4ODkwMg==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r553488902", "bodyText": "I'd remove all the extra empty lines in these small methods.", "author": "efge", "createdAt": "2021-01-07T17:55:15Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/CopyingResponseWrapper.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.nio.file.Files;\n+\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpServletResponseWrapper;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.output.DeferredFileOutputStream;\n+\n+/**\n+ * Response wrapper that can capture response result, using a {@link DeferredFileOutputStream}.\n+ *\n+ * @since 11.5\n+ */\n+public class CopyingResponseWrapper extends HttpServletResponseWrapper implements AutoCloseable {\n+\n+    protected final DeferredFileOutputStream capture;\n+\n+    protected ServletOutputStream output;\n+\n+    protected PrintWriter writer;\n+\n+    public CopyingResponseWrapper(int threshold, HttpServletResponse response) {\n+        super(response);\n+        capture = new DeferredFileOutputStream(threshold, response.getBufferSize(), \"nxidem\", null, null);\n+    }\n+\n+    protected CopyingServletOutputStream getCopyingOutputStream() throws IOException {\n+        return new CopyingServletOutputStream(getResponse().getOutputStream(), capture);\n+    }\n+\n+    @Override\n+    public ServletOutputStream getOutputStream() throws IOException {\n+        if (writer != null) {\n+            throw new IllegalStateException(\"getWriter() has already been called on this response.\");\n+        }\n+", "originalCommit": "60b9d9884031ab0dbd8e68fd9d1867d05da526cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ5MTA3Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r553491077", "bodyText": "Capture->copy here too.\nAs we probably don't want to materialize a huge byte array for nothing, let's also add a getCopySize method and check it first in the caller.", "author": "efge", "createdAt": "2021-01-07T17:59:05Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/CopyingResponseWrapper.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.nio.file.Files;\n+\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpServletResponseWrapper;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.output.DeferredFileOutputStream;\n+\n+/**\n+ * Response wrapper that can capture response result, using a {@link DeferredFileOutputStream}.\n+ *\n+ * @since 11.5\n+ */\n+public class CopyingResponseWrapper extends HttpServletResponseWrapper implements AutoCloseable {\n+\n+    protected final DeferredFileOutputStream capture;\n+\n+    protected ServletOutputStream output;\n+\n+    protected PrintWriter writer;\n+\n+    public CopyingResponseWrapper(int threshold, HttpServletResponse response) {\n+        super(response);\n+        capture = new DeferredFileOutputStream(threshold, response.getBufferSize(), \"nxidem\", null, null);\n+    }\n+\n+    protected CopyingServletOutputStream getCopyingOutputStream() throws IOException {\n+        return new CopyingServletOutputStream(getResponse().getOutputStream(), capture);\n+    }\n+\n+    @Override\n+    public ServletOutputStream getOutputStream() throws IOException {\n+        if (writer != null) {\n+            throw new IllegalStateException(\"getWriter() has already been called on this response.\");\n+        }\n+\n+        if (output == null) {\n+            output = getCopyingOutputStream();\n+        }\n+\n+        return output;\n+    }\n+\n+    @Override\n+    public PrintWriter getWriter() throws IOException {\n+        if (output != null) {\n+            throw new IllegalStateException(\"getOutputStream() has already been called on this response.\");\n+        }\n+\n+        if (writer == null) {\n+            writer = new PrintWriter(new OutputStreamWriter(getCopyingOutputStream(), getCharacterEncoding()));\n+        }\n+\n+        return writer;\n+    }\n+\n+    @Override\n+    public void flushBuffer() throws IOException {\n+        super.flushBuffer();\n+\n+        if (writer != null) {\n+            writer.flush();\n+        } else if (output != null) {\n+            output.flush();\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        if (writer != null) {\n+            writer.close();\n+        } else if (output != null) {\n+            output.close();\n+        }\n+        if (!capture.isInMemory()) {\n+            // tmp file cleanup\n+            File file = capture.getFile();\n+            if (file != null) {\n+                Files.delete(file.toPath());\n+            }\n+        }\n+    }\n+\n+    public byte[] getCaptureAsBytes() throws IOException {", "originalCommit": "60b9d9884031ab0dbd8e68fd9d1867d05da526cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ5NjkzMw==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r553496933", "bodyText": "You have to set the header before sending the body, because in most cases (unless there's buffering, or in mocked classes) sending the body \"commits\" the response (see ServletResponse.isCommitted) and you can't set any header or status after that.", "author": "efge", "createdAt": "2021-01-07T18:09:57Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentFilter.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Set;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpFilter;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Filter handling an idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentFilter extends HttpFilter {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private static final Logger log = LogManager.getLogger(NuxeoIdempotentFilter.class);\n+\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.idempotency.keyvaluestore.name\";\n+\n+    public static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    protected static final Duration DEFAULT_TTL = Duration.ofDays(1);\n+\n+    public static final String TTL_DURATION_PROPERTY = \"org.nuxeo.request.idempotency.ttl.duration\";\n+\n+    public static final String INPROGRESS_MARKER = \"{\\\"inprogress\\\":true}\";\n+\n+    public static final String INFO_SUFFIX = \"_info\";\n+\n+    protected static final int DEFERRED_OUTPUT_STREAM_THRESHOLD = 1024 * 1024; // 1 MB\n+\n+    protected static final int MAX_CONTENT_SIZE = 1024 * 1024 * 5; // 5 MB\n+\n+    protected static final Set<String> IDEMPOTENT_METHODS = Set.of(\n+            // safe methods according to RFC 7231 4.2.1\n+            HttpGet.METHOD_NAME, HttpHead.METHOD_NAME, HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME,\n+            // idempotent methods according to RFC 7231 4.2.2\n+            HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME);\n+\n+    protected Duration getTTL() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getDuration(TTL_DURATION_PROPERTY, DEFAULT_TTL);\n+        }\n+        return DEFAULT_TTL;\n+    }\n+\n+    protected String getStoreName() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getString(STORE_PROPERTY, DEFAULT_STORE);\n+        }\n+        return DEFAULT_STORE;\n+    }\n+\n+    @Override\n+    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        if (!doFilterIdempotent(request, response, chain)) {\n+            chain.doFilter(request, response);\n+        }\n+    }\n+\n+    protected boolean doFilterIdempotent(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        String method = request.getMethod();\n+        if (IDEMPOTENT_METHODS.contains(method)) {\n+            log.debug(\"No idempotent processing done: method is already idempotent: {}\", method);\n+            return false;\n+        }\n+        String key = request.getHeader(HEADER_KEY);\n+        if (key == null) {\n+            log.debug(\"No idempotent processing done: no {} header present\", HEADER_KEY);\n+            return false;\n+        }\n+        log.debug(\"Idempotent request key: {}\", key);\n+        KeyValueService kvs = Framework.getService(KeyValueService.class);\n+        if (kvs == null) {\n+            log.debug(\"KeyValueService not present\");\n+            return false;\n+        }\n+        KeyValueStore store = kvs.getKeyValueStore(getStoreName());\n+        String storeStatus = store.getString(key + INFO_SUFFIX);\n+        byte[] storeContent = store.get(key);\n+        if (storeStatus == null) {\n+            log.debug(\"Handle new request for key: {}\", key);\n+            long ttl = getTTL().toSeconds();\n+            store.put(key + INFO_SUFFIX, INPROGRESS_MARKER, ttl);\n+            try {\n+                try (CopyingResponseWrapper wrapper = new CopyingResponseWrapper(DEFERRED_OUTPUT_STREAM_THRESHOLD,\n+                        response)) {\n+                    chain.doFilter(request, wrapper);\n+                    wrapper.flushBuffer();\n+                    byte[] content = wrapper.getCaptureAsBytes();\n+                    wrapper.setHeader(HEADER_KEY, key);\n+                    if (content.length > MAX_CONTENT_SIZE) {\n+                        log.debug(\n+                                \"Not storing response for key: {} (status: {}, size in bytes: {}), max content size exceeded: {}\",\n+                                key, wrapper.getStatus(), content.length, MAX_CONTENT_SIZE);\n+                        return true;\n+                    }\n+                    store.put(key, content, ttl);\n+                    store.put(key + INFO_SUFFIX, NuxeoIdempotentResponse.write(wrapper), ttl);\n+                    log.debug(\"Stored response for key: {} (status: {}, size in bytes: {})\", key, wrapper.getStatus(),\n+                            content.length);\n+                    return true;\n+                }\n+            } catch (IOException | ServletException e) {\n+                response.setHeader(HEADER_KEY, key);\n+                response.setStatus(SC_INTERNAL_SERVER_ERROR);\n+                throw e;\n+            } finally {\n+                if (response.getStatus() >= SC_BAD_REQUEST) {\n+                    // error request: cleanup store\n+                    store.put(key, (String) null);\n+                    store.put(key + INFO_SUFFIX, (String) null);\n+                    log.debug(\"Cleanup store: error for key: {}\", key);\n+                }\n+            }\n+        } else if (INPROGRESS_MARKER.equals(storeStatus)) {\n+            // request already in progress -> conflict\n+            // Don't call response.sendError, because it commits the response\n+            // which prevents NuxeoExceptionFilter from returning a custom error page.\n+            response.setStatus(SC_CONFLICT);\n+            response.setHeader(HEADER_KEY, key);\n+            log.debug(\"Conflict response for key: {}\", key);\n+            return true;\n+        } else {\n+            try {\n+                // request already done: return stored result\n+                NuxeoIdempotentResponse.restore(response, storeStatus.getBytes());\n+                response.getOutputStream().write(storeContent);\n+                response.setHeader(HEADER_KEY, key);", "originalCommit": "60b9d9884031ab0dbd8e68fd9d1867d05da526cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ5NzUxNg==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r553497516", "bodyText": "This should be wrapped with a if (!response.isCommitted())", "author": "efge", "createdAt": "2021-01-07T18:11:05Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentFilter.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Set;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpFilter;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Filter handling an idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentFilter extends HttpFilter {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private static final Logger log = LogManager.getLogger(NuxeoIdempotentFilter.class);\n+\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.idempotency.keyvaluestore.name\";\n+\n+    public static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    protected static final Duration DEFAULT_TTL = Duration.ofDays(1);\n+\n+    public static final String TTL_DURATION_PROPERTY = \"org.nuxeo.request.idempotency.ttl.duration\";\n+\n+    public static final String INPROGRESS_MARKER = \"{\\\"inprogress\\\":true}\";\n+\n+    public static final String INFO_SUFFIX = \"_info\";\n+\n+    protected static final int DEFERRED_OUTPUT_STREAM_THRESHOLD = 1024 * 1024; // 1 MB\n+\n+    protected static final int MAX_CONTENT_SIZE = 1024 * 1024 * 5; // 5 MB\n+\n+    protected static final Set<String> IDEMPOTENT_METHODS = Set.of(\n+            // safe methods according to RFC 7231 4.2.1\n+            HttpGet.METHOD_NAME, HttpHead.METHOD_NAME, HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME,\n+            // idempotent methods according to RFC 7231 4.2.2\n+            HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME);\n+\n+    protected Duration getTTL() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getDuration(TTL_DURATION_PROPERTY, DEFAULT_TTL);\n+        }\n+        return DEFAULT_TTL;\n+    }\n+\n+    protected String getStoreName() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getString(STORE_PROPERTY, DEFAULT_STORE);\n+        }\n+        return DEFAULT_STORE;\n+    }\n+\n+    @Override\n+    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        if (!doFilterIdempotent(request, response, chain)) {\n+            chain.doFilter(request, response);\n+        }\n+    }\n+\n+    protected boolean doFilterIdempotent(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        String method = request.getMethod();\n+        if (IDEMPOTENT_METHODS.contains(method)) {\n+            log.debug(\"No idempotent processing done: method is already idempotent: {}\", method);\n+            return false;\n+        }\n+        String key = request.getHeader(HEADER_KEY);\n+        if (key == null) {\n+            log.debug(\"No idempotent processing done: no {} header present\", HEADER_KEY);\n+            return false;\n+        }\n+        log.debug(\"Idempotent request key: {}\", key);\n+        KeyValueService kvs = Framework.getService(KeyValueService.class);\n+        if (kvs == null) {\n+            log.debug(\"KeyValueService not present\");\n+            return false;\n+        }\n+        KeyValueStore store = kvs.getKeyValueStore(getStoreName());\n+        String storeStatus = store.getString(key + INFO_SUFFIX);\n+        byte[] storeContent = store.get(key);\n+        if (storeStatus == null) {\n+            log.debug(\"Handle new request for key: {}\", key);\n+            long ttl = getTTL().toSeconds();\n+            store.put(key + INFO_SUFFIX, INPROGRESS_MARKER, ttl);\n+            try {\n+                try (CopyingResponseWrapper wrapper = new CopyingResponseWrapper(DEFERRED_OUTPUT_STREAM_THRESHOLD,\n+                        response)) {\n+                    chain.doFilter(request, wrapper);\n+                    wrapper.flushBuffer();\n+                    byte[] content = wrapper.getCaptureAsBytes();\n+                    wrapper.setHeader(HEADER_KEY, key);\n+                    if (content.length > MAX_CONTENT_SIZE) {\n+                        log.debug(\n+                                \"Not storing response for key: {} (status: {}, size in bytes: {}), max content size exceeded: {}\",\n+                                key, wrapper.getStatus(), content.length, MAX_CONTENT_SIZE);\n+                        return true;\n+                    }\n+                    store.put(key, content, ttl);\n+                    store.put(key + INFO_SUFFIX, NuxeoIdempotentResponse.write(wrapper), ttl);\n+                    log.debug(\"Stored response for key: {} (status: {}, size in bytes: {})\", key, wrapper.getStatus(),\n+                            content.length);\n+                    return true;\n+                }\n+            } catch (IOException | ServletException e) {\n+                response.setHeader(HEADER_KEY, key);\n+                response.setStatus(SC_INTERNAL_SERVER_ERROR);", "originalCommit": "60b9d9884031ab0dbd8e68fd9d1867d05da526cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ5ODE3Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r553498172", "bodyText": "You won't be able to set the header if the response is committed, which will usually be the case (unless buffering) after the flush. So maybe set before calling doFilter?", "author": "efge", "createdAt": "2021-01-07T18:12:25Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentFilter.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Set;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpFilter;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpHead;\n+import org.apache.http.client.methods.HttpOptions;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpTrace;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Filter handling an idempotency key in POST requests.\n+ * <p>\n+ * If {@link #HEADER_KEY} is found in the request header, will intercept request handling to:\n+ * <ul>\n+ * <li>mark the request as being processed\n+ * <li>capture the response when request was processed without any error and store it\n+ * <li>return the stored response if a subsequent request with the same key is processed again\n+ * <li>return a conflict response if a request with the same key is processed while the first request is still in\n+ * progress.\n+ * </ul>\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentFilter extends HttpFilter {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private static final Logger log = LogManager.getLogger(NuxeoIdempotentFilter.class);\n+\n+    public static final String HEADER_KEY = \"Idempotency-Key\";\n+\n+    public static final String STORE_PROPERTY = \"org.nuxeo.request.idempotency.keyvaluestore.name\";\n+\n+    public static final String DEFAULT_STORE = \"idempotentrequest\";\n+\n+    protected static final Duration DEFAULT_TTL = Duration.ofDays(1);\n+\n+    public static final String TTL_DURATION_PROPERTY = \"org.nuxeo.request.idempotency.ttl.duration\";\n+\n+    public static final String INPROGRESS_MARKER = \"{\\\"inprogress\\\":true}\";\n+\n+    public static final String INFO_SUFFIX = \"_info\";\n+\n+    protected static final int DEFERRED_OUTPUT_STREAM_THRESHOLD = 1024 * 1024; // 1 MB\n+\n+    protected static final int MAX_CONTENT_SIZE = 1024 * 1024 * 5; // 5 MB\n+\n+    protected static final Set<String> IDEMPOTENT_METHODS = Set.of(\n+            // safe methods according to RFC 7231 4.2.1\n+            HttpGet.METHOD_NAME, HttpHead.METHOD_NAME, HttpOptions.METHOD_NAME, HttpTrace.METHOD_NAME,\n+            // idempotent methods according to RFC 7231 4.2.2\n+            HttpPut.METHOD_NAME, HttpDelete.METHOD_NAME);\n+\n+    protected Duration getTTL() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getDuration(TTL_DURATION_PROPERTY, DEFAULT_TTL);\n+        }\n+        return DEFAULT_TTL;\n+    }\n+\n+    protected String getStoreName() {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        if (cs != null) {\n+            return cs.getString(STORE_PROPERTY, DEFAULT_STORE);\n+        }\n+        return DEFAULT_STORE;\n+    }\n+\n+    @Override\n+    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        if (!doFilterIdempotent(request, response, chain)) {\n+            chain.doFilter(request, response);\n+        }\n+    }\n+\n+    protected boolean doFilterIdempotent(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n+            throws IOException, ServletException {\n+        String method = request.getMethod();\n+        if (IDEMPOTENT_METHODS.contains(method)) {\n+            log.debug(\"No idempotent processing done: method is already idempotent: {}\", method);\n+            return false;\n+        }\n+        String key = request.getHeader(HEADER_KEY);\n+        if (key == null) {\n+            log.debug(\"No idempotent processing done: no {} header present\", HEADER_KEY);\n+            return false;\n+        }\n+        log.debug(\"Idempotent request key: {}\", key);\n+        KeyValueService kvs = Framework.getService(KeyValueService.class);\n+        if (kvs == null) {\n+            log.debug(\"KeyValueService not present\");\n+            return false;\n+        }\n+        KeyValueStore store = kvs.getKeyValueStore(getStoreName());\n+        String storeStatus = store.getString(key + INFO_SUFFIX);\n+        byte[] storeContent = store.get(key);\n+        if (storeStatus == null) {\n+            log.debug(\"Handle new request for key: {}\", key);\n+            long ttl = getTTL().toSeconds();\n+            store.put(key + INFO_SUFFIX, INPROGRESS_MARKER, ttl);\n+            try {\n+                try (CopyingResponseWrapper wrapper = new CopyingResponseWrapper(DEFERRED_OUTPUT_STREAM_THRESHOLD,\n+                        response)) {\n+                    chain.doFilter(request, wrapper);\n+                    wrapper.flushBuffer();\n+                    byte[] content = wrapper.getCaptureAsBytes();\n+                    wrapper.setHeader(HEADER_KEY, key);", "originalCommit": "60b9d9884031ab0dbd8e68fd9d1867d05da526cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUwMjE1NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r553502155", "bodyText": "Constants -> all-uppercase", "author": "efge", "createdAt": "2021-01-07T18:20:30Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentResponse.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+\n+/**\n+ * POJO representing response to be serialized and served by {@link NuxeoIdempotentFilter}.\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentResponse {\n+\n+    protected int status;\n+\n+    protected Map<String, Collection<String>> headers = new LinkedHashMap<>();\n+\n+    protected static final ObjectMapper mapper = //", "originalCommit": "60b9d9884031ab0dbd8e68fd9d1867d05da526cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUwMzA3MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r553503071", "bodyText": "I don't like write much. Maybe save instead?", "author": "efge", "createdAt": "2021-01-07T18:22:23Z", "path": "modules/platform/nuxeo-platform-web-common/src/main/java/org/nuxeo/ecm/platform/web/common/idempotency/NuxeoIdempotentResponse.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.common.idempotency;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+\n+/**\n+ * POJO representing response to be serialized and served by {@link NuxeoIdempotentFilter}.\n+ *\n+ * @since 11.5\n+ */\n+public class NuxeoIdempotentResponse {\n+\n+    protected int status;\n+\n+    protected Map<String, Collection<String>> headers = new LinkedHashMap<>();\n+\n+    protected static final ObjectMapper mapper = //\n+            new ObjectMapper().configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, true)\n+                              .configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS, true);\n+\n+    protected static final ObjectReader readMapper = mapper.readerFor(NuxeoIdempotentResponse.class)\n+                                                           .withoutRootName()\n+                                                           .without(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n+\n+    protected static final ObjectWriter writeMapper = mapper.writerFor(NuxeoIdempotentResponse.class)\n+                                                            .withoutRootName()\n+                                                            .with(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM)\n+                                                            .without(JsonGenerator.Feature.AUTO_CLOSE_TARGET);\n+\n+    public int getStatus() {\n+        return status;\n+    }\n+\n+    public void setStatus(int status) {\n+        this.status = status;\n+    }\n+\n+    public Map<String, Collection<String>> getHeaders() {\n+        return headers;\n+    }\n+\n+    public void setHeader(String name, Collection<String> value) {\n+        headers.put(name, value);\n+    }\n+\n+    public static final void restore(HttpServletResponse response, byte[] bytes) throws IOException {\n+        NuxeoIdempotentResponse stored = readMapper.readValue(bytes);\n+        response.setStatus(stored.getStatus());\n+        stored.getHeaders().forEach((name, values) -> {\n+            boolean isFirst = true;\n+            for (String value : values) {\n+                if (isFirst) {\n+                    response.setHeader(name, value);\n+                    isFirst = false;\n+                } else {\n+                    response.addHeader(name, value);\n+                }\n+            }\n+        });\n+    }\n+\n+    public static final byte[] write(HttpServletResponse response) throws JsonProcessingException {", "originalCommit": "60b9d9884031ab0dbd8e68fd9d1867d05da526cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9c1ed41079d557971026f4593adbae5eac5fd748", "url": "https://github.com/nuxeo/nuxeo/commit/9c1ed41079d557971026f4593adbae5eac5fd748", "message": "NXP-29978: add idempotent request filter", "committedDate": "2021-01-08T08:40:32Z", "type": "forcePushed"}, {"oid": "c62f92a76d6ab663695e59088ab7b78b3d8987d7", "url": "https://github.com/nuxeo/nuxeo/commit/c62f92a76d6ab663695e59088ab7b78b3d8987d7", "message": "NXP-29978: add idempotent request filter", "committedDate": "2021-01-12T11:42:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTgzMTQ3NA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r555831474", "bodyText": "FINAL_COPY_RESPONSE_HEADERS.keySet().removeAll(SKIPPED_HEADERS) instead for clarity?", "author": "efge", "createdAt": "2021-01-12T14:53:51Z", "path": "modules/platform/nuxeo-platform-web-common/src/test/java/org/nuxeo/ecm/platform/web/idempotency/TestNuxeoIdempotentFilter.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ecm.platform.web.idempotency;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static javax.servlet.http.HttpServletResponse.SC_OK;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyInt;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static org.nuxeo.ecm.platform.web.common.idempotency.NuxeoIdempotentResponse.SKIPPED_HEADERS;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.nuxeo.ecm.platform.web.common.idempotency.NuxeoIdempotentFilter;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStoreProvider;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.RuntimeFeature;\n+\n+/**\n+ * Checks idempotent requests management.\n+ *\n+ * @since 11.5\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(RuntimeFeature.class)\n+@Deploy(\"org.nuxeo.runtime.kv\")\n+@Deploy(\"org.nuxeo.ecm.platform.web.common:OSGI-INF/idempotency-configuration.xml\")\n+public class TestNuxeoIdempotentFilter {\n+\n+    protected static final String KEY = \"mykey\";\n+\n+    protected static final String CONTENT = \"test content\";\n+\n+    protected static final Map<String, Collection<String>> RESPONSE_HEADERS = new LinkedHashMap<>();\n+\n+    static {\n+        RESPONSE_HEADERS.put(\"Accept\", List.of(\"text/html\", \"application/xhtml+xml\", \"*/*;q=0.8\"));\n+        RESPONSE_HEADERS.put(\"Connection\", List.of(\"Keep-Alive\"));\n+        RESPONSE_HEADERS.put(\"Content-Encoding\", List.of(\"gzip\"));\n+        RESPONSE_HEADERS.put(\"Content-Type\", List.of(\"text/html; charset=utf-8\"));\n+        RESPONSE_HEADERS.put(\"Set-Cookie\", List.of(\"sessionId=38afes7a8\", \"id=a3fWa; Max-Age=2592000\"));\n+        RESPONSE_HEADERS.put(\"Transfer-Encoding\", List.of(\"chunked\")); // should be filtered\n+    }\n+\n+    protected static final Map<String, Collection<String>> KEY_RESPONSE_HEADERS = new LinkedHashMap<>();\n+\n+    static {\n+        KEY_RESPONSE_HEADERS.put(NuxeoIdempotentFilter.HEADER_KEY, List.of(KEY));\n+    }\n+\n+    protected static final Map<String, Collection<String>> FINAL_RESPONSE_HEADERS = new LinkedHashMap<>();\n+\n+    static {\n+        FINAL_RESPONSE_HEADERS.putAll(RESPONSE_HEADERS);\n+        FINAL_RESPONSE_HEADERS.putAll(KEY_RESPONSE_HEADERS);\n+    }\n+\n+    protected static final Map<String, Collection<String>> FINAL_COPY_RESPONSE_HEADERS = new LinkedHashMap<>();\n+\n+    static {\n+        FINAL_COPY_RESPONSE_HEADERS.putAll(FINAL_RESPONSE_HEADERS);\n+        SKIPPED_HEADERS.forEach(FINAL_COPY_RESPONSE_HEADERS::remove);", "originalCommit": "c62f92a76d6ab663695e59088ab7b78b3d8987d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "af2941afe51fe5dc050bd8e8804f48b8b6f7643f", "url": "https://github.com/nuxeo/nuxeo/commit/af2941afe51fe5dc050bd8e8804f48b8b6f7643f", "message": "NXP-29978: add idempotent request filter", "committedDate": "2021-01-12T15:15:54Z", "type": "forcePushed"}, {"oid": "656c458a341c83868279c7be3dbbe9d9f7a0a232", "url": "https://github.com/nuxeo/nuxeo/commit/656c458a341c83868279c7be3dbbe9d9f7a0a232", "message": "NXP-29978: add idempotent request filter", "committedDate": "2021-01-12T18:16:37Z", "type": "commit"}, {"oid": "656c458a341c83868279c7be3dbbe9d9f7a0a232", "url": "https://github.com/nuxeo/nuxeo/commit/656c458a341c83868279c7be3dbbe9d9f7a0a232", "message": "NXP-29978: add idempotent request filter", "committedDate": "2021-01-12T18:16:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI3OTgxNg==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r556279816", "bodyText": "How come? There should be no async jobs involved here, and I guess the transaction should always have been committed when getting  the answer from createDocument @kevinleturc?", "author": "ataillefer", "createdAt": "2021-01-13T05:58:33Z", "path": "ftests/nuxeo-server-tests/src/test/java/org/nuxeo/ftest/server/ITNuxeoIdempotentRequestTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * (C) Copyright 2021 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.ftest.server;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.nuxeo.ecm.platform.web.common.idempotency.NuxeoIdempotentFilter.HEADER_KEY;\n+import static org.nuxeo.functionaltests.AbstractTest.NUXEO_URL;\n+import static org.nuxeo.functionaltests.Constants.ADMINISTRATOR;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.junit.Test;\n+import org.nuxeo.client.NuxeoClient;\n+import org.nuxeo.client.objects.Document;\n+import org.nuxeo.ecm.core.query.sql.NXQL;\n+import org.nuxeo.ecm.platform.dublincore.constants.DublinCoreConstants;\n+import org.nuxeo.functionaltests.RestHelper.NuxeoClientForNuxeo;\n+\n+/**\n+ * Tests for idempotent request mechanism.\n+ *\n+ * @since 11.5\n+ */\n+public class ITNuxeoIdempotentRequestTest {\n+\n+    private static final String TEST_KEY = \"idempotenttestkey\" + new Date().getTime();\n+\n+    private static final NuxeoClient.Builder CLIENT_BUILDER = new NuxeoClientForNuxeo.BuilderForNuxeo().url(\n+            NUXEO_URL).authentication(ADMINISTRATOR, ADMINISTRATOR).schemas(\"*\");\n+\n+    private static final NuxeoClient CLIENT = CLIENT_BUILDER.connect();\n+\n+    private static final NuxeoClient IDEMPOTENT_CLIENT = CLIENT_BUILDER.header(HEADER_KEY, TEST_KEY).connect();\n+\n+    private static final String PARENT_PATH = \"/default-domain/workspaces/\";\n+\n+    private static final String QUERY_CHILDREN = String.format(\"SELECT * FROM Document WHERE %s STARTSWITH '%s'\",\n+            NXQL.ECM_PATH, PARENT_PATH);\n+\n+    private static final String TEST_TITLE = \"testdoc\";\n+\n+    private static final String TEST_TYPE = \"File\";\n+\n+    protected String createDocument(NuxeoClient client) {\n+        Document document = Document.createWithName(TEST_TITLE, TEST_TYPE);\n+        document.setProperties(Map.of(DublinCoreConstants.DUBLINCORE_TITLE_PROPERTY, TEST_TITLE));\n+        Document created = client.repository().createDocumentByPath(PARENT_PATH, document);\n+        waitForAsyncWork();\n+        return created.getId();\n+    }\n+\n+    /**\n+     * Prevents from random failures when counting children.", "originalCommit": "656c458a341c83868279c7be3dbbe9d9f7a0a232", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMwMjAzOA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r556302038", "bodyText": "The rest query API (used to count children) relies on the page provider REST_API_SEARCH_ADAPTER, using ElasticSearch and not the CoreSession, hence the need for this to avoid random failures.\nNote i needed this trick in Explorer ftests too, so i think this whole method would be useful on the RestHelper API.", "author": "atchertchian", "createdAt": "2021-01-13T07:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI3OTgxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM0ODcxOA==", "url": "https://github.com/nuxeo/nuxeo/pull/4545#discussion_r556348718", "bodyText": "And just to answer the fact that this would be needed to get the document id after creation: it's not.\nI'm just following a test pattern where the async jobs should be waited for after the action triggering them, as shutting down the test server while async jobs are still running is also exposing tests to random failures, with errors in logs, typically.", "author": "atchertchian", "createdAt": "2021-01-13T08:41:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI3OTgxNg=="}], "type": "inlineReview"}]}