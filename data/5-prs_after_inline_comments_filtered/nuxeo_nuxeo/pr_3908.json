{"pr_number": 3908, "pr_title": "Feature nxp 28839 explorer reorg", "pr_createdAt": "2020-04-09T14:09:18Z", "pr_url": "https://github.com/nuxeo/nuxeo/pull/3908", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE1Nzc3NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r408157775", "bodyText": "We have stopped testing login page for package tests if this is the only test, we rely on server start errors. Not sure if we want to introduce this one.", "author": "kevinleturc", "createdAt": "2020-04-14T13:58:34Z", "path": "ftests/nuxeo-platform-explorer-ftests/src/test/java/org/nuxeo/functionaltests/ITLoginLogoutTest.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * (C) Copyright 2014 Nuxeo SA (http://nuxeo.com/) and contributors.\n+ *\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the GNU Lesser General Public License\n+ * (LGPL) version 2.1 which accompanies this distribution, and is available at\n+ * http://www.gnu.org/licenses/lgpl-2.1.html\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * Contributors:\n+ *     Nuxeo\n+ */\n+package org.nuxeo.functionaltests;\n+\n+import static org.nuxeo.functionaltests.Constants.ADMINISTRATOR;\n+\n+import org.junit.Test;\n+import org.nuxeo.functionaltests.pages.DocumentBasePage.UserNotConnectedException;\n+\n+/**\n+ * Simple login, logout test.\n+ */\n+public class ITLoginLogoutTest extends AbstractTest {", "originalCommit": "9b17d39cc8017c94ddb3d78c83fe12e4f3f888b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3MTg0MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r408271840", "bodyText": "more are actually coming (currently working on these tests), and this one ensures that at least the explorer \"home\" page does not crash", "author": "atchertchian", "createdAt": "2020-04-14T16:28:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE1Nzc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMzNjI2Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r411336262", "bodyText": "i renamed the test class so that this basic test (which is useful imho) is run in the same class than others, sharing the same browser session", "author": "atchertchian", "createdAt": "2020-04-20T12:27:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE1Nzc3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE2NDcyMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r408164722", "bodyText": "Won't it be a problem to change the constructor for previous persisted data?", "author": "kevinleturc", "createdAt": "2020-04-14T14:07:23Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/introspection/RuntimeSnapshot.java", "diffHunk": "@@ -94,26 +95,29 @@\n \n     protected final List<Class<?>> spi = new ArrayList<>();\n \n+    protected boolean pluginSnapshotsInitialized = false;\n+\n+    protected final Map<String, PluginSnapshot<?>> pluginSnapshots = new HashMap<>();\n+\n     public static RuntimeSnapshot build() {\n         return new RuntimeSnapshot();\n     }\n \n     @JsonCreator\n     private RuntimeSnapshot(@JsonProperty(\"serverInfo\") ServerInfo serverInfo,\n-            @JsonProperty(\"creationDate\") Date created,\n-            @JsonProperty(\"seamComponents\") List<SeamComponentInfo> seamComponents,\n-            @JsonProperty(\"operations\") List<OperationInfo> operations) {\n+            @JsonProperty(\"creationDate\") Date created, @JsonProperty(\"operations\") List<OperationInfo> operations,\n+            @JsonProperty(\"pluginSnapshots\") Map<String, PluginSnapshot<?>> pluginSnapshots) {\n         this.serverInfo = serverInfo;\n         this.created = created;\n         index();\n-        this.seamComponents.addAll(seamComponents);\n         this.operations.addAll(operations);\n+        opsInitialized = true;\n+        this.pluginSnapshots.putAll(pluginSnapshots);\n     }", "originalCommit": "9b17d39cc8017c94ddb3d78c83fe12e4f3f888b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3NDIzMA==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r408274230", "bodyText": "actually the json export is completely buggy and was never exposed publicly, only in tests... i'm working on exposing it, so i will fix it (without compatibility with previous format, then) -- more commits coming about this in the same PR (as i realized the problem when adding more unit tests)", "author": "atchertchian", "createdAt": "2020-04-14T16:31:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE2NDcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMzODYzMA==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r411338630", "bodyText": "note i modified to the parser so that it's resilient to \"unknown\" fields at read time, and i will attach an old json serialization for history in the jira issue", "author": "atchertchian", "createdAt": "2020-04-20T12:31:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE2NDcyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE2NjgyNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r408166825", "bodyText": "It should be elsewhere as it doesn't use anything from current object, in a factory class maybe?", "author": "kevinleturc", "createdAt": "2020-04-14T14:10:11Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/introspection/RuntimeSnapshot.java", "diffHunk": "@@ -611,4 +564,48 @@ public boolean isLatestLTS() {\n     public boolean isHidden() {\n         return false;\n     }\n-}\n+\n+    protected List<Plugin<?>> getPlugins() {\n+        return Framework.getService(SnapshotManager.class).getPlugins();\n+    }", "originalCommit": "9b17d39cc8017c94ddb3d78c83fe12e4f3f888b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5NzgxMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r408297812", "bodyText": "it's just a helper method (protected) to retrieve plugins here", "author": "atchertchian", "createdAt": "2020-04-14T17:07:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE2NjgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0OTUyNw==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r410349527", "bodyText": "kept it as used in 2 occurences in this class", "author": "atchertchian", "createdAt": "2020-04-17T16:55:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE2NjgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3MTEwMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r408171102", "bodyText": "This looks like service and not data and doesn't use anything from the current object.", "author": "kevinleturc", "createdAt": "2020-04-14T14:15:54Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/introspection/RuntimeSnapshot.java", "diffHunk": "@@ -611,4 +564,48 @@ public boolean isLatestLTS() {\n     public boolean isHidden() {\n         return false;\n     }\n-}\n+\n+    protected List<Plugin<?>> getPlugins() {\n+        return Framework.getService(SnapshotManager.class).getPlugins();\n+    }\n+\n+    @Override\n+    public ObjectMapper getJsonMapper() {\n+        ObjectMapper mapper = DistributionSnapshot.jsonMapper();\n+        for (Plugin<?> plugin : getPlugins()) {\n+            mapper = plugin.getJsonMapper(mapper);\n+        }\n+        return mapper;\n+    }\n+\n+    @Override\n+    public ObjectWriter getJsonWriter() {\n+        return getJsonMapper().writerFor(DistributionSnapshot.class)\n+                              .withoutRootName()\n+                              .with(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM)\n+                              .without(JsonGenerator.Feature.AUTO_CLOSE_TARGET);\n+    }\n+\n+    @Override\n+    public ObjectReader getJsonReader() {\n+        return getJsonMapper().readerFor(DistributionSnapshot.class)\n+                              .withoutRootName()\n+                              .without(JsonParser.Feature.AUTO_CLOSE_SOURCE)\n+                              .with(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT);\n+    }", "originalCommit": "9b17d39cc8017c94ddb3d78c83fe12e4f3f888b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5NjY3MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r408296671", "bodyText": "it's for plugin extending the parent mapper: they need to contribute to the mapper", "author": "atchertchian", "createdAt": "2020-04-14T17:05:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3MTEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NDc2Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r410344766", "bodyText": "i changed the reader and writer api so that they do apply to current object, i hope it's better like this", "author": "atchertchian", "createdAt": "2020-04-17T16:46:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3MTEwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3NDU5NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r408174595", "bodyText": "I would suggest renaming the method enrichJsonMapper and provide a default implementation which returns the given ObjectMapper like the abstract does.", "author": "kevinleturc", "createdAt": "2020-04-14T14:20:30Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/plugin/Plugin.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.apidoc.plugin;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+import org.nuxeo.apidoc.api.NuxeoArtifact;\n+import org.nuxeo.apidoc.snapshot.DistributionSnapshot;\n+import org.nuxeo.apidoc.snapshot.SnapshotFilter;\n+import org.nuxeo.apidoc.snapshot.SnapshotManager;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Interface for plugins to the {@link SnapshotManager} service, handling specific runtime introspections and their\n+ * persistence.\n+ *\n+ * @since 11.1\n+ */\n+public interface Plugin<T extends NuxeoArtifact> {\n+\n+    /**\n+     * Returns the plugin unique identifier.\n+     */\n+    String getId();\n+\n+    /**\n+     * Returns the plugin label, to be displayed in the UI (if not hidden).\n+     */\n+    String getLabel();\n+\n+    /**\n+     * Returns the plugin webengine type contributed to the main webengine module ((if not hidden).\n+     * <p>\n+     * The corresponding class should be annotated with @WebObject and given type.\n+     * <p>\n+     * It should extend DefaultObject and implement an #initialize method taking the distribution id as first parameter,\n+     * and an optional boolean specifiying if the distribution is embedded as an options second parameter.\n+     */\n+    String getViewType();\n+\n+    /**\n+     * Returns the home view URL for navigation in the UI (if not hidden).\n+     */\n+    String getHomeView();\n+\n+    /**\n+     * Provides navigation mapping, to handle tab selection in the UI.\n+     */\n+    String getView(String url);\n+\n+    /**\n+     * Returns the style class to be used in the UI menu (if not hidden).\n+     */\n+    String getStyleClass();\n+\n+    /**\n+     * Specifies whether the plugin should be displayed in the UI.\n+     */\n+    boolean isHidden();\n+\n+    /**\n+     * Contributes to the parent object mapper, to handle serialization of local introspection.\n+     */\n+    ObjectMapper getJsonMapper(ObjectMapper parent);", "originalCommit": "9b17d39cc8017c94ddb3d78c83fe12e4f3f888b6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3OTkyOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r408179929", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Map<String, PluginSnapshot<?>> res = new HashMap<>();\n          \n          \n            \n                    getPlugins().forEach(plugin -> res.put(plugin.getId(), plugin.getRepositorySnapshot(getDoc())));\n          \n          \n            \n                    return res;\n          \n          \n            \n                    return Framework.getService(SnapshotManager.class)\n          \n          \n            \n                                    .getPlugins()\n          \n          \n            \n                                    .stream()\n          \n          \n            \n                                    .collect(Collectors.toMap(Descriptor::getId, p -> p.getRepositorySnapshot(getDoc())));", "author": "kevinleturc", "createdAt": "2020-04-14T14:27:23Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/repository/RepositoryDistributionSnapshot.java", "diffHunk": "@@ -464,4 +443,41 @@ public boolean isHidden() {\n     public ServerInfo getServerInfo() {\n         throw new UnsupportedOperationException();\n     }\n-}\n+\n+    protected List<Plugin<?>> getPlugins() {\n+        return Framework.getService(SnapshotManager.class).getPlugins();\n+    }\n+\n+    @Override\n+    public ObjectMapper getJsonMapper() {\n+        ObjectMapper mapper = DistributionSnapshot.jsonMapper();\n+        for (Plugin<?> plugin : getPlugins()) {\n+            mapper = plugin.getJsonMapper(mapper);\n+        }\n+        return mapper;\n+    }\n+\n+    @Override\n+    public ObjectWriter getJsonWriter() {\n+        return getJsonMapper().writerFor(RepositoryDistributionSnapshot.class)\n+                              .withoutRootName()\n+                              .with(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM)\n+                              .without(JsonGenerator.Feature.AUTO_CLOSE_TARGET);\n+    }\n+\n+    @Override\n+    public ObjectReader getJsonReader() {\n+        return getJsonMapper().readerFor(RepositoryDistributionSnapshot.class)\n+                              .withoutRootName()\n+                              .without(JsonParser.Feature.AUTO_CLOSE_SOURCE)\n+                              .with(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT);\n+    }\n+\n+    @Override\n+    public Map<String, PluginSnapshot<?>> getPluginSnapshots() {\n+        Map<String, PluginSnapshot<?>> res = new HashMap<>();\n+        getPlugins().forEach(plugin -> res.put(plugin.getId(), plugin.getRepositorySnapshot(getDoc())));\n+        return res;", "originalCommit": "9b17d39cc8017c94ddb3d78c83fe12e4f3f888b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5ODkzOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r408298939", "bodyText": "ok \ud83d\udc4d  even if i don't really see what it brings (?)", "author": "atchertchian", "createdAt": "2020-04-14T17:09:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3OTkyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4MDA5NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r408180095", "bodyText": "No new line at the end.", "author": "kevinleturc", "createdAt": "2020-04-14T14:27:33Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/repository/RepositoryDistributionSnapshot.java", "diffHunk": "@@ -464,4 +443,41 @@ public boolean isHidden() {\n     public ServerInfo getServerInfo() {\n         throw new UnsupportedOperationException();\n     }\n-}\n+\n+    protected List<Plugin<?>> getPlugins() {\n+        return Framework.getService(SnapshotManager.class).getPlugins();\n+    }\n+\n+    @Override\n+    public ObjectMapper getJsonMapper() {\n+        ObjectMapper mapper = DistributionSnapshot.jsonMapper();\n+        for (Plugin<?> plugin : getPlugins()) {\n+            mapper = plugin.getJsonMapper(mapper);\n+        }\n+        return mapper;\n+    }\n+\n+    @Override\n+    public ObjectWriter getJsonWriter() {\n+        return getJsonMapper().writerFor(RepositoryDistributionSnapshot.class)\n+                              .withoutRootName()\n+                              .with(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM)\n+                              .without(JsonGenerator.Feature.AUTO_CLOSE_TARGET);\n+    }\n+\n+    @Override\n+    public ObjectReader getJsonReader() {\n+        return getJsonMapper().readerFor(RepositoryDistributionSnapshot.class)\n+                              .withoutRootName()\n+                              .without(JsonParser.Feature.AUTO_CLOSE_SOURCE)\n+                              .with(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT);\n+    }\n+\n+    @Override\n+    public Map<String, PluginSnapshot<?>> getPluginSnapshots() {\n+        Map<String, PluginSnapshot<?>> res = new HashMap<>();\n+        getPlugins().forEach(plugin -> res.put(plugin.getId(), plugin.getRepositorySnapshot(getDoc())));\n+        return res;\n+    }\n+\n+}", "originalCommit": "9b17d39cc8017c94ddb3d78c83fe12e4f3f888b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5OTMxMQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r408299311", "bodyText": "if only it was my only pb with this module...", "author": "atchertchian", "createdAt": "2020-04-14T17:10:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4MDA5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4NDM3Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r408184372", "bodyText": "You should use ReflectiveOperationException.", "author": "kevinleturc", "createdAt": "2020-04-14T14:32:59Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/snapshot/SnapshotManagerComponent.java", "diffHunk": "@@ -339,4 +361,38 @@ protected void beforeCreateDocument(DocumentModel doc) {\n         }\n     }\n \n-}\n+    @Override\n+    public List<Plugin<?>> getPlugins() {\n+        return new ArrayList<>(plugins.values());\n+    }\n+\n+    @Override\n+    public Plugin<?> getPlugin(String id) {\n+        return plugins.get(id);\n+    }\n+\n+    @Override\n+    public void start(ComponentContext context) {\n+        super.start(context);\n+        plugins.clear();\n+        List<PluginDescriptor> descriptors = getDescriptors(XP_PLUGINS);\n+        for (PluginDescriptor descriptor : descriptors) {\n+            try {\n+                Class<?> clazz = Class.forName(descriptor.getKlass());\n+                Constructor<?> constructor = clazz.getConstructor(PluginDescriptor.class);\n+                Plugin<?> plugin = (Plugin<?>) constructor.newInstance(descriptor);\n+                plugins.put(descriptor.getId(), plugin);\n+            } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | IllegalArgumentException", "originalCommit": "9b17d39cc8017c94ddb3d78c83fe12e4f3f888b6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4NjYxNg==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r408186616", "bodyText": "Could you add a message stating the culprit plugin id?\nWhat do you think about adding this error to the runtime warning messages in order to block server boot in non lenient mode?", "author": "kevinleturc", "createdAt": "2020-04-14T14:35:54Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/snapshot/SnapshotManagerComponent.java", "diffHunk": "@@ -339,4 +361,38 @@ protected void beforeCreateDocument(DocumentModel doc) {\n         }\n     }\n \n-}\n+    @Override\n+    public List<Plugin<?>> getPlugins() {\n+        return new ArrayList<>(plugins.values());\n+    }\n+\n+    @Override\n+    public Plugin<?> getPlugin(String id) {\n+        return plugins.get(id);\n+    }\n+\n+    @Override\n+    public void start(ComponentContext context) {\n+        super.start(context);\n+        plugins.clear();\n+        List<PluginDescriptor> descriptors = getDescriptors(XP_PLUGINS);\n+        for (PluginDescriptor descriptor : descriptors) {\n+            try {\n+                Class<?> clazz = Class.forName(descriptor.getKlass());\n+                Constructor<?> constructor = clazz.getConstructor(PluginDescriptor.class);\n+                Plugin<?> plugin = (Plugin<?>) constructor.newInstance(descriptor);\n+                plugins.put(descriptor.getId(), plugin);\n+            } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | IllegalArgumentException\n+                    | InvocationTargetException | NoSuchMethodException | SecurityException e) {\n+                log.error(e, e);", "originalCommit": "9b17d39cc8017c94ddb3d78c83fe12e4f3f888b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3NDU5NA==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r408274594", "bodyText": "why not indeed, will do \ud83d\udc4d", "author": "atchertchian", "createdAt": "2020-04-14T16:32:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4NjYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4ODc2Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r408188767", "bodyText": "Maybe unmodifiableList?", "author": "kevinleturc", "createdAt": "2020-04-14T14:38:39Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/snapshot/SnapshotManagerComponent.java", "diffHunk": "@@ -339,4 +361,38 @@ protected void beforeCreateDocument(DocumentModel doc) {\n         }\n     }\n \n-}\n+    @Override\n+    public List<Plugin<?>> getPlugins() {\n+        return new ArrayList<>(plugins.values());", "originalCommit": "9b17d39cc8017c94ddb3d78c83fe12e4f3f888b6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4OTk2NA==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r408189964", "bodyText": "You can depend on RuntimeSnaphotFeature and remove two deploys.", "author": "kevinleturc", "createdAt": "2020-04-14T14:40:07Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-repo/src/test/java/org/nuxeo/apidoc/test/RuntimeSnaphotRepoFeature.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * (C) Copyright 2012-2013 Nuxeo SA (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.apidoc.test;\n+\n+import org.nuxeo.ecm.automation.test.AutomationFeature;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.ecm.core.test.annotations.Granularity;\n+import org.nuxeo.ecm.core.test.annotations.RepositoryConfig;\n+import org.nuxeo.elasticsearch.test.RepositoryElasticSearchFeature;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.RunnerFeature;\n+\n+/**\n+ * @since 8.3\n+ */\n+@Features({ CoreFeature.class, RepositoryElasticSearchFeature.class, AutomationFeature.class })\n+@RepositoryConfig(cleanup = Granularity.METHOD)\n+@Deploy(\"org.nuxeo.apidoc.core\")\n+@Deploy(\"org.nuxeo.apidoc.repo\")\n+@Deploy(\"org.nuxeo.apidoc.repo:apidoc-works-test-contrib.xml\")\n+public class RuntimeSnaphotRepoFeature implements RunnerFeature {", "originalCommit": "9b17d39cc8017c94ddb3d78c83fe12e4f3f888b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3NTU0NA==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r408275544", "bodyText": "indeed, thx -- and actually: i created the \"non repo\" one since the startup is faster, but there are missing extension points when running it --> do we have any good practices to follow in that kind of cases please?", "author": "atchertchian", "createdAt": "2020-04-14T16:33:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4OTk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0OTA5MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r410349090", "bodyText": "gave up on this change anyway: i need the repo in all tests", "author": "atchertchian", "createdAt": "2020-04-17T16:54:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4OTk2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2MTc0OA==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r408261748", "bodyText": "Could be ApiBrowsers as there's a method + final + private constructor.", "author": "kevinleturc", "createdAt": "2020-04-14T16:13:27Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-webengine/src/main/java/org/nuxeo/apidoc/browse/ApiBrowserConstants.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.apidoc.browse;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class ApiBrowserConstants {", "originalCommit": "9b17d39cc8017c94ddb3d78c83fe12e4f3f888b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3NjEzMA==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r408276130", "bodyText": "wdym? changing the class name?", "author": "atchertchian", "createdAt": "2020-04-14T16:34:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2MTc0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MDI1Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r410350256", "bodyText": "this is pure cleanup and i don't find the new name better --> kept it as is, please tell if that's an issue", "author": "atchertchian", "createdAt": "2020-04-17T16:56:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2MTc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2NjQ2NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r408266465", "bodyText": "Missing copyright", "author": "kevinleturc", "createdAt": "2020-04-14T16:20:21Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-webengine/src/test/java/org/nuxeo/apidoc/browse/DistributionTest.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package org.nuxeo.apidoc.browse;", "originalCommit": "9b17d39cc8017c94ddb3d78c83fe12e4f3f888b6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8b44a6fe46c1449e16f899eebc5297b9046ca996", "url": "https://github.com/nuxeo/nuxeo/commit/8b44a6fe46c1449e16f899eebc5297b9046ca996", "message": "NXP-28839: extract constants", "committedDate": "2020-04-17T16:24:20Z", "type": "forcePushed"}, {"oid": "4d6d7f4550b942f5b0deb871d793eabe858ab406", "url": "https://github.com/nuxeo/nuxeo/commit/4d6d7f4550b942f5b0deb871d793eabe858ab406", "message": "NXP-28839: rework json export of the runtime snapshot (not implemented for repo)\nCompatibility on format was not kept as export was not used except in tests.", "committedDate": "2020-04-17T16:26:57Z", "type": "forcePushed"}, {"oid": "d5d0799b41eda446d9e68ea33881587217712c47", "url": "https://github.com/nuxeo/nuxeo/commit/d5d0799b41eda446d9e68ea33881587217712c47", "message": "NXP-28839: rework json export of the runtime snapshot (not implemented for repo)\nCompatibility on format was not kept as export was not used except in tests.", "committedDate": "2020-04-17T16:37:33Z", "type": "forcePushed"}, {"oid": "2fda3ffb589beda671041d811be0e4b34e0260ef", "url": "https://github.com/nuxeo/nuxeo/commit/2fda3ffb589beda671041d811be0e4b34e0260ef", "message": "NXP-28839: rework json export of the runtime snapshot (not implemented for persisted distributions).\nCompatibility on format was not kept as export was not used except in tests.", "committedDate": "2020-04-20T08:34:32Z", "type": "forcePushed"}, {"oid": "7baf40fc499bc76f22eac2863ac23157ffea0100", "url": "https://github.com/nuxeo/nuxeo/commit/7baf40fc499bc76f22eac2863ac23157ffea0100", "message": "NXP-28839: rework json export of the runtime snapshot (not implemented for persisted distributions).\nCompatibility on format was not kept as export was not used except in tests.", "committedDate": "2020-04-20T08:38:45Z", "type": "forcePushed"}, {"oid": "24ea0ba563962b575068e7288b34fb80b6a266c3", "url": "https://github.com/nuxeo/nuxeo/commit/24ea0ba563962b575068e7288b34fb80b6a266c3", "message": "NXP-28839: rework json export of the runtime snapshot (not implemented for persisted distributions).\nCompatibility on format was not kept as export was not used except in tests.", "committedDate": "2020-04-20T10:25:51Z", "type": "forcePushed"}, {"oid": "fdad1cfb1798c74bc806271db9b8ca585d1027d8", "url": "https://github.com/nuxeo/nuxeo/commit/fdad1cfb1798c74bc806271db9b8ca585d1027d8", "message": "NXP-28839: adapt explorer ftests", "committedDate": "2020-04-20T10:29:32Z", "type": "forcePushed"}, {"oid": "0f09091e58f2eab14b6d99456eb31b4a83deacc6", "url": "https://github.com/nuxeo/nuxeo/commit/0f09091e58f2eab14b6d99456eb31b4a83deacc6", "message": "NXP-28839: adapt explorer ftests", "committedDate": "2020-04-20T11:03:10Z", "type": "forcePushed"}, {"oid": "5fd242ecdffceaaca985d159dbd2b4cba46a3c60", "url": "https://github.com/nuxeo/nuxeo/commit/5fd242ecdffceaaca985d159dbd2b4cba46a3c60", "message": "NXP-28839: adapt explorer ftests", "committedDate": "2020-04-20T13:01:24Z", "type": "forcePushed"}, {"oid": "a62a8ee1dd8c766af2b0bc50f4f9c6ce809871fa", "url": "https://github.com/nuxeo/nuxeo/commit/a62a8ee1dd8c766af2b0bc50f4f9c6ce809871fa", "message": "NXP-28839: add functional tests", "committedDate": "2020-04-20T17:12:20Z", "type": "forcePushed"}, {"oid": "3c03fde52a59a67463da1264ad3133e3210c5d04", "url": "https://github.com/nuxeo/nuxeo/commit/3c03fde52a59a67463da1264ad3133e3210c5d04", "message": "NXP-28839: add functional tests", "committedDate": "2020-04-20T17:16:02Z", "type": "forcePushed"}, {"oid": "a97867928c10358a6ea63d6eae8b3b8e91521799", "url": "https://github.com/nuxeo/nuxeo/commit/a97867928c10358a6ea63d6eae8b3b8e91521799", "message": "NXP-28839: add functional tests", "committedDate": "2020-04-20T17:20:04Z", "type": "forcePushed"}, {"oid": "ab4d535f198ac4abb3a2a00e304b113d34990b26", "url": "https://github.com/nuxeo/nuxeo/commit/ab4d535f198ac4abb3a2a00e304b113d34990b26", "message": "NXP-28839: add functional tests", "committedDate": "2020-04-20T18:15:40Z", "type": "forcePushed"}, {"oid": "401f698d2735898fb848cbe1144093c2605e5a60", "url": "https://github.com/nuxeo/nuxeo/commit/401f698d2735898fb848cbe1144093c2605e5a60", "message": "NXP-28839: add functional tests", "committedDate": "2020-04-20T20:24:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk2NjA5Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r411966092", "bodyText": "You could rely on @Before for this one.", "author": "akervern", "createdAt": "2020-04-21T08:06:46Z", "path": "ftests/nuxeo-platform-explorer-ftests/src/test/java/org/nuxeo/functionaltests/explorer/ITExplorerTest.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * (C) Copyright 2014-2020 Nuxeo SA (http://nuxeo.com/) and contributors.\n+ *\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the GNU Lesser General Public License\n+ * (LGPL) version 2.1 which accompanies this distribution, and is available at\n+ * http://www.gnu.org/licenses/lgpl-2.1.html\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * Contributors:\n+ *     Nuxeo\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.functionaltests.explorer;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.nuxeo.functionaltests.AbstractTest;\n+import org.nuxeo.functionaltests.Locator;\n+import org.nuxeo.functionaltests.RestHelper;\n+import org.nuxeo.functionaltests.explorer.pages.ArtifactHomePage;\n+import org.nuxeo.functionaltests.explorer.pages.ArtifactPage;\n+import org.nuxeo.functionaltests.explorer.pages.ExplorerHomePage;\n+import org.nuxeo.functionaltests.pages.DocumentBasePage.UserNotConnectedException;\n+import org.openqa.selenium.By;\n+import org.openqa.selenium.WebElement;\n+\n+/**\n+ * Test explorer main webengine pages.\n+ *\n+ * @since 11.1\n+ */\n+public class ITExplorerTest extends AbstractTest {\n+\n+    @Before\n+    public void before() {\n+        RestHelper.createUser(TEST_USERNAME, TEST_PASSWORD, null, null, null, null, \"members\");\n+    }\n+\n+    @After\n+    public void after() {\n+        RestHelper.cleanup();\n+    }\n+\n+    protected void doLogin() {", "originalCommit": "627f1a0934df8e48defa817e5b8fbe558da53c3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAwNzY4Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412007682", "bodyText": "thanks indeed, although i sometimes log in as admin user instead, so i'll take that option in next PRs (more ftests are coming for admin user for https://jira.nuxeo.com/browse/NXP-20246)", "author": "atchertchian", "createdAt": "2020-04-21T09:03:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk2NjA5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjEyMzEwOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412123109", "bodyText": "Actually i got confused with JSF tests (similar logics, but one additional test checking admin center), will do here \ud83d\udc4d", "author": "atchertchian", "createdAt": "2020-04-21T12:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk2NjA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk2NjI3OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r411966279", "bodyText": "and @After for this guy", "author": "akervern", "createdAt": "2020-04-21T08:07:02Z", "path": "ftests/nuxeo-platform-explorer-ftests/src/test/java/org/nuxeo/functionaltests/explorer/ITExplorerTest.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * (C) Copyright 2014-2020 Nuxeo SA (http://nuxeo.com/) and contributors.\n+ *\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the GNU Lesser General Public License\n+ * (LGPL) version 2.1 which accompanies this distribution, and is available at\n+ * http://www.gnu.org/licenses/lgpl-2.1.html\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * Contributors:\n+ *     Nuxeo\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.functionaltests.explorer;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.nuxeo.functionaltests.AbstractTest;\n+import org.nuxeo.functionaltests.Locator;\n+import org.nuxeo.functionaltests.RestHelper;\n+import org.nuxeo.functionaltests.explorer.pages.ArtifactHomePage;\n+import org.nuxeo.functionaltests.explorer.pages.ArtifactPage;\n+import org.nuxeo.functionaltests.explorer.pages.ExplorerHomePage;\n+import org.nuxeo.functionaltests.pages.DocumentBasePage.UserNotConnectedException;\n+import org.openqa.selenium.By;\n+import org.openqa.selenium.WebElement;\n+\n+/**\n+ * Test explorer main webengine pages.\n+ *\n+ * @since 11.1\n+ */\n+public class ITExplorerTest extends AbstractTest {\n+\n+    @Before\n+    public void before() {\n+        RestHelper.createUser(TEST_USERNAME, TEST_PASSWORD, null, null, null, null, \"members\");\n+    }\n+\n+    @After\n+    public void after() {\n+        RestHelper.cleanup();\n+    }\n+\n+    protected void doLogin() {\n+        getLoginPage().login(TEST_USERNAME, TEST_PASSWORD);\n+    }\n+\n+    protected void doLogout() {", "originalCommit": "627f1a0934df8e48defa817e5b8fbe558da53c3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAwODUxOA==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412008518", "bodyText": "will do with https://jira.nuxeo.com/browse/NXP-20246 \ud83d\udc4d (see last test as admin)", "author": "atchertchian", "createdAt": "2020-04-21T09:04:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk2NjI3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwNzM2NA==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412807364", "bodyText": "(done, see previous conversation)", "author": "atchertchian", "createdAt": "2020-04-22T09:06:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk2NjI3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk2ODAxMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r411968012", "bodyText": "What comes first in my mind seeing all those tests; you should use some Class (like ArtifactHomePage) and accessors to make it more understandable instead of relying on direct selectors to By.xpath and consosr.", "author": "akervern", "createdAt": "2020-04-21T08:09:36Z", "path": "ftests/nuxeo-platform-explorer-ftests/src/test/java/org/nuxeo/functionaltests/explorer/ITExplorerTest.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * (C) Copyright 2014-2020 Nuxeo SA (http://nuxeo.com/) and contributors.\n+ *\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the GNU Lesser General Public License\n+ * (LGPL) version 2.1 which accompanies this distribution, and is available at\n+ * http://www.gnu.org/licenses/lgpl-2.1.html\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * Contributors:\n+ *     Nuxeo\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.functionaltests.explorer;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.nuxeo.functionaltests.AbstractTest;\n+import org.nuxeo.functionaltests.Locator;\n+import org.nuxeo.functionaltests.RestHelper;\n+import org.nuxeo.functionaltests.explorer.pages.ArtifactHomePage;\n+import org.nuxeo.functionaltests.explorer.pages.ArtifactPage;\n+import org.nuxeo.functionaltests.explorer.pages.ExplorerHomePage;\n+import org.nuxeo.functionaltests.pages.DocumentBasePage.UserNotConnectedException;\n+import org.openqa.selenium.By;\n+import org.openqa.selenium.WebElement;\n+\n+/**\n+ * Test explorer main webengine pages.\n+ *\n+ * @since 11.1\n+ */\n+public class ITExplorerTest extends AbstractTest {\n+\n+    @Before\n+    public void before() {\n+        RestHelper.createUser(TEST_USERNAME, TEST_PASSWORD, null, null, null, null, \"members\");\n+    }\n+\n+    @After\n+    public void after() {\n+        RestHelper.cleanup();\n+    }\n+\n+    protected void doLogin() {\n+        getLoginPage().login(TEST_USERNAME, TEST_PASSWORD);\n+    }\n+\n+    protected void doLogout() {\n+        // logout avoiding JS error check\n+        driver.get(NUXEO_URL + \"/logout\");\n+    }\n+\n+    protected ExplorerHomePage goHome() {\n+        open(ExplorerHomePage.URL);\n+        return asPage(ExplorerHomePage.class);\n+    }\n+\n+    /**\n+     * Simple login, logout test, checking the home page is displayed without errors after login.\n+     */\n+    @Test\n+    public void testLoginLogout() throws UserNotConnectedException {\n+        doLogin();\n+        goHome();\n+        doLogout();\n+    }\n+\n+    @Test\n+    public void testHomePage() throws UserNotConnectedException {\n+        doLogin();\n+        ExplorerHomePage home = goHome();\n+        assertEquals(\"Nuxeo Platform Explorer\", home.getTitle());\n+        assertEquals(\"Running Platform\".toUpperCase(), home.currentPlatform.getText());\n+\n+        ArtifactHomePage ahome = home.navigateTo(home.currentExtensionPoints);\n+        assertEquals(\"All extension points\", ahome.getTitle());\n+        ahome = goHome().navigateTo(home.currentContributions);\n+        assertEquals(\"All contributions\", ahome.getTitle());\n+        ahome = goHome().navigateTo(home.currentExtensionPoints);\n+        assertEquals(\"All extension points\", ahome.getTitle());\n+        ahome = goHome().navigateTo(home.currentOperations);\n+        assertEquals(\"All operations\", ahome.getTitle());\n+        ahome = goHome().navigateTo(home.currentServices);\n+        assertEquals(\"All services\", ahome.getTitle());\n+\n+        doLogout();\n+    }\n+\n+    @Test\n+    public void testExtensionPoints() throws UserNotConnectedException {\n+        doLogin();\n+        ExplorerHomePage home = goHome();\n+        ArtifactHomePage ahome = home.navigateTo(home.currentExtensionPoints);\n+        assertTrue(ahome.isSelected(ahome.extensionPoints));\n+        WebElement elt = ahome.getFirstListingElement();\n+        WebElement link = elt.findElement(By.xpath(\".//a\"));", "originalCommit": "627f1a0934df8e48defa817e5b8fbe558da53c3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAxMzEyOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412013129", "bodyText": "I agree it is not that consistent: i just wanted to have quick ftests here, because the selectors depend on the page, so i'd rather make ftl files more consistent to ease up test classes maintenance (that's why i kept it kind of hardcoded here).\nAlso note i'll make some visual changes with https://jira.nuxeo.com/browse/NXP-28913, so i can try to work on this at the same time if it makes sense.", "author": "atchertchian", "createdAt": "2020-04-21T09:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk2ODAxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjEyNTg2Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412125867", "bodyText": "will do with https://jira.nuxeo.com/browse/NXP-28913", "author": "atchertchian", "createdAt": "2020-04-21T12:06:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk2ODAxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE1ODQzNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r413158435", "bodyText": "see #3959 (draft PR waiting for this PR merge on master)", "author": "atchertchian", "createdAt": "2020-04-22T17:04:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk2ODAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk3MzkwNg==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r411973906", "bodyText": "For the future, instead of having a private constructor for json deserialization; you should consider using libray like Google AutoValue (see: google/auto#138 (comment)) for not having to maintain a constructor with every attribute.", "author": "akervern", "createdAt": "2020-04-21T08:17:56Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/introspection/ComponentInfoImpl.java", "diffHunk": "@@ -71,8 +74,18 @@\n     public ComponentInfoImpl(BundleInfo bundleInfo, String name) {\n         bundle = bundleInfo;\n         this.name = name;\n-        extensionPoints = new HashMap<>();\n-        extensions = new ArrayList<>();\n+    }\n+\n+    @JsonCreator", "originalCommit": "627f1a0934df8e48defa817e5b8fbe558da53c3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjEyNjI0OA==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412126248", "bodyText": "will have a look with https://jira.nuxeo.com/browse/NXP-28838 (which entails more json serializations)", "author": "atchertchian", "createdAt": "2020-04-21T12:07:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk3MzkwNg=="}], "type": "inlineReview"}, {"oid": "0dd06c038580d3b997713cef71e06bcfa5d1636e", "url": "https://github.com/nuxeo/nuxeo/commit/0dd06c038580d3b997713cef71e06bcfa5d1636e", "message": "NXP-28839: add functional tests", "committedDate": "2020-04-22T08:50:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkyNDY0Mw==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412924643", "bodyText": "List#sort(Comparator) is preferred to avoid importing Collections.", "author": "kevinleturc", "createdAt": "2020-04-22T12:09:10Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/introspection/RuntimeSnapshot.java", "diffHunk": "@@ -505,49 +473,22 @@ public void initOperations() {\n             return;\n         }\n         OperationType[] ops = service.getOperations();\n-        for (OperationType op : ops) {\n+        // make sure operations are ordered, as service currently returns any order\n+        List<OperationType> oops = Arrays.asList(ops);\n+        Collections.sort(oops, Comparator.comparing(OperationType::getId));", "originalCommit": "0dd06c038580d3b997713cef71e06bcfa5d1636e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzAwNDQxNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r413004415", "bodyText": "There are lots of calls to Collections#sort for lists in this code (including in this PR), do you mean i should change them all?\nNote also i followed the same advice than at #3882 (comment)", "author": "atchertchian", "createdAt": "2020-04-22T13:55:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkyNDY0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzAwNTc3Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r413005777", "bodyText": "I think the advice was on comparator no?\nI would suggest doing it on the new code and replace old code if wanted.", "author": "kevinleturc", "createdAt": "2020-04-22T13:56:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkyNDY0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzAwODg3Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r413008872", "bodyText": "Well it suggested that Collections.sort was ok for lists, still.\nBut I will do the changes.", "author": "atchertchian", "createdAt": "2020-04-22T14:00:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkyNDY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkzNjQ5Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412936496", "bodyText": "Missing newline", "author": "kevinleturc", "createdAt": "2020-04-22T12:26:59Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/introspection/RuntimeSnapshot.java", "diffHunk": "@@ -587,28 +528,82 @@ public void cleanPreviousArtifacts() {\n     }\n \n     @Override\n-    @JsonIgnore\n     public boolean isLatestFT() {\n         return false;\n     }\n \n     @Override\n-    @JsonIgnore\n     public boolean isLatestLTS() {\n         return false;\n     }\n \n-    final List<String> aliases = new LinkedList<>(Collections.singletonList(\"current\"));\n-\n     @Override\n-    @JsonIgnore\n     public List<String> getAliases() {\n         return aliases;\n     }\n \n     @Override\n-    @JsonIgnore\n     public boolean isHidden() {\n         return false;\n     }\n-}\n+\n+    protected List<Plugin<?>> getPlugins() {\n+        return Framework.getService(SnapshotManager.class).getPlugins();\n+    }\n+\n+    @Override\n+    public ObjectMapper getJsonMapper() {\n+        ObjectMapper mapper = DistributionSnapshot.jsonMapper();\n+        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+        for (Plugin<?> plugin : getPlugins()) {\n+            mapper = plugin.enrishJsonMapper(mapper);\n+        }\n+        return mapper;\n+    }\n+\n+    @Override\n+    public void writeJson(OutputStream out) {\n+        ObjectWriter writer = getJsonMapper().writerFor(DistributionSnapshot.class)\n+                                             .withoutRootName()\n+                                             .with(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM)\n+                                             .without(JsonGenerator.Feature.AUTO_CLOSE_TARGET);\n+        try {\n+            writer.writeValue(out, this);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public DistributionSnapshot readJson(InputStream in) {\n+        ObjectReader reader = getJsonMapper().readerFor(DistributionSnapshot.class)\n+                                             .withoutRootName()\n+                                             .without(JsonParser.Feature.AUTO_CLOSE_SOURCE)\n+                                             .with(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT);\n+        try {\n+            return reader.readValue(in);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    protected void initPluginSnapshots() {\n+        if (pluginSnapshotsInitialized) {\n+            return;\n+        }\n+        getPlugins().forEach(plugin -> pluginSnapshots.put(plugin.getId(), plugin.getRuntimeSnapshot(this)));\n+        pluginSnapshotsInitialized = true;\n+    }\n+\n+    @Override\n+    public Map<String, PluginSnapshot<?>> getPluginSnapshots() {\n+        initPluginSnapshots();\n+        return Collections.unmodifiableMap(pluginSnapshots);\n+    }\n+\n+    @Override\n+    public List<BundleInfo> getBundles() {\n+        return Collections.unmodifiableList(new ArrayList<>(bundles.values()));\n+    }\n+\n+}", "originalCommit": "0dd06c038580d3b997713cef71e06bcfa5d1636e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkzNjg5Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412936897", "bodyText": "List#sort usage.", "author": "kevinleturc", "createdAt": "2020-04-22T12:27:38Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/introspection/ServerInfo.java", "diffHunk": "@@ -163,15 +162,18 @@ public String getVersion() {\n         return version;\n     }\n \n-    public Collection<BundleInfo> getBundles() {\n-        return bundles.values();\n+    public List<BundleInfo> getBundles() {\n+        List<BundleInfo> res = new ArrayList<>(bundles.values());\n+        // order by name for deterministic processing\n+        Collections.sort(res, Comparator.comparing(BundleInfo::getId));", "originalCommit": "0dd06c038580d3b997713cef71e06bcfa5d1636e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk0MTA5MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412941090", "bodyText": "extra ,?", "author": "kevinleturc", "createdAt": "2020-04-22T12:33:43Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/snapshot/SnapshotManagerComponent.java", "diffHunk": "@@ -339,4 +356,42 @@ protected void beforeCreateDocument(DocumentModel doc) {\n         }\n     }\n \n-}\n+    @Override\n+    public List<Plugin<?>> getPlugins() {\n+        return Collections.unmodifiableList(new ArrayList<>(plugins.values()));\n+    }\n+\n+    @Override\n+    public Plugin<?> getPlugin(String id) {\n+        return plugins.get(id);\n+    }\n+\n+    @Override\n+    public void start(ComponentContext context) {\n+        super.start(context);\n+        plugins.clear();\n+        List<PluginDescriptor> descriptors = getDescriptors(XP_PLUGINS);\n+        for (PluginDescriptor descriptor : descriptors) {\n+            try {\n+                Class<?> clazz = Class.forName(descriptor.getKlass());\n+                Constructor<?> constructor = clazz.getConstructor(PluginDescriptor.class);\n+                Plugin<?> plugin = (Plugin<?>) constructor.newInstance(descriptor);\n+                plugins.put(descriptor.getId(), plugin);\n+            } catch (ReflectiveOperationException e) {\n+                String msg = String.format(\n+                        \"Failed to register plugin with id '%s' on '%s': error initializing class '%s' (%s).\",\n+                        descriptor.getId(), name, descriptor.getKlass(), e.toString());\n+                ;", "originalCommit": "0dd06c038580d3b997713cef71e06bcfa5d1636e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk0MTMwMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412941302", "bodyText": "No newline", "author": "kevinleturc", "createdAt": "2020-04-22T12:34:04Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/snapshot/SnapshotManagerComponent.java", "diffHunk": "@@ -339,4 +356,42 @@ protected void beforeCreateDocument(DocumentModel doc) {\n         }\n     }\n \n-}\n+    @Override\n+    public List<Plugin<?>> getPlugins() {\n+        return Collections.unmodifiableList(new ArrayList<>(plugins.values()));\n+    }\n+\n+    @Override\n+    public Plugin<?> getPlugin(String id) {\n+        return plugins.get(id);\n+    }\n+\n+    @Override\n+    public void start(ComponentContext context) {\n+        super.start(context);\n+        plugins.clear();\n+        List<PluginDescriptor> descriptors = getDescriptors(XP_PLUGINS);\n+        for (PluginDescriptor descriptor : descriptors) {\n+            try {\n+                Class<?> clazz = Class.forName(descriptor.getKlass());\n+                Constructor<?> constructor = clazz.getConstructor(PluginDescriptor.class);\n+                Plugin<?> plugin = (Plugin<?>) constructor.newInstance(descriptor);\n+                plugins.put(descriptor.getId(), plugin);\n+            } catch (ReflectiveOperationException e) {\n+                String msg = String.format(\n+                        \"Failed to register plugin with id '%s' on '%s': error initializing class '%s' (%s).\",\n+                        descriptor.getId(), name, descriptor.getKlass(), e.toString());\n+                ;\n+                log.error(msg, e);\n+                Framework.getRuntime().getMessageHandler().addError(msg);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void stop(ComponentContext context) throws InterruptedException {\n+        super.stop(context);\n+        plugins.clear();\n+    }\n+\n+}", "originalCommit": "0dd06c038580d3b997713cef71e06bcfa5d1636e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk0NTYzNg==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412945636", "bodyText": "Could be:\nString latest = snaps.stream()\n                      .filter(snap -> snap.getName().toLowerCase().startsWith(\"nuxeo platform\"))\n                      .map(DistributionSnapshot::getKey)\n                      .findFirst()\n                      .orElse(\"current\");", "author": "kevinleturc", "createdAt": "2020-04-22T12:40:18Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-webengine/src/main/java/org/nuxeo/apidoc/browse/Distribution.java", "diffHunk": "@@ -0,0 +1,593 @@\n+/*\n+ * (C) Copyright 2006-2015 Nuxeo SA (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Thierry Delprat\n+ */\n+package org.nuxeo.apidoc.browse;\n+\n+import static org.nuxeo.apidoc.snapshot.DistributionSnapshot.PROP_RELEASED;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.text.ParseException;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.naming.NamingException;\n+import javax.transaction.HeuristicMixedException;\n+import javax.transaction.HeuristicRollbackException;\n+import javax.transaction.NotSupportedException;\n+import javax.transaction.RollbackException;\n+import javax.transaction.SystemException;\n+import javax.transaction.UserTransaction;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.nuxeo.apidoc.documentation.DocumentationService;\n+import org.nuxeo.apidoc.export.ArchiveFile;\n+import org.nuxeo.apidoc.listener.AttributesExtractorStater;\n+import org.nuxeo.apidoc.plugin.Plugin;\n+import org.nuxeo.apidoc.snapshot.DistributionSnapshot;\n+import org.nuxeo.apidoc.snapshot.DistributionSnapshotDesc;\n+import org.nuxeo.apidoc.snapshot.SnapshotFilter;\n+import org.nuxeo.apidoc.snapshot.SnapshotManager;\n+import org.nuxeo.apidoc.snapshot.SnapshotManagerComponent;\n+import org.nuxeo.apidoc.snapshot.SnapshotResolverHelper;\n+import org.nuxeo.apidoc.worker.ExtractXmlAttributesWorker;\n+import org.nuxeo.common.Environment;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IterableQueryResult;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n+import org.nuxeo.ecm.core.query.QueryFilter;\n+import org.nuxeo.ecm.core.query.sql.NXQL;\n+import org.nuxeo.ecm.core.work.api.Work;\n+import org.nuxeo.ecm.core.work.api.WorkManager;\n+import org.nuxeo.ecm.webengine.forms.FormData;\n+import org.nuxeo.ecm.webengine.model.Resource;\n+import org.nuxeo.ecm.webengine.model.WebObject;\n+import org.nuxeo.ecm.webengine.model.exceptions.WebResourceNotFoundException;\n+import org.nuxeo.ecm.webengine.model.impl.ModuleRoot;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.transaction.TransactionHelper;\n+\n+@Path(\"/distribution\")\n+// needed for 5.4.1\n+@WebObject(type = \"distribution\")\n+public class Distribution extends ModuleRoot {\n+\n+    public static final String DIST_ID = \"distId\";\n+\n+    protected static final Log log = LogFactory.getLog(Distribution.class);\n+\n+    protected static final Pattern VERSION_REGEX = Pattern.compile(\"^(\\\\d+)(?:\\\\.(\\\\d+))?(?:\\\\.(\\\\d+))?(?:-.*)?$\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // handle errors\n+    @Override\n+    public Object handleError(Throwable t) {\n+        if (t instanceof WebResourceNotFoundException) {\n+            return Response.status(404).entity(getTemplate(\"error/error_404.ftl\")).type(\"text/html\").build();\n+        } else {\n+            return super.handleError(t);\n+        }\n+    }\n+\n+    protected SnapshotManager getSnapshotManager() {\n+        return Framework.getService(SnapshotManager.class);\n+    }\n+\n+    public String getNavigationPoint() {\n+        String url = getContext().getURL();\n+        String point = null;\n+        if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_BUNDLEGROUPS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_BUNDLEGROUP)) {\n+            point = ApiBrowserConstants.LIST_BUNDLEGROUPS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_BUNDLES)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_BUNDLE)) {\n+            point = ApiBrowserConstants.LIST_BUNDLES;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_COMPONENTS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_COMPONENT)) {\n+            point = ApiBrowserConstants.LIST_COMPONENTS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_SERVICES)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_SERVICE)) {\n+            point = ApiBrowserConstants.LIST_SERVICES;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_EXTENSIONPOINTS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_EXTENSIONPOINT)) {\n+            point = ApiBrowserConstants.LIST_EXTENSIONPOINTS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_CONTRIBUTIONS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_CONTRIBUTION)) {\n+            point = ApiBrowserConstants.LIST_CONTRIBUTIONS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_OPERATIONS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_OPERATION)) {\n+            point = ApiBrowserConstants.LIST_OPERATIONS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_DOCUMENTATION)) {\n+            point = ApiBrowserConstants.VIEW_DOCUMENTATION;\n+        }\n+        if (point == null) {\n+            // check plugins\n+            List<Plugin<?>> plugins = getSnapshotManager().getPlugins();\n+            for (Plugin<?> plugin : plugins) {\n+                point = plugin.getView(url);\n+                if (point != null) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return point;\n+    }\n+\n+    @GET\n+    @Produces(\"text/html\")\n+    public Object doGet() {\n+        return getView(\"index\").arg(\"hideNav\", Boolean.TRUE);\n+    }\n+\n+    @Path(\"latest\")\n+    public Resource getLatest() {\n+        List<DistributionSnapshot> snaps = listPersistedDistributions();\n+        Optional<DistributionSnapshot> distribution = snaps.stream()\n+                                                           .filter(snap -> snap.getName()\n+                                                                               .toLowerCase()\n+                                                                               .startsWith(\"nuxeo platform\"))\n+                                                           .findFirst();\n+\n+        String latest = \"current\";\n+        if (distribution.isPresent()) {\n+            latest = distribution.get().getKey();\n+        }", "originalCommit": "0dd06c038580d3b997713cef71e06bcfa5d1636e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk3NjU2Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412976562", "bodyText": "indeed but i only moved that code -> i would prefer not modifying it to avoid unforeseen regressions in these logics", "author": "atchertchian", "createdAt": "2020-04-22T13:21:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk0NTYzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk0NjQyNw==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412946427", "bodyText": "You could use StringUtils#isBlank.", "author": "kevinleturc", "createdAt": "2020-04-22T12:41:20Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-webengine/src/main/java/org/nuxeo/apidoc/browse/Distribution.java", "diffHunk": "@@ -0,0 +1,593 @@\n+/*\n+ * (C) Copyright 2006-2015 Nuxeo SA (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Thierry Delprat\n+ */\n+package org.nuxeo.apidoc.browse;\n+\n+import static org.nuxeo.apidoc.snapshot.DistributionSnapshot.PROP_RELEASED;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.text.ParseException;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.naming.NamingException;\n+import javax.transaction.HeuristicMixedException;\n+import javax.transaction.HeuristicRollbackException;\n+import javax.transaction.NotSupportedException;\n+import javax.transaction.RollbackException;\n+import javax.transaction.SystemException;\n+import javax.transaction.UserTransaction;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.nuxeo.apidoc.documentation.DocumentationService;\n+import org.nuxeo.apidoc.export.ArchiveFile;\n+import org.nuxeo.apidoc.listener.AttributesExtractorStater;\n+import org.nuxeo.apidoc.plugin.Plugin;\n+import org.nuxeo.apidoc.snapshot.DistributionSnapshot;\n+import org.nuxeo.apidoc.snapshot.DistributionSnapshotDesc;\n+import org.nuxeo.apidoc.snapshot.SnapshotFilter;\n+import org.nuxeo.apidoc.snapshot.SnapshotManager;\n+import org.nuxeo.apidoc.snapshot.SnapshotManagerComponent;\n+import org.nuxeo.apidoc.snapshot.SnapshotResolverHelper;\n+import org.nuxeo.apidoc.worker.ExtractXmlAttributesWorker;\n+import org.nuxeo.common.Environment;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IterableQueryResult;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n+import org.nuxeo.ecm.core.query.QueryFilter;\n+import org.nuxeo.ecm.core.query.sql.NXQL;\n+import org.nuxeo.ecm.core.work.api.Work;\n+import org.nuxeo.ecm.core.work.api.WorkManager;\n+import org.nuxeo.ecm.webengine.forms.FormData;\n+import org.nuxeo.ecm.webengine.model.Resource;\n+import org.nuxeo.ecm.webengine.model.WebObject;\n+import org.nuxeo.ecm.webengine.model.exceptions.WebResourceNotFoundException;\n+import org.nuxeo.ecm.webengine.model.impl.ModuleRoot;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.transaction.TransactionHelper;\n+\n+@Path(\"/distribution\")\n+// needed for 5.4.1\n+@WebObject(type = \"distribution\")\n+public class Distribution extends ModuleRoot {\n+\n+    public static final String DIST_ID = \"distId\";\n+\n+    protected static final Log log = LogFactory.getLog(Distribution.class);\n+\n+    protected static final Pattern VERSION_REGEX = Pattern.compile(\"^(\\\\d+)(?:\\\\.(\\\\d+))?(?:\\\\.(\\\\d+))?(?:-.*)?$\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // handle errors\n+    @Override\n+    public Object handleError(Throwable t) {\n+        if (t instanceof WebResourceNotFoundException) {\n+            return Response.status(404).entity(getTemplate(\"error/error_404.ftl\")).type(\"text/html\").build();\n+        } else {\n+            return super.handleError(t);\n+        }\n+    }\n+\n+    protected SnapshotManager getSnapshotManager() {\n+        return Framework.getService(SnapshotManager.class);\n+    }\n+\n+    public String getNavigationPoint() {\n+        String url = getContext().getURL();\n+        String point = null;\n+        if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_BUNDLEGROUPS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_BUNDLEGROUP)) {\n+            point = ApiBrowserConstants.LIST_BUNDLEGROUPS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_BUNDLES)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_BUNDLE)) {\n+            point = ApiBrowserConstants.LIST_BUNDLES;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_COMPONENTS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_COMPONENT)) {\n+            point = ApiBrowserConstants.LIST_COMPONENTS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_SERVICES)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_SERVICE)) {\n+            point = ApiBrowserConstants.LIST_SERVICES;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_EXTENSIONPOINTS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_EXTENSIONPOINT)) {\n+            point = ApiBrowserConstants.LIST_EXTENSIONPOINTS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_CONTRIBUTIONS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_CONTRIBUTION)) {\n+            point = ApiBrowserConstants.LIST_CONTRIBUTIONS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_OPERATIONS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_OPERATION)) {\n+            point = ApiBrowserConstants.LIST_OPERATIONS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_DOCUMENTATION)) {\n+            point = ApiBrowserConstants.VIEW_DOCUMENTATION;\n+        }\n+        if (point == null) {\n+            // check plugins\n+            List<Plugin<?>> plugins = getSnapshotManager().getPlugins();\n+            for (Plugin<?> plugin : plugins) {\n+                point = plugin.getView(url);\n+                if (point != null) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return point;\n+    }\n+\n+    @GET\n+    @Produces(\"text/html\")\n+    public Object doGet() {\n+        return getView(\"index\").arg(\"hideNav\", Boolean.TRUE);\n+    }\n+\n+    @Path(\"latest\")\n+    public Resource getLatest() {\n+        List<DistributionSnapshot> snaps = listPersistedDistributions();\n+        Optional<DistributionSnapshot> distribution = snaps.stream()\n+                                                           .filter(snap -> snap.getName()\n+                                                                               .toLowerCase()\n+                                                                               .startsWith(\"nuxeo platform\"))\n+                                                           .findFirst();\n+\n+        String latest = \"current\";\n+        if (distribution.isPresent()) {\n+            latest = distribution.get().getKey();\n+        }\n+        return ctx.newObject(\"redirectWO\", \"latest\", latest);\n+    }\n+\n+    @Path(\"{distributionId}\")\n+    public Resource viewDistribution(@PathParam(\"distributionId\") String distributionId) {\n+        if (distributionId == null || \"\".equals(distributionId)) {\n+            return this;\n+        }\n+\n+        List<DistributionSnapshot> snaps = getSnapshotManager().listPersistentSnapshots((ctx.getCoreSession()));\n+        if (distributionId.matches(VERSION_REGEX.toString())) {\n+            String finalDistributionId = distributionId;\n+            String distribution = snaps.stream()\n+                                       .filter(s -> s.getVersion().equals(finalDistributionId))\n+                                       .findFirst()\n+                                       .map(DistributionSnapshot::getKey)\n+                                       .orElse(\"current\");\n+\n+            return ctx.newObject(\"redirectWO\", finalDistributionId, distribution);\n+        }\n+\n+        String orgDistributionId = distributionId;\n+        Boolean embeddedMode = Boolean.FALSE;\n+        if (\"adm\".equals(distributionId)) {\n+            embeddedMode = Boolean.TRUE;\n+        } else {\n+            snaps.add(getSnapshotManager().getRuntimeSnapshot());\n+            distributionId = SnapshotResolverHelper.findBestMatch(snaps, distributionId);\n+        }\n+        if (distributionId == null || \"\".equals(distributionId)) {", "originalCommit": "0dd06c038580d3b997713cef71e06bcfa5d1636e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk3Njc2OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412976769", "bodyText": "indeed but i only moved that code -> i would prefer not modifying it to avoid unforeseen regressions in these logics", "author": "atchertchian", "createdAt": "2020-04-22T13:21:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk0NjQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk0NzA5Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412947097", "bodyText": "With log4j2:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        log.info(String.format(\"Comparing version using String between %s - %s\", o1.getVersion(), o2.getVersion()));\n          \n          \n            \n                        log.info(\"Comparing version using String between {} - {}\", o1::getVersion, o2::getVersion);", "author": "kevinleturc", "createdAt": "2020-04-22T12:42:10Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-webengine/src/main/java/org/nuxeo/apidoc/browse/Distribution.java", "diffHunk": "@@ -0,0 +1,593 @@\n+/*\n+ * (C) Copyright 2006-2015 Nuxeo SA (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Thierry Delprat\n+ */\n+package org.nuxeo.apidoc.browse;\n+\n+import static org.nuxeo.apidoc.snapshot.DistributionSnapshot.PROP_RELEASED;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.text.ParseException;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.naming.NamingException;\n+import javax.transaction.HeuristicMixedException;\n+import javax.transaction.HeuristicRollbackException;\n+import javax.transaction.NotSupportedException;\n+import javax.transaction.RollbackException;\n+import javax.transaction.SystemException;\n+import javax.transaction.UserTransaction;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.nuxeo.apidoc.documentation.DocumentationService;\n+import org.nuxeo.apidoc.export.ArchiveFile;\n+import org.nuxeo.apidoc.listener.AttributesExtractorStater;\n+import org.nuxeo.apidoc.plugin.Plugin;\n+import org.nuxeo.apidoc.snapshot.DistributionSnapshot;\n+import org.nuxeo.apidoc.snapshot.DistributionSnapshotDesc;\n+import org.nuxeo.apidoc.snapshot.SnapshotFilter;\n+import org.nuxeo.apidoc.snapshot.SnapshotManager;\n+import org.nuxeo.apidoc.snapshot.SnapshotManagerComponent;\n+import org.nuxeo.apidoc.snapshot.SnapshotResolverHelper;\n+import org.nuxeo.apidoc.worker.ExtractXmlAttributesWorker;\n+import org.nuxeo.common.Environment;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IterableQueryResult;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n+import org.nuxeo.ecm.core.query.QueryFilter;\n+import org.nuxeo.ecm.core.query.sql.NXQL;\n+import org.nuxeo.ecm.core.work.api.Work;\n+import org.nuxeo.ecm.core.work.api.WorkManager;\n+import org.nuxeo.ecm.webengine.forms.FormData;\n+import org.nuxeo.ecm.webengine.model.Resource;\n+import org.nuxeo.ecm.webengine.model.WebObject;\n+import org.nuxeo.ecm.webengine.model.exceptions.WebResourceNotFoundException;\n+import org.nuxeo.ecm.webengine.model.impl.ModuleRoot;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.transaction.TransactionHelper;\n+\n+@Path(\"/distribution\")\n+// needed for 5.4.1\n+@WebObject(type = \"distribution\")\n+public class Distribution extends ModuleRoot {\n+\n+    public static final String DIST_ID = \"distId\";\n+\n+    protected static final Log log = LogFactory.getLog(Distribution.class);\n+\n+    protected static final Pattern VERSION_REGEX = Pattern.compile(\"^(\\\\d+)(?:\\\\.(\\\\d+))?(?:\\\\.(\\\\d+))?(?:-.*)?$\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // handle errors\n+    @Override\n+    public Object handleError(Throwable t) {\n+        if (t instanceof WebResourceNotFoundException) {\n+            return Response.status(404).entity(getTemplate(\"error/error_404.ftl\")).type(\"text/html\").build();\n+        } else {\n+            return super.handleError(t);\n+        }\n+    }\n+\n+    protected SnapshotManager getSnapshotManager() {\n+        return Framework.getService(SnapshotManager.class);\n+    }\n+\n+    public String getNavigationPoint() {\n+        String url = getContext().getURL();\n+        String point = null;\n+        if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_BUNDLEGROUPS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_BUNDLEGROUP)) {\n+            point = ApiBrowserConstants.LIST_BUNDLEGROUPS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_BUNDLES)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_BUNDLE)) {\n+            point = ApiBrowserConstants.LIST_BUNDLES;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_COMPONENTS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_COMPONENT)) {\n+            point = ApiBrowserConstants.LIST_COMPONENTS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_SERVICES)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_SERVICE)) {\n+            point = ApiBrowserConstants.LIST_SERVICES;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_EXTENSIONPOINTS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_EXTENSIONPOINT)) {\n+            point = ApiBrowserConstants.LIST_EXTENSIONPOINTS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_CONTRIBUTIONS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_CONTRIBUTION)) {\n+            point = ApiBrowserConstants.LIST_CONTRIBUTIONS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_OPERATIONS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_OPERATION)) {\n+            point = ApiBrowserConstants.LIST_OPERATIONS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_DOCUMENTATION)) {\n+            point = ApiBrowserConstants.VIEW_DOCUMENTATION;\n+        }\n+        if (point == null) {\n+            // check plugins\n+            List<Plugin<?>> plugins = getSnapshotManager().getPlugins();\n+            for (Plugin<?> plugin : plugins) {\n+                point = plugin.getView(url);\n+                if (point != null) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return point;\n+    }\n+\n+    @GET\n+    @Produces(\"text/html\")\n+    public Object doGet() {\n+        return getView(\"index\").arg(\"hideNav\", Boolean.TRUE);\n+    }\n+\n+    @Path(\"latest\")\n+    public Resource getLatest() {\n+        List<DistributionSnapshot> snaps = listPersistedDistributions();\n+        Optional<DistributionSnapshot> distribution = snaps.stream()\n+                                                           .filter(snap -> snap.getName()\n+                                                                               .toLowerCase()\n+                                                                               .startsWith(\"nuxeo platform\"))\n+                                                           .findFirst();\n+\n+        String latest = \"current\";\n+        if (distribution.isPresent()) {\n+            latest = distribution.get().getKey();\n+        }\n+        return ctx.newObject(\"redirectWO\", \"latest\", latest);\n+    }\n+\n+    @Path(\"{distributionId}\")\n+    public Resource viewDistribution(@PathParam(\"distributionId\") String distributionId) {\n+        if (distributionId == null || \"\".equals(distributionId)) {\n+            return this;\n+        }\n+\n+        List<DistributionSnapshot> snaps = getSnapshotManager().listPersistentSnapshots((ctx.getCoreSession()));\n+        if (distributionId.matches(VERSION_REGEX.toString())) {\n+            String finalDistributionId = distributionId;\n+            String distribution = snaps.stream()\n+                                       .filter(s -> s.getVersion().equals(finalDistributionId))\n+                                       .findFirst()\n+                                       .map(DistributionSnapshot::getKey)\n+                                       .orElse(\"current\");\n+\n+            return ctx.newObject(\"redirectWO\", finalDistributionId, distribution);\n+        }\n+\n+        String orgDistributionId = distributionId;\n+        Boolean embeddedMode = Boolean.FALSE;\n+        if (\"adm\".equals(distributionId)) {\n+            embeddedMode = Boolean.TRUE;\n+        } else {\n+            snaps.add(getSnapshotManager().getRuntimeSnapshot());\n+            distributionId = SnapshotResolverHelper.findBestMatch(snaps, distributionId);\n+        }\n+        if (distributionId == null || \"\".equals(distributionId)) {\n+            distributionId = \"current\";\n+        }\n+\n+        if (!orgDistributionId.equals(distributionId)) {\n+            return ctx.newObject(\"redirectWO\", orgDistributionId, distributionId);\n+        }\n+\n+        ctx.setProperty(\"embeddedMode\", embeddedMode);\n+        ctx.setProperty(\"distribution\", getSnapshotManager().getSnapshot(distributionId, ctx.getCoreSession()));\n+        ctx.setProperty(DIST_ID, distributionId);\n+        return ctx.newObject(\"apibrowser\", distributionId, embeddedMode);\n+    }\n+\n+    public List<DistributionSnapshotDesc> getAvailableDistributions() {\n+        return getSnapshotManager().getAvailableDistributions(ctx.getCoreSession());\n+    }\n+\n+    public String getRuntimeDistributionName() {\n+        return SnapshotManagerComponent.RUNTIME;\n+    }\n+\n+    public DistributionSnapshot getRuntimeDistribution() {\n+        return getSnapshotManager().getRuntimeSnapshot();\n+    }\n+\n+    public List<DistributionSnapshot> listPersistedDistributions() {\n+        SnapshotManager sm = getSnapshotManager();\n+        return sm.listPersistentSnapshots(ctx.getCoreSession()).stream().sorted((o1, o2) -> {\n+            Matcher m1 = VERSION_REGEX.matcher(o1.getVersion());\n+            Matcher m2 = VERSION_REGEX.matcher(o2.getVersion());\n+\n+            if (m1.matches() && m2.matches()) {\n+                for (int i = 0; i < 3; i++) {\n+                    String s1 = m1.group(i + 1);\n+                    int c1 = s1 != null ? Integer.parseInt(s1) : 0;\n+                    String s2 = m2.group(i + 1);\n+                    int c2 = s2 != null ? Integer.parseInt(s2) : 0;\n+\n+                    if (c1 != c2 || i == 2) {\n+                        return Integer.compare(c2, c1);\n+                    }\n+                }\n+            }\n+            log.info(String.format(\"Comparing version using String between %s - %s\", o1.getVersion(), o2.getVersion()));", "originalCommit": "0dd06c038580d3b997713cef71e06bcfa5d1636e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk3NjgxMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412976812", "bodyText": "indeed but i only moved that code -> i would prefer not modifying it to avoid unforeseen regressions in these logics", "author": "atchertchian", "createdAt": "2020-04-22T13:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk0NzA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk0ODQ0OA==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412948448", "bodyText": "The only usage I see is in getLatest which turns back the result to stream, should this method return Stream?", "author": "kevinleturc", "createdAt": "2020-04-22T12:44:06Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-webengine/src/main/java/org/nuxeo/apidoc/browse/Distribution.java", "diffHunk": "@@ -0,0 +1,593 @@\n+/*\n+ * (C) Copyright 2006-2015 Nuxeo SA (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Thierry Delprat\n+ */\n+package org.nuxeo.apidoc.browse;\n+\n+import static org.nuxeo.apidoc.snapshot.DistributionSnapshot.PROP_RELEASED;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.text.ParseException;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.naming.NamingException;\n+import javax.transaction.HeuristicMixedException;\n+import javax.transaction.HeuristicRollbackException;\n+import javax.transaction.NotSupportedException;\n+import javax.transaction.RollbackException;\n+import javax.transaction.SystemException;\n+import javax.transaction.UserTransaction;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.nuxeo.apidoc.documentation.DocumentationService;\n+import org.nuxeo.apidoc.export.ArchiveFile;\n+import org.nuxeo.apidoc.listener.AttributesExtractorStater;\n+import org.nuxeo.apidoc.plugin.Plugin;\n+import org.nuxeo.apidoc.snapshot.DistributionSnapshot;\n+import org.nuxeo.apidoc.snapshot.DistributionSnapshotDesc;\n+import org.nuxeo.apidoc.snapshot.SnapshotFilter;\n+import org.nuxeo.apidoc.snapshot.SnapshotManager;\n+import org.nuxeo.apidoc.snapshot.SnapshotManagerComponent;\n+import org.nuxeo.apidoc.snapshot.SnapshotResolverHelper;\n+import org.nuxeo.apidoc.worker.ExtractXmlAttributesWorker;\n+import org.nuxeo.common.Environment;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IterableQueryResult;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n+import org.nuxeo.ecm.core.query.QueryFilter;\n+import org.nuxeo.ecm.core.query.sql.NXQL;\n+import org.nuxeo.ecm.core.work.api.Work;\n+import org.nuxeo.ecm.core.work.api.WorkManager;\n+import org.nuxeo.ecm.webengine.forms.FormData;\n+import org.nuxeo.ecm.webengine.model.Resource;\n+import org.nuxeo.ecm.webengine.model.WebObject;\n+import org.nuxeo.ecm.webengine.model.exceptions.WebResourceNotFoundException;\n+import org.nuxeo.ecm.webengine.model.impl.ModuleRoot;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.transaction.TransactionHelper;\n+\n+@Path(\"/distribution\")\n+// needed for 5.4.1\n+@WebObject(type = \"distribution\")\n+public class Distribution extends ModuleRoot {\n+\n+    public static final String DIST_ID = \"distId\";\n+\n+    protected static final Log log = LogFactory.getLog(Distribution.class);\n+\n+    protected static final Pattern VERSION_REGEX = Pattern.compile(\"^(\\\\d+)(?:\\\\.(\\\\d+))?(?:\\\\.(\\\\d+))?(?:-.*)?$\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // handle errors\n+    @Override\n+    public Object handleError(Throwable t) {\n+        if (t instanceof WebResourceNotFoundException) {\n+            return Response.status(404).entity(getTemplate(\"error/error_404.ftl\")).type(\"text/html\").build();\n+        } else {\n+            return super.handleError(t);\n+        }\n+    }\n+\n+    protected SnapshotManager getSnapshotManager() {\n+        return Framework.getService(SnapshotManager.class);\n+    }\n+\n+    public String getNavigationPoint() {\n+        String url = getContext().getURL();\n+        String point = null;\n+        if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_BUNDLEGROUPS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_BUNDLEGROUP)) {\n+            point = ApiBrowserConstants.LIST_BUNDLEGROUPS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_BUNDLES)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_BUNDLE)) {\n+            point = ApiBrowserConstants.LIST_BUNDLES;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_COMPONENTS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_COMPONENT)) {\n+            point = ApiBrowserConstants.LIST_COMPONENTS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_SERVICES)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_SERVICE)) {\n+            point = ApiBrowserConstants.LIST_SERVICES;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_EXTENSIONPOINTS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_EXTENSIONPOINT)) {\n+            point = ApiBrowserConstants.LIST_EXTENSIONPOINTS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_CONTRIBUTIONS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_CONTRIBUTION)) {\n+            point = ApiBrowserConstants.LIST_CONTRIBUTIONS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_OPERATIONS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_OPERATION)) {\n+            point = ApiBrowserConstants.LIST_OPERATIONS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_DOCUMENTATION)) {\n+            point = ApiBrowserConstants.VIEW_DOCUMENTATION;\n+        }\n+        if (point == null) {\n+            // check plugins\n+            List<Plugin<?>> plugins = getSnapshotManager().getPlugins();\n+            for (Plugin<?> plugin : plugins) {\n+                point = plugin.getView(url);\n+                if (point != null) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return point;\n+    }\n+\n+    @GET\n+    @Produces(\"text/html\")\n+    public Object doGet() {\n+        return getView(\"index\").arg(\"hideNav\", Boolean.TRUE);\n+    }\n+\n+    @Path(\"latest\")\n+    public Resource getLatest() {\n+        List<DistributionSnapshot> snaps = listPersistedDistributions();\n+        Optional<DistributionSnapshot> distribution = snaps.stream()\n+                                                           .filter(snap -> snap.getName()\n+                                                                               .toLowerCase()\n+                                                                               .startsWith(\"nuxeo platform\"))\n+                                                           .findFirst();\n+\n+        String latest = \"current\";\n+        if (distribution.isPresent()) {\n+            latest = distribution.get().getKey();\n+        }\n+        return ctx.newObject(\"redirectWO\", \"latest\", latest);\n+    }\n+\n+    @Path(\"{distributionId}\")\n+    public Resource viewDistribution(@PathParam(\"distributionId\") String distributionId) {\n+        if (distributionId == null || \"\".equals(distributionId)) {\n+            return this;\n+        }\n+\n+        List<DistributionSnapshot> snaps = getSnapshotManager().listPersistentSnapshots((ctx.getCoreSession()));\n+        if (distributionId.matches(VERSION_REGEX.toString())) {\n+            String finalDistributionId = distributionId;\n+            String distribution = snaps.stream()\n+                                       .filter(s -> s.getVersion().equals(finalDistributionId))\n+                                       .findFirst()\n+                                       .map(DistributionSnapshot::getKey)\n+                                       .orElse(\"current\");\n+\n+            return ctx.newObject(\"redirectWO\", finalDistributionId, distribution);\n+        }\n+\n+        String orgDistributionId = distributionId;\n+        Boolean embeddedMode = Boolean.FALSE;\n+        if (\"adm\".equals(distributionId)) {\n+            embeddedMode = Boolean.TRUE;\n+        } else {\n+            snaps.add(getSnapshotManager().getRuntimeSnapshot());\n+            distributionId = SnapshotResolverHelper.findBestMatch(snaps, distributionId);\n+        }\n+        if (distributionId == null || \"\".equals(distributionId)) {\n+            distributionId = \"current\";\n+        }\n+\n+        if (!orgDistributionId.equals(distributionId)) {\n+            return ctx.newObject(\"redirectWO\", orgDistributionId, distributionId);\n+        }\n+\n+        ctx.setProperty(\"embeddedMode\", embeddedMode);\n+        ctx.setProperty(\"distribution\", getSnapshotManager().getSnapshot(distributionId, ctx.getCoreSession()));\n+        ctx.setProperty(DIST_ID, distributionId);\n+        return ctx.newObject(\"apibrowser\", distributionId, embeddedMode);\n+    }\n+\n+    public List<DistributionSnapshotDesc> getAvailableDistributions() {\n+        return getSnapshotManager().getAvailableDistributions(ctx.getCoreSession());\n+    }\n+\n+    public String getRuntimeDistributionName() {\n+        return SnapshotManagerComponent.RUNTIME;\n+    }\n+\n+    public DistributionSnapshot getRuntimeDistribution() {\n+        return getSnapshotManager().getRuntimeSnapshot();\n+    }\n+\n+    public List<DistributionSnapshot> listPersistedDistributions() {", "originalCommit": "0dd06c038580d3b997713cef71e06bcfa5d1636e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk3NjkxOA==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412976918", "bodyText": "indeed but i only moved that code -> i would prefer not modifying it to avoid unforeseen regressions in these logics", "author": "atchertchian", "createdAt": "2020-04-22T13:21:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk0ODQ0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk1MDU1Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412950557", "bodyText": "You should use try-with-resources:\ntry (OutputStream out = new FileOutputStream(tmp)) {\n    ds.exportDocumentation(getContext().getCoreSession(), out);\n    out.flush();\n}", "author": "kevinleturc", "createdAt": "2020-04-22T12:46:50Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-webengine/src/main/java/org/nuxeo/apidoc/browse/Distribution.java", "diffHunk": "@@ -0,0 +1,593 @@\n+/*\n+ * (C) Copyright 2006-2015 Nuxeo SA (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Thierry Delprat\n+ */\n+package org.nuxeo.apidoc.browse;\n+\n+import static org.nuxeo.apidoc.snapshot.DistributionSnapshot.PROP_RELEASED;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.text.ParseException;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.naming.NamingException;\n+import javax.transaction.HeuristicMixedException;\n+import javax.transaction.HeuristicRollbackException;\n+import javax.transaction.NotSupportedException;\n+import javax.transaction.RollbackException;\n+import javax.transaction.SystemException;\n+import javax.transaction.UserTransaction;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.nuxeo.apidoc.documentation.DocumentationService;\n+import org.nuxeo.apidoc.export.ArchiveFile;\n+import org.nuxeo.apidoc.listener.AttributesExtractorStater;\n+import org.nuxeo.apidoc.plugin.Plugin;\n+import org.nuxeo.apidoc.snapshot.DistributionSnapshot;\n+import org.nuxeo.apidoc.snapshot.DistributionSnapshotDesc;\n+import org.nuxeo.apidoc.snapshot.SnapshotFilter;\n+import org.nuxeo.apidoc.snapshot.SnapshotManager;\n+import org.nuxeo.apidoc.snapshot.SnapshotManagerComponent;\n+import org.nuxeo.apidoc.snapshot.SnapshotResolverHelper;\n+import org.nuxeo.apidoc.worker.ExtractXmlAttributesWorker;\n+import org.nuxeo.common.Environment;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IterableQueryResult;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n+import org.nuxeo.ecm.core.query.QueryFilter;\n+import org.nuxeo.ecm.core.query.sql.NXQL;\n+import org.nuxeo.ecm.core.work.api.Work;\n+import org.nuxeo.ecm.core.work.api.WorkManager;\n+import org.nuxeo.ecm.webengine.forms.FormData;\n+import org.nuxeo.ecm.webengine.model.Resource;\n+import org.nuxeo.ecm.webengine.model.WebObject;\n+import org.nuxeo.ecm.webengine.model.exceptions.WebResourceNotFoundException;\n+import org.nuxeo.ecm.webengine.model.impl.ModuleRoot;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.transaction.TransactionHelper;\n+\n+@Path(\"/distribution\")\n+// needed for 5.4.1\n+@WebObject(type = \"distribution\")\n+public class Distribution extends ModuleRoot {\n+\n+    public static final String DIST_ID = \"distId\";\n+\n+    protected static final Log log = LogFactory.getLog(Distribution.class);\n+\n+    protected static final Pattern VERSION_REGEX = Pattern.compile(\"^(\\\\d+)(?:\\\\.(\\\\d+))?(?:\\\\.(\\\\d+))?(?:-.*)?$\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // handle errors\n+    @Override\n+    public Object handleError(Throwable t) {\n+        if (t instanceof WebResourceNotFoundException) {\n+            return Response.status(404).entity(getTemplate(\"error/error_404.ftl\")).type(\"text/html\").build();\n+        } else {\n+            return super.handleError(t);\n+        }\n+    }\n+\n+    protected SnapshotManager getSnapshotManager() {\n+        return Framework.getService(SnapshotManager.class);\n+    }\n+\n+    public String getNavigationPoint() {\n+        String url = getContext().getURL();\n+        String point = null;\n+        if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_BUNDLEGROUPS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_BUNDLEGROUP)) {\n+            point = ApiBrowserConstants.LIST_BUNDLEGROUPS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_BUNDLES)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_BUNDLE)) {\n+            point = ApiBrowserConstants.LIST_BUNDLES;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_COMPONENTS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_COMPONENT)) {\n+            point = ApiBrowserConstants.LIST_COMPONENTS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_SERVICES)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_SERVICE)) {\n+            point = ApiBrowserConstants.LIST_SERVICES;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_EXTENSIONPOINTS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_EXTENSIONPOINT)) {\n+            point = ApiBrowserConstants.LIST_EXTENSIONPOINTS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_CONTRIBUTIONS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_CONTRIBUTION)) {\n+            point = ApiBrowserConstants.LIST_CONTRIBUTIONS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_OPERATIONS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_OPERATION)) {\n+            point = ApiBrowserConstants.LIST_OPERATIONS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_DOCUMENTATION)) {\n+            point = ApiBrowserConstants.VIEW_DOCUMENTATION;\n+        }\n+        if (point == null) {\n+            // check plugins\n+            List<Plugin<?>> plugins = getSnapshotManager().getPlugins();\n+            for (Plugin<?> plugin : plugins) {\n+                point = plugin.getView(url);\n+                if (point != null) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return point;\n+    }\n+\n+    @GET\n+    @Produces(\"text/html\")\n+    public Object doGet() {\n+        return getView(\"index\").arg(\"hideNav\", Boolean.TRUE);\n+    }\n+\n+    @Path(\"latest\")\n+    public Resource getLatest() {\n+        List<DistributionSnapshot> snaps = listPersistedDistributions();\n+        Optional<DistributionSnapshot> distribution = snaps.stream()\n+                                                           .filter(snap -> snap.getName()\n+                                                                               .toLowerCase()\n+                                                                               .startsWith(\"nuxeo platform\"))\n+                                                           .findFirst();\n+\n+        String latest = \"current\";\n+        if (distribution.isPresent()) {\n+            latest = distribution.get().getKey();\n+        }\n+        return ctx.newObject(\"redirectWO\", \"latest\", latest);\n+    }\n+\n+    @Path(\"{distributionId}\")\n+    public Resource viewDistribution(@PathParam(\"distributionId\") String distributionId) {\n+        if (distributionId == null || \"\".equals(distributionId)) {\n+            return this;\n+        }\n+\n+        List<DistributionSnapshot> snaps = getSnapshotManager().listPersistentSnapshots((ctx.getCoreSession()));\n+        if (distributionId.matches(VERSION_REGEX.toString())) {\n+            String finalDistributionId = distributionId;\n+            String distribution = snaps.stream()\n+                                       .filter(s -> s.getVersion().equals(finalDistributionId))\n+                                       .findFirst()\n+                                       .map(DistributionSnapshot::getKey)\n+                                       .orElse(\"current\");\n+\n+            return ctx.newObject(\"redirectWO\", finalDistributionId, distribution);\n+        }\n+\n+        String orgDistributionId = distributionId;\n+        Boolean embeddedMode = Boolean.FALSE;\n+        if (\"adm\".equals(distributionId)) {\n+            embeddedMode = Boolean.TRUE;\n+        } else {\n+            snaps.add(getSnapshotManager().getRuntimeSnapshot());\n+            distributionId = SnapshotResolverHelper.findBestMatch(snaps, distributionId);\n+        }\n+        if (distributionId == null || \"\".equals(distributionId)) {\n+            distributionId = \"current\";\n+        }\n+\n+        if (!orgDistributionId.equals(distributionId)) {\n+            return ctx.newObject(\"redirectWO\", orgDistributionId, distributionId);\n+        }\n+\n+        ctx.setProperty(\"embeddedMode\", embeddedMode);\n+        ctx.setProperty(\"distribution\", getSnapshotManager().getSnapshot(distributionId, ctx.getCoreSession()));\n+        ctx.setProperty(DIST_ID, distributionId);\n+        return ctx.newObject(\"apibrowser\", distributionId, embeddedMode);\n+    }\n+\n+    public List<DistributionSnapshotDesc> getAvailableDistributions() {\n+        return getSnapshotManager().getAvailableDistributions(ctx.getCoreSession());\n+    }\n+\n+    public String getRuntimeDistributionName() {\n+        return SnapshotManagerComponent.RUNTIME;\n+    }\n+\n+    public DistributionSnapshot getRuntimeDistribution() {\n+        return getSnapshotManager().getRuntimeSnapshot();\n+    }\n+\n+    public List<DistributionSnapshot> listPersistedDistributions() {\n+        SnapshotManager sm = getSnapshotManager();\n+        return sm.listPersistentSnapshots(ctx.getCoreSession()).stream().sorted((o1, o2) -> {\n+            Matcher m1 = VERSION_REGEX.matcher(o1.getVersion());\n+            Matcher m2 = VERSION_REGEX.matcher(o2.getVersion());\n+\n+            if (m1.matches() && m2.matches()) {\n+                for (int i = 0; i < 3; i++) {\n+                    String s1 = m1.group(i + 1);\n+                    int c1 = s1 != null ? Integer.parseInt(s1) : 0;\n+                    String s2 = m2.group(i + 1);\n+                    int c2 = s2 != null ? Integer.parseInt(s2) : 0;\n+\n+                    if (c1 != c2 || i == 2) {\n+                        return Integer.compare(c2, c1);\n+                    }\n+                }\n+            }\n+            log.info(String.format(\"Comparing version using String between %s - %s\", o1.getVersion(), o2.getVersion()));\n+            return o2.getVersion().compareTo(o1.getVersion());\n+        }).filter(s -> !s.isHidden()).collect(Collectors.toList());\n+    }\n+\n+    public Map<String, DistributionSnapshot> getPersistedDistributions() {\n+        return getSnapshotManager().getPersistentSnapshots(ctx.getCoreSession());\n+    }\n+\n+    public DistributionSnapshot getCurrentDistribution() {\n+        String distId = (String) ctx.getProperty(DIST_ID);\n+        DistributionSnapshot currentDistribution = (DistributionSnapshot) ctx.getProperty(\"currentDistribution\");\n+        if (currentDistribution == null || !currentDistribution.getKey().equals(distId)) {\n+            currentDistribution = getSnapshotManager().getSnapshot(distId, ctx.getCoreSession());\n+            ctx.setProperty(\"currentDistribution\", currentDistribution);\n+        }\n+        return currentDistribution;\n+    }\n+\n+    @POST\n+    @Path(\"save\")\n+    @Produces(\"text/html\")\n+    public Object doSave() throws NamingException, NotSupportedException, SystemException, RollbackException,\n+            HeuristicMixedException, HeuristicRollbackException, ParseException {\n+        if (!canAddDocumentation()) {\n+            return null;\n+        }\n+        FormData formData = getContext().getForm();\n+        String distribLabel = formData.getString(\"name\");\n+\n+        log.info(\"Start Snapshot...\");\n+        boolean startedTx = false;\n+        UserTransaction tx = TransactionHelper.lookupUserTransaction();\n+        if (tx != null && !TransactionHelper.isTransactionActiveOrMarkedRollback()) {\n+            tx.begin();\n+            startedTx = true;\n+        }\n+\n+        Map<String, Serializable> otherProperties = readFormData(formData);\n+        try {\n+            getSnapshotManager().persistRuntimeSnapshot(getContext().getCoreSession(), distribLabel, otherProperties);\n+\n+        } catch (NuxeoException e) {\n+            log.error(\"Error during storage\", e);\n+            if (tx != null) {\n+                tx.rollback();\n+            }\n+            return getView(\"savedKO\").arg(\"message\", e.getMessage());\n+        }\n+        log.info(\"Snapshot saved.\");\n+        if (tx != null && startedTx) {\n+            tx.commit();\n+        }\n+\n+        String redirectUrl = getContext().getBaseURL() + getPath();\n+        log.debug(\"Path => \" + redirectUrl);\n+        return getView(\"saved\");\n+    }\n+\n+    protected Map<String, Serializable> readFormData(FormData formData) {\n+        Map<String, Serializable> properties = new HashMap<>();\n+\n+        // Release date\n+        String released = formData.getString(\"released\");\n+        if (StringUtils.isNotBlank(released)) {\n+            LocalDate date = LocalDate.parse(released);\n+            Instant instant = date.atStartOfDay().atZone(ZoneId.systemDefault()).toInstant();\n+            properties.put(PROP_RELEASED, java.util.Date.from(instant));\n+        }\n+\n+        return properties;\n+    }\n+\n+    @POST\n+    @Path(\"saveExtended\")\n+    @Produces(\"text/html\")\n+    public Object doSaveExtended() throws NamingException, NotSupportedException, SystemException, SecurityException,\n+            RollbackException, HeuristicMixedException, HeuristicRollbackException {\n+        if (!canAddDocumentation()) {\n+            return null;\n+        }\n+\n+        FormData formData = getContext().getForm();\n+\n+        String distribLabel = formData.getString(\"name\");\n+        String bundleList = formData.getString(\"bundles\");\n+        String pkgList = formData.getString(\"packages\");\n+        SnapshotFilter filter = new SnapshotFilter(distribLabel);\n+\n+        if (bundleList != null) {\n+            String[] bundles = bundleList.split(\"\\n\");\n+            for (String bundleId : bundles) {\n+                filter.addBundlePrefix(bundleId);\n+            }\n+        }\n+\n+        if (pkgList != null) {\n+            String[] packages = pkgList.split(\"\\\\r?\\\\n\");\n+            for (String pkg : packages) {\n+                filter.addPackagesPrefix(pkg);\n+            }\n+        }\n+\n+        Map<String, Serializable> otherProperties = readFormData(formData);\n+\n+        log.info(\"Start Snapshot...\");\n+        boolean startedTx = false;\n+        UserTransaction tx = TransactionHelper.lookupUserTransaction();\n+        if (tx != null && !TransactionHelper.isTransactionActiveOrMarkedRollback()) {\n+            tx.begin();\n+            startedTx = true;\n+        }\n+        try {\n+            getSnapshotManager().persistRuntimeSnapshot(getContext().getCoreSession(), distribLabel, otherProperties,\n+                    filter);\n+        } catch (NuxeoException e) {\n+            log.error(\"Error during storage\", e);\n+            if (tx != null) {\n+                tx.rollback();\n+            }\n+            return getView(\"savedKO\").arg(\"message\", e.getMessage());\n+        }\n+        log.info(\"Snapshot saved.\");\n+        if (tx != null && startedTx) {\n+            tx.commit();\n+        }\n+        return getView(\"saved\");\n+    }\n+\n+    /**\n+     * Returns the runtime snapshot json export.\n+     *\n+     * @since 11.1\n+     */\n+    @GET\n+    @Path(\"json\")\n+    @Produces(\"application/json\")\n+    public Object getJson() throws IOException {\n+        // init potential resources depending on request\n+        getSnapshotManager().initWebContext(getContext().getRequest());\n+        DistributionSnapshot snap = getSnapshotManager().getRuntimeSnapshot();\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        snap.writeJson(out);\n+        return out.toString();\n+    }\n+\n+    public String getDocumentationInfo() {\n+        DocumentationService ds = Framework.getService(DocumentationService.class);\n+        return ds.getDocumentationStats(getContext().getCoreSession());\n+    }\n+\n+    protected File getExportTmpFile() {\n+        File tmpFile = new File(Environment.getDefault().getTemp(), \"export.zip\");\n+        if (tmpFile.exists()) {\n+            tmpFile.delete();\n+        }\n+        tmpFile.deleteOnExit();\n+        return tmpFile;\n+    }\n+\n+    @GET\n+    @Path(\"downloadDoc\")\n+    public Response downloadDoc() throws IOException {\n+        DocumentationService ds = Framework.getService(DocumentationService.class);\n+        File tmp = getExportTmpFile();\n+        tmp.createNewFile();\n+        OutputStream out = new FileOutputStream(tmp);\n+        ds.exportDocumentation(getContext().getCoreSession(), out);\n+        out.flush();\n+        out.close();", "originalCommit": "0dd06c038580d3b997713cef71e06bcfa5d1636e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk3Njk3Mw==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412976973", "bodyText": "indeed but i only moved that code -> i would prefer not modifying it to avoid unforeseen regressions in these logics", "author": "atchertchian", "createdAt": "2020-04-22T13:22:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk1MDU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk1MTIxOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r412951219", "bodyText": "No newline", "author": "kevinleturc", "createdAt": "2020-04-22T12:47:48Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-webengine/src/main/java/org/nuxeo/apidoc/browse/Distribution.java", "diffHunk": "@@ -0,0 +1,593 @@\n+/*\n+ * (C) Copyright 2006-2015 Nuxeo SA (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Thierry Delprat\n+ */\n+package org.nuxeo.apidoc.browse;\n+\n+import static org.nuxeo.apidoc.snapshot.DistributionSnapshot.PROP_RELEASED;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.text.ParseException;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.naming.NamingException;\n+import javax.transaction.HeuristicMixedException;\n+import javax.transaction.HeuristicRollbackException;\n+import javax.transaction.NotSupportedException;\n+import javax.transaction.RollbackException;\n+import javax.transaction.SystemException;\n+import javax.transaction.UserTransaction;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.nuxeo.apidoc.documentation.DocumentationService;\n+import org.nuxeo.apidoc.export.ArchiveFile;\n+import org.nuxeo.apidoc.listener.AttributesExtractorStater;\n+import org.nuxeo.apidoc.plugin.Plugin;\n+import org.nuxeo.apidoc.snapshot.DistributionSnapshot;\n+import org.nuxeo.apidoc.snapshot.DistributionSnapshotDesc;\n+import org.nuxeo.apidoc.snapshot.SnapshotFilter;\n+import org.nuxeo.apidoc.snapshot.SnapshotManager;\n+import org.nuxeo.apidoc.snapshot.SnapshotManagerComponent;\n+import org.nuxeo.apidoc.snapshot.SnapshotResolverHelper;\n+import org.nuxeo.apidoc.worker.ExtractXmlAttributesWorker;\n+import org.nuxeo.common.Environment;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IterableQueryResult;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n+import org.nuxeo.ecm.core.query.QueryFilter;\n+import org.nuxeo.ecm.core.query.sql.NXQL;\n+import org.nuxeo.ecm.core.work.api.Work;\n+import org.nuxeo.ecm.core.work.api.WorkManager;\n+import org.nuxeo.ecm.webengine.forms.FormData;\n+import org.nuxeo.ecm.webengine.model.Resource;\n+import org.nuxeo.ecm.webengine.model.WebObject;\n+import org.nuxeo.ecm.webengine.model.exceptions.WebResourceNotFoundException;\n+import org.nuxeo.ecm.webengine.model.impl.ModuleRoot;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.transaction.TransactionHelper;\n+\n+@Path(\"/distribution\")\n+// needed for 5.4.1\n+@WebObject(type = \"distribution\")\n+public class Distribution extends ModuleRoot {\n+\n+    public static final String DIST_ID = \"distId\";\n+\n+    protected static final Log log = LogFactory.getLog(Distribution.class);\n+\n+    protected static final Pattern VERSION_REGEX = Pattern.compile(\"^(\\\\d+)(?:\\\\.(\\\\d+))?(?:\\\\.(\\\\d+))?(?:-.*)?$\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // handle errors\n+    @Override\n+    public Object handleError(Throwable t) {\n+        if (t instanceof WebResourceNotFoundException) {\n+            return Response.status(404).entity(getTemplate(\"error/error_404.ftl\")).type(\"text/html\").build();\n+        } else {\n+            return super.handleError(t);\n+        }\n+    }\n+\n+    protected SnapshotManager getSnapshotManager() {\n+        return Framework.getService(SnapshotManager.class);\n+    }\n+\n+    public String getNavigationPoint() {\n+        String url = getContext().getURL();\n+        String point = null;\n+        if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_BUNDLEGROUPS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_BUNDLEGROUP)) {\n+            point = ApiBrowserConstants.LIST_BUNDLEGROUPS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_BUNDLES)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_BUNDLE)) {\n+            point = ApiBrowserConstants.LIST_BUNDLES;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_COMPONENTS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_COMPONENT)) {\n+            point = ApiBrowserConstants.LIST_COMPONENTS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_SERVICES)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_SERVICE)) {\n+            point = ApiBrowserConstants.LIST_SERVICES;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_EXTENSIONPOINTS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_EXTENSIONPOINT)) {\n+            point = ApiBrowserConstants.LIST_EXTENSIONPOINTS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_CONTRIBUTIONS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_CONTRIBUTION)) {\n+            point = ApiBrowserConstants.LIST_CONTRIBUTIONS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.LIST_OPERATIONS)\n+                || ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_OPERATION)) {\n+            point = ApiBrowserConstants.LIST_OPERATIONS;\n+        } else if (ApiBrowserConstants.check(url, ApiBrowserConstants.VIEW_DOCUMENTATION)) {\n+            point = ApiBrowserConstants.VIEW_DOCUMENTATION;\n+        }\n+        if (point == null) {\n+            // check plugins\n+            List<Plugin<?>> plugins = getSnapshotManager().getPlugins();\n+            for (Plugin<?> plugin : plugins) {\n+                point = plugin.getView(url);\n+                if (point != null) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return point;\n+    }\n+\n+    @GET\n+    @Produces(\"text/html\")\n+    public Object doGet() {\n+        return getView(\"index\").arg(\"hideNav\", Boolean.TRUE);\n+    }\n+\n+    @Path(\"latest\")\n+    public Resource getLatest() {\n+        List<DistributionSnapshot> snaps = listPersistedDistributions();\n+        Optional<DistributionSnapshot> distribution = snaps.stream()\n+                                                           .filter(snap -> snap.getName()\n+                                                                               .toLowerCase()\n+                                                                               .startsWith(\"nuxeo platform\"))\n+                                                           .findFirst();\n+\n+        String latest = \"current\";\n+        if (distribution.isPresent()) {\n+            latest = distribution.get().getKey();\n+        }\n+        return ctx.newObject(\"redirectWO\", \"latest\", latest);\n+    }\n+\n+    @Path(\"{distributionId}\")\n+    public Resource viewDistribution(@PathParam(\"distributionId\") String distributionId) {\n+        if (distributionId == null || \"\".equals(distributionId)) {\n+            return this;\n+        }\n+\n+        List<DistributionSnapshot> snaps = getSnapshotManager().listPersistentSnapshots((ctx.getCoreSession()));\n+        if (distributionId.matches(VERSION_REGEX.toString())) {\n+            String finalDistributionId = distributionId;\n+            String distribution = snaps.stream()\n+                                       .filter(s -> s.getVersion().equals(finalDistributionId))\n+                                       .findFirst()\n+                                       .map(DistributionSnapshot::getKey)\n+                                       .orElse(\"current\");\n+\n+            return ctx.newObject(\"redirectWO\", finalDistributionId, distribution);\n+        }\n+\n+        String orgDistributionId = distributionId;\n+        Boolean embeddedMode = Boolean.FALSE;\n+        if (\"adm\".equals(distributionId)) {\n+            embeddedMode = Boolean.TRUE;\n+        } else {\n+            snaps.add(getSnapshotManager().getRuntimeSnapshot());\n+            distributionId = SnapshotResolverHelper.findBestMatch(snaps, distributionId);\n+        }\n+        if (distributionId == null || \"\".equals(distributionId)) {\n+            distributionId = \"current\";\n+        }\n+\n+        if (!orgDistributionId.equals(distributionId)) {\n+            return ctx.newObject(\"redirectWO\", orgDistributionId, distributionId);\n+        }\n+\n+        ctx.setProperty(\"embeddedMode\", embeddedMode);\n+        ctx.setProperty(\"distribution\", getSnapshotManager().getSnapshot(distributionId, ctx.getCoreSession()));\n+        ctx.setProperty(DIST_ID, distributionId);\n+        return ctx.newObject(\"apibrowser\", distributionId, embeddedMode);\n+    }\n+\n+    public List<DistributionSnapshotDesc> getAvailableDistributions() {\n+        return getSnapshotManager().getAvailableDistributions(ctx.getCoreSession());\n+    }\n+\n+    public String getRuntimeDistributionName() {\n+        return SnapshotManagerComponent.RUNTIME;\n+    }\n+\n+    public DistributionSnapshot getRuntimeDistribution() {\n+        return getSnapshotManager().getRuntimeSnapshot();\n+    }\n+\n+    public List<DistributionSnapshot> listPersistedDistributions() {\n+        SnapshotManager sm = getSnapshotManager();\n+        return sm.listPersistentSnapshots(ctx.getCoreSession()).stream().sorted((o1, o2) -> {\n+            Matcher m1 = VERSION_REGEX.matcher(o1.getVersion());\n+            Matcher m2 = VERSION_REGEX.matcher(o2.getVersion());\n+\n+            if (m1.matches() && m2.matches()) {\n+                for (int i = 0; i < 3; i++) {\n+                    String s1 = m1.group(i + 1);\n+                    int c1 = s1 != null ? Integer.parseInt(s1) : 0;\n+                    String s2 = m2.group(i + 1);\n+                    int c2 = s2 != null ? Integer.parseInt(s2) : 0;\n+\n+                    if (c1 != c2 || i == 2) {\n+                        return Integer.compare(c2, c1);\n+                    }\n+                }\n+            }\n+            log.info(String.format(\"Comparing version using String between %s - %s\", o1.getVersion(), o2.getVersion()));\n+            return o2.getVersion().compareTo(o1.getVersion());\n+        }).filter(s -> !s.isHidden()).collect(Collectors.toList());\n+    }\n+\n+    public Map<String, DistributionSnapshot> getPersistedDistributions() {\n+        return getSnapshotManager().getPersistentSnapshots(ctx.getCoreSession());\n+    }\n+\n+    public DistributionSnapshot getCurrentDistribution() {\n+        String distId = (String) ctx.getProperty(DIST_ID);\n+        DistributionSnapshot currentDistribution = (DistributionSnapshot) ctx.getProperty(\"currentDistribution\");\n+        if (currentDistribution == null || !currentDistribution.getKey().equals(distId)) {\n+            currentDistribution = getSnapshotManager().getSnapshot(distId, ctx.getCoreSession());\n+            ctx.setProperty(\"currentDistribution\", currentDistribution);\n+        }\n+        return currentDistribution;\n+    }\n+\n+    @POST\n+    @Path(\"save\")\n+    @Produces(\"text/html\")\n+    public Object doSave() throws NamingException, NotSupportedException, SystemException, RollbackException,\n+            HeuristicMixedException, HeuristicRollbackException, ParseException {\n+        if (!canAddDocumentation()) {\n+            return null;\n+        }\n+        FormData formData = getContext().getForm();\n+        String distribLabel = formData.getString(\"name\");\n+\n+        log.info(\"Start Snapshot...\");\n+        boolean startedTx = false;\n+        UserTransaction tx = TransactionHelper.lookupUserTransaction();\n+        if (tx != null && !TransactionHelper.isTransactionActiveOrMarkedRollback()) {\n+            tx.begin();\n+            startedTx = true;\n+        }\n+\n+        Map<String, Serializable> otherProperties = readFormData(formData);\n+        try {\n+            getSnapshotManager().persistRuntimeSnapshot(getContext().getCoreSession(), distribLabel, otherProperties);\n+\n+        } catch (NuxeoException e) {\n+            log.error(\"Error during storage\", e);\n+            if (tx != null) {\n+                tx.rollback();\n+            }\n+            return getView(\"savedKO\").arg(\"message\", e.getMessage());\n+        }\n+        log.info(\"Snapshot saved.\");\n+        if (tx != null && startedTx) {\n+            tx.commit();\n+        }\n+\n+        String redirectUrl = getContext().getBaseURL() + getPath();\n+        log.debug(\"Path => \" + redirectUrl);\n+        return getView(\"saved\");\n+    }\n+\n+    protected Map<String, Serializable> readFormData(FormData formData) {\n+        Map<String, Serializable> properties = new HashMap<>();\n+\n+        // Release date\n+        String released = formData.getString(\"released\");\n+        if (StringUtils.isNotBlank(released)) {\n+            LocalDate date = LocalDate.parse(released);\n+            Instant instant = date.atStartOfDay().atZone(ZoneId.systemDefault()).toInstant();\n+            properties.put(PROP_RELEASED, java.util.Date.from(instant));\n+        }\n+\n+        return properties;\n+    }\n+\n+    @POST\n+    @Path(\"saveExtended\")\n+    @Produces(\"text/html\")\n+    public Object doSaveExtended() throws NamingException, NotSupportedException, SystemException, SecurityException,\n+            RollbackException, HeuristicMixedException, HeuristicRollbackException {\n+        if (!canAddDocumentation()) {\n+            return null;\n+        }\n+\n+        FormData formData = getContext().getForm();\n+\n+        String distribLabel = formData.getString(\"name\");\n+        String bundleList = formData.getString(\"bundles\");\n+        String pkgList = formData.getString(\"packages\");\n+        SnapshotFilter filter = new SnapshotFilter(distribLabel);\n+\n+        if (bundleList != null) {\n+            String[] bundles = bundleList.split(\"\\n\");\n+            for (String bundleId : bundles) {\n+                filter.addBundlePrefix(bundleId);\n+            }\n+        }\n+\n+        if (pkgList != null) {\n+            String[] packages = pkgList.split(\"\\\\r?\\\\n\");\n+            for (String pkg : packages) {\n+                filter.addPackagesPrefix(pkg);\n+            }\n+        }\n+\n+        Map<String, Serializable> otherProperties = readFormData(formData);\n+\n+        log.info(\"Start Snapshot...\");\n+        boolean startedTx = false;\n+        UserTransaction tx = TransactionHelper.lookupUserTransaction();\n+        if (tx != null && !TransactionHelper.isTransactionActiveOrMarkedRollback()) {\n+            tx.begin();\n+            startedTx = true;\n+        }\n+        try {\n+            getSnapshotManager().persistRuntimeSnapshot(getContext().getCoreSession(), distribLabel, otherProperties,\n+                    filter);\n+        } catch (NuxeoException e) {\n+            log.error(\"Error during storage\", e);\n+            if (tx != null) {\n+                tx.rollback();\n+            }\n+            return getView(\"savedKO\").arg(\"message\", e.getMessage());\n+        }\n+        log.info(\"Snapshot saved.\");\n+        if (tx != null && startedTx) {\n+            tx.commit();\n+        }\n+        return getView(\"saved\");\n+    }\n+\n+    /**\n+     * Returns the runtime snapshot json export.\n+     *\n+     * @since 11.1\n+     */\n+    @GET\n+    @Path(\"json\")\n+    @Produces(\"application/json\")\n+    public Object getJson() throws IOException {\n+        // init potential resources depending on request\n+        getSnapshotManager().initWebContext(getContext().getRequest());\n+        DistributionSnapshot snap = getSnapshotManager().getRuntimeSnapshot();\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        snap.writeJson(out);\n+        return out.toString();\n+    }\n+\n+    public String getDocumentationInfo() {\n+        DocumentationService ds = Framework.getService(DocumentationService.class);\n+        return ds.getDocumentationStats(getContext().getCoreSession());\n+    }\n+\n+    protected File getExportTmpFile() {\n+        File tmpFile = new File(Environment.getDefault().getTemp(), \"export.zip\");\n+        if (tmpFile.exists()) {\n+            tmpFile.delete();\n+        }\n+        tmpFile.deleteOnExit();\n+        return tmpFile;\n+    }\n+\n+    @GET\n+    @Path(\"downloadDoc\")\n+    public Response downloadDoc() throws IOException {\n+        DocumentationService ds = Framework.getService(DocumentationService.class);\n+        File tmp = getExportTmpFile();\n+        tmp.createNewFile();\n+        OutputStream out = new FileOutputStream(tmp);\n+        ds.exportDocumentation(getContext().getCoreSession(), out);\n+        out.flush();\n+        out.close();\n+        ArchiveFile aFile = new ArchiveFile(tmp.getAbsolutePath());\n+        return Response.ok(aFile)\n+                       .header(\"Content-Disposition\", \"attachment;filename=\" + \"nuxeo-documentation.zip\")\n+                       .type(\"application/zip\")\n+                       .build();\n+    }\n+\n+    @GET\n+    @Path(\"download/{distributionId}\")\n+    public Response downloadDistrib(@PathParam(\"distributionId\") String distribId) throws IOException {\n+        File tmp = getExportTmpFile();\n+        tmp.createNewFile();\n+        OutputStream out = new FileOutputStream(tmp);\n+        getSnapshotManager().exportSnapshot(getContext().getCoreSession(), distribId, out);\n+        out.close();\n+        String fName = \"nuxeo-distribution-\" + distribId + \".zip\";\n+        fName = fName.replace(\" \", \"_\");\n+        ArchiveFile aFile = new ArchiveFile(tmp.getAbsolutePath());\n+        return Response.ok(aFile)\n+                       .header(\"Content-Disposition\", \"attachment;filename=\" + fName)\n+                       .type(\"application/zip\")\n+                       .build();\n+    }\n+\n+    /**\n+     * Use to allow authorized users to upload distribution even in site mode\n+     *\n+     * @since 8.3\n+     */\n+    @GET\n+    @Path(\"_admin\")\n+    public Object getForms() {\n+        NuxeoPrincipal principal = getContext().getPrincipal();\n+        if (SecurityHelper.canEditDocumentation(principal)) {\n+            return getView(\"forms\").arg(\"hideNav\", Boolean.TRUE);\n+        } else {\n+            return Response.status(401).build();\n+        }\n+    }\n+\n+    @POST\n+    @Path(\"uploadDistrib\")\n+    @Produces(\"text/html\")\n+    public Object uploadDistrib() throws IOException {\n+        if (!canAddDocumentation()) {\n+            return null;\n+        }\n+        Blob blob = getContext().getForm().getFirstBlob();\n+\n+        getSnapshotManager().importSnapshot(getContext().getCoreSession(), blob.getStream());\n+        getSnapshotManager().readPersistentSnapshots(getContext().getCoreSession());\n+\n+        return getView(\"index\");\n+    }\n+\n+    @POST\n+    @Path(\"uploadDistribTmp\")\n+    @Produces(\"text/html\")\n+    public Object uploadDistribTmp() throws IOException {\n+        if (!canAddDocumentation()) {\n+            return null;\n+        }\n+        Blob blob = getContext().getForm().getFirstBlob();\n+        if (blob == null || blob.getLength() == 0) {\n+            return null;\n+        }\n+        DocumentModel snap = getSnapshotManager().importTmpSnapshot(getContext().getCoreSession(), blob.getStream());\n+        if (snap == null) {\n+            log.error(\"Unable to import archive\");\n+            return null;\n+        }\n+        DistributionSnapshot snapObject = snap.getAdapter(DistributionSnapshot.class);\n+        return getView(\"uploadEdit\").arg(\"tmpSnap\", snap).arg(\"snapObject\", snapObject);\n+    }\n+\n+    @POST\n+    @Path(\"uploadDistribTmpValid\")\n+    @Produces(\"text/html\")\n+    public Object uploadDistribTmpValid() {\n+        if (!canAddDocumentation()) {\n+            return null;\n+        }\n+\n+        FormData formData = getContext().getForm();\n+        String name = formData.getString(\"name\");\n+        String version = formData.getString(\"version\");\n+        String pathSegment = formData.getString(\"pathSegment\");\n+        String title = formData.getString(\"title\");\n+\n+        getSnapshotManager().validateImportedSnapshot(getContext().getCoreSession(), name, version, pathSegment, title);\n+        getSnapshotManager().readPersistentSnapshots(getContext().getCoreSession());\n+        return getView(\"importDone\");\n+    }\n+\n+    @POST\n+    @Path(\"uploadDoc\")\n+    @Produces(\"text/html\")\n+    public Object uploadDoc() throws IOException {\n+        if (!canAddDocumentation()) {\n+            return null;\n+        }\n+\n+        Blob blob = getContext().getForm().getFirstBlob();\n+        if (blob == null || blob.getLength() == 0) {\n+            return null;\n+        }\n+\n+        DocumentationService ds = Framework.getService(DocumentationService.class);\n+        ds.importDocumentation(getContext().getCoreSession(), blob.getStream());\n+\n+        log.info(\"Documents imported.\");\n+\n+        return getView(\"docImportDone\");\n+    }\n+\n+    @GET\n+    @Path(\"_reindex\")\n+    @Produces(\"text/plain\")\n+    public Object reindex() {\n+        NuxeoPrincipal nxPrincipal = getContext().getPrincipal();\n+        if (!nxPrincipal.isAdministrator()) {\n+            return Response.status(404).build();\n+        }\n+\n+        CoreSession coreSession = getContext().getCoreSession();\n+        String query = String.format(\n+                \"SELECT ecm:uuid FROM Document WHERE ecm:primaryType in ('%s') AND ecm:isProxy = 0 AND ecm:isTrashed = 0\",\n+                StringUtils.join(AttributesExtractorStater.DOC_TYPES, \"','\"));\n+\n+        try (IterableQueryResult it = coreSession.queryAndFetch(query, NXQL.NXQL, QueryFilter.EMPTY);) {\n+            for (Map<String, Serializable> map : it) {\n+                String id = (String) map.get(NXQL.ECM_UUID);\n+                Work work = new ExtractXmlAttributesWorker(coreSession.getRepositoryName(), nxPrincipal.getName(), id);\n+                Framework.getService(WorkManager.class).schedule(work);\n+            }\n+        }\n+\n+        return Response.ok().build();\n+    }\n+\n+    public boolean isEmbeddedMode() {\n+        Boolean embed = (Boolean) getContext().getProperty(\"embeddedMode\", Boolean.FALSE);\n+        return embed != null && embed;\n+    }\n+\n+    public boolean isEditor() {\n+        if (isEmbeddedMode() || isSiteMode()) {\n+            return false;\n+        }\n+        NuxeoPrincipal principal = getContext().getPrincipal();\n+        return SecurityHelper.canEditDocumentation(principal);\n+    }\n+\n+    public boolean canAddDocumentation() {\n+        NuxeoPrincipal principal = getContext().getPrincipal();\n+        return !isEmbeddedMode() && SecurityHelper.canEditDocumentation(principal);\n+    }\n+\n+    public static boolean showCurrentDistribution() {\n+        return !(Framework.isBooleanPropertyTrue(ApiBrowserConstants.PROPERTY_SITE_MODE) || isSiteMode());\n+    }\n+\n+    public static boolean isSiteMode() {\n+        return Framework.isBooleanPropertyTrue(ApiBrowserConstants.PROPERTY_SITE_MODE);\n+    }\n+\n+    /**\n+     * Generates the list of plugins that should be displayed in the menu.\n+     */\n+    public List<Plugin<?>> getPluginMenu() {\n+        return getSnapshotManager().getPlugins()\n+                                   .stream()\n+                                   .filter(plugin -> !plugin.isHidden())\n+                                   .collect(Collectors.toList());\n+    }\n+\n+}", "originalCommit": "0dd06c038580d3b997713cef71e06bcfa5d1636e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1bb627dfefb2d20a44dd8bf50189b3da6f1af30a", "url": "https://github.com/nuxeo/nuxeo/commit/1bb627dfefb2d20a44dd8bf50189b3da6f1af30a", "message": "NXP-28839: add new line at end of files", "committedDate": "2020-04-22T14:20:49Z", "type": "forcePushed"}, {"oid": "9be33c34cbfe1367efb50f6d58f33fc1de16f603", "url": "https://github.com/nuxeo/nuxeo/commit/9be33c34cbfe1367efb50f6d58f33fc1de16f603", "message": "NXP-28839: add new line at end of files", "committedDate": "2020-04-22T14:31:30Z", "type": "forcePushed"}, {"oid": "424807d7095ea9b2f6912778b5164c06dd2c60da", "url": "https://github.com/nuxeo/nuxeo/commit/424807d7095ea9b2f6912778b5164c06dd2c60da", "message": "NXP-28839: add new line at end of files", "committedDate": "2020-04-24T11:56:33Z", "type": "forcePushed"}, {"oid": "dd44175b15ef6593b825995513b598a62cd2b8e3", "url": "https://github.com/nuxeo/nuxeo/commit/dd44175b15ef6593b825995513b598a62cd2b8e3", "message": "NXP-28876: better skip of TestSnapshotPersist when not on VCS + H2", "committedDate": "2020-04-24T11:58:27Z", "type": "commit"}, {"oid": "65fed953c2e64ab58ba10f5c8cc04a152faf5b99", "url": "https://github.com/nuxeo/nuxeo/commit/65fed953c2e64ab58ba10f5c8cc04a152faf5b99", "message": "NXP-28839: add back apidoc-webengine module into the platform (losing history this time :shrug:)", "committedDate": "2020-04-24T11:58:27Z", "type": "commit"}, {"oid": "46d31a2d5b11b705eb46fe307c53cf26b738a834", "url": "https://github.com/nuxeo/nuxeo/commit/46d31a2d5b11b705eb46fe307c53cf26b738a834", "message": "NXP-28839: format/cleanup apidoc modules", "committedDate": "2020-04-24T11:58:27Z", "type": "commit"}, {"oid": "f2a242a0dd4cb3e9c8383d8e039f059406a3870d", "url": "https://github.com/nuxeo/nuxeo/commit/f2a242a0dd4cb3e9c8383d8e039f059406a3870d", "message": "NXP-28839: remove old explorer package", "committedDate": "2020-04-24T11:58:27Z", "type": "commit"}, {"oid": "c8cc33f2a974217096c3951711e9deede7a4f9d6", "url": "https://github.com/nuxeo/nuxeo/commit/c8cc33f2a974217096c3951711e9deede7a4f9d6", "message": "NXP-28839: cleanup explorer pom dependencies", "committedDate": "2020-04-24T11:58:27Z", "type": "commit"}, {"oid": "e850d42f4a4179113967a5d1f824196aa913276c", "url": "https://github.com/nuxeo/nuxeo/commit/e850d42f4a4179113967a5d1f824196aa913276c", "message": "NXP-28839: cleanup JSF dependencies", "committedDate": "2020-04-24T11:58:27Z", "type": "commit"}, {"oid": "f66596ad91717bee6d5542dee39a5fb1aed95ae8", "url": "https://github.com/nuxeo/nuxeo/commit/f66596ad91717bee6d5542dee39a5fb1aed95ae8", "message": "NXP-28839: extract plugin extension point for JSF plug (and other potential use cases), extract constants", "committedDate": "2020-04-24T11:58:28Z", "type": "commit"}, {"oid": "9a2de7c9389481da25744f61aaed4f937a427d60", "url": "https://github.com/nuxeo/nuxeo/commit/9a2de7c9389481da25744f61aaed4f937a427d60", "message": "NXP-28839: rework json export of the runtime snapshot (not implemented for persisted distributions).\nCompatibility on format was not kept as export was not used except in tests.", "committedDate": "2020-04-24T11:58:28Z", "type": "commit"}, {"oid": "9144dfa65632640630d0f34743f6b9adf7033e27", "url": "https://github.com/nuxeo/nuxeo/commit/9144dfa65632640630d0f34743f6b9adf7033e27", "message": "NXP-28839: add pristine package and ftests from marketplace-platform-explorer", "committedDate": "2020-04-24T11:58:28Z", "type": "commit"}, {"oid": "ed0298c23f815070b86661907977c44e60e10ce9", "url": "https://github.com/nuxeo/nuxeo/commit/ed0298c23f815070b86661907977c44e60e10ce9", "message": "NXP-28839: adapt explorer package to new build logics", "committedDate": "2020-04-24T11:58:28Z", "type": "commit"}, {"oid": "27340f811fbbe22fd8812928e2cf449cd0d8d64c", "url": "https://github.com/nuxeo/nuxeo/commit/27340f811fbbe22fd8812928e2cf449cd0d8d64c", "message": "NXP-28839: adapt explorer ftests", "committedDate": "2020-04-24T11:58:28Z", "type": "commit"}, {"oid": "39daf9a234cca0824b0085874ad962f425ddf511", "url": "https://github.com/nuxeo/nuxeo/commit/39daf9a234cca0824b0085874ad962f425ddf511", "message": "NXP-28839: add functional tests", "committedDate": "2020-04-24T11:58:28Z", "type": "commit"}, {"oid": "a32f41f41b34eae88a4eea3ebeddbb8f476623ae", "url": "https://github.com/nuxeo/nuxeo/commit/a32f41f41b34eae88a4eea3ebeddbb8f476623ae", "message": "NXP-28839: add new line at end of files", "committedDate": "2020-04-24T11:58:28Z", "type": "commit"}, {"oid": "a32f41f41b34eae88a4eea3ebeddbb8f476623ae", "url": "https://github.com/nuxeo/nuxeo/commit/a32f41f41b34eae88a4eea3ebeddbb8f476623ae", "message": "NXP-28839: add new line at end of files", "committedDate": "2020-04-24T11:58:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcxMDkyMA==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r415710920", "bodyText": "For simple UnrestrictedRunner like that; I'd recommend to use: org.nuxeo.ecm.core.api.CoreInstance#doPrivileged(java.lang.String, java.util.function.Function<org.nuxeo.ecm.core.api.CoreSession,R>)", "author": "akervern", "createdAt": "2020-04-27T10:52:08Z", "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/plugin/AbstractPlugin.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.apidoc.plugin;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+import org.nuxeo.apidoc.api.NuxeoArtifact;\n+import org.nuxeo.apidoc.repository.UnrestrictedRootCreator;\n+import org.nuxeo.apidoc.snapshot.DistributionSnapshot;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.PathRef;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * @since 11.1\n+ */\n+public abstract class AbstractPlugin<T extends NuxeoArtifact> implements Plugin<T> {\n+\n+    protected final PluginDescriptor descriptor;\n+\n+    public AbstractPlugin(PluginDescriptor descriptor) {\n+        super();\n+        this.descriptor = descriptor;\n+    }\n+\n+    @Override\n+    public String getId() {\n+        return descriptor.getId();\n+    }\n+\n+    @Override\n+    public String getPluginSnapshotClass() {\n+        return descriptor.getSnapshotClass();\n+    }\n+\n+    @Override\n+    public String getLabel() {\n+        return descriptor.getLabel();\n+    }\n+\n+    @Override\n+    public String getViewType() {\n+        return descriptor.getViewType();\n+    }\n+\n+    @Override\n+    public String getHomeView() {\n+        return descriptor.getHomeView();\n+    }\n+\n+    @Override\n+    public String getStyleClass() {\n+        return descriptor.getStyleClass();\n+    }\n+\n+    @Override\n+    public ObjectMapper enrishJsonMapper(ObjectMapper parent) {\n+        // NOOP\n+        return parent;\n+    }\n+\n+    protected DocumentModel getOrCreateSubRoot(CoreSession session, DocumentModel root, String name) {\n+        DocumentRef rootRef = new PathRef(root.getPathAsString() + name);\n+        if (session.exists(rootRef)) {\n+            return session.getDocument(rootRef);\n+        }\n+        UnrestrictedRootCreator creator = new UnrestrictedRootCreator(session, root.getPathAsString(), name, false);", "originalCommit": "a32f41f41b34eae88a4eea3ebeddbb8f476623ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcxMjkxNg==", "url": "https://github.com/nuxeo/nuxeo/pull/3908#discussion_r415712916", "bodyText": "Thanks indeed, i chose not to update this code that i moved from the inner class for easier reuse in the JSF module, but i will keep that in mind for future work \ud83d\udc4d", "author": "atchertchian", "createdAt": "2020-04-27T10:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcxMDkyMA=="}], "type": "inlineReview"}]}