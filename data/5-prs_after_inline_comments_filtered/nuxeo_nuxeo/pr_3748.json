{"pr_number": 3748, "pr_title": "NXP-28661 fix concurrent startup", "pr_createdAt": "2020-02-14T16:24:48Z", "pr_url": "https://github.com/nuxeo/nuxeo/pull/3748", "timeline": [{"oid": "4d31a81181778882c4a159011b45e458b7706913", "url": "https://github.com/nuxeo/nuxeo/commit/4d31a81181778882c4a159011b45e458b7706913", "message": "NXP-28661: disallow concurrent startup for repositories", "committedDate": "2020-02-14T16:33:31Z", "type": "forcePushed"}, {"oid": "6474647ed805eb557b4a1dcda33bab2813ec6bbc", "url": "https://github.com/nuxeo/nuxeo/commit/6474647ed805eb557b4a1dcda33bab2813ec6bbc", "message": "NXP-28661: disallow concurrent startup for repositories", "committedDate": "2020-02-14T16:57:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0MTg4MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3748#discussion_r379541880", "bodyText": "can be replaced by:  log.debug(\"Sleeping on busy lock '{}' for {}ms\", () -> key, pollDelay::toMillis);", "author": "RSalem07", "createdAt": "2020-02-14T17:00:37Z", "path": "nuxeo-runtime/nuxeo-runtime-cluster/src/main/java/org/nuxeo/runtime/cluster/ClusterServiceImpl.java", "diffHunk": "@@ -117,4 +123,148 @@ public void setNodeId(String nodeId) {\n         this.nodeId = nodeId;\n     }\n \n+    @Override\n+    public void runAtomically(String key, Duration duration, Duration pollDelay, Runnable runnable) {\n+        if (!isEnabled()) {\n+            runnable.run();\n+            return;\n+        }\n+        new ClusterLockHelper(getNodeId(), duration, pollDelay).runAtomically(key, runnable);\n+    }\n+\n+    public static class ClusterLockHelper {\n+\n+        private static final Logger log = LogManager.getLogger(ClusterLockHelper.class);\n+\n+        public static final String KV_STORE_NAME = \"cluster\";\n+\n+        // TTL set on the lock, to make it expire if the process crashes or gets stuck\n+        // this is a multiplier of the duration during which we attempt to acquire the lock\n+        private static final int TTL_MULTIPLIER = 10;\n+\n+        protected final String nodeId;\n+\n+        protected final Duration duration;\n+\n+        protected final Duration pollDelay;\n+\n+        protected final KeyValueStore kvStore;\n+\n+        public ClusterLockHelper(String nodeId, Duration duration, Duration pollDelay) {\n+            this.nodeId = nodeId;\n+            this.duration = duration;\n+            this.pollDelay = pollDelay;\n+            kvStore = Framework.getService(KeyValueService.class).getKeyValueStore(KV_STORE_NAME);\n+        }\n+\n+        /**\n+         * Runs a {@link Runnable} atomically in a cluster-wide critical section, outside a transaction.\n+         */\n+        public void runAtomically(String key, Runnable runnable) {\n+            runInSeparateTransaction(() -> runAtomicallyInternal(key, runnable));\n+        }\n+\n+        /**\n+         * Runs a {@link Runnable} outside the current transaction (committing and finally restarting it if needed).\n+         *\n+         * @implSpec this is different from {@link TransactionHelper#runWithoutTransaction(Runnable)} because that one,\n+         *           in some implementations, may keep the current transaction and start the runnable in a new thread.\n+         *           Here we don't want a new thread or a risk of deadlock, so we just commit the original transaction.\n+         */\n+        protected void runInSeparateTransaction(Runnable runnable) {\n+            // check if there is a current transaction, before committing it\n+            boolean transaction = TransactionHelper.isTransactionActiveOrMarkedRollback();\n+            if (transaction) {\n+                TransactionHelper.commitOrRollbackTransaction();\n+            }\n+            boolean completedAbruptly = true;\n+            try {\n+                if (transaction) {\n+                    TransactionHelper.runInTransaction(runnable);\n+                } else {\n+                    runnable.run();\n+                }\n+                completedAbruptly = false;\n+            } finally {\n+                if (transaction) {\n+                    // restart a transaction if there was one originally\n+                    try {\n+                        TransactionHelper.startTransaction();\n+                    } finally {\n+                        if (completedAbruptly) {\n+                            // mark rollback-only if there was an exception\n+                            TransactionHelper.setTransactionRollbackOnly();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Runs a {@link Runnable} atomically, in a cluster-wide critical section.\n+         */\n+        protected void runAtomicallyInternal(String key, Runnable runnable) {\n+            String lockInfo = tryLock(key);\n+            if (lockInfo != null) {\n+                try {\n+                    runnable.run();\n+                } finally {\n+                    unLock(key, lockInfo);\n+                }\n+            } else {\n+                throw new RuntimeServiceException(\"Failed to acquire lock '\" + key + \"' after \" + duration.toSeconds()\n+                        + \"s, owner: \" + getLock(key));\n+            }\n+        }\n+\n+        // try to acquire the lock and fail if it takes too long\n+        protected String tryLock(String key) {\n+            log.debug(\"Trying to lock '{}'\", key);\n+            long deadline = System.nanoTime() + duration.toNanos();\n+            long ttl = duration.multipliedBy(TTL_MULTIPLIER).toSeconds();\n+            do {\n+                // try to acquire the lock\n+                String lockInfo = \"node=\" + nodeId + \" time=\" + Instant.now();\n+                if (kvStore.compareAndSet(key, null, lockInfo, ttl)) {\n+                    // lock acquired\n+                    log.debug(\"Lock '{}' acquired after {}ms\", () -> key,\n+                            () -> (System.nanoTime() - (deadline - duration.toNanos())) / 1_000_000);\n+                    return lockInfo;\n+                }\n+                // wait a bit before retrying\n+                log.debug(\"  Sleeping on busy lock '{}' for {}ms\", () -> key, () -> pollDelay.toMillis());\n+                try {", "originalCommit": "8219aa9e7c91cf650cb75ac4ae26a9ea1907ae4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0Mjk3Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3748#discussion_r379542972", "bodyText": "can be replaced by:\nlog.debug(\"Failed to acquire lock '{}' after {}s\", () -> key,  tryDuration::toSeconds);", "author": "RSalem07", "createdAt": "2020-02-14T17:02:56Z", "path": "nuxeo-runtime/nuxeo-runtime-cluster/src/main/java/org/nuxeo/runtime/cluster/ClusterServiceImpl.java", "diffHunk": "@@ -117,4 +123,148 @@ public void setNodeId(String nodeId) {\n         this.nodeId = nodeId;\n     }\n \n+    @Override\n+    public void runAtomically(String key, Duration duration, Duration pollDelay, Runnable runnable) {\n+        if (!isEnabled()) {\n+            runnable.run();\n+            return;\n+        }\n+        new ClusterLockHelper(getNodeId(), duration, pollDelay).runAtomically(key, runnable);\n+    }\n+\n+    public static class ClusterLockHelper {\n+\n+        private static final Logger log = LogManager.getLogger(ClusterLockHelper.class);\n+\n+        public static final String KV_STORE_NAME = \"cluster\";\n+\n+        // TTL set on the lock, to make it expire if the process crashes or gets stuck\n+        // this is a multiplier of the duration during which we attempt to acquire the lock\n+        private static final int TTL_MULTIPLIER = 10;\n+\n+        protected final String nodeId;\n+\n+        protected final Duration duration;\n+\n+        protected final Duration pollDelay;\n+\n+        protected final KeyValueStore kvStore;\n+\n+        public ClusterLockHelper(String nodeId, Duration duration, Duration pollDelay) {\n+            this.nodeId = nodeId;\n+            this.duration = duration;\n+            this.pollDelay = pollDelay;\n+            kvStore = Framework.getService(KeyValueService.class).getKeyValueStore(KV_STORE_NAME);\n+        }\n+\n+        /**\n+         * Runs a {@link Runnable} atomically in a cluster-wide critical section, outside a transaction.\n+         */\n+        public void runAtomically(String key, Runnable runnable) {\n+            runInSeparateTransaction(() -> runAtomicallyInternal(key, runnable));\n+        }\n+\n+        /**\n+         * Runs a {@link Runnable} outside the current transaction (committing and finally restarting it if needed).\n+         *\n+         * @implSpec this is different from {@link TransactionHelper#runWithoutTransaction(Runnable)} because that one,\n+         *           in some implementations, may keep the current transaction and start the runnable in a new thread.\n+         *           Here we don't want a new thread or a risk of deadlock, so we just commit the original transaction.\n+         */\n+        protected void runInSeparateTransaction(Runnable runnable) {\n+            // check if there is a current transaction, before committing it\n+            boolean transaction = TransactionHelper.isTransactionActiveOrMarkedRollback();\n+            if (transaction) {\n+                TransactionHelper.commitOrRollbackTransaction();\n+            }\n+            boolean completedAbruptly = true;\n+            try {\n+                if (transaction) {\n+                    TransactionHelper.runInTransaction(runnable);\n+                } else {\n+                    runnable.run();\n+                }\n+                completedAbruptly = false;\n+            } finally {\n+                if (transaction) {\n+                    // restart a transaction if there was one originally\n+                    try {\n+                        TransactionHelper.startTransaction();\n+                    } finally {\n+                        if (completedAbruptly) {\n+                            // mark rollback-only if there was an exception\n+                            TransactionHelper.setTransactionRollbackOnly();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Runs a {@link Runnable} atomically, in a cluster-wide critical section.\n+         */\n+        protected void runAtomicallyInternal(String key, Runnable runnable) {\n+            String lockInfo = tryLock(key);\n+            if (lockInfo != null) {\n+                try {\n+                    runnable.run();\n+                } finally {\n+                    unLock(key, lockInfo);\n+                }\n+            } else {\n+                throw new RuntimeServiceException(\"Failed to acquire lock '\" + key + \"' after \" + duration.toSeconds()\n+                        + \"s, owner: \" + getLock(key));\n+            }\n+        }\n+\n+        // try to acquire the lock and fail if it takes too long\n+        protected String tryLock(String key) {\n+            log.debug(\"Trying to lock '{}'\", key);\n+            long deadline = System.nanoTime() + duration.toNanos();\n+            long ttl = duration.multipliedBy(TTL_MULTIPLIER).toSeconds();\n+            do {\n+                // try to acquire the lock\n+                String lockInfo = \"node=\" + nodeId + \" time=\" + Instant.now();\n+                if (kvStore.compareAndSet(key, null, lockInfo, ttl)) {\n+                    // lock acquired\n+                    log.debug(\"Lock '{}' acquired after {}ms\", () -> key,\n+                            () -> (System.nanoTime() - (deadline - duration.toNanos())) / 1_000_000);\n+                    return lockInfo;\n+                }\n+                // wait a bit before retrying\n+                log.debug(\"  Sleeping on busy lock '{}' for {}ms\", () -> key, () -> pollDelay.toMillis());\n+                try {\n+                    Thread.sleep(pollDelay.toMillis());\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                    throw new RuntimeServiceException(e);\n+                }\n+            } while (System.nanoTime() < deadline);\n+            log.debug(\"Failed to acquire lock '{}' after {}s\", () -> key, () -> duration.toSeconds());\n+            return null;", "originalCommit": "8219aa9e7c91cf650cb75ac4ae26a9ea1907ae4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0NDAxNA==", "url": "https://github.com/nuxeo/nuxeo/pull/3748#discussion_r379544014", "bodyText": "Unlocking '{}' but the lock had already expired;  -> Unlocking '{}' but the lock had already expired,  a , instead of ;", "author": "RSalem07", "createdAt": "2020-02-14T17:05:21Z", "path": "nuxeo-runtime/nuxeo-runtime-cluster/src/main/java/org/nuxeo/runtime/cluster/ClusterServiceImpl.java", "diffHunk": "@@ -117,4 +123,148 @@ public void setNodeId(String nodeId) {\n         this.nodeId = nodeId;\n     }\n \n+    @Override\n+    public void runAtomically(String key, Duration duration, Duration pollDelay, Runnable runnable) {\n+        if (!isEnabled()) {\n+            runnable.run();\n+            return;\n+        }\n+        new ClusterLockHelper(getNodeId(), duration, pollDelay).runAtomically(key, runnable);\n+    }\n+\n+    public static class ClusterLockHelper {\n+\n+        private static final Logger log = LogManager.getLogger(ClusterLockHelper.class);\n+\n+        public static final String KV_STORE_NAME = \"cluster\";\n+\n+        // TTL set on the lock, to make it expire if the process crashes or gets stuck\n+        // this is a multiplier of the duration during which we attempt to acquire the lock\n+        private static final int TTL_MULTIPLIER = 10;\n+\n+        protected final String nodeId;\n+\n+        protected final Duration duration;\n+\n+        protected final Duration pollDelay;\n+\n+        protected final KeyValueStore kvStore;\n+\n+        public ClusterLockHelper(String nodeId, Duration duration, Duration pollDelay) {\n+            this.nodeId = nodeId;\n+            this.duration = duration;\n+            this.pollDelay = pollDelay;\n+            kvStore = Framework.getService(KeyValueService.class).getKeyValueStore(KV_STORE_NAME);\n+        }\n+\n+        /**\n+         * Runs a {@link Runnable} atomically in a cluster-wide critical section, outside a transaction.\n+         */\n+        public void runAtomically(String key, Runnable runnable) {\n+            runInSeparateTransaction(() -> runAtomicallyInternal(key, runnable));\n+        }\n+\n+        /**\n+         * Runs a {@link Runnable} outside the current transaction (committing and finally restarting it if needed).\n+         *\n+         * @implSpec this is different from {@link TransactionHelper#runWithoutTransaction(Runnable)} because that one,\n+         *           in some implementations, may keep the current transaction and start the runnable in a new thread.\n+         *           Here we don't want a new thread or a risk of deadlock, so we just commit the original transaction.\n+         */\n+        protected void runInSeparateTransaction(Runnable runnable) {\n+            // check if there is a current transaction, before committing it\n+            boolean transaction = TransactionHelper.isTransactionActiveOrMarkedRollback();\n+            if (transaction) {\n+                TransactionHelper.commitOrRollbackTransaction();\n+            }\n+            boolean completedAbruptly = true;\n+            try {\n+                if (transaction) {\n+                    TransactionHelper.runInTransaction(runnable);\n+                } else {\n+                    runnable.run();\n+                }\n+                completedAbruptly = false;\n+            } finally {\n+                if (transaction) {\n+                    // restart a transaction if there was one originally\n+                    try {\n+                        TransactionHelper.startTransaction();\n+                    } finally {\n+                        if (completedAbruptly) {\n+                            // mark rollback-only if there was an exception\n+                            TransactionHelper.setTransactionRollbackOnly();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Runs a {@link Runnable} atomically, in a cluster-wide critical section.\n+         */\n+        protected void runAtomicallyInternal(String key, Runnable runnable) {\n+            String lockInfo = tryLock(key);\n+            if (lockInfo != null) {\n+                try {\n+                    runnable.run();\n+                } finally {\n+                    unLock(key, lockInfo);\n+                }\n+            } else {\n+                throw new RuntimeServiceException(\"Failed to acquire lock '\" + key + \"' after \" + duration.toSeconds()\n+                        + \"s, owner: \" + getLock(key));\n+            }\n+        }\n+\n+        // try to acquire the lock and fail if it takes too long\n+        protected String tryLock(String key) {\n+            log.debug(\"Trying to lock '{}'\", key);\n+            long deadline = System.nanoTime() + duration.toNanos();\n+            long ttl = duration.multipliedBy(TTL_MULTIPLIER).toSeconds();\n+            do {\n+                // try to acquire the lock\n+                String lockInfo = \"node=\" + nodeId + \" time=\" + Instant.now();\n+                if (kvStore.compareAndSet(key, null, lockInfo, ttl)) {\n+                    // lock acquired\n+                    log.debug(\"Lock '{}' acquired after {}ms\", () -> key,\n+                            () -> (System.nanoTime() - (deadline - duration.toNanos())) / 1_000_000);\n+                    return lockInfo;\n+                }\n+                // wait a bit before retrying\n+                log.debug(\"  Sleeping on busy lock '{}' for {}ms\", () -> key, () -> pollDelay.toMillis());\n+                try {\n+                    Thread.sleep(pollDelay.toMillis());\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                    throw new RuntimeServiceException(e);\n+                }\n+            } while (System.nanoTime() < deadline);\n+            log.debug(\"Failed to acquire lock '{}' after {}s\", () -> key, () -> duration.toSeconds());\n+            return null;\n+        }\n+\n+        protected void unLock(String key, String lockInfo) {\n+            log.debug(\"Unlocking '{}'\", key);\n+            if (kvStore.compareAndSet(key, lockInfo, null)) {\n+                return;\n+            }\n+            // couldn't remove the lock, it expired an may have been reacquired\n+            String current = kvStore.getString(key);\n+            if (current == null) {\n+                // lock expired but was not reacquired\n+                log.warn(\"Unlocking '{}' but the lock had already expired; \"", "originalCommit": "8219aa9e7c91cf650cb75ac4ae26a9ea1907ae4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU1OTY0MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3748#discussion_r379559641", "bodyText": "The ; is on purpose for better grammar.", "author": "efge", "createdAt": "2020-02-14T17:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0NDAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU2OTYwNw==", "url": "https://github.com/nuxeo/nuxeo/pull/3748#discussion_r379569607", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Feature to test the {@link CacheService}.\n          \n          \n            \n             * Feature to test the {@link ClusterService}.\n          \n      \n    \n    \n  \n\n?", "author": "troger", "createdAt": "2020-02-14T18:04:24Z", "path": "nuxeo-runtime/nuxeo-runtime-cluster/src/test/java/org/nuxeo/runtime/cluster/ClusterFeature.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Florent Guillaume\n+ */\n+package org.nuxeo.runtime.cluster;\n+\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.RunnerFeature;\n+import org.nuxeo.runtime.test.runner.RuntimeFeature;\n+\n+/**\n+ * Feature to test the {@link CacheService}.", "originalCommit": "6474647ed805eb557b4a1dcda33bab2813ec6bbc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "97e84533557afe9b9a84eefe090e67a3f02bf4a0", "url": "https://github.com/nuxeo/nuxeo/commit/97e84533557afe9b9a84eefe090e67a3f02bf4a0", "message": "NXP-28661: disallow concurrent startup for repositories", "committedDate": "2020-02-15T14:07:27Z", "type": "forcePushed"}, {"oid": "781ce7e591abd3e9d89d94107f8ef444fdf169b5", "url": "https://github.com/nuxeo/nuxeo/commit/781ce7e591abd3e9d89d94107f8ef444fdf169b5", "message": "NXP-28667: new ClusterFeature", "committedDate": "2020-02-18T13:12:42Z", "type": "commit"}, {"oid": "f8532cee703c638c04eb3108bdd003f950a297b5", "url": "https://github.com/nuxeo/nuxeo/commit/f8532cee703c638c04eb3108bdd003f950a297b5", "message": "NXP-28661: add cluster-wide lock service", "committedDate": "2020-02-18T13:12:42Z", "type": "commit"}, {"oid": "b7ab5e656a2512d54070d4cb89cf814236f308bf", "url": "https://github.com/nuxeo/nuxeo/commit/b7ab5e656a2512d54070d4cb89cf814236f308bf", "message": "NXP-28661: disallow concurrent startup for directories", "committedDate": "2020-02-18T13:19:00Z", "type": "commit"}, {"oid": "dfb90dd54dee7b571ed4969d8a151424f3af0979", "url": "https://github.com/nuxeo/nuxeo/commit/dfb90dd54dee7b571ed4969d8a151424f3af0979", "message": "NXP-28661: disallow concurrent startup for repositories", "committedDate": "2020-02-18T13:19:00Z", "type": "commit"}, {"oid": "dfb90dd54dee7b571ed4969d8a151424f3af0979", "url": "https://github.com/nuxeo/nuxeo/commit/dfb90dd54dee7b571ed4969d8a151424f3af0979", "message": "NXP-28661: disallow concurrent startup for repositories", "committedDate": "2020-02-18T13:19:00Z", "type": "forcePushed"}]}