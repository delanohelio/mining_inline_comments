{"pr_number": 627, "pr_title": "HDDS-3118. Possible deadlock in LockManager.", "pr_createdAt": "2020-03-03T06:14:31Z", "pr_url": "https://github.com/apache/ozone/pull/627", "timeline": [{"oid": "1ac2122d65b95385ad75c29869ec5c155ed46de2", "url": "https://github.com/apache/ozone/commit/1ac2122d65b95385ad75c29869ec5c155ed46de2", "message": "HDDS-3118. Possible deadlock in LockManager.", "committedDate": "2020-03-03T06:16:10Z", "type": "forcePushed"}, {"oid": "290b75f9ab103210a566ceb7c86245d3ac7f69cf", "url": "https://github.com/apache/ozone/commit/290b75f9ab103210a566ceb7c86245d3ac7f69cf", "message": "HDDS-3118. Possible deadlock in LockManager.", "committedDate": "2020-03-03T06:19:03Z", "type": "commit"}, {"oid": "290b75f9ab103210a566ceb7c86245d3ac7f69cf", "url": "https://github.com/apache/ozone/commit/290b75f9ab103210a566ceb7c86245d3ac7f69cf", "message": "HDDS-3118. Possible deadlock in LockManager.", "committedDate": "2020-03-03T06:19:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgzMDIwMA==", "url": "https://github.com/apache/ozone/pull/627#discussion_r386830200", "bodyText": "Nit: Is this necessary?  I don't see any checked exception being thrown in the try block, and unchecked exceptions don't need to be wrapped.", "author": "adoroszlai", "createdAt": "2020-03-03T07:02:57Z", "path": "hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/lock/LockManager.java", "diffHunk": "@@ -186,21 +186,42 @@ private ActiveLock getLockForLocking(final R resource) {\n      * be removed from the activeLocks map and returned to\n      * the object pool.\n      */\n-    return activeLocks.compute(resource, (k, v) -> {\n+    ActiveLock computedLock = activeLocks.compute(resource, (k, v) -> {\n       final ActiveLock lock;\n+      if (v == null) {\n+        return null;\n+      } else {\n+        lock = v;\n+      }\n+      lock.incrementActiveCount();\n+      return lock;\n+    });\n+\n+\n+    if (computedLock == null) {\n       try {\n-        if (v == null) {\n-          lock = lockPool.borrowObject();\n-        } else {\n-          lock = v;\n-        }\n-        lock.incrementActiveCount();\n+        final ActiveLock lock2 = lockPool.borrowObject();\n+        computedLock = activeLocks.compute(resource, (k, v) -> {\n+          final ActiveLock lock;\n+          try {\n+            if (v == null) {\n+              lock = lock2;\n+            } else {\n+              lockPool.returnObject(lock2);\n+              lock = v;\n+            }\n+            lock.incrementActiveCount();\n+          } catch (Exception ex) {\n+            throw new RuntimeException(ex);", "originalCommit": "290b75f9ab103210a566ceb7c86245d3ac7f69cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1MzgzOQ==", "url": "https://github.com/apache/ozone/pull/627#discussion_r387453839", "bodyText": "Based on Xiaoyu's comment reverted this change.", "author": "bharatviswa504", "createdAt": "2020-03-04T05:20:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgzMDIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzMTc3NQ==", "url": "https://github.com/apache/ozone/pull/627#discussion_r387331775", "bodyText": "Thanks @bharatviswa504 for the patch. The PR LGTM. I understand we are trying to avoid wait forever while holding the lock of the pool map. However, it does not completely solve the lock resource exhausting problem. I have a cluster with this patch but create key still can live lock by the limited number of locks (100).\nMy question is why we are restricting # of locks here via hdds.lock.max.concurrency.  In my opinion, if we change the default from 100 to -1, this deadlock will not happen. This also match the default max pool size (-1) of GenericObjectPool, especially lock is a cheaper resource compared with threads or tcp connections. To allow handling 4K+ request per second, we should consider removing this key that can easily cause deadlock, especially when handler counter is several times larger than the lock pool size.", "author": "xiaoyuyao", "createdAt": "2020-03-03T22:24:57Z", "path": "hadoop-hdds/common/src/test/java/org/apache/hadoop/ozone/lock/TestLockManager.java", "diffHunk": "@@ -170,4 +175,32 @@ public void testMultiReadWriteLockWithSameResource() throws Exception {\n     Assert.assertTrue(gotLock.get());\n   }\n \n+  @Test\n+  public void testConcurrentWriteLockWithDifferentResource() throws Exception {\n+    OzoneConfiguration conf = new OzoneConfiguration();\n+    final int count = 100;\n+    conf.setInt(HDDS_LOCK_MAX_CONCURRENCY, count/4);", "originalCommit": "290b75f9ab103210a566ceb7c86245d3ac7f69cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1MTA4Mw==", "url": "https://github.com/apache/ozone/pull/627#discussion_r387451083", "bodyText": "Yes, if we set max pool size to -1, the max total objects created by GenericcObjectPool used in Integer.MAX. I agree we can change to -1, and we shall not see this issue. And we can remove this property, and set it to -1 so that we shall not see this kind of issue when someone mistakenly sets this to a low value and operates on the cluster with very large number of volumes/buckets in parallel. With this way, we shall not see lock contention during acquiring lock.\nBut few questions, right now we take a lock on resource name, so if there is a lock Object which is already in activeLocks map, we reuse that object if it does not we borrowObject from lockPool. So,  when we operate on more than 100 buckets simultaneously we should see this problem when creating keys or when more than 100 volumes operations are going in parallel we can see some contention in acquiring locks. So, it is not exactly related to handler count in OM. Just trying to understand is the issue is observed on the test cluster, where some test is working in parallel across more than 100 volumes/100 buckets and a lock contention is observed?", "author": "bharatviswa504", "createdAt": "2020-03-04T05:07:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzMTc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1Mzc2MQ==", "url": "https://github.com/apache/ozone/pull/627#discussion_r387453761", "bodyText": "Thank You @xiaoyuyao for the review. Removed the config in the latest commit.", "author": "bharatviswa504", "createdAt": "2020-03-04T05:20:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzMTc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2MjEzNQ==", "url": "https://github.com/apache/ozone/pull/627#discussion_r387462135", "bodyText": "bq. Just trying to understand is the issue is observed on the test cluster, where some test is working in parallel across more than 100 volumes/100 buckets and a lock contention is observed?\nI hit the problem last week and had been reviewing related code along with the OM stack dumps this week. Found the fix here yesterday, tried it and found that here may not completely solve the problem. Here is the root cause:\nOMKeyCreateRequest.validateAndUpdateCache requires two locks from the lock pool to finish a key creation. One write lock for the BUCKET at the beginning and one lock for longest prefix path close to the end during prepareKeyInfo call.\nIf you have 200 threads handlers but only 100 lock limit from the lock manager. When the first 100 key creation threads all grab the bucket lock, OM will stuck there forever as we don't have any locks from the pool for the second call. My initial thought is to add a timeout but later found removing the limit seems to be a better solution as they will quickly finish and return the lock without the limit.", "author": "xiaoyuyao", "createdAt": "2020-03-04T05:56:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzMTc3NQ=="}], "type": "inlineReview"}, {"oid": "c9318d3fef029d928a13971eaddbebf4100ee7af", "url": "https://github.com/apache/ozone/commit/c9318d3fef029d928a13971eaddbebf4100ee7af", "message": "review comment", "committedDate": "2020-03-04T05:18:27Z", "type": "commit"}, {"oid": "b6bfdd29698fd541f15d2c9f74229c3d7ce28e17", "url": "https://github.com/apache/ozone/commit/b6bfdd29698fd541f15d2c9f74229c3d7ce28e17", "message": "checkstyle and set to -1 expilicitly to use INT.MAX", "committedDate": "2020-03-04T05:24:43Z", "type": "commit"}, {"oid": "146c7410300b5bfa91d26c678c9e0ac795468ce8", "url": "https://github.com/apache/ozone/commit/146c7410300b5bfa91d26c678c9e0ac795468ce8", "message": "revert", "committedDate": "2020-03-04T05:28:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1NzE0Mg==", "url": "https://github.com/apache/ozone/pull/627#discussion_r387457142", "bodyText": "NIT: we don't need to explicitly set -1 as the default maxTotal from GenericObjectPool is -1.", "author": "xiaoyuyao", "createdAt": "2020-03-04T05:35:44Z", "path": "hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/lock/LockManager.java", "diffHunk": "@@ -57,12 +56,9 @@ public LockManager(final Configuration conf) {\n    * @param fair - true to use fair lock ordering, else non-fair lock ordering.\n    */\n   public LockManager(final Configuration conf, boolean fair) {\n-    final int maxPoolSize = conf.getInt(\n-        HddsConfigKeys.HDDS_LOCK_MAX_CONCURRENCY,\n-        HddsConfigKeys.HDDS_LOCK_MAX_CONCURRENCY_DEFAULT);\n     lockPool =\n         new GenericObjectPool<>(new PooledLockFactory(fair));\n-    lockPool.setMaxTotal(maxPoolSize);\n+    lockPool.setMaxTotal(-1);", "originalCommit": "146c7410300b5bfa91d26c678c9e0ac795468ce8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1NzM1Nw==", "url": "https://github.com/apache/ozone/pull/627#discussion_r387457357", "bodyText": "yes, I did this expicitly, if in future releases if they changed the defaults it might break when we upgrade the commons-pool2.", "author": "bharatviswa504", "createdAt": "2020-03-04T05:36:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1NzE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2MjU1Mw==", "url": "https://github.com/apache/ozone/pull/627#discussion_r387462553", "bodyText": "Sounds good. +1 pending CI.", "author": "xiaoyuyao", "createdAt": "2020-03-04T05:58:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1NzE0Mg=="}], "type": "inlineReview"}]}