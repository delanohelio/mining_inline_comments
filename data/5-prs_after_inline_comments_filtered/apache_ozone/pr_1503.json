{"pr_number": 1503, "pr_title": "HDDS-4332: ListFileStatus - do lookup in directory and file tables", "pr_createdAt": "2020-10-16T16:30:57Z", "pr_url": "https://github.com/apache/ozone/pull/1503", "timeline": [{"oid": "408479dcd883223d781a0e733949754986ec9b87", "url": "https://github.com/apache/ozone/commit/408479dcd883223d781a0e733949754986ec9b87", "message": "HDDS-4332: ListFileStatus - do lookup in directory and file tables", "committedDate": "2020-10-16T16:21:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MDk0Ng==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506790946", "bodyText": "Nit: this comment seems not accurate here.", "author": "linyiqun", "createdAt": "2020-10-17T04:07:39Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -1831,6 +1838,62 @@ private OzoneFileStatus getOzoneFileStatus(String volumeName,\n             FILE_NOT_FOUND);\n   }\n \n+\n+  private OzoneFileStatus getOzoneFileStatusV1(String volumeName,\n+                                             String bucketName,\n+                                             String keyName,\n+                                             boolean sortDatanodes,\n+                                             String clientAddress)\n+          throws IOException {\n+    OzoneFileStatus fileStatus = null;\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      // Check if this is the root of the filesystem.\n+      if (keyName.length() == 0) {\n+        validateBucket(volumeName, bucketName);\n+        return new OzoneFileStatus();\n+      }\n+\n+      fileStatus = OMFileRequest.getOMKeyInfoIfExists(metadataManager,\n+              volumeName, bucketName, keyName, scmBlockSize);\n+\n+      // Check if the key is a directory.", "originalCommit": "408479dcd883223d781a0e733949754986ec9b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTUzNDk3MA==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r509534970", "bodyText": "Done", "author": "rakeshadr", "createdAt": "2020-10-21T18:07:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MDk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjAwNg==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506792006", "bodyText": "Can we use default replication type/factor:\n\nOzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT\nOzoneConfigKeys.OZONE_REPLICATION_DEFAULT", "author": "linyiqun", "createdAt": "2020-10-17T04:21:52Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -583,4 +588,112 @@ public static OmKeyInfo getOmKeyInfoFromFileTable(boolean openFileTable,\n     return dbOmKeyInfo;\n   }\n \n+  /**\n+   * Gets OmKeyInfo if exists for the given key name in the DB.\n+   *\n+   * @param omMetadataMgr metadata manager\n+   * @param volumeName    volume name\n+   * @param bucketName    bucket name\n+   * @param keyName       key name\n+   * @param scmBlockSize  scm block size\n+   * @return OzoneFileStatus\n+   * @throws IOException DB failure\n+   */\n+  @Nullable\n+  public static OzoneFileStatus getOMKeyInfoIfExists(\n+      OMMetadataManager omMetadataMgr, String volumeName, String bucketName,\n+      String keyName, long scmBlockSize) throws IOException {\n+\n+    Path keyPath = Paths.get(keyName);\n+    Iterator<Path> elements = keyPath.iterator();\n+    String bucketKey = omMetadataMgr.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataMgr.getBucketTable().get(bucketKey);\n+\n+    long lastKnownParentId = omBucketInfo.getObjectID();\n+    OmDirectoryInfo omDirInfo = null;\n+    while (elements.hasNext()) {\n+      String fileName = elements.next().toString();\n+\n+      // For example, /vol1/buck1/a/b/c/d/e/file1.txt\n+      // 1. Do lookup path component on directoryTable starting from bucket\n+      // 'buck1' to the leaf node component, which is 'file1.txt'.\n+      // 2. If there is no dir exists for the leaf node component 'file1.txt'\n+      // then do look it on fileTable.\n+      String dbNodeName = omMetadataMgr.getOzonePathKey(\n+              lastKnownParentId, fileName);\n+      omDirInfo = omMetadataMgr.getDirectoryTable().get(dbNodeName);\n+\n+      if (omDirInfo != null) {\n+        lastKnownParentId = omDirInfo.getObjectID();\n+      } else if (!elements.hasNext()) {\n+        // reached last path component. Check file exists for the given path.\n+        OmKeyInfo omKeyInfo = OMFileRequest.getOmKeyInfoFromFileTable(false,\n+                omMetadataMgr, dbNodeName, keyName);\n+        if (omKeyInfo != null) {\n+          return new OzoneFileStatus(omKeyInfo, scmBlockSize, false);\n+        }\n+      } else {\n+        // Missing intermediate directory and just return null;\n+        // key not found in DB\n+        return null;\n+      }\n+    }\n+\n+    if (omDirInfo != null) {\n+      OmKeyInfo omKeyInfo = getOmKeyInfo(volumeName, bucketName, omDirInfo,\n+              keyName);\n+      return new OzoneFileStatus(omKeyInfo, scmBlockSize, true);\n+    }\n+\n+    // key not found in DB\n+    return null;\n+  }\n+\n+  /**\n+   * Prepare OmKeyInfo from OmDirectoryInfo.\n+   *\n+   * @param volumeName volume name\n+   * @param bucketName bucket name\n+   * @param dirInfo    directory info\n+   * @param keyName    usewr given key name\n+   * @return OmKeyInfo object\n+   */\n+  @NotNull\n+  public static OmKeyInfo getOmKeyInfo(String volumeName, String bucketName,\n+      OmDirectoryInfo dirInfo, String keyName) {\n+\n+    OmKeyInfo.Builder builder = new OmKeyInfo.Builder();\n+    builder.setParentObjectID(dirInfo.getParentObjectID());\n+    builder.setKeyName(keyName);\n+    builder.setAcls(dirInfo.getAcls());\n+    builder.addAllMetadata(dirInfo.getMetadata());\n+    builder.setVolumeName(volumeName);\n+    builder.setBucketName(bucketName);\n+    builder.setCreationTime(dirInfo.getCreationTime());\n+    builder.setModificationTime(dirInfo.getModificationTime());\n+    builder.setObjectID(dirInfo.getObjectID());\n+    builder.setUpdateID(dirInfo.getUpdateID());\n+    builder.setFileName(dirInfo.getName());\n+    builder.setReplicationType(HddsProtos.ReplicationType.RATIS);\n+    builder.setReplicationFactor(HddsProtos.ReplicationFactor.ONE);", "originalCommit": "408479dcd883223d781a0e733949754986ec9b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg4ODgyMA==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r507888820", "bodyText": "I've followed existing logic during directory creation : OMDirectoryCreateRequest.java#L351.\nOzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT is string object but\nOmKeyInfo.Builder().setReplicationType(HddsProtos.ReplicationType.RATIS) requires enum ReplicationType. Changing code requires a conversion logic.\nAlso, OZONE_REPLICATION_DEFAULT is THREE but directory has a value ONE.", "author": "rakeshadr", "createdAt": "2020-10-19T16:27:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0MjAwMA==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r508242000", "bodyText": "Okay, let us keep current logic here.", "author": "linyiqun", "createdAt": "2020-10-20T06:34:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg0ODQxNQ==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506848415", "bodyText": "We also don't need args.getRefreshPipeline() here due to HDDS-3658 change.", "author": "linyiqun", "createdAt": "2020-10-17T07:19:17Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2272,167 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    List<OzoneFileStatus> fileStatusList = new ArrayList<>();\n+    if (numEntries <= 0) {\n+      return fileStatusList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    // A map sorted by OmKey to combine results from TableCache and DB.\n+    TreeMap<String, OzoneFileStatus> cacheKeyMap = new TreeMap<>();\n+    String seekKeyInDB = \"\";\n+    long prefixKeyInDB = Long.MIN_VALUE;\n+    String prefixPath = keyName;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // keyName is a directory\n+        if (fileStatus.getKeyInfo() != null) {\n+          seekKeyInDB = fileStatus.getKeyInfo().getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          seekKeyInDB = omBucketInfo.getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+      } else {\n+        // startKey will be used in iterator seek and sets the beginning point\n+        // for key traversal.\n+        // key name will be used as parent ID where the user has requested to\n+        // list the keys from.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null);\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          seekKeyInDB = prefixKeyInDB + OZONE_URI_DELIMITER\n+                  + fileStatusInfo.getKeyInfo().getFileName();\n+        }\n+      }\n+\n+      // Not required to search in TableCache because all the deleted keys\n+      // are marked directly in directory table or in key table by breaking\n+      // the pointer to its sub-dirs. So, there is no issue of inconsistency.\n+      int countEntries = 0;\n+      // Seek the given key in key table.\n+      countEntries = getFilesFromDirectory(cacheKeyMap, seekKeyInDB,\n+              prefixPath, countEntries, numEntries, prefixKeyInDB);\n+      // Seek the given key in dir table.\n+      Table dirTable = metadataManager.getDirectoryTable();\n+      TableIterator<String, ? extends Table.KeyValue<String, OmDirectoryInfo>>\n+              iterator = dirTable.iterator();\n+\n+      iterator.seek(seekKeyInDB);\n+\n+      while (iterator.hasNext() && numEntries - countEntries > 0) {\n+        String entryInDb = iterator.key();\n+        OmDirectoryInfo dirInfo = iterator.value().getValue();\n+        if (!isImmediateChild(dirInfo.getParentObjectID(), prefixKeyInDB)) {\n+          break;\n+        }\n+\n+        if (recursive) {\n+          // for recursive list all the entries\n+          prefixPath = OMFileRequest.getAbsolutePath(prefixPath,\n+                  dirInfo.getName());\n+          OmKeyInfo omKeyInfo = OMFileRequest.getOmKeyInfo(volumeName,\n+                  bucketName, dirInfo, prefixPath);\n+          cacheKeyMap.put(entryInDb,\n+                  new OzoneFileStatus(omKeyInfo, 0, true));\n+          ++countEntries;\n+          // files from this directory\n+          seekKeyInDB = dirInfo.getObjectID() + OZONE_URI_DELIMITER;\n+          countEntries = getFilesFromDirectory(cacheKeyMap, seekKeyInDB,\n+                  prefixPath, countEntries, numEntries, prefixKeyInDB);\n+        } else {\n+          String dirName = OMFileRequest.getAbsolutePath(prefixPath,\n+                  dirInfo.getName());\n+          OmKeyInfo omKeyInfo = OMFileRequest.getOmKeyInfo(volumeName,\n+                  bucketName, dirInfo, dirName);\n+          cacheKeyMap.put(entryInDb,\n+                  new OzoneFileStatus(omKeyInfo, 0, true));\n+          countEntries++;\n+        }\n+        // move to next entry in the table\n+        iterator.next();\n+      }\n+    } finally {\n+      metadataManager.getLock().releaseReadLock(BUCKET_LOCK, volumeName,\n+              bucketName);\n+    }\n+\n+    int countEntries = 0;\n+    // Convert results in cacheKeyMap to List\n+    for (Map.Entry<String, OzoneFileStatus> entry : cacheKeyMap.entrySet()) {\n+      // No need to check if a key is deleted or not here, this is handled\n+      // when adding entries to cacheKeyMap from DB.\n+      if (args.getRefreshPipeline()) {", "originalCommit": "408479dcd883223d781a0e733949754986ec9b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTUzNTg1Mg==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r509535852", "bodyText": "Done", "author": "rakeshadr", "createdAt": "2020-10-21T18:07:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg0ODQxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg1MTMxMA==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506851310", "bodyText": "Can we reuse an existed method OzoneFSUtils#addTrailingSlashIfNeeded(keyName) instead of?", "author": "linyiqun", "createdAt": "2020-10-17T07:28:49Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2272,167 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    List<OzoneFileStatus> fileStatusList = new ArrayList<>();\n+    if (numEntries <= 0) {\n+      return fileStatusList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    // A map sorted by OmKey to combine results from TableCache and DB.\n+    TreeMap<String, OzoneFileStatus> cacheKeyMap = new TreeMap<>();\n+    String seekKeyInDB = \"\";\n+    long prefixKeyInDB = Long.MIN_VALUE;\n+    String prefixPath = keyName;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // keyName is a directory\n+        if (fileStatus.getKeyInfo() != null) {\n+          seekKeyInDB = fileStatus.getKeyInfo().getObjectID()\n+                  + OZONE_URI_DELIMITER;", "originalCommit": "408479dcd883223d781a0e733949754986ec9b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTUzNTk5OQ==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r509535999", "bodyText": "Done", "author": "rakeshadr", "createdAt": "2020-10-21T18:08:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg1MTMxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg1NDU0OA==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506854548", "bodyText": "If we cannot find the first OzoneFileStatus based on given startKey. It means that there is no other  OzoneFileStatus matched. And we should return the empty list.", "author": "linyiqun", "createdAt": "2020-10-17T07:35:16Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2272,167 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    List<OzoneFileStatus> fileStatusList = new ArrayList<>();\n+    if (numEntries <= 0) {\n+      return fileStatusList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    // A map sorted by OmKey to combine results from TableCache and DB.\n+    TreeMap<String, OzoneFileStatus> cacheKeyMap = new TreeMap<>();\n+    String seekKeyInDB = \"\";\n+    long prefixKeyInDB = Long.MIN_VALUE;\n+    String prefixPath = keyName;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // keyName is a directory\n+        if (fileStatus.getKeyInfo() != null) {\n+          seekKeyInDB = fileStatus.getKeyInfo().getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          seekKeyInDB = omBucketInfo.getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+      } else {\n+        // startKey will be used in iterator seek and sets the beginning point\n+        // for key traversal.\n+        // key name will be used as parent ID where the user has requested to\n+        // list the keys from.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null);\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          seekKeyInDB = prefixKeyInDB + OZONE_URI_DELIMITER\n+                  + fileStatusInfo.getKeyInfo().getFileName();\n+        }", "originalCommit": "408479dcd883223d781a0e733949754986ec9b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkwNTc3MQ==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r514905771", "bodyText": "Done!", "author": "rakeshadr", "createdAt": "2020-10-30T07:06:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg1NDU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg1NzAyMw==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506857023", "bodyText": "startKey can be a non-existed key here. We cannot just reuse getOzoneFileStatusV1 to find the OzoneFileStatus. getOzoneFileStatusV1 needs the key existed then it has the result.\nExample,\nkey list:\n/a/a\n/a/c\n/a/d\nIf given startkey: /a/b, here should return /a/c", "author": "linyiqun", "createdAt": "2020-10-17T07:42:51Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2272,167 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    List<OzoneFileStatus> fileStatusList = new ArrayList<>();\n+    if (numEntries <= 0) {\n+      return fileStatusList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    // A map sorted by OmKey to combine results from TableCache and DB.\n+    TreeMap<String, OzoneFileStatus> cacheKeyMap = new TreeMap<>();\n+    String seekKeyInDB = \"\";\n+    long prefixKeyInDB = Long.MIN_VALUE;\n+    String prefixPath = keyName;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // keyName is a directory\n+        if (fileStatus.getKeyInfo() != null) {\n+          seekKeyInDB = fileStatus.getKeyInfo().getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          seekKeyInDB = omBucketInfo.getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+      } else {\n+        // startKey will be used in iterator seek and sets the beginning point\n+        // for key traversal.\n+        // key name will be used as parent ID where the user has requested to\n+        // list the keys from.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null);", "originalCommit": "408479dcd883223d781a0e733949754986ec9b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU0MzM3Ng==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r509543376", "bodyText": "Good point. I kept this as an open point now and not addressed in my latest commit. Need to do some more testing to understand the existing behavior.", "author": "rakeshadr", "createdAt": "2020-10-21T18:16:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg1NzAyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0NjkwMA==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r509846900", "bodyText": "Raised HDDS-4364 jira to handle this case.", "author": "rakeshadr", "createdAt": "2020-10-22T02:45:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg1NzAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg2MDQ3OA==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506860478", "bodyText": "We need to pass scmBlockSize as well:\nOzoneFileStatus(keyInfo, 0, false) -> OzoneFileStatus(keyInfo, scmBlockSize, false)", "author": "linyiqun", "createdAt": "2020-10-17T07:54:43Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2272,167 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    List<OzoneFileStatus> fileStatusList = new ArrayList<>();\n+    if (numEntries <= 0) {\n+      return fileStatusList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    // A map sorted by OmKey to combine results from TableCache and DB.\n+    TreeMap<String, OzoneFileStatus> cacheKeyMap = new TreeMap<>();\n+    String seekKeyInDB = \"\";\n+    long prefixKeyInDB = Long.MIN_VALUE;\n+    String prefixPath = keyName;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // keyName is a directory\n+        if (fileStatus.getKeyInfo() != null) {\n+          seekKeyInDB = fileStatus.getKeyInfo().getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          seekKeyInDB = omBucketInfo.getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+      } else {\n+        // startKey will be used in iterator seek and sets the beginning point\n+        // for key traversal.\n+        // key name will be used as parent ID where the user has requested to\n+        // list the keys from.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null);\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          seekKeyInDB = prefixKeyInDB + OZONE_URI_DELIMITER\n+                  + fileStatusInfo.getKeyInfo().getFileName();\n+        }\n+      }\n+\n+      // Not required to search in TableCache because all the deleted keys\n+      // are marked directly in directory table or in key table by breaking\n+      // the pointer to its sub-dirs. So, there is no issue of inconsistency.\n+      int countEntries = 0;\n+      // Seek the given key in key table.\n+      countEntries = getFilesFromDirectory(cacheKeyMap, seekKeyInDB,\n+              prefixPath, countEntries, numEntries, prefixKeyInDB);\n+      // Seek the given key in dir table.\n+      Table dirTable = metadataManager.getDirectoryTable();\n+      TableIterator<String, ? extends Table.KeyValue<String, OmDirectoryInfo>>\n+              iterator = dirTable.iterator();\n+\n+      iterator.seek(seekKeyInDB);\n+\n+      while (iterator.hasNext() && numEntries - countEntries > 0) {\n+        String entryInDb = iterator.key();\n+        OmDirectoryInfo dirInfo = iterator.value().getValue();\n+        if (!isImmediateChild(dirInfo.getParentObjectID(), prefixKeyInDB)) {\n+          break;\n+        }\n+\n+        if (recursive) {\n+          // for recursive list all the entries\n+          prefixPath = OMFileRequest.getAbsolutePath(prefixPath,\n+                  dirInfo.getName());\n+          OmKeyInfo omKeyInfo = OMFileRequest.getOmKeyInfo(volumeName,\n+                  bucketName, dirInfo, prefixPath);\n+          cacheKeyMap.put(entryInDb,\n+                  new OzoneFileStatus(omKeyInfo, 0, true));\n+          ++countEntries;\n+          // files from this directory\n+          seekKeyInDB = dirInfo.getObjectID() + OZONE_URI_DELIMITER;\n+          countEntries = getFilesFromDirectory(cacheKeyMap, seekKeyInDB,\n+                  prefixPath, countEntries, numEntries, prefixKeyInDB);\n+        } else {\n+          String dirName = OMFileRequest.getAbsolutePath(prefixPath,\n+                  dirInfo.getName());\n+          OmKeyInfo omKeyInfo = OMFileRequest.getOmKeyInfo(volumeName,\n+                  bucketName, dirInfo, dirName);\n+          cacheKeyMap.put(entryInDb,\n+                  new OzoneFileStatus(omKeyInfo, 0, true));\n+          countEntries++;\n+        }\n+        // move to next entry in the table\n+        iterator.next();\n+      }\n+    } finally {\n+      metadataManager.getLock().releaseReadLock(BUCKET_LOCK, volumeName,\n+              bucketName);\n+    }\n+\n+    int countEntries = 0;\n+    // Convert results in cacheKeyMap to List\n+    for (Map.Entry<String, OzoneFileStatus> entry : cacheKeyMap.entrySet()) {\n+      // No need to check if a key is deleted or not here, this is handled\n+      // when adding entries to cacheKeyMap from DB.\n+      if (args.getRefreshPipeline()) {\n+        refreshPipeline(entry.getValue().getKeyInfo());\n+      }\n+      fileStatusList.add(entry.getValue());\n+      if (args.getSortDatanodes()) {\n+        sortDatanodeInPipeline(entry.getValue().getKeyInfo(), clientAddress);\n+      }\n+      countEntries++;\n+      if (countEntries >= numEntries) {\n+        break;\n+      }\n+    }\n+    // Clean up temp map and set\n+    cacheKeyMap.clear();\n+\n+    return fileStatusList;\n+  }\n+\n+  private int getFilesFromDirectory(Map<String, OzoneFileStatus> cacheKeyMap,\n+      String seekKeyInDB, String prefixKeyPath, int countEntries,\n+      long numEntries, long prefixKeyInDB) throws IOException {\n+\n+    Table<String, OmKeyInfo> keyTable = metadataManager.getKeyTable();\n+    TableIterator<String, ? extends Table.KeyValue<String, OmKeyInfo>>\n+            iterator = keyTable.iterator();\n+    iterator.seek(seekKeyInDB);\n+    while (iterator.hasNext() && numEntries - countEntries > 0) {\n+      String entryInDb = iterator.key();\n+      OmKeyInfo keyInfo = iterator.value().getValue();\n+\n+      if (!isImmediateChild(keyInfo.getParentObjectID(), prefixKeyInDB)) {\n+        break;\n+      }\n+\n+      keyInfo.setFileName(keyInfo.getKeyName());\n+      String fullKeyPath = OMFileRequest.getAbsolutePath(prefixKeyPath,\n+              keyInfo.getKeyName());\n+      keyInfo.setKeyName(fullKeyPath);\n+      cacheKeyMap.put(entryInDb, new OzoneFileStatus(keyInfo, 0, false));", "originalCommit": "408479dcd883223d781a0e733949754986ec9b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU0MzUzOA==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r509543538", "bodyText": "Done", "author": "rakeshadr", "createdAt": "2020-10-21T18:16:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg2MDQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg2MTY0NA==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506861644", "bodyText": "Can we remove this unused line.", "author": "linyiqun", "createdAt": "2020-10-17T07:58:00Z", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystem.java", "diffHunk": "@@ -249,12 +273,10 @@ public void tearDown() {\n     }\n   }\n \n-  private void setupOzoneFileSystem()\n+  protected void setupOzoneFileSystem()\n       throws IOException, TimeoutException, InterruptedException {\n-    OzoneConfiguration conf = new OzoneConfiguration();\n-    conf.setInt(FS_TRASH_INTERVAL_KEY, 1);\n-    conf.setBoolean(OMConfigKeys.OZONE_OM_ENABLE_FILESYSTEM_PATHS,\n-        enabledFileSystemPaths);\n+    OzoneConfiguration conf = getOzoneConfig();\n+    //conf.set(OMConfigKeys.OZONE_OM_LAYOUT_VERSION, \"V1\");", "originalCommit": "408479dcd883223d781a0e733949754986ec9b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU0MzYyNA==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r509543624", "bodyText": "Done", "author": "rakeshadr", "createdAt": "2020-10-21T18:16:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg2MTY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg3NDc2Ng==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506874766", "bodyText": "prefixKeyInDB should also updated to new dir objectID dirInfo.getObjectID()", "author": "linyiqun", "createdAt": "2020-10-17T08:14:21Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2272,167 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    List<OzoneFileStatus> fileStatusList = new ArrayList<>();\n+    if (numEntries <= 0) {\n+      return fileStatusList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    // A map sorted by OmKey to combine results from TableCache and DB.\n+    TreeMap<String, OzoneFileStatus> cacheKeyMap = new TreeMap<>();\n+    String seekKeyInDB = \"\";\n+    long prefixKeyInDB = Long.MIN_VALUE;\n+    String prefixPath = keyName;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // keyName is a directory\n+        if (fileStatus.getKeyInfo() != null) {\n+          seekKeyInDB = fileStatus.getKeyInfo().getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          seekKeyInDB = omBucketInfo.getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+      } else {\n+        // startKey will be used in iterator seek and sets the beginning point\n+        // for key traversal.\n+        // key name will be used as parent ID where the user has requested to\n+        // list the keys from.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null);\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          seekKeyInDB = prefixKeyInDB + OZONE_URI_DELIMITER\n+                  + fileStatusInfo.getKeyInfo().getFileName();\n+        }\n+      }\n+\n+      // Not required to search in TableCache because all the deleted keys\n+      // are marked directly in directory table or in key table by breaking\n+      // the pointer to its sub-dirs. So, there is no issue of inconsistency.\n+      int countEntries = 0;\n+      // Seek the given key in key table.\n+      countEntries = getFilesFromDirectory(cacheKeyMap, seekKeyInDB,\n+              prefixPath, countEntries, numEntries, prefixKeyInDB);\n+      // Seek the given key in dir table.\n+      Table dirTable = metadataManager.getDirectoryTable();\n+      TableIterator<String, ? extends Table.KeyValue<String, OmDirectoryInfo>>\n+              iterator = dirTable.iterator();\n+\n+      iterator.seek(seekKeyInDB);\n+\n+      while (iterator.hasNext() && numEntries - countEntries > 0) {\n+        String entryInDb = iterator.key();\n+        OmDirectoryInfo dirInfo = iterator.value().getValue();\n+        if (!isImmediateChild(dirInfo.getParentObjectID(), prefixKeyInDB)) {\n+          break;\n+        }\n+\n+        if (recursive) {\n+          // for recursive list all the entries\n+          prefixPath = OMFileRequest.getAbsolutePath(prefixPath,\n+                  dirInfo.getName());\n+          OmKeyInfo omKeyInfo = OMFileRequest.getOmKeyInfo(volumeName,\n+                  bucketName, dirInfo, prefixPath);\n+          cacheKeyMap.put(entryInDb,\n+                  new OzoneFileStatus(omKeyInfo, 0, true));\n+          ++countEntries;\n+          // files from this directory\n+          seekKeyInDB = dirInfo.getObjectID() + OZONE_URI_DELIMITER;", "originalCommit": "408479dcd883223d781a0e733949754986ec9b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU0MzcxNg==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r509543716", "bodyText": "Done", "author": "rakeshadr", "createdAt": "2020-10-21T18:16:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg3NDc2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg4MDA0NQ==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506880045", "bodyText": "Typo: usewr -> user", "author": "linyiqun", "createdAt": "2020-10-17T08:18:30Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -583,4 +588,112 @@ public static OmKeyInfo getOmKeyInfoFromFileTable(boolean openFileTable,\n     return dbOmKeyInfo;\n   }\n \n+  /**\n+   * Gets OmKeyInfo if exists for the given key name in the DB.\n+   *\n+   * @param omMetadataMgr metadata manager\n+   * @param volumeName    volume name\n+   * @param bucketName    bucket name\n+   * @param keyName       key name\n+   * @param scmBlockSize  scm block size\n+   * @return OzoneFileStatus\n+   * @throws IOException DB failure\n+   */\n+  @Nullable\n+  public static OzoneFileStatus getOMKeyInfoIfExists(\n+      OMMetadataManager omMetadataMgr, String volumeName, String bucketName,\n+      String keyName, long scmBlockSize) throws IOException {\n+\n+    Path keyPath = Paths.get(keyName);\n+    Iterator<Path> elements = keyPath.iterator();\n+    String bucketKey = omMetadataMgr.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataMgr.getBucketTable().get(bucketKey);\n+\n+    long lastKnownParentId = omBucketInfo.getObjectID();\n+    OmDirectoryInfo omDirInfo = null;\n+    while (elements.hasNext()) {\n+      String fileName = elements.next().toString();\n+\n+      // For example, /vol1/buck1/a/b/c/d/e/file1.txt\n+      // 1. Do lookup path component on directoryTable starting from bucket\n+      // 'buck1' to the leaf node component, which is 'file1.txt'.\n+      // 2. If there is no dir exists for the leaf node component 'file1.txt'\n+      // then do look it on fileTable.\n+      String dbNodeName = omMetadataMgr.getOzonePathKey(\n+              lastKnownParentId, fileName);\n+      omDirInfo = omMetadataMgr.getDirectoryTable().get(dbNodeName);\n+\n+      if (omDirInfo != null) {\n+        lastKnownParentId = omDirInfo.getObjectID();\n+      } else if (!elements.hasNext()) {\n+        // reached last path component. Check file exists for the given path.\n+        OmKeyInfo omKeyInfo = OMFileRequest.getOmKeyInfoFromFileTable(false,\n+                omMetadataMgr, dbNodeName, keyName);\n+        if (omKeyInfo != null) {\n+          return new OzoneFileStatus(omKeyInfo, scmBlockSize, false);\n+        }\n+      } else {\n+        // Missing intermediate directory and just return null;\n+        // key not found in DB\n+        return null;\n+      }\n+    }\n+\n+    if (omDirInfo != null) {\n+      OmKeyInfo omKeyInfo = getOmKeyInfo(volumeName, bucketName, omDirInfo,\n+              keyName);\n+      return new OzoneFileStatus(omKeyInfo, scmBlockSize, true);\n+    }\n+\n+    // key not found in DB\n+    return null;\n+  }\n+\n+  /**\n+   * Prepare OmKeyInfo from OmDirectoryInfo.\n+   *\n+   * @param volumeName volume name\n+   * @param bucketName bucket name\n+   * @param dirInfo    directory info\n+   * @param keyName    usewr given key name", "originalCommit": "408479dcd883223d781a0e733949754986ec9b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU0Mzc3OQ==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r509543779", "bodyText": "Done", "author": "rakeshadr", "createdAt": "2020-10-21T18:16:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg4MDA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg4NzM3Mg==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506887372", "bodyText": "We should reset prefixPath after we find the first ozone file info to list.", "author": "linyiqun", "createdAt": "2020-10-17T08:32:45Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2272,167 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    List<OzoneFileStatus> fileStatusList = new ArrayList<>();\n+    if (numEntries <= 0) {\n+      return fileStatusList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    // A map sorted by OmKey to combine results from TableCache and DB.\n+    TreeMap<String, OzoneFileStatus> cacheKeyMap = new TreeMap<>();\n+    String seekKeyInDB = \"\";\n+    long prefixKeyInDB = Long.MIN_VALUE;\n+    String prefixPath = keyName;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // keyName is a directory\n+        if (fileStatus.getKeyInfo() != null) {\n+          seekKeyInDB = fileStatus.getKeyInfo().getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          seekKeyInDB = omBucketInfo.getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+      } else {\n+        // startKey will be used in iterator seek and sets the beginning point\n+        // for key traversal.\n+        // key name will be used as parent ID where the user has requested to\n+        // list the keys from.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null);\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          seekKeyInDB = prefixKeyInDB + OZONE_URI_DELIMITER\n+                  + fileStatusInfo.getKeyInfo().getFileName();", "originalCommit": "408479dcd883223d781a0e733949754986ec9b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2NjA5Mg==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r508666092", "bodyText": "Good catch. With recursive flag false, prefix path will always be same as user given keyname. But with recursive flag true, it can change between two pages, if the second page is iterating on the sub-dirs of the given user keyname.\nI have raised separate jira HDDS-4360 to handle the recursive logic. IMHO that would be helpful to do more focussed development.", "author": "rakeshadr", "createdAt": "2020-10-20T16:19:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg4NzM3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1Mzk3Mw==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r508953973", "bodyText": "Yes, the logic for recursive makes this more complex.", "author": "linyiqun", "createdAt": "2020-10-21T02:39:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg4NzM3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg4NzYxMA==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506887610", "bodyText": "Should reset prefixPath to bucketKey I think.", "author": "linyiqun", "createdAt": "2020-10-17T08:33:34Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2272,167 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    List<OzoneFileStatus> fileStatusList = new ArrayList<>();\n+    if (numEntries <= 0) {\n+      return fileStatusList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    // A map sorted by OmKey to combine results from TableCache and DB.\n+    TreeMap<String, OzoneFileStatus> cacheKeyMap = new TreeMap<>();\n+    String seekKeyInDB = \"\";\n+    long prefixKeyInDB = Long.MIN_VALUE;\n+    String prefixPath = keyName;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // keyName is a directory\n+        if (fileStatus.getKeyInfo() != null) {\n+          seekKeyInDB = fileStatus.getKeyInfo().getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          seekKeyInDB = omBucketInfo.getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = omBucketInfo.getObjectID();", "originalCommit": "408479dcd883223d781a0e733949754986ec9b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQxODE0Mg==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r508418142", "bodyText": "\"/vol/bucket/\" is the root directory and the first level directories are under this. Thats the reason I left, prefixPath as empty. PrefixPath is used to build the absolute key path name which will be added to the OMKeyInfo#keyName. Existing code base don't have volume/bucket name in the key path name.", "author": "rakeshadr", "createdAt": "2020-10-20T11:19:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg4NzYxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1Nzc3NQ==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r508957775", "bodyText": "Thanks for correct me. I am thinking more for this, here the case is that we cannot find the expected key info due to a non-exist key name, right. So maybe we should just return the empty list. Because we give a wrong key name.\nAbove logic lists the first level directories are under this, this is for the case when key name is empty. For the key name is not empty, empty list expected to be returned.", "author": "linyiqun", "createdAt": "2020-10-21T02:53:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg4NzYxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk5OTIwNA==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r508999204", "bodyText": "Yes, this condition is for the root directory listing. fileSystem.listStatus(new Path(\"o3fs://bucket1.vol1/\"))\nFor a wrong or non-existing keyname, today it is throwing exception. I have referred code base KeyManagerImpl.java#L1823", "author": "rakeshadr", "createdAt": "2020-10-21T05:30:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg4NzYxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE2MzM5NA==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r509163394", "bodyText": "Okay, get it.", "author": "linyiqun", "createdAt": "2020-10-21T10:22:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg4NzYxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk1NDczNg==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506954736", "bodyText": "Additionally, startKey needs to be normalized when FileSystemPaths enabled, related JIRA: HDDS-4117", "author": "linyiqun", "createdAt": "2020-10-17T15:36:29Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2272,167 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    List<OzoneFileStatus> fileStatusList = new ArrayList<>();\n+    if (numEntries <= 0) {\n+      return fileStatusList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();", "originalCommit": "408479dcd883223d781a0e733949754986ec9b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3MzIwNg==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r508673206", "bodyText": "Thanks a lot for pointing out this. Since the startKey value is internally taken from the OMKeyInfo.keyName, I thought the path would have already been in the normalized form. I saw startKey normalization in PR #1451, I would like to hear from @bharatviswa504 about the plans and follow the same logic here as well.", "author": "rakeshadr", "createdAt": "2020-10-20T16:30:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk1NDczNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MTgzOQ==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r508951839", "bodyText": "Seems the keyName in OmKeyArgs already be normalized. But startKey is not included in that, it's an independent parameter passed in here. So the PR #1451 did the fix for this.", "author": "linyiqun", "createdAt": "2020-10-21T02:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk1NDczNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MzUyMA==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r508953520", "bodyText": "Noted and will add TODO in V1 code. I will watch #1451 progress and will incorporate that logic in V1 once that PR is merged. Hope that make sense to you?", "author": "rakeshadr", "createdAt": "2020-10-21T02:37:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk1NDczNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1NTA2MQ==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r508955061", "bodyText": "Makes sense to me.", "author": "linyiqun", "createdAt": "2020-10-21T02:43:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk1NDczNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzAzODc0Ng==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r507038746", "bodyText": "Currently, CreateFile/CreateDir of V1 version also add entry into double buffer cache first, then flush to db. So seems we still need to combine the result from table cache and db.\nFor the further DeleteFile/DeleteDir API implement, we may still follow this table cache way. Not fully understand why here we say ' deleted keys are marked directly in directory table'. Current write type request always operate the cache first, then flush to db I think.", "author": "linyiqun", "createdAt": "2020-10-18T08:18:24Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2272,167 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    List<OzoneFileStatus> fileStatusList = new ArrayList<>();\n+    if (numEntries <= 0) {\n+      return fileStatusList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    // A map sorted by OmKey to combine results from TableCache and DB.\n+    TreeMap<String, OzoneFileStatus> cacheKeyMap = new TreeMap<>();\n+    String seekKeyInDB = \"\";\n+    long prefixKeyInDB = Long.MIN_VALUE;\n+    String prefixPath = keyName;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // keyName is a directory\n+        if (fileStatus.getKeyInfo() != null) {\n+          seekKeyInDB = fileStatus.getKeyInfo().getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          seekKeyInDB = omBucketInfo.getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+      } else {\n+        // startKey will be used in iterator seek and sets the beginning point\n+        // for key traversal.\n+        // key name will be used as parent ID where the user has requested to\n+        // list the keys from.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null);\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          seekKeyInDB = prefixKeyInDB + OZONE_URI_DELIMITER\n+                  + fileStatusInfo.getKeyInfo().getFileName();\n+        }\n+      }\n+\n+      // Not required to search in TableCache because all the deleted keys\n+      // are marked directly in directory table or in key table by breaking\n+      // the pointer to its sub-dirs. So, there is no issue of inconsistency.\n+      int countEntries = 0;", "originalCommit": "408479dcd883223d781a0e733949754986ec9b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU0ODgwNw==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r509548807", "bodyText": "Thanks @linyiqun for pointing out this case. I have implemented File & Dir Table cache logic in latest commit. As the plan is to update the Dir & FileTable directly during delete api, ideally there is no need of considering deletedTableCache. Will revisit this logic once we implement the delete api.\nI have commented in HDDS-4358 jira", "author": "rakeshadr", "createdAt": "2020-10-21T18:22:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzAzODc0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAzMDMxNg==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r510030316", "bodyText": "Okay, makes sense to me.", "author": "linyiqun", "createdAt": "2020-10-22T09:50:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzAzODc0Ng=="}], "type": "inlineReview"}, {"oid": "d3e9035b7e0b0a28102c481d1d887b6b56abc656", "url": "https://github.com/apache/ozone/commit/d3e9035b7e0b0a28102c481d1d887b6b56abc656", "message": "Fixed review comments - startKey, tableCache functionality", "committedDate": "2020-10-21T18:06:36Z", "type": "commit"}, {"oid": "e70dbabd7bacc7b0b21771e0a5013114b9072a09", "url": "https://github.com/apache/ozone/commit/e70dbabd7bacc7b0b21771e0a5013114b9072a09", "message": "Fixed checkstyle warnings.", "committedDate": "2020-10-22T03:04:48Z", "type": "commit"}, {"oid": "57d92c33bb7b5cd47b281eecadcc0fa464205267", "url": "https://github.com/apache/ozone/commit/57d92c33bb7b5cd47b281eecadcc0fa464205267", "message": "Fixed UT failure - skipFileNotFoundError", "committedDate": "2020-10-22T03:33:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAxNzczNw==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r510017737", "bodyText": "For this branch, we use startKey to get the key info and it's a file in key table. So we will not have the same key string as startKey in dir table. Here I think we should just return one  single file\nCollections.singletonList(fileStatusInfo);", "author": "linyiqun", "createdAt": "2020-10-22T09:31:34Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2276,318 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    // unsorted OMKeyInfo list contains combine results from TableCache and DB.\n+    List<OzoneFileStatus> fileStatusFinalList = new ArrayList<>();\n+    LinkedHashSet<OzoneFileStatus> fileStatusList = new LinkedHashSet<>();\n+    if (numEntries <= 0) {\n+      return fileStatusFinalList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    String seekFileInDB;\n+    String seekDirInDB;\n+    long prefixKeyInDB;\n+    String prefixPath = keyName;\n+\n+    int countEntries = 0;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // Not required to search in DeletedTable because all the deleted\n+        // keys will be marked directly in dirTable or in keyTable by\n+        // breaking the pointer to its sub-dirs. So, there is no issue of\n+        // inconsistency.\n+\n+        /*\n+         * keyName is a directory.\n+         * Say, \"/a\" is the dir name and its objectID is 1024, then seek\n+         * will be doing with \"1024/\" to get all immediate descendants.\n+         */\n+        if (fileStatus.getKeyInfo() != null) {\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          // list root directory.\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+        seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+        seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        // Order of seek -> (1)Seek dirs in dirTable (2)Seek files in fileTable\n+        // 1. Seek the given key in key table.\n+        countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                prefixPath, prefixKeyInDB, startKey, countEntries, numEntries);\n+        // 2. Seek the given key in dir table.\n+        getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                volumeName, bucketName, seekDirInDB, prefixKeyInDB,\n+                prefixPath, countEntries);\n+      } else {\n+        /*\n+         * startKey will be used in iterator seek and sets the beginning point\n+         * for key traversal.\n+         *\n+         * key name will be used as parentID where the user has requested to\n+         * list the keys from.\n+         *\n+         * When recursive flag=false, parentID won't change between two pages.\n+         * For example: OM has a namespace like,\n+         *    /a/1...1M files and /a/b/1...1M files.\n+         *    /a/1...1M directories and /a/b/1...1M directories.\n+         * Listing \"/a\", will always have the parentID as \"a\" irrespective of\n+         * the startKey value.\n+         */\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null, true);\n+\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          if(fileStatusInfo.isDirectory()){\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+\n+            // Order of seek -> (1) Seek dirs in dirTable. In OM, always the\n+            // order of search is, first seek into fileTable and then dirTable.\n+            // So, its not required to search again into the fileTable.\n+\n+            // Seek the given key in dirTable.\n+            getDirectories(recursive, startKey, numEntries,\n+                    fileStatusList, volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+\n+          } else {\n+            seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB,", "originalCommit": "57d92c33bb7b5cd47b281eecadcc0fa464205267", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQ1Mjg3Nw==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r512452877", "bodyText": "As we have to perform seek in two tables to finish the listing, I'm maintaining a seek order\n\nSeek all the files from FileTable, then\nStart seeking dirs from DirTable.\n\nThats the reason for continuing seek the given key in DirTable using logic:\n            // begins from the first sub-dir under the parent dir\n            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n\nFor example: OM has a namespace like,\n/a/1...1M files and /a/dir1...dirM directories\n\nkeyName='/a' and its objectId is \"1027/\"\n\nHere, iterate to finish all 1M files using the startKey indexes and then move the parent pointer to '1027/' to seek the contents from DirTable. Now, onwards the startKey represents directory entires. Once all dirs are listed thats the break point and come out to send response back to the user #lisStatus API call.", "author": "rakeshadr", "createdAt": "2020-10-27T06:56:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAxNzczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEwMDE1NQ==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r514100155", "bodyText": "Hi @rakeshadr , I agreed with the case you mentioned. That's the case when there is no entry key name exactly\nequals to startKey. And then we need to lookup the file table, dir table.\nCan you check below corner case I am thinking here:\nFileTable\n/a/a1\n/a/a1_2\nDirTable\n/a/a12\nHere we pass startKey /a/a1 and find the target file entry which name is completely matched, then we still need to list FileTable, DirTable and get /a/a1_2,  /a/a12 entry?\nIf  /a/a1_2,  /a/a12  is expected to return under startKey semantic, I'm okay for current logic.", "author": "linyiqun", "createdAt": "2020-10-29T09:01:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAxNzczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI3NDM1OQ==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r514274359", "bodyText": "Thanks @linyiqun for the detailed example case.\nyes, it will first finish fetching the FileTable entries and then do fetching the DirTable entries of keyname /a.\nFor the startKey /a/a1 , it will return list [/a/a1, /a/a1_2, /a/a12].\nIn BasicOzoneFileSystem client it will skip the first entry and prepare subList without duplicates startKey.\nPlease refer BasicOzoneFileSystem.java#L591 for the client side sublist logic to filter out startKey from the return list.", "author": "rakeshadr", "createdAt": "2020-10-29T13:52:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAxNzczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE3NDgwMQ==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r515174801", "bodyText": "Get it, thanks for the confirmation, @rakeshadr .", "author": "linyiqun", "createdAt": "2020-10-30T15:19:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAxNzczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1OTAyNA==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r513059024", "bodyText": "Question: This should be done under bucket lock right?", "author": "bharatviswa504", "createdAt": "2020-10-27T22:00:56Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -583,4 +588,112 @@ public static OmKeyInfo getOmKeyInfoFromFileTable(boolean openFileTable,\n     return dbOmKeyInfo;\n   }\n \n+  /**\n+   * Gets OmKeyInfo if exists for the given key name in the DB.\n+   *\n+   * @param omMetadataMgr metadata manager\n+   * @param volumeName    volume name\n+   * @param bucketName    bucket name\n+   * @param keyName       key name\n+   * @param scmBlockSize  scm block size\n+   * @return OzoneFileStatus\n+   * @throws IOException DB failure\n+   */\n+  @Nullable\n+  public static OzoneFileStatus getOMKeyInfoIfExists(", "originalCommit": "57d92c33bb7b5cd47b281eecadcc0fa464205267", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI0MjM3NA==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r514242374", "bodyText": "yes, it should be under the bucket lock. The caller KeyManagerImpl#getOzoneFileStatusV1() has acquireReadLock and hope thats enough?", "author": "rakeshadr", "createdAt": "2020-10-29T13:05:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1OTAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc0Njk4OA==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r513746988", "bodyText": "We need to consider count from this during total count when iterating from cache.\nWe are using that countEntries but listStatusFindFilesInTableCache is not returning that.", "author": "bharatviswa504", "createdAt": "2020-10-28T20:42:16Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2276,318 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    // unsorted OMKeyInfo list contains combine results from TableCache and DB.\n+    List<OzoneFileStatus> fileStatusFinalList = new ArrayList<>();\n+    LinkedHashSet<OzoneFileStatus> fileStatusList = new LinkedHashSet<>();\n+    if (numEntries <= 0) {\n+      return fileStatusFinalList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    String seekFileInDB;\n+    String seekDirInDB;\n+    long prefixKeyInDB;\n+    String prefixPath = keyName;\n+\n+    int countEntries = 0;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // Not required to search in DeletedTable because all the deleted\n+        // keys will be marked directly in dirTable or in keyTable by\n+        // breaking the pointer to its sub-dirs. So, there is no issue of\n+        // inconsistency.\n+\n+        /*\n+         * keyName is a directory.\n+         * Say, \"/a\" is the dir name and its objectID is 1024, then seek\n+         * will be doing with \"1024/\" to get all immediate descendants.\n+         */\n+        if (fileStatus.getKeyInfo() != null) {\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          // list root directory.\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+        seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+        seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        // Order of seek -> (1)Seek dirs in dirTable (2)Seek files in fileTable\n+        // 1. Seek the given key in key table.\n+        countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                prefixPath, prefixKeyInDB, startKey, countEntries, numEntries);\n+        // 2. Seek the given key in dir table.\n+        getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                volumeName, bucketName, seekDirInDB, prefixKeyInDB,\n+                prefixPath, countEntries);\n+      } else {\n+        /*\n+         * startKey will be used in iterator seek and sets the beginning point\n+         * for key traversal.\n+         *\n+         * key name will be used as parentID where the user has requested to\n+         * list the keys from.\n+         *\n+         * When recursive flag=false, parentID won't change between two pages.\n+         * For example: OM has a namespace like,\n+         *    /a/1...1M files and /a/b/1...1M files.\n+         *    /a/1...1M directories and /a/b/1...1M directories.\n+         * Listing \"/a\", will always have the parentID as \"a\" irrespective of\n+         * the startKey value.\n+         */\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null, true);\n+\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          if(fileStatusInfo.isDirectory()){\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+\n+            // Order of seek -> (1) Seek dirs in dirTable. In OM, always the\n+            // order of search is, first seek into fileTable and then dirTable.\n+            // So, its not required to search again into the fileTable.\n+\n+            // Seek the given key in dirTable.\n+            getDirectories(recursive, startKey, numEntries,\n+                    fileStatusList, volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+\n+          } else {\n+            seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+            // begins from the first sub-dir under the parent dir\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+            // Seek the given key in key table.\n+            countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                    prefixPath, prefixKeyInDB, startKey, countEntries,\n+                    numEntries);\n+            // Seek the given key in dir table.\n+            getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                    volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+          }\n+        } else {\n+          // No key exists for the given startKey.\n+          // TODO: HDDS-4364: startKey can be a non-existed key\n+          return Collections.emptyList();\n+        }\n+      }\n+    } finally {\n+      metadataManager.getLock().releaseReadLock(BUCKET_LOCK, volumeName,\n+              bucketName);\n+    }\n+\n+    // Convert results in cacheKeyMap to List\n+    for (OzoneFileStatus fileStatus : fileStatusList) {\n+      // refreshPipeline flag check has been removed as part of\n+      // https://issues.apache.org/jira/browse/HDDS-3658.\n+      // Please refer this jira for more details.\n+      refreshPipeline(fileStatus.getKeyInfo());\n+\n+      // No need to check if a key is deleted or not here, this is handled\n+      // when adding entries to cacheKeyMap from DB.\n+      if (args.getSortDatanodes()) {\n+        sortDatanodeInPipeline(fileStatus.getKeyInfo(), clientAddress);\n+      }\n+    }\n+    fileStatusFinalList.addAll(fileStatusList);\n+    return fileStatusFinalList;\n+  }\n+\n+  @SuppressWarnings(\"parameternumber\")\n+  protected int getDirectories(boolean recursive, String startKey,\n+      long numEntries, Set<OzoneFileStatus> fileStatusList,\n+      String volumeName, String bucketName, String seekDirInDB,\n+      long prefixKeyInDB, String prefixPath,\n+      int countEntries) throws IOException {\n+\n+    Table dirTable = metadataManager.getDirectoryTable();\n+    listStatusFindDirsInTableCache(fileStatusList, dirTable, prefixKeyInDB,\n+            seekDirInDB, prefixPath, startKey, volumeName, bucketName,\n+            countEntries, numEntries);\n+    TableIterator<String, ? extends Table.KeyValue<String, OmDirectoryInfo>>\n+            iterator = dirTable.iterator();\n+\n+    iterator.seek(seekDirInDB);\n+\n+    while (iterator.hasNext() && numEntries - countEntries > 0) {\n+      OmDirectoryInfo dirInfo = iterator.value().getValue();\n+      if (!isImmediateChild(dirInfo.getParentObjectID(), prefixKeyInDB)) {\n+        break;\n+      }\n+\n+      // TODO: recursive list will be handled in HDDS-4360 jira.\n+      if (!recursive) {\n+        String dirName = OMFileRequest.getAbsolutePath(prefixPath,\n+                dirInfo.getName());\n+        OmKeyInfo omKeyInfo = OMFileRequest.getOmKeyInfo(volumeName,\n+                bucketName, dirInfo, dirName);\n+        fileStatusList.add(new OzoneFileStatus(omKeyInfo, scmBlockSize,\n+                true));\n+        countEntries++;\n+      }\n+      // move to next entry in the DirTable\n+      iterator.next();\n+    }\n+\n+    return countEntries;\n+  }\n+\n+  private int getFilesFromDirectory(Set<OzoneFileStatus> fileStatusList,\n+      String seekKeyInDB, String prefixKeyPath, long prefixKeyInDB,\n+      String startKey, int countEntries, long numEntries) throws IOException {\n+\n+    Table<String, OmKeyInfo> keyTable = metadataManager.getKeyTable();\n+    listStatusFindFilesInTableCache(fileStatusList, keyTable, prefixKeyInDB,", "originalCommit": "57d92c33bb7b5cd47b281eecadcc0fa464205267", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI4MDczMg==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r514280732", "bodyText": "Done!", "author": "rakeshadr", "createdAt": "2020-10-29T14:00:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc0Njk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc5OTE2Ng==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r513799166", "bodyText": "We need to consider count from this during total count when iterating from cache.\nWe are using that countEntries but listStatusFindDirsInTableCache is not returning that", "author": "bharatviswa504", "createdAt": "2020-10-28T22:27:26Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2276,318 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    // unsorted OMKeyInfo list contains combine results from TableCache and DB.\n+    List<OzoneFileStatus> fileStatusFinalList = new ArrayList<>();\n+    LinkedHashSet<OzoneFileStatus> fileStatusList = new LinkedHashSet<>();\n+    if (numEntries <= 0) {\n+      return fileStatusFinalList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    String seekFileInDB;\n+    String seekDirInDB;\n+    long prefixKeyInDB;\n+    String prefixPath = keyName;\n+\n+    int countEntries = 0;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // Not required to search in DeletedTable because all the deleted\n+        // keys will be marked directly in dirTable or in keyTable by\n+        // breaking the pointer to its sub-dirs. So, there is no issue of\n+        // inconsistency.\n+\n+        /*\n+         * keyName is a directory.\n+         * Say, \"/a\" is the dir name and its objectID is 1024, then seek\n+         * will be doing with \"1024/\" to get all immediate descendants.\n+         */\n+        if (fileStatus.getKeyInfo() != null) {\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          // list root directory.\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+        seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+        seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        // Order of seek -> (1)Seek dirs in dirTable (2)Seek files in fileTable\n+        // 1. Seek the given key in key table.\n+        countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                prefixPath, prefixKeyInDB, startKey, countEntries, numEntries);\n+        // 2. Seek the given key in dir table.\n+        getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                volumeName, bucketName, seekDirInDB, prefixKeyInDB,\n+                prefixPath, countEntries);\n+      } else {\n+        /*\n+         * startKey will be used in iterator seek and sets the beginning point\n+         * for key traversal.\n+         *\n+         * key name will be used as parentID where the user has requested to\n+         * list the keys from.\n+         *\n+         * When recursive flag=false, parentID won't change between two pages.\n+         * For example: OM has a namespace like,\n+         *    /a/1...1M files and /a/b/1...1M files.\n+         *    /a/1...1M directories and /a/b/1...1M directories.\n+         * Listing \"/a\", will always have the parentID as \"a\" irrespective of\n+         * the startKey value.\n+         */\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null, true);\n+\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          if(fileStatusInfo.isDirectory()){\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+\n+            // Order of seek -> (1) Seek dirs in dirTable. In OM, always the\n+            // order of search is, first seek into fileTable and then dirTable.\n+            // So, its not required to search again into the fileTable.\n+\n+            // Seek the given key in dirTable.\n+            getDirectories(recursive, startKey, numEntries,\n+                    fileStatusList, volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+\n+          } else {\n+            seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+            // begins from the first sub-dir under the parent dir\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+            // Seek the given key in key table.\n+            countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                    prefixPath, prefixKeyInDB, startKey, countEntries,\n+                    numEntries);\n+            // Seek the given key in dir table.\n+            getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                    volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+          }\n+        } else {\n+          // No key exists for the given startKey.\n+          // TODO: HDDS-4364: startKey can be a non-existed key\n+          return Collections.emptyList();\n+        }\n+      }\n+    } finally {\n+      metadataManager.getLock().releaseReadLock(BUCKET_LOCK, volumeName,\n+              bucketName);\n+    }\n+\n+    // Convert results in cacheKeyMap to List\n+    for (OzoneFileStatus fileStatus : fileStatusList) {\n+      // refreshPipeline flag check has been removed as part of\n+      // https://issues.apache.org/jira/browse/HDDS-3658.\n+      // Please refer this jira for more details.\n+      refreshPipeline(fileStatus.getKeyInfo());\n+\n+      // No need to check if a key is deleted or not here, this is handled\n+      // when adding entries to cacheKeyMap from DB.\n+      if (args.getSortDatanodes()) {\n+        sortDatanodeInPipeline(fileStatus.getKeyInfo(), clientAddress);\n+      }\n+    }\n+    fileStatusFinalList.addAll(fileStatusList);\n+    return fileStatusFinalList;\n+  }\n+\n+  @SuppressWarnings(\"parameternumber\")\n+  protected int getDirectories(boolean recursive, String startKey,\n+      long numEntries, Set<OzoneFileStatus> fileStatusList,\n+      String volumeName, String bucketName, String seekDirInDB,\n+      long prefixKeyInDB, String prefixPath,\n+      int countEntries) throws IOException {\n+\n+    Table dirTable = metadataManager.getDirectoryTable();\n+    listStatusFindDirsInTableCache(fileStatusList, dirTable, prefixKeyInDB,", "originalCommit": "57d92c33bb7b5cd47b281eecadcc0fa464205267", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI4MDgwMg==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r514280802", "bodyText": "Done!", "author": "rakeshadr", "createdAt": "2020-10-29T14:00:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc5OTE2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwNjA5Mg==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r513806092", "bodyText": "Question: Do we need this second check when startKey is blank?", "author": "bharatviswa504", "createdAt": "2020-10-28T22:45:35Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2276,318 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    // unsorted OMKeyInfo list contains combine results from TableCache and DB.\n+    List<OzoneFileStatus> fileStatusFinalList = new ArrayList<>();\n+    LinkedHashSet<OzoneFileStatus> fileStatusList = new LinkedHashSet<>();\n+    if (numEntries <= 0) {\n+      return fileStatusFinalList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    String seekFileInDB;\n+    String seekDirInDB;\n+    long prefixKeyInDB;\n+    String prefixPath = keyName;\n+\n+    int countEntries = 0;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // Not required to search in DeletedTable because all the deleted\n+        // keys will be marked directly in dirTable or in keyTable by\n+        // breaking the pointer to its sub-dirs. So, there is no issue of\n+        // inconsistency.\n+\n+        /*\n+         * keyName is a directory.\n+         * Say, \"/a\" is the dir name and its objectID is 1024, then seek\n+         * will be doing with \"1024/\" to get all immediate descendants.\n+         */\n+        if (fileStatus.getKeyInfo() != null) {\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          // list root directory.\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+        seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+        seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        // Order of seek -> (1)Seek dirs in dirTable (2)Seek files in fileTable\n+        // 1. Seek the given key in key table.\n+        countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                prefixPath, prefixKeyInDB, startKey, countEntries, numEntries);\n+        // 2. Seek the given key in dir table.\n+        getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                volumeName, bucketName, seekDirInDB, prefixKeyInDB,\n+                prefixPath, countEntries);\n+      } else {\n+        /*\n+         * startKey will be used in iterator seek and sets the beginning point\n+         * for key traversal.\n+         *\n+         * key name will be used as parentID where the user has requested to\n+         * list the keys from.\n+         *\n+         * When recursive flag=false, parentID won't change between two pages.\n+         * For example: OM has a namespace like,\n+         *    /a/1...1M files and /a/b/1...1M files.\n+         *    /a/1...1M directories and /a/b/1...1M directories.\n+         * Listing \"/a\", will always have the parentID as \"a\" irrespective of\n+         * the startKey value.\n+         */\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null, true);\n+\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          if(fileStatusInfo.isDirectory()){\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+\n+            // Order of seek -> (1) Seek dirs in dirTable. In OM, always the\n+            // order of search is, first seek into fileTable and then dirTable.\n+            // So, its not required to search again into the fileTable.\n+\n+            // Seek the given key in dirTable.\n+            getDirectories(recursive, startKey, numEntries,\n+                    fileStatusList, volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+\n+          } else {\n+            seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+            // begins from the first sub-dir under the parent dir\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+            // Seek the given key in key table.\n+            countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                    prefixPath, prefixKeyInDB, startKey, countEntries,\n+                    numEntries);\n+            // Seek the given key in dir table.\n+            getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                    volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+          }\n+        } else {\n+          // No key exists for the given startKey.\n+          // TODO: HDDS-4364: startKey can be a non-existed key\n+          return Collections.emptyList();\n+        }\n+      }\n+    } finally {\n+      metadataManager.getLock().releaseReadLock(BUCKET_LOCK, volumeName,\n+              bucketName);\n+    }\n+\n+    // Convert results in cacheKeyMap to List\n+    for (OzoneFileStatus fileStatus : fileStatusList) {\n+      // refreshPipeline flag check has been removed as part of\n+      // https://issues.apache.org/jira/browse/HDDS-3658.\n+      // Please refer this jira for more details.\n+      refreshPipeline(fileStatus.getKeyInfo());\n+\n+      // No need to check if a key is deleted or not here, this is handled\n+      // when adding entries to cacheKeyMap from DB.\n+      if (args.getSortDatanodes()) {\n+        sortDatanodeInPipeline(fileStatus.getKeyInfo(), clientAddress);\n+      }\n+    }\n+    fileStatusFinalList.addAll(fileStatusList);\n+    return fileStatusFinalList;\n+  }\n+\n+  @SuppressWarnings(\"parameternumber\")\n+  protected int getDirectories(boolean recursive, String startKey,\n+      long numEntries, Set<OzoneFileStatus> fileStatusList,\n+      String volumeName, String bucketName, String seekDirInDB,\n+      long prefixKeyInDB, String prefixPath,\n+      int countEntries) throws IOException {\n+\n+    Table dirTable = metadataManager.getDirectoryTable();\n+    listStatusFindDirsInTableCache(fileStatusList, dirTable, prefixKeyInDB,\n+            seekDirInDB, prefixPath, startKey, volumeName, bucketName,\n+            countEntries, numEntries);\n+    TableIterator<String, ? extends Table.KeyValue<String, OmDirectoryInfo>>\n+            iterator = dirTable.iterator();\n+\n+    iterator.seek(seekDirInDB);\n+\n+    while (iterator.hasNext() && numEntries - countEntries > 0) {\n+      OmDirectoryInfo dirInfo = iterator.value().getValue();\n+      if (!isImmediateChild(dirInfo.getParentObjectID(), prefixKeyInDB)) {\n+        break;\n+      }\n+\n+      // TODO: recursive list will be handled in HDDS-4360 jira.\n+      if (!recursive) {\n+        String dirName = OMFileRequest.getAbsolutePath(prefixPath,\n+                dirInfo.getName());\n+        OmKeyInfo omKeyInfo = OMFileRequest.getOmKeyInfo(volumeName,\n+                bucketName, dirInfo, dirName);\n+        fileStatusList.add(new OzoneFileStatus(omKeyInfo, scmBlockSize,\n+                true));\n+        countEntries++;\n+      }\n+      // move to next entry in the DirTable\n+      iterator.next();\n+    }\n+\n+    return countEntries;\n+  }\n+\n+  private int getFilesFromDirectory(Set<OzoneFileStatus> fileStatusList,\n+      String seekKeyInDB, String prefixKeyPath, long prefixKeyInDB,\n+      String startKey, int countEntries, long numEntries) throws IOException {\n+\n+    Table<String, OmKeyInfo> keyTable = metadataManager.getKeyTable();\n+    listStatusFindFilesInTableCache(fileStatusList, keyTable, prefixKeyInDB,\n+            seekKeyInDB, prefixKeyPath, startKey, countEntries, numEntries);\n+    TableIterator<String, ? extends Table.KeyValue<String, OmKeyInfo>>\n+            iterator = keyTable.iterator();\n+    iterator.seek(seekKeyInDB);\n+    while (iterator.hasNext() && numEntries - countEntries > 0) {\n+      OmKeyInfo keyInfo = iterator.value().getValue();\n+\n+      if (!isImmediateChild(keyInfo.getParentObjectID(), prefixKeyInDB)) {\n+        break;\n+      }\n+\n+      keyInfo.setFileName(keyInfo.getKeyName());\n+      String fullKeyPath = OMFileRequest.getAbsolutePath(prefixKeyPath,\n+              keyInfo.getKeyName());\n+      keyInfo.setKeyName(fullKeyPath);\n+      fileStatusList.add(new OzoneFileStatus(keyInfo, scmBlockSize, false));\n+      countEntries++;\n+      iterator.next(); // move to next entry in the table\n+    }\n+    return countEntries;\n+  }\n+\n+  private boolean isImmediateChild(long parentId, long ancestorId) {\n+    return parentId == ancestorId;\n+  }\n+\n+  /**\n+   * Helper function for listStatus to find key in FileTableCache.\n+   */\n+  @SuppressWarnings(\"parameternumber\")\n+  private void listStatusFindFilesInTableCache(\n+          Set<OzoneFileStatus> fileStatusList, Table<String,\n+          OmKeyInfo> keyTable, long prefixKeyInDB, String seekKeyInDB,\n+          String prefixKeyPath, String startKey, int countEntries,\n+          long numEntries) {\n+\n+    Iterator<Map.Entry<CacheKey<String>, CacheValue<OmKeyInfo>>>\n+            cacheIter = keyTable.cacheIterator();\n+    // seekKeyInDB will have two type of values.\n+    // 1. \"1024/\"   -> startKey is null or empty\n+    // 2. \"1024/b\"  -> startKey exists\n+    // TODO: recursive list will be handled in HDDS-4360 jira.\n+    while (cacheIter.hasNext() && numEntries - countEntries > 0) {\n+      Map.Entry<CacheKey<String>, CacheValue<OmKeyInfo>> entry =\n+              cacheIter.next();\n+      String cacheKey = entry.getKey().getCacheKey();\n+      OmKeyInfo cacheOmKeyInfo = entry.getValue().getCacheValue();\n+      if(cacheOmKeyInfo == null){\n+        continue;\n+      }\n+\n+      cacheOmKeyInfo.setFileName(cacheOmKeyInfo.getKeyName());\n+      String fullKeyPath = OMFileRequest.getAbsolutePath(prefixKeyPath,\n+              cacheOmKeyInfo.getKeyName());\n+      cacheOmKeyInfo.setKeyName(fullKeyPath);\n+\n+      if (StringUtils.isBlank(startKey)) {\n+        // cacheOmKeyInfo is null if an entry is deleted in cache\n+        if (cacheKey.startsWith(seekKeyInDB) &&\n+                cacheKey.compareTo(seekKeyInDB) >= 0) {", "originalCommit": "57d92c33bb7b5cd47b281eecadcc0fa464205267", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI1NzI5MQ==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r514257291", "bodyText": "Sorry, I failed to understand the \"second check\". Are you asking about cacheKey.compareTo(seekKeyInDB) this?\nIf yes, this is required for listing files/dirs under the keyname.", "author": "rakeshadr", "createdAt": "2020-10-29T13:28:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwNjA5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkwNzgzMw==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r514907833", "bodyText": "OK, based on the offline discussions I will remove the cacheKey.compareTo(seekKeyInDB) >= 0 check. Adding discussion details to make the scenario clear to all.\n'seekKeyInDB' will have two type of values.\n      1. \"1024/\"   -> startKey is null or empty\n      2. \"1024/b\"  -> startKey exists", "author": "rakeshadr", "createdAt": "2020-10-30T07:13:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwNjA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgxNTk2OQ==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r513815969", "bodyText": "Minor NIT: Can we maintain similar order for parameters for getFilesFromDirectories and getDirectories it will be easy to follow while reading code, as it has many parameters.", "author": "bharatviswa504", "createdAt": "2020-10-28T23:13:14Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2276,318 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    // unsorted OMKeyInfo list contains combine results from TableCache and DB.\n+    List<OzoneFileStatus> fileStatusFinalList = new ArrayList<>();\n+    LinkedHashSet<OzoneFileStatus> fileStatusList = new LinkedHashSet<>();\n+    if (numEntries <= 0) {\n+      return fileStatusFinalList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    String seekFileInDB;\n+    String seekDirInDB;\n+    long prefixKeyInDB;\n+    String prefixPath = keyName;\n+\n+    int countEntries = 0;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // Not required to search in DeletedTable because all the deleted\n+        // keys will be marked directly in dirTable or in keyTable by\n+        // breaking the pointer to its sub-dirs. So, there is no issue of\n+        // inconsistency.\n+\n+        /*\n+         * keyName is a directory.\n+         * Say, \"/a\" is the dir name and its objectID is 1024, then seek\n+         * will be doing with \"1024/\" to get all immediate descendants.\n+         */\n+        if (fileStatus.getKeyInfo() != null) {\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          // list root directory.\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+        seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+        seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        // Order of seek -> (1)Seek dirs in dirTable (2)Seek files in fileTable\n+        // 1. Seek the given key in key table.\n+        countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                prefixPath, prefixKeyInDB, startKey, countEntries, numEntries);\n+        // 2. Seek the given key in dir table.\n+        getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                volumeName, bucketName, seekDirInDB, prefixKeyInDB,\n+                prefixPath, countEntries);\n+      } else {\n+        /*\n+         * startKey will be used in iterator seek and sets the beginning point\n+         * for key traversal.\n+         *\n+         * key name will be used as parentID where the user has requested to\n+         * list the keys from.\n+         *\n+         * When recursive flag=false, parentID won't change between two pages.\n+         * For example: OM has a namespace like,\n+         *    /a/1...1M files and /a/b/1...1M files.\n+         *    /a/1...1M directories and /a/b/1...1M directories.\n+         * Listing \"/a\", will always have the parentID as \"a\" irrespective of\n+         * the startKey value.\n+         */\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null, true);\n+\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          if(fileStatusInfo.isDirectory()){\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+\n+            // Order of seek -> (1) Seek dirs in dirTable. In OM, always the\n+            // order of search is, first seek into fileTable and then dirTable.\n+            // So, its not required to search again into the fileTable.\n+\n+            // Seek the given key in dirTable.\n+            getDirectories(recursive, startKey, numEntries,\n+                    fileStatusList, volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+\n+          } else {\n+            seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+            // begins from the first sub-dir under the parent dir\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+            // Seek the given key in key table.\n+            countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                    prefixPath, prefixKeyInDB, startKey, countEntries,\n+                    numEntries);\n+            // Seek the given key in dir table.\n+            getDirectories(recursive, startKey, numEntries, fileStatusList,", "originalCommit": "57d92c33bb7b5cd47b281eecadcc0fa464205267", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI4MDkwNw==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r514280907", "bodyText": "Done!", "author": "rakeshadr", "createdAt": "2020-10-29T14:01:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgxNTk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgxNjc4MA==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r513816780", "bodyText": "Can we avoid the call to refreshPipeline for directories and also for sortDatanodeInPipeline.\nif (fileStatus.isFile()) {\nrefreshPipeline(fileStatus.getKeyInfo());\nif (args.getSortDatanodes()) {\n        sortDatanodeInPipeline(fileStatus.getKeyInfo(), clientAddress);\n      }\n    }\n}", "author": "bharatviswa504", "createdAt": "2020-10-28T23:15:25Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2276,318 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    // unsorted OMKeyInfo list contains combine results from TableCache and DB.\n+    List<OzoneFileStatus> fileStatusFinalList = new ArrayList<>();\n+    LinkedHashSet<OzoneFileStatus> fileStatusList = new LinkedHashSet<>();\n+    if (numEntries <= 0) {\n+      return fileStatusFinalList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    String seekFileInDB;\n+    String seekDirInDB;\n+    long prefixKeyInDB;\n+    String prefixPath = keyName;\n+\n+    int countEntries = 0;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // Not required to search in DeletedTable because all the deleted\n+        // keys will be marked directly in dirTable or in keyTable by\n+        // breaking the pointer to its sub-dirs. So, there is no issue of\n+        // inconsistency.\n+\n+        /*\n+         * keyName is a directory.\n+         * Say, \"/a\" is the dir name and its objectID is 1024, then seek\n+         * will be doing with \"1024/\" to get all immediate descendants.\n+         */\n+        if (fileStatus.getKeyInfo() != null) {\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          // list root directory.\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+        seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+        seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        // Order of seek -> (1)Seek dirs in dirTable (2)Seek files in fileTable\n+        // 1. Seek the given key in key table.\n+        countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                prefixPath, prefixKeyInDB, startKey, countEntries, numEntries);\n+        // 2. Seek the given key in dir table.\n+        getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                volumeName, bucketName, seekDirInDB, prefixKeyInDB,\n+                prefixPath, countEntries);\n+      } else {\n+        /*\n+         * startKey will be used in iterator seek and sets the beginning point\n+         * for key traversal.\n+         *\n+         * key name will be used as parentID where the user has requested to\n+         * list the keys from.\n+         *\n+         * When recursive flag=false, parentID won't change between two pages.\n+         * For example: OM has a namespace like,\n+         *    /a/1...1M files and /a/b/1...1M files.\n+         *    /a/1...1M directories and /a/b/1...1M directories.\n+         * Listing \"/a\", will always have the parentID as \"a\" irrespective of\n+         * the startKey value.\n+         */\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null, true);\n+\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          if(fileStatusInfo.isDirectory()){\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+\n+            // Order of seek -> (1) Seek dirs in dirTable. In OM, always the\n+            // order of search is, first seek into fileTable and then dirTable.\n+            // So, its not required to search again into the fileTable.\n+\n+            // Seek the given key in dirTable.\n+            getDirectories(recursive, startKey, numEntries,\n+                    fileStatusList, volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+\n+          } else {\n+            seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+            // begins from the first sub-dir under the parent dir\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+            // Seek the given key in key table.\n+            countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                    prefixPath, prefixKeyInDB, startKey, countEntries,\n+                    numEntries);\n+            // Seek the given key in dir table.\n+            getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                    volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+          }\n+        } else {\n+          // No key exists for the given startKey.\n+          // TODO: HDDS-4364: startKey can be a non-existed key\n+          return Collections.emptyList();\n+        }\n+      }\n+    } finally {\n+      metadataManager.getLock().releaseReadLock(BUCKET_LOCK, volumeName,\n+              bucketName);\n+    }\n+\n+    // Convert results in cacheKeyMap to List\n+    for (OzoneFileStatus fileStatus : fileStatusList) {\n+      // refreshPipeline flag check has been removed as part of\n+      // https://issues.apache.org/jira/browse/HDDS-3658.\n+      // Please refer this jira for more details.\n+      refreshPipeline(fileStatus.getKeyInfo());", "originalCommit": "57d92c33bb7b5cd47b281eecadcc0fa464205267", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI4MTA1Mg==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r514281052", "bodyText": "Done!", "author": "rakeshadr", "createdAt": "2020-10-29T14:01:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgxNjc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyNTU1MA==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r513825550", "bodyText": "When startKey is passed, we seek to that and to construct keyName we used keyArgs keyName as keyName and construct the paths.\nBut let's say\nKeyArgs keyName /a/b\nstartkey is /f/d\nThen we have used parentObjectID and seek and then return all keys in directory /f, but we construct keyNames with prefix as \"/a/b\".\nDo you think we need to have a check when startKey is passed is the parentObjectID is same when recursive is false. To avoid this kind of corner case scenarios?", "author": "bharatviswa504", "createdAt": "2020-10-28T23:41:29Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2276,318 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    // unsorted OMKeyInfo list contains combine results from TableCache and DB.\n+    List<OzoneFileStatus> fileStatusFinalList = new ArrayList<>();\n+    LinkedHashSet<OzoneFileStatus> fileStatusList = new LinkedHashSet<>();\n+    if (numEntries <= 0) {\n+      return fileStatusFinalList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    String seekFileInDB;\n+    String seekDirInDB;\n+    long prefixKeyInDB;\n+    String prefixPath = keyName;\n+\n+    int countEntries = 0;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // Not required to search in DeletedTable because all the deleted\n+        // keys will be marked directly in dirTable or in keyTable by\n+        // breaking the pointer to its sub-dirs. So, there is no issue of\n+        // inconsistency.\n+\n+        /*\n+         * keyName is a directory.\n+         * Say, \"/a\" is the dir name and its objectID is 1024, then seek\n+         * will be doing with \"1024/\" to get all immediate descendants.\n+         */\n+        if (fileStatus.getKeyInfo() != null) {\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          // list root directory.\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+        seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+        seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        // Order of seek -> (1)Seek dirs in dirTable (2)Seek files in fileTable\n+        // 1. Seek the given key in key table.\n+        countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                prefixPath, prefixKeyInDB, startKey, countEntries, numEntries);\n+        // 2. Seek the given key in dir table.\n+        getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                volumeName, bucketName, seekDirInDB, prefixKeyInDB,\n+                prefixPath, countEntries);\n+      } else {\n+        /*\n+         * startKey will be used in iterator seek and sets the beginning point\n+         * for key traversal.\n+         *\n+         * key name will be used as parentID where the user has requested to\n+         * list the keys from.\n+         *\n+         * When recursive flag=false, parentID won't change between two pages.\n+         * For example: OM has a namespace like,\n+         *    /a/1...1M files and /a/b/1...1M files.\n+         *    /a/1...1M directories and /a/b/1...1M directories.\n+         * Listing \"/a\", will always have the parentID as \"a\" irrespective of\n+         * the startKey value.\n+         */\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null, true);\n+\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          if(fileStatusInfo.isDirectory()){\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+\n+            // Order of seek -> (1) Seek dirs in dirTable. In OM, always the\n+            // order of search is, first seek into fileTable and then dirTable.\n+            // So, its not required to search again into the fileTable.\n+\n+            // Seek the given key in dirTable.\n+            getDirectories(recursive, startKey, numEntries,\n+                    fileStatusList, volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+\n+          } else {\n+            seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+            // begins from the first sub-dir under the parent dir\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+            // Seek the given key in key table.\n+            countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                    prefixPath, prefixKeyInDB, startKey, countEntries,\n+                    numEntries);\n+            // Seek the given key in dir table.\n+            getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                    volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+          }\n+        } else {\n+          // No key exists for the given startKey.\n+          // TODO: HDDS-4364: startKey can be a non-existed key\n+          return Collections.emptyList();\n+        }\n+      }\n+    } finally {\n+      metadataManager.getLock().releaseReadLock(BUCKET_LOCK, volumeName,\n+              bucketName);\n+    }\n+\n+    // Convert results in cacheKeyMap to List\n+    for (OzoneFileStatus fileStatus : fileStatusList) {\n+      // refreshPipeline flag check has been removed as part of\n+      // https://issues.apache.org/jira/browse/HDDS-3658.\n+      // Please refer this jira for more details.\n+      refreshPipeline(fileStatus.getKeyInfo());\n+\n+      // No need to check if a key is deleted or not here, this is handled\n+      // when adding entries to cacheKeyMap from DB.\n+      if (args.getSortDatanodes()) {\n+        sortDatanodeInPipeline(fileStatus.getKeyInfo(), clientAddress);\n+      }\n+    }\n+    fileStatusFinalList.addAll(fileStatusList);", "originalCommit": "57d92c33bb7b5cd47b281eecadcc0fa464205267", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI3ODMyOQ==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r514278329", "bodyText": "As I'm implementing only recursive=false cases in this patch, it will return list with only immediate files/dirs. In your example, the keyname is  /a/b, then it will list only upto  /a/b/f. It won't have  /a/b/f/d entry in the result list.\nKeyArgs keyName /a/b\nstartkey will be in the fashion /a/b/f. It will be full path, right?.\nI believe the case what you mentioned will occur when I'm doing recursive=true in jira HDDS-4360, am I correct?", "author": "rakeshadr", "createdAt": "2020-10-29T13:57:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyNTU1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkxNTMxMw==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r514915313", "bodyText": "Based on offline discussions, added a case to safe check to verify startKey is an immediate child of keyName.\nFollowing are the valid parentKey formats:\n    parentKey=\"\" or parentKey=\"/\" or parentKey=\"/a\" or parentKey=\"a\"\nFollowing are the valid startKey formats, which is called as childKey:\n    childKey=\"/\" or childKey=\"/a/b\" or childKey=\"a/b\"", "author": "rakeshadr", "createdAt": "2020-10-30T07:34:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyNTU1MA=="}], "type": "inlineReview"}, {"oid": "2ba48b6affe0738d31765df42322bccb376b809d", "url": "https://github.com/apache/ozone/commit/2ba48b6affe0738d31765df42322bccb376b809d", "message": "Fixed review comments", "committedDate": "2020-10-29T14:00:21Z", "type": "commit"}, {"oid": "ea07683a0838e9bd6fd4ed06d1e82e91f29d5f13", "url": "https://github.com/apache/ozone/commit/ea07683a0838e9bd6fd4ed06d1e82e91f29d5f13", "message": "Fixed Review comments - added isImmediateChild check for startKey, updated seekInDB comparison", "committedDate": "2020-10-30T07:41:53Z", "type": "commit"}, {"oid": "ff36080affed8955b737ac92c604688c279db219", "url": "https://github.com/apache/ozone/commit/ff36080affed8955b737ac92c604688c279db219", "message": "Fixed checkstyle warnings", "committedDate": "2020-10-30T14:50:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzNjIyMA==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r515436220", "bodyText": "Minor: Is this needed here?", "author": "bharatviswa504", "createdAt": "2020-10-31T00:57:10Z", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileInterfaces.java", "diffHunk": "@@ -162,6 +164,14 @@ public void init() throws Exception {\n     omMetrics = cluster.getOzoneManager().getMetrics();\n   }\n \n+  @NotNull", "originalCommit": "ff36080affed8955b737ac92c604688c279db219", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzOTE0Mg==", "url": "https://github.com/apache/ozone/pull/1503#discussion_r515439142", "bodyText": "Sure, will take care along with refactoring jira.", "author": "rakeshadr", "createdAt": "2020-10-31T01:24:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzNjIyMA=="}], "type": "inlineReview"}]}