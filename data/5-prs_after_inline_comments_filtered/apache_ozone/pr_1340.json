{"pr_number": 1340, "pr_title": "HDDS-3188 Add failover proxy for SCM block location.", "pr_createdAt": "2020-08-20T07:29:11Z", "pr_url": "https://github.com/apache/ozone/pull/1340", "timeline": [{"oid": "5144bc5bf97d6880b4eaf684be742d460e93c78b", "url": "https://github.com/apache/ozone/commit/5144bc5bf97d6880b4eaf684be742d460e93c78b", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location.", "committedDate": "2020-08-20T14:08:36Z", "type": "forcePushed"}, {"oid": "0883c8110be3f37ecf1e7a09bacd5c0656baa863", "url": "https://github.com/apache/ozone/commit/0883c8110be3f37ecf1e7a09bacd5c0656baa863", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location.", "committedDate": "2020-08-21T08:07:32Z", "type": "forcePushed"}, {"oid": "57c4841ace66e3cbc6751871a509fcddc982883c", "url": "https://github.com/apache/ozone/commit/57c4841ace66e3cbc6751871a509fcddc982883c", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location.", "committedDate": "2020-08-21T13:23:42Z", "type": "forcePushed"}, {"oid": "dbbab11102d050d5590b541f4debdcd442379a07", "url": "https://github.com/apache/ozone/commit/dbbab11102d050d5590b541f4debdcd442379a07", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location.", "committedDate": "2020-08-25T04:34:30Z", "type": "forcePushed"}, {"oid": "cec791b921501a7a06efaf8bbb0785a0cb21916e", "url": "https://github.com/apache/ozone/commit/cec791b921501a7a06efaf8bbb0785a0cb21916e", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location.", "committedDate": "2020-08-25T08:55:25Z", "type": "forcePushed"}, {"oid": "bb8b1fb78910a4605cfb12e25848e446ed197fa8", "url": "https://github.com/apache/ozone/commit/bb8b1fb78910a4605cfb12e25848e446ed197fa8", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location.", "committedDate": "2020-08-25T09:56:13Z", "type": "forcePushed"}, {"oid": "f811ed461002c3d4817dd9093d419182d4fa37ff", "url": "https://github.com/apache/ozone/commit/f811ed461002c3d4817dd9093d419182d4fa37ff", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location.", "committedDate": "2020-08-25T10:44:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM3MDUxNg==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r476370516", "bodyText": "refer to OM-HA, the rpcProxy should be a result of Proxy.newProxyInstance(.... which relies on FailoverProxyProvider to switch between different ScmBlockLocationProtocolService.\n    OzoneManagerProtocolPB proxy = (OzoneManagerProtocolPB) RetryProxy.create(\n        OzoneManagerProtocolPB.class, failoverProxyProvider, retryPolicy);\n    return proxy;", "author": "GlenGeng", "createdAt": "2020-08-25T11:19:24Z", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/protocolPB/ScmBlockLocationProtocolClientSideTranslatorPB.java", "diffHunk": "@@ -73,15 +75,19 @@\n   private static final RpcController NULL_RPC_CONTROLLER = null;\n \n   private final ScmBlockLocationProtocolPB rpcProxy;\n+  private SCMBlockLocationFailoverProxyProvider failoverProxyProvider;\n \n   /**\n    * Creates a new StorageContainerLocationProtocolClientSideTranslatorPB.\n    *\n-   * @param rpcProxy {@link StorageContainerLocationProtocolPB} RPC proxy\n+   * @param proxyProvider {@link SCMBlockLocationFailoverProxyProvider}\n+   * failover proxy provider.\n    */\n   public ScmBlockLocationProtocolClientSideTranslatorPB(\n-      ScmBlockLocationProtocolPB rpcProxy) {\n-    this.rpcProxy = rpcProxy;\n+      SCMBlockLocationFailoverProxyProvider proxyProvider) {\n+    Preconditions.checkState(proxyProvider != null);\n+    this.failoverProxyProvider = proxyProvider;\n+    this.rpcProxy = proxyProvider.getCurrentProxy();", "originalCommit": "f811ed461002c3d4817dd9093d419182d4fa37ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM3MTk0Ng==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r476371946", "bodyText": "We need consider the case that current follower SCM does not know current leader.\ncheck this\n  public OMResponse submitRequest(OMRequest payload) throws IOException {\n    try {\n      OMResponse omResponse =\n          rpcProxy.submitRequest(NULL_RPC_CONTROLLER, payload);\n\n      if (omResponse.hasLeaderOMNodeId() && omFailoverProxyProvider != null) {\n        String leaderOmId = omResponse.getLeaderOMNodeId();\n\n        // Failover to the OM node returned by OMResponse leaderOMNodeId if\n        // current proxy is not pointing to that node.\n        omFailoverProxyProvider.performFailoverIfRequired(leaderOmId);\n      }", "author": "GlenGeng", "createdAt": "2020-08-25T11:22:17Z", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/protocolPB/ScmBlockLocationProtocolClientSideTranslatorPB.java", "diffHunk": "@@ -105,6 +111,11 @@ private SCMBlockLocationResponse submitRequest(\n     try {\n       SCMBlockLocationResponse response =\n           rpcProxy.send(NULL_RPC_CONTROLLER, req);\n+      if (response.getStatus() ==", "originalCommit": "f811ed461002c3d4817dd9093d419182d4fa37ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM3NTIyNQ==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r476375225", "bodyText": "This is not used.", "author": "GlenGeng", "createdAt": "2020-08-25T11:28:59Z", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+  private ScmBlockLocationProtocol currentProxy;", "originalCommit": "f811ed461002c3d4817dd9093d419182d4fa37ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM3NjAzNw==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r476376037", "bodyText": "I guess this method is not needed.", "author": "GlenGeng", "createdAt": "2020-08-25T11:30:29Z", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+  private ScmBlockLocationProtocol currentProxy;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  private Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (scmAddressList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    } else {\n+      for (String scmAddress : scmAddressList) {\n+        resultList.add(NetUtils.createSocketAddr(scmAddress));\n+      }\n+    }\n+    return resultList;\n+  }\n+\n+  private void loadConfigs() {\n+    Collection<InetSocketAddress> scmAddressList = getSCMAddressList();\n+    int scmNodeIndex = 1;\n+    for (InetSocketAddress scmAddress : scmAddressList) {\n+      String nodeId = SCM_DUMMY_NODEID_PREFIX + scmNodeIndex;\n+      if (scmAddress == null) {\n+        LOG.error(\"Failed to create SCM proxy for {}.\", nodeId);\n+        continue;\n+      }\n+      scmNodeIndex++;\n+      SCMProxyInfo scmProxyInfo = new SCMProxyInfo(\n+          scmServiceId, nodeId, scmAddress);\n+      ProxyInfo<ScmBlockLocationProtocolPB> proxy = new ProxyInfo<>(\n+          null, scmProxyInfo.toString());\n+      scmProxies.put(nodeId, proxy);\n+      scmProxyInfoMap.put(nodeId, scmProxyInfo);\n+      scmNodeIDList.add(nodeId);\n+    }\n+\n+    if (scmProxies.isEmpty()) {\n+      throw new IllegalArgumentException(\"Could not find any configured \" +\n+          \"addresses for SCM. Please configure the system with \"\n+          + OZONE_SCM_NAMES);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public synchronized String getCurrentProxyOMNodeId() {\n+    return currentProxySCMNodeId;\n+  }\n+\n+  @Override\n+  public synchronized ProxyInfo getProxy() {\n+    ProxyInfo currentProxyInfo = scmProxies.get(currentProxySCMNodeId);\n+    createSCMProxyIfNeeded(currentProxyInfo, currentProxySCMNodeId);\n+    return currentProxyInfo;\n+  }\n+\n+  public ScmBlockLocationProtocolPB getCurrentProxy() {", "originalCommit": "f811ed461002c3d4817dd9093d419182d4fa37ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM4MTE2OQ==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r476381169", "bodyText": "Should not call performFailover() in FailoverProxyProvider, it is job of RetryInvocationHandler to call performFailover() in its RetryInvocationHandler.ProxyDescriptor.failover()", "author": "GlenGeng", "createdAt": "2020-08-25T11:39:02Z", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+  private ScmBlockLocationProtocol currentProxy;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  private Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (scmAddressList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    } else {\n+      for (String scmAddress : scmAddressList) {\n+        resultList.add(NetUtils.createSocketAddr(scmAddress));\n+      }\n+    }\n+    return resultList;\n+  }\n+\n+  private void loadConfigs() {\n+    Collection<InetSocketAddress> scmAddressList = getSCMAddressList();\n+    int scmNodeIndex = 1;\n+    for (InetSocketAddress scmAddress : scmAddressList) {\n+      String nodeId = SCM_DUMMY_NODEID_PREFIX + scmNodeIndex;\n+      if (scmAddress == null) {\n+        LOG.error(\"Failed to create SCM proxy for {}.\", nodeId);\n+        continue;\n+      }\n+      scmNodeIndex++;\n+      SCMProxyInfo scmProxyInfo = new SCMProxyInfo(\n+          scmServiceId, nodeId, scmAddress);\n+      ProxyInfo<ScmBlockLocationProtocolPB> proxy = new ProxyInfo<>(\n+          null, scmProxyInfo.toString());\n+      scmProxies.put(nodeId, proxy);\n+      scmProxyInfoMap.put(nodeId, scmProxyInfo);\n+      scmNodeIDList.add(nodeId);\n+    }\n+\n+    if (scmProxies.isEmpty()) {\n+      throw new IllegalArgumentException(\"Could not find any configured \" +\n+          \"addresses for SCM. Please configure the system with \"\n+          + OZONE_SCM_NAMES);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public synchronized String getCurrentProxyOMNodeId() {\n+    return currentProxySCMNodeId;\n+  }\n+\n+  @Override\n+  public synchronized ProxyInfo getProxy() {\n+    ProxyInfo currentProxyInfo = scmProxies.get(currentProxySCMNodeId);\n+    createSCMProxyIfNeeded(currentProxyInfo, currentProxySCMNodeId);\n+    return currentProxyInfo;\n+  }\n+\n+  public ScmBlockLocationProtocolPB getCurrentProxy() {\n+    return (ScmBlockLocationProtocolPB) getProxy().proxy;\n+  }\n+\n+  @Override\n+  public void performFailover(ScmBlockLocationProtocolPB newLeader) {\n+    // By default, will round robin to next proxy.\n+    nextProxyIndex();\n+    LOG.debug(\"Failing over to next proxy. {}\", getCurrentProxyOMNodeId());\n+  }\n+\n+  public void performFailoverToAssignedLeader(String newLeader) {\n+    if (newLeader == null) {\n+      // If newLeader is not assigned, it will fail over to next proxy.\n+      nextProxyIndex();\n+    } else {\n+      if (!assignLeaderToNode(newLeader)) {\n+        LOG.debug(\"Failing over OM proxy to nodeId: {}\", newLeader);\n+        nextProxyIndex();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Class<ScmBlockLocationProtocolPB> getInterface() {\n+    return ScmBlockLocationProtocolPB.class;\n+  }\n+\n+  @Override\n+  public synchronized void close() throws IOException {\n+    for (ProxyInfo<ScmBlockLocationProtocolPB> proxy : scmProxies.values()) {\n+      ScmBlockLocationProtocolPB scmProxy = proxy.proxy;\n+      if (scmProxy != null) {\n+        RPC.stopProxy(scmProxy);\n+      }\n+    }\n+  }\n+\n+  public RetryAction getRetryAction(int failovers) {\n+    if (failovers < maxRetryCount) {\n+      return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n+          getRetryInterval());\n+    } else {\n+      return RetryAction.FAIL;\n+    }\n+  }\n+\n+  private synchronized long getRetryInterval() {\n+    // TODO add exponential backup\n+    return retryInterval;\n+  }\n+\n+  private synchronized int nextProxyIndex() {\n+    lastAttemptedLeader = currentProxySCMNodeId;\n+\n+    // round robin the next proxy\n+    currentProxyIndex = (currentProxyIndex + 1) % scmProxies.size();\n+    currentProxySCMNodeId =  scmNodeIDList.get(currentProxyIndex);\n+    return currentProxyIndex;\n+  }\n+\n+  synchronized boolean assignLeaderToNode(String newLeaderNodeId) {\n+    if (!currentProxySCMNodeId.equals(newLeaderNodeId)) {\n+      if (scmProxies.containsKey(newLeaderNodeId)) {\n+        lastAttemptedLeader = currentProxySCMNodeId;\n+        currentProxySCMNodeId = newLeaderNodeId;\n+        currentProxyIndex = scmNodeIDList.indexOf(currentProxySCMNodeId);\n+        return true;\n+      }\n+    } else {\n+      lastAttemptedLeader = currentProxySCMNodeId;\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Creates proxy object if it does not already exist.\n+   */\n+  private void createSCMProxyIfNeeded(ProxyInfo proxyInfo,\n+                                     String nodeId) {\n+    if (proxyInfo.proxy == null) {\n+      InetSocketAddress address = scmProxyInfoMap.get(nodeId).getAddress();\n+      try {\n+        ScmBlockLocationProtocolPB proxy = createSCMProxy(address);\n+        try {\n+          proxyInfo.proxy = proxy;\n+        } catch (IllegalAccessError iae) {\n+          scmProxies.put(nodeId,\n+              new ProxyInfo<>(proxy, proxyInfo.proxyInfo));\n+        }\n+      } catch (IOException ioe) {\n+        LOG.error(\"{} Failed to create RPC proxy to SCM at {}\",\n+            this.getClass().getSimpleName(), address, ioe);\n+        throw new RuntimeException(ioe);\n+      }\n+    }\n+  }\n+\n+  private ScmBlockLocationProtocolPB createSCMProxy(\n+      InetSocketAddress scmAddress) throws IOException {\n+    Configuration hadoopConf =\n+        LegacyHadoopConfigurationSource.asHadoopConfiguration(conf);\n+    RPC.setProtocolEngine(hadoopConf, ScmBlockLocationProtocol.class,\n+        ProtobufRpcEngine.class);\n+    return RPC.getProxy(ScmBlockLocationProtocolPB.class, scmVersion,\n+        scmAddress, UserGroupInformation.getCurrentUser(), hadoopConf,\n+        NetUtils.getDefaultSocketFactory(hadoopConf),\n+        (int)conf.getObject(SCMBlockClientConfig.class).getRpcTimeOut());\n+  }\n+\n+  public RetryPolicy getSCMBlockLocationRetryPolicy(\n+      String suggestedLeader) {\n+    RetryPolicy retryPolicy = new RetryPolicy() {\n+      @Override\n+      public RetryAction shouldRetry(Exception e, int retry,\n+                                     int failover, boolean b) {\n+        if (suggestedLeader == null) {\n+          performFailover(null);", "originalCommit": "f811ed461002c3d4817dd9093d419182d4fa37ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEzNzQ5MQ==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r477137491", "bodyText": "miss access modifier, such as public", "author": "GlenGeng", "createdAt": "2020-08-26T08:45:38Z", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMProxyInfo.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetSocketAddress;\n+\n+/**\n+ * Class to store SCM proxy info.\n+ */\n+public class SCMProxyInfo {\n+  private String serviceId;\n+  private String nodeId;\n+  private String rpcAddrStr;\n+  private InetSocketAddress rpcAddr;\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SCMProxyInfo.class);\n+\n+  SCMProxyInfo(String serviceID, String nodeID, InetSocketAddress rpcAddress) {", "originalCommit": "f811ed461002c3d4817dd9093d419182d4fa37ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE4OTE1MQ==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r477189151", "bodyText": "may be NPE ?", "author": "GlenGeng", "createdAt": "2020-08-26T10:09:22Z", "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/StorageContainerManager.java", "diffHunk": "@@ -1053,6 +1053,22 @@ public ReplicationManager getReplicationManager() {\n     return replicationManager;\n   }\n \n+  /**\n+   * Check if the current scm is the leader.\n+   * @return - if the current scm is the leader.\n+   */\n+  public boolean checkLeader() {\n+    return scmHAManager.isLeader();\n+  }\n+\n+  /**\n+   * Get suggested leader from Raft.\n+   * @return - suggested leader address.\n+   */\n+  public String getSuggestedLeader() {\n+    return scmHAManager.getSuggestedLeader().getAddress();", "originalCommit": "f811ed461002c3d4817dd9093d419182d4fa37ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "875c46ddccfc3b9ad4f2d230fed1fc52374f94af", "url": "https://github.com/apache/ozone/commit/875c46ddccfc3b9ad4f2d230fed1fc52374f94af", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location.", "committedDate": "2020-08-26T10:41:09Z", "type": "forcePushed"}, {"oid": "aa1c4a6541f6e02f50eb4f03d0255ca1286bb085", "url": "https://github.com/apache/ozone/commit/aa1c4a6541f6e02f50eb4f03d0255ca1286bb085", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location.", "committedDate": "2020-08-27T03:02:46Z", "type": "forcePushed"}, {"oid": "aff69a69a1ec0e710909d123ffb1ef7784bdb9a0", "url": "https://github.com/apache/ozone/commit/aff69a69a1ec0e710909d123ffb1ef7784bdb9a0", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location.", "committedDate": "2020-08-27T06:17:33Z", "type": "forcePushed"}, {"oid": "684f8ff6e5b49d89a0ab3847c36d19d9ea733357", "url": "https://github.com/apache/ozone/commit/684f8ff6e5b49d89a0ab3847c36d19d9ea733357", "message": "HDDS-3188 Add failover proxy for SCMBlockLocation.", "committedDate": "2020-08-27T06:22:15Z", "type": "forcePushed"}, {"oid": "046872462842863a56eafb28bfafbf5c130672bc", "url": "https://github.com/apache/ozone/commit/046872462842863a56eafb28bfafbf5c130672bc", "message": "HDDS-3188 Add failover proxy for SCMBlockLocation.", "committedDate": "2020-08-27T07:42:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI4NjA4OA==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r478286088", "bodyText": "no need to call nextProxyIndex().\nSince the real failover is done by performFailoverToAssignedLeader(), it is called by RetryPolicy.shouldRetry() and submitRequest()", "author": "GlenGeng", "createdAt": "2020-08-27T09:34:17Z", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  @VisibleForTesting\n+  protected Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (scmAddressList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    } else {\n+      for (String scmAddress : scmAddressList) {\n+        LOG.info(\"SCM Address for proxy is {}\", scmAddress);\n+        if (scmAddress.contains(\":\")) {\n+          resultList.add(NetUtils.createSocketAddr(scmAddress));\n+        } else {\n+          final int port = getPortNumberFromConfigKeys(conf,\n+              ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_ADDRESS_KEY)\n+              .orElse(ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_PORT_DEFAULT);\n+          resultList.add(NetUtils.createSocketAddr(scmAddress + \":\" + port));\n+        }\n+      }\n+    }\n+    return resultList;\n+  }\n+\n+  private void loadConfigs() {\n+    Collection<InetSocketAddress> scmAddressList = getSCMAddressList();\n+    int scmNodeIndex = 1;\n+    for (InetSocketAddress scmAddress : scmAddressList) {\n+      String nodeId = SCM_DUMMY_NODEID_PREFIX + scmNodeIndex;\n+      if (scmAddress == null) {\n+        LOG.error(\"Failed to create SCM proxy for {}.\", nodeId);\n+        continue;\n+      }\n+      scmNodeIndex++;\n+      SCMProxyInfo scmProxyInfo = new SCMProxyInfo(\n+          scmServiceId, nodeId, scmAddress);\n+      ProxyInfo<ScmBlockLocationProtocolPB> proxy = new ProxyInfo<>(\n+          null, scmProxyInfo.toString());\n+      scmProxies.put(nodeId, proxy);\n+      scmProxyInfoMap.put(nodeId, scmProxyInfo);\n+      scmNodeIDList.add(nodeId);\n+    }\n+\n+    if (scmProxies.isEmpty()) {\n+      throw new IllegalArgumentException(\"Could not find any configured \" +\n+          \"addresses for SCM. Please configure the system with \"\n+          + OZONE_SCM_NAMES);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public synchronized String getCurrentProxyOMNodeId() {\n+    return currentProxySCMNodeId;\n+  }\n+\n+  @Override\n+  public synchronized ProxyInfo getProxy() {\n+    ProxyInfo currentProxyInfo = scmProxies.get(currentProxySCMNodeId);\n+    createSCMProxyIfNeeded(currentProxyInfo, currentProxySCMNodeId);\n+    return currentProxyInfo;\n+  }\n+\n+  @Override\n+  public void performFailover(ScmBlockLocationProtocolPB newLeader) {\n+    // By default, will round robin to next proxy.\n+    nextProxyIndex();", "originalCommit": "046872462842863a56eafb28bfafbf5c130672bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI4OTQyMg==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r478289422", "bodyText": "Sure. Thanks for pointing out.", "author": "timmylicheng", "createdAt": "2020-08-27T09:39:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI4NjA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI4NzExOA==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r478287118", "bodyText": "I guess it will be a NPE ?", "author": "GlenGeng", "createdAt": "2020-08-27T09:36:02Z", "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/StorageContainerManager.java", "diffHunk": "@@ -1027,6 +1027,25 @@ public ReplicationManager getReplicationManager() {\n     return replicationManager;\n   }\n \n+  /**\n+   * Check if the current scm is the leader.\n+   * @return - if the current scm is the leader.\n+   */\n+  public boolean checkLeader() {\n+    return scmHAManager.isLeader();\n+  }\n+\n+  /**\n+   * Get suggested leader from Raft.\n+   * @return - suggested leader address.\n+   */\n+  public String getSuggestedLeader() {\n+    if (scmHAManager.getSuggestedLeader() != null) {", "originalCommit": "046872462842863a56eafb28bfafbf5c130672bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI4OTI3OA==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r478289278", "bodyText": "Updated.", "author": "timmylicheng", "createdAt": "2020-08-27T09:39:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI4NzExOA=="}], "type": "inlineReview"}, {"oid": "311ac066cc5e6bbc899fa8d03f48aea9bd23455a", "url": "https://github.com/apache/ozone/commit/311ac066cc5e6bbc899fa8d03f48aea9bd23455a", "message": "HDDS-3188 Add failover proxy for SCMBlockLocation.", "committedDate": "2020-08-27T09:39:30Z", "type": "commit"}, {"oid": "311ac066cc5e6bbc899fa8d03f48aea9bd23455a", "url": "https://github.com/apache/ozone/commit/311ac066cc5e6bbc899fa8d03f48aea9bd23455a", "message": "HDDS-3188 Add failover proxy for SCMBlockLocation.", "committedDate": "2020-08-27T09:39:30Z", "type": "forcePushed"}, {"oid": "7d4c2bdffa6ecbd05e06d99135d69bf6c92fdb28", "url": "https://github.com/apache/ozone/commit/7d4c2bdffa6ecbd05e06d99135d69bf6c92fdb28", "message": "Add close to scm client.", "committedDate": "2020-08-31T08:52:13Z", "type": "forcePushed"}, {"oid": "358362f377edf91ea941c5e3d88c87e3b6999671", "url": "https://github.com/apache/ozone/commit/358362f377edf91ea941c5e3d88c87e3b6999671", "message": "HDDS-3188: Fix CI", "committedDate": "2020-08-31T09:29:35Z", "type": "commit"}, {"oid": "311ac066cc5e6bbc899fa8d03f48aea9bd23455a", "url": "https://github.com/apache/ozone/commit/311ac066cc5e6bbc899fa8d03f48aea9bd23455a", "message": "HDDS-3188 Add failover proxy for SCMBlockLocation.", "committedDate": "2020-08-27T09:39:30Z", "type": "forcePushed"}, {"oid": "0966949fb860e722d52f13518862736aed8f53e8", "url": "https://github.com/apache/ozone/commit/0966949fb860e722d52f13518862736aed8f53e8", "message": "Merge pull request #7 from GlenGeng/HDDS-3188\n\nHDDS-3188: Fix CI", "committedDate": "2020-08-31T10:42:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDcxMjgzNA==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r480712834", "bodyText": "nit: might be useful to print which class current impl is.", "author": "amaliujia", "createdAt": "2020-09-01T03:37:49Z", "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/protocol/ScmBlockLocationProtocolServerSideTranslatorPB.java", "diffHunk": "@@ -94,9 +95,33 @@ public ScmBlockLocationProtocolServerSideTranslatorPB(\n         .setTraceID(traceID);\n   }\n \n+  private boolean isLeader() throws ServiceException {\n+    if (!(impl instanceof SCMBlockProtocolServer)) {\n+      throw new ServiceException(\"Should be SCMBlockProtocolServer\");", "originalCommit": "0966949fb860e722d52f13518862736aed8f53e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1OTc5OA==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r481759798", "bodyText": "Updated", "author": "timmylicheng", "createdAt": "2020-09-02T06:05:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDcxMjgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDcyMDMzOA==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r480720338", "bodyText": "The default implementation of getTrimmedStringCollection seems does not validate the format of ip address in string: https://github.com/apache/hadoop-ozone/blob/34ee8311b0d0a37878fe1fd2e5d8c1b91aa8cc8f/hadoop-hdds/config/src/main/java/org/apache/hadoop/hdds/conf/ConfigurationSource.java#L99\nIs the format is already validated somewhere else? if not this implementation will be fragile.", "author": "amaliujia", "createdAt": "2020-09-01T03:43:26Z", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  @VisibleForTesting\n+  protected Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (scmAddressList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    } else {\n+      for (String scmAddress : scmAddressList) {\n+        LOG.info(\"SCM Address for proxy is {}\", scmAddress);\n+        int indexOfComma = scmAddress.lastIndexOf(\":\");", "originalCommit": "0966949fb860e722d52f13518862736aed8f53e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1OTk5Mg==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r481759992", "bodyText": "Add a validator", "author": "timmylicheng", "createdAt": "2020-09-02T06:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDcyMDMzOA=="}], "type": "inlineReview"}, {"oid": "362e6f5446fd50f6521007ad9efd5b0ae44a234a", "url": "https://github.com/apache/ozone/commit/362e6f5446fd50f6521007ad9efd5b0ae44a234a", "message": "Add scm ip address validation.", "committedDate": "2020-09-02T07:02:07Z", "type": "commit"}, {"oid": "362e6f5446fd50f6521007ad9efd5b0ae44a234a", "url": "https://github.com/apache/ozone/commit/362e6f5446fd50f6521007ad9efd5b0ae44a234a", "message": "Add scm ip address validation.", "committedDate": "2020-09-02T07:02:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEwODEyNg==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r485108126", "bodyText": "conf#getObject is a heavy call, we can avoid calling it twice.", "author": "nandakumar131", "createdAt": "2020-09-08T18:14:08Z", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+import static org.apache.hadoop.hdds.HddsUtils.getHostName;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)", "originalCommit": "362e6f5446fd50f6521007ad9efd5b0ae44a234a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNjEyOQ==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r486736129", "bodyText": "Updated", "author": "timmylicheng", "createdAt": "2020-09-11T02:26:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEwODEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExNDU1NQ==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r485114555", "bodyText": "Can we avoid putting null proxy?\nWhile reading, instead of checking if proxyInfo.proxy == null, we can do proxyInfo#contains.", "author": "nandakumar131", "createdAt": "2020-09-08T18:26:06Z", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+import static org.apache.hadoop.hdds.HddsUtils.getHostName;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  @VisibleForTesting\n+  protected Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (!scmAddressList.isEmpty()) {\n+      final int port = getPortNumberFromConfigKeys(conf,\n+          ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_ADDRESS_KEY)\n+          .orElse(ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_PORT_DEFAULT);\n+      for (String scmAddress : scmAddressList) {\n+        LOG.info(\"SCM Address for proxy is {}\", scmAddress);\n+\n+        Optional<String> hostname = getHostName(scmAddress);\n+        if (hostname.isPresent()) {\n+          resultList.add(NetUtils.createSocketAddr(\n+              hostname.get() + \":\" + port));\n+        }\n+      }\n+    }\n+    if (resultList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    }\n+    return resultList;\n+  }\n+\n+  private void loadConfigs() {\n+    Collection<InetSocketAddress> scmAddressList = getSCMAddressList();\n+    int scmNodeIndex = 1;\n+    for (InetSocketAddress scmAddress : scmAddressList) {\n+      String nodeId = SCM_DUMMY_NODEID_PREFIX + scmNodeIndex;\n+      if (scmAddress == null) {\n+        LOG.error(\"Failed to create SCM proxy for {}.\", nodeId);\n+        continue;\n+      }\n+      scmNodeIndex++;\n+      SCMProxyInfo scmProxyInfo = new SCMProxyInfo(\n+          scmServiceId, nodeId, scmAddress);\n+      ProxyInfo<ScmBlockLocationProtocolPB> proxy = new ProxyInfo<>(\n+          null, scmProxyInfo.toString());\n+      scmProxies.put(nodeId, proxy);", "originalCommit": "362e6f5446fd50f6521007ad9efd5b0ae44a234a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5OTAyMQ==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r486199021", "bodyText": "ProxyInfo is defined in FailoverProxyProvider. Interface is defined already.", "author": "timmylicheng", "createdAt": "2020-09-10T09:31:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExNDU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExNjMzMA==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r485116330", "bodyText": "What is the reason for not doing anything here?", "author": "nandakumar131", "createdAt": "2020-09-08T18:29:31Z", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+import static org.apache.hadoop.hdds.HddsUtils.getHostName;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  @VisibleForTesting\n+  protected Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (!scmAddressList.isEmpty()) {\n+      final int port = getPortNumberFromConfigKeys(conf,\n+          ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_ADDRESS_KEY)\n+          .orElse(ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_PORT_DEFAULT);\n+      for (String scmAddress : scmAddressList) {\n+        LOG.info(\"SCM Address for proxy is {}\", scmAddress);\n+\n+        Optional<String> hostname = getHostName(scmAddress);\n+        if (hostname.isPresent()) {\n+          resultList.add(NetUtils.createSocketAddr(\n+              hostname.get() + \":\" + port));\n+        }\n+      }\n+    }\n+    if (resultList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    }\n+    return resultList;\n+  }\n+\n+  private void loadConfigs() {\n+    Collection<InetSocketAddress> scmAddressList = getSCMAddressList();\n+    int scmNodeIndex = 1;\n+    for (InetSocketAddress scmAddress : scmAddressList) {\n+      String nodeId = SCM_DUMMY_NODEID_PREFIX + scmNodeIndex;\n+      if (scmAddress == null) {\n+        LOG.error(\"Failed to create SCM proxy for {}.\", nodeId);\n+        continue;\n+      }\n+      scmNodeIndex++;\n+      SCMProxyInfo scmProxyInfo = new SCMProxyInfo(\n+          scmServiceId, nodeId, scmAddress);\n+      ProxyInfo<ScmBlockLocationProtocolPB> proxy = new ProxyInfo<>(\n+          null, scmProxyInfo.toString());\n+      scmProxies.put(nodeId, proxy);\n+      scmProxyInfoMap.put(nodeId, scmProxyInfo);\n+      scmNodeIDList.add(nodeId);\n+    }\n+\n+    if (scmProxies.isEmpty()) {\n+      throw new IllegalArgumentException(\"Could not find any configured \" +\n+          \"addresses for SCM. Please configure the system with \"\n+          + OZONE_SCM_NAMES);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public synchronized String getCurrentProxyOMNodeId() {\n+    return currentProxySCMNodeId;\n+  }\n+\n+  @Override\n+  public synchronized ProxyInfo getProxy() {\n+    ProxyInfo currentProxyInfo = scmProxies.get(currentProxySCMNodeId);\n+    createSCMProxyIfNeeded(currentProxyInfo, currentProxySCMNodeId);\n+    return currentProxyInfo;\n+  }\n+\n+  @Override\n+  public void performFailover(ScmBlockLocationProtocolPB newLeader) {\n+    // Should do nothing here.", "originalCommit": "362e6f5446fd50f6521007ad9efd5b0ae44a234a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTMzNzAxMA==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r485337010", "bodyText": "The input protocol ScmBlockLocationProtocolPB is difficult to use here. We mainly use performFailoverToAssignedLeader", "author": "timmylicheng", "createdAt": "2020-09-09T04:53:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExNjMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExODEyMA==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r485118120", "bodyText": "This can be made private.", "author": "nandakumar131", "createdAt": "2020-09-08T18:32:58Z", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+import static org.apache.hadoop.hdds.HddsUtils.getHostName;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  @VisibleForTesting\n+  protected Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (!scmAddressList.isEmpty()) {\n+      final int port = getPortNumberFromConfigKeys(conf,\n+          ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_ADDRESS_KEY)\n+          .orElse(ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_PORT_DEFAULT);\n+      for (String scmAddress : scmAddressList) {\n+        LOG.info(\"SCM Address for proxy is {}\", scmAddress);\n+\n+        Optional<String> hostname = getHostName(scmAddress);\n+        if (hostname.isPresent()) {\n+          resultList.add(NetUtils.createSocketAddr(\n+              hostname.get() + \":\" + port));\n+        }\n+      }\n+    }\n+    if (resultList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    }\n+    return resultList;\n+  }\n+\n+  private void loadConfigs() {\n+    Collection<InetSocketAddress> scmAddressList = getSCMAddressList();\n+    int scmNodeIndex = 1;\n+    for (InetSocketAddress scmAddress : scmAddressList) {\n+      String nodeId = SCM_DUMMY_NODEID_PREFIX + scmNodeIndex;\n+      if (scmAddress == null) {\n+        LOG.error(\"Failed to create SCM proxy for {}.\", nodeId);\n+        continue;\n+      }\n+      scmNodeIndex++;\n+      SCMProxyInfo scmProxyInfo = new SCMProxyInfo(\n+          scmServiceId, nodeId, scmAddress);\n+      ProxyInfo<ScmBlockLocationProtocolPB> proxy = new ProxyInfo<>(\n+          null, scmProxyInfo.toString());\n+      scmProxies.put(nodeId, proxy);\n+      scmProxyInfoMap.put(nodeId, scmProxyInfo);\n+      scmNodeIDList.add(nodeId);\n+    }\n+\n+    if (scmProxies.isEmpty()) {\n+      throw new IllegalArgumentException(\"Could not find any configured \" +\n+          \"addresses for SCM. Please configure the system with \"\n+          + OZONE_SCM_NAMES);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public synchronized String getCurrentProxyOMNodeId() {\n+    return currentProxySCMNodeId;\n+  }\n+\n+  @Override\n+  public synchronized ProxyInfo getProxy() {\n+    ProxyInfo currentProxyInfo = scmProxies.get(currentProxySCMNodeId);\n+    createSCMProxyIfNeeded(currentProxyInfo, currentProxySCMNodeId);\n+    return currentProxyInfo;\n+  }\n+\n+  @Override\n+  public void performFailover(ScmBlockLocationProtocolPB newLeader) {\n+    // Should do nothing here.\n+    LOG.debug(\"Failing over to next proxy. {}\", getCurrentProxyOMNodeId());\n+  }\n+\n+  public void performFailoverToAssignedLeader(String newLeader) {\n+    if (newLeader == null) {\n+      // If newLeader is not assigned, it will fail over to next proxy.\n+      nextProxyIndex();\n+    } else {\n+      if (!assignLeaderToNode(newLeader)) {\n+        LOG.debug(\"Failing over OM proxy to nodeId: {}\", newLeader);\n+        nextProxyIndex();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Class<ScmBlockLocationProtocolPB> getInterface() {\n+    return ScmBlockLocationProtocolPB.class;\n+  }\n+\n+  @Override\n+  public synchronized void close() throws IOException {\n+    for (ProxyInfo<ScmBlockLocationProtocolPB> proxy : scmProxies.values()) {\n+      ScmBlockLocationProtocolPB scmProxy = proxy.proxy;\n+      if (scmProxy != null) {\n+        RPC.stopProxy(scmProxy);\n+      }\n+    }\n+  }\n+\n+  public RetryAction getRetryAction(int failovers) {\n+    if (failovers < maxRetryCount) {\n+      return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n+          getRetryInterval());\n+    } else {\n+      return RetryAction.FAIL;\n+    }\n+  }\n+\n+  private synchronized long getRetryInterval() {\n+    // TODO add exponential backup\n+    return retryInterval;\n+  }\n+\n+  private synchronized int nextProxyIndex() {\n+    lastAttemptedLeader = currentProxySCMNodeId;\n+\n+    // round robin the next proxy\n+    currentProxyIndex = (currentProxyIndex + 1) % scmProxies.size();\n+    currentProxySCMNodeId =  scmNodeIDList.get(currentProxyIndex);\n+    return currentProxyIndex;\n+  }\n+\n+  synchronized boolean assignLeaderToNode(String newLeaderNodeId) {", "originalCommit": "362e6f5446fd50f6521007ad9efd5b0ae44a234a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5OTg0Ng==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r486199846", "bodyText": "Updated", "author": "timmylicheng", "createdAt": "2020-09-10T09:32:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExODEyMA=="}], "type": "inlineReview"}, {"oid": "402f00f95b24f0b8ac53ee882cc4dbdbe5ccc1c9", "url": "https://github.com/apache/ozone/commit/402f00f95b24f0b8ac53ee882cc4dbdbe5ccc1c9", "message": "Remove suggestedLeader.", "committedDate": "2020-09-11T03:35:00Z", "type": "forcePushed"}, {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f", "url": "https://github.com/apache/ozone/commit/277efde99dc3f324ee7b760a99b8d608f0eb1a3f", "message": "Remove suggestedLeader.", "committedDate": "2020-09-14T07:30:05Z", "type": "commit"}, {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f", "url": "https://github.com/apache/ozone/commit/277efde99dc3f324ee7b760a99b8d608f0eb1a3f", "message": "Remove suggestedLeader.", "committedDate": "2020-09-14T07:30:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NDQzNA==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r492294434", "bodyText": "should this configuration group prefix with hdds.scmclient to match with the package name?", "author": "xiaoyuyao", "createdAt": "2020-09-21T19:25:17Z", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMClientConfig.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import org.apache.hadoop.hdds.conf.Config;\n+import org.apache.hadoop.hdds.conf.ConfigGroup;\n+import org.apache.hadoop.hdds.conf.ConfigType;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.hadoop.hdds.conf.ConfigTag.CLIENT;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.OZONE;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.SCM;\n+\n+/**\n+ * Config for SCM Block Client.\n+ */\n+@ConfigGroup(prefix = \"ozone.scmclient\")", "originalCommit": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTUzNzMwNg==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r495537306", "bodyText": "Updated", "author": "timmylicheng", "createdAt": "2020-09-27T06:50:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NDQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NDY5Ng==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r492294696", "bodyText": "OzoneManager=>StorageContainerManger", "author": "xiaoyuyao", "createdAt": "2020-09-21T19:25:46Z", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMClientConfig.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import org.apache.hadoop.hdds.conf.Config;\n+import org.apache.hadoop.hdds.conf.ConfigGroup;\n+import org.apache.hadoop.hdds.conf.ConfigType;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.hadoop.hdds.conf.ConfigTag.CLIENT;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.OZONE;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.SCM;\n+\n+/**\n+ * Config for SCM Block Client.\n+ */\n+@ConfigGroup(prefix = \"ozone.scmclient\")\n+public class SCMClientConfig {\n+  public static final String SCM_CLIENT_RPC_TIME_OUT = \"rpc.timeout\";\n+  public static final String SCM_CLIENT_FAILOVER_MAX_RETRY =\n+      \"failover.max.retry\";\n+  public static final String SCM_CLIENT_RETRY_INTERVAL =\n+      \"failover.retry.interval\";\n+\n+  @Config(key = SCM_CLIENT_RPC_TIME_OUT,\n+      defaultValue = \"15m\",\n+      type = ConfigType.TIME,\n+      tags = {OZONE, SCM, CLIENT},\n+      timeUnit = TimeUnit.MILLISECONDS,\n+      description = \"RpcClient timeout on waiting for the response from \" +\n+          \"OzoneManager. The default value is set to 15 minutes. \" +", "originalCommit": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTUzNzI3Mg==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r495537272", "bodyText": "Updated", "author": "timmylicheng", "createdAt": "2020-09-27T06:50:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NDY5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTMxMQ==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r492295311", "bodyText": "OzoneManager=>StorageContainerManger", "author": "xiaoyuyao", "createdAt": "2020-09-21T19:26:59Z", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMClientConfig.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import org.apache.hadoop.hdds.conf.Config;\n+import org.apache.hadoop.hdds.conf.ConfigGroup;\n+import org.apache.hadoop.hdds.conf.ConfigType;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.hadoop.hdds.conf.ConfigTag.CLIENT;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.OZONE;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.SCM;\n+\n+/**\n+ * Config for SCM Block Client.\n+ */\n+@ConfigGroup(prefix = \"ozone.scmclient\")\n+public class SCMClientConfig {\n+  public static final String SCM_CLIENT_RPC_TIME_OUT = \"rpc.timeout\";\n+  public static final String SCM_CLIENT_FAILOVER_MAX_RETRY =\n+      \"failover.max.retry\";\n+  public static final String SCM_CLIENT_RETRY_INTERVAL =\n+      \"failover.retry.interval\";\n+\n+  @Config(key = SCM_CLIENT_RPC_TIME_OUT,\n+      defaultValue = \"15m\",\n+      type = ConfigType.TIME,\n+      tags = {OZONE, SCM, CLIENT},\n+      timeUnit = TimeUnit.MILLISECONDS,\n+      description = \"RpcClient timeout on waiting for the response from \" +\n+          \"OzoneManager. The default value is set to 15 minutes. \" +\n+          \"If ipc.client.ping is set to true and this rpc-timeout \" +\n+          \"is greater than the value of ipc.ping.interval, the effective \" +\n+          \"value of the rpc-timeout is rounded up to multiple of \" +\n+          \"ipc.ping.interval.\"\n+  )\n+  private long rpcTimeOut = 15 * 60 * 1000;\n+\n+  @Config(key = SCM_CLIENT_FAILOVER_MAX_RETRY,\n+      defaultValue = \"15\",\n+      type = ConfigType.INT,\n+      tags = {OZONE, SCM, CLIENT},\n+      description = \"Max retry count for SCM Client when failover happens.\"\n+  )\n+  private int retryCount = 15;\n+\n+  @Config(key = SCM_CLIENT_RETRY_INTERVAL,\n+      defaultValue = \"2s\",\n+      type = ConfigType.TIME,\n+      tags = {OZONE, SCM, CLIENT},\n+      timeUnit = TimeUnit.MILLISECONDS,\n+      description = \"RpcClient timeout on waiting for the response from \" +\n+          \"OzoneManager. The default value is set to 15 minutes. \" +", "originalCommit": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTc4OQ==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r492295789", "bodyText": "Also the description does not match with the configuration key and needs to be updated.", "author": "xiaoyuyao", "createdAt": "2020-09-21T19:27:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTUzNzI3MA==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r495537270", "bodyText": "Updated", "author": "timmylicheng", "createdAt": "2020-09-27T06:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NjU4MQ==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r492296581", "bodyText": "missing getter for nodeid and serviceid?", "author": "xiaoyuyao", "createdAt": "2020-09-21T19:29:26Z", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMProxyInfo.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetSocketAddress;\n+\n+/**\n+ * Class to store SCM proxy info.\n+ */\n+public class SCMProxyInfo {\n+  private String serviceId;\n+  private String nodeId;\n+  private String rpcAddrStr;\n+  private InetSocketAddress rpcAddr;\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SCMProxyInfo.class);\n+\n+  public SCMProxyInfo(String serviceID, String nodeID,\n+                      InetSocketAddress rpcAddress) {\n+    Preconditions.checkNotNull(rpcAddress);\n+    this.serviceId = serviceID;\n+    this.nodeId = nodeID;\n+    this.rpcAddrStr = rpcAddress.toString();\n+    this.rpcAddr = rpcAddress;\n+    if (rpcAddr.isUnresolved()) {\n+      LOG.warn(\"SCM address {} for serviceID {} remains unresolved \" +\n+              \"for node ID {} Check your ozone-site.xml file to ensure scm \" +\n+              \"addresses are configured properly.\",\n+          rpcAddress, serviceId, nodeId);\n+    }\n+  }\n+\n+  public String toString() {\n+    return new StringBuilder()\n+        .append(\"nodeId=\")\n+        .append(nodeId)\n+        .append(\",nodeAddress=\")\n+        .append(rpcAddrStr).toString();\n+  }\n+\n+  public InetSocketAddress getAddress() {", "originalCommit": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTUzNzUyMQ==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r495537521", "bodyText": "Updated.", "author": "timmylicheng", "createdAt": "2020-09-27T06:53:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NjU4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5ODE0OA==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r492298148", "bodyText": "Should we send back the leader known by this SCM follower instead of null to avoid unnecessary client retry?", "author": "xiaoyuyao", "createdAt": "2020-09-21T19:32:26Z", "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/protocol/ScmBlockLocationProtocolServerSideTranslatorPB.java", "diffHunk": "@@ -94,9 +95,26 @@ public ScmBlockLocationProtocolServerSideTranslatorPB(\n         .setTraceID(traceID);\n   }\n \n+  private boolean isLeader() throws ServiceException {\n+    if (!(impl instanceof SCMBlockProtocolServer)) {\n+      throw new ServiceException(\"Should be SCMBlockProtocolServer\");\n+    } else {\n+      return ((SCMBlockProtocolServer) impl).getScm().checkLeader();\n+    }\n+  }\n+\n   @Override\n   public SCMBlockLocationResponse send(RpcController controller,\n       SCMBlockLocationRequest request) throws ServiceException {\n+    if (!isLeader()) {\n+      SCMBlockLocationResponse.Builder response = createSCMBlockResponse(\n+          request.getCmdType(),\n+          request.getTraceID());\n+      response.setSuccess(false);\n+      response.setStatus(Status.SCM_NOT_LEADER);\n+      response.setLeaderSCMNodeId(null);", "originalCommit": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTUyNDIzNw==", "url": "https://github.com/apache/ozone/pull/1340#discussion_r495524237", "bodyText": "@xiaoyuyao We decide to implement suggestedLeader in following JIRA https://issues.apache.org/jira/browse/HDDS-4281. To use suggestedLeader from Ratis, we may need a more well-rounded strategy.", "author": "timmylicheng", "createdAt": "2020-09-27T03:52:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5ODE0OA=="}], "type": "inlineReview"}, {"oid": "d143b79028da2c380e806d4e478843fdd722c94a", "url": "https://github.com/apache/ozone/commit/d143b79028da2c380e806d4e478843fdd722c94a", "message": "Address commnets.", "committedDate": "2020-09-27T06:54:02Z", "type": "commit"}]}