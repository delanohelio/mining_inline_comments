{"pr_number": 1405, "pr_title": "HDDS-4143. Implement a factory for OM Requests that returns an instance based on layout version.", "pr_createdAt": "2020-09-07T22:19:28Z", "pr_url": "https://github.com/apache/ozone/pull/1405", "timeline": [{"oid": "2bcc75fecf0ab3a53dddddbcd9ae4236e9bfc937", "url": "https://github.com/apache/ozone/commit/2bcc75fecf0ab3a53dddddbcd9ae4236e9bfc937", "message": "Commit 1.", "committedDate": "2020-09-07T22:14:00Z", "type": "commit"}, {"oid": "af28891ac0d6ebc81d8b56dc92334d8e30bd679b", "url": "https://github.com/apache/ozone/commit/af28891ac0d6ebc81d8b56dc92334d8e30bd679b", "message": "Commit 2.", "committedDate": "2020-09-07T22:14:11Z", "type": "commit"}, {"oid": "13356b920e4cc0e90102d5193df6468671a02521", "url": "https://github.com/apache/ozone/commit/13356b920e4cc0e90102d5193df6468671a02521", "message": "Commit 3.", "committedDate": "2020-09-07T22:14:18Z", "type": "commit"}, {"oid": "06bee3e6962c94278dc604320bc5b15bc4b273ef", "url": "https://github.com/apache/ozone/commit/06bee3e6962c94278dc604320bc5b15bc4b273ef", "message": "Integration test fix.", "committedDate": "2020-09-07T22:14:27Z", "type": "commit"}, {"oid": "40e47a18ddd4e94b01bc28922699aed8dfacf4d9", "url": "https://github.com/apache/ozone/commit/40e47a18ddd4e94b01bc28922699aed8dfacf4d9", "message": "Address review comments.", "committedDate": "2020-09-07T22:28:08Z", "type": "commit"}, {"oid": "f37fd02da6e15efff27f12e2b0449fbb5ba694d3", "url": "https://github.com/apache/ozone/commit/f37fd02da6e15efff27f12e2b0449fbb5ba694d3", "message": "Fix acceptance tests.", "committedDate": "2020-09-08T15:17:59Z", "type": "commit"}, {"oid": "c9e3d2014747d87a3583d91c822ce4af6f58600f", "url": "https://github.com/apache/ozone/commit/c9e3d2014747d87a3583d91c822ce4af6f58600f", "message": "trigger new CI check", "committedDate": "2020-09-08T19:35:24Z", "type": "commit"}, {"oid": "6fd391a766e862918859b2cb441594882f0c250f", "url": "https://github.com/apache/ozone/commit/6fd391a766e862918859b2cb441594882f0c250f", "message": "trigger new CI check", "committedDate": "2020-09-08T19:35:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM0NTA2Nw==", "url": "https://github.com/apache/ozone/pull/1405#discussion_r485345067", "bodyText": "Instead of a new method, we can use annotation.", "author": "bharatviswa504", "createdAt": "2020-09-09T05:22:36Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/bucket/OMBucketSetPropertyRequest.java", "diffHunk": "@@ -206,4 +207,8 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n       return omClientResponse;\n     }\n   }\n+\n+  public static String getRequestType() {", "originalCommit": "6fd391a766e862918859b2cb441594882f0c250f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc2OTAxMQ==", "url": "https://github.com/apache/ozone/pull/1405#discussion_r485769011", "bodyText": "@bharatviswa504 Yes, I pondered about adding annotation for this. Given that we already have annotations for Cleanup tables and BelongsToLayoutVersion, I wanted to hold off on adding more annotations. If it is ok with you, after the first round of changes, we can change this to an annotation.", "author": "avijayanhwx", "createdAt": "2020-09-09T16:49:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM0NTA2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIxMzg2MQ==", "url": "https://github.com/apache/ozone/pull/1405#discussion_r486213861", "bodyText": "The problem currently with an annotation approach is the fact that we can not use expressions like \"SetAcl.name() + \"-\" + ObjectType.KEY\" in annotations, as that does not qualify as a constant.", "author": "fapifta", "createdAt": "2020-09-10T09:55:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM0NTA2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODIyMDE2MQ==", "url": "https://github.com/apache/ozone/pull/1405#discussion_r488220161", "bodyText": "If that is the problem we can define a static variable with direct value and do it.", "author": "bharatviswa504", "createdAt": "2020-09-14T21:06:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM0NTA2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzMTMzOA==", "url": "https://github.com/apache/ozone/pull/1405#discussion_r488331338", "bodyText": "@bharatviswa504 As discussed offline, we can revisit in the next iteration.", "author": "avijayanhwx", "createdAt": "2020-09-15T01:41:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM0NTA2Nw=="}], "type": "inlineReview"}, {"oid": "d5c5be6c60d40f83c97cc2ca400107071ed427a2", "url": "https://github.com/apache/ozone/commit/d5c5be6c60d40f83c97cc2ca400107071ed427a2", "message": "Merge remote-tracking branch 'upstream/HDDS-3698-upgrade' into HDDS-4143-upgrade", "committedDate": "2020-09-09T20:07:17Z", "type": "commit"}, {"oid": "7774112146837c7b54441d16c791c3e4dbad9ddc", "url": "https://github.com/apache/ozone/commit/7774112146837c7b54441d16c791c3e4dbad9ddc", "message": "Address review comments.", "committedDate": "2020-09-11T22:00:44Z", "type": "commit"}, {"oid": "5281c2615e479e3a6b6685e1cc776b548d78b4da", "url": "https://github.com/apache/ozone/commit/5281c2615e479e3a6b6685e1cc776b548d78b4da", "message": "Add onFinalize to Instance factory.", "committedDate": "2020-09-12T00:52:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE5Njg5Mg==", "url": "https://github.com/apache/ozone/pull/1405#discussion_r488196892", "bodyText": "I think we need a \",\" here instead of \"+\".", "author": "fapifta", "createdAt": "2020-09-14T20:20:46Z", "path": "hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/upgrade/LayoutVersionInstanceFactory.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.upgrade;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.stream.Collectors.toList;\n+\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.PriorityQueue;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * Generic factory which stores different instances of Type 'T' sharded by\n+ * a key & version. A single key can be associated with different versions\n+ * of 'T'.\n+ *\n+ * Why does this class exist?\n+ * A typical use case during upgrade is to have multiple versions of a class\n+ * / method / object and chose them based  on current layout\n+ * version at runtime. Before finalizing, an older version is typically\n+ * needed, and after finalize, a newer version is needed. This class serves\n+ * this purpose in a generic way.\n+ *\n+ * For example, we can create a Factory to create multiple versions of\n+ * OMRequests sharded by Request Type & Layout Version Supported.\n+ */\n+public class LayoutVersionInstanceFactory<T> {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(LayoutVersionInstanceFactory.class);\n+\n+  /**\n+   * The factory will maintain ALL instances > MLV and 1 instance <= MLV in a\n+   * priority queue (ordered by version). By doing that it guarantees O(1)\n+   * lookup at all times, since we always would lookup the first element (top\n+   * of the PQ).\n+   * Multiple entries will be there ONLY during pre-finalized state.\n+   * On finalization, we will be removing the entry one by one until we reach\n+   * a single entry. On a regular component instance (finalized), there will\n+   * be a single request version associated with a request always.\n+   */\n+  private final Map<String, PriorityQueue<VersionedInstance<T>>> instances =\n+      new HashMap<>();\n+\n+  /**\n+   * Register an instance with a given factory key (key + version).\n+   * For safety reasons we dont allow (1) re-registering, (2) registering an\n+   * instance with version > SLV.\n+   *\n+   * @param lvm LayoutVersionManager\n+   * @param key VersionFactoryKey key to associate with instance.\n+   * @param instance instance to register.\n+   */\n+  public boolean register(LayoutVersionManager lvm, VersionFactoryKey key,\n+                       T instance) {\n+    // If version is not passed in, go defensive and set the highest possible\n+    // version (SLV).\n+    int version = key.getVersion() == null ?\n+        lvm.getSoftwareLayoutVersion() : key.getVersion();\n+\n+    checkArgument(lvm.getSoftwareLayoutVersion() >= key.getVersion(),\n+        String.format(\"Cannot register key %s since the version is greater \" +\n+                \"than the Software layout version %d\",\n+        key, lvm.getSoftwareLayoutVersion()));\n+\n+    // If we reach here, we know that the passed in version belongs to\n+    // [0, SLV].\n+    String primaryKey = key.getKey();\n+    instances.computeIfAbsent(primaryKey, s ->\n+        new PriorityQueue<>(Comparator.comparingInt(o -> o.version)));\n+\n+    PriorityQueue<VersionedInstance<T>> versionedInstances =\n+        instances.get(primaryKey);\n+    Optional<VersionedInstance<T>> existingInstance =\n+        versionedInstances.parallelStream()\n+        .filter(v -> v.version == key.getVersion()).findAny();\n+\n+    if (existingInstance.isPresent()) {\n+      throw new IllegalArgumentException(String.format(\"Cannot register key \" +\n+          \"%s since there is an existing entry already.\", key));\n+    }\n+\n+    if (!versionedInstances.isEmpty() && isValid(lvm, version)) {\n+      VersionedInstance<T> currentPeek = versionedInstances.peek();\n+      if (currentPeek.version < version) {\n+        // Current peek < passed in version (and <= MLV). Hence, we can\n+        // remove it, since the passed in a better candidate.\n+        versionedInstances.poll();\n+        // Add the passed in instance.\n+        versionedInstances.offer(new VersionedInstance<>(version, instance));\n+        return true;\n+      } else if (currentPeek.version > lvm.getMetadataLayoutVersion()) {\n+        // Current peak is > MLV, hence we don't need to remove that. Just\n+        // add passed in instance.\n+        versionedInstances.offer(new VersionedInstance<>(version, instance));\n+        return true;\n+      } else {\n+        // Current peek <= MLV and > passed in version, and hence a better\n+        // canidate. Retaining the peek, and ignoring the passed in instance.\n+        return false;\n+      }\n+    } else {\n+      // Passed in instance version > MLV (or the first version to be\n+      // registered), hence can be registered.\n+      versionedInstances.offer(new VersionedInstance<>(version, instance));\n+      return true;\n+    }\n+  }\n+\n+  private boolean isValid(LayoutVersionManager lvm, int version) {\n+    return version <= lvm.getMetadataLayoutVersion();\n+  }\n+\n+  /**\n+   * From the list of versioned instances for a given \"key\", this\n+   * returns the \"floor\" value corresponding to the given version.\n+   * For example, if we have key = \"CreateKey\",  entry -> [(1, CreateKeyV1),\n+   * (3, CreateKeyV2), and if the passed in key = CreateKey & version = 2, we\n+   * return CreateKeyV1.\n+   * Since this is a priority queue based implementation, we use a O(1) peek()\n+   * lookup to get the current valid version.\n+   * @param lvm LayoutVersionManager\n+   * @param key Key and Version.\n+   * @return instance.\n+   */\n+  public T get(LayoutVersionManager lvm, VersionFactoryKey key) {\n+    Integer version = key.getVersion();\n+    // If version is not passed in, go defensive and set the highest allowed\n+    // version (MLV).\n+    if (version == null) {\n+      version = lvm.getMetadataLayoutVersion();\n+    }\n+\n+    checkArgument(lvm.getMetadataLayoutVersion() >= version,\n+        String.format(\"Cannot get key %s since the version is greater \" +\n+                \"than the Metadata layout version %d\",\n+            key, lvm.getMetadataLayoutVersion()));\n+\n+    String primaryKey = key.getKey();\n+    PriorityQueue<VersionedInstance<T>> versionedInstances =\n+        instances.get(primaryKey);\n+    if (versionedInstances == null || versionedInstances.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"No suitable instance found for request : \" + key);\n+    }\n+\n+    VersionedInstance<T> value = versionedInstances.peek();\n+    if (value == null || value.version > version) {\n+      throw new IllegalArgumentException(\n+          \"No suitable instance found for request : \" + key);\n+    } else {\n+      return value.instance;\n+    }\n+  }\n+\n+  /**\n+   * To be called on finalization when there is an MLV update.\n+   * @param lvm LayoutVersionManager instance.\n+   */\n+  public void onFinalize(LayoutVersionManager lvm) {\n+    Iterator<Map.Entry<String, PriorityQueue<VersionedInstance<T>>>> iterator =\n+        instances.entrySet().iterator();\n+    while (iterator.hasNext()) {\n+      Map.Entry<String, PriorityQueue<VersionedInstance<T>>> next =\n+          iterator.next();\n+      PriorityQueue<VersionedInstance<T>> vInstances = next.getValue();\n+      VersionedInstance<T> prevInstance = null;\n+      while (!vInstances.isEmpty() &&\n+          vInstances.peek().version < lvm.getMetadataLayoutVersion()) {\n+        prevInstance = vInstances.poll();\n+        LOG.info(\"Unregistering {} from factory. \", prevInstance.instance);\n+      }\n+\n+      if ((vInstances.isEmpty() ||\n+          vInstances.peek().version > lvm.getMetadataLayoutVersion())\n+          && prevInstance != null) {\n+        vInstances.offer(prevInstance);\n+      }\n+\n+      if (vInstances.isEmpty()) {\n+        LOG.info(\"Unregistering '{}' from factory since it has no entries.\" +", "originalCommit": "5281c2615e479e3a6b6685e1cc776b548d78b4da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "547e3d07037520c4672fffe3b84c9356991cc6b4", "url": "https://github.com/apache/ozone/commit/547e3d07037520c4672fffe3b84c9356991cc6b4", "message": "Address minor review comments.", "committedDate": "2020-09-14T20:59:36Z", "type": "commit"}]}