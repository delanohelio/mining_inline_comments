{"pr_number": 1339, "pr_title": "HDDS-4131. Container report should update container key count and bytes used if they differ in SCM", "pr_createdAt": "2020-08-19T16:16:02Z", "pr_url": "https://github.com/apache/ozone/pull/1339", "timeline": [{"oid": "62fc28e77b36ae5824ad0fc90b8237c3f73e87f7", "url": "https://github.com/apache/ozone/commit/62fc28e77b36ae5824ad0fc90b8237c3f73e87f7", "message": "Changes to fix the issue", "committedDate": "2020-08-19T16:11:46Z", "type": "commit"}, {"oid": "77ebff109d4ffa310b8d37049dc9d39babc27582", "url": "https://github.com/apache/ozone/commit/77ebff109d4ffa310b8d37049dc9d39babc27582", "message": "Consider all replicas when adjusting keyCount and UsedBytes", "committedDate": "2020-08-21T14:34:59Z", "type": "commit"}, {"oid": "2870dc6841090d9706f080391841fa1fdd6cddd0", "url": "https://github.com/apache/ozone/commit/2870dc6841090d9706f080391841fa1fdd6cddd0", "message": "Added tests", "committedDate": "2020-08-23T13:31:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyNDA1Nw==", "url": "https://github.com/apache/ozone/pull/1339#discussion_r475524057", "bodyText": "I think we can skip filtering the replicas for \"others\" (and omit the code for that), since the resulting count/bytes values are the min/max of all replicas, including this one, either way.  If we loop over all replicas, the iteration for the current replica will be a \"no-op\", not change the result.", "author": "adoroszlai", "createdAt": "2020-08-24T11:08:37Z", "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/container/AbstractContainerReportHandler.java", "diffHunk": "@@ -103,14 +108,44 @@ private void updateContainerStats(final ContainerID containerId,\n         containerInfo.updateSequenceId(\n             replicaProto.getBlockCommitSequenceId());\n       }\n+      List<ContainerReplica> otherReplicas =\n+          getOtherReplicas(containerId, datanodeDetails);", "originalCommit": "2870dc6841090d9706f080391841fa1fdd6cddd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU0NzkxMw==", "url": "https://github.com/apache/ozone/pull/1339#discussion_r475547913", "bodyText": "I think we still do need to filter out the current replica. The reason is that at the point the stats are updated, the newly reported replica has not yet updated the previous values stored for it in SCM memory. This is due to the order of operations here, in AbstractContainerReportHandler:\n  protected void processContainerReplica(final DatanodeDetails datanodeDetails,\n                               final ContainerReplicaProto replicaProto)\n      throws IOException {\n    final ContainerID containerId = ContainerID\n        .valueof(replicaProto.getContainerID());\n\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Processing replica of container {} from datanode {}\",\n          containerId, datanodeDetails);\n    }\n    // Synchronized block should be replaced by container lock,\n    // once we have introduced lock inside ContainerInfo.\n    synchronized (containerManager.getContainer(containerId)) {\n      updateContainerStats(datanodeDetails, containerId, replicaProto);\n      updateContainerState(datanodeDetails, containerId, replicaProto);\n      updateContainerReplica(datanodeDetails, containerId, replicaProto);\n    }\n  }\n\nThe in-memory values for the reported replicas are not updated until the updateContainerReplica(...) call, but we updateContainerStats(...) before that.\nFor example, lets say we have an CLOSED container, so its the max of the values we use.\nExisting replicas have values 4, 4, 5, so the value used is 5.\nThe new report changes the 5 to 4, so now we would have:\n4, 4, 5 (stale value, will be updated soon), 4(new value of stale value).\nIf we don't filter out the stale replica, then the value will be wrong and left as 5 until the next container report is processed, when it would change to 4.\nDoes that make sense?", "author": "sodonnel", "createdAt": "2020-08-24T11:59:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyNDA1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU3NzI5Mg==", "url": "https://github.com/apache/ozone/pull/1339#discussion_r475577292", "bodyText": "Good point, I missed that.  Thanks for the explanation.", "author": "adoroszlai", "createdAt": "2020-08-24T12:53:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyNDA1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUzMTM0Nw==", "url": "https://github.com/apache/ozone/pull/1339#discussion_r475531347", "bodyText": "Note: not a big deal, but it seems usedBytes and keyCount values are swapped compared to the original.", "author": "adoroszlai", "createdAt": "2020-08-24T11:24:20Z", "path": "hadoop-hdds/server-scm/src/test/java/org/apache/hadoop/hdds/scm/container/TestContainerReportHandler.java", "diffHunk": "@@ -483,9 +485,167 @@ public void testQuasiClosedToClosed()\n     Assert.assertEquals(LifeCycleState.CLOSED, containerOne.getState());\n   }\n \n+  @Test\n+  public void openContainerKeyAndBytesUsedUpdatedToMinimumOfAllReplicas()\n+      throws SCMException {\n+    final ContainerReportHandler reportHandler = new ContainerReportHandler(\n+        nodeManager, containerManager);\n+    final Iterator<DatanodeDetails> nodeIterator = nodeManager.getNodes(\n+        NodeState.HEALTHY).iterator();\n+\n+    final DatanodeDetails datanodeOne = nodeIterator.next();\n+    final DatanodeDetails datanodeTwo = nodeIterator.next();\n+    final DatanodeDetails datanodeThree = nodeIterator.next();\n+\n+    final ContainerReplicaProto.State replicaState\n+        = ContainerReplicaProto.State.OPEN;\n+    final ContainerInfo containerOne = getContainer(LifeCycleState.OPEN);\n+\n+    final Set<ContainerID> containerIDSet = new HashSet<>();\n+    containerIDSet.add(containerOne.containerID());\n+\n+    containerStateManager.loadContainer(containerOne);\n+    // Container loaded, no replicas reported from DNs. Expect zeros for\n+    // usage values.\n+    assertEquals(0L, containerOne.getUsedBytes());\n+    assertEquals(0L, containerOne.getNumberOfKeys());\n+\n+    reportHandler.onMessage(getContainerReportFromDatanode(\n+        containerOne.containerID(), replicaState,\n+        datanodeOne, 50L, 60L), publisher);\n+\n+    // Single replica reported - ensure values are updated\n+    assertEquals(50L, containerOne.getUsedBytes());\n+    assertEquals(60L, containerOne.getNumberOfKeys());\n+\n+    reportHandler.onMessage(getContainerReportFromDatanode(\n+        containerOne.containerID(), replicaState,\n+        datanodeTwo, 50L, 60L), publisher);\n+    reportHandler.onMessage(getContainerReportFromDatanode(\n+        containerOne.containerID(), replicaState,\n+        datanodeThree, 50L, 60L), publisher);\n+\n+    // All 3 DNs are reporting the same values. Counts should be as expected.\n+    assertEquals(50L, containerOne.getUsedBytes());\n+    assertEquals(60L, containerOne.getNumberOfKeys());\n+\n+    // Now each DN reports a different lesser value. Counts should be the min\n+    // reported.\n+    reportHandler.onMessage(getContainerReportFromDatanode(\n+        containerOne.containerID(), replicaState,\n+        datanodeOne, 1L, 10L), publisher);\n+    reportHandler.onMessage(getContainerReportFromDatanode(\n+        containerOne.containerID(), replicaState,\n+        datanodeTwo, 2L, 11L), publisher);\n+    reportHandler.onMessage(getContainerReportFromDatanode(\n+        containerOne.containerID(), replicaState,\n+        datanodeThree, 3L, 12L), publisher);\n+\n+    // All 3 DNs are reporting different values. The actual value should be the\n+    // minimum.\n+    assertEquals(1L, containerOne.getUsedBytes());\n+    assertEquals(10L, containerOne.getNumberOfKeys());\n+\n+    // Have the lowest value report a higher value and ensure the new value\n+    // is the minimum\n+    reportHandler.onMessage(getContainerReportFromDatanode(\n+        containerOne.containerID(), replicaState,\n+        datanodeOne, 3L, 12L), publisher);\n+\n+    assertEquals(2L, containerOne.getUsedBytes());\n+    assertEquals(11L, containerOne.getNumberOfKeys());\n+  }\n+\n+  @Test\n+  public void notOpenContainerKeyAndBytesUsedUpdatedToMaximumOfAllReplicas()\n+      throws SCMException {\n+    final ContainerReportHandler reportHandler = new ContainerReportHandler(\n+        nodeManager, containerManager);\n+    final Iterator<DatanodeDetails> nodeIterator = nodeManager.getNodes(\n+        NodeState.HEALTHY).iterator();\n+\n+    final DatanodeDetails datanodeOne = nodeIterator.next();\n+    final DatanodeDetails datanodeTwo = nodeIterator.next();\n+    final DatanodeDetails datanodeThree = nodeIterator.next();\n+\n+    final ContainerReplicaProto.State replicaState\n+        = ContainerReplicaProto.State.CLOSED;\n+    final ContainerInfo containerOne = getContainer(LifeCycleState.CLOSED);\n+\n+    final Set<ContainerID> containerIDSet = new HashSet<>();\n+    containerIDSet.add(containerOne.containerID());\n+\n+    containerStateManager.loadContainer(containerOne);\n+    // Container loaded, no replicas reported from DNs. Expect zeros for\n+    // usage values.\n+    assertEquals(0L, containerOne.getUsedBytes());\n+    assertEquals(0L, containerOne.getNumberOfKeys());\n+\n+    reportHandler.onMessage(getContainerReportFromDatanode(\n+        containerOne.containerID(), replicaState,\n+        datanodeOne, 50L, 60L), publisher);\n+\n+    // Single replica reported - ensure values are updated\n+    assertEquals(50L, containerOne.getUsedBytes());\n+    assertEquals(60L, containerOne.getNumberOfKeys());\n+\n+    reportHandler.onMessage(getContainerReportFromDatanode(\n+        containerOne.containerID(), replicaState,\n+        datanodeTwo, 50L, 60L), publisher);\n+    reportHandler.onMessage(getContainerReportFromDatanode(\n+        containerOne.containerID(), replicaState,\n+        datanodeThree, 50L, 60L), publisher);\n+\n+    // All 3 DNs are reporting the same values. Counts should be as expected.\n+    assertEquals(50L, containerOne.getUsedBytes());\n+    assertEquals(60L, containerOne.getNumberOfKeys());\n+\n+    // Now each DN reports a different lesser value. Counts should be the max\n+    // reported.\n+    reportHandler.onMessage(getContainerReportFromDatanode(\n+        containerOne.containerID(), replicaState,\n+        datanodeOne, 1L, 10L), publisher);\n+    reportHandler.onMessage(getContainerReportFromDatanode(\n+        containerOne.containerID(), replicaState,\n+        datanodeTwo, 2L, 11L), publisher);\n+    reportHandler.onMessage(getContainerReportFromDatanode(\n+        containerOne.containerID(), replicaState,\n+        datanodeThree, 3L, 12L), publisher);\n+\n+    // All 3 DNs are reporting different values. The actual value should be the\n+    // maximum.\n+    assertEquals(3L, containerOne.getUsedBytes());\n+    assertEquals(12L, containerOne.getNumberOfKeys());\n+\n+    // Have the highest value report a lower value and ensure the new value\n+    // is the new maximumu\n+    reportHandler.onMessage(getContainerReportFromDatanode(\n+        containerOne.containerID(), replicaState,\n+        datanodeThree, 1L, 10L), publisher);\n+\n+    assertEquals(2L, containerOne.getUsedBytes());\n+    assertEquals(11L, containerOne.getNumberOfKeys());\n+  }\n+\n+  private ContainerReportFromDatanode getContainerReportFromDatanode(\n+      ContainerID containerId, ContainerReplicaProto.State state,\n+      DatanodeDetails dn, long bytesUsed, long keyCount) {\n+    ContainerReportsProto containerReport = getContainerReportsProto(\n+        containerId, state, dn.getUuidString(), bytesUsed, keyCount);\n+\n+    return new ContainerReportFromDatanode(dn, containerReport);\n+  }\n+\n   private static ContainerReportsProto getContainerReportsProto(\n       final ContainerID containerId, final ContainerReplicaProto.State state,\n       final String originNodeId) {\n+    return getContainerReportsProto(containerId, state, originNodeId,\n+        100000000L, 2000000000L);", "originalCommit": "2870dc6841090d9706f080391841fa1fdd6cddd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU0ODcwNQ==", "url": "https://github.com/apache/ozone/pull/1339#discussion_r475548705", "bodyText": "Ooops. That was not an intentional change. I will fix that just to keep things consistent with how they were before.", "author": "sodonnel", "createdAt": "2020-08-24T12:00:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUzMTM0Nw=="}], "type": "inlineReview"}, {"oid": "67e1cb2f80ed13a2de9acdb1a18b14cc17eda168", "url": "https://github.com/apache/ozone/commit/67e1cb2f80ed13a2de9acdb1a18b14cc17eda168", "message": "Fixed swapped values in test", "committedDate": "2020-08-24T12:03:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE5NjcxNA==", "url": "https://github.com/apache/ozone/pull/1339#discussion_r478196714", "bodyText": "Prefer to keep the KeyCount and UsedKeys persist action here.", "author": "ChenSammi", "createdAt": "2020-08-27T06:54:56Z", "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/container/SCMContainerManager.java", "diffHunk": "@@ -398,8 +398,6 @@ public void updateDeleteTransactionId(Map<Long, Long> deleteTransactionMap)\n               SCMException.ResultCodes.FAILED_TO_FIND_CONTAINER);\n         }\n         containerInfo.updateDeleteTransactionId(entry.getValue());\n-        containerInfo.setNumberOfKeys(containerInfoInMem.getNumberOfKeys());", "originalCommit": "67e1cb2f80ed13a2de9acdb1a18b14cc17eda168", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTAyNDM2Mg==", "url": "https://github.com/apache/ozone/pull/1339#discussion_r479024362", "bodyText": "After looking at this area a bit more I understand why that is needed now. I have added those two lines back in.", "author": "sodonnel", "createdAt": "2020-08-28T09:32:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE5NjcxNA=="}], "type": "inlineReview"}, {"oid": "0f4136c1c62e5353a343d1460cab1b978ed25826", "url": "https://github.com/apache/ozone/commit/0f4136c1c62e5353a343d1460cab1b978ed25826", "message": "Replace numberOfKeys and getUsedBytes in updateDeleteTransactionId", "committedDate": "2020-08-28T09:31:01Z", "type": "commit"}, {"oid": "ad0bebe2fdeb440b83f0298e44f4c89733e6e5f2", "url": "https://github.com/apache/ozone/commit/ad0bebe2fdeb440b83f0298e44f4c89733e6e5f2", "message": "Trigger build", "committedDate": "2020-08-28T14:12:30Z", "type": "commit"}]}