{"pr_number": 874, "pr_title": "HDDS-3493. Refactor Failures in MiniOzoneChaosCluster into pluggable model.", "pr_createdAt": "2020-04-27T18:11:13Z", "pr_url": "https://github.com/apache/ozone/pull/874", "timeline": [{"oid": "d5002b26a1e757387d4a308ae9ecb68fb4d0d0a6", "url": "https://github.com/apache/ozone/commit/d5002b26a1e757387d4a308ae9ecb68fb4d0d0a6", "message": "HDDS-3493. Refactor Failures in MiniOzoneChaosCluster into pluggable model.", "committedDate": "2020-04-29T14:55:35Z", "type": "commit"}, {"oid": "1c7c85ef3377716751a524d814252375d9da7654", "url": "https://github.com/apache/ozone/commit/1c7c85ef3377716751a524d814252375d9da7654", "message": "fix checkstyle", "committedDate": "2020-04-30T07:26:58Z", "type": "commit"}, {"oid": "1c7c85ef3377716751a524d814252375d9da7654", "url": "https://github.com/apache/ozone/commit/1c7c85ef3377716751a524d814252375d9da7654", "message": "fix checkstyle", "committedDate": "2020-04-30T07:26:58Z", "type": "forcePushed"}, {"oid": "be2ef962388f8d3cd50baadc23cd09b8b06bc853", "url": "https://github.com/apache/ozone/commit/be2ef962388f8d3cd50baadc23cd09b8b06bc853", "message": "fix unit tests", "committedDate": "2020-05-03T14:45:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3MTcxNQ==", "url": "https://github.com/apache/ozone/pull/874#discussion_r426571715", "bodyText": "Duplicate config setting.  Did you intend to set some other property?", "author": "adoroszlai", "createdAt": "2020-05-18T11:57:17Z", "path": "hadoop-ozone/fault-injection-test/mini-chaos-tests/src/test/java/org/apache/hadoop/ozone/MiniOzoneChaosCluster.java", "diffHunk": "@@ -358,6 +233,11 @@ protected void initializeConfiguration() throws IOException {\n       conf.setInt(\"hdds.scm.replication.event.timeout\", 20 * 1000);\n       conf.setInt(OzoneConfigKeys.DFS_RATIS_SNAPSHOT_THRESHOLD_KEY, 100);\n       conf.setInt(OzoneConfigKeys.DFS_CONTAINER_RATIS_LOG_PURGE_GAP, 100);\n+\n+      conf.setInt(OMConfigKeys.\n+              OZONE_OM_RATIS_SNAPSHOT_AUTO_TRIGGER_THRESHOLD_KEY, 100);\n+      conf.setInt(OMConfigKeys.\n+              OZONE_OM_RATIS_SNAPSHOT_AUTO_TRIGGER_THRESHOLD_KEY, 100);", "originalCommit": "be2ef962388f8d3cd50baadc23cd09b8b06bc853", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc5MTM4OQ==", "url": "https://github.com/apache/ozone/pull/874#discussion_r426791389", "bodyText": "yes, this was supposed to be purge gap.", "author": "mukul1987", "createdAt": "2020-05-18T17:40:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3MTcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3NDA3OQ==", "url": "https://github.com/apache/ozone/pull/874#discussion_r426574079", "bodyText": "This can add the same OM multiple times to the list.  Is that OK?", "author": "adoroszlai", "createdAt": "2020-05-18T12:01:40Z", "path": "hadoop-ozone/fault-injection-test/mini-chaos-tests/src/test/java/org/apache/hadoop/ozone/MiniOzoneChaosCluster.java", "diffHunk": "@@ -406,19 +280,71 @@ public MiniOzoneChaosCluster build() throws IOException {\n       final List<HddsDatanodeService> hddsDatanodes = createHddsDatanodes(\n           scm, null);\n \n-      MiniOzoneChaosCluster cluster;\n-      if (failureService == FailureService.DATANODE) {\n-        cluster = new MiniOzoneDatanodeChaosCluster(conf, omList, scm,\n-            hddsDatanodes, omServiceId);\n-      } else {\n-        cluster = new MiniOzoneOMChaosCluster(conf, omList, scm,\n-            hddsDatanodes, omServiceId);\n-      }\n+      MiniOzoneChaosCluster cluster =\n+          new MiniOzoneChaosCluster(conf, omList, scm, hddsDatanodes,\n+              omServiceId, clazzes);\n \n       if (startDataNodes) {\n         cluster.startHddsDatanodes();\n       }\n       return cluster;\n     }\n   }\n+\n+  // OzoneManager specifc\n+  public List<OzoneManager> omToFail() {\n+    int numNodesToFail = FailureManager.getNumberOfOmToFail();\n+    if (failedOmSet.size() >= numOzoneManagers/2) {\n+      return Collections.emptyList();\n+    }\n+\n+    int numOms = getOzoneManagersList().size();\n+    List<OzoneManager> oms = new ArrayList<>(numNodesToFail);\n+    for (int i = 0; i < numNodesToFail; i++) {\n+      int failedNodeIndex = FailureManager.getBoundedRandomIndex(numOms);\n+      oms.add(getOzoneManager(failedNodeIndex));", "originalCommit": "be2ef962388f8d3cd50baadc23cd09b8b06bc853", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc5MTQ5NQ==", "url": "https://github.com/apache/ozone/pull/874#discussion_r426791495", "bodyText": "Coverted into hashset.", "author": "mukul1987", "createdAt": "2020-05-18T17:40:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3NDA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgxMDgyMQ==", "url": "https://github.com/apache/ozone/pull/874#discussion_r426810821", "bodyText": "There are two concerns with adding same node multiple times:\n\ntrying to fail the same nodes multiple times\nnot failing the required number of nodes\n\nI think using a set addresses the first item, but not the second one.  This could be fixed by generating a random combination of the required size instead of generating multiple independent random indexes.\nI guess that's OK to address in a followup, because this was broken previously, too.", "author": "adoroszlai", "createdAt": "2020-05-18T18:17:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3NDA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3NTIzOQ==", "url": "https://github.com/apache/ozone/pull/874#discussion_r426575239", "bodyText": "Do we need these overrides?", "author": "adoroszlai", "createdAt": "2020-05-18T12:04:02Z", "path": "hadoop-ozone/fault-injection-test/mini-chaos-tests/src/test/java/org/apache/hadoop/ozone/MiniOzoneChaosCluster.java", "diffHunk": "@@ -406,19 +280,71 @@ public MiniOzoneChaosCluster build() throws IOException {\n       final List<HddsDatanodeService> hddsDatanodes = createHddsDatanodes(\n           scm, null);\n \n-      MiniOzoneChaosCluster cluster;\n-      if (failureService == FailureService.DATANODE) {\n-        cluster = new MiniOzoneDatanodeChaosCluster(conf, omList, scm,\n-            hddsDatanodes, omServiceId);\n-      } else {\n-        cluster = new MiniOzoneOMChaosCluster(conf, omList, scm,\n-            hddsDatanodes, omServiceId);\n-      }\n+      MiniOzoneChaosCluster cluster =\n+          new MiniOzoneChaosCluster(conf, omList, scm, hddsDatanodes,\n+              omServiceId, clazzes);\n \n       if (startDataNodes) {\n         cluster.startHddsDatanodes();\n       }\n       return cluster;\n     }\n   }\n+\n+  // OzoneManager specifc\n+  public List<OzoneManager> omToFail() {\n+    int numNodesToFail = FailureManager.getNumberOfOmToFail();\n+    if (failedOmSet.size() >= numOzoneManagers/2) {\n+      return Collections.emptyList();\n+    }\n+\n+    int numOms = getOzoneManagersList().size();\n+    List<OzoneManager> oms = new ArrayList<>(numNodesToFail);\n+    for (int i = 0; i < numNodesToFail; i++) {\n+      int failedNodeIndex = FailureManager.getBoundedRandomIndex(numOms);\n+      oms.add(getOzoneManager(failedNodeIndex));\n+    }\n+    return oms;\n+  }\n+\n+  public void shutdownOzoneManager(OzoneManager om) {\n+    super.shutdownOzoneManager(om);\n+    failedOmSet.add(om);\n+  }\n+\n+  public void restartOzoneManager(OzoneManager om, boolean waitForOM)\n+      throws IOException, TimeoutException, InterruptedException {\n+    super.restartOzoneManager(om, waitForOM);\n+    failedOmSet.remove(om);\n+  }\n+\n+  // Should the selected node be stopped or started.\n+  public boolean shouldStop() {\n+    if (failedOmSet.size() >= numOzoneManagers/2) {\n+      return false;\n+    }\n+    return RandomUtils.nextBoolean();\n+  }\n+\n+  public List<DatanodeDetails> dnToFail() {\n+    int numNodesToFail = FailureManager.getNumberOfDnToFail();\n+    int numDns = getHddsDatanodes().size();\n+    List<DatanodeDetails> dns = new ArrayList<>(numNodesToFail);\n+    for (int i = 0; i < numNodesToFail; i++) {\n+      int failedNodeIndex = FailureManager.getBoundedRandomIndex(numDns);\n+      dns.add(getHddsDatanodes().get(failedNodeIndex).getDatanodeDetails());\n+    }\n+    return dns;\n+  }\n+  \n+  @Override\n+  public void restartHddsDatanode(DatanodeDetails dn, boolean waitForDatanode)\n+      throws InterruptedException, TimeoutException, IOException {\n+    super.restartHddsDatanode(dn, waitForDatanode);\n+  }\n+\n+  @Override\n+  public void shutdownHddsDatanode(int i) {\n+    super.shutdownHddsDatanode(i);\n+  }", "originalCommit": "be2ef962388f8d3cd50baadc23cd09b8b06bc853", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgyMTMxNQ==", "url": "https://github.com/apache/ozone/pull/874#discussion_r426821315", "bodyText": "Yes, they are getting this used now.", "author": "mukul1987", "createdAt": "2020-05-18T18:37:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3NTIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3NzA3OQ==", "url": "https://github.com/apache/ozone/pull/874#discussion_r426577079", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void waitForClusterToBeReady()\n          \n          \n            \n              @Override\n          \n          \n            \n              public void waitForClusterToBeReady()", "author": "adoroszlai", "createdAt": "2020-05-18T12:07:36Z", "path": "hadoop-ozone/fault-injection-test/mini-chaos-tests/src/test/java/org/apache/hadoop/ozone/MiniOzoneChaosCluster.java", "diffHunk": "@@ -264,12 +121,30 @@ public void shutdown() {\n     }\n   }\n \n+  /**\n+   * Check if cluster is ready for a restart or shutdown of an OM node. If\n+   * yes, then set isClusterReady to false so that another thread cannot\n+   * restart/ shutdown OM till all OMs are up again.\n+   */\n+  public void waitForClusterToBeReady()", "originalCommit": "be2ef962388f8d3cd50baadc23cd09b8b06bc853", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5NzgzMw==", "url": "https://github.com/apache/ozone/pull/874#discussion_r426697833", "bodyText": "Nit: fail seems to be an overloaded term here (refers to both managed failure and unexpected failure while trying to induce failure).", "author": "adoroszlai", "createdAt": "2020-05-18T15:10:09Z", "path": "hadoop-ozone/fault-injection-test/mini-chaos-tests/src/test/java/org/apache/hadoop/ozone/failure/FailureManager.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.failure;\n+\n+import org.apache.commons.lang3.RandomUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.ozone.MiniOzoneChaosCluster;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Manages all the failures in the MiniOzoneChaosCluster.\n+ */\n+public class FailureManager {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(Failures.class);\n+\n+  private final MiniOzoneChaosCluster cluster;\n+  private final List<Failures> failures;\n+  private ScheduledFuture scheduledFuture;\n+  private final ScheduledExecutorService executorService;\n+  public FailureManager(MiniOzoneChaosCluster cluster,\n+                        Configuration conf,\n+                        List<Class<? extends Failures>> clazzes) {\n+    this.cluster = cluster;\n+    this.executorService = Executors.newSingleThreadScheduledExecutor();\n+\n+    failures = new ArrayList<>();\n+    for (Class<? extends Failures> clazz : clazzes) {\n+      Failures f = ReflectionUtils.newInstance(clazz, conf);\n+      f.validateFailure(cluster.getOzoneManagersList(),\n+          cluster.getStorageContainerManager(),\n+          cluster.getHddsDatanodes());\n+      failures.add(f);\n+    }\n+\n+  }\n+\n+\n+  // Fail nodes randomly at configured timeout period.\n+  private void fail() {\n+    try {\n+      Failures f = failures.get(getBoundedRandomIndex(failures.size()));\n+      LOG.info(\"time failure with {}\", f.getName());\n+      f.fail(cluster);\n+    } catch (Throwable t) {\n+      LOG.info(\"failing with \", t);", "originalCommit": "be2ef962388f8d3cd50baadc23cd09b8b06bc853", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwNzk4Mg==", "url": "https://github.com/apache/ozone/pull/874#discussion_r426807982", "bodyText": "changed the logging here.", "author": "mukul1987", "createdAt": "2020-05-18T18:11:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5NzgzMw=="}], "type": "inlineReview"}, {"oid": "b1899005caf8ceda7238ec2d1800bde61772b458", "url": "https://github.com/apache/ozone/commit/b1899005caf8ceda7238ec2d1800bde61772b458", "message": "address review comments", "committedDate": "2020-05-18T18:43:43Z", "type": "commit"}]}