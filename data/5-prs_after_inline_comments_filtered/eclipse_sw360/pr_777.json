{"pr_number": 777, "pr_title": "feat(REST): Trigger FOSSology process and check status.", "pr_createdAt": "2020-02-13T12:55:57Z", "pr_url": "https://github.com/eclipse/sw360/pull/777", "timeline": [{"oid": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef", "url": "https://github.com/eclipse/sw360/commit/628bb7fc20b0ad95a37acad2a3125cbf7ec589ef", "message": "feat(REST): Trigger FOSSology process and check status.\n\nSigned-off-by: Jaideep Palit <jaideep.palit@siemens.com>", "committedDate": "2020-02-27T14:28:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzNzE1NA==", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r386337154", "bodyText": "Kindly remove the extra blank line here.", "author": "smrutis1", "createdAt": "2020-03-02T11:24:38Z", "path": "backend/src/src-fossology/src/main/java/org/eclipse/sw360/fossology/FossologyHandler.java", "diffHunk": "@@ -31,11 +31,13 @@\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Component;\n \n+", "originalCommit": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgzMTU4Mg==", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r386831582", "bodyText": "status code -1 for failure right? I am wondering if it is significant here.", "author": "smrutis1", "createdAt": "2020-03-03T07:07:31Z", "path": "backend/src/src-fossology/src/main/java/org/eclipse/sw360/fossology/FossologyHandler.java", "diffHunk": "@@ -375,8 +382,8 @@ private void handleScanStep(Iface componentClient, Release release, User user,\n         case IN_WORK:\n             // query state\n             int scanningJobId = Integer.valueOf(furthestStep.getProcessStepIdInTool());\n-            int status = fossologyRestClient.checkScanStatus(scanningJobId);\n-            if (status > 0) {\n+            int status = scanStatusCode(fossologyRestClient.checkScanStatus(scanningJobId));\n+            if (status > 0 || status == -1) {", "originalCommit": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg1NDczMg==", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r388854732", "bodyText": "If scan is successful , it saves the result.\nBut if scan is failed ,it doesn't saves the result and goes in a loop to check status again which will be -1.", "author": "JaideepPalit", "createdAt": "2020-03-06T11:34:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgzMTU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA3NDMxNg==", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r388074316", "bodyText": "Please add a null check for release.getAttachments() and may be rename the method name as it is returning the attachmentid along with validation.", "author": "smrutis1", "createdAt": "2020-03-05T04:36:40Z", "path": "rest/resource-server/src/main/java/org/eclipse/sw360/rest/resourceserver/release/ReleaseController.java", "diffHunk": "@@ -270,12 +298,314 @@ public void downloadAttachmentFromRelease(\n         attachmentService.downloadAttachmentWithContext(release, attachmentId, response, sw360User);\n     }\n \n+    @RequestMapping(value = RELEASES_URL + \"/{id}/checkFossologyProcessStatus\", method = RequestMethod.GET)\n+    public ResponseEntity<Map<String, Object>> checkFossologyProcessStatus(\n+            @PathVariable(\"id\") String releaseId) throws TException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        Map<String, Object> responseMap = new HashMap<>();\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        if (lock != null && lock.isLocked()) {\n+            responseMap.put(\"status\", RequestStatus.PROCESSING);\n+        } else if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" is complete.\");\n+            responseMap.put(\"status\", RequestStatus.SUCCESS);\n+        } else {\n+            responseMap.put(\"status\", RequestStatus.FAILURE);\n+        }\n+        responseMap.put(\"fossologyProcessInfo\", fossologyProcess);\n+        return new ResponseEntity<>(responseMap, HttpStatus.OK);\n+    }\n+\n+    @RequestMapping(value = RELEASES_URL + \"/{id}/triggerFossologyProcess\", method = RequestMethod.GET)\n+    public ResponseEntity<HalResource> triggerFossologyProcess(@PathVariable(\"id\") String releaseId,\n+            @RequestParam(value = \"markFossologyProcessOutdated\", required = false) boolean markFossologyProcessOutdated,\n+            HttpServletResponse response) throws TException, IOException {\n+        releaseService.checkFossologyConnection();\n+\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        Map<String, String> responseMap = new HashMap<>();\n+        HttpStatus status = null;\n+        if (lock == null || !lock.isLocked()) {\n+            if (mapOfLocks.size() > 10) {\n+                responseMap.put(\"message\",\n+                        \"Max 10 FOSSology Process can be triggered simultaneously. Please try after sometime.\");\n+                status = HttpStatus.TOO_MANY_REQUESTS;\n+            } else {\n+                executeFossologyProcess(releaseId, markFossologyProcessOutdated);\n+                responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId + \" has been triggered.\");\n+                status = HttpStatus.OK;\n+            }\n+\n+        } else {\n+            status = HttpStatus.NOT_ACCEPTABLE;\n+            responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId\n+                    + \" is already running. Please wait till it is completed.\");\n+        }\n+        HalResource responseResource = new HalResource(responseMap);\n+        Link checkStatusLink = linkTo(ReleaseController.class)\n+                .slash(\"api/releases/\" + releaseId + \"/checkFossologyProcessStatus\").withSelfRel();\n+        responseResource.add(checkStatusLink);\n+\n+        return new ResponseEntity<HalResource>(responseResource, status);\n+    }\n+\n     @Override\n     public RepositoryLinksResource process(RepositoryLinksResource resource) {\n         resource.add(linkTo(ReleaseController.class).slash(\"api\" + RELEASES_URL).withRel(\"releases\"));\n         return resource;\n     }\n \n+    private void executeFossologyProcess(String releaseId, boolean markFossologyProcessOutdated)\n+            throws TException, IOException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        String attachmentId = validateNumberOfSrcAttached(releaseId, user);\n+\n+        if (markFossologyProcessOutdated) {\n+            log.info(\"Marking FOSSology process outdated for Release : \" + releaseId);\n+            releaseService.markFossologyProcessOutdated(releaseId, user);\n+        }\n+\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" already completed.\");\n+            return;\n+        }\n+\n+        final ExternalToolProcess fossologyProcessFinal = fossologyProcess;\n+\n+        Runnable asyncRunnable = () -> wrapTException(() -> {\n+            ReentrantLock lockObj = locks.apply(releaseId);\n+            ScheduledExecutorService service = null;\n+\n+            try {\n+                if (lockObj.tryLock()) {\n+                    service = Executors.newSingleThreadScheduledExecutor();\n+                    triggerUploadScanAndReportStep(service, fossologyProcessFinal, release, user, attachmentId);\n+                }\n+            } catch (Exception exp) {\n+                log.error(String.format(\"Release : %s .Error occured while triggering Fossology Process . %s\",\n+                        new Object[] { releaseId, exp.getMessage() }));\n+            } finally {\n+                log.info(\"Release : \" + releaseId + \" .Fossology Process exited, removing lock.\");\n+                if (service != null)\n+                    service.shutdownNow();\n+                if (lockObj.isLocked())\n+                    lockObj.unlock();\n+                mapOfLocks.remove(releaseId);\n+            }\n+        });\n+\n+        Thread asyncThread = new Thread(asyncRunnable);\n+        asyncThread.start();\n+    }\n+\n+    private String validateNumberOfSrcAttached(String releaseId, User user) throws TException {\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        List<Attachment> listOfSources = release.getAttachments().parallelStream()", "originalCommit": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5MDI4Mw==", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r388090283", "bodyText": "Kindly consider moving it to the service class.", "author": "smrutis1", "createdAt": "2020-03-05T05:52:46Z", "path": "rest/resource-server/src/main/java/org/eclipse/sw360/rest/resourceserver/release/ReleaseController.java", "diffHunk": "@@ -270,12 +298,314 @@ public void downloadAttachmentFromRelease(\n         attachmentService.downloadAttachmentWithContext(release, attachmentId, response, sw360User);\n     }\n \n+    @RequestMapping(value = RELEASES_URL + \"/{id}/checkFossologyProcessStatus\", method = RequestMethod.GET)\n+    public ResponseEntity<Map<String, Object>> checkFossologyProcessStatus(\n+            @PathVariable(\"id\") String releaseId) throws TException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        Map<String, Object> responseMap = new HashMap<>();\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        if (lock != null && lock.isLocked()) {\n+            responseMap.put(\"status\", RequestStatus.PROCESSING);\n+        } else if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" is complete.\");\n+            responseMap.put(\"status\", RequestStatus.SUCCESS);\n+        } else {\n+            responseMap.put(\"status\", RequestStatus.FAILURE);\n+        }\n+        responseMap.put(\"fossologyProcessInfo\", fossologyProcess);\n+        return new ResponseEntity<>(responseMap, HttpStatus.OK);\n+    }\n+\n+    @RequestMapping(value = RELEASES_URL + \"/{id}/triggerFossologyProcess\", method = RequestMethod.GET)\n+    public ResponseEntity<HalResource> triggerFossologyProcess(@PathVariable(\"id\") String releaseId,\n+            @RequestParam(value = \"markFossologyProcessOutdated\", required = false) boolean markFossologyProcessOutdated,\n+            HttpServletResponse response) throws TException, IOException {\n+        releaseService.checkFossologyConnection();\n+\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        Map<String, String> responseMap = new HashMap<>();\n+        HttpStatus status = null;\n+        if (lock == null || !lock.isLocked()) {\n+            if (mapOfLocks.size() > 10) {\n+                responseMap.put(\"message\",\n+                        \"Max 10 FOSSology Process can be triggered simultaneously. Please try after sometime.\");\n+                status = HttpStatus.TOO_MANY_REQUESTS;\n+            } else {\n+                executeFossologyProcess(releaseId, markFossologyProcessOutdated);\n+                responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId + \" has been triggered.\");\n+                status = HttpStatus.OK;\n+            }\n+\n+        } else {\n+            status = HttpStatus.NOT_ACCEPTABLE;\n+            responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId\n+                    + \" is already running. Please wait till it is completed.\");\n+        }\n+        HalResource responseResource = new HalResource(responseMap);\n+        Link checkStatusLink = linkTo(ReleaseController.class)\n+                .slash(\"api/releases/\" + releaseId + \"/checkFossologyProcessStatus\").withSelfRel();\n+        responseResource.add(checkStatusLink);\n+\n+        return new ResponseEntity<HalResource>(responseResource, status);\n+    }\n+\n     @Override\n     public RepositoryLinksResource process(RepositoryLinksResource resource) {\n         resource.add(linkTo(ReleaseController.class).slash(\"api\" + RELEASES_URL).withRel(\"releases\"));\n         return resource;\n     }\n \n+    private void executeFossologyProcess(String releaseId, boolean markFossologyProcessOutdated)", "originalCommit": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5MTk2NA==", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r388091964", "bodyText": "Kindly consider extracting the size calculation of attachments to a method .", "author": "smrutis1", "createdAt": "2020-03-05T05:59:32Z", "path": "rest/resource-server/src/main/java/org/eclipse/sw360/rest/resourceserver/release/ReleaseController.java", "diffHunk": "@@ -270,12 +298,314 @@ public void downloadAttachmentFromRelease(\n         attachmentService.downloadAttachmentWithContext(release, attachmentId, response, sw360User);\n     }\n \n+    @RequestMapping(value = RELEASES_URL + \"/{id}/checkFossologyProcessStatus\", method = RequestMethod.GET)\n+    public ResponseEntity<Map<String, Object>> checkFossologyProcessStatus(\n+            @PathVariable(\"id\") String releaseId) throws TException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        Map<String, Object> responseMap = new HashMap<>();\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        if (lock != null && lock.isLocked()) {\n+            responseMap.put(\"status\", RequestStatus.PROCESSING);\n+        } else if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" is complete.\");\n+            responseMap.put(\"status\", RequestStatus.SUCCESS);\n+        } else {\n+            responseMap.put(\"status\", RequestStatus.FAILURE);\n+        }\n+        responseMap.put(\"fossologyProcessInfo\", fossologyProcess);\n+        return new ResponseEntity<>(responseMap, HttpStatus.OK);\n+    }\n+\n+    @RequestMapping(value = RELEASES_URL + \"/{id}/triggerFossologyProcess\", method = RequestMethod.GET)\n+    public ResponseEntity<HalResource> triggerFossologyProcess(@PathVariable(\"id\") String releaseId,\n+            @RequestParam(value = \"markFossologyProcessOutdated\", required = false) boolean markFossologyProcessOutdated,\n+            HttpServletResponse response) throws TException, IOException {\n+        releaseService.checkFossologyConnection();\n+\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        Map<String, String> responseMap = new HashMap<>();\n+        HttpStatus status = null;\n+        if (lock == null || !lock.isLocked()) {\n+            if (mapOfLocks.size() > 10) {\n+                responseMap.put(\"message\",\n+                        \"Max 10 FOSSology Process can be triggered simultaneously. Please try after sometime.\");\n+                status = HttpStatus.TOO_MANY_REQUESTS;\n+            } else {\n+                executeFossologyProcess(releaseId, markFossologyProcessOutdated);\n+                responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId + \" has been triggered.\");\n+                status = HttpStatus.OK;\n+            }\n+\n+        } else {\n+            status = HttpStatus.NOT_ACCEPTABLE;\n+            responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId\n+                    + \" is already running. Please wait till it is completed.\");\n+        }\n+        HalResource responseResource = new HalResource(responseMap);\n+        Link checkStatusLink = linkTo(ReleaseController.class)\n+                .slash(\"api/releases/\" + releaseId + \"/checkFossologyProcessStatus\").withSelfRel();\n+        responseResource.add(checkStatusLink);\n+\n+        return new ResponseEntity<HalResource>(responseResource, status);\n+    }\n+\n     @Override\n     public RepositoryLinksResource process(RepositoryLinksResource resource) {\n         resource.add(linkTo(ReleaseController.class).slash(\"api\" + RELEASES_URL).withRel(\"releases\"));\n         return resource;\n     }\n \n+    private void executeFossologyProcess(String releaseId, boolean markFossologyProcessOutdated)\n+            throws TException, IOException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        String attachmentId = validateNumberOfSrcAttached(releaseId, user);\n+\n+        if (markFossologyProcessOutdated) {\n+            log.info(\"Marking FOSSology process outdated for Release : \" + releaseId);\n+            releaseService.markFossologyProcessOutdated(releaseId, user);\n+        }\n+\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" already completed.\");\n+            return;\n+        }\n+\n+        final ExternalToolProcess fossologyProcessFinal = fossologyProcess;\n+\n+        Runnable asyncRunnable = () -> wrapTException(() -> {\n+            ReentrantLock lockObj = locks.apply(releaseId);\n+            ScheduledExecutorService service = null;\n+\n+            try {\n+                if (lockObj.tryLock()) {\n+                    service = Executors.newSingleThreadScheduledExecutor();\n+                    triggerUploadScanAndReportStep(service, fossologyProcessFinal, release, user, attachmentId);\n+                }\n+            } catch (Exception exp) {\n+                log.error(String.format(\"Release : %s .Error occured while triggering Fossology Process . %s\",\n+                        new Object[] { releaseId, exp.getMessage() }));\n+            } finally {\n+                log.info(\"Release : \" + releaseId + \" .Fossology Process exited, removing lock.\");\n+                if (service != null)\n+                    service.shutdownNow();\n+                if (lockObj.isLocked())\n+                    lockObj.unlock();\n+                mapOfLocks.remove(releaseId);\n+            }\n+        });\n+\n+        Thread asyncThread = new Thread(asyncRunnable);\n+        asyncThread.start();\n+    }\n+\n+    private String validateNumberOfSrcAttached(String releaseId, User user) throws TException {\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        List<Attachment> listOfSources = release.getAttachments().parallelStream()\n+                .filter(attachment -> attachment.getAttachmentType() == AttachmentType.SOURCE)\n+                .collect(Collectors.toList());\n+        int noOfSrcAttached = listOfSources.size();\n+\n+        if (noOfSrcAttached != 1) {\n+            throw new HttpMessageNotReadableException(\"There has to be exactly one source attachment, but there are \"\n+                    + noOfSrcAttached + \" at this release. Please come back once you corrected that.\");\n+        }\n+\n+        return listOfSources.get(0).getAttachmentContentId();\n+    }\n+\n+    private void triggerUploadScanAndReportStep(final ScheduledExecutorService service,\n+            final ExternalToolProcess fossologyProcess, final Release release, final User user,\n+            final String attachmentId) throws TException {\n+\n+        int scanStatusCheckCount = 0, scanTriggerRetriesCount = 0, reportGenerateTriggerRetries = 0,\n+                reportGeneratestatusCheckCount = 0,maxRetries=15;\n+        ScheduledFuture<ExternalToolProcess> future = null;\n+        String releaseId = release.getId();\n+        ExternalToolProcess fossologyProcessLocal = fossologyProcess;\n+        byte[] byteArray = new byte[0];", "originalCommit": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5MjM3OQ==", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r388092379", "bodyText": "Please remove the unused variable scanCheckCount", "author": "smrutis1", "createdAt": "2020-03-05T06:01:15Z", "path": "rest/resource-server/src/main/java/org/eclipse/sw360/rest/resourceserver/release/ReleaseController.java", "diffHunk": "@@ -270,12 +298,314 @@ public void downloadAttachmentFromRelease(\n         attachmentService.downloadAttachmentWithContext(release, attachmentId, response, sw360User);\n     }\n \n+    @RequestMapping(value = RELEASES_URL + \"/{id}/checkFossologyProcessStatus\", method = RequestMethod.GET)\n+    public ResponseEntity<Map<String, Object>> checkFossologyProcessStatus(\n+            @PathVariable(\"id\") String releaseId) throws TException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        Map<String, Object> responseMap = new HashMap<>();\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        if (lock != null && lock.isLocked()) {\n+            responseMap.put(\"status\", RequestStatus.PROCESSING);\n+        } else if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" is complete.\");\n+            responseMap.put(\"status\", RequestStatus.SUCCESS);\n+        } else {\n+            responseMap.put(\"status\", RequestStatus.FAILURE);\n+        }\n+        responseMap.put(\"fossologyProcessInfo\", fossologyProcess);\n+        return new ResponseEntity<>(responseMap, HttpStatus.OK);\n+    }\n+\n+    @RequestMapping(value = RELEASES_URL + \"/{id}/triggerFossologyProcess\", method = RequestMethod.GET)\n+    public ResponseEntity<HalResource> triggerFossologyProcess(@PathVariable(\"id\") String releaseId,\n+            @RequestParam(value = \"markFossologyProcessOutdated\", required = false) boolean markFossologyProcessOutdated,\n+            HttpServletResponse response) throws TException, IOException {\n+        releaseService.checkFossologyConnection();\n+\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        Map<String, String> responseMap = new HashMap<>();\n+        HttpStatus status = null;\n+        if (lock == null || !lock.isLocked()) {\n+            if (mapOfLocks.size() > 10) {\n+                responseMap.put(\"message\",\n+                        \"Max 10 FOSSology Process can be triggered simultaneously. Please try after sometime.\");\n+                status = HttpStatus.TOO_MANY_REQUESTS;\n+            } else {\n+                executeFossologyProcess(releaseId, markFossologyProcessOutdated);\n+                responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId + \" has been triggered.\");\n+                status = HttpStatus.OK;\n+            }\n+\n+        } else {\n+            status = HttpStatus.NOT_ACCEPTABLE;\n+            responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId\n+                    + \" is already running. Please wait till it is completed.\");\n+        }\n+        HalResource responseResource = new HalResource(responseMap);\n+        Link checkStatusLink = linkTo(ReleaseController.class)\n+                .slash(\"api/releases/\" + releaseId + \"/checkFossologyProcessStatus\").withSelfRel();\n+        responseResource.add(checkStatusLink);\n+\n+        return new ResponseEntity<HalResource>(responseResource, status);\n+    }\n+\n     @Override\n     public RepositoryLinksResource process(RepositoryLinksResource resource) {\n         resource.add(linkTo(ReleaseController.class).slash(\"api\" + RELEASES_URL).withRel(\"releases\"));\n         return resource;\n     }\n \n+    private void executeFossologyProcess(String releaseId, boolean markFossologyProcessOutdated)\n+            throws TException, IOException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        String attachmentId = validateNumberOfSrcAttached(releaseId, user);\n+\n+        if (markFossologyProcessOutdated) {\n+            log.info(\"Marking FOSSology process outdated for Release : \" + releaseId);\n+            releaseService.markFossologyProcessOutdated(releaseId, user);\n+        }\n+\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" already completed.\");\n+            return;\n+        }\n+\n+        final ExternalToolProcess fossologyProcessFinal = fossologyProcess;\n+\n+        Runnable asyncRunnable = () -> wrapTException(() -> {\n+            ReentrantLock lockObj = locks.apply(releaseId);\n+            ScheduledExecutorService service = null;\n+\n+            try {\n+                if (lockObj.tryLock()) {\n+                    service = Executors.newSingleThreadScheduledExecutor();\n+                    triggerUploadScanAndReportStep(service, fossologyProcessFinal, release, user, attachmentId);\n+                }\n+            } catch (Exception exp) {\n+                log.error(String.format(\"Release : %s .Error occured while triggering Fossology Process . %s\",\n+                        new Object[] { releaseId, exp.getMessage() }));\n+            } finally {\n+                log.info(\"Release : \" + releaseId + \" .Fossology Process exited, removing lock.\");\n+                if (service != null)\n+                    service.shutdownNow();\n+                if (lockObj.isLocked())\n+                    lockObj.unlock();\n+                mapOfLocks.remove(releaseId);\n+            }\n+        });\n+\n+        Thread asyncThread = new Thread(asyncRunnable);\n+        asyncThread.start();\n+    }\n+\n+    private String validateNumberOfSrcAttached(String releaseId, User user) throws TException {\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        List<Attachment> listOfSources = release.getAttachments().parallelStream()\n+                .filter(attachment -> attachment.getAttachmentType() == AttachmentType.SOURCE)\n+                .collect(Collectors.toList());\n+        int noOfSrcAttached = listOfSources.size();\n+\n+        if (noOfSrcAttached != 1) {\n+            throw new HttpMessageNotReadableException(\"There has to be exactly one source attachment, but there are \"\n+                    + noOfSrcAttached + \" at this release. Please come back once you corrected that.\");\n+        }\n+\n+        return listOfSources.get(0).getAttachmentContentId();\n+    }\n+\n+    private void triggerUploadScanAndReportStep(final ScheduledExecutorService service,\n+            final ExternalToolProcess fossologyProcess, final Release release, final User user,\n+            final String attachmentId) throws TException {\n+\n+        int scanStatusCheckCount = 0, scanTriggerRetriesCount = 0, reportGenerateTriggerRetries = 0,", "originalCommit": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5MzI0NQ==", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r388093245", "bodyText": "please remove this unnecessary assignment.", "author": "smrutis1", "createdAt": "2020-03-05T06:04:54Z", "path": "rest/resource-server/src/main/java/org/eclipse/sw360/rest/resourceserver/release/ReleaseController.java", "diffHunk": "@@ -270,12 +298,314 @@ public void downloadAttachmentFromRelease(\n         attachmentService.downloadAttachmentWithContext(release, attachmentId, response, sw360User);\n     }\n \n+    @RequestMapping(value = RELEASES_URL + \"/{id}/checkFossologyProcessStatus\", method = RequestMethod.GET)\n+    public ResponseEntity<Map<String, Object>> checkFossologyProcessStatus(\n+            @PathVariable(\"id\") String releaseId) throws TException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        Map<String, Object> responseMap = new HashMap<>();\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        if (lock != null && lock.isLocked()) {\n+            responseMap.put(\"status\", RequestStatus.PROCESSING);\n+        } else if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" is complete.\");\n+            responseMap.put(\"status\", RequestStatus.SUCCESS);\n+        } else {\n+            responseMap.put(\"status\", RequestStatus.FAILURE);\n+        }\n+        responseMap.put(\"fossologyProcessInfo\", fossologyProcess);\n+        return new ResponseEntity<>(responseMap, HttpStatus.OK);\n+    }\n+\n+    @RequestMapping(value = RELEASES_URL + \"/{id}/triggerFossologyProcess\", method = RequestMethod.GET)\n+    public ResponseEntity<HalResource> triggerFossologyProcess(@PathVariable(\"id\") String releaseId,\n+            @RequestParam(value = \"markFossologyProcessOutdated\", required = false) boolean markFossologyProcessOutdated,\n+            HttpServletResponse response) throws TException, IOException {\n+        releaseService.checkFossologyConnection();\n+\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        Map<String, String> responseMap = new HashMap<>();\n+        HttpStatus status = null;\n+        if (lock == null || !lock.isLocked()) {\n+            if (mapOfLocks.size() > 10) {\n+                responseMap.put(\"message\",\n+                        \"Max 10 FOSSology Process can be triggered simultaneously. Please try after sometime.\");\n+                status = HttpStatus.TOO_MANY_REQUESTS;\n+            } else {\n+                executeFossologyProcess(releaseId, markFossologyProcessOutdated);\n+                responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId + \" has been triggered.\");\n+                status = HttpStatus.OK;\n+            }\n+\n+        } else {\n+            status = HttpStatus.NOT_ACCEPTABLE;\n+            responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId\n+                    + \" is already running. Please wait till it is completed.\");\n+        }\n+        HalResource responseResource = new HalResource(responseMap);\n+        Link checkStatusLink = linkTo(ReleaseController.class)\n+                .slash(\"api/releases/\" + releaseId + \"/checkFossologyProcessStatus\").withSelfRel();\n+        responseResource.add(checkStatusLink);\n+\n+        return new ResponseEntity<HalResource>(responseResource, status);\n+    }\n+\n     @Override\n     public RepositoryLinksResource process(RepositoryLinksResource resource) {\n         resource.add(linkTo(ReleaseController.class).slash(\"api\" + RELEASES_URL).withRel(\"releases\"));\n         return resource;\n     }\n \n+    private void executeFossologyProcess(String releaseId, boolean markFossologyProcessOutdated)\n+            throws TException, IOException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        String attachmentId = validateNumberOfSrcAttached(releaseId, user);\n+\n+        if (markFossologyProcessOutdated) {\n+            log.info(\"Marking FOSSology process outdated for Release : \" + releaseId);\n+            releaseService.markFossologyProcessOutdated(releaseId, user);\n+        }\n+\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" already completed.\");\n+            return;\n+        }\n+\n+        final ExternalToolProcess fossologyProcessFinal = fossologyProcess;\n+\n+        Runnable asyncRunnable = () -> wrapTException(() -> {\n+            ReentrantLock lockObj = locks.apply(releaseId);\n+            ScheduledExecutorService service = null;\n+\n+            try {\n+                if (lockObj.tryLock()) {\n+                    service = Executors.newSingleThreadScheduledExecutor();\n+                    triggerUploadScanAndReportStep(service, fossologyProcessFinal, release, user, attachmentId);\n+                }\n+            } catch (Exception exp) {\n+                log.error(String.format(\"Release : %s .Error occured while triggering Fossology Process . %s\",\n+                        new Object[] { releaseId, exp.getMessage() }));\n+            } finally {\n+                log.info(\"Release : \" + releaseId + \" .Fossology Process exited, removing lock.\");\n+                if (service != null)\n+                    service.shutdownNow();\n+                if (lockObj.isLocked())\n+                    lockObj.unlock();\n+                mapOfLocks.remove(releaseId);\n+            }\n+        });\n+\n+        Thread asyncThread = new Thread(asyncRunnable);\n+        asyncThread.start();\n+    }\n+\n+    private String validateNumberOfSrcAttached(String releaseId, User user) throws TException {\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        List<Attachment> listOfSources = release.getAttachments().parallelStream()\n+                .filter(attachment -> attachment.getAttachmentType() == AttachmentType.SOURCE)\n+                .collect(Collectors.toList());\n+        int noOfSrcAttached = listOfSources.size();\n+\n+        if (noOfSrcAttached != 1) {\n+            throw new HttpMessageNotReadableException(\"There has to be exactly one source attachment, but there are \"\n+                    + noOfSrcAttached + \" at this release. Please come back once you corrected that.\");\n+        }\n+\n+        return listOfSources.get(0).getAttachmentContentId();\n+    }\n+\n+    private void triggerUploadScanAndReportStep(final ScheduledExecutorService service,\n+            final ExternalToolProcess fossologyProcess, final Release release, final User user,\n+            final String attachmentId) throws TException {\n+\n+        int scanStatusCheckCount = 0, scanTriggerRetriesCount = 0, reportGenerateTriggerRetries = 0,\n+                reportGeneratestatusCheckCount = 0,maxRetries=15;\n+        ScheduledFuture<ExternalToolProcess> future = null;\n+        String releaseId = release.getId();\n+        ExternalToolProcess fossologyProcessLocal = fossologyProcess;", "originalCommit": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5NDc4NA==", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r388094784", "bodyText": "Please consider removing this assignment, if there is no significant.", "author": "smrutis1", "createdAt": "2020-03-05T06:11:24Z", "path": "rest/resource-server/src/main/java/org/eclipse/sw360/rest/resourceserver/release/ReleaseController.java", "diffHunk": "@@ -270,12 +298,314 @@ public void downloadAttachmentFromRelease(\n         attachmentService.downloadAttachmentWithContext(release, attachmentId, response, sw360User);\n     }\n \n+    @RequestMapping(value = RELEASES_URL + \"/{id}/checkFossologyProcessStatus\", method = RequestMethod.GET)\n+    public ResponseEntity<Map<String, Object>> checkFossologyProcessStatus(\n+            @PathVariable(\"id\") String releaseId) throws TException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        Map<String, Object> responseMap = new HashMap<>();\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        if (lock != null && lock.isLocked()) {\n+            responseMap.put(\"status\", RequestStatus.PROCESSING);\n+        } else if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" is complete.\");\n+            responseMap.put(\"status\", RequestStatus.SUCCESS);\n+        } else {\n+            responseMap.put(\"status\", RequestStatus.FAILURE);\n+        }\n+        responseMap.put(\"fossologyProcessInfo\", fossologyProcess);\n+        return new ResponseEntity<>(responseMap, HttpStatus.OK);\n+    }\n+\n+    @RequestMapping(value = RELEASES_URL + \"/{id}/triggerFossologyProcess\", method = RequestMethod.GET)\n+    public ResponseEntity<HalResource> triggerFossologyProcess(@PathVariable(\"id\") String releaseId,\n+            @RequestParam(value = \"markFossologyProcessOutdated\", required = false) boolean markFossologyProcessOutdated,\n+            HttpServletResponse response) throws TException, IOException {\n+        releaseService.checkFossologyConnection();\n+\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        Map<String, String> responseMap = new HashMap<>();\n+        HttpStatus status = null;\n+        if (lock == null || !lock.isLocked()) {\n+            if (mapOfLocks.size() > 10) {\n+                responseMap.put(\"message\",\n+                        \"Max 10 FOSSology Process can be triggered simultaneously. Please try after sometime.\");\n+                status = HttpStatus.TOO_MANY_REQUESTS;\n+            } else {\n+                executeFossologyProcess(releaseId, markFossologyProcessOutdated);\n+                responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId + \" has been triggered.\");\n+                status = HttpStatus.OK;\n+            }\n+\n+        } else {\n+            status = HttpStatus.NOT_ACCEPTABLE;\n+            responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId\n+                    + \" is already running. Please wait till it is completed.\");\n+        }\n+        HalResource responseResource = new HalResource(responseMap);\n+        Link checkStatusLink = linkTo(ReleaseController.class)\n+                .slash(\"api/releases/\" + releaseId + \"/checkFossologyProcessStatus\").withSelfRel();\n+        responseResource.add(checkStatusLink);\n+\n+        return new ResponseEntity<HalResource>(responseResource, status);\n+    }\n+\n     @Override\n     public RepositoryLinksResource process(RepositoryLinksResource resource) {\n         resource.add(linkTo(ReleaseController.class).slash(\"api\" + RELEASES_URL).withRel(\"releases\"));\n         return resource;\n     }\n \n+    private void executeFossologyProcess(String releaseId, boolean markFossologyProcessOutdated)\n+            throws TException, IOException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        String attachmentId = validateNumberOfSrcAttached(releaseId, user);\n+\n+        if (markFossologyProcessOutdated) {\n+            log.info(\"Marking FOSSology process outdated for Release : \" + releaseId);\n+            releaseService.markFossologyProcessOutdated(releaseId, user);\n+        }\n+\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" already completed.\");\n+            return;\n+        }\n+\n+        final ExternalToolProcess fossologyProcessFinal = fossologyProcess;", "originalCommit": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg1NzU4Mg==", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r388857582", "bodyText": "fossologyProcessFinal is used in lambda expression, which needs to be final or implicitly final.\nfossologyProcess cannot be used inside Lambda Exp as its value changes over the control flow.\nPlease suggest if this can be achieved by any other means.", "author": "JaideepPalit", "createdAt": "2020-03-06T11:41:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5NDc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEyMjUxNg==", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r388122516", "bodyText": "Please remove this unused import ExecutionException or it can be made as import java.util.concurrent.*", "author": "smrutis1", "createdAt": "2020-03-05T07:43:52Z", "path": "rest/resource-server/src/main/java/org/eclipse/sw360/rest/resourceserver/release/ReleaseController.java", "diffHunk": "@@ -39,21 +46,36 @@\n import org.springframework.http.HttpStatus;\n import org.springframework.http.MediaType;\n import org.springframework.http.ResponseEntity;\n+import org.springframework.http.converter.HttpMessageNotReadableException;\n import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.util.FileCopyUtils;\n import org.springframework.util.MultiValueMap;\n import org.springframework.web.bind.annotation.*;\n import org.springframework.web.multipart.MultipartFile;\n import org.springframework.web.servlet.support.ServletUriComponentsBuilder;\n \n import javax.servlet.http.HttpServletResponse;\n+\n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n+import java.io.InputStream;\n import java.net.URI;\n import java.net.URISyntaxException;\n import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;", "originalCommit": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEyNjE5MQ==", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r388126191", "bodyText": "May be we can use RELEASES_URL constants.", "author": "smrutis1", "createdAt": "2020-03-05T07:54:01Z", "path": "rest/resource-server/src/main/java/org/eclipse/sw360/rest/resourceserver/release/ReleaseController.java", "diffHunk": "@@ -270,12 +298,314 @@ public void downloadAttachmentFromRelease(\n         attachmentService.downloadAttachmentWithContext(release, attachmentId, response, sw360User);\n     }\n \n+    @RequestMapping(value = RELEASES_URL + \"/{id}/checkFossologyProcessStatus\", method = RequestMethod.GET)\n+    public ResponseEntity<Map<String, Object>> checkFossologyProcessStatus(\n+            @PathVariable(\"id\") String releaseId) throws TException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        Map<String, Object> responseMap = new HashMap<>();\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        if (lock != null && lock.isLocked()) {\n+            responseMap.put(\"status\", RequestStatus.PROCESSING);\n+        } else if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" is complete.\");\n+            responseMap.put(\"status\", RequestStatus.SUCCESS);\n+        } else {\n+            responseMap.put(\"status\", RequestStatus.FAILURE);\n+        }\n+        responseMap.put(\"fossologyProcessInfo\", fossologyProcess);\n+        return new ResponseEntity<>(responseMap, HttpStatus.OK);\n+    }\n+\n+    @RequestMapping(value = RELEASES_URL + \"/{id}/triggerFossologyProcess\", method = RequestMethod.GET)\n+    public ResponseEntity<HalResource> triggerFossologyProcess(@PathVariable(\"id\") String releaseId,\n+            @RequestParam(value = \"markFossologyProcessOutdated\", required = false) boolean markFossologyProcessOutdated,\n+            HttpServletResponse response) throws TException, IOException {\n+        releaseService.checkFossologyConnection();\n+\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        Map<String, String> responseMap = new HashMap<>();\n+        HttpStatus status = null;\n+        if (lock == null || !lock.isLocked()) {\n+            if (mapOfLocks.size() > 10) {\n+                responseMap.put(\"message\",\n+                        \"Max 10 FOSSology Process can be triggered simultaneously. Please try after sometime.\");\n+                status = HttpStatus.TOO_MANY_REQUESTS;\n+            } else {\n+                executeFossologyProcess(releaseId, markFossologyProcessOutdated);\n+                responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId + \" has been triggered.\");\n+                status = HttpStatus.OK;\n+            }\n+\n+        } else {\n+            status = HttpStatus.NOT_ACCEPTABLE;\n+            responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId\n+                    + \" is already running. Please wait till it is completed.\");\n+        }\n+        HalResource responseResource = new HalResource(responseMap);\n+        Link checkStatusLink = linkTo(ReleaseController.class)\n+                .slash(\"api/releases/\" + releaseId + \"/checkFossologyProcessStatus\").withSelfRel();", "originalCommit": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEzMjg0Mw==", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r388132843", "bodyText": "I think from 459-489 can be made extracted to a method and can be made generic.", "author": "smrutis1", "createdAt": "2020-03-05T08:10:48Z", "path": "rest/resource-server/src/main/java/org/eclipse/sw360/rest/resourceserver/release/ReleaseController.java", "diffHunk": "@@ -270,12 +298,314 @@ public void downloadAttachmentFromRelease(\n         attachmentService.downloadAttachmentWithContext(release, attachmentId, response, sw360User);\n     }\n \n+    @RequestMapping(value = RELEASES_URL + \"/{id}/checkFossologyProcessStatus\", method = RequestMethod.GET)\n+    public ResponseEntity<Map<String, Object>> checkFossologyProcessStatus(\n+            @PathVariable(\"id\") String releaseId) throws TException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        Map<String, Object> responseMap = new HashMap<>();\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        if (lock != null && lock.isLocked()) {\n+            responseMap.put(\"status\", RequestStatus.PROCESSING);\n+        } else if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" is complete.\");\n+            responseMap.put(\"status\", RequestStatus.SUCCESS);\n+        } else {\n+            responseMap.put(\"status\", RequestStatus.FAILURE);\n+        }\n+        responseMap.put(\"fossologyProcessInfo\", fossologyProcess);\n+        return new ResponseEntity<>(responseMap, HttpStatus.OK);\n+    }\n+\n+    @RequestMapping(value = RELEASES_URL + \"/{id}/triggerFossologyProcess\", method = RequestMethod.GET)\n+    public ResponseEntity<HalResource> triggerFossologyProcess(@PathVariable(\"id\") String releaseId,\n+            @RequestParam(value = \"markFossologyProcessOutdated\", required = false) boolean markFossologyProcessOutdated,\n+            HttpServletResponse response) throws TException, IOException {\n+        releaseService.checkFossologyConnection();\n+\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        Map<String, String> responseMap = new HashMap<>();\n+        HttpStatus status = null;\n+        if (lock == null || !lock.isLocked()) {\n+            if (mapOfLocks.size() > 10) {\n+                responseMap.put(\"message\",\n+                        \"Max 10 FOSSology Process can be triggered simultaneously. Please try after sometime.\");\n+                status = HttpStatus.TOO_MANY_REQUESTS;\n+            } else {\n+                executeFossologyProcess(releaseId, markFossologyProcessOutdated);\n+                responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId + \" has been triggered.\");\n+                status = HttpStatus.OK;\n+            }\n+\n+        } else {\n+            status = HttpStatus.NOT_ACCEPTABLE;\n+            responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId\n+                    + \" is already running. Please wait till it is completed.\");\n+        }\n+        HalResource responseResource = new HalResource(responseMap);\n+        Link checkStatusLink = linkTo(ReleaseController.class)\n+                .slash(\"api/releases/\" + releaseId + \"/checkFossologyProcessStatus\").withSelfRel();\n+        responseResource.add(checkStatusLink);\n+\n+        return new ResponseEntity<HalResource>(responseResource, status);\n+    }\n+\n     @Override\n     public RepositoryLinksResource process(RepositoryLinksResource resource) {\n         resource.add(linkTo(ReleaseController.class).slash(\"api\" + RELEASES_URL).withRel(\"releases\"));\n         return resource;\n     }\n \n+    private void executeFossologyProcess(String releaseId, boolean markFossologyProcessOutdated)\n+            throws TException, IOException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        String attachmentId = validateNumberOfSrcAttached(releaseId, user);\n+\n+        if (markFossologyProcessOutdated) {\n+            log.info(\"Marking FOSSology process outdated for Release : \" + releaseId);\n+            releaseService.markFossologyProcessOutdated(releaseId, user);\n+        }\n+\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" already completed.\");\n+            return;\n+        }\n+\n+        final ExternalToolProcess fossologyProcessFinal = fossologyProcess;\n+\n+        Runnable asyncRunnable = () -> wrapTException(() -> {\n+            ReentrantLock lockObj = locks.apply(releaseId);\n+            ScheduledExecutorService service = null;\n+\n+            try {\n+                if (lockObj.tryLock()) {\n+                    service = Executors.newSingleThreadScheduledExecutor();\n+                    triggerUploadScanAndReportStep(service, fossologyProcessFinal, release, user, attachmentId);\n+                }\n+            } catch (Exception exp) {\n+                log.error(String.format(\"Release : %s .Error occured while triggering Fossology Process . %s\",\n+                        new Object[] { releaseId, exp.getMessage() }));\n+            } finally {\n+                log.info(\"Release : \" + releaseId + \" .Fossology Process exited, removing lock.\");\n+                if (service != null)\n+                    service.shutdownNow();\n+                if (lockObj.isLocked())\n+                    lockObj.unlock();\n+                mapOfLocks.remove(releaseId);\n+            }\n+        });\n+\n+        Thread asyncThread = new Thread(asyncRunnable);\n+        asyncThread.start();\n+    }\n+\n+    private String validateNumberOfSrcAttached(String releaseId, User user) throws TException {\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        List<Attachment> listOfSources = release.getAttachments().parallelStream()\n+                .filter(attachment -> attachment.getAttachmentType() == AttachmentType.SOURCE)\n+                .collect(Collectors.toList());\n+        int noOfSrcAttached = listOfSources.size();\n+\n+        if (noOfSrcAttached != 1) {\n+            throw new HttpMessageNotReadableException(\"There has to be exactly one source attachment, but there are \"\n+                    + noOfSrcAttached + \" at this release. Please come back once you corrected that.\");\n+        }\n+\n+        return listOfSources.get(0).getAttachmentContentId();\n+    }\n+\n+    private void triggerUploadScanAndReportStep(final ScheduledExecutorService service,\n+            final ExternalToolProcess fossologyProcess, final Release release, final User user,\n+            final String attachmentId) throws TException {\n+\n+        int scanStatusCheckCount = 0, scanTriggerRetriesCount = 0, reportGenerateTriggerRetries = 0,\n+                reportGeneratestatusCheckCount = 0,maxRetries=15;\n+        ScheduledFuture<ExternalToolProcess> future = null;\n+        String releaseId = release.getId();\n+        ExternalToolProcess fossologyProcessLocal = fossologyProcess;\n+        byte[] byteArray = new byte[0];\n+        try (ByteArrayOutputStream attachmentOutputStream = new ByteArrayOutputStream();\n+                InputStream streamToAttachments = attachmentService.getStreamToAttachments(\n+                        Collections.singleton(attachmentService.getAttachmentContent(attachmentId)), user, release)) {\n+            FileCopyUtils.copy(streamToAttachments, attachmentOutputStream);\n+            byteArray = attachmentOutputStream.toByteArray();\n+        } catch (IOException exp) {\n+            log.error(\"Release : \" + releaseId + \" .Error occured while calculation attachment size.Attachment ID : \"\n+                    + attachmentId);\n+        }\n+\n+        int attachmentSizeinMB = (byteArray.length / 1024) / 1024;\n+        int timeIntervalToCheckUnpackScanStatus = attachmentSizeinMB <= 5 ? 10 : 2 * attachmentSizeinMB;\n+\n+        log.info(String.format(\n+                \"Release : %s .Size of source is %s MB, Time interval to check scan and unpack status %s sec\",\n+                new Object[] { releaseId, attachmentSizeinMB, timeIntervalToCheckUnpackScanStatus }));\n+\n+        Callable<ExternalToolProcess> processRunnable = new Callable<ExternalToolProcess>() {\n+            public ExternalToolProcess call() throws Exception {\n+                return releaseService.fossologyProcess(releaseId, user);\n+            }\n+        };\n+\n+        if (fossologyProcessLocal == null || !isUploadStepCompletedSuccessfully(fossologyProcessLocal, releaseId)) {\n+            log.info(\"Release : \" + releaseId + \" .Triggering Upload Step.\");\n+            fossologyProcessLocal = releaseService.fossologyProcess(releaseId, user);\n+        }\n+\n+        if (isUploadStepCompletedSuccessfully(fossologyProcessLocal, releaseId) && releaseService.isUnpackSuccessFull(", "originalCommit": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bb9f2bad92339d0d8a1b44ccfa92052659f0d76f", "url": "https://github.com/eclipse/sw360/commit/bb9f2bad92339d0d8a1b44ccfa92052659f0d76f", "message": "feat(REST): Trigger FOSSology process and check status.\n\nSigned-off-by: Jaideep Palit <jaideep.palit@siemens.com>", "committedDate": "2020-03-06T11:28:08Z", "type": "commit"}, {"oid": "bb9f2bad92339d0d8a1b44ccfa92052659f0d76f", "url": "https://github.com/eclipse/sw360/commit/bb9f2bad92339d0d8a1b44ccfa92052659f0d76f", "message": "feat(REST): Trigger FOSSology process and check status.\n\nSigned-off-by: Jaideep Palit <jaideep.palit@siemens.com>", "committedDate": "2020-03-06T11:28:08Z", "type": "forcePushed"}]}