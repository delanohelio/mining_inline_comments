{"pr_number": 721, "pr_title": "DPC-25 Common code", "pr_createdAt": "2020-03-30T22:00:27Z", "pr_url": "https://github.com/CMSgov/dpc-app/pull/721", "timeline": [{"oid": "0cb555062cd72e4c63c830c6e3b03ca54e583023", "url": "https://github.com/CMSgov/dpc-app/commit/0cb555062cd72e4c63c830c6e3b03ca54e583023", "message": "move to queue module", "committedDate": "2020-03-30T21:57:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyNzkwMA==", "url": "https://github.com/CMSgov/dpc-app/pull/721#discussion_r400527900", "bodyText": "Similar blocks of code found in 6 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-03-30T22:17:18Z", "path": "dpc-queue/src/main/java/gov/cms/dpc/queue/service/DataService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package gov.cms.dpc.queue.service;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import gov.cms.dpc.common.annotations.ExportPath;\n+import gov.cms.dpc.queue.IJobQueue;\n+import gov.cms.dpc.queue.JobStatus;\n+import gov.cms.dpc.queue.exceptions.DataRetrievalException;\n+import gov.cms.dpc.queue.exceptions.DataRetrievalRetryException;\n+import gov.cms.dpc.queue.models.JobQueueBatch;\n+import gov.cms.dpc.queue.models.JobQueueBatchFile;\n+import org.hl7.fhir.dstu3.model.Bundle;\n+import org.hl7.fhir.dstu3.model.OperationOutcome;\n+import org.hl7.fhir.dstu3.model.Resource;\n+import org.hl7.fhir.dstu3.model.ResourceType;\n+\n+import javax.inject.Inject;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.stream.Collectors;\n+\n+public class DataService {\n+\n+    private static final int JOB_POLLING_TIMEOUT = 3 * 5;\n+\n+    private IJobQueue queue;\n+    private String exportPath;\n+    private FhirContext fhirContext;\n+\n+    @Inject", "originalCommit": "0cb555062cd72e4c63c830c6e3b03ca54e583023", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyNzkwMg==", "url": "https://github.com/CMSgov/dpc-app/pull/721#discussion_r400527902", "bodyText": "Call \"optionalBatches.isPresent()\" before accessing the value.", "author": "codeclimate", "createdAt": "2020-03-30T22:17:18Z", "path": "dpc-queue/src/main/java/gov/cms/dpc/queue/service/DataService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package gov.cms.dpc.queue.service;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import gov.cms.dpc.common.annotations.ExportPath;\n+import gov.cms.dpc.queue.IJobQueue;\n+import gov.cms.dpc.queue.JobStatus;\n+import gov.cms.dpc.queue.exceptions.DataRetrievalException;\n+import gov.cms.dpc.queue.exceptions.DataRetrievalRetryException;\n+import gov.cms.dpc.queue.models.JobQueueBatch;\n+import gov.cms.dpc.queue.models.JobQueueBatchFile;\n+import org.hl7.fhir.dstu3.model.Bundle;\n+import org.hl7.fhir.dstu3.model.OperationOutcome;\n+import org.hl7.fhir.dstu3.model.Resource;\n+import org.hl7.fhir.dstu3.model.ResourceType;\n+\n+import javax.inject.Inject;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.stream.Collectors;\n+\n+public class DataService {\n+\n+    private static final int JOB_POLLING_TIMEOUT = 3 * 5;\n+\n+    private IJobQueue queue;\n+    private String exportPath;\n+    private FhirContext fhirContext;\n+\n+    @Inject\n+    public DataService(IJobQueue queue, FhirContext fhirContext, @ExportPath String exportPath) {\n+        this.queue = queue;\n+        this.fhirContext = fhirContext;\n+        this.exportPath = exportPath;\n+    }\n+\n+    public Resource retrieveData(UUID organizationID, UUID providerID, List<String> patientIDs, ResourceType... resourceTypes) {\n+        UUID jobID = this.queue.createJob(organizationID, providerID.toString(), patientIDs, List.of(resourceTypes), null, null);\n+        Optional<List<JobQueueBatch>> optionalBatches = waitForJobToComplete(jobID, organizationID, this.queue);\n+\n+        if (optionalBatches.isEmpty()) {\n+            throw new DataRetrievalException(\"Failed to retrieve data\");\n+        }\n+\n+        List<JobQueueBatch> batches = optionalBatches.get();", "originalCommit": "0cb555062cd72e4c63c830c6e3b03ca54e583023", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYwMTY5Nw==", "url": "https://github.com/CMSgov/dpc-app/pull/721#discussion_r401601697", "bodyText": "I wonder if an if/else based on optionalBatches.isPresent() would make codeclimate happier. That's not to say that I agree with its complaint; I like the way you've written it. Just curious if that would make a difference.", "author": "em1", "createdAt": "2020-04-01T13:09:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyNzkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyNzkwNA==", "url": "https://github.com/CMSgov/dpc-app/pull/721#discussion_r400527904", "bodyText": "Call \"batchFile.isPresent()\" before accessing the value.", "author": "codeclimate", "createdAt": "2020-03-30T22:17:18Z", "path": "dpc-queue/src/main/java/gov/cms/dpc/queue/service/DataService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package gov.cms.dpc.queue.service;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import gov.cms.dpc.common.annotations.ExportPath;\n+import gov.cms.dpc.queue.IJobQueue;\n+import gov.cms.dpc.queue.JobStatus;\n+import gov.cms.dpc.queue.exceptions.DataRetrievalException;\n+import gov.cms.dpc.queue.exceptions.DataRetrievalRetryException;\n+import gov.cms.dpc.queue.models.JobQueueBatch;\n+import gov.cms.dpc.queue.models.JobQueueBatchFile;\n+import org.hl7.fhir.dstu3.model.Bundle;\n+import org.hl7.fhir.dstu3.model.OperationOutcome;\n+import org.hl7.fhir.dstu3.model.Resource;\n+import org.hl7.fhir.dstu3.model.ResourceType;\n+\n+import javax.inject.Inject;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.stream.Collectors;\n+\n+public class DataService {\n+\n+    private static final int JOB_POLLING_TIMEOUT = 3 * 5;\n+\n+    private IJobQueue queue;\n+    private String exportPath;\n+    private FhirContext fhirContext;\n+\n+    @Inject\n+    public DataService(IJobQueue queue, FhirContext fhirContext, @ExportPath String exportPath) {\n+        this.queue = queue;\n+        this.fhirContext = fhirContext;\n+        this.exportPath = exportPath;\n+    }\n+\n+    public Resource retrieveData(UUID organizationID, UUID providerID, List<String> patientIDs, ResourceType... resourceTypes) {\n+        UUID jobID = this.queue.createJob(organizationID, providerID.toString(), patientIDs, List.of(resourceTypes), null, null);\n+        Optional<List<JobQueueBatch>> optionalBatches = waitForJobToComplete(jobID, organizationID, this.queue);\n+\n+        if (optionalBatches.isEmpty()) {\n+            throw new DataRetrievalException(\"Failed to retrieve data\");\n+        }\n+\n+        List<JobQueueBatch> batches = optionalBatches.get();\n+        List<JobQueueBatchFile> files = batches.stream().map(JobQueueBatch::getJobQueueBatchFiles).flatMap(List::stream).collect(Collectors.toList());\n+        if (files.size() == 1 && files.get(0).getResourceType() == ResourceType.OperationOutcome) {\n+            return assembleOperationOutcome(batches);\n+        } else {\n+            return assembleBundleFromBatches(batches, Arrays.asList(resourceTypes));\n+        }\n+    }\n+\n+    Optional<List<JobQueueBatch>> waitForJobToComplete(UUID jobID, UUID organizationID, IJobQueue queue) {\n+        CompletableFuture<Optional<List<JobQueueBatch>>> finalStatusFuture = new CompletableFuture<>();\n+        final ScheduledExecutorService poller = Executors.newSingleThreadScheduledExecutor();\n+        final ScheduledFuture<?> task = poller.scheduleAtFixedRate(() -> {\n+            try {\n+                List<JobQueueBatch> batches = getJobBatch(jobID, organizationID, queue);\n+                finalStatusFuture.complete(Optional.of(batches));\n+            } catch (DataRetrievalRetryException e) {\n+                //retrying\n+            }\n+        }, 0, 250, TimeUnit.MILLISECONDS);\n+\n+        // this timeout value should probably be adjusted according to the number of types being requested\n+        finalStatusFuture.completeOnTimeout(Optional.empty(), JOB_POLLING_TIMEOUT, TimeUnit.SECONDS);\n+\n+        try {\n+            return finalStatusFuture.get();\n+        } catch (InterruptedException | ExecutionException e) {\n+            return Optional.empty();\n+        } finally {\n+            task.cancel(true);\n+            poller.shutdown();\n+        }\n+    }\n+\n+    List<JobQueueBatch> getJobBatch(UUID jobID, UUID organizationId, IJobQueue queue) throws DataRetrievalRetryException {\n+        final List<JobQueueBatch> batches = queue.getJobBatches(jobID);\n+        if (batches.isEmpty()) {\n+            throw new DataRetrievalRetryException();\n+        }\n+\n+        Set<JobStatus> jobStatusSet = batches\n+                .stream()\n+                .filter(b -> b.getOrgID().equals(organizationId))\n+                .filter(JobQueueBatch::isValid)\n+                .map(JobQueueBatch::getStatus).collect(Collectors.toSet());\n+\n+        if (jobStatusSet.size() == 1 && jobStatusSet.contains(JobStatus.COMPLETED)) {\n+            return batches;\n+        } else if (jobStatusSet.contains(JobStatus.FAILED)) {\n+            throw new DataRetrievalException(\"Failed to retrieve batches\");\n+        } else {\n+            throw new DataRetrievalRetryException();\n+        }\n+    }\n+\n+    private Bundle assembleBundleFromBatches(List<JobQueueBatch> batches, List<ResourceType> resourceTypes) {\n+        final Bundle bundle = new Bundle().setType(Bundle.BundleType.SEARCHSET);\n+\n+        batches.stream()\n+                .map(JobQueueBatch::getJobQueueBatchFiles)\n+                .flatMap(List::stream)\n+                .filter(bf -> resourceTypes.contains(bf.getResourceType()))\n+                .forEach(batchFile -> {\n+                    java.nio.file.Path path = Paths.get(String.format(\"%s/%s.ndjson\", exportPath, batchFile.getFileName()));\n+                    addResourceEntries(Resource.class, path, bundle);\n+                });\n+\n+\n+        // set a bundle id here? anything else?\n+        bundle.setId(UUID.randomUUID().toString());\n+        return bundle.setTotal(bundle.getEntry().size());\n+    }\n+\n+    private void addResourceEntries(Class<? extends Resource> clazz, java.nio.file.Path path, Bundle bundle) {\n+        try (BufferedReader br = Files.newBufferedReader(path)) {\n+            br.lines().forEach(line -> {\n+                Resource r = fhirContext.newJsonParser().parseResource(clazz, line);\n+                bundle.addEntry().setResource(r);\n+            });\n+        } catch (IOException e) {\n+            throw new DataRetrievalException(String.format(\"Unable to read resource because %s\", e.getMessage()));\n+        }\n+    }\n+\n+    OperationOutcome assembleOperationOutcome(List<JobQueueBatch> batches) {\n+        // There is only ever 1 OperationOutcome file\n+        final Optional<JobQueueBatchFile> batchFile = batches.stream()\n+                .map(b -> b.getJobQueueFileLatest(ResourceType.OperationOutcome))\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .findFirst();\n+\n+\n+        if (batchFile.isEmpty()) {\n+            throw new DataRetrievalException(\"Failed to retrieve operationOutcome\");\n+        }\n+\n+        OperationOutcome outcome = new OperationOutcome();\n+        java.nio.file.Path path = Paths.get(String.format(\"%s/%s.ndjson\", exportPath, batchFile.get().getFileName()));", "originalCommit": "0cb555062cd72e4c63c830c6e3b03ca54e583023", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyNzkwNg==", "url": "https://github.com/CMSgov/dpc-app/pull/721#discussion_r400527906", "bodyText": "Remove this unused method parameter \"resourceTypes\".", "author": "codeclimate", "createdAt": "2020-03-30T22:17:18Z", "path": "dpc-queue/src/main/java/gov/cms/dpc/queue/service/DataService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package gov.cms.dpc.queue.service;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import gov.cms.dpc.common.annotations.ExportPath;\n+import gov.cms.dpc.queue.IJobQueue;\n+import gov.cms.dpc.queue.JobStatus;\n+import gov.cms.dpc.queue.exceptions.DataRetrievalException;\n+import gov.cms.dpc.queue.exceptions.DataRetrievalRetryException;\n+import gov.cms.dpc.queue.models.JobQueueBatch;\n+import gov.cms.dpc.queue.models.JobQueueBatchFile;\n+import org.hl7.fhir.dstu3.model.Bundle;\n+import org.hl7.fhir.dstu3.model.OperationOutcome;\n+import org.hl7.fhir.dstu3.model.Resource;\n+import org.hl7.fhir.dstu3.model.ResourceType;\n+\n+import javax.inject.Inject;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.stream.Collectors;\n+\n+public class DataService {\n+\n+    private static final int JOB_POLLING_TIMEOUT = 3 * 5;\n+\n+    private IJobQueue queue;\n+    private String exportPath;\n+    private FhirContext fhirContext;\n+\n+    @Inject\n+    public DataService(IJobQueue queue, FhirContext fhirContext, @ExportPath String exportPath) {\n+        this.queue = queue;\n+        this.fhirContext = fhirContext;\n+        this.exportPath = exportPath;\n+    }\n+\n+    public Resource retrieveData(UUID organizationID, UUID providerID, List<String> patientIDs, ResourceType... resourceTypes) {\n+        UUID jobID = this.queue.createJob(organizationID, providerID.toString(), patientIDs, List.of(resourceTypes), null, null);\n+        Optional<List<JobQueueBatch>> optionalBatches = waitForJobToComplete(jobID, organizationID, this.queue);\n+\n+        if (optionalBatches.isEmpty()) {\n+            throw new DataRetrievalException(\"Failed to retrieve data\");\n+        }\n+\n+        List<JobQueueBatch> batches = optionalBatches.get();\n+        List<JobQueueBatchFile> files = batches.stream().map(JobQueueBatch::getJobQueueBatchFiles).flatMap(List::stream).collect(Collectors.toList());\n+        if (files.size() == 1 && files.get(0).getResourceType() == ResourceType.OperationOutcome) {\n+            return assembleOperationOutcome(batches);\n+        } else {\n+            return assembleBundleFromBatches(batches, Arrays.asList(resourceTypes));\n+        }\n+    }\n+\n+    Optional<List<JobQueueBatch>> waitForJobToComplete(UUID jobID, UUID organizationID, IJobQueue queue) {\n+        CompletableFuture<Optional<List<JobQueueBatch>>> finalStatusFuture = new CompletableFuture<>();\n+        final ScheduledExecutorService poller = Executors.newSingleThreadScheduledExecutor();\n+        final ScheduledFuture<?> task = poller.scheduleAtFixedRate(() -> {\n+            try {\n+                List<JobQueueBatch> batches = getJobBatch(jobID, organizationID, queue);\n+                finalStatusFuture.complete(Optional.of(batches));\n+            } catch (DataRetrievalRetryException e) {\n+                //retrying\n+            }\n+        }, 0, 250, TimeUnit.MILLISECONDS);\n+\n+        // this timeout value should probably be adjusted according to the number of types being requested\n+        finalStatusFuture.completeOnTimeout(Optional.empty(), JOB_POLLING_TIMEOUT, TimeUnit.SECONDS);\n+\n+        try {\n+            return finalStatusFuture.get();\n+        } catch (InterruptedException | ExecutionException e) {\n+            return Optional.empty();\n+        } finally {\n+            task.cancel(true);\n+            poller.shutdown();\n+        }\n+    }\n+\n+    List<JobQueueBatch> getJobBatch(UUID jobID, UUID organizationId, IJobQueue queue) throws DataRetrievalRetryException {\n+        final List<JobQueueBatch> batches = queue.getJobBatches(jobID);\n+        if (batches.isEmpty()) {\n+            throw new DataRetrievalRetryException();\n+        }\n+\n+        Set<JobStatus> jobStatusSet = batches\n+                .stream()\n+                .filter(b -> b.getOrgID().equals(organizationId))\n+                .filter(JobQueueBatch::isValid)\n+                .map(JobQueueBatch::getStatus).collect(Collectors.toSet());\n+\n+        if (jobStatusSet.size() == 1 && jobStatusSet.contains(JobStatus.COMPLETED)) {\n+            return batches;\n+        } else if (jobStatusSet.contains(JobStatus.FAILED)) {\n+            throw new DataRetrievalException(\"Failed to retrieve batches\");\n+        } else {\n+            throw new DataRetrievalRetryException();\n+        }\n+    }\n+\n+    private Bundle assembleBundleFromBatches(List<JobQueueBatch> batches, List<ResourceType> resourceTypes) {", "originalCommit": "0cb555062cd72e4c63c830c6e3b03ca54e583023", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTczMTUyMQ==", "url": "https://github.com/CMSgov/dpc-app/pull/721#discussion_r401731521", "bodyText": "Not sure why codeClimate doesn't see it being used at line 135.. I debugged just to make sure it is using it...", "author": "MrBilnon", "createdAt": "2020-04-01T16:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyNzkwNg=="}], "type": "inlineReview"}, {"oid": "96078ac31656406a3141c867c659a2b3595d750a", "url": "https://github.com/CMSgov/dpc-app/commit/96078ac31656406a3141c867c659a2b3595d750a", "message": "add test", "committedDate": "2020-03-31T06:19:55Z", "type": "commit"}, {"oid": "54d511f1da59c86ea81a4b48d4037d34e0a345ab", "url": "https://github.com/CMSgov/dpc-app/commit/54d511f1da59c86ea81a4b48d4037d34e0a345ab", "message": "fix tests", "committedDate": "2020-03-31T17:50:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExNzMxMw==", "url": "https://github.com/CMSgov/dpc-app/pull/721#discussion_r401117313", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-03-31T18:15:50Z", "path": "dpc-queue/src/main/java/gov/cms/dpc/queue/service/DataService.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package gov.cms.dpc.queue.service;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import gov.cms.dpc.common.annotations.ExportPath;\n+import gov.cms.dpc.common.annotations.JobTimeout;\n+import gov.cms.dpc.queue.IJobQueue;\n+import gov.cms.dpc.queue.JobStatus;\n+import gov.cms.dpc.queue.exceptions.DataRetrievalException;\n+import gov.cms.dpc.queue.exceptions.DataRetrievalRetryException;\n+import gov.cms.dpc.queue.models.JobQueueBatch;\n+import gov.cms.dpc.queue.models.JobQueueBatchFile;\n+import org.hl7.fhir.dstu3.model.Bundle;\n+import org.hl7.fhir.dstu3.model.OperationOutcome;\n+import org.hl7.fhir.dstu3.model.Resource;\n+import org.hl7.fhir.dstu3.model.ResourceType;\n+\n+import javax.inject.Inject;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.stream.Collectors;\n+\n+public class DataService {\n+\n+    private IJobQueue queue;\n+    private String exportPath;\n+    private FhirContext fhirContext;\n+    private int jobTimeoutInSeconds;\n+\n+    @Inject", "originalCommit": "54d511f1da59c86ea81a4b48d4037d34e0a345ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTczMjIwNQ==", "url": "https://github.com/CMSgov/dpc-app/pull/721#discussion_r401732205", "bodyText": "I don't quite understand what this is pertaining to", "author": "MrBilnon", "createdAt": "2020-04-01T16:05:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExNzMxMw=="}], "type": "inlineReview"}, {"oid": "8089049a9c85544074ba6d2efef6c610674554a7", "url": "https://github.com/CMSgov/dpc-app/commit/8089049a9c85544074ba6d2efef6c610674554a7", "message": "allow passing in since and transactionTime", "committedDate": "2020-04-01T02:55:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMzMjI5NQ==", "url": "https://github.com/CMSgov/dpc-app/pull/721#discussion_r401332295", "bodyText": "Method retrieveData has 6 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-01T03:14:27Z", "path": "dpc-queue/src/main/java/gov/cms/dpc/queue/service/DataService.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package gov.cms.dpc.queue.service;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import gov.cms.dpc.common.annotations.ExportPath;\n+import gov.cms.dpc.common.annotations.JobTimeout;\n+import gov.cms.dpc.queue.IJobQueue;\n+import gov.cms.dpc.queue.JobStatus;\n+import gov.cms.dpc.queue.exceptions.DataRetrievalException;\n+import gov.cms.dpc.queue.exceptions.DataRetrievalRetryException;\n+import gov.cms.dpc.queue.models.JobQueueBatch;\n+import gov.cms.dpc.queue.models.JobQueueBatchFile;\n+import org.hl7.fhir.dstu3.model.Bundle;\n+import org.hl7.fhir.dstu3.model.OperationOutcome;\n+import org.hl7.fhir.dstu3.model.Resource;\n+import org.hl7.fhir.dstu3.model.ResourceType;\n+\n+import javax.inject.Inject;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.time.OffsetDateTime;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.stream.Collectors;\n+\n+public class DataService {\n+\n+    private IJobQueue queue;\n+    private String exportPath;\n+    private FhirContext fhirContext;\n+    private int jobTimeoutInSeconds;\n+\n+    @Inject\n+    public DataService(IJobQueue queue, FhirContext fhirContext, @ExportPath String exportPath, @JobTimeout  int jobTimeoutInSeconds) {\n+        this.queue = queue;\n+        this.fhirContext = fhirContext;\n+        this.exportPath = exportPath;\n+        this.jobTimeoutInSeconds = jobTimeoutInSeconds;\n+    }\n+\n+    public Resource retrieveData(UUID organizationID,", "originalCommit": "8089049a9c85544074ba6d2efef6c610674554a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYzMzIzMA==", "url": "https://github.com/CMSgov/dpc-app/pull/721#discussion_r401633230", "bodyText": "What's the reason for not importing java.nio.file.Path?", "author": "em1", "createdAt": "2020-04-01T13:54:00Z", "path": "dpc-queue/src/main/java/gov/cms/dpc/queue/service/DataService.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package gov.cms.dpc.queue.service;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import gov.cms.dpc.common.annotations.ExportPath;\n+import gov.cms.dpc.common.annotations.JobTimeout;\n+import gov.cms.dpc.queue.IJobQueue;\n+import gov.cms.dpc.queue.JobStatus;\n+import gov.cms.dpc.queue.exceptions.DataRetrievalException;\n+import gov.cms.dpc.queue.exceptions.DataRetrievalRetryException;\n+import gov.cms.dpc.queue.models.JobQueueBatch;\n+import gov.cms.dpc.queue.models.JobQueueBatchFile;\n+import org.hl7.fhir.dstu3.model.Bundle;\n+import org.hl7.fhir.dstu3.model.OperationOutcome;\n+import org.hl7.fhir.dstu3.model.Resource;\n+import org.hl7.fhir.dstu3.model.ResourceType;\n+\n+import javax.inject.Inject;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.time.OffsetDateTime;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.stream.Collectors;\n+\n+public class DataService {\n+\n+    private IJobQueue queue;\n+    private String exportPath;\n+    private FhirContext fhirContext;\n+    private int jobTimeoutInSeconds;\n+\n+    @Inject\n+    public DataService(IJobQueue queue, FhirContext fhirContext, @ExportPath String exportPath, @JobTimeout  int jobTimeoutInSeconds) {\n+        this.queue = queue;\n+        this.fhirContext = fhirContext;\n+        this.exportPath = exportPath;\n+        this.jobTimeoutInSeconds = jobTimeoutInSeconds;\n+    }\n+\n+    public Resource retrieveData(UUID organizationID,\n+                                 UUID providerID,\n+                                 List<String> patientIDs,\n+                                 OffsetDateTime since,\n+                                 OffsetDateTime transactionTime,\n+                                 ResourceType... resourceTypes) {\n+        UUID jobID = this.queue.createJob(organizationID, providerID.toString(), patientIDs, List.of(resourceTypes), since, transactionTime);\n+        Optional<List<JobQueueBatch>> optionalBatches = waitForJobToComplete(jobID, organizationID, this.queue);\n+\n+        if (optionalBatches.isEmpty()) {\n+            throw new DataRetrievalException(\"Failed to retrieve data\");\n+        }\n+\n+        List<JobQueueBatch> batches = optionalBatches.get();\n+        List<JobQueueBatchFile> files = batches.stream().map(JobQueueBatch::getJobQueueBatchFiles).flatMap(List::stream).collect(Collectors.toList());\n+        if (files.size() == 1 && files.get(0).getResourceType() == ResourceType.OperationOutcome) {\n+            return assembleOperationOutcome(batches);\n+        } else {\n+            return assembleBundleFromBatches(batches, Arrays.asList(resourceTypes));\n+        }\n+    }\n+\n+    private Optional<List<JobQueueBatch>> waitForJobToComplete(UUID jobID, UUID organizationID, IJobQueue queue) {\n+        CompletableFuture<Optional<List<JobQueueBatch>>> dataFuture = new CompletableFuture<>();\n+        final ScheduledExecutorService poller = Executors.newSingleThreadScheduledExecutor();\n+        final ScheduledFuture<?> task = poller.scheduleAtFixedRate(() -> {\n+            try {\n+                List<JobQueueBatch> batches = getJobBatch(jobID, organizationID, queue);\n+                dataFuture.complete(Optional.of(batches));\n+            } catch (DataRetrievalRetryException e) {\n+                //retrying\n+            }\n+        }, 0, 250, TimeUnit.MILLISECONDS);\n+\n+        // this timeout value should probably be adjusted according to the number of types being requested\n+        dataFuture.completeOnTimeout(Optional.empty(), jobTimeoutInSeconds, TimeUnit.SECONDS);\n+\n+        try {\n+            return dataFuture.get();\n+        } catch (InterruptedException | ExecutionException e) {\n+            return Optional.empty();\n+        } finally {\n+            task.cancel(true);\n+            poller.shutdown();\n+        }\n+    }\n+\n+    private List<JobQueueBatch> getJobBatch(UUID jobID, UUID organizationId, IJobQueue queue) throws DataRetrievalRetryException {\n+        final List<JobQueueBatch> batches = queue.getJobBatches(jobID);\n+        if (batches.isEmpty()) {\n+            throw new DataRetrievalRetryException();\n+        }\n+\n+        Set<JobStatus> jobStatusSet = batches\n+                .stream()\n+                .filter(b -> b.getOrgID().equals(organizationId))\n+                .filter(JobQueueBatch::isValid)\n+                .map(JobQueueBatch::getStatus).collect(Collectors.toSet());\n+\n+        if (jobStatusSet.size() == 1 && jobStatusSet.contains(JobStatus.COMPLETED)) {\n+            return batches;\n+        } else if (jobStatusSet.contains(JobStatus.FAILED)) {\n+            throw new DataRetrievalException(\"Failed to retrieve batches\");\n+        } else {\n+            throw new DataRetrievalRetryException();\n+        }\n+    }\n+\n+    private Bundle assembleBundleFromBatches(List<JobQueueBatch> batches, List<ResourceType> resourceTypes) {\n+        final Bundle bundle = new Bundle().setType(Bundle.BundleType.SEARCHSET);\n+\n+        batches.stream()\n+                .map(JobQueueBatch::getJobQueueBatchFiles)\n+                .flatMap(List::stream)\n+                .filter(bf -> resourceTypes.contains(bf.getResourceType()))\n+                .forEach(batchFile -> {\n+                    java.nio.file.Path path = Paths.get(String.format(\"%s/%s.ndjson\", exportPath, batchFile.getFileName()));", "originalCommit": "8089049a9c85544074ba6d2efef6c610674554a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ec772e02585d409f7e9eccafd9c2c8885e1d9fbe", "url": "https://github.com/CMSgov/dpc-app/commit/ec772e02585d409f7e9eccafd9c2c8885e1d9fbe", "message": "try to fix code climate, add log statements, fix PR concerns", "committedDate": "2020-04-01T16:02:32Z", "type": "commit"}, {"oid": "db0473fa540f17ff908e637fdea2930ae54c50ff", "url": "https://github.com/CMSgov/dpc-app/commit/db0473fa540f17ff908e637fdea2930ae54c50ff", "message": "add documentation and comments to highlight codeclimate issues", "committedDate": "2020-04-01T16:11:56Z", "type": "commit"}, {"oid": "bf61a00629187d5cf54700d0c5ed3b6c4f3ffc8e", "url": "https://github.com/CMSgov/dpc-app/commit/bf61a00629187d5cf54700d0c5ed3b6c4f3ffc8e", "message": "Merge branch 'master' into DPC-25-common-code\n\n# Conflicts:\n#\tdpc-api/src/main/java/gov/cms/dpc/api/DPCAPIConfiguration.java", "committedDate": "2020-04-01T18:24:41Z", "type": "commit"}, {"oid": "e9470113c265ace356b9b5c4dd4edc48d0ba70f2", "url": "https://github.com/CMSgov/dpc-app/commit/e9470113c265ace356b9b5c4dd4edc48d0ba70f2", "message": "Merge branch 'master' into DPC-25-common-code", "committedDate": "2020-04-03T14:01:57Z", "type": "commit"}, {"oid": "acc7eeadaf53fab51ace852744e4008ae63da742", "url": "https://github.com/CMSgov/dpc-app/commit/acc7eeadaf53fab51ace852744e4008ae63da742", "message": "try to fix code climate", "committedDate": "2020-04-03T14:26:13Z", "type": "commit"}, {"oid": "c5c860b3fa0787939ddc2c2d204b3551823f8e42", "url": "https://github.com/CMSgov/dpc-app/commit/c5c860b3fa0787939ddc2c2d204b3551823f8e42", "message": "try to fix code climate", "committedDate": "2020-04-03T14:35:50Z", "type": "commit"}, {"oid": "3c9e7c291ee078758c13bb098eab038d4e96fdc7", "url": "https://github.com/CMSgov/dpc-app/commit/3c9e7c291ee078758c13bb098eab038d4e96fdc7", "message": "Merge branch 'master' into DPC-25-common-code", "committedDate": "2020-04-03T14:37:22Z", "type": "commit"}]}