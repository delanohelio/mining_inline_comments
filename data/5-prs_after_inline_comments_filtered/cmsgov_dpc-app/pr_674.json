{"pr_number": 674, "pr_title": "Fix: Stuck jobs are unable to be restarted due to SQL constraint exception", "pr_createdAt": "2020-03-09T15:59:17Z", "pr_url": "https://github.com/CMSgov/dpc-app/pull/674", "timeline": [{"oid": "d020ac7e96a7061b70d9fb6754f9e04a62a74c08", "url": "https://github.com/CMSgov/dpc-app/commit/d020ac7e96a7061b70d9fb6754f9e04a62a74c08", "message": "Reproduce stuck job issue as a unit test", "committedDate": "2020-03-09T15:57:57Z", "type": "commit"}, {"oid": "644b0a7b967830c922a6a65ddf75eae3d2e69c9b", "url": "https://github.com/CMSgov/dpc-app/commit/644b0a7b967830c922a6a65ddf75eae3d2e69c9b", "message": "Update unit test to match reality for how jobs are re-claimed after being stuck", "committedDate": "2020-03-09T16:33:52Z", "type": "commit"}, {"oid": "d249a823274cc6db187fae1e12302d923bf8fb09", "url": "https://github.com/CMSgov/dpc-app/commit/d249a823274cc6db187fae1e12302d923bf8fb09", "message": "Add flags onto @JoinColumn to fix Hibernate's delete and update behavior", "committedDate": "2020-03-09T16:34:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk0MzM0OA==", "url": "https://github.com/CMSgov/dpc-app/pull/674#discussion_r389943348", "bodyText": "Would it be possible to use a public constant from the distributed queue module instead of a hardcoded 15 minutes?", "author": "RickHawesUSDS", "createdAt": "2020-03-09T20:29:58Z", "path": "dpc-queue/src/test/java/gov/cms/dpc/queue/DistributedBatchQueueTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package gov.cms.dpc.queue;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import gov.cms.dpc.common.hibernate.queue.DPCQueueManagedSessionFactory;\n+import gov.cms.dpc.queue.models.JobQueueBatch;\n+import gov.cms.dpc.testing.BufferedLoggerHandler;\n+import org.hibernate.Session;\n+import org.hibernate.SessionFactory;\n+import org.hibernate.Transaction;\n+import org.hibernate.cfg.Configuration;\n+import org.hl7.fhir.dstu3.model.ResourceType;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import java.time.OffsetDateTime;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+@ExtendWith(BufferedLoggerHandler.class)\n+public class DistributedBatchQueueTest {\n+\n+    private final UUID aggregatorID = UUID.randomUUID();\n+    private SessionFactory sessionFactory;\n+    private DistributedBatchQueue queue;\n+\n+    @BeforeEach\n+    void setUp() {\n+        final Configuration conf = new Configuration();\n+        sessionFactory = conf.configure().buildSessionFactory();\n+        queue = new DistributedBatchQueue(new DPCQueueManagedSessionFactory(sessionFactory), 100, new MetricRegistry());\n+    }\n+\n+    @AfterEach\n+    void shutdown() {\n+        try (final Session session = sessionFactory.openSession()) {\n+            final Transaction tx = session.beginTransaction();\n+            try {\n+                session.createQuery(\"delete from job_queue_batch_file\").executeUpdate();\n+                session.createQuery(\"delete from job_queue_batch\").executeUpdate();\n+            } finally {\n+                tx.commit();\n+            }\n+        }\n+        sessionFactory.close();\n+    }\n+\n+    @Test\n+    void handleStuckBatchWithClaim() {\n+        // One organization id for both jobs\n+        final UUID orgID = UUID.randomUUID();\n+\n+        // Add a job\n+        var jobID = queue.createJob(orgID, \"test-provider-1\", List.of(\"test-patient-1\", \"test-patient-2\"), Collections.singletonList(ResourceType.Patient));\n+\n+        // Work the job\n+        Optional<JobQueueBatch> workBatch = queue.claimBatch(aggregatorID);\n+        assertTrue(workBatch.isPresent(), \"Should have a job to work\");\n+        final UUID firstBatchID = workBatch.orElseThrow().getBatchID();\n+\n+        // Add a file on the batch\n+        workBatch.get().addJobQueueFile(ResourceType.Patient, 0, 1);\n+        queue.completePartialBatch(workBatch.get(), aggregatorID);\n+\n+        // Check that the persisted job is RUNNING\n+        final Optional<JobQueueBatch> runningJobOptional = queue.getBatch(firstBatchID);\n+        assertTrue(runningJobOptional.isPresent(), \"Should have a running job\");\n+        runningJobOptional.ifPresent(runningJob -> {\n+            assertEquals(JobStatus.RUNNING, runningJob.getStatus(), \"Should be in the RUNNING state\");\n+            assertEquals(1, runningJob.getJobQueueBatchFiles().size(), \"Should have 1 file on the running job\");\n+            assertTrue(runningJob.getJobQueueFile(ResourceType.Patient).isPresent(), \"Should have a patient job file\");\n+        });\n+\n+        // Simulate a stuck job by modifying the update_time\n+        try (final Session session = sessionFactory.openSession()) {\n+            final Transaction tx = session.beginTransaction();\n+            try {\n+                session.createQuery(\"update job_queue_batch set updateTime = :updateTime where jobID = :jobID\")\n+                        .setParameter(\"jobID\", jobID)\n+                        .setParameter(\"updateTime\", OffsetDateTime.now().minusMinutes(15))\n+                        .executeUpdate();", "originalCommit": "d249a823274cc6db187fae1e12302d923bf8fb09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}