{"pr_number": 840, "pr_title": "feat(sample): Add plug and play Thermostat sample (no-component)", "pr_createdAt": "2020-07-06T20:38:09Z", "pr_url": "https://github.com/Azure/azure-iot-sdk-java/pull/840", "timeline": [{"oid": "c93671ae42d61410db1b39aa1a75617df8bf0b87", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/c93671ae42d61410db1b39aa1a75617df8bf0b87", "message": "feat(sample): Add plug and play Thermostat sample (no-component)", "committedDate": "2020-07-06T20:37:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ2ODg5MQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#discussion_r450468891", "bodyText": "SneakyThrows will not ignore, wrap or modify the actual checked exception thrown, but will instead prevent the compiler from complaining that the exception is not handled (either by declaring throws n the method signature, or by wrapping it in a try-catch block and rethrowing a RuntimeException.\nFrom lombok documentation: https://projectlombok.org/features/SneakyThrows\nwhatever exception propagates out of your run() method, checked or not, it will be passed to the Thread's unhandled exception handler. Catching a checked exception and wrapping it in some sort of RuntimeException is only obscuring the real cause of the issue.", "author": "abhipsaMisra", "createdAt": "2020-07-06T20:42:34Z", "path": "device/iot-device-samples/pnp-device-sample/Thermostat/src/main/java/samples/com/microsoft/azure/sdk/iot/Thermostat.java", "diffHunk": "@@ -0,0 +1,317 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import com.google.gson.annotations.SerializedName;\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.AllArgsConstructor;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+\n+@Slf4j\n+public class Thermostat {\n+\n+    public enum StatusCode {\n+        COMPLETED (200),\n+        IN_PROGRESS (202),\n+        NOT_FOUND (404);\n+\n+        private final int value;\n+        StatusCode(int value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    private static final String deviceConnectionString = System.getenv(\"IOTHUB_DEVICE_CONNECTION_STRING\");\n+    private static final String MODEL_ID = \"dtmi:com:example:Thermostat;1\";\n+\n+    // Plug and play features are available over either MQTT or MQTT_WS.\n+    private static final IotHubClientProtocol protocol = IotHubClientProtocol.MQTT;\n+\n+    private static final Random random = new Random();\n+    private static final Map<Date, Double> temperatureReadings = new HashMap<>();\n+\n+    private static DeviceClient deviceClient;\n+    private static double temperature = 0.0d;\n+    private static double maxTemperature = 0.0d;\n+    private static boolean temperatureReset = true;\n+\n+    public static void main(String[] args) throws URISyntaxException, IOException {\n+\n+        // This sample follows the following workflow:\n+        // -> Initialize device client instance.\n+        // -> Set handler to receive \"targetTemperature\" updates, and send the received update over reported property.\n+        // -> Set handler to receive \"getMaxMinReport\" command, and send the generated report as command response.\n+        // -> Periodically send \"temperature\" over telemetry.\n+        // -> Send \"maxTempSinceLastReboot\" over property update, when a new max temperature is set.\n+\n+        log.debug(\"Initialize the device client.\");\n+        initializeDeviceClient();\n+\n+        log.debug(\"Start twin and set handler to receive \\\"targetTemperature\\\" updates.\");\n+        deviceClient.startDeviceTwin(new TwinIotHubEventCallback(), null, new TargetTemperatureUpdateCallback(), null);\n+        Map<Property, Pair<TwinPropertyCallBack, Object>> desiredPropertyUpdateCallback =\n+                Collections.singletonMap(\n+                        new Property(\"targetTemperature\", null),\n+                        new Pair<TwinPropertyCallBack, Object>(new TargetTemperatureUpdateCallback(), null));\n+        deviceClient.subscribeToTwinDesiredProperties(desiredPropertyUpdateCallback);\n+\n+        log.debug(\"Set handler to receive \\\"getMaxMinReport\\\" command.\");\n+        String methodName = \"getMaxMinReport\";\n+        deviceClient.subscribeToDeviceMethod(new GetMaxMinReportMethodCallback(), methodName, new MethodIotHubEventCallback(), methodName);\n+\n+        new Thread(new Runnable() {\n+            @SneakyThrows(InterruptedException.class)", "originalCommit": "c93671ae42d61410db1b39aa1a75617df8bf0b87", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ2OTMxNw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#discussion_r450469317", "bodyText": "This is only to ensure only a single decimal place is stored, for the double.", "author": "abhipsaMisra", "createdAt": "2020-07-06T20:43:29Z", "path": "device/iot-device-samples/pnp-device-sample/Thermostat/src/main/java/samples/com/microsoft/azure/sdk/iot/Thermostat.java", "diffHunk": "@@ -0,0 +1,317 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import com.google.gson.annotations.SerializedName;\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.AllArgsConstructor;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+\n+@Slf4j\n+public class Thermostat {\n+\n+    public enum StatusCode {\n+        COMPLETED (200),\n+        IN_PROGRESS (202),\n+        NOT_FOUND (404);\n+\n+        private final int value;\n+        StatusCode(int value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    private static final String deviceConnectionString = System.getenv(\"IOTHUB_DEVICE_CONNECTION_STRING\");\n+    private static final String MODEL_ID = \"dtmi:com:example:Thermostat;1\";\n+\n+    // Plug and play features are available over either MQTT or MQTT_WS.\n+    private static final IotHubClientProtocol protocol = IotHubClientProtocol.MQTT;\n+\n+    private static final Random random = new Random();\n+    private static final Map<Date, Double> temperatureReadings = new HashMap<>();\n+\n+    private static DeviceClient deviceClient;\n+    private static double temperature = 0.0d;\n+    private static double maxTemperature = 0.0d;\n+    private static boolean temperatureReset = true;\n+\n+    public static void main(String[] args) throws URISyntaxException, IOException {\n+\n+        // This sample follows the following workflow:\n+        // -> Initialize device client instance.\n+        // -> Set handler to receive \"targetTemperature\" updates, and send the received update over reported property.\n+        // -> Set handler to receive \"getMaxMinReport\" command, and send the generated report as command response.\n+        // -> Periodically send \"temperature\" over telemetry.\n+        // -> Send \"maxTempSinceLastReboot\" over property update, when a new max temperature is set.\n+\n+        log.debug(\"Initialize the device client.\");\n+        initializeDeviceClient();\n+\n+        log.debug(\"Start twin and set handler to receive \\\"targetTemperature\\\" updates.\");\n+        deviceClient.startDeviceTwin(new TwinIotHubEventCallback(), null, new TargetTemperatureUpdateCallback(), null);\n+        Map<Property, Pair<TwinPropertyCallBack, Object>> desiredPropertyUpdateCallback =\n+                Collections.singletonMap(\n+                        new Property(\"targetTemperature\", null),\n+                        new Pair<TwinPropertyCallBack, Object>(new TargetTemperatureUpdateCallback(), null));\n+        deviceClient.subscribeToTwinDesiredProperties(desiredPropertyUpdateCallback);\n+\n+        log.debug(\"Set handler to receive \\\"getMaxMinReport\\\" command.\");\n+        String methodName = \"getMaxMinReport\";\n+        deviceClient.subscribeToDeviceMethod(new GetMaxMinReportMethodCallback(), methodName, new MethodIotHubEventCallback(), methodName);\n+\n+        new Thread(new Runnable() {\n+            @SneakyThrows(InterruptedException.class)\n+            @Override\n+            public void run() {\n+                while (true) {\n+                    if (temperatureReset) {\n+                        // Generate a random value between 5.0\u00b0C and 45.0\u00b0C for the current temperature reading.\n+                        temperature = BigDecimal.valueOf(random.nextDouble() * 40 + 5).setScale(1, RoundingMode.HALF_UP).doubleValue();", "originalCommit": "c93671ae42d61410db1b39aa1a75617df8bf0b87", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ2OTU1Mg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#discussion_r450469552", "bodyText": "This call is required explicitly for java SDK", "author": "abhipsaMisra", "createdAt": "2020-07-06T20:44:00Z", "path": "device/iot-device-samples/pnp-device-sample/Thermostat/src/main/java/samples/com/microsoft/azure/sdk/iot/Thermostat.java", "diffHunk": "@@ -0,0 +1,317 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import com.google.gson.annotations.SerializedName;\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.AllArgsConstructor;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+\n+@Slf4j\n+public class Thermostat {\n+\n+    public enum StatusCode {\n+        COMPLETED (200),\n+        IN_PROGRESS (202),\n+        NOT_FOUND (404);\n+\n+        private final int value;\n+        StatusCode(int value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    private static final String deviceConnectionString = System.getenv(\"IOTHUB_DEVICE_CONNECTION_STRING\");\n+    private static final String MODEL_ID = \"dtmi:com:example:Thermostat;1\";\n+\n+    // Plug and play features are available over either MQTT or MQTT_WS.\n+    private static final IotHubClientProtocol protocol = IotHubClientProtocol.MQTT;\n+\n+    private static final Random random = new Random();\n+    private static final Map<Date, Double> temperatureReadings = new HashMap<>();\n+\n+    private static DeviceClient deviceClient;\n+    private static double temperature = 0.0d;\n+    private static double maxTemperature = 0.0d;\n+    private static boolean temperatureReset = true;\n+\n+    public static void main(String[] args) throws URISyntaxException, IOException {\n+\n+        // This sample follows the following workflow:\n+        // -> Initialize device client instance.\n+        // -> Set handler to receive \"targetTemperature\" updates, and send the received update over reported property.\n+        // -> Set handler to receive \"getMaxMinReport\" command, and send the generated report as command response.\n+        // -> Periodically send \"temperature\" over telemetry.\n+        // -> Send \"maxTempSinceLastReboot\" over property update, when a new max temperature is set.\n+\n+        log.debug(\"Initialize the device client.\");\n+        initializeDeviceClient();\n+\n+        log.debug(\"Start twin and set handler to receive \\\"targetTemperature\\\" updates.\");\n+        deviceClient.startDeviceTwin(new TwinIotHubEventCallback(), null, new TargetTemperatureUpdateCallback(), null);\n+        Map<Property, Pair<TwinPropertyCallBack, Object>> desiredPropertyUpdateCallback =\n+                Collections.singletonMap(\n+                        new Property(\"targetTemperature\", null),\n+                        new Pair<TwinPropertyCallBack, Object>(new TargetTemperatureUpdateCallback(), null));\n+        deviceClient.subscribeToTwinDesiredProperties(desiredPropertyUpdateCallback);\n+\n+        log.debug(\"Set handler to receive \\\"getMaxMinReport\\\" command.\");\n+        String methodName = \"getMaxMinReport\";\n+        deviceClient.subscribeToDeviceMethod(new GetMaxMinReportMethodCallback(), methodName, new MethodIotHubEventCallback(), methodName);\n+\n+        new Thread(new Runnable() {\n+            @SneakyThrows(InterruptedException.class)\n+            @Override\n+            public void run() {\n+                while (true) {\n+                    if (temperatureReset) {\n+                        // Generate a random value between 5.0\u00b0C and 45.0\u00b0C for the current temperature reading.\n+                        temperature = BigDecimal.valueOf(random.nextDouble() * 40 + 5).setScale(1, RoundingMode.HALF_UP).doubleValue();\n+                        temperatureReset = false;\n+                    }\n+\n+                    try {\n+                        sendTemperatureReading();\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(\"IOException when sending reported property update: \", e);\n+                    }\n+\n+                    Thread.sleep(5 * 1000);\n+                }\n+            }\n+        }).start();\n+    }\n+\n+    /**\n+     * Initialize the device client instance over Mqtt protocol, setting the ModelId into ClientOptions.\n+     * This method also sets a connection status change callback, that will get triggered any time the device's connection status changes.\n+     */\n+    private static void initializeDeviceClient() throws URISyntaxException, IOException {\n+        ClientOptions options = new ClientOptions();\n+        options.setModelId(MODEL_ID);\n+        deviceClient = new DeviceClient(deviceConnectionString, protocol, options);\n+\n+        deviceClient.registerConnectionStatusChangeCallback(new IotHubConnectionStatusChangeCallback() {\n+            @Override\n+            public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext) {\n+                log.debug(\"Connection status change registered: status={}, reason={}\", status, statusChangeReason);\n+\n+                if (throwable != null) {\n+                    log.debug(\"The connection status change was caused by the following Throwable: {}\", throwable.getMessage());\n+                    throwable.printStackTrace();\n+                }\n+            }\n+        }, deviceClient);\n+\n+        deviceClient.open();", "originalCommit": "c93671ae42d61410db1b39aa1a75617df8bf0b87", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ2OTk1MA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#discussion_r450469950", "bodyText": "data type to store the embedded property update object.", "author": "abhipsaMisra", "createdAt": "2020-07-06T20:44:50Z", "path": "device/iot-device-samples/pnp-device-sample/Thermostat/src/main/java/samples/com/microsoft/azure/sdk/iot/Thermostat.java", "diffHunk": "@@ -0,0 +1,317 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import com.google.gson.annotations.SerializedName;\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.AllArgsConstructor;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+\n+@Slf4j\n+public class Thermostat {\n+\n+    public enum StatusCode {\n+        COMPLETED (200),\n+        IN_PROGRESS (202),\n+        NOT_FOUND (404);\n+\n+        private final int value;\n+        StatusCode(int value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    private static final String deviceConnectionString = System.getenv(\"IOTHUB_DEVICE_CONNECTION_STRING\");\n+    private static final String MODEL_ID = \"dtmi:com:example:Thermostat;1\";\n+\n+    // Plug and play features are available over either MQTT or MQTT_WS.\n+    private static final IotHubClientProtocol protocol = IotHubClientProtocol.MQTT;\n+\n+    private static final Random random = new Random();\n+    private static final Map<Date, Double> temperatureReadings = new HashMap<>();\n+\n+    private static DeviceClient deviceClient;\n+    private static double temperature = 0.0d;\n+    private static double maxTemperature = 0.0d;\n+    private static boolean temperatureReset = true;\n+\n+    public static void main(String[] args) throws URISyntaxException, IOException {\n+\n+        // This sample follows the following workflow:\n+        // -> Initialize device client instance.\n+        // -> Set handler to receive \"targetTemperature\" updates, and send the received update over reported property.\n+        // -> Set handler to receive \"getMaxMinReport\" command, and send the generated report as command response.\n+        // -> Periodically send \"temperature\" over telemetry.\n+        // -> Send \"maxTempSinceLastReboot\" over property update, when a new max temperature is set.\n+\n+        log.debug(\"Initialize the device client.\");\n+        initializeDeviceClient();\n+\n+        log.debug(\"Start twin and set handler to receive \\\"targetTemperature\\\" updates.\");\n+        deviceClient.startDeviceTwin(new TwinIotHubEventCallback(), null, new TargetTemperatureUpdateCallback(), null);\n+        Map<Property, Pair<TwinPropertyCallBack, Object>> desiredPropertyUpdateCallback =\n+                Collections.singletonMap(\n+                        new Property(\"targetTemperature\", null),\n+                        new Pair<TwinPropertyCallBack, Object>(new TargetTemperatureUpdateCallback(), null));\n+        deviceClient.subscribeToTwinDesiredProperties(desiredPropertyUpdateCallback);\n+\n+        log.debug(\"Set handler to receive \\\"getMaxMinReport\\\" command.\");\n+        String methodName = \"getMaxMinReport\";\n+        deviceClient.subscribeToDeviceMethod(new GetMaxMinReportMethodCallback(), methodName, new MethodIotHubEventCallback(), methodName);\n+\n+        new Thread(new Runnable() {\n+            @SneakyThrows(InterruptedException.class)\n+            @Override\n+            public void run() {\n+                while (true) {\n+                    if (temperatureReset) {\n+                        // Generate a random value between 5.0\u00b0C and 45.0\u00b0C for the current temperature reading.\n+                        temperature = BigDecimal.valueOf(random.nextDouble() * 40 + 5).setScale(1, RoundingMode.HALF_UP).doubleValue();\n+                        temperatureReset = false;\n+                    }\n+\n+                    try {\n+                        sendTemperatureReading();\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(\"IOException when sending reported property update: \", e);\n+                    }\n+\n+                    Thread.sleep(5 * 1000);\n+                }\n+            }\n+        }).start();\n+    }\n+\n+    /**\n+     * Initialize the device client instance over Mqtt protocol, setting the ModelId into ClientOptions.\n+     * This method also sets a connection status change callback, that will get triggered any time the device's connection status changes.\n+     */\n+    private static void initializeDeviceClient() throws URISyntaxException, IOException {\n+        ClientOptions options = new ClientOptions();\n+        options.setModelId(MODEL_ID);\n+        deviceClient = new DeviceClient(deviceConnectionString, protocol, options);\n+\n+        deviceClient.registerConnectionStatusChangeCallback(new IotHubConnectionStatusChangeCallback() {\n+            @Override\n+            public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext) {\n+                log.debug(\"Connection status change registered: status={}, reason={}\", status, statusChangeReason);\n+\n+                if (throwable != null) {\n+                    log.debug(\"The connection status change was caused by the following Throwable: {}\", throwable.getMessage());\n+                    throwable.printStackTrace();\n+                }\n+            }\n+        }, deviceClient);\n+\n+        deviceClient.open();\n+    }\n+\n+    /**\n+     * The desired property update callback, which receives the target temperature as a desired property update,\n+     * and updates the current temperature value over telemetry and reported property update.\n+     */\n+    private static class TargetTemperatureUpdateCallback implements TwinPropertyCallBack {\n+\n+        String propertyName = \"targetTemperature\";\n+\n+        @SneakyThrows(InterruptedException.class)\n+        @Override\n+        public void TwinPropertyCallBack(Property property, Object context) {\n+            if (property.getKey().equalsIgnoreCase(propertyName)) {\n+                double targetTemperature = ((Number)property.getValue()).doubleValue();\n+                log.debug(\"Property: Received - {\\\"{}\\\": {}\u00b0C}.\", propertyName, targetTemperature);\n+\n+                EmbeddedPropertyUpdate pendingUpdate = new EmbeddedPropertyUpdate(targetTemperature, StatusCode.IN_PROGRESS.value, property.getVersion(), null);\n+                Property reportedPropertyPending = new Property(propertyName, pendingUpdate);\n+                try {\n+                    deviceClient.sendReportedProperties(Collections.singleton(reportedPropertyPending));\n+                } catch (IOException e) {\n+                    throw new RuntimeException(\"IOException when sending reported property update: \", e);\n+                }\n+                log.debug(\"Property: Update - {\\\"{}\\\": {}\u00b0C} is {}\", propertyName, targetTemperature, StatusCode.IN_PROGRESS);\n+\n+                // Update temperature in 2 steps\n+                double step = (targetTemperature - temperature) / 2;\n+                for (int i = 1; i <=2; i++) {\n+                    temperature = BigDecimal.valueOf(temperature + step).setScale(1, RoundingMode.HALF_UP).doubleValue();\n+                    Thread.sleep(5 * 1000);\n+                }\n+\n+                EmbeddedPropertyUpdate completedUpdate = new EmbeddedPropertyUpdate(temperature, StatusCode.COMPLETED.value, property.getVersion(), \"Successfully updated target temperature\");\n+                Property reportedPropertyCompleted = new Property(propertyName, completedUpdate);\n+                try {\n+                    deviceClient.sendReportedProperties(Collections.singleton(reportedPropertyCompleted));\n+                } catch (IOException e) {\n+                    throw new RuntimeException(\"IOException when sending reported property update: \", e);\n+                }\n+                log.debug(\"Property: Update - {\\\"{}\\\": {}\u00b0C} is {}\", propertyName, temperature, StatusCode.COMPLETED);\n+            } else {\n+                log.debug(\"Property: Received an unrecognized property update from service.\");\n+            }\n+        }\n+    }\n+\n+    @AllArgsConstructor\n+    private static class EmbeddedPropertyUpdate {", "originalCommit": "c93671ae42d61410db1b39aa1a75617df8bf0b87", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3MDMzOQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#discussion_r450470339", "bodyText": "@timtay-microsoft Is there an easier/ better way to do this parsing in java?", "author": "abhipsaMisra", "createdAt": "2020-07-06T20:45:37Z", "path": "device/iot-device-samples/pnp-device-sample/Thermostat/src/main/java/samples/com/microsoft/azure/sdk/iot/Thermostat.java", "diffHunk": "@@ -0,0 +1,317 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import com.google.gson.annotations.SerializedName;\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.AllArgsConstructor;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+\n+@Slf4j\n+public class Thermostat {\n+\n+    public enum StatusCode {\n+        COMPLETED (200),\n+        IN_PROGRESS (202),\n+        NOT_FOUND (404);\n+\n+        private final int value;\n+        StatusCode(int value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    private static final String deviceConnectionString = System.getenv(\"IOTHUB_DEVICE_CONNECTION_STRING\");\n+    private static final String MODEL_ID = \"dtmi:com:example:Thermostat;1\";\n+\n+    // Plug and play features are available over either MQTT or MQTT_WS.\n+    private static final IotHubClientProtocol protocol = IotHubClientProtocol.MQTT;\n+\n+    private static final Random random = new Random();\n+    private static final Map<Date, Double> temperatureReadings = new HashMap<>();\n+\n+    private static DeviceClient deviceClient;\n+    private static double temperature = 0.0d;\n+    private static double maxTemperature = 0.0d;\n+    private static boolean temperatureReset = true;\n+\n+    public static void main(String[] args) throws URISyntaxException, IOException {\n+\n+        // This sample follows the following workflow:\n+        // -> Initialize device client instance.\n+        // -> Set handler to receive \"targetTemperature\" updates, and send the received update over reported property.\n+        // -> Set handler to receive \"getMaxMinReport\" command, and send the generated report as command response.\n+        // -> Periodically send \"temperature\" over telemetry.\n+        // -> Send \"maxTempSinceLastReboot\" over property update, when a new max temperature is set.\n+\n+        log.debug(\"Initialize the device client.\");\n+        initializeDeviceClient();\n+\n+        log.debug(\"Start twin and set handler to receive \\\"targetTemperature\\\" updates.\");\n+        deviceClient.startDeviceTwin(new TwinIotHubEventCallback(), null, new TargetTemperatureUpdateCallback(), null);\n+        Map<Property, Pair<TwinPropertyCallBack, Object>> desiredPropertyUpdateCallback =\n+                Collections.singletonMap(\n+                        new Property(\"targetTemperature\", null),\n+                        new Pair<TwinPropertyCallBack, Object>(new TargetTemperatureUpdateCallback(), null));\n+        deviceClient.subscribeToTwinDesiredProperties(desiredPropertyUpdateCallback);\n+\n+        log.debug(\"Set handler to receive \\\"getMaxMinReport\\\" command.\");\n+        String methodName = \"getMaxMinReport\";\n+        deviceClient.subscribeToDeviceMethod(new GetMaxMinReportMethodCallback(), methodName, new MethodIotHubEventCallback(), methodName);\n+\n+        new Thread(new Runnable() {\n+            @SneakyThrows(InterruptedException.class)\n+            @Override\n+            public void run() {\n+                while (true) {\n+                    if (temperatureReset) {\n+                        // Generate a random value between 5.0\u00b0C and 45.0\u00b0C for the current temperature reading.\n+                        temperature = BigDecimal.valueOf(random.nextDouble() * 40 + 5).setScale(1, RoundingMode.HALF_UP).doubleValue();\n+                        temperatureReset = false;\n+                    }\n+\n+                    try {\n+                        sendTemperatureReading();\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(\"IOException when sending reported property update: \", e);\n+                    }\n+\n+                    Thread.sleep(5 * 1000);\n+                }\n+            }\n+        }).start();\n+    }\n+\n+    /**\n+     * Initialize the device client instance over Mqtt protocol, setting the ModelId into ClientOptions.\n+     * This method also sets a connection status change callback, that will get triggered any time the device's connection status changes.\n+     */\n+    private static void initializeDeviceClient() throws URISyntaxException, IOException {\n+        ClientOptions options = new ClientOptions();\n+        options.setModelId(MODEL_ID);\n+        deviceClient = new DeviceClient(deviceConnectionString, protocol, options);\n+\n+        deviceClient.registerConnectionStatusChangeCallback(new IotHubConnectionStatusChangeCallback() {\n+            @Override\n+            public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext) {\n+                log.debug(\"Connection status change registered: status={}, reason={}\", status, statusChangeReason);\n+\n+                if (throwable != null) {\n+                    log.debug(\"The connection status change was caused by the following Throwable: {}\", throwable.getMessage());\n+                    throwable.printStackTrace();\n+                }\n+            }\n+        }, deviceClient);\n+\n+        deviceClient.open();\n+    }\n+\n+    /**\n+     * The desired property update callback, which receives the target temperature as a desired property update,\n+     * and updates the current temperature value over telemetry and reported property update.\n+     */\n+    private static class TargetTemperatureUpdateCallback implements TwinPropertyCallBack {\n+\n+        String propertyName = \"targetTemperature\";\n+\n+        @SneakyThrows(InterruptedException.class)\n+        @Override\n+        public void TwinPropertyCallBack(Property property, Object context) {\n+            if (property.getKey().equalsIgnoreCase(propertyName)) {\n+                double targetTemperature = ((Number)property.getValue()).doubleValue();\n+                log.debug(\"Property: Received - {\\\"{}\\\": {}\u00b0C}.\", propertyName, targetTemperature);\n+\n+                EmbeddedPropertyUpdate pendingUpdate = new EmbeddedPropertyUpdate(targetTemperature, StatusCode.IN_PROGRESS.value, property.getVersion(), null);\n+                Property reportedPropertyPending = new Property(propertyName, pendingUpdate);\n+                try {\n+                    deviceClient.sendReportedProperties(Collections.singleton(reportedPropertyPending));\n+                } catch (IOException e) {\n+                    throw new RuntimeException(\"IOException when sending reported property update: \", e);\n+                }\n+                log.debug(\"Property: Update - {\\\"{}\\\": {}\u00b0C} is {}\", propertyName, targetTemperature, StatusCode.IN_PROGRESS);\n+\n+                // Update temperature in 2 steps\n+                double step = (targetTemperature - temperature) / 2;\n+                for (int i = 1; i <=2; i++) {\n+                    temperature = BigDecimal.valueOf(temperature + step).setScale(1, RoundingMode.HALF_UP).doubleValue();\n+                    Thread.sleep(5 * 1000);\n+                }\n+\n+                EmbeddedPropertyUpdate completedUpdate = new EmbeddedPropertyUpdate(temperature, StatusCode.COMPLETED.value, property.getVersion(), \"Successfully updated target temperature\");\n+                Property reportedPropertyCompleted = new Property(propertyName, completedUpdate);\n+                try {\n+                    deviceClient.sendReportedProperties(Collections.singleton(reportedPropertyCompleted));\n+                } catch (IOException e) {\n+                    throw new RuntimeException(\"IOException when sending reported property update: \", e);\n+                }\n+                log.debug(\"Property: Update - {\\\"{}\\\": {}\u00b0C} is {}\", propertyName, temperature, StatusCode.COMPLETED);\n+            } else {\n+                log.debug(\"Property: Received an unrecognized property update from service.\");\n+            }\n+        }\n+    }\n+\n+    @AllArgsConstructor\n+    private static class EmbeddedPropertyUpdate {\n+        @NonNull\n+        @SerializedName(\"value\")\n+        public Object value;\n+        @NonNull\n+        @SerializedName(\"ac\")\n+        public Integer ackCode;\n+        @NonNull\n+        @SerializedName(\"av\")\n+        public Integer ackVersion;\n+        @SerializedName(\"ad\")\n+        public String ackDescription;\n+    }\n+\n+    /**\n+     * The callback to handle \"getMaxMinReport\" command.\n+     * This method will returns the max, min and average temperature from the specified time to the current time.\n+     */\n+    private static class GetMaxMinReportMethodCallback implements DeviceMethodCallback {\n+        String commandName = \"getMaxMinReport\";\n+        String formatPattern = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\";\n+\n+        @SneakyThrows(ParseException.class)\n+        @Override\n+        public DeviceMethodData call(String methodName, Object methodData, Object context) {\n+            if (methodName.equalsIgnoreCase(commandName)) {\n+\n+                String jsonRequest = new String((byte[]) methodData, StandardCharsets.UTF_8);\n+                JsonObject jsonObject = new Gson().fromJson(jsonRequest, JsonObject.class);\n+                String sinceString = jsonObject.get(\"commandRequest\").getAsJsonObject().get(\"value\").getAsString();\n+\n+                DateFormat format = new SimpleDateFormat(formatPattern);", "originalCommit": "c93671ae42d61410db1b39aa1a75617df8bf0b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUxMDkyOQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#discussion_r450510929", "bodyText": "For parsing a datetime? What you have here is pretty standard", "author": "timtay-microsoft", "createdAt": "2020-07-06T22:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3MDMzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUxMTM4OA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#discussion_r450511388", "bodyText": "Java 8 introduced the \"Instant\" class to replace most date time code, so you may find something simpler there", "author": "timtay-microsoft", "createdAt": "2020-07-06T22:26:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3MDMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3MDY5MA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#discussion_r450470690", "bodyText": "I wish we supported Java 8+, we could then use Streams. In the absence of that, we are stuck with implementing this logic manually.", "author": "abhipsaMisra", "createdAt": "2020-07-06T20:46:18Z", "path": "device/iot-device-samples/pnp-device-sample/Thermostat/src/main/java/samples/com/microsoft/azure/sdk/iot/Thermostat.java", "diffHunk": "@@ -0,0 +1,317 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import com.google.gson.annotations.SerializedName;\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.AllArgsConstructor;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+\n+@Slf4j\n+public class Thermostat {\n+\n+    public enum StatusCode {\n+        COMPLETED (200),\n+        IN_PROGRESS (202),\n+        NOT_FOUND (404);\n+\n+        private final int value;\n+        StatusCode(int value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    private static final String deviceConnectionString = System.getenv(\"IOTHUB_DEVICE_CONNECTION_STRING\");\n+    private static final String MODEL_ID = \"dtmi:com:example:Thermostat;1\";\n+\n+    // Plug and play features are available over either MQTT or MQTT_WS.\n+    private static final IotHubClientProtocol protocol = IotHubClientProtocol.MQTT;\n+\n+    private static final Random random = new Random();\n+    private static final Map<Date, Double> temperatureReadings = new HashMap<>();\n+\n+    private static DeviceClient deviceClient;\n+    private static double temperature = 0.0d;\n+    private static double maxTemperature = 0.0d;\n+    private static boolean temperatureReset = true;\n+\n+    public static void main(String[] args) throws URISyntaxException, IOException {\n+\n+        // This sample follows the following workflow:\n+        // -> Initialize device client instance.\n+        // -> Set handler to receive \"targetTemperature\" updates, and send the received update over reported property.\n+        // -> Set handler to receive \"getMaxMinReport\" command, and send the generated report as command response.\n+        // -> Periodically send \"temperature\" over telemetry.\n+        // -> Send \"maxTempSinceLastReboot\" over property update, when a new max temperature is set.\n+\n+        log.debug(\"Initialize the device client.\");\n+        initializeDeviceClient();\n+\n+        log.debug(\"Start twin and set handler to receive \\\"targetTemperature\\\" updates.\");\n+        deviceClient.startDeviceTwin(new TwinIotHubEventCallback(), null, new TargetTemperatureUpdateCallback(), null);\n+        Map<Property, Pair<TwinPropertyCallBack, Object>> desiredPropertyUpdateCallback =\n+                Collections.singletonMap(\n+                        new Property(\"targetTemperature\", null),\n+                        new Pair<TwinPropertyCallBack, Object>(new TargetTemperatureUpdateCallback(), null));\n+        deviceClient.subscribeToTwinDesiredProperties(desiredPropertyUpdateCallback);\n+\n+        log.debug(\"Set handler to receive \\\"getMaxMinReport\\\" command.\");\n+        String methodName = \"getMaxMinReport\";\n+        deviceClient.subscribeToDeviceMethod(new GetMaxMinReportMethodCallback(), methodName, new MethodIotHubEventCallback(), methodName);\n+\n+        new Thread(new Runnable() {\n+            @SneakyThrows(InterruptedException.class)\n+            @Override\n+            public void run() {\n+                while (true) {\n+                    if (temperatureReset) {\n+                        // Generate a random value between 5.0\u00b0C and 45.0\u00b0C for the current temperature reading.\n+                        temperature = BigDecimal.valueOf(random.nextDouble() * 40 + 5).setScale(1, RoundingMode.HALF_UP).doubleValue();\n+                        temperatureReset = false;\n+                    }\n+\n+                    try {\n+                        sendTemperatureReading();\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(\"IOException when sending reported property update: \", e);\n+                    }\n+\n+                    Thread.sleep(5 * 1000);\n+                }\n+            }\n+        }).start();\n+    }\n+\n+    /**\n+     * Initialize the device client instance over Mqtt protocol, setting the ModelId into ClientOptions.\n+     * This method also sets a connection status change callback, that will get triggered any time the device's connection status changes.\n+     */\n+    private static void initializeDeviceClient() throws URISyntaxException, IOException {\n+        ClientOptions options = new ClientOptions();\n+        options.setModelId(MODEL_ID);\n+        deviceClient = new DeviceClient(deviceConnectionString, protocol, options);\n+\n+        deviceClient.registerConnectionStatusChangeCallback(new IotHubConnectionStatusChangeCallback() {\n+            @Override\n+            public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext) {\n+                log.debug(\"Connection status change registered: status={}, reason={}\", status, statusChangeReason);\n+\n+                if (throwable != null) {\n+                    log.debug(\"The connection status change was caused by the following Throwable: {}\", throwable.getMessage());\n+                    throwable.printStackTrace();\n+                }\n+            }\n+        }, deviceClient);\n+\n+        deviceClient.open();\n+    }\n+\n+    /**\n+     * The desired property update callback, which receives the target temperature as a desired property update,\n+     * and updates the current temperature value over telemetry and reported property update.\n+     */\n+    private static class TargetTemperatureUpdateCallback implements TwinPropertyCallBack {\n+\n+        String propertyName = \"targetTemperature\";\n+\n+        @SneakyThrows(InterruptedException.class)\n+        @Override\n+        public void TwinPropertyCallBack(Property property, Object context) {\n+            if (property.getKey().equalsIgnoreCase(propertyName)) {\n+                double targetTemperature = ((Number)property.getValue()).doubleValue();\n+                log.debug(\"Property: Received - {\\\"{}\\\": {}\u00b0C}.\", propertyName, targetTemperature);\n+\n+                EmbeddedPropertyUpdate pendingUpdate = new EmbeddedPropertyUpdate(targetTemperature, StatusCode.IN_PROGRESS.value, property.getVersion(), null);\n+                Property reportedPropertyPending = new Property(propertyName, pendingUpdate);\n+                try {\n+                    deviceClient.sendReportedProperties(Collections.singleton(reportedPropertyPending));\n+                } catch (IOException e) {\n+                    throw new RuntimeException(\"IOException when sending reported property update: \", e);\n+                }\n+                log.debug(\"Property: Update - {\\\"{}\\\": {}\u00b0C} is {}\", propertyName, targetTemperature, StatusCode.IN_PROGRESS);\n+\n+                // Update temperature in 2 steps\n+                double step = (targetTemperature - temperature) / 2;\n+                for (int i = 1; i <=2; i++) {\n+                    temperature = BigDecimal.valueOf(temperature + step).setScale(1, RoundingMode.HALF_UP).doubleValue();\n+                    Thread.sleep(5 * 1000);\n+                }\n+\n+                EmbeddedPropertyUpdate completedUpdate = new EmbeddedPropertyUpdate(temperature, StatusCode.COMPLETED.value, property.getVersion(), \"Successfully updated target temperature\");\n+                Property reportedPropertyCompleted = new Property(propertyName, completedUpdate);\n+                try {\n+                    deviceClient.sendReportedProperties(Collections.singleton(reportedPropertyCompleted));\n+                } catch (IOException e) {\n+                    throw new RuntimeException(\"IOException when sending reported property update: \", e);\n+                }\n+                log.debug(\"Property: Update - {\\\"{}\\\": {}\u00b0C} is {}\", propertyName, temperature, StatusCode.COMPLETED);\n+            } else {\n+                log.debug(\"Property: Received an unrecognized property update from service.\");\n+            }\n+        }\n+    }\n+\n+    @AllArgsConstructor\n+    private static class EmbeddedPropertyUpdate {\n+        @NonNull\n+        @SerializedName(\"value\")\n+        public Object value;\n+        @NonNull\n+        @SerializedName(\"ac\")\n+        public Integer ackCode;\n+        @NonNull\n+        @SerializedName(\"av\")\n+        public Integer ackVersion;\n+        @SerializedName(\"ad\")\n+        public String ackDescription;\n+    }\n+\n+    /**\n+     * The callback to handle \"getMaxMinReport\" command.\n+     * This method will returns the max, min and average temperature from the specified time to the current time.\n+     */\n+    private static class GetMaxMinReportMethodCallback implements DeviceMethodCallback {\n+        String commandName = \"getMaxMinReport\";\n+        String formatPattern = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\";\n+\n+        @SneakyThrows(ParseException.class)\n+        @Override\n+        public DeviceMethodData call(String methodName, Object methodData, Object context) {\n+            if (methodName.equalsIgnoreCase(commandName)) {\n+\n+                String jsonRequest = new String((byte[]) methodData, StandardCharsets.UTF_8);\n+                JsonObject jsonObject = new Gson().fromJson(jsonRequest, JsonObject.class);\n+                String sinceString = jsonObject.get(\"commandRequest\").getAsJsonObject().get(\"value\").getAsString();\n+\n+                DateFormat format = new SimpleDateFormat(formatPattern);\n+                Date since = format.parse(sinceString);\n+                log.debug(\"Command: Received - Generating min, max, avg temperature report since {}.\", since);\n+\n+                double runningTotal = 0;\n+                Map<Date, Double> filteredReadings = new HashMap<>();\n+                for (Map.Entry<Date, Double> entry : temperatureReadings.entrySet()) {", "originalCommit": "c93671ae42d61410db1b39aa1a75617df8bf0b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUxMTczMg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#discussion_r450511732", "bodyText": "We can make the sample support Java 8 if you'd like. Our SDK is about to deprecate Java 7 support anyways", "author": "timtay-microsoft", "createdAt": "2020-07-06T22:27:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3MDY5MA=="}], "type": "inlineReview"}, {"oid": "1a7713e7e90765068af7291568aa8696ceaaed13", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/1a7713e7e90765068af7291568aa8696ceaaed13", "message": "fix formatting", "committedDate": "2020-07-06T21:00:32Z", "type": "commit"}, {"oid": "8ae49478a89835766e8bcdba991c9d7bbef8d78a", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/8ae49478a89835766e8bcdba991c9d7bbef8d78a", "message": "add comments", "committedDate": "2020-07-06T22:12:13Z", "type": "commit"}]}