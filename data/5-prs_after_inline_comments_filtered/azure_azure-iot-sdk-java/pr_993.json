{"pr_number": 993, "pr_title": "Multiplexing samples: Device Client Manager and Multiplexing client manager", "pr_createdAt": "2020-11-16T17:33:19Z", "pr_url": "https://github.com/Azure/azure-iot-sdk-java/pull/993", "timeline": [{"oid": "b9ee67f86ba5cfc36cc8f9b427ce8b4e9f009f98", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/b9ee67f86ba5cfc36cc8f9b427ce8b4e9f009f98", "message": "Reconnection logic added.", "committedDate": "2020-11-16T17:31:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ0OTg5NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r524449895", "bodyText": "@timtay-microsoft  , you rightfully mentioned that we shouldn't be using this implementation and there is an out of the box Pair class in java.\nI found javafx.util.Pair implementation ... is that the one you had in mind?", "author": "azabbasi", "createdAt": "2020-11-16T17:34:33Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;", "originalCommit": "b9ee67f86ba5cfc36cc8f9b427ce8b4e9f009f98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkxOTQwMw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r527919403", "bodyText": "My mistake on this one. I thought there was a pair class within Java's collection namespace, but apparently there isn't. This one should be fine, though, sure.", "author": "timtay-microsoft", "createdAt": "2020-11-20T19:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ0OTg5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyNDA5NA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r527924094", "bodyText": "For reference, there is an interface defined for a class like Pair in Map: https://docs.oracle.com/javase/8/docs/api/java/util/Map.Entry.html\nBut the implementation is private, so we have no access to it", "author": "timtay-microsoft", "createdAt": "2020-11-20T19:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ0OTg5NQ=="}], "type": "inlineReview"}, {"oid": "c4e28a655339273efc8aac13c28a8c7b0c42ec65", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/c4e28a655339273efc8aac13c28a8c7b0c42ec65", "message": "Merge branch 'preview' into azabbasi/multiplexingSamples", "committedDate": "2020-11-17T17:24:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkxOTk4Ng==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r527919986", "bodyText": "Don't hardcode \"10\" into this message. Use the value from the variable below, in case we ever change its value", "author": "timtay-microsoft", "createdAt": "2020-11-20T19:17:23Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+\n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        if (ex.getCause() instanceof TransportException && ((TransportException) ex.getCause()).isRetryable()) {\n+                            log.warn(\"Transport exception thrown while opening DeviceClient instance \" + getClientId() + \", retrying: \", ex);\n+                        } else {\n+                            log.error(\"Non-retryable exception thrown while opening DeviceClient instance \" + getClientId() + \": \", ex);\n+                            connectionStatus = ConnectionStatus.DISCONNECTED;\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            try {\n+                log.debug(\"Sleeping for 10 secs before attempting another open()\");", "originalCommit": "c4e28a655339273efc8aac13c28a8c7b0c42ec65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMDQzOQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r527920439", "bodyText": "Since we are using log.debug everywhere else, can you switch these from System.out to log.info or log.debug?", "author": "timtay-microsoft", "createdAt": "2020-11-20T19:18:21Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+\n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        if (ex.getCause() instanceof TransportException && ((TransportException) ex.getCause()).isRetryable()) {\n+                            log.warn(\"Transport exception thrown while opening DeviceClient instance \" + getClientId() + \", retrying: \", ex);\n+                        } else {\n+                            log.error(\"Non-retryable exception thrown while opening DeviceClient instance \" + getClientId() + \": \", ex);\n+                            connectionStatus = ConnectionStatus.DISCONNECTED;\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            try {\n+                log.debug(\"Sleeping for 10 secs before attempting another open()\");\n+                Thread.sleep(SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS * 1000);\n+            }\n+            catch (InterruptedException ex) {\n+                throw new RuntimeException(\"Interrupted while waiting between attempting to open the client: \", ex);\n+            }\n+        }\n+    }\n+\n+    public void closeNow() {\n+        synchronized (lock) {\n+            try {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException e) {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", e);\n+            } finally {\n+                connectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    public void open() throws IOException {\n+        synchronized (lock) {\n+            if(connectionStatus == ConnectionStatus.DISCONNECTED) {\n+                connectionStatus = ConnectionStatus.CONNECTING;\n+            } else {\n+                return;\n+            }\n+        }\n+        doConnect();\n+    }\n+\n+    @Override\n+    public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext) {\n+        Pair<IotHubConnectionStatusChangeCallback, Object> suppliedCallbackPair = this.suppliedConnectionStatusChangeCallback;\n+        if (throwable == null)\n+        {\n+            System.out.println(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason);", "originalCommit": "c4e28a655339273efc8aac13c28a8c7b0c42ec65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMTM1OA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r527921358", "bodyText": "Add a header here if only to clarify that the multiplexClientId is user-defined, and isn't some Id like deviceId where they get it from the portal.", "author": "timtay-microsoft", "createdAt": "2020-11-20T19:19:59Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexClientManager.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.MultiplexingClient;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This class is in charge of handling reconnection logic and registering callbacks for connection status changes.\n+ * It will delegate all other calls other than `Open`, `Close` and registerConnectionStatusChangeCallbaack to the inner client (MultiplexingClient)\n+ */\n+@Slf4j\n+public class MultiplexClientManager extends ClientManagerBase {\n+\n+    // Define method calls that will not be delegated to the inner client.\n+    private interface DeviceClientNonDelegatedFunction {\n+        void open();\n+        void close();\n+        void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext);\n+    }\n+\n+    // The methods defined in the interface DeviceClientNonDelegatedFunction will be called on MultiplexingClientManager, and not on MultiplexingClient.\n+    @Delegate(excludes = DeviceClientNonDelegatedFunction.class)\n+    private final MultiplexingClient client;\n+    private final String multiplexClientId;\n+\n+    MultiplexClientManager(MultiplexingClient multiplexingClient, String multiplexClientId) {", "originalCommit": "c4e28a655339273efc8aac13c28a8c7b0c42ec65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "message": "Address comments", "committedDate": "2020-11-23T17:47:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkwMzc3Ng==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528903776", "bodyText": "I'd suggest swapping this condition to handle the positive case first", "author": "drwill-ms", "createdAt": "2020-11-23T18:14:47Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {", "originalCommit": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkwMzk4OQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528903989", "bodyText": "space after if", "author": "drwill-ms", "createdAt": "2020-11-23T18:15:07Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {", "originalCommit": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkwNDgwNQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528904805", "bodyText": "Is openClient() synchronous, such that after it completes we can be sure we're connected?\nShouldn't we wait for a callback that says we're connected to change this internally tracked state to connected?", "author": "drwill-ms", "createdAt": "2020-11-23T18:16:33Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;", "originalCommit": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkxNjk5NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528916995", "bodyText": "Yes, it is synchronous.", "author": "azabbasi", "createdAt": "2020-11-23T18:38:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkwNDgwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkzNjQ0MA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528936440", "bodyText": "What do you think about using the callback confirmation to change the cached state vs. setting it here?", "author": "drwill-ms", "createdAt": "2020-11-23T19:13:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkwNDgwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA0Mzk1Ng==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r529043956", "bodyText": "You mean in the execute method instead of doConnect ? sure, we can certainly do that, I am curious to know why you think that's a better approach?\nas I mentioned, if openClient doesn't throw, it means it successfully established the connection. also, the \"connection status change callback\" is basically invoked every time there is a change, and that doesn't exactly (or \"accurately\") maps to the states we are maintaining in this class.", "author": "azabbasi", "createdAt": "2020-11-23T22:44:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkwNDgwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxODI5Mw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532818293", "bodyText": "Because getting confirmation from the SDK client that we've connected is more affirmative than asserting it should be connected.", "author": "drwill-ms", "createdAt": "2020-11-30T18:43:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkwNDgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkxODI3Nw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528918277", "bodyText": "Suggest changing this to != connecting, and return, so the remaining code doesn't have to be tabbed in 1 more", "author": "drwill-ms", "createdAt": "2020-11-23T18:40:47Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {", "originalCommit": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkxODgwNw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528918807", "bodyText": "Why is locking not necessary here when changing this state but is elsewhere?", "author": "drwill-ms", "createdAt": "2020-11-23T18:41:45Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        if (ex.getCause() instanceof TransportException && ((TransportException) ex.getCause()).isRetryable()) {\n+                            log.warn(\"Transport exception thrown while opening DeviceClient instance \" + getClientId() + \", retrying: \", ex);\n+                        } else {\n+                            log.error(\"Non-retryable exception thrown while opening DeviceClient instance \" + getClientId() + \": \", ex);\n+                            connectionStatus = ConnectionStatus.DISCONNECTED;\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            try {\n+                log.debug(\"Sleeping for \" + SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS + \" secs before attempting another open()\");\n+                Thread.sleep(SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS * 1000);\n+            }\n+            catch (InterruptedException ex) {\n+                throw new RuntimeException(\"Interrupted while waiting between attempting to open the client: \", ex);\n+            }\n+        }\n+    }\n+\n+    public void closeNow() {\n+        synchronized (lock) {\n+            try {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException e) {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", e);\n+            } finally {\n+                connectionStatus = ConnectionStatus.DISCONNECTED;", "originalCommit": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyMjk5MQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528922991", "bodyText": "The finally statement is also in the synchronized block. Am I missing something?", "author": "azabbasi", "createdAt": "2020-11-23T18:49:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkxODgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0ODQwNQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528948405", "bodyText": "I wasn't looking broadly enough to see it is in a larger lock. Do we want this entire operation locked?\nI thought the lock was just for conditionally acting on and changing the state of the cached last known connection status", "author": "drwill-ms", "createdAt": "2020-11-23T19:35:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkxODgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA0MjI1Ng==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r529042256", "bodyText": "This block is updating the connectionStatus and opening the client (in which if there is no exceptions, means it's successful) ... so I think having it in the synchronized block is justified .\nDid I understand your comment correctly?", "author": "azabbasi", "createdAt": "2020-11-23T22:40:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkxODgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyMTI3Ng==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528921276", "bodyText": "very inconsistent brace usage in this file", "author": "drwill-ms", "createdAt": "2020-11-23T18:46:16Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        if (ex.getCause() instanceof TransportException && ((TransportException) ex.getCause()).isRetryable()) {\n+                            log.warn(\"Transport exception thrown while opening DeviceClient instance \" + getClientId() + \", retrying: \", ex);\n+                        } else {\n+                            log.error(\"Non-retryable exception thrown while opening DeviceClient instance \" + getClientId() + \": \", ex);\n+                            connectionStatus = ConnectionStatus.DISCONNECTED;\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            try {\n+                log.debug(\"Sleeping for \" + SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS + \" secs before attempting another open()\");\n+                Thread.sleep(SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS * 1000);\n+            }\n+            catch (InterruptedException ex) {\n+                throw new RuntimeException(\"Interrupted while waiting between attempting to open the client: \", ex);\n+            }\n+        }\n+    }\n+\n+    public void closeNow() {\n+        synchronized (lock) {\n+            try {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException e) {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", e);\n+            } finally {\n+                connectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    public void open() throws IOException {\n+        synchronized (lock) {\n+            if(connectionStatus == ConnectionStatus.DISCONNECTED) {\n+                connectionStatus = ConnectionStatus.CONNECTING;\n+            } else {\n+                return;\n+            }\n+        }\n+        doConnect();\n+    }\n+\n+    @Override\n+    public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext) {\n+        Pair<IotHubConnectionStatusChangeCallback, Object> suppliedCallbackPair = this.suppliedConnectionStatusChangeCallback;\n+        if (throwable == null)\n+        {", "originalCommit": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyMzIyMQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528923221", "bodyText": "fixing.", "author": "azabbasi", "createdAt": "2020-11-23T18:49:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyMTI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyNjA0MA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528926040", "bodyText": "lastKnownConnectionStatus?", "author": "drwill-ms", "createdAt": "2020-11-23T18:54:48Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;", "originalCommit": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA0MTQwNA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r529041404", "bodyText": "I like that", "author": "azabbasi", "createdAt": "2020-11-23T22:38:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyNjA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyNzU2Mw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528927563", "bodyText": "It doesn't handle that state. It detects that state, right?", "author": "drwill-ms", "createdAt": "2020-11-23T18:57:26Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        if (ex.getCause() instanceof TransportException && ((TransportException) ex.getCause()).isRetryable()) {\n+                            log.warn(\"Transport exception thrown while opening DeviceClient instance \" + getClientId() + \", retrying: \", ex);\n+                        } else {\n+                            log.error(\"Non-retryable exception thrown while opening DeviceClient instance \" + getClientId() + \": \", ex);\n+                            connectionStatus = ConnectionStatus.DISCONNECTED;\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            try {\n+                log.debug(\"Sleeping for \" + SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS + \" secs before attempting another open()\");\n+                Thread.sleep(SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS * 1000);\n+            }\n+            catch (InterruptedException ex) {\n+                throw new RuntimeException(\"Interrupted while waiting between attempting to open the client: \", ex);\n+            }\n+        }\n+    }\n+\n+    public void closeNow() {\n+        synchronized (lock) {\n+            try {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException e) {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", e);\n+            } finally {\n+                connectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    public void open() throws IOException {\n+        synchronized (lock) {\n+            if(connectionStatus == ConnectionStatus.DISCONNECTED) {\n+                connectionStatus = ConnectionStatus.CONNECTING;\n+            } else {\n+                return;\n+            }\n+        }\n+        doConnect();\n+    }\n+\n+    @Override\n+    public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext) {\n+        Pair<IotHubConnectionStatusChangeCallback, Object> suppliedCallbackPair = this.suppliedConnectionStatusChangeCallback;\n+        if (throwable == null)\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason);\n+        }\n+        else\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason + \", \" + throwable.getMessage());\n+            throwable.printStackTrace();\n+        }\n+\n+        if (shouldDeviceReconnect(status, statusChangeReason, throwable)) {\n+            if (suppliedCallbackPair != null) {\n+                suppliedCallbackPair.getKey().execute(DISCONNECTED_RETRYING, NO_NETWORK, throwable, suppliedCallbackPair.getValue());\n+            }\n+\n+            handleRecoverableDisconnection();\n+        } else if (suppliedCallbackPair != null) {\n+            suppliedCallbackPair.getKey().execute(status, statusChangeReason, throwable, suppliedCallbackPair.getValue());\n+        }\n+    }\n+\n+    // This handles the state where the DeviceClient reports that OperationTimeout has expired, and stops retrying; even though the applied RetryPolicy is still valid.", "originalCommit": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyNzkzOA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528927938", "bodyText": "Given this is a sample and that the task is complex, it is going to need way more code comments.\nI'd like to see high level approach, and then for each method how it fits into the larger picture.", "author": "drwill-ms", "createdAt": "2020-11-23T18:58:06Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;", "originalCommit": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0Nzc0Nw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528947747", "bodyText": "good point. will add a lot more comments.", "author": "azabbasi", "createdAt": "2020-11-23T19:33:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyNzkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyODM0Nw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528928347", "bodyText": "Does Java share this antipattern with C#? That is, throw ex; vs throw;?", "author": "drwill-ms", "createdAt": "2020-11-23T18:58:50Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        if (ex.getCause() instanceof TransportException && ((TransportException) ex.getCause()).isRetryable()) {\n+                            log.warn(\"Transport exception thrown while opening DeviceClient instance \" + getClientId() + \", retrying: \", ex);\n+                        } else {\n+                            log.error(\"Non-retryable exception thrown while opening DeviceClient instance \" + getClientId() + \": \", ex);\n+                            connectionStatus = ConnectionStatus.DISCONNECTED;\n+                            throw ex;", "originalCommit": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0ODcyOA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528948728", "bodyText": "no, you always have to throw an exception in the throw statement.", "author": "azabbasi", "createdAt": "2020-11-23T19:35:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyODM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyOTI3Mg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528929272", "bodyText": "Again, I think this would read easier if it was formatted as:\nsynchronized (lock) {\n    if (connectionStatus != ConnectionStatus.DISCONNECTED) {\n        return;\n    }\n\n    connectionStatus = ConnectionStatus.CONNECTING;\n}\n\ndoConnect();", "author": "drwill-ms", "createdAt": "2020-11-23T19:00:35Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        if (ex.getCause() instanceof TransportException && ((TransportException) ex.getCause()).isRetryable()) {\n+                            log.warn(\"Transport exception thrown while opening DeviceClient instance \" + getClientId() + \", retrying: \", ex);\n+                        } else {\n+                            log.error(\"Non-retryable exception thrown while opening DeviceClient instance \" + getClientId() + \": \", ex);\n+                            connectionStatus = ConnectionStatus.DISCONNECTED;\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            try {\n+                log.debug(\"Sleeping for \" + SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS + \" secs before attempting another open()\");\n+                Thread.sleep(SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS * 1000);\n+            }\n+            catch (InterruptedException ex) {\n+                throw new RuntimeException(\"Interrupted while waiting between attempting to open the client: \", ex);\n+            }\n+        }\n+    }\n+\n+    public void closeNow() {\n+        synchronized (lock) {\n+            try {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException e) {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", e);\n+            } finally {\n+                connectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    public void open() throws IOException {\n+        synchronized (lock) {\n+            if(connectionStatus == ConnectionStatus.DISCONNECTED) {", "originalCommit": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkzNzM0NA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528937344", "bodyText": "callback is 1 word", "author": "drwill-ms", "createdAt": "2020-11-23T19:15:07Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.", "originalCommit": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkzOTEyMA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528939120", "bodyText": "Perhaps this belongs on the client wrapper classes we have?", "author": "drwill-ms", "createdAt": "2020-11-23T19:18:15Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexingSample.java", "diffHunk": "@@ -193,22 +122,34 @@ public static void main(String[] args)\n         String deviceIdToUnregister = deviceIds.get(0);\n \n         System.out.println(\"Unregistering device \" + deviceIdToUnregister + \" from multiplexed connection...\");\n-        multiplexingClient.unregisterDeviceClient(multiplexedDeviceClients.get(deviceIdToUnregister));\n+        multiplexClientManager.unregisterDeviceClient(multiplexedDeviceClients.get(deviceIdToUnregister));\n         System.out.println(\"Successfully unregistered device \" + deviceIdToUnregister + \" from an active multiplexed connection.\");\n \n         // This code demonstrates how to add a device to an active multiplexed connection without shutting down\n         // the whole multiplexed connection or any of the other devices.\n         System.out.println(\"Re-registering device \" + deviceIdToUnregister + \" to an active multiplexed connection...\");\n-        multiplexingClient.registerDeviceClient(multiplexedDeviceClients.get(deviceIdToUnregister));\n+        multiplexClientManager.registerDeviceClient(multiplexedDeviceClients.get(deviceIdToUnregister));\n         System.out.println(\"Successfully registered \" + deviceIdToUnregister + \" to an active multiplexed connection\");\n \n         // Before closing a multiplexing client, you do not need to unregister all of the registered clients.\n         // If they are not unregistered, then you can re-open the multiplexing client later and it will still\n         // have all of your registered devices\n-\n         System.out.println(\"Closing entire multiplexed connection...\");\n         // This call will close all multiplexed device client instances as well\n-        multiplexingClient.close();\n+        multiplexClientManager.closeClient();\n         System.out.println(\"Successfully closed the multiplexed connection\");\n+\n+        System.out.println(\"Shutting down...\");\n+    }\n+\n+    private static int acknowledgedSentMessages = 0;\n+    private static class TelemetryAcknowledgedEventCallback implements IotHubEventCallback", "originalCommit": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4Nzg3NA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532887874", "bodyText": "I think that would complicate the logic in client managers unnecessarily. Let's discuss this further if you feel really strongly about this.", "author": "azabbasi", "createdAt": "2020-11-30T20:37:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkzOTEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0MDA4MA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528940080", "bodyText": "Where is this used?", "author": "drwill-ms", "createdAt": "2020-11-23T19:20:00Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexClientManager.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.MultiplexingClient;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This class is in charge of handling reconnection logic and registering callbacks for connection status changes.\n+ * It will delegate all other calls other than `Open`, `Close` and registerConnectionStatusChangeCallbaack to the inner client (MultiplexingClient)\n+ */\n+@Slf4j\n+public class MultiplexClientManager extends ClientManagerBase {\n+\n+    // Define method calls that will not be delegated to the inner client.\n+    private interface DeviceClientNonDelegatedFunction {\n+        void open();\n+        void close();\n+        void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext);\n+    }\n+\n+    // The methods defined in the interface DeviceClientNonDelegatedFunction will be called on MultiplexingClientManager, and not on MultiplexingClient.\n+    @Delegate(excludes = DeviceClientNonDelegatedFunction.class)\n+    private final MultiplexingClient client;\n+    private final String multiplexClientId;\n+\n+    /**\n+     * Creates an instance of the MultiplexClientManager\n+     *\n+     * @param multiplexingClient the multiplexing client\n+     * @param multiplexClientId user defined Id for the multiplexing client.\n+     */\n+    MultiplexClientManager(MultiplexingClient multiplexingClient, String multiplexClientId) {\n+        this.connectionStatus = ConnectionStatus.DISCONNECTED;\n+        this.client = multiplexingClient;\n+        this.multiplexClientId = multiplexClientId;", "originalCommit": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0MDE5Nw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528940197", "bodyText": "Just for logging, I guess?", "author": "drwill-ms", "createdAt": "2020-11-23T19:20:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0MDA4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk1MjUyMw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528952523", "bodyText": "correct.", "author": "azabbasi", "createdAt": "2020-11-23T19:42:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0MDA4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2NTc4NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528965785", "bodyText": "Perhaps that makes me wonder why the multiplexing client doesn't have a way to uniquely identify it.\nAnytime we have to write code in our samples (especially each time), I think that is a sign we are missing something in our client library. Do you agree?", "author": "drwill-ms", "createdAt": "2020-11-23T20:07:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0MDA4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAyNjcxOA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r529026718", "bodyText": "well, the question is how would you actually uniquely identify the multiplexing client? we either have to assign a random identifier to it as a metadata upon initialization, or take it as an input form the user. I don't know how much value there is in providing extra metadata to identify the multiplexing client ...", "author": "azabbasi", "createdAt": "2020-11-23T22:06:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0MDA4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA0MDUyOQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r529040529", "bodyText": "The multiplexing client doesn't need to be identified to the service, but it would be for local use, as you've done with logging. I'd make it an optional, read-only property on the multiplexing client. If not provided, we could initialize it with a GUID - maybe not.", "author": "drwill-ms", "createdAt": "2020-11-23T22:36:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0MDA4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg3ODE0MQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532878141", "bodyText": "I think at this stage since this is a sample code and it's only used for logging purposes taking it as a parameter in the constructor is reasonable. but I do agree that if at some point users start managing multiple multiplexingClients in their code, there might be a good argument that these clients should be easily identifiable which requires the core SDK logic to change (which is an addition and should be fine)", "author": "azabbasi", "createdAt": "2020-11-30T20:18:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0MDA4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0MTE3Mw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528941173", "bodyText": "Why wouldn't this be set to DISCONNECTED?", "author": "drwill-ms", "createdAt": "2020-11-23T19:22:04Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        if (ex.getCause() instanceof TransportException && ((TransportException) ex.getCause()).isRetryable()) {\n+                            log.warn(\"Transport exception thrown while opening DeviceClient instance \" + getClientId() + \", retrying: \", ex);\n+                        } else {\n+                            log.error(\"Non-retryable exception thrown while opening DeviceClient instance \" + getClientId() + \": \", ex);\n+                            connectionStatus = ConnectionStatus.DISCONNECTED;\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            try {\n+                log.debug(\"Sleeping for \" + SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS + \" secs before attempting another open()\");\n+                Thread.sleep(SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS * 1000);\n+            }\n+            catch (InterruptedException ex) {\n+                throw new RuntimeException(\"Interrupted while waiting between attempting to open the client: \", ex);\n+            }\n+        }\n+    }\n+\n+    public void closeNow() {\n+        synchronized (lock) {\n+            try {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException e) {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", e);\n+            } finally {\n+                connectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    public void open() throws IOException {\n+        synchronized (lock) {\n+            if(connectionStatus == ConnectionStatus.DISCONNECTED) {\n+                connectionStatus = ConnectionStatus.CONNECTING;\n+            } else {\n+                return;\n+            }\n+        }\n+        doConnect();\n+    }\n+\n+    @Override\n+    public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext) {\n+        Pair<IotHubConnectionStatusChangeCallback, Object> suppliedCallbackPair = this.suppliedConnectionStatusChangeCallback;\n+        if (throwable == null)\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason);\n+        }\n+        else\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason + \", \" + throwable.getMessage());\n+            throwable.printStackTrace();\n+        }\n+\n+        if (shouldDeviceReconnect(status, statusChangeReason, throwable)) {\n+            if (suppliedCallbackPair != null) {\n+                suppliedCallbackPair.getKey().execute(DISCONNECTED_RETRYING, NO_NETWORK, throwable, suppliedCallbackPair.getValue());\n+            }\n+\n+            handleRecoverableDisconnection();\n+        } else if (suppliedCallbackPair != null) {\n+            suppliedCallbackPair.getKey().execute(status, statusChangeReason, throwable, suppliedCallbackPair.getValue());\n+        }\n+    }\n+\n+    // This handles the state where the DeviceClient reports that OperationTimeout has expired, and stops retrying; even though the applied RetryPolicy is still valid.\n+    protected boolean shouldDeviceReconnect(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable) {\n+        return (status == DISCONNECTED && statusChangeReason == RETRY_EXPIRED && throwable instanceof DeviceOperationTimeoutException);\n+    }\n+\n+    public void handleRecoverableDisconnection() {\n+        synchronized (lock) {\n+            if (connectionStatus == ConnectionStatus.CONNECTED) {\n+                new Thread(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        log.debug(\"Attempting reconnect for client: \" + getClientId() + \" ...\");\n+                        synchronized (lock) {\n+                            if (connectionStatus == ConnectionStatus.CONNECTED) {\n+                                try {\n+                                    closeClient();\n+                                } catch (Exception e) {\n+                                    log.warn(\"Client \" + getClientId() + \" closeNow failed.\", e);\n+                                } finally {\n+                                    connectionStatus = ConnectionStatus.CONNECTING;", "originalCommit": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2MTk4OA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528961988", "bodyText": "The DISCONNECTED status represents a final disconnected (and not going to retry) status. Connecting is basically saying, we are trying to open this connection and it's not yet connected.", "author": "azabbasi", "createdAt": "2020-11-23T20:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0MTE3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2NTE5NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528965195", "bodyText": "That might be evident to a sample reader, such as myself, if the enum values had comments describing what they are and when they are used", "author": "drwill-ms", "createdAt": "2020-11-23T20:06:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0MTE3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4Njg1OQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532786859", "bodyText": "Comments added", "author": "azabbasi", "createdAt": "2020-11-30T17:51:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0MTE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0MTk3MQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528941971", "bodyText": "Any reason not to use the same exception variable name throughout? We have ex and e in some places.", "author": "drwill-ms", "createdAt": "2020-11-23T19:23:42Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        if (ex.getCause() instanceof TransportException && ((TransportException) ex.getCause()).isRetryable()) {\n+                            log.warn(\"Transport exception thrown while opening DeviceClient instance \" + getClientId() + \", retrying: \", ex);\n+                        } else {\n+                            log.error(\"Non-retryable exception thrown while opening DeviceClient instance \" + getClientId() + \": \", ex);\n+                            connectionStatus = ConnectionStatus.DISCONNECTED;\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            try {\n+                log.debug(\"Sleeping for \" + SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS + \" secs before attempting another open()\");\n+                Thread.sleep(SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS * 1000);\n+            }\n+            catch (InterruptedException ex) {\n+                throw new RuntimeException(\"Interrupted while waiting between attempting to open the client: \", ex);\n+            }\n+        }\n+    }\n+\n+    public void closeNow() {\n+        synchronized (lock) {\n+            try {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException e) {", "originalCommit": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0Mjk4NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528942985", "bodyText": "The class comment says this is the base class for device and multiplexing manager clients, but this comment mentions the device client.", "author": "drwill-ms", "createdAt": "2020-11-23T19:25:18Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        if (ex.getCause() instanceof TransportException && ((TransportException) ex.getCause()).isRetryable()) {\n+                            log.warn(\"Transport exception thrown while opening DeviceClient instance \" + getClientId() + \", retrying: \", ex);", "originalCommit": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk1NTQ4OQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528955489", "bodyText": "my bad, fixing.", "author": "azabbasi", "createdAt": "2020-11-23T19:48:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0Mjk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0NDQ3NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528944475", "bodyText": "How might/should the multiplexing connection status callback calls (where the status is disconnected_retrying) affect the device client manager statuses? They may still think they are connected, but they aren't. Or are they getting the callback too, and if so, what action are they taking?", "author": "drwill-ms", "createdAt": "2020-11-23T19:27:52Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexClientManager.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.MultiplexingClient;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This class is in charge of handling reconnection logic and registering callbacks for connection status changes.\n+ * It will delegate all other calls other than `Open`, `Close` and registerConnectionStatusChangeCallbaack to the inner client (MultiplexingClient)\n+ */\n+@Slf4j\n+public class MultiplexClientManager extends ClientManagerBase {\n+\n+    // Define method calls that will not be delegated to the inner client.\n+    private interface DeviceClientNonDelegatedFunction {\n+        void open();\n+        void close();\n+        void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext);\n+    }\n+\n+    // The methods defined in the interface DeviceClientNonDelegatedFunction will be called on MultiplexingClientManager, and not on MultiplexingClient.\n+    @Delegate(excludes = DeviceClientNonDelegatedFunction.class)\n+    private final MultiplexingClient client;\n+    private final String multiplexClientId;\n+\n+    /**\n+     * Creates an instance of the MultiplexClientManager\n+     *\n+     * @param multiplexingClient the multiplexing client\n+     * @param multiplexClientId user defined Id for the multiplexing client.\n+     */\n+    MultiplexClientManager(MultiplexingClient multiplexingClient, String multiplexClientId) {\n+        this.connectionStatus = ConnectionStatus.DISCONNECTED;\n+        this.client = multiplexingClient;\n+        this.multiplexClientId = multiplexClientId;\n+        this.client.registerConnectionStatusChangeCallback(this, this);", "originalCommit": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAyNjkxMg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r529026912", "bodyText": "let's chat about this in the live review together.", "author": "azabbasi", "createdAt": "2020-11-23T22:07:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0NDQ3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0NTgzNw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528945837", "bodyText": "What's the difference between getClientId() and suppliedCallbackPair.getValue()? Are they both the device Id?", "author": "drwill-ms", "createdAt": "2020-11-23T19:30:10Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        if (ex.getCause() instanceof TransportException && ((TransportException) ex.getCause()).isRetryable()) {\n+                            log.warn(\"Transport exception thrown while opening DeviceClient instance \" + getClientId() + \", retrying: \", ex);\n+                        } else {\n+                            log.error(\"Non-retryable exception thrown while opening DeviceClient instance \" + getClientId() + \": \", ex);\n+                            connectionStatus = ConnectionStatus.DISCONNECTED;\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            try {\n+                log.debug(\"Sleeping for \" + SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS + \" secs before attempting another open()\");\n+                Thread.sleep(SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS * 1000);\n+            }\n+            catch (InterruptedException ex) {\n+                throw new RuntimeException(\"Interrupted while waiting between attempting to open the client: \", ex);\n+            }\n+        }\n+    }\n+\n+    public void closeNow() {\n+        synchronized (lock) {\n+            try {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException e) {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", e);\n+            } finally {\n+                connectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    public void open() throws IOException {\n+        synchronized (lock) {\n+            if(connectionStatus == ConnectionStatus.DISCONNECTED) {\n+                connectionStatus = ConnectionStatus.CONNECTING;\n+            } else {\n+                return;\n+            }\n+        }\n+        doConnect();\n+    }\n+\n+    @Override\n+    public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext) {\n+        Pair<IotHubConnectionStatusChangeCallback, Object> suppliedCallbackPair = this.suppliedConnectionStatusChangeCallback;\n+        if (throwable == null)\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason);\n+        }\n+        else\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason + \", \" + throwable.getMessage());\n+            throwable.printStackTrace();\n+        }\n+\n+        if (shouldDeviceReconnect(status, statusChangeReason, throwable)) {\n+            if (suppliedCallbackPair != null) {\n+                suppliedCallbackPair.getKey().execute(DISCONNECTED_RETRYING, NO_NETWORK, throwable, suppliedCallbackPair.getValue());", "originalCommit": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk1OTM2Ng==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528959366", "bodyText": "in this case, yes, they are both deviceId/multiplexing client Id", "author": "azabbasi", "createdAt": "2020-11-23T19:55:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0NTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2NzAzNg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528967036", "bodyText": "Seems could be a source of confusion for a sample reader when we use both in the same function.", "author": "drwill-ms", "createdAt": "2020-11-23T20:09:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0NTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg1MzM5Mw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532853393", "bodyText": "The suppliedCallbackPair is removed. We no longer have this issue.", "author": "azabbasi", "createdAt": "2020-11-30T19:42:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0NTgzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0NjMxMQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528946311", "bodyText": "2 spaces after return => 1", "author": "drwill-ms", "createdAt": "2020-11-23T19:30:59Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexClientManager.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.MultiplexingClient;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This class is in charge of handling reconnection logic and registering callbacks for connection status changes.\n+ * It will delegate all other calls other than `Open`, `Close` and registerConnectionStatusChangeCallbaack to the inner client (MultiplexingClient)\n+ */\n+@Slf4j\n+public class MultiplexClientManager extends ClientManagerBase {\n+\n+    // Define method calls that will not be delegated to the inner client.\n+    private interface DeviceClientNonDelegatedFunction {\n+        void open();\n+        void close();\n+        void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext);\n+    }\n+\n+    // The methods defined in the interface DeviceClientNonDelegatedFunction will be called on MultiplexingClientManager, and not on MultiplexingClient.\n+    @Delegate(excludes = DeviceClientNonDelegatedFunction.class)\n+    private final MultiplexingClient client;\n+    private final String multiplexClientId;\n+\n+    /**\n+     * Creates an instance of the MultiplexClientManager\n+     *\n+     * @param multiplexingClient the multiplexing client\n+     * @param multiplexClientId user defined Id for the multiplexing client.\n+     */\n+    MultiplexClientManager(MultiplexingClient multiplexingClient, String multiplexClientId) {\n+        this.connectionStatus = ConnectionStatus.DISCONNECTED;\n+        this.client = multiplexingClient;\n+        this.multiplexClientId = multiplexClientId;\n+        this.client.registerConnectionStatusChangeCallback(this, this);\n+    }\n+\n+    @Override\n+    public void openClient() throws IOException {\n+        this.client.open();\n+    }\n+\n+    @Override\n+    public void closeClient() throws IOException {\n+        this.client.close();\n+    }\n+\n+    @Override\n+    public String getClientId() {\n+        return  multiplexClientId;", "originalCommit": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0NjQyMA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528946420", "bodyText": "space before brace", "author": "drwill-ms", "createdAt": "2020-11-23T19:31:10Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexClientManager.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.MultiplexingClient;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This class is in charge of handling reconnection logic and registering callbacks for connection status changes.\n+ * It will delegate all other calls other than `Open`, `Close` and registerConnectionStatusChangeCallbaack to the inner client (MultiplexingClient)\n+ */\n+@Slf4j\n+public class MultiplexClientManager extends ClientManagerBase {\n+\n+    // Define method calls that will not be delegated to the inner client.\n+    private interface DeviceClientNonDelegatedFunction {\n+        void open();\n+        void close();\n+        void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext);\n+    }\n+\n+    // The methods defined in the interface DeviceClientNonDelegatedFunction will be called on MultiplexingClientManager, and not on MultiplexingClient.\n+    @Delegate(excludes = DeviceClientNonDelegatedFunction.class)\n+    private final MultiplexingClient client;\n+    private final String multiplexClientId;\n+\n+    /**\n+     * Creates an instance of the MultiplexClientManager\n+     *\n+     * @param multiplexingClient the multiplexing client\n+     * @param multiplexClientId user defined Id for the multiplexing client.\n+     */\n+    MultiplexClientManager(MultiplexingClient multiplexingClient, String multiplexClientId) {\n+        this.connectionStatus = ConnectionStatus.DISCONNECTED;\n+        this.client = multiplexingClient;\n+        this.multiplexClientId = multiplexClientId;\n+        this.client.registerConnectionStatusChangeCallback(this, this);\n+    }\n+\n+    @Override\n+    public void openClient() throws IOException {\n+        this.client.open();\n+    }\n+\n+    @Override\n+    public void closeClient() throws IOException {\n+        this.client.close();\n+    }\n+\n+    @Override\n+    public String getClientId() {\n+        return  multiplexClientId;\n+    }\n+\n+    public MultiplexingClient getMultiplexClient(){", "originalCommit": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3d1da1b587953ee4680a3cf18989495decaf5e73", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/3d1da1b587953ee4680a3cf18989495decaf5e73", "message": "Address comments", "committedDate": "2020-11-24T19:39:25Z", "type": "commit"}, {"oid": "17a7c2866b18ba138223cc74483571bccf480aaf", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/17a7c2866b18ba138223cc74483571bccf480aaf", "message": "formatting", "committedDate": "2020-11-24T19:47:02Z", "type": "commit"}, {"oid": "7620bdff266881584f521a4ae707ea50af018180", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/7620bdff266881584f521a4ae707ea50af018180", "message": "Update ClientManagerBase.java", "committedDate": "2020-11-24T19:51:23Z", "type": "commit"}, {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/5826833250201d6a8cc339cde06d6e90fdc23201", "message": "Update ClientManagerBase.java", "committedDate": "2020-11-24T21:27:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5MjEyNw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532792127", "bodyText": "In .NET we'd make this abstract to ensure the inheriting class implemented it. Does Java have an analog?", "author": "drwill-ms", "createdAt": "2020-11-30T17:59:51Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change callback exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback, ConnectionStatusTracker\n+{\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+\n+    // Initialize the connection status as DISCONNECTED\n+    protected ConnectionStatus lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+\n+    // Tracks connection status of the dependency connection (multiplexing client connection status for example in this case for DeviceClientManager)\n+    protected ConnectionStatusTracker dependencyConnectionStatusTracker;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    // Since the client manager is in charge of handling the connection status callback, this method is a no-op\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)", "originalCommit": "5826833250201d6a8cc339cde06d6e90fdc23201", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzNzQ5Mw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532837493", "bodyText": "There is the same concept in java, I didn't make it abstract because there is nothing to override, we don't want the subclasses to do anything with this, we just want to make sure the call is delegated to the ClientManager and it doesn't do anything. we can discuss it in more depth if you like.", "author": "azabbasi", "createdAt": "2020-11-30T19:16:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5MjEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5MjUxMA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532792510", "bodyText": "Why closeNow() instead of just close()?", "author": "drwill-ms", "createdAt": "2020-11-30T18:00:24Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change callback exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback, ConnectionStatusTracker\n+{\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+\n+    // Initialize the connection status as DISCONNECTED\n+    protected ConnectionStatus lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+\n+    // Tracks connection status of the dependency connection (multiplexing client connection status for example in this case for DeviceClientManager)\n+    protected ConnectionStatusTracker dependencyConnectionStatusTracker;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    // Since the client manager is in charge of handling the connection status callback, this method is a no-op\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)\n+    {\n+        return;\n+    }\n+\n+    public void closeNow()", "originalCommit": "5826833250201d6a8cc339cde06d6e90fdc23201", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg3MDAyOQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532870029", "bodyText": "That is an excellent question.\nDeviceClient has two different method signatures, close() and closeNow(). close() has been deprecated\nclient managers for both DeviceClient and MultiplexingClient are setup such that any call that you make to them they will delegate to the inner client except for open, close and registerConnectionStatusCallback\nNow there are 2 different method signatures on the DeviceClient for closing the connection, and we want to make sure we delegate those calls to the client manager and it knows how to override both of those methods.", "author": "azabbasi", "createdAt": "2020-11-30T20:03:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5MjUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5Mjk1Mg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532792952", "bodyText": "As previous block returns, else is not necessary", "author": "drwill-ms", "createdAt": "2020-11-30T18:00:59Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change callback exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback, ConnectionStatusTracker\n+{\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+\n+    // Initialize the connection status as DISCONNECTED\n+    protected ConnectionStatus lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+\n+    // Tracks connection status of the dependency connection (multiplexing client connection status for example in this case for DeviceClientManager)\n+    protected ConnectionStatusTracker dependencyConnectionStatusTracker;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    // Since the client manager is in charge of handling the connection status callback, this method is a no-op\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)\n+    {\n+        return;\n+    }\n+\n+    public void closeNow()\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            try\n+            {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException ex)\n+            {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", ex);\n+            }\n+            finally\n+            {\n+                // Once the connection is closed, set the Status to DISCONNECTED\n+                lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    // When client manager is being opened it first makes sure the client is in a DISCONNECTED state\n+    // If the client is in CONNECTING or CONNECTED state, Open will be no-op.\n+    public void open() throws IOException\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            // Do not attempt to CONNECT if the connection status is not DISCONNECTED. This ensure that only one process is going to attempt to connect\n+            if (lastKnownConnectionStatus != ConnectionStatus.DISCONNECTED)\n+            {\n+                return;\n+            }\n+            else", "originalCommit": "5826833250201d6a8cc339cde06d6e90fdc23201", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5MzEwNg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532793106", "bodyText": "Same, why not just connect()?", "author": "drwill-ms", "createdAt": "2020-11-30T18:01:16Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change callback exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback, ConnectionStatusTracker\n+{\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+\n+    // Initialize the connection status as DISCONNECTED\n+    protected ConnectionStatus lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+\n+    // Tracks connection status of the dependency connection (multiplexing client connection status for example in this case for DeviceClientManager)\n+    protected ConnectionStatusTracker dependencyConnectionStatusTracker;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    // Since the client manager is in charge of handling the connection status callback, this method is a no-op\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)\n+    {\n+        return;\n+    }\n+\n+    public void closeNow()\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            try\n+            {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException ex)\n+            {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", ex);\n+            }\n+            finally\n+            {\n+                // Once the connection is closed, set the Status to DISCONNECTED\n+                lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    // When client manager is being opened it first makes sure the client is in a DISCONNECTED state\n+    // If the client is in CONNECTING or CONNECTED state, Open will be no-op.\n+    public void open() throws IOException\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            // Do not attempt to CONNECT if the connection status is not DISCONNECTED. This ensure that only one process is going to attempt to connect\n+            if (lastKnownConnectionStatus != ConnectionStatus.DISCONNECTED)\n+            {\n+                return;\n+            }\n+            else\n+            {\n+                // Set the connection status to CONNECTING\n+                lastKnownConnectionStatus = ConnectionStatus.CONNECTING;\n+            }\n+        }\n+\n+        establishConnection();", "originalCommit": "5826833250201d6a8cc339cde06d6e90fdc23201", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5MzYzMQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532793631", "bodyText": "Let's avoid the verb execute. It doesn't pass PoliCheck.", "author": "drwill-ms", "createdAt": "2020-11-30T18:02:09Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change callback exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback, ConnectionStatusTracker\n+{\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+\n+    // Initialize the connection status as DISCONNECTED\n+    protected ConnectionStatus lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+\n+    // Tracks connection status of the dependency connection (multiplexing client connection status for example in this case for DeviceClientManager)\n+    protected ConnectionStatusTracker dependencyConnectionStatusTracker;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    // Since the client manager is in charge of handling the connection status callback, this method is a no-op\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)\n+    {\n+        return;\n+    }\n+\n+    public void closeNow()\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            try\n+            {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException ex)\n+            {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", ex);\n+            }\n+            finally\n+            {\n+                // Once the connection is closed, set the Status to DISCONNECTED\n+                lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    // When client manager is being opened it first makes sure the client is in a DISCONNECTED state\n+    // If the client is in CONNECTING or CONNECTED state, Open will be no-op.\n+    public void open() throws IOException\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            // Do not attempt to CONNECT if the connection status is not DISCONNECTED. This ensure that only one process is going to attempt to connect\n+            if (lastKnownConnectionStatus != ConnectionStatus.DISCONNECTED)\n+            {\n+                return;\n+            }\n+            else\n+            {\n+                // Set the connection status to CONNECTING\n+                lastKnownConnectionStatus = ConnectionStatus.CONNECTING;\n+            }\n+        }\n+\n+        establishConnection();\n+    }\n+\n+    @Override\n+    public ConnectionStatus getConnectionStatus(){\n+        return this.lastKnownConnectionStatus;\n+    }\n+\n+    @Override\n+    public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext)", "originalCommit": "5826833250201d6a8cc339cde06d6e90fdc23201", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxMTE5Mg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532811192", "bodyText": "I don't think we can avoid it, it's in our SDK interface and we have to implement it :(", "author": "azabbasi", "createdAt": "2020-11-30T18:30:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5MzYzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxOTM0NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532819345", "bodyText": "Which SDK? The legacy DeviceClient or the new MultiplexingClient?", "author": "drwill-ms", "createdAt": "2020-11-30T18:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5MzYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NDYwNw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532794607", "bodyText": "For readability, consider putting each condition on a newline:\nreturn status == DISCONNECTED\n    && statusChangeReason == RETRY_EXPIRED\n    && throwable instanceof DeviceOperationTimeoutException;", "author": "drwill-ms", "createdAt": "2020-11-30T18:03:49Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change callback exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback, ConnectionStatusTracker\n+{\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+\n+    // Initialize the connection status as DISCONNECTED\n+    protected ConnectionStatus lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+\n+    // Tracks connection status of the dependency connection (multiplexing client connection status for example in this case for DeviceClientManager)\n+    protected ConnectionStatusTracker dependencyConnectionStatusTracker;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    // Since the client manager is in charge of handling the connection status callback, this method is a no-op\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)\n+    {\n+        return;\n+    }\n+\n+    public void closeNow()\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            try\n+            {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException ex)\n+            {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", ex);\n+            }\n+            finally\n+            {\n+                // Once the connection is closed, set the Status to DISCONNECTED\n+                lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    // When client manager is being opened it first makes sure the client is in a DISCONNECTED state\n+    // If the client is in CONNECTING or CONNECTED state, Open will be no-op.\n+    public void open() throws IOException\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            // Do not attempt to CONNECT if the connection status is not DISCONNECTED. This ensure that only one process is going to attempt to connect\n+            if (lastKnownConnectionStatus != ConnectionStatus.DISCONNECTED)\n+            {\n+                return;\n+            }\n+            else\n+            {\n+                // Set the connection status to CONNECTING\n+                lastKnownConnectionStatus = ConnectionStatus.CONNECTING;\n+            }\n+        }\n+\n+        establishConnection();\n+    }\n+\n+    @Override\n+    public ConnectionStatus getConnectionStatus(){\n+        return this.lastKnownConnectionStatus;\n+    }\n+\n+    @Override\n+    public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext)\n+    {\n+        if (throwable == null)\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason);\n+        }\n+        else\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason + \", \" + throwable.getMessage());\n+            throwable.printStackTrace();\n+        }\n+\n+        if (shouldDeviceReconnect(status, statusChangeReason, throwable))\n+        {\n+            handleRecoverableDisconnection();\n+        }\n+    }\n+\n+    // This detects the state where the DeviceClient reports that OperationTimeout has expired, and stops retrying; even though the applied RetryPolicy is still valid.\n+    // The logic to identify whether or not the connection should be established lives in this method.\n+    // The client will automatically retry to establish the connection if the error is retryable\n+    protected boolean shouldDeviceReconnect(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable)\n+    {\n+        return (status == DISCONNECTED && statusChangeReason == RETRY_EXPIRED && throwable instanceof DeviceOperationTimeoutException);", "originalCommit": "5826833250201d6a8cc339cde06d6e90fdc23201", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NTU0OA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532795548", "bodyText": "Same idea as above, splitting conditions on multiple lines; it will also reduce line length here which is getting a bit long", "author": "drwill-ms", "createdAt": "2020-11-30T18:05:23Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change callback exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback, ConnectionStatusTracker\n+{\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+\n+    // Initialize the connection status as DISCONNECTED\n+    protected ConnectionStatus lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+\n+    // Tracks connection status of the dependency connection (multiplexing client connection status for example in this case for DeviceClientManager)\n+    protected ConnectionStatusTracker dependencyConnectionStatusTracker;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    // Since the client manager is in charge of handling the connection status callback, this method is a no-op\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)\n+    {\n+        return;\n+    }\n+\n+    public void closeNow()\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            try\n+            {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException ex)\n+            {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", ex);\n+            }\n+            finally\n+            {\n+                // Once the connection is closed, set the Status to DISCONNECTED\n+                lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    // When client manager is being opened it first makes sure the client is in a DISCONNECTED state\n+    // If the client is in CONNECTING or CONNECTED state, Open will be no-op.\n+    public void open() throws IOException\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            // Do not attempt to CONNECT if the connection status is not DISCONNECTED. This ensure that only one process is going to attempt to connect\n+            if (lastKnownConnectionStatus != ConnectionStatus.DISCONNECTED)\n+            {\n+                return;\n+            }\n+            else\n+            {\n+                // Set the connection status to CONNECTING\n+                lastKnownConnectionStatus = ConnectionStatus.CONNECTING;\n+            }\n+        }\n+\n+        establishConnection();\n+    }\n+\n+    @Override\n+    public ConnectionStatus getConnectionStatus(){\n+        return this.lastKnownConnectionStatus;\n+    }\n+\n+    @Override\n+    public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext)\n+    {\n+        if (throwable == null)\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason);\n+        }\n+        else\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason + \", \" + throwable.getMessage());\n+            throwable.printStackTrace();\n+        }\n+\n+        if (shouldDeviceReconnect(status, statusChangeReason, throwable))\n+        {\n+            handleRecoverableDisconnection();\n+        }\n+    }\n+\n+    // This detects the state where the DeviceClient reports that OperationTimeout has expired, and stops retrying; even though the applied RetryPolicy is still valid.\n+    // The logic to identify whether or not the connection should be established lives in this method.\n+    // The client will automatically retry to establish the connection if the error is retryable\n+    protected boolean shouldDeviceReconnect(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable)\n+    {\n+        return (status == DISCONNECTED && statusChangeReason == RETRY_EXPIRED && throwable instanceof DeviceOperationTimeoutException);\n+    }\n+\n+    // We only expect the connection status to be CONNECTED by the time we enter this state.\n+    public void handleRecoverableDisconnection() {\n+        // If the lastKnownConnectionStatus is not in a CONNECTED state it can mean two things:\n+        // 1: the status is CONNECTING, in which case there is nothing to be done at this time.\n+        // 2: the status is DISCONNECTED, in which case connection cannot be re-established.\n+        if (lastKnownConnectionStatus == ConnectionStatus.CONNECTED)\n+        {\n+            new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    log.debug(\"Attempting reconnect for client: \" + getClientId() + \" ...\");\n+                    synchronized (lastKnownConnectionStatus)\n+                    {\n+                        if (lastKnownConnectionStatus == ConnectionStatus.CONNECTED)\n+                        {\n+                            try\n+                            {\n+                                closeClient();\n+                            }\n+                            catch (Exception ex)\n+                            {\n+                                log.warn(\"Client \" + getClientId() + \" closeNow failed.\", ex);\n+                            }\n+                            finally\n+                            {\n+                                lastKnownConnectionStatus = ConnectionStatus.CONNECTING;\n+                            }\n+                        }\n+                        else\n+                        {\n+                            log.debug(\"Client `\" + getClientId() + \"` is currently connecting; skipping...\");\n+                            return;\n+                        }\n+                    }\n+\n+                    // The client is now closed and the connection status is CONNECTING. Connection can be established now.\n+                    try\n+                    {\n+                        establishConnection();\n+                    }\n+                    catch (IOException ex)\n+                    {\n+                        log.error(\"Exception thrown while opening client instance: \" + getClientId(), ex);\n+                    }\n+                }\n+            }).start();\n+        }\n+    }\n+\n+    public void establishConnection() throws IOException\n+    {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        // Lock the lastKnownConnectionStus so no other process will be able to change it while the client manager is attempting to open the connection.\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            while (lastKnownConnectionStatus == ConnectionStatus.CONNECTING)\n+            {\n+                // If the client has dependencies to another client (in this case it could be the multiplexing client) we have to wait to make sure the\n+                // dependent connection is established first.\n+                if (dependencyConnectionStatusTracker != null && dependencyConnectionStatusTracker.getConnectionStatus() == ConnectionStatus.CONNECTING)", "originalCommit": "5826833250201d6a8cc339cde06d6e90fdc23201", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5ODQzNg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532798436", "bodyText": "comment", "author": "drwill-ms", "createdAt": "2020-11-30T18:10:11Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ConnectionStatusTracker.java", "diffHunk": "@@ -0,0 +1,6 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+public interface ConnectionStatusTracker", "originalCommit": "5826833250201d6a8cc339cde06d6e90fdc23201", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5ODYzNA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532798634", "bodyText": "baack", "author": "drwill-ms", "createdAt": "2020-11-30T18:10:29Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/DeviceClientManager.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceClient;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This class is in charge of handling reconnection logic and registering callbacks for connection status changes.\n+ * It will delegate all other calls other than `Open`, `Close` and registerConnectionStatusChangeCallbaack to the inner client (DeviceClient)", "originalCommit": "5826833250201d6a8cc339cde06d6e90fdc23201", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5OTAyOA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532799028", "bodyText": "I don't know if markdown works for Java doc comments, but you have the first two methods enclosed in backticks, but not the third. We should decorate them consistently.", "author": "drwill-ms", "createdAt": "2020-11-30T18:11:10Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/DeviceClientManager.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceClient;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This class is in charge of handling reconnection logic and registering callbacks for connection status changes.\n+ * It will delegate all other calls other than `Open`, `Close` and registerConnectionStatusChangeCallbaack to the inner client (DeviceClient)", "originalCommit": "5826833250201d6a8cc339cde06d6e90fdc23201", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxNjkyNg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532816926", "bodyText": "Lots of \"clients\" to distinguish. Perhaps call this sdkClient?", "author": "drwill-ms", "createdAt": "2020-11-30T18:41:03Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexClientManager.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.MultiplexingClient;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This class is in charge of handling reconnection logic and registering callbacks for connection status changes.\n+ * It will delegate all other calls other than `Open`, `Close` and registerConnectionStatusChangeCallbaack to the inner client (MultiplexingClient)\n+ */\n+@Slf4j\n+public class MultiplexClientManager extends ClientManagerBase\n+{\n+    // Define method calls that will not be delegated to the inner client.\n+    private interface DeviceClientNonDelegatedFunction\n+    {\n+        void open();\n+        void close();\n+        void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext);\n+    }\n+\n+    // The methods defined in the interface DeviceClientNonDelegatedFunction will be called on MultiplexingClientManager, and not on MultiplexingClient.\n+    @Delegate(excludes = DeviceClientNonDelegatedFunction.class)\n+    private final MultiplexingClient client;", "originalCommit": "5826833250201d6a8cc339cde06d6e90fdc23201", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg1NDYyNg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532854626", "bodyText": "named them each after what they represent. deviceClient and multiplexingClient respectively in both DeviceClientManager and MultiplexClientManager", "author": "azabbasi", "createdAt": "2020-11-30T19:44:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxNjkyNg=="}], "type": "inlineReview"}, {"oid": "723391617e06cb9c19e63ddaef216120cbbeefd0", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/723391617e06cb9c19e63ddaef216120cbbeefd0", "message": "Address more CR comments", "committedDate": "2020-11-30T20:37:57Z", "type": "commit"}, {"oid": "4c221e7863877392c91caacefcef1159ad6c5e8c", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/4c221e7863877392c91caacefcef1159ad6c5e8c", "message": "more comment fixes.", "committedDate": "2020-11-30T20:42:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkwMzUwNQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532903505", "bodyText": "Why is this indented twice?", "author": "drwill-ms", "createdAt": "2020-11-30T21:06:42Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,255 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change callback exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback, ConnectionStatusTracker\n+{\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+\n+    /**\n+     * Initialize the connection status as DISCONNECTED\n+     */\n+    protected ConnectionStatus lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+\n+    // Tracks connection status of the dependency connection (multiplexing client connection status for example in this case for DeviceClientManager)\n+    protected ConnectionStatusTracker dependencyConnectionStatusTracker;\n+\n+    /**\n+     * All classes that extend ClientManagerBase should implement how their inner client can be opened.\n+     */\n+    protected abstract void openClient() throws IOException;\n+\n+    /**\n+     * All classes that extend ClientManagerBase should implement how their inner client can be closed.\n+     */\n+    protected abstract void closeClient() throws IOException;\n+\n+    /**\n+     * All classes that extend ClientManagerBase should implement how their inner client can be identified for logging purposes.\n+     */\n+    public abstract String getClientId();\n+\n+    /**\n+     * Since the client manager is in charge of handling the connection status callback, this method is a no-op.\n+     * This method is not an abstract method since in this sample there is no need for the user to register a connection status callback\n+     * @param callback The callback function.\n+     * @param callbackContext The callback context\n+     */\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)\n+    {\n+        return;\n+    }\n+\n+    public void close()\n+    {\n+        closeNow();\n+    }\n+\n+    public void closeNow()\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            try\n+            {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException ex)\n+            {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", ex);\n+            }\n+            finally\n+            {\n+                // Once the connection is closed, set the Status to DISCONNECTED\n+                lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * When client manager is being opened it first makes sure the client is in a DISCONNECTED state\n+     * If the client is in CONNECTING or CONNECTED state, Open will be no-op.\n+     * @throws IOException\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            // Do not attempt to CONNECT if the connection status is not DISCONNECTED. This ensure that only one process is going to attempt to connect\n+            if (lastKnownConnectionStatus != ConnectionStatus.DISCONNECTED)\n+            {\n+                return;\n+            }\n+\n+            // Set the connection status to CONNECTING\n+            lastKnownConnectionStatus = ConnectionStatus.CONNECTING;\n+        }\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public ConnectionStatus getConnectionStatus(){\n+        return this.lastKnownConnectionStatus;\n+    }\n+\n+    @Override\n+    public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext)\n+    {\n+        if (throwable == null)\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason);\n+        }\n+        else\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason + \", \" + throwable.getMessage());\n+            throwable.printStackTrace();\n+        }\n+\n+        if (shouldClientReconnect(status, statusChangeReason, throwable))\n+        {\n+            handleRecoverableDisconnection();\n+        }\n+    }\n+\n+    /**\n+     * This detects the state where the DeviceClient reports that OperationTimeout has expired, and sto\n+     * The logic to identify whether or not the connection should be established lives in this method.\n+     * The client will automatically retry to establish the connection if the error is retryable\n+     */\n+    protected boolean shouldClientReconnect(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable)\n+    {\n+        return status == DISCONNECTED\n+                && statusChangeReason == RETRY_EXPIRED", "originalCommit": "4c221e7863877392c91caacefcef1159ad6c5e8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6774d8e48b80b5a0485d09979694859698c6af92", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/6774d8e48b80b5a0485d09979694859698c6af92", "message": "Update ClientManagerBase.java", "committedDate": "2020-11-30T21:53:25Z", "type": "commit"}]}