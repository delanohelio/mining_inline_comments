{"pr_number": 1002, "pr_title": "feat(iot-dev): Add client constructors that take sas token provider interface", "pr_createdAt": "2020-11-19T00:25:05Z", "pr_url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002", "timeline": [{"oid": "c5b631848ff8c9555404e2a58761288c0ad0f4fe", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/c5b631848ff8c9555404e2a58761288c0ad0f4fe", "message": "feat(iot-dev): Add client constructors that take sas token provider interface", "committedDate": "2020-11-19T00:25:19Z", "type": "forcePushed"}, {"oid": "bb3b3c64a8ca03121a9420a5c2eb9dfcc706f0ec", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/bb3b3c64a8ca03121a9420a5c2eb9dfcc706f0ec", "message": "feat(iot-dev): Add client constructors that take sas token provider interface", "committedDate": "2020-11-19T18:50:08Z", "type": "forcePushed"}, {"oid": "80c28ecc041f85599b338661eff8c1f1fc81abb5", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/80c28ecc041f85599b338661eff8c1f1fc81abb5", "message": "feat(iot-dev): Add client constructors that take sas token provider interface", "committedDate": "2020-11-19T18:50:47Z", "type": "commit"}, {"oid": "80c28ecc041f85599b338661eff8c1f1fc81abb5", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/80c28ecc041f85599b338661eff8c1f1fc81abb5", "message": "feat(iot-dev): Add client constructors that take sas token provider interface", "committedDate": "2020-11-19T18:50:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEyODQ2MA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527128460", "bodyText": "Is AMQPS a thing? or should this be AMQP?", "author": "barustum", "createdAt": "2020-11-19T19:04:05Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/SasTokenProvider.java", "diffHunk": "@@ -0,0 +1,34 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.microsoft.azure.sdk.iot.device;\n+\n+/**\n+ * Interface for allowing users to control SAS token generation. To see an example of how SAS tokens can be generated\n+ * from device connection strings, see {@link com.microsoft.azure.sdk.iot.device.auth.IotHubSasToken}.\n+ * @see <a href=\"https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-devguide-security#example\">This document</a> for more details on sas tokens.\n+ */\n+public interface SasTokenProvider\n+{\n+    /**\n+     * Returns a SAS token to be used for authentication.\n+     * <p>\n+     * This function will be called each time the client library needs a SAS token. This will follow different patterns\n+     * based on which protocol your client object is using.\n+     * <p>\n+     * For HTTPS, this function will be called for each HTTPS request made (for instance, once per telemetry send), and does not need\n+     * to be a unique token each time. Because of that, users may simply cache and return the same SAS token repeatedly here.\n+     * Alternatively, users can generate very short-lived SAS tokens since they will only need to be valid for a relative short period of time.\n+     * The user of this API is responsible for tracking when to renew the SAS token based on how long the previous token was valid for.\n+     * <p>\n+     * For AMQPS/AMQPS_WS, this function will be called once when first opening the connection, and then will be called again", "originalCommit": "80c28ecc041f85599b338661eff8c1f1fc81abb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzOTA3MQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527139071", "bodyText": "\"AMQP\" is to \"AMQPS\" what \"HTTP\" is to \"HTTPS\". Typically we say AMQPS because we do SSL handshakes when opening AMQP connections to secure them", "author": "timtay-microsoft", "createdAt": "2020-11-19T19:21:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEyODQ2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0NjAwNw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527146007", "bodyText": "This doesn't apply to MQTT then?", "author": "drwill-ms", "createdAt": "2020-11-19T19:33:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEyODQ2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkxNjU5OQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527916599", "bodyText": "You'd think it would, but I don't think \"MQTTS\" is a thing, terminology-wise. Our MQTT connections always do an SSL handshake though, just like HTTPS and AMQPS/AMQPS_WS.", "author": "timtay-microsoft", "createdAt": "2020-11-20T19:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEyODQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEyOTA2OA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527129068", "bodyText": "How come no tricks? `clientOptions?.sslContext\n:(", "author": "drwill-ms", "createdAt": "2020-11-19T19:05:06Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceClientConfig.java", "diffHunk": "@@ -144,6 +144,22 @@ public DeviceClientConfig(IotHubAuthenticationProvider authenticationProvider) t\n         this.productInfo = new ProductInfo();\n     }\n \n+\n+    public DeviceClientConfig(String hostName, SasTokenProvider sasTokenProvider, ClientOptions clientOptions, String deviceId, String moduleId)\n+    {\n+        this.authenticationProvider = new IotHubSasTokenProvidedAuthenticationProvider(\n+                hostName,\n+                deviceId,\n+                moduleId,\n+                sasTokenProvider,\n+                clientOptions != null ? clientOptions.sslContext : null);", "originalCommit": "80c28ecc041f85599b338661eff8c1f1fc81abb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzOTQ5Ng==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527139496", "bodyText": "Because Java :(", "author": "timtay-microsoft", "createdAt": "2020-11-19T19:22:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEyOTA2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMDExNg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527130116", "bodyText": "Is this not customer public (e.g. breaking change)?", "author": "drwill-ms", "createdAt": "2020-11-19T19:06:59Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/auth/IotHubSasTokenHardwareAuthenticationProvider.java", "diffHunk": "@@ -65,25 +65,14 @@ public IotHubSasTokenHardwareAuthenticationProvider(String hostname, String gate\n     /**\n      * Getter for SasToken. If the saved token has expired, this method shall renew it if possible\n      *\n-     * @param proactivelyRenew if true, this method will generate a fresh sas token even if the previously saved token\n-     *                                 has not expired yet as long as the current token has lived beyond its buffer.\n-     *                                 Use this for pre-emptively renewing sas tokens.\n-\n      * @throws IOException if generating the sas token from the TPM fails\n      * @return The value of SasToken\n      */\n-    public String getRenewedSasToken(boolean proactivelyRenew, boolean forceRenewal) throws IOException", "originalCommit": "80c28ecc041f85599b338661eff8c1f1fc81abb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzOTYzNw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527139637", "bodyText": "This is not customer public, no", "author": "timtay-microsoft", "createdAt": "2020-11-19T19:22:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMDExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMDY1MA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527130650", "bodyText": "SAS as it is an acronym", "author": "drwill-ms", "createdAt": "2020-11-19T19:08:01Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/auth/IotHubSasTokenProvidedAuthenticationProvider.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+*  Copyright (c) Microsoft. All rights reserved.\n+*  Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+*/\n+\n+package com.microsoft.azure.sdk.iot.device.auth;\n+\n+import com.microsoft.azure.sdk.iot.device.SasTokenProvider;\n+\n+import javax.net.ssl.SSLContext;\n+\n+public class IotHubSasTokenProvidedAuthenticationProvider extends IotHubSasTokenAuthenticationProvider\n+{\n+    SasTokenProvider sasTokenProvider;\n+    char[] lastSasToken;\n+\n+    public IotHubSasTokenProvidedAuthenticationProvider(String hostName, String deviceId, String moduleId, SasTokenProvider sasTokenProvider, SSLContext sslContext) {\n+        super(hostName, null, deviceId, moduleId, sslContext);\n+\n+        if (sasTokenProvider == null)\n+        {\n+            throw new IllegalArgumentException(\"sas token provider cannot be null\");", "originalCommit": "80c28ecc041f85599b338661eff8c1f1fc81abb5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMTI2Nw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527131267", "bodyText": "Why is this false? If it can be refreshed, wouldn't renewal be necessary?", "author": "drwill-ms", "createdAt": "2020-11-19T19:09:04Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/auth/IotHubSasTokenProvidedAuthenticationProvider.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+*  Copyright (c) Microsoft. All rights reserved.\n+*  Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+*/\n+\n+package com.microsoft.azure.sdk.iot.device.auth;\n+\n+import com.microsoft.azure.sdk.iot.device.SasTokenProvider;\n+\n+import javax.net.ssl.SSLContext;\n+\n+public class IotHubSasTokenProvidedAuthenticationProvider extends IotHubSasTokenAuthenticationProvider\n+{\n+    SasTokenProvider sasTokenProvider;\n+    char[] lastSasToken;\n+\n+    public IotHubSasTokenProvidedAuthenticationProvider(String hostName, String deviceId, String moduleId, SasTokenProvider sasTokenProvider, SSLContext sslContext) {\n+        super(hostName, null, deviceId, moduleId, sslContext);\n+\n+        if (sasTokenProvider == null)\n+        {\n+            throw new IllegalArgumentException(\"sas token provider cannot be null\");\n+        }\n+\n+        this.sasTokenProvider = sasTokenProvider;\n+    }\n+\n+    @Override\n+    public boolean isRenewalNecessary()\n+    {\n+        return false;", "originalCommit": "80c28ecc041f85599b338661eff8c1f1fc81abb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0MTMxNA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527141314", "bodyText": "This function is more about \"Does the customer need to create a new client because they created this client with a SAS token rather than a symmetric key, and that SAS token has expired\"", "author": "timtay-microsoft", "createdAt": "2020-11-19T19:25:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMTI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0MTUwNQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527141505", "bodyText": "Since the user is providing all the SAS tokens, this function should never return true.", "author": "timtay-microsoft", "createdAt": "2020-11-19T19:25:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMTI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0MjcxOA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527142718", "bodyText": "Or maybe canRefreshToken() should be false then?", "author": "drwill-ms", "createdAt": "2020-11-19T19:27:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMTI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE1ODg1Ng==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527158856", "bodyText": "Oh, this isn't the impl for when a SAS-token provided? I'm confused.", "author": "drwill-ms", "createdAt": "2020-11-19T19:54:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMTI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI3OTUyMA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527279520", "bodyText": "Let me just rename this method to help with the confusion.", "author": "timtay-microsoft", "createdAt": "2020-11-19T23:48:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMTI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMjU3OA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527132578", "bodyText": "Meaningful class comment", "author": "drwill-ms", "createdAt": "2020-11-19T19:11:11Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/auth/IotHubSasTokenProvidedAuthenticationProvider.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+*  Copyright (c) Microsoft. All rights reserved.\n+*  Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+*/\n+\n+package com.microsoft.azure.sdk.iot.device.auth;\n+\n+import com.microsoft.azure.sdk.iot.device.SasTokenProvider;\n+\n+import javax.net.ssl.SSLContext;\n+\n+public class IotHubSasTokenProvidedAuthenticationProvider extends IotHubSasTokenAuthenticationProvider", "originalCommit": "80c28ecc041f85599b338661eff8c1f1fc81abb5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMzE5Mw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527133193", "bodyText": "I don't see any code referring to 85%", "author": "drwill-ms", "createdAt": "2020-11-19T19:12:14Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/auth/IotHubSasTokenProvidedAuthenticationProvider.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+*  Copyright (c) Microsoft. All rights reserved.\n+*  Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+*/\n+\n+package com.microsoft.azure.sdk.iot.device.auth;\n+\n+import com.microsoft.azure.sdk.iot.device.SasTokenProvider;\n+\n+import javax.net.ssl.SSLContext;\n+\n+public class IotHubSasTokenProvidedAuthenticationProvider extends IotHubSasTokenAuthenticationProvider\n+{\n+    SasTokenProvider sasTokenProvider;\n+    char[] lastSasToken;\n+\n+    public IotHubSasTokenProvidedAuthenticationProvider(String hostName, String deviceId, String moduleId, SasTokenProvider sasTokenProvider, SSLContext sslContext) {\n+        super(hostName, null, deviceId, moduleId, sslContext);\n+\n+        if (sasTokenProvider == null)\n+        {\n+            throw new IllegalArgumentException(\"sas token provider cannot be null\");\n+        }\n+\n+        this.sasTokenProvider = sasTokenProvider;\n+    }\n+\n+    @Override\n+    public boolean isRenewalNecessary()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    public void setTokenValidSecs(long tokenValidSecs)\n+    {\n+        throw new UnsupportedOperationException(\"Cannot configure sas token time to live when custom sas token provider is in use\");\n+    }\n+\n+    @Override\n+    public boolean canRefreshToken()\n+    {\n+        return true;\n+    }\n+\n+    @Override\n+    public char[] getSasToken()\n+    {\n+        lastSasToken = sasTokenProvider.getSasToken();\n+        return lastSasToken;\n+    }\n+\n+    @Override\n+    public int getMillisecondsBeforeProactiveRenewal()\n+    {\n+        // Seconds since UNIX epoch when this sas token will expire\n+        long expiryTimeSeconds = IotHubSasToken.getExpiryTimeFromToken(new String(lastSasToken));\n+\n+        // Assuming that the token's life \"starts\" now for the sake of figuring out when it needs to be renewed. Users\n+        // could theoretically give us a SAS token that started a while ago, but since we have no way of figuring that out,\n+        // we will conservatively just renew at 85% of the remaining time on the token, rather than 85% of the time the token", "originalCommit": "80c28ecc041f85599b338661eff8c1f1fc81abb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0MjQ5Mw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527142493", "bodyText": "That sits in a class that this class extends", "author": "timtay-microsoft", "createdAt": "2020-11-19T19:27:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMzE5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0NzY2Nw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527147667", "bodyText": "Seems all the talk about 85% then is irrelevant there. That responsibility is delegated to the base class. If it changes in the base class, this comment would be wrong, so best to just abstract it and say, the base class schedules early renewal via this.timeBufferPercentage, and we'll adhere to that in this impl.", "author": "drwill-ms", "createdAt": "2020-11-19T19:35:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMzE5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkxNjY2OA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527916668", "bodyText": "Good idea", "author": "timtay-microsoft", "createdAt": "2020-11-20T19:11:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzMzE5Mw=="}], "type": "inlineReview"}, {"oid": "43e6b38caec46a1e29128d56e67fde7d54c16e24", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/43e6b38caec46a1e29128d56e67fde7d54c16e24", "message": "feedback", "committedDate": "2020-11-19T19:27:40Z", "type": "commit"}, {"oid": "af179dfd7fe12b83fde20f31b4cd00751dfdde11", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/af179dfd7fe12b83fde20f31b4cd00751dfdde11", "message": "feedback", "committedDate": "2020-11-19T23:40:01Z", "type": "commit"}, {"oid": "617f075af09615026f4f329046908a771bc10fa6", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/617f075af09615026f4f329046908a771bc10fa6", "message": "fixup", "committedDate": "2020-11-19T23:53:12Z", "type": "commit"}, {"oid": "a74da4005303d57fc9ff09911bf40ff713395f88", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/a74da4005303d57fc9ff09911bf40ff713395f88", "message": "squash", "committedDate": "2020-11-20T00:33:14Z", "type": "commit"}, {"oid": "7c7446ad6ad2858a0b5c5fc53caa25e3e1ca4273", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/7c7446ad6ad2858a0b5c5fc53caa25e3e1ca4273", "message": "feedback", "committedDate": "2020-11-20T18:35:47Z", "type": "commit"}, {"oid": "8744d7d72feb2590ba6035b33da493357691bf9e", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/8744d7d72feb2590ba6035b33da493357691bf9e", "message": "feedback", "committedDate": "2020-11-20T19:28:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0Nzk0OA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527947948", "bodyText": "I wonder if these should be constants in the SDK so someone can just refer to them instead of having to know or refer to your sample.", "author": "drwill-ms", "createdAt": "2020-11-20T20:16:35Z", "path": "device/iot-device-samples/custom-sas-token-provider-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/CustomSasTokenProviderSample.java", "diffHunk": "@@ -0,0 +1,370 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import org.apache.commons.codec.binary.Base64;\n+\n+import javax.crypto.Mac;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * This sample demonstrates how to configure your device client to use a custom SAS token provider instead of\n+ * directly providing it the device's symmetric key.\n+ */\n+public class CustomSasTokenProviderSample\n+{\n+    private static final int D2C_MESSAGE_TIMEOUT = 2000; // 2 seconds\n+    private static List<String> failedMessageListOnClose = new ArrayList(); // List of messages that failed on close\n+\n+    /**\n+     * Helper class for turning symmetric keys into SAS tokens. It also provides some helpful functions around\n+     * if this token should be renewed.\n+     */\n+    protected static class SasToken\n+    {\n+        private static final String RAW_SIGNATURE_FORMAT = \"%s\\n%s\";", "originalCommit": "8744d7d72feb2590ba6035b33da493357691bf9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk4NTQ2OQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527985469", "bodyText": "It's tempting, but we don't have a great place to put it. None of our \"public\" classes are directly tied to our connection string/sas token logic", "author": "timtay-microsoft", "createdAt": "2020-11-20T21:40:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0Nzk0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwNTc3NA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r528005774", "bodyText": "It could be a standalone constants class", "author": "drwill-ms", "createdAt": "2020-11-20T22:32:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0Nzk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0ODU4OQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527948589", "bodyText": "should first params be on the next line?", "author": "drwill-ms", "createdAt": "2020-11-20T20:17:59Z", "path": "device/iot-device-samples/custom-sas-token-provider-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/CustomSasTokenProviderSample.java", "diffHunk": "@@ -0,0 +1,370 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import org.apache.commons.codec.binary.Base64;\n+\n+import javax.crypto.Mac;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * This sample demonstrates how to configure your device client to use a custom SAS token provider instead of\n+ * directly providing it the device's symmetric key.\n+ */\n+public class CustomSasTokenProviderSample\n+{\n+    private static final int D2C_MESSAGE_TIMEOUT = 2000; // 2 seconds\n+    private static List<String> failedMessageListOnClose = new ArrayList(); // List of messages that failed on close\n+\n+    /**\n+     * Helper class for turning symmetric keys into SAS tokens. It also provides some helpful functions around\n+     * if this token should be renewed.\n+     */\n+    protected static class SasToken\n+    {\n+        private static final String RAW_SIGNATURE_FORMAT = \"%s\\n%s\";\n+        private static final String SHARED_ACCESS_SIGNATURE_FORMAT = \"SharedAccessSignature %s=%s&%s=%s&%s=%d\";\n+        private static final Charset SIGNATURE_CHARSET = StandardCharsets.UTF_8;\n+        private static final String ExpiryTimeFieldKey = \"se\";\n+        private static final String SignatureFieldKey = \"sig\";\n+        private static final String ResourceURIFieldKey = \"sr\";\n+\n+        // When deciding whether to renew SAS tokens or not, it is wise to renew proactively to avoid clock skew issues\n+        // between client and server.\n+        private int renewalBufferSeconds;\n+        private long expiryTimeSeconds;\n+        private final char[] sasToken;\n+\n+        /**\n+         * Generate a new SAS token from your host name, device Id, and device Key.\n+         * @param hostName the host name of your IoT Hub (for instance, \"my-iot-hub.azure-devices.net\").\n+         * @param deviceId the Id of your device.\n+         * @param deviceKey the primary or secondary key of your device.\n+         * @param secondsToLive the number of seconds that the token will live for.\n+         * @param renewalBufferSeconds the number of seconds before the token expires when this instance will recommend renewal via {{@link #shouldRenewSasToken()}}\n+         */\n+        public SasToken(String hostName, String deviceId, String deviceKey, int secondsToLive, int renewalBufferSeconds)\n+        {\n+            this.renewalBufferSeconds = renewalBufferSeconds;\n+\n+            try\n+            {\n+                // expiry time is represented by seconds since the UNIX epoch.\n+                this.expiryTimeSeconds = (System.currentTimeMillis() / 1000) + secondsToLive;\n+\n+                String scope = buildScope(hostName, deviceId);\n+\n+                byte[] signature = String.format(RAW_SIGNATURE_FORMAT, scope, this.expiryTimeSeconds).getBytes(SIGNATURE_CHARSET);\n+                byte[] decodedDeviceKey = Base64.decodeBase64(deviceKey);\n+\n+                // HMAC encrypt the signature\n+                byte[] hmacEncryptedSignature = encryptSignatureHmacSha256(signature, decodedDeviceKey);\n+\n+                // Base64 encode the HMAC encrypted byte[]\n+                byte[] base64EncodedHmacEncryptedSignature = Base64.encodeBase64(hmacEncryptedSignature);\n+\n+                // Convert byte[] of base64 encoded and HMAC encrypted bits to a UTF-8 String\n+                String utf8Sig = new String(base64EncodedHmacEncryptedSignature, SIGNATURE_CHARSET);\n+\n+                // URL encode the string\n+                String urlEncodedSignature = URLEncoder.encode(utf8Sig, SIGNATURE_CHARSET.name());\n+\n+                this.sasToken = String.format(SHARED_ACCESS_SIGNATURE_FORMAT,", "originalCommit": "8744d7d72feb2590ba6035b33da493357691bf9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0ODY5Mw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527948693", "bodyText": "These are tabbed in twice", "author": "drwill-ms", "createdAt": "2020-11-20T20:18:11Z", "path": "device/iot-device-samples/custom-sas-token-provider-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/CustomSasTokenProviderSample.java", "diffHunk": "@@ -0,0 +1,370 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import org.apache.commons.codec.binary.Base64;\n+\n+import javax.crypto.Mac;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * This sample demonstrates how to configure your device client to use a custom SAS token provider instead of\n+ * directly providing it the device's symmetric key.\n+ */\n+public class CustomSasTokenProviderSample\n+{\n+    private static final int D2C_MESSAGE_TIMEOUT = 2000; // 2 seconds\n+    private static List<String> failedMessageListOnClose = new ArrayList(); // List of messages that failed on close\n+\n+    /**\n+     * Helper class for turning symmetric keys into SAS tokens. It also provides some helpful functions around\n+     * if this token should be renewed.\n+     */\n+    protected static class SasToken\n+    {\n+        private static final String RAW_SIGNATURE_FORMAT = \"%s\\n%s\";\n+        private static final String SHARED_ACCESS_SIGNATURE_FORMAT = \"SharedAccessSignature %s=%s&%s=%s&%s=%d\";\n+        private static final Charset SIGNATURE_CHARSET = StandardCharsets.UTF_8;\n+        private static final String ExpiryTimeFieldKey = \"se\";\n+        private static final String SignatureFieldKey = \"sig\";\n+        private static final String ResourceURIFieldKey = \"sr\";\n+\n+        // When deciding whether to renew SAS tokens or not, it is wise to renew proactively to avoid clock skew issues\n+        // between client and server.\n+        private int renewalBufferSeconds;\n+        private long expiryTimeSeconds;\n+        private final char[] sasToken;\n+\n+        /**\n+         * Generate a new SAS token from your host name, device Id, and device Key.\n+         * @param hostName the host name of your IoT Hub (for instance, \"my-iot-hub.azure-devices.net\").\n+         * @param deviceId the Id of your device.\n+         * @param deviceKey the primary or secondary key of your device.\n+         * @param secondsToLive the number of seconds that the token will live for.\n+         * @param renewalBufferSeconds the number of seconds before the token expires when this instance will recommend renewal via {{@link #shouldRenewSasToken()}}\n+         */\n+        public SasToken(String hostName, String deviceId, String deviceKey, int secondsToLive, int renewalBufferSeconds)\n+        {\n+            this.renewalBufferSeconds = renewalBufferSeconds;\n+\n+            try\n+            {\n+                // expiry time is represented by seconds since the UNIX epoch.\n+                this.expiryTimeSeconds = (System.currentTimeMillis() / 1000) + secondsToLive;\n+\n+                String scope = buildScope(hostName, deviceId);\n+\n+                byte[] signature = String.format(RAW_SIGNATURE_FORMAT, scope, this.expiryTimeSeconds).getBytes(SIGNATURE_CHARSET);\n+                byte[] decodedDeviceKey = Base64.decodeBase64(deviceKey);\n+\n+                // HMAC encrypt the signature\n+                byte[] hmacEncryptedSignature = encryptSignatureHmacSha256(signature, decodedDeviceKey);\n+\n+                // Base64 encode the HMAC encrypted byte[]\n+                byte[] base64EncodedHmacEncryptedSignature = Base64.encodeBase64(hmacEncryptedSignature);\n+\n+                // Convert byte[] of base64 encoded and HMAC encrypted bits to a UTF-8 String\n+                String utf8Sig = new String(base64EncodedHmacEncryptedSignature, SIGNATURE_CHARSET);\n+\n+                // URL encode the string\n+                String urlEncodedSignature = URLEncoder.encode(utf8Sig, SIGNATURE_CHARSET.name());\n+\n+                this.sasToken = String.format(SHARED_ACCESS_SIGNATURE_FORMAT,\n+                        ResourceURIFieldKey,", "originalCommit": "8744d7d72feb2590ba6035b33da493357691bf9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0OTE4NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527949185", "bodyText": "Why is this format not with the class constants?", "author": "drwill-ms", "createdAt": "2020-11-20T20:19:21Z", "path": "device/iot-device-samples/custom-sas-token-provider-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/CustomSasTokenProviderSample.java", "diffHunk": "@@ -0,0 +1,370 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import org.apache.commons.codec.binary.Base64;\n+\n+import javax.crypto.Mac;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * This sample demonstrates how to configure your device client to use a custom SAS token provider instead of\n+ * directly providing it the device's symmetric key.\n+ */\n+public class CustomSasTokenProviderSample\n+{\n+    private static final int D2C_MESSAGE_TIMEOUT = 2000; // 2 seconds\n+    private static List<String> failedMessageListOnClose = new ArrayList(); // List of messages that failed on close\n+\n+    /**\n+     * Helper class for turning symmetric keys into SAS tokens. It also provides some helpful functions around\n+     * if this token should be renewed.\n+     */\n+    protected static class SasToken\n+    {\n+        private static final String RAW_SIGNATURE_FORMAT = \"%s\\n%s\";\n+        private static final String SHARED_ACCESS_SIGNATURE_FORMAT = \"SharedAccessSignature %s=%s&%s=%s&%s=%d\";\n+        private static final Charset SIGNATURE_CHARSET = StandardCharsets.UTF_8;\n+        private static final String ExpiryTimeFieldKey = \"se\";\n+        private static final String SignatureFieldKey = \"sig\";\n+        private static final String ResourceURIFieldKey = \"sr\";\n+\n+        // When deciding whether to renew SAS tokens or not, it is wise to renew proactively to avoid clock skew issues\n+        // between client and server.\n+        private int renewalBufferSeconds;\n+        private long expiryTimeSeconds;\n+        private final char[] sasToken;\n+\n+        /**\n+         * Generate a new SAS token from your host name, device Id, and device Key.\n+         * @param hostName the host name of your IoT Hub (for instance, \"my-iot-hub.azure-devices.net\").\n+         * @param deviceId the Id of your device.\n+         * @param deviceKey the primary or secondary key of your device.\n+         * @param secondsToLive the number of seconds that the token will live for.\n+         * @param renewalBufferSeconds the number of seconds before the token expires when this instance will recommend renewal via {{@link #shouldRenewSasToken()}}\n+         */\n+        public SasToken(String hostName, String deviceId, String deviceKey, int secondsToLive, int renewalBufferSeconds)\n+        {\n+            this.renewalBufferSeconds = renewalBufferSeconds;\n+\n+            try\n+            {\n+                // expiry time is represented by seconds since the UNIX epoch.\n+                this.expiryTimeSeconds = (System.currentTimeMillis() / 1000) + secondsToLive;\n+\n+                String scope = buildScope(hostName, deviceId);\n+\n+                byte[] signature = String.format(RAW_SIGNATURE_FORMAT, scope, this.expiryTimeSeconds).getBytes(SIGNATURE_CHARSET);\n+                byte[] decodedDeviceKey = Base64.decodeBase64(deviceKey);\n+\n+                // HMAC encrypt the signature\n+                byte[] hmacEncryptedSignature = encryptSignatureHmacSha256(signature, decodedDeviceKey);\n+\n+                // Base64 encode the HMAC encrypted byte[]\n+                byte[] base64EncodedHmacEncryptedSignature = Base64.encodeBase64(hmacEncryptedSignature);\n+\n+                // Convert byte[] of base64 encoded and HMAC encrypted bits to a UTF-8 String\n+                String utf8Sig = new String(base64EncodedHmacEncryptedSignature, SIGNATURE_CHARSET);\n+\n+                // URL encode the string\n+                String urlEncodedSignature = URLEncoder.encode(utf8Sig, SIGNATURE_CHARSET.name());\n+\n+                this.sasToken = String.format(SHARED_ACCESS_SIGNATURE_FORMAT,\n+                        ResourceURIFieldKey,\n+                        scope,\n+                        SignatureFieldKey,\n+                        urlEncodedSignature,\n+                        ExpiryTimeFieldKey,\n+                        this.expiryTimeSeconds).toCharArray();\n+            }\n+            catch (UnsupportedEncodingException | InvalidKeyException | NoSuchAlgorithmException e)\n+            {\n+                // The exceptions here should never be thrown since the algorithm, encoding, and key are all hardcoded\n+                throw new IllegalStateException(\"Failed to generate a new SAS token\", e);\n+            }\n+        }\n+\n+        /**\n+         * Get the SAS token char array.\n+         * @return The SAS token char array.\n+         */\n+        public char[] getValue()\n+        {\n+            return this.sasToken;\n+        }\n+\n+        /**\n+         * Returns if this SAS token should be renewed.\n+         * @return true if this SAS token has expired, or will expire soon (depending on the provided renewal buffer). False, otherwise.\n+         */\n+        public boolean shouldRenewSasToken()\n+        {\n+            long currentTimeSeconds = (System.currentTimeMillis() / 1000);\n+\n+            // It will recommend renewing the token if it is expired, or if it will expire in the next few seconds\n+            return this.expiryTimeSeconds + this.renewalBufferSeconds >= currentTimeSeconds;\n+        }\n+\n+        private byte[] encryptSignatureHmacSha256(byte[] signature, byte[] deviceKey) throws NoSuchAlgorithmException, InvalidKeyException\n+        {\n+            String hmacSha256 = \"HmacSHA256\";\n+\n+            SecretKeySpec secretKey = new SecretKeySpec(deviceKey, hmacSha256);\n+\n+            byte[] encryptedSig = null;\n+            Mac hMacSha256 = Mac.getInstance(hmacSha256);\n+            hMacSha256.init(secretKey);\n+            encryptedSig = hMacSha256.doFinal(signature);\n+\n+            return encryptedSig;\n+        }\n+\n+        private String buildScope(String hostName, String deviceId)\n+        {\n+            return String.format(\"%s/devices/%s\", hostName, deviceId);", "originalCommit": "8744d7d72feb2590ba6035b33da493357691bf9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1MDA4NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527950085", "bodyText": "Spaces around ==", "author": "drwill-ms", "createdAt": "2020-11-20T20:21:20Z", "path": "device/iot-device-samples/custom-sas-token-provider-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/CustomSasTokenProviderSample.java", "diffHunk": "@@ -0,0 +1,370 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import org.apache.commons.codec.binary.Base64;\n+\n+import javax.crypto.Mac;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * This sample demonstrates how to configure your device client to use a custom SAS token provider instead of\n+ * directly providing it the device's symmetric key.\n+ */\n+public class CustomSasTokenProviderSample\n+{\n+    private static final int D2C_MESSAGE_TIMEOUT = 2000; // 2 seconds\n+    private static List<String> failedMessageListOnClose = new ArrayList(); // List of messages that failed on close\n+\n+    /**\n+     * Helper class for turning symmetric keys into SAS tokens. It also provides some helpful functions around\n+     * if this token should be renewed.\n+     */\n+    protected static class SasToken\n+    {\n+        private static final String RAW_SIGNATURE_FORMAT = \"%s\\n%s\";\n+        private static final String SHARED_ACCESS_SIGNATURE_FORMAT = \"SharedAccessSignature %s=%s&%s=%s&%s=%d\";\n+        private static final Charset SIGNATURE_CHARSET = StandardCharsets.UTF_8;\n+        private static final String ExpiryTimeFieldKey = \"se\";\n+        private static final String SignatureFieldKey = \"sig\";\n+        private static final String ResourceURIFieldKey = \"sr\";\n+\n+        // When deciding whether to renew SAS tokens or not, it is wise to renew proactively to avoid clock skew issues\n+        // between client and server.\n+        private int renewalBufferSeconds;\n+        private long expiryTimeSeconds;\n+        private final char[] sasToken;\n+\n+        /**\n+         * Generate a new SAS token from your host name, device Id, and device Key.\n+         * @param hostName the host name of your IoT Hub (for instance, \"my-iot-hub.azure-devices.net\").\n+         * @param deviceId the Id of your device.\n+         * @param deviceKey the primary or secondary key of your device.\n+         * @param secondsToLive the number of seconds that the token will live for.\n+         * @param renewalBufferSeconds the number of seconds before the token expires when this instance will recommend renewal via {{@link #shouldRenewSasToken()}}\n+         */\n+        public SasToken(String hostName, String deviceId, String deviceKey, int secondsToLive, int renewalBufferSeconds)\n+        {\n+            this.renewalBufferSeconds = renewalBufferSeconds;\n+\n+            try\n+            {\n+                // expiry time is represented by seconds since the UNIX epoch.\n+                this.expiryTimeSeconds = (System.currentTimeMillis() / 1000) + secondsToLive;\n+\n+                String scope = buildScope(hostName, deviceId);\n+\n+                byte[] signature = String.format(RAW_SIGNATURE_FORMAT, scope, this.expiryTimeSeconds).getBytes(SIGNATURE_CHARSET);\n+                byte[] decodedDeviceKey = Base64.decodeBase64(deviceKey);\n+\n+                // HMAC encrypt the signature\n+                byte[] hmacEncryptedSignature = encryptSignatureHmacSha256(signature, decodedDeviceKey);\n+\n+                // Base64 encode the HMAC encrypted byte[]\n+                byte[] base64EncodedHmacEncryptedSignature = Base64.encodeBase64(hmacEncryptedSignature);\n+\n+                // Convert byte[] of base64 encoded and HMAC encrypted bits to a UTF-8 String\n+                String utf8Sig = new String(base64EncodedHmacEncryptedSignature, SIGNATURE_CHARSET);\n+\n+                // URL encode the string\n+                String urlEncodedSignature = URLEncoder.encode(utf8Sig, SIGNATURE_CHARSET.name());\n+\n+                this.sasToken = String.format(SHARED_ACCESS_SIGNATURE_FORMAT,\n+                        ResourceURIFieldKey,\n+                        scope,\n+                        SignatureFieldKey,\n+                        urlEncodedSignature,\n+                        ExpiryTimeFieldKey,\n+                        this.expiryTimeSeconds).toCharArray();\n+            }\n+            catch (UnsupportedEncodingException | InvalidKeyException | NoSuchAlgorithmException e)\n+            {\n+                // The exceptions here should never be thrown since the algorithm, encoding, and key are all hardcoded\n+                throw new IllegalStateException(\"Failed to generate a new SAS token\", e);\n+            }\n+        }\n+\n+        /**\n+         * Get the SAS token char array.\n+         * @return The SAS token char array.\n+         */\n+        public char[] getValue()\n+        {\n+            return this.sasToken;\n+        }\n+\n+        /**\n+         * Returns if this SAS token should be renewed.\n+         * @return true if this SAS token has expired, or will expire soon (depending on the provided renewal buffer). False, otherwise.\n+         */\n+        public boolean shouldRenewSasToken()\n+        {\n+            long currentTimeSeconds = (System.currentTimeMillis() / 1000);\n+\n+            // It will recommend renewing the token if it is expired, or if it will expire in the next few seconds\n+            return this.expiryTimeSeconds + this.renewalBufferSeconds >= currentTimeSeconds;\n+        }\n+\n+        private byte[] encryptSignatureHmacSha256(byte[] signature, byte[] deviceKey) throws NoSuchAlgorithmException, InvalidKeyException\n+        {\n+            String hmacSha256 = \"HmacSHA256\";\n+\n+            SecretKeySpec secretKey = new SecretKeySpec(deviceKey, hmacSha256);\n+\n+            byte[] encryptedSig = null;\n+            Mac hMacSha256 = Mac.getInstance(hmacSha256);\n+            hMacSha256.init(secretKey);\n+            encryptedSig = hMacSha256.doFinal(signature);\n+\n+            return encryptedSig;\n+        }\n+\n+        private String buildScope(String hostName, String deviceId)\n+        {\n+            return String.format(\"%s/devices/%s\", hostName, deviceId);\n+        }\n+    }\n+\n+    /**\n+     * A sample implementation of the {@link SasTokenProvider} interface. It demonstrates how to generate your own SAS\n+     * tokens from your device key, device Id, and host name. It also demonstrates how to choose how long your SAS tokens\n+     * will live for.\n+     *\n+     * The purpose of the {@link SasTokenProvider} interface is to allow users to generate these tokens in separate\n+     * processes from the SDK for security purposes, if they wish. This sample does not demonstrate that scenario.\n+     */\n+    protected static class SasTokenProviderImpl implements SasTokenProvider\n+    {\n+        private String deviceKey;\n+        private String hostName;\n+        private String deviceId;\n+        private int secondsToLivePerToken;\n+        private int renewalBufferSeconds;\n+\n+        private SasToken cachedSasToken;\n+\n+        public SasTokenProviderImpl(String hostName, String deviceId, String deviceKey, int secondsToLivePerToken, int renewalBufferSeconds)\n+        {\n+            this.hostName = hostName;\n+            this.deviceId = deviceId;\n+            this.deviceKey = deviceKey;\n+            this.secondsToLivePerToken = secondsToLivePerToken;\n+            this.renewalBufferSeconds = renewalBufferSeconds;\n+        }\n+\n+        @Override\n+        public char[] getSasToken()\n+        {\n+            if (this.cachedSasToken == null || this.cachedSasToken.shouldRenewSasToken())\n+            {\n+                // if no SAS token is cached, or if the cached token is expired/about to expire, create a new one\n+                this.cachedSasToken = new SasToken(this.hostName, this.deviceId, this.deviceKey, this.secondsToLivePerToken, this.renewalBufferSeconds);\n+                return this.cachedSasToken.getValue();\n+            }\n+            //else if (...)\n+            //{\n+                // It is recommended to have some logic in here that checks to make sure that the device key in use itself\n+                // is still valid. A given device may have it's keys cycled by its owner, and this would be an appropriate\n+                // time to update the device key if a new one was cycled in.\n+            //}\n+            else\n+            {\n+                return this.cachedSasToken.getValue();\n+            }\n+        }\n+    }\n+\n+    protected static class EventCallback implements IotHubEventCallback\n+    {\n+        public void execute(IotHubStatusCode status, Object context)\n+        {\n+            Message msg = (Message) context;\n+\n+            System.out.println(\"IoT Hub responded to message \"+ msg.getMessageId()  + \" with status \" + status.name());\n+\n+            if (status==IotHubStatusCode.MESSAGE_CANCELLED_ONCLOSE)", "originalCommit": "8744d7d72feb2590ba6035b33da493357691bf9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1NDUyOQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527954529", "bodyText": "nit: I am a bit confused by the naming of this - we aren't renewing the authentication provider itself, right?", "author": "abhipsaMisra", "createdAt": "2020-11-20T20:30:54Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/InternalClient.java", "diffHunk": "@@ -138,7 +161,7 @@\n \n     public void open() throws IOException\n     {\n-        if (this.config.getAuthenticationType() == DeviceClientConfig.AuthType.SAS_TOKEN && this.config.getSasTokenAuthentication().isRenewalNecessary())\n+        if (this.config.getAuthenticationType() == DeviceClientConfig.AuthType.SAS_TOKEN && this.config.getSasTokenAuthentication().isAuthenticationProviderRenewalNecessary())", "originalCommit": "8744d7d72feb2590ba6035b33da493357691bf9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk2ODUxMw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527968513", "bodyText": "We kind of are. isAuthenticationProviderRenewalNecessary is only true when the user provides a single SAS token, and it expires, and we can't refresh it because we don't have the device key", "author": "timtay-microsoft", "createdAt": "2020-11-20T21:03:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1NDUyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk4ODc0OA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527988748", "bodyText": "So are they really renewing the authentication provider or just a SAS token? the name is really confusing to me.", "author": "azabbasi", "createdAt": "2020-11-20T21:47:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1NDUyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk4OTA2Mg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527989062", "bodyText": "so does the SasTokenProvider control the auth keys to generate the SAS token?", "author": "azabbasi", "createdAt": "2020-11-20T21:48:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1NDUyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwNjEyNw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r528006127", "bodyText": "I'd just ignore this function, to be honest. It only is relevant in very niche cases. For users who use the new DeviceClient constructor in this PR, they will never enter into this if block.", "author": "timtay-microsoft", "createdAt": "2020-11-20T22:33:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1NDUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1OTIzMw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527959233", "bodyText": "If I understand coreectly, for a user implementing this interface, they would need to implement their own renewal logic, right? This statement is only for our library's implementation of SasTokenProvider, which incidentally contains the 85% lifetime renewal logic?\nCorrect me if I am wrong, this is what I understand -\nFrom an interface perspective, our library calls getSasToken() whenever it requires a new SAS token (at it's simplest implementation - every time for Http, on CONNECT for Mqtt, while opening cbs link for Amqp).\nFor a user of this interface, you can then add any caching or renewal logic as you require in your implementation of getSasToken(), while the sdk can (edit: and has) additional calls to getSasToken() on reconnection, with an amqp refresh timer, etc.\nIf this is correct, then we should instead state that any renewal or caching logic is the ownership of whoever implements SasTokenProvider interface.", "author": "abhipsaMisra", "createdAt": "2020-11-20T20:41:54Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/SasTokenProvider.java", "diffHunk": "@@ -0,0 +1,34 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.microsoft.azure.sdk.iot.device;\n+\n+/**\n+ * Interface for allowing users to control SAS token generation. To see an example of how SAS tokens can be generated\n+ * from device connection strings, see {@link com.microsoft.azure.sdk.iot.device.auth.IotHubSasToken}.\n+ * @see <a href=\"https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-devguide-security#example\">This document</a> for more details on sas tokens.\n+ */\n+public interface SasTokenProvider\n+{\n+    /**\n+     * Returns a SAS token to be used for authentication.\n+     * <p>\n+     * This function will be called each time the client library needs a SAS token. This will follow different patterns\n+     * based on which protocol your client object is using.\n+     * <p>\n+     * For HTTPS, this function will be called for each HTTPS request made (for instance, once per telemetry send), and does not need\n+     * to be a unique token each time. Because of that, users may simply cache and return the same SAS token repeatedly here.\n+     * Alternatively, users can generate very short-lived SAS tokens since they will only need to be valid for a relative short period of time.\n+     * The user of this API is responsible for tracking when to renew the SAS token based on how long the previous token was valid for.\n+     * <p>\n+     * For AMQPS/AMQPS_WS, this function will be called once when first opening the connection, and then will be called again\n+     * at some point prior to the previous SAS token's expiry time in order to proactively renew the connection's authentication.\n+     * This proactive renewal takes place at around 85% of the previous SAS token's lifespan.", "originalCommit": "8744d7d72feb2590ba6035b33da493357691bf9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk2MTEzMQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527961131", "bodyText": "Wait, I see a lot of authentication provider classes in our library; would you mind listing their hierarchy? That will help understand which method (in the auth provider interface) our transport layer calls into.", "author": "abhipsaMisra", "createdAt": "2020-11-20T20:46:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1OTIzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk2MTQ1NA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527961454", "bodyText": "If SasTokenProvider is not what our transport layer calls into, then my assumption above might not be correct.", "author": "abhipsaMisra", "createdAt": "2020-11-20T20:46:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1OTIzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk4Nzc5MA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527987790", "bodyText": "I'd need a whiteboard to illustrate these authentication providers and their hierarchies. Just focusing on the SAS side of the tree, IotHubSasTokenAuthenticationProvider is the \"root\" class for all symmetric key based authentication mechanisms. From there, there are several implementations depending on if the device key is present, or if the TPM is the provider, or if the new SAS token provider interface is provided.", "author": "timtay-microsoft", "createdAt": "2020-11-20T21:45:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1OTIzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk5MjY3Nw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527992677", "bodyText": "I once attempted to draw the hierarchy by just looking at the code and I failed on the first few attempts ... it's a confusing logic.", "author": "azabbasi", "createdAt": "2020-11-20T21:57:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1OTIzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk5NzE5Mw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527997193", "bodyText": "This statement is only for our library's implementation of SasTokenProvider, which incidentally contains the 85% lifetime renewal logic?\n\nOur SDK will still ask for a new SAS token once the previous token has 15% of it's life left, but the SDK doesn't mandate anything about that token. It's not recommended, but customers could just return the same SAS token at that point, for instance.", "author": "timtay-microsoft", "createdAt": "2020-11-20T22:08:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1OTIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk2MjU5NA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527962594", "bodyText": "ok, this answers a question that I asked above - why do we want to expose something like this? Wouldn't it be easier to simply state that if you create an authentication provider using a shared access signature, then you cannot renew tokens and your client will be unusable once your token expires.", "author": "abhipsaMisra", "createdAt": "2020-11-20T20:49:32Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/auth/IotHubSasTokenAuthenticationProvider.java", "diffHunk": "@@ -76,10 +76,13 @@ public void setTokenValidSecs(long tokenValidSecs)\n     }\n \n     /**\n-     * Returns true if the saved sas token needs to be manually renewed by the user\n-     * @return true if the saved sas token needs to be manually renewed by the user\n+     * Returns true if the this authentication provider is no longer valid. If true, users will need to create a new\n+     * DeviceClient instance to get a new authentication provider. The most common case for this is if the user\n+     * provides a SAS token, but no symmetric key, and that SAS token has expired. At that point, the user's client\n+     * won't be able to authenticate anymore.\n+     * @return true if the this authentication provider is no longer valid. False otherwise", "originalCommit": "8744d7d72feb2590ba6035b33da493357691bf9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk4ODIwOQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527988209", "bodyText": "We don't expose this. These AuthenticationProvider classes are strictly internal. This particular function is used only in a few special cases where we throw an exception. I'd love to get rid of it, but that would be a breaking change.", "author": "timtay-microsoft", "createdAt": "2020-11-20T21:46:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk2MjU5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk5NDc1OA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527994758", "bodyText": "I am  confused here again, can't they hold the logic to provide a new SAS token in their implementation of the SasTokenProvider?", "author": "azabbasi", "createdAt": "2020-11-20T22:02:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk2MjU5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk5NDk0OA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527994948", "bodyText": "that way they would still be able to keep using the DeviceClient.", "author": "azabbasi", "createdAt": "2020-11-20T22:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk2MjU5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk5NTIwNA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527995204", "bodyText": "it's just not a great experience if I have to keep creating a device client every time my SAS expires.", "author": "azabbasi", "createdAt": "2020-11-20T22:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk2MjU5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwNTcyOQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r528005729", "bodyText": "I am confused here again, can't they hold the logic to provide a new SAS token in their implementation of the SasTokenProvider?\n\nThey can. They do not need to create a new device client each time their SAS token expires. This particular method only raises issues if the user creates a device client instance through a old constructor that allows for a single SAS token to be provided. In the case that the user uses that old constructor, and their SAS token expires, then this method returns true, signaling to the Transport layer to fire a notification to the user.\nFor users of the new constructor that takes the SasTokenProvider interface, they will never need to create a new device client because they will always be capable of providing new SAS tokens.", "author": "timtay-microsoft", "createdAt": "2020-11-20T22:32:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk2MjU5NA=="}], "type": "inlineReview"}, {"oid": "1d4db8201ab1a2b829e90054f23d61239ddb4cfa", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/1d4db8201ab1a2b829e90054f23d61239ddb4cfa", "message": "feedback", "committedDate": "2020-11-20T21:48:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk5MzcyMg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527993722", "bodyText": "This class is a public class yes? can we just change the method ?", "author": "azabbasi", "createdAt": "2020-11-20T22:00:12Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/auth/IotHubSasTokenAuthenticationProvider.java", "diffHunk": "@@ -34,7 +34,7 @@\n     protected IotHubSasToken sasToken;\n \n     public abstract boolean canRefreshToken();\n-    public abstract String getRenewedSasToken(boolean proactivelyRenew, boolean forceRenewal) throws IOException, TransportException;\n+    public abstract char[] getSasToken() throws IOException, TransportException;", "originalCommit": "8744d7d72feb2590ba6035b33da493357691bf9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk5ODMxMg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527998312", "bodyText": "No, these AuthenticationProvider classes are not part of our public API surface. Users can't construct a device client with one of these things", "author": "timtay-microsoft", "createdAt": "2020-11-20T22:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk5MzcyMg=="}], "type": "inlineReview"}, {"oid": "a872ee7d673316f8bf677cd0b0de65e22bcf144a", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/a872ee7d673316f8bf677cd0b0de65e22bcf144a", "message": "Merge branch 'master' into timtay/sasTokenProvider", "committedDate": "2020-11-20T22:11:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk5NTY4MQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527995681", "bodyText": "so if we are repurposing this method entirely, where does this logic go? the proactive renewal approach that is.", "author": "azabbasi", "createdAt": "2020-11-20T22:05:00Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/auth/IotHubSasTokenHardwareAuthenticationProvider.java", "diffHunk": "@@ -65,25 +65,14 @@ public IotHubSasTokenHardwareAuthenticationProvider(String hostname, String gate\n     /**\n      * Getter for SasToken. If the saved token has expired, this method shall renew it if possible\n      *\n-     * @param proactivelyRenew if true, this method will generate a fresh sas token even if the previously saved token", "originalCommit": "8744d7d72feb2590ba6035b33da493357691bf9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk5NjI5OQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r527996299", "bodyText": "did we never use this?", "author": "azabbasi", "createdAt": "2020-11-20T22:06:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk5NTY4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwMjgyNQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r528002825", "bodyText": "We only ever called this method with the same flags set, (true and true), so we can just get rid of the other cases", "author": "timtay-microsoft", "createdAt": "2020-11-20T22:23:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk5NTY4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwMDc4Mw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r528000783", "bodyText": "I think it's important to make the distinction that this is a helper class by including that in the name.\nSampleSasTokenHelper ? or something of that nature.", "author": "azabbasi", "createdAt": "2020-11-20T22:17:59Z", "path": "device/iot-device-samples/custom-sas-token-provider-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/CustomSasTokenProviderSample.java", "diffHunk": "@@ -0,0 +1,371 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import org.apache.commons.codec.binary.Base64;\n+\n+import javax.crypto.Mac;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * This sample demonstrates how to configure your device client to use a custom SAS token provider instead of\n+ * directly providing it the device's symmetric key.\n+ */\n+public class CustomSasTokenProviderSample\n+{\n+    private static final int D2C_MESSAGE_TIMEOUT = 2000; // 2 seconds\n+    private static List<String> failedMessageListOnClose = new ArrayList(); // List of messages that failed on close\n+\n+    /**\n+     * Helper class for turning symmetric keys into SAS tokens. It also provides some helpful functions around\n+     * if this token should be renewed.\n+     */\n+    protected static class SasToken", "originalCommit": "1d4db8201ab1a2b829e90054f23d61239ddb4cfa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwNDgxMQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r528004811", "bodyText": "This class is functional enough to replace the similar classes we have defined in our SDK, so I kind of like the name as is.", "author": "timtay-microsoft", "createdAt": "2020-11-20T22:29:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwMDc4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwNjA3MQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r528006071", "bodyText": "then maybe we should include this as the default implementation of our own that ships along with the interface?", "author": "azabbasi", "createdAt": "2020-11-20T22:33:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwMDc4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwODIxMQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r528008211", "bodyText": "But it isn't a SasToken, so the name is misleading, don't you think?", "author": "drwill-ms", "createdAt": "2020-11-20T22:39:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwMDc4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNTkwNg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r528025906", "bodyText": "Sure then, I can rename this to SasTokenHelper", "author": "timtay-microsoft", "createdAt": "2020-11-20T23:38:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwMDc4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwMjI1Ng==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r528002256", "bodyText": "I assume this implementation works out of the box if they provide the connection string. Is that correct?", "author": "azabbasi", "createdAt": "2020-11-20T22:22:02Z", "path": "iot-e2e-tests/common/src/test/java/tests/integration/com/microsoft/azure/sdk/iot/helpers/SasTokenProviderImpl.java", "diffHunk": "@@ -0,0 +1,45 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package tests.integration.com.microsoft.azure.sdk.iot.helpers;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionString;\n+import com.microsoft.azure.sdk.iot.device.SasTokenProvider;\n+import com.microsoft.azure.sdk.iot.device.auth.IotHubSasToken;\n+\n+import java.net.URISyntaxException;\n+\n+/**\n+ * Basic implementation of the SasTokenProvider interface, for test purposes.\n+ */\n+public class SasTokenProviderImpl implements SasTokenProvider", "originalCommit": "1d4db8201ab1a2b829e90054f23d61239ddb4cfa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwMzA3NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r528003075", "bodyText": "It does, but this lives in our test code. I'd prefer users pick up the sample code's implementation rather than this one.", "author": "timtay-microsoft", "createdAt": "2020-11-20T22:24:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwMjI1Ng=="}], "type": "inlineReview"}, {"oid": "73c78712828840799d7ec90fb62d2ccaed2be0ff", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/73c78712828840799d7ec90fb62d2ccaed2be0ff", "message": "Merge branch 'master' into timtay/sasTokenProvider", "committedDate": "2020-11-20T22:33:33Z", "type": "commit"}, {"oid": "5c2bb2e1692f637ba27911fe7a9209ec3b50c098", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/5c2bb2e1692f637ba27911fe7a9209ec3b50c098", "message": "feedback", "committedDate": "2020-11-20T23:39:21Z", "type": "commit"}, {"oid": "0c4d7ba1d08509a6b38310696b9a13694269a75f", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/0c4d7ba1d08509a6b38310696b9a13694269a75f", "message": "Merge branch 'master' into timtay/sasTokenProvider", "committedDate": "2020-11-30T18:08:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgyNzkzMA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r532827930", "bodyText": "these are tabbed in twice", "author": "drwill-ms", "createdAt": "2020-11-30T18:59:40Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceClientConfig.java", "diffHunk": "@@ -144,6 +144,22 @@ public DeviceClientConfig(IotHubAuthenticationProvider authenticationProvider) t\n         this.productInfo = new ProductInfo();\n     }\n \n+\n+    public DeviceClientConfig(String hostName, SasTokenProvider sasTokenProvider, ClientOptions clientOptions, String deviceId, String moduleId)\n+    {\n+        this.authenticationProvider = new IotHubSasTokenProvidedAuthenticationProvider(\n+                hostName,", "originalCommit": "0c4d7ba1d08509a6b38310696b9a13694269a75f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgyODIwMg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r532828202", "bodyText": "there are 2 newlines here, when I think 1 is expected", "author": "drwill-ms", "createdAt": "2020-11-30T19:00:05Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/InternalClient.java", "diffHunk": "@@ -128,6 +128,29 @@\n         this.deviceIO = new DeviceIO(this.config, sendPeriodMillis, receivePeriodMillis);\n     }\n \n+    InternalClient(String hostName, String deviceId, String moduleId, SasTokenProvider sasTokenProvider, IotHubClientProtocol protocol, ClientOptions clientOptions, long sendPeriodMillis, long receivePeriodMillis)\n+    {\n+        if (hostName == null)\n+        {\n+            throw new IllegalArgumentException(\"Host name cannot be null\");\n+        }\n+\n+        if (protocol == null)\n+        {\n+            throw new IllegalArgumentException(\"Protocol cannot be null.\");\n+        }\n+\n+        this.config = new DeviceClientConfig(hostName, sasTokenProvider, clientOptions, deviceId, moduleId);\n+        this.config.setProtocol(protocol);\n+        if (clientOptions != null)\n+        {\n+            this.config.modelId = clientOptions.getModelId();\n+        }\n+\n+        this.deviceIO = new DeviceIO(this.config, sendPeriodMillis, receivePeriodMillis);\n+    }\n+", "originalCommit": "0c4d7ba1d08509a6b38310696b9a13694269a75f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzMzUyMQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r532833521", "bodyText": "As this is overridden and specified for this impl, I think it warrants a comment as to why it is true.", "author": "drwill-ms", "createdAt": "2020-11-30T19:09:18Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/auth/IotHubSasTokenProvidedAuthenticationProvider.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+*  Copyright (c) Microsoft. All rights reserved.\n+*  Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+*/\n+\n+package com.microsoft.azure.sdk.iot.device.auth;\n+\n+import com.microsoft.azure.sdk.iot.device.ClientOptions;\n+import com.microsoft.azure.sdk.iot.device.IotHubClientProtocol;\n+import com.microsoft.azure.sdk.iot.device.SasTokenProvider;\n+\n+import javax.net.ssl.SSLContext;\n+\n+/**\n+ * {@link IotHubSasTokenAuthenticationProvider} implementation where the tokens are provided by an instance of {@link SasTokenProvider}.\n+ * This is used in cases like when the user creates a device client with {@link com.microsoft.azure.sdk.iot.device.DeviceClient#DeviceClient(String, String, SasTokenProvider, IotHubClientProtocol, ClientOptions)}\n+ */\n+public class IotHubSasTokenProvidedAuthenticationProvider extends IotHubSasTokenAuthenticationProvider\n+{\n+    SasTokenProvider sasTokenProvider;\n+    char[] lastSasToken;\n+\n+    public IotHubSasTokenProvidedAuthenticationProvider(String hostName, String deviceId, String moduleId, SasTokenProvider sasTokenProvider, SSLContext sslContext) {\n+        super(hostName, null, deviceId, moduleId, sslContext);\n+\n+        if (sasTokenProvider == null)\n+        {\n+            throw new IllegalArgumentException(\"SAS token provider cannot be null\");\n+        }\n+\n+        this.sasTokenProvider = sasTokenProvider;\n+    }\n+\n+    @Override\n+    public boolean isAuthenticationProviderRenewalNecessary()\n+    {\n+        // Renewal of the authentication provider itself is never needed since the SAS token provider is responsible\n+        // for providing SAS tokens indefinitely.\n+        return false;\n+    }\n+\n+    @Override\n+    public void setTokenValidSecs(long tokenValidSecs)\n+    {\n+        throw new UnsupportedOperationException(\"Cannot configure SAS token time to live when custom SAS token provider is in use\");\n+    }\n+\n+    @Override\n+    public boolean canRefreshToken()", "originalCommit": "0c4d7ba1d08509a6b38310696b9a13694269a75f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0MTg1Mg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r532841852", "bodyText": "What's with the weird tabbing going on here where some params are further in than others?", "author": "drwill-ms", "createdAt": "2020-11-30T19:23:14Z", "path": "device/iot-device-samples/custom-sas-token-provider-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/CustomSasTokenProviderSample.java", "diffHunk": "@@ -0,0 +1,371 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import org.apache.commons.codec.binary.Base64;\n+\n+import javax.crypto.Mac;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * This sample demonstrates how to configure your device client to use a custom SAS token provider instead of\n+ * directly providing it the device's symmetric key.\n+ */\n+public class CustomSasTokenProviderSample\n+{\n+    private static final int D2C_MESSAGE_TIMEOUT = 2000; // 2 seconds\n+    private static List<String> failedMessageListOnClose = new ArrayList(); // List of messages that failed on close\n+\n+    /**\n+     * Helper class for turning symmetric keys into SAS tokens. It also provides some helpful functions around\n+     * if this token should be renewed.\n+     */\n+    protected static class SasTokenHelper\n+    {\n+        private static final String RAW_SIGNATURE_FORMAT = \"%s\\n%s\";\n+        private static final String SHARED_ACCESS_SIGNATURE_FORMAT = \"SharedAccessSignature %s=%s&%s=%s&%s=%d\";\n+        private static final String SCOPE_FORMAT = \"%s/devices/%s\";\n+        private static final Charset SIGNATURE_CHARSET = StandardCharsets.UTF_8;\n+        private static final String EXPIRY_TIME_FIELD_KEY = \"se\";\n+        private static final String SIGNATURE_FIELD_KEY = \"sig\";\n+        private static final String RESOURCE_URI_FIELD_KEY = \"sr\";\n+        private static final String HMAC_SHA_256 = \"HmacSHA256\";\n+\n+        // When deciding whether to renew SAS tokens or not, it is wise to renew proactively to avoid clock skew issues\n+        // between client and server.\n+        private int renewalBufferSeconds;\n+        private long expiryTimeSeconds;\n+        private final char[] sasToken;\n+\n+        /**\n+         * Generate a new SAS token from your host name, device Id, and device Key.\n+         * @param hostName the host name of your IoT Hub (for instance, \"my-iot-hub.azure-devices.net\").\n+         * @param deviceId the Id of your device.\n+         * @param deviceKey the primary or secondary key of your device.\n+         * @param secondsToLive the number of seconds that the token will live for.\n+         * @param renewalBufferSeconds the number of seconds before the token expires when this instance will recommend renewal via {{@link #shouldRenewSasToken()}}\n+         */\n+        public SasTokenHelper(String hostName, String deviceId, String deviceKey, int secondsToLive, int renewalBufferSeconds)\n+        {\n+            this.renewalBufferSeconds = renewalBufferSeconds;\n+\n+            try\n+            {\n+                // expiry time is represented by seconds since the UNIX epoch.\n+                this.expiryTimeSeconds = (System.currentTimeMillis() / 1000) + secondsToLive;\n+\n+                String scope = buildScope(hostName, deviceId);\n+\n+                byte[] signature = String.format(RAW_SIGNATURE_FORMAT, scope, this.expiryTimeSeconds).getBytes(SIGNATURE_CHARSET);\n+                byte[] decodedDeviceKey = Base64.decodeBase64(deviceKey);\n+\n+                // HMAC encrypt the signature\n+                byte[] hmacEncryptedSignature = encryptSignatureHmacSha256(signature, decodedDeviceKey);\n+\n+                // Base64 encode the HMAC encrypted byte[]\n+                byte[] base64EncodedHmacEncryptedSignature = Base64.encodeBase64(hmacEncryptedSignature);\n+\n+                // Convert byte[] of base64 encoded and HMAC encrypted bits to a UTF-8 String\n+                String utf8Sig = new String(base64EncodedHmacEncryptedSignature, SIGNATURE_CHARSET);\n+\n+                // URL encode the string\n+                String urlEncodedSignature = URLEncoder.encode(utf8Sig, SIGNATURE_CHARSET.name());\n+\n+                this.sasToken = String.format(\n+                    SHARED_ACCESS_SIGNATURE_FORMAT,\n+                        RESOURCE_URI_FIELD_KEY,", "originalCommit": "0c4d7ba1d08509a6b38310696b9a13694269a75f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyODg2NA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1002#discussion_r533628864", "bodyText": "I'll fix it", "author": "timtay-microsoft", "createdAt": "2020-12-01T18:25:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0MTg1Mg=="}], "type": "inlineReview"}, {"oid": "f4c233cd2faae11f09e255b4224d0c572c8479ff", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/f4c233cd2faae11f09e255b4224d0c572c8479ff", "message": "address cr comments", "committedDate": "2020-12-01T18:28:14Z", "type": "commit"}]}