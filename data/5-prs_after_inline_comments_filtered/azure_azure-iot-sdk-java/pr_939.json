{"pr_number": 939, "pr_title": "feat(iot-dev): Add multiplexing client that supports device registration/unregistration during open connection", "pr_createdAt": "2020-09-28T19:08:34Z", "pr_url": "https://github.com/Azure/azure-iot-sdk-java/pull/939", "timeline": [{"oid": "37cf09f06e4d70e77218a44de91cab8a6d7cae67", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/37cf09f06e4d70e77218a44de91cab8a6d7cae67", "message": "feat(iot-dev): Add multiplexing client that supports device registration/unregistration during open connection\n\nTransportClient was our multiplexing client, but there was no way to add the ability to add/remove devices from an active connection without breaking the APIs in that class, so this deprecates the transport client in favor of a new MultiplexingClient.\n\nSignificant changes had to made to the IotHubTransport layer so that each multiplexed client could have its own connection state and so that each multiplexed client could have its own focused retry logic. Instead of closing the entire multiplexed connection every time a session drops, the transport layer can re-open individual device sessions", "committedDate": "2020-09-28T19:08:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzNTQ0OA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r514635448", "bodyText": "Might as well make this string a constant instead of repeating it.", "author": "drwill-ms", "createdAt": "2020-10-30T00:05:07Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceClient.java", "diffHunk": "@@ -376,6 +376,11 @@ private void commonConstructorVerifications() throws UnsupportedOperationExcepti\n      */\n     public void open() throws IOException\n     {\n+        if (this.ioTHubConnectionType == IoTHubConnectionType.USE_MULTIPLEXING_CLIENT)\n+        {\n+            throw new UnsupportedOperationException(\"Cannot open a multiplexed client through this method. Must use multiplexingClient.registerDeviceClient(deviceClient)\");", "originalCommit": "a0104b7933f8b17190eac935c591375f74af08e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjExNDEzMg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516114132", "bodyText": "I don't see this string being used in more than one place", "author": "timtay-microsoft", "createdAt": "2020-11-02T16:55:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzNTQ0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE0NTk2MQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516145961", "bodyText": "I see. It looks like the repeated string is the one for close.", "author": "drwill-ms", "createdAt": "2020-11-02T17:39:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzNTQ0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzNTcxMQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r514635711", "bodyText": "\"; abandoning it.\"", "author": "drwill-ms", "createdAt": "2020-10-30T00:06:01Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceTwin/DeviceTwin.java", "diffHunk": "@@ -69,7 +69,7 @@ public IotHubMessageResult execute(Message message, Object callbackContext)\n                 IotHubStatusCode iotHubStatus = IotHubStatusCode.ERROR;\n                 if (message.getMessageType() != MessageType.DEVICE_TWIN)\n                 {\n-                    System.out.print(\"Unexpected message type received\");\n+                    log.warn(\"Unexpected message type received, abandoning it\");", "originalCommit": "a0104b7933f8b17190eac935c591375f74af08e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "90c993b2808ae6ef6e3ae2b120a270c14539c8a2", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/90c993b2808ae6ef6e3ae2b120a270c14539c8a2", "message": "fixup", "committedDate": "2020-11-02T16:55:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMjI2NA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516302264", "bodyText": "So we're marking this constructor as deprecated so users can use the MultiplexingClient instead. But isn't this true only for customers who want to use multiplexed connections? Wouldn't this still be useful to customers who don't want to use multiplexed connections?", "author": "barustum", "createdAt": "2020-11-02T22:43:41Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceClient.java", "diffHunk": "@@ -128,18 +129,19 @@\n      * RFC 3986 or if the provided {@code connString} is for an x509 authenticated device\n      * @throws URISyntaxException if the hostname in the connection string is not a valid URI\n      * @throws UnsupportedOperationException if the connection string belongs to a module rather than a device\n+     * @deprecated {@link MultiplexingClient} should be used instead of {@link TransportClient} for creating all multiplexed connections.", "originalCommit": "6a88d33ab305b43dd56726bf57c89f98493fef30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxMDk4Mg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516310982", "bodyText": "I'm doing this to impress upon users that we won't be supporting that transport client anymore, and that users who want better multiplexing support should use the multiplexing client. I'm also doing it to cut down on confusion from customers as to which multiplexing client they should use if they are starting from scratch", "author": "timtay-microsoft", "createdAt": "2020-11-02T22:58:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMjI2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwMzQ4OA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516403488", "bodyText": "I too am (still) confused by this. If I'm a normal device client user, not multiplexing, will I get any error about this client being deprecated?", "author": "drwill-ms", "createdAt": "2020-11-03T02:55:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMjI2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgxMTEwNA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516811104", "bodyText": "If you are not multiplexing, then you won't get any errors, no. This tag only deprecates the constructor, not the device client class. This constructor was only used when multiplexing using the now deprecated TransportClient", "author": "timtay-microsoft", "createdAt": "2020-11-03T16:48:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMjI2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1Nzk5MQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516857991", "bodyText": "Ah, it wasn't clear to us newbies that TransportClient was code for multiplexing.", "author": "drwill-ms", "createdAt": "2020-11-03T18:01:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMjI2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwMDg2MA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516900860", "bodyText": "The name of it certainly didn't make it obvious that TransportClient is for multiplexing. All the more reason to deprecate it", "author": "timtay-microsoft", "createdAt": "2020-11-03T19:19:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMjI2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMzEzOA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516303138", "bodyText": "add space after the double slash", "author": "barustum", "createdAt": "2020-11-02T22:45:11Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceClient.java", "diffHunk": "@@ -668,6 +685,12 @@ public void subscribeToDeviceMethod(DeviceMethodCallback deviceMethodCallback, O\n         this.subscribeToMethodsInternal(deviceMethodCallback, deviceMethodCallbackContext, deviceMethodStatusCallback, deviceMethodStatusCallbackContext);\n     }\n \n+    //Used by multiplexing clients to signal to this client what kind of multiplexing client is using this device client", "originalCommit": "6a88d33ab305b43dd56726bf57c89f98493fef30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxNDAzNg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516314036", "bodyText": "There really wasn't a good reason to have a list of configs or the protocol at this level. I've delegated that responsibility down to the transport connection since that layer actually needs the protocol value and configs", "author": "timtay-microsoft", "createdAt": "2020-11-02T23:04:21Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -75,16 +77,13 @@\n     private long receivePeriodInMilliseconds;\n \n     private IotHubTransport transport;\n-    private DeviceClientConfig config;\n     private IotHubSendTask sendTask = null;\n     private IotHubReceiveTask receiveTask = null;\n-    private IotHubClientProtocol protocol = null;\n \n     private ScheduledExecutorService receiveTaskScheduler;\n     private ScheduledExecutorService sendTaskScheduler;\n     private IotHubConnectionStatus state;\n \n-    private List<DeviceClientConfig> deviceClientConfigs = new LinkedList<>();", "originalCommit": "3b3efe19125b1e9dc3ee1e0ca5a08bd070d837eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxNDUyMQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516314521", "bodyText": "Totally unrelated to this PR, but thought I'd fix this since I saw it. Never use System.out.println from our library", "author": "timtay-microsoft", "createdAt": "2020-11-02T23:05:10Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceTwin/DeviceTwin.java", "diffHunk": "@@ -69,7 +69,7 @@ public IotHubMessageResult execute(Message message, Object callbackContext)\n                 IotHubStatusCode iotHubStatus = IotHubStatusCode.ERROR;\n                 if (message.getMessageType() != MessageType.DEVICE_TWIN)\n                 {\n-                    System.out.print(\"Unexpected message type received\");", "originalCommit": "3b3efe19125b1e9dc3ee1e0ca5a08bd070d837eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMyMDM2OA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516320368", "bodyText": "It never made sense that we defined the possibility of multiplexing in this interface considering only AMQP supports it, so I've removed it", "author": "timtay-microsoft", "createdAt": "2020-11-02T23:14:07Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransportConnection.java", "diffHunk": "@@ -24,11 +24,9 @@\n {\n     /**\n      * Opens the transport connection object\n-     * @param deviceClientConfigs The list of configs to use. If more than 1 configs are in this list, multiplexing\n-     *                            will be used\n      * @throws TransportException If any exceptions are encountered while opening the connection\n      */\n-    void open(Queue<DeviceClientConfig> deviceClientConfigs) throws TransportException;", "originalCommit": "3b3efe19125b1e9dc3ee1e0ca5a08bd070d837eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMTM1NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516911355", "bodyText": "Not a customer-breaking change?", "author": "drwill-ms", "createdAt": "2020-11-03T19:39:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMyMDM2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNDQwOQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516404409", "bodyText": "We should confirm with Avneet that 1000 devices is sufficient for the customers' requirements.", "author": "drwill-ms", "createdAt": "2020-11-03T03:00:30Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        if (deviceClientList.size() < 1)\n+        {\n+            throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+        }\n+\n+        log.info(\"Opening multiplexing client\");\n+        this.deviceIO.open();\n+        log.info(\"Successfully opened multiplexing client\");\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        log.info(\"Closing multiplexing client\");\n+        for (DeviceClient deviceClient : this.deviceClientList)\n+        {\n+            deviceClient.closeFileUpload();\n+        }\n+\n+        if (this.deviceIO != null)\n+        {\n+            this.deviceIO.multiplexClose();\n+        }\n+\n+        log.info(\"Successfully closed multiplexing client\");\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client instance must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * The registered device client may have its own retry policy and its own SAS token expiry time, separate from every other multiplexed device.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If this device client is already registered, then this method will throw a {@link IllegalStateException}\n+     * <p>\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        for (DeviceClient currentClient : deviceClientList)\n+        {\n+            if (currentClient.getConfig().getDeviceId().equals(deviceClient.getConfig().getDeviceId()))\n+            {\n+                throw new IllegalStateException(\"Cannot register device client because a device client for that device identity has already been registered\");\n+            }\n+        }\n+\n+        if (deviceClient.getConfig().getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+        {\n+            throw new UnsupportedOperationException(\"Can only register a device client if it uses SAS token based authentication\");\n+        }\n+\n+        if (deviceClient.getConfig().getProtocol() != this.protocol)\n+        {\n+            throw new UnsupportedOperationException(\"Cannot register a device client that uses a different transport protocol than this multiplexing client uses\");\n+        }\n+\n+        if (this.protocol == IotHubClientProtocol.AMQPS && this.deviceClientList.size() > 1000)\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed connections over AMQPS only support up to 1000 devices\");", "originalCommit": "ff1c610164699199f630b1379b8407d3dc6e44bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg3MDA0Ng==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516870046", "bodyText": "We (Avneet and I) have already shared this with the customer and they seemed fine with it", "author": "timtay-microsoft", "createdAt": "2020-11-03T18:23:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNDQwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNDYyMw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516404623", "bodyText": "I'd also like us to confirm this restriction with Avneet.", "author": "drwill-ms", "createdAt": "2020-11-03T03:01:29Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        if (deviceClientList.size() < 1)\n+        {\n+            throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+        }\n+\n+        log.info(\"Opening multiplexing client\");\n+        this.deviceIO.open();\n+        log.info(\"Successfully opened multiplexing client\");\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        log.info(\"Closing multiplexing client\");\n+        for (DeviceClient deviceClient : this.deviceClientList)\n+        {\n+            deviceClient.closeFileUpload();\n+        }\n+\n+        if (this.deviceIO != null)\n+        {\n+            this.deviceIO.multiplexClose();\n+        }\n+\n+        log.info(\"Successfully closed multiplexing client\");\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client instance must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * The registered device client may have its own retry policy and its own SAS token expiry time, separate from every other multiplexed device.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If this device client is already registered, then this method will throw a {@link IllegalStateException}\n+     * <p>\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        for (DeviceClient currentClient : deviceClientList)\n+        {\n+            if (currentClient.getConfig().getDeviceId().equals(deviceClient.getConfig().getDeviceId()))\n+            {\n+                throw new IllegalStateException(\"Cannot register device client because a device client for that device identity has already been registered\");\n+            }\n+        }\n+\n+        if (deviceClient.getConfig().getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+        {\n+            throw new UnsupportedOperationException(\"Can only register a device client if it uses SAS token based authentication\");\n+        }\n+\n+        if (deviceClient.getConfig().getProtocol() != this.protocol)\n+        {\n+            throw new UnsupportedOperationException(\"Cannot register a device client that uses a different transport protocol than this multiplexing client uses\");\n+        }\n+\n+        if (this.protocol == IotHubClientProtocol.AMQPS && this.deviceClientList.size() > 1000)\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed connections over AMQPS only support up to 1000 devices\");\n+        }\n+\n+        // Typically client side validation is duplicate work, but IoT Hub doesn't give a good error message when closing the\n+        // AMQPS_WS connection so this is the only way that users will know about this limit\n+        if (this.protocol == IotHubClientProtocol.AMQPS_WS && this.deviceClientList.size() > 500)\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed connections over AMQPS_WS only support up to 500 devices\");\n+        }\n+\n+        if (this.deviceClientList.size() > 1 && !this.deviceClientList.get(0).getConfig().getIotHubHostname().equals(deviceClient.getConfig().getIotHubHostname()))\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed device clients must connect to the same host name\");", "originalCommit": "ff1c610164699199f630b1379b8407d3dc6e44bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1MDc0NA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516850744", "bodyText": "A single TCP connection cannot connect to two hosts, so I doubt this will be an issue", "author": "timtay-microsoft", "createdAt": "2020-11-03T17:50:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNDYyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNDcyNg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516404726", "bodyText": "This doesn't look threadsafe. Shouldn't it be?", "author": "drwill-ms", "createdAt": "2020-11-03T03:01:53Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        if (deviceClientList.size() < 1)\n+        {\n+            throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+        }\n+\n+        log.info(\"Opening multiplexing client\");\n+        this.deviceIO.open();\n+        log.info(\"Successfully opened multiplexing client\");\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        log.info(\"Closing multiplexing client\");\n+        for (DeviceClient deviceClient : this.deviceClientList)\n+        {\n+            deviceClient.closeFileUpload();\n+        }\n+\n+        if (this.deviceIO != null)\n+        {\n+            this.deviceIO.multiplexClose();\n+        }\n+\n+        log.info(\"Successfully closed multiplexing client\");\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client instance must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * The registered device client may have its own retry policy and its own SAS token expiry time, separate from every other multiplexed device.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If this device client is already registered, then this method will throw a {@link IllegalStateException}\n+     * <p>\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        for (DeviceClient currentClient : deviceClientList)\n+        {\n+            if (currentClient.getConfig().getDeviceId().equals(deviceClient.getConfig().getDeviceId()))\n+            {\n+                throw new IllegalStateException(\"Cannot register device client because a device client for that device identity has already been registered\");\n+            }\n+        }\n+\n+        if (deviceClient.getConfig().getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+        {\n+            throw new UnsupportedOperationException(\"Can only register a device client if it uses SAS token based authentication\");\n+        }\n+\n+        if (deviceClient.getConfig().getProtocol() != this.protocol)\n+        {\n+            throw new UnsupportedOperationException(\"Cannot register a device client that uses a different transport protocol than this multiplexing client uses\");\n+        }\n+\n+        if (this.protocol == IotHubClientProtocol.AMQPS && this.deviceClientList.size() > 1000)\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed connections over AMQPS only support up to 1000 devices\");\n+        }\n+\n+        // Typically client side validation is duplicate work, but IoT Hub doesn't give a good error message when closing the\n+        // AMQPS_WS connection so this is the only way that users will know about this limit\n+        if (this.protocol == IotHubClientProtocol.AMQPS_WS && this.deviceClientList.size() > 500)\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed connections over AMQPS_WS only support up to 500 devices\");\n+        }\n+\n+        if (this.deviceClientList.size() > 1 && !this.deviceClientList.get(0).getConfig().getIotHubHostname().equals(deviceClient.getConfig().getIotHubHostname()))\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed device clients must connect to the same host name\");\n+        }\n+\n+        // The first device to be registered will cause this client to build the IO layer with its configuration\n+        if (this.deviceIO == null)", "originalCommit": "ff1c610164699199f630b1379b8407d3dc6e44bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1MTYyNw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516851627", "bodyText": "It should be. I'll add a lock to synchronize the register/unregister calls onto", "author": "timtay-microsoft", "createdAt": "2020-11-03T17:51:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNDcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1OTE0NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516859145", "bodyText": "I think 186 - 200 should be in a synchronized block", "author": "azabbasi", "createdAt": "2020-11-03T18:04:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNDcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNDk0OQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516404949", "bodyText": "This is an interesting case. Why do we have this restriction, and what options might we have for fixing that?", "author": "drwill-ms", "createdAt": "2020-11-03T03:03:00Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        if (deviceClientList.size() < 1)\n+        {\n+            throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+        }\n+\n+        log.info(\"Opening multiplexing client\");\n+        this.deviceIO.open();\n+        log.info(\"Successfully opened multiplexing client\");\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        log.info(\"Closing multiplexing client\");\n+        for (DeviceClient deviceClient : this.deviceClientList)\n+        {\n+            deviceClient.closeFileUpload();\n+        }\n+\n+        if (this.deviceIO != null)\n+        {\n+            this.deviceIO.multiplexClose();\n+        }\n+\n+        log.info(\"Successfully closed multiplexing client\");\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client instance must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * The registered device client may have its own retry policy and its own SAS token expiry time, separate from every other multiplexed device.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If this device client is already registered, then this method will throw a {@link IllegalStateException}\n+     * <p>\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        for (DeviceClient currentClient : deviceClientList)\n+        {\n+            if (currentClient.getConfig().getDeviceId().equals(deviceClient.getConfig().getDeviceId()))\n+            {\n+                throw new IllegalStateException(\"Cannot register device client because a device client for that device identity has already been registered\");\n+            }\n+        }\n+\n+        if (deviceClient.getConfig().getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+        {\n+            throw new UnsupportedOperationException(\"Can only register a device client if it uses SAS token based authentication\");\n+        }\n+\n+        if (deviceClient.getConfig().getProtocol() != this.protocol)\n+        {\n+            throw new UnsupportedOperationException(\"Cannot register a device client that uses a different transport protocol than this multiplexing client uses\");\n+        }\n+\n+        if (this.protocol == IotHubClientProtocol.AMQPS && this.deviceClientList.size() > 1000)\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed connections over AMQPS only support up to 1000 devices\");\n+        }\n+\n+        // Typically client side validation is duplicate work, but IoT Hub doesn't give a good error message when closing the\n+        // AMQPS_WS connection so this is the only way that users will know about this limit\n+        if (this.protocol == IotHubClientProtocol.AMQPS_WS && this.deviceClientList.size() > 500)\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed connections over AMQPS_WS only support up to 500 devices\");\n+        }\n+\n+        if (this.deviceClientList.size() > 1 && !this.deviceClientList.get(0).getConfig().getIotHubHostname().equals(deviceClient.getConfig().getIotHubHostname()))\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed device clients must connect to the same host name\");\n+        }\n+\n+        // The first device to be registered will cause this client to build the IO layer with its configuration\n+        if (this.deviceIO == null)\n+        {\n+            log.debug(\"Creating DeviceIO layer for multiplexing client since this is the first registered device\");\n+            this.deviceIO = new DeviceIO(deviceClient.getConfig(), SEND_PERIOD_MILLIS, RECEIVE_PERIOD_MILLIS);\n+        }\n+\n+        deviceClient.setDeviceIO(this.deviceIO);\n+        deviceClient.getConfig().setProxy(this.proxySettings);\n+        deviceClient.setConnectionType(IoTHubConnectionType.USE_MULTIPLEXING_CLIENT);\n+        this.deviceClientList.add(deviceClient);\n+\n+        // if the device IO hasn't been created yet, then this client will be registered once it is created.\n+        log.info(\"Registering device {} to multiplexing client\", deviceClient.getConfig().getDeviceId());\n+        this.deviceIO.registerMultiplexedDeviceClient(deviceClient.getConfig());\n+    }\n+\n+    /**\n+     * Remove a device client from this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will close the AMQP device session associated with\n+     * this device, but it will not close any other registered device sessions or the multiplexing client itself.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation and you can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * <p>\n+     * If the multiplexed connection is already open, then at least one device client must be registered at any given time.\n+     * Because of this, this method will throw an {@link IllegalStateException} if it attempts to remove the last device client.\n+     * <p>\n+     * @param deviceClient The device client to unregister from this multiplexing client.\n+     */\n+    public void unregisterDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        if (deviceClientList.size() <= 1)", "originalCommit": "ff1c610164699199f630b1379b8407d3dc6e44bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1MzcxMg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516853712", "bodyText": "The problem here is that we cannot remove the last device session from a multiplexed connection without the whole multiplexed connection getting shut down. One option here is to just allow the connection to close if it is the last device session to be unregistered, but that feels unintuitive to me", "author": "timtay-microsoft", "createdAt": "2020-11-03T17:54:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNDk0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg3MTEzMQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516871131", "bodyText": "It is interesting. I think this needs to be more clear, maybe we should first look for the device in the devicelist and throw if we can't find it.\nthen if it's there and it's the last one, while maintaining thread safety, close the deviceIO and allow the multiplex client to not have any devices.\njust as you would when you first initialize it. just a thought ... curious what else we can do here.", "author": "azabbasi", "createdAt": "2020-11-03T18:25:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNDk0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyMjg0OQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516922849", "bodyText": "I like the idea of returning to the initialized state, however I recall seeing that when initializing you had to have at least 1 device then too.", "author": "drwill-ms", "createdAt": "2020-11-03T20:00:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNDk0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAyMzE3Mg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520023172", "bodyText": "Resolving this thread since the multplexing client now lets you have a multiplexed connection open with no devices registered", "author": "timtay-microsoft", "createdAt": "2020-11-09T18:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNDk0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNTA1Nw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516405057", "bodyText": "As long as we're fixing this, I don't see why it would be capitalized. It isn't a proper noun, right?", "author": "drwill-ms", "createdAt": "2020-11-03T03:03:30Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubListener.java", "diffHunk": "@@ -11,7 +11,7 @@\n \n /**\n  * Callback interface for communicating connection and message status updates from individual protocol clients\n- * (mqtt, https, amqps) to the Tranpsort layer that handles queueing of messages and connecting/reconnecting/disconnecting\n+ * (mqtt, https, amqps) to the Transport layer that handles queueing of messages and connecting/reconnecting/disconnecting", "originalCommit": "ff1c610164699199f630b1379b8407d3dc6e44bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNTIzNw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516405237", "bodyText": "Maybe this is just me, but I cringe at the word \"statuses\". I much prefer \"states\". Thoughts?", "author": "drwill-ms", "createdAt": "2020-11-03T03:04:14Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -30,47 +30,54 @@\n public class IotHubTransport implements IotHubListener\n {\n     private static final int MAX_MESSAGES_TO_SEND_PER_THREAD = 10;\n+\n+    // For tracking the state of this layer in particular. If multiplexing, this value may be CONNECTED while a\n+    // device specific state is DISCONNECTED_RETRYING. If this state is DISCONNECTED_RETRYING, then the multiplexed\n+    // connection will be completely torn down and re-opened.\n     private volatile IotHubConnectionStatus connectionStatus;\n+\n+    // for multiplexing. A particular device can be disconnected retrying while the tcp connection is fine and the other\n+    // device sessions are open.\n+    private Map<String, IotHubConnectionStatus> deviceConnectionStatuses = new HashMap<>();", "originalCommit": "ff1c610164699199f630b1379b8407d3dc6e44bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzOTMwMQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516839301", "bodyText": "nit: I would change and construct this string by using the class and method names so we won't have any refactoring issues.", "author": "azabbasi", "createdAt": "2020-11-03T17:31:01Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceClient.java", "diffHunk": "@@ -376,6 +378,11 @@ private void commonConstructorVerifications() throws UnsupportedOperationExcepti\n      */\n     public void open() throws IOException\n     {\n+        if (this.ioTHubConnectionType == IoTHubConnectionType.USE_MULTIPLEXING_CLIENT)\n+        {\n+            throw new UnsupportedOperationException(\"Cannot open a multiplexed client through this method. Must use multiplexingClient.registerDeviceClient(deviceClient)\");", "originalCommit": "82af88904d85ecdbe000a03a5125ee584bab7f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1NDg2NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516854865", "bodyText": "Strings outside of javadocs don't support the {@ link } notation, if that is what you are getting at.", "author": "timtay-microsoft", "createdAt": "2020-11-03T17:56:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzOTMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg3MjcxMQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516872711", "bodyText": "ah, there is no equivalent of nameof in java. Fair enough", "author": "azabbasi", "createdAt": "2020-11-03T18:28:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzOTMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0MDgxNQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516840815", "bodyText": "this check seems useful, why remove it?", "author": "azabbasi", "createdAt": "2020-11-03T17:33:31Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -101,16 +100,8 @@\n      */\n     DeviceIO(DeviceClientConfig config, long sendPeriodInMilliseconds, long receivePeriodInMilliseconds)\n     {\n-        /* Codes_SRS_DEVICE_IO_21_002: [If the `config` is null, the constructor shall throw an IllegalArgumentException.] */\n-        if(config == null)", "originalCommit": "82af88904d85ecdbe000a03a5125ee584bab7f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0MTE1Mg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516841152", "bodyText": "unless it happens in the public method that calls this one ...", "author": "azabbasi", "createdAt": "2020-11-03T17:34:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0MDgxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1NjMxNw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516856317", "bodyText": "I can add this back in. The DeviceIO layer doesn't do much with the config object, but it does dereference it at least once so there is value in leaving this check.", "author": "timtay-microsoft", "createdAt": "2020-11-03T17:59:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0MDgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0MjkxMg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516842912", "bodyText": "does DISCONNECTED status means all the tasks schedulers are shut down?", "author": "azabbasi", "createdAt": "2020-11-03T17:37:09Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -218,6 +215,11 @@ public void close() throws IOException\n     {\n         synchronized (this.stateLock)\n         {\n+            if (state == IotHubConnectionStatus.DISCONNECTED)", "originalCommit": "82af88904d85ecdbe000a03a5125ee584bab7f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1NzAwMA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516857000", "bodyText": "Yes", "author": "timtay-microsoft", "createdAt": "2020-11-03T18:00:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0MjkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0NDgyMA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516844820", "bodyText": "double negative method name. We can just call it verifyRegisteredIfMultiplexing", "author": "azabbasi", "createdAt": "2020-11-03T17:40:15Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/InternalClient.java", "diffHunk": "@@ -180,6 +183,8 @@ public void closeNow() throws IOException\n      */\n     public void sendEventAsync(Message message, IotHubEventCallback callback, Object callbackContext)\n     {\n+        verifyNotUnregisteredIfMultiplexing();", "originalCommit": "82af88904d85ecdbe000a03a5125ee584bab7f85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0NjI0MA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516846240", "bodyText": "can this.deviceIO be null? then shouldn't this method throw?", "author": "azabbasi", "createdAt": "2020-11-03T17:42:43Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/InternalClient.java", "diffHunk": "@@ -354,8 +369,13 @@ public void sendReportedProperties(Set<Property> reportedProperties, int version\n      */\n     public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) throws IllegalArgumentException\n     {\n-        //Codes_SRS_INTERNALCLIENT_34_069: [This function shall register the provided callback and context with its device IO instance.]\n-        this.deviceIO.registerConnectionStatusChangeCallback(callback, callbackContext);\n+        this.connectionStatusChangeCallback = callback;\n+        this.connectionStatusChangeCallbackContext = callbackContext;\n+\n+        if (this.deviceIO != null)", "originalCommit": "82af88904d85ecdbe000a03a5125ee584bab7f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1MDMwOA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516850308", "bodyText": "I see that it can be null if it's using multiplexing ... ignore my previous commnet.", "author": "azabbasi", "createdAt": "2020-11-03T17:49:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0NjI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1MDg3Nw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516850877", "bodyText": "if we had a boolean flag that we would set if multiplexing was registered, we could just check that  ... just a thought", "author": "azabbasi", "createdAt": "2020-11-03T17:50:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0NjI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1ODUzMw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516858533", "bodyText": "We sort of have that flag already at the DeviceClient level in the Enum ioTHubConnectionType\nUnfortunately, the internal client level also encompasses the ModuleClient, which has no concept of multiplexing. I'm a bit on the fence about adding a boolean about multiplexing at this level because of that", "author": "timtay-microsoft", "createdAt": "2020-11-03T18:02:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0NjI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg3Mzc3OA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516873778", "bodyText": "fair enough. just wanted to bring it up if it might add value to not rely on contextual knowledge about how the multiplexing is designed to read the code.", "author": "azabbasi", "createdAt": "2020-11-03T18:30:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0NjI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyMzMwNg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516923306", "bodyText": "How about a method isClientMultiplexing() and have the body of that return this.deviceIO != null. It reads better, and if you later device to change the condition, you won't have to update it in several places.", "author": "drwill-ms", "createdAt": "2020-11-03T20:01:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0NjI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY5MjU4NA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r517692584", "bodyText": "I've added a isMultiplexed flag within the InternalClient now to make this stuff more obvious, and so that it can be referenced when we want to block certain things like setting the proxySettings of a multiplexed device", "author": "timtay-microsoft", "createdAt": "2020-11-04T23:31:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0NjI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0NjY4Mw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516846683", "bodyText": "nit: break this line into multiple lines for readability", "author": "azabbasi", "createdAt": "2020-11-03T17:43:33Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/InternalClient.java", "diffHunk": "@@ -745,7 +773,15 @@ DeviceIO getDeviceIO()\n      */\n     void setDeviceIO(DeviceIO deviceIO)\n     {\n+        // deviceIO may be set to null in the case when a device client was multiplexing and was unregistered\n         this.deviceIO = deviceIO;\n+\n+        // Since connection status callbacks can be registered before associating a device client with a multiplexing client, the callback and its\n+        // context also need to be registered when the device IO is set.\n+        if (this.deviceIO != null && this.connectionStatusChangeCallback != null)\n+        {\n+            this.deviceIO.registerConnectionStatusChangeCallback(this.connectionStatusChangeCallback, this.connectionStatusChangeCallbackContext, this.getConfig().getDeviceId());", "originalCommit": "82af88904d85ecdbe000a03a5125ee584bab7f85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0ODk4NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516848985", "bodyText": "good catch, we can probably check to see if it's null at the beginning and throw there. before we check for anything else.", "author": "azabbasi", "createdAt": "2020-11-03T17:47:10Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/InternalClient.java", "diffHunk": "@@ -948,13 +984,15 @@ void setOption_SetAmqpOpenDeviceSessionsTimeout(Object value)\n      */\n     public void setProxySettings(ProxySettings proxySettings)\n     {\n+        verifyNotUnregisteredIfMultiplexing();\n+\n         if (this.deviceIO.isOpen())\n         {\n             throw new IllegalStateException(\"Cannot set proxy after connection was already opened\");\n         }\n \n         IotHubClientProtocol protocol = this.deviceIO.getProtocol();\n-        if (protocol != HTTPS && protocol != AMQPS_WS && protocol != MQTT_WS)\n+        if (protocol != HTTPS && protocol != AMQPS_WS && protocol != MQTT_WS && proxySettings != null)", "originalCommit": "82af88904d85ecdbe000a03a5125ee584bab7f85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0OTgzNQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516849835", "bodyText": "is this the only indication of the client using multiplexing? no boolean indicator anywhere? it would probably be useful to have.", "author": "azabbasi", "createdAt": "2020-11-03T17:48:39Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/InternalClient.java", "diffHunk": "@@ -980,4 +1018,13 @@ private void commonConstructorVerification(IotHubConnectionString connectionStri\n             throw new UnsupportedOperationException(\"Communication with edgehub only supported by MQTT/MQTT_WS and AMQPS/AMQPS_WS\");\n         }\n     }\n+\n+    private void verifyNotUnregisteredIfMultiplexing()\n+    {\n+        // deviceIO is only ever null when a client was registered to a multiplexing client, became unregistered, and hasn't be re-registered yet.", "originalCommit": "82af88904d85ecdbe000a03a5125ee584bab7f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1OTAyNA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516859024", "bodyText": "We have an enum ioTHubConnectionType at the DeviceClient level, but not at the internal client level. I'm on the fence about adding one since ModuleClient also uses this class and has no concept of multiplexing", "author": "timtay-microsoft", "createdAt": "2020-11-03T18:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0OTgzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1Mzk5Nw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516853997", "bodyText": "can you elaborate why we don't have to close every device client as well?\nlike this:\ndeviceClient.close()", "author": "azabbasi", "createdAt": "2020-11-03T17:55:19Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        if (deviceClientList.size() < 1)\n+        {\n+            throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+        }\n+\n+        log.info(\"Opening multiplexing client\");\n+        this.deviceIO.open();\n+        log.info(\"Successfully opened multiplexing client\");\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        log.info(\"Closing multiplexing client\");\n+        for (DeviceClient deviceClient : this.deviceClientList)\n+        {\n+            deviceClient.closeFileUpload();", "originalCommit": "82af88904d85ecdbe000a03a5125ee584bab7f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg3NzAzNA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516877034", "bodyText": "I can add a comment about this, but deviceClient.Close() only closes the deviceIO layer, and that layer is closed by this class instead", "author": "timtay-microsoft", "createdAt": "2020-11-03T18:36:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1Mzk5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1NDU5Nw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516854597", "bodyText": "is this limitation documented somewhere that we can link this paragraph to?", "author": "azabbasi", "createdAt": "2020-11-03T17:56:14Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        if (deviceClientList.size() < 1)\n+        {\n+            throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+        }\n+\n+        log.info(\"Opening multiplexing client\");\n+        this.deviceIO.open();\n+        log.info(\"Successfully opened multiplexing client\");\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        log.info(\"Closing multiplexing client\");\n+        for (DeviceClient deviceClient : this.deviceClientList)\n+        {\n+            deviceClient.closeFileUpload();\n+        }\n+\n+        if (this.deviceIO != null)\n+        {\n+            this.deviceIO.multiplexClose();\n+        }\n+\n+        log.info(\"Successfully closed multiplexing client\");\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a", "originalCommit": "82af88904d85ecdbe000a03a5125ee584bab7f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg3NzgyMQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516877821", "bodyText": "Sadly no. I had to ask for this information from a service team member directly", "author": "timtay-microsoft", "createdAt": "2020-11-03T18:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1NDU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1NjE3Mw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516856173", "bodyText": "do we check to see if we are overwriting any proxy setting on individual devices? just as warning maybe? it's an unlikely event but might be useful to warn the user about", "author": "azabbasi", "createdAt": "2020-11-03T17:58:50Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        if (deviceClientList.size() < 1)\n+        {\n+            throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+        }\n+\n+        log.info(\"Opening multiplexing client\");\n+        this.deviceIO.open();\n+        log.info(\"Successfully opened multiplexing client\");\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        log.info(\"Closing multiplexing client\");\n+        for (DeviceClient deviceClient : this.deviceClientList)\n+        {\n+            deviceClient.closeFileUpload();\n+        }\n+\n+        if (this.deviceIO != null)\n+        {\n+            this.deviceIO.multiplexClose();\n+        }\n+\n+        log.info(\"Successfully closed multiplexing client\");\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.", "originalCommit": "82af88904d85ecdbe000a03a5125ee584bab7f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg4MDc0OQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516880749", "bodyText": "I could add something like that, but I think the typical use case will involve customers setting the proxy settings at the MultiplexingClient level, and not also setting them at each device client level. Because of that, if I add a warning log here, customers will hit it even when using our library correctly.\nMultiplexingClient multiplexingClient = new MultiplexingClient(protocol, someProxySettings);\nDeviceClient[] multiplexedDeviceClients = new DeviceClient[MULTIPLEXED_DEVICE_CLIENT_COUNT];\n\nfor (int i = 0; i < MULTIPLEXED_DEVICE_CLIENT_COUNT; i++)\n{\n    //Users would have to do this to avoid the warning log if we add it, which feels unnecessary\n    multiplexedDeviceClients.setProxySettings(someProxySettings);\n}", "author": "timtay-microsoft", "createdAt": "2020-11-03T18:43:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1NjE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1NjkxMA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516856910", "bodyText": "should we throw in this case? can't we just be resilient to this?", "author": "azabbasi", "createdAt": "2020-11-03T18:00:03Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        if (deviceClientList.size() < 1)\n+        {\n+            throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+        }\n+\n+        log.info(\"Opening multiplexing client\");\n+        this.deviceIO.open();\n+        log.info(\"Successfully opened multiplexing client\");\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        log.info(\"Closing multiplexing client\");\n+        for (DeviceClient deviceClient : this.deviceClientList)\n+        {\n+            deviceClient.closeFileUpload();\n+        }\n+\n+        if (this.deviceIO != null)\n+        {\n+            this.deviceIO.multiplexClose();\n+        }\n+\n+        log.info(\"Successfully closed multiplexing client\");\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client instance must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * The registered device client may have its own retry policy and its own SAS token expiry time, separate from every other multiplexed device.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If this device client is already registered, then this method will throw a {@link IllegalStateException}\n+     * <p>\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        for (DeviceClient currentClient : deviceClientList)\n+        {\n+            if (currentClient.getConfig().getDeviceId().equals(deviceClient.getConfig().getDeviceId()))", "originalCommit": "82af88904d85ecdbe000a03a5125ee584bab7f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg4NTcwNw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516885707", "bodyText": "We'd need to at least log a warning about attempting to re-register an already registered client. I'm of the mindset that anyone who does that is probably doing it accidentally, and should be notified more strongly with this exception", "author": "timtay-microsoft", "createdAt": "2020-11-03T18:52:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1NjkxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwMzM2OA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516903368", "bodyText": "I don't disagree, but throwing is not just a warning. I don't feel too strongly about this, but I think if we can move on with the operation with no setbacks or issues, we should try doing that. this seems a fairly innocent operation to add an already existing device to multiplexing client.", "author": "azabbasi", "createdAt": "2020-11-03T19:24:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1NjkxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwOTQxMA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516909410", "bodyText": "Fair enough. I'll make this just log what happens instead. I guess it is analogous to trying to open an already open device client, and we do allow that without throwing", "author": "timtay-microsoft", "createdAt": "2020-11-03T19:35:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1NjkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1ODQzOA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516858438", "bodyText": "is this check case insensitive?", "author": "azabbasi", "createdAt": "2020-11-03T18:02:44Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        if (deviceClientList.size() < 1)\n+        {\n+            throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+        }\n+\n+        log.info(\"Opening multiplexing client\");\n+        this.deviceIO.open();\n+        log.info(\"Successfully opened multiplexing client\");\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        log.info(\"Closing multiplexing client\");\n+        for (DeviceClient deviceClient : this.deviceClientList)\n+        {\n+            deviceClient.closeFileUpload();\n+        }\n+\n+        if (this.deviceIO != null)\n+        {\n+            this.deviceIO.multiplexClose();\n+        }\n+\n+        log.info(\"Successfully closed multiplexing client\");\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client instance must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * The registered device client may have its own retry policy and its own SAS token expiry time, separate from every other multiplexed device.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If this device client is already registered, then this method will throw a {@link IllegalStateException}\n+     * <p>\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        for (DeviceClient currentClient : deviceClientList)\n+        {\n+            if (currentClient.getConfig().getDeviceId().equals(deviceClient.getConfig().getDeviceId()))\n+            {\n+                throw new IllegalStateException(\"Cannot register device client because a device client for that device identity has already been registered\");\n+            }\n+        }\n+\n+        if (deviceClient.getConfig().getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+        {\n+            throw new UnsupportedOperationException(\"Can only register a device client if it uses SAS token based authentication\");\n+        }\n+\n+        if (deviceClient.getConfig().getProtocol() != this.protocol)\n+        {\n+            throw new UnsupportedOperationException(\"Cannot register a device client that uses a different transport protocol than this multiplexing client uses\");\n+        }\n+\n+        if (this.protocol == IotHubClientProtocol.AMQPS && this.deviceClientList.size() > 1000)\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed connections over AMQPS only support up to 1000 devices\");\n+        }\n+\n+        // Typically client side validation is duplicate work, but IoT Hub doesn't give a good error message when closing the\n+        // AMQPS_WS connection so this is the only way that users will know about this limit\n+        if (this.protocol == IotHubClientProtocol.AMQPS_WS && this.deviceClientList.size() > 500)\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed connections over AMQPS_WS only support up to 500 devices\");\n+        }\n+\n+        if (this.deviceClientList.size() > 1 && !this.deviceClientList.get(0).getConfig().getIotHubHostname().equals(deviceClient.getConfig().getIotHubHostname()))", "originalCommit": "82af88904d85ecdbe000a03a5125ee584bab7f85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg4MjYxNA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516882614", "bodyText": "It is, but it should be insensitive. I'll fix it", "author": "timtay-microsoft", "createdAt": "2020-11-03T18:46:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1ODQzOA=="}], "type": "inlineReview"}, {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/b7af2b477c526150c91e5853fcb3ddd8b39fe760", "message": "feat(iot-dev): Add multiplexing client that supports device registration/unregistration during open connection\n\nTransportClient was our multiplexing client, but there was no way to add the ability to add/remove devices from an active connection without breaking the APIs in that class, so this deprecates the transport client in favor of a new MultiplexingClient.\n\nSignificant changes had to made to the IotHubTransport layer so that each multiplexed client could have its own connection state and so that each multiplexed client could have its own focused retry logic. Instead of closing the entire multiplexed connection every time a session drops, the transport layer can re-open individual device sessions", "committedDate": "2020-11-03T18:59:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5MTY5Mw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516891693", "bodyText": "This can have multiplex in the name of the call back to avoid confusion ... maybe onDeviceMultiplexSessionEstablished\nsame for the method below.", "author": "azabbasi", "createdAt": "2020-11-03T19:03:24Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubListener.java", "diffHunk": "@@ -43,4 +43,16 @@\n      * @param connectionId the id of the connection this update is relevant to\n      */\n     void onConnectionEstablished(String connectionId);\n+\n+    /**\n+     * Callback to be fired when the multiplexed connection establishes a new device session.\n+     * @param deviceId the Id of the device that the session belongs to\n+     */\n+    void onDeviceSessionEstablished(String connectionId, String deviceId);", "originalCommit": "b7af2b477c526150c91e5853fcb3ddd8b39fe760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5MjQwMg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516892402", "bodyText": "space between + s", "author": "azabbasi", "createdAt": "2020-11-03T19:04:28Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/ReconnectionNotifier.java", "diffHunk": "@@ -21,7 +22,21 @@ public static void notifyDisconnectAsync(final Throwable connectionLossCause, fi\n                         listener.onConnectionLost(connectionLossCause,connectionId);\n                     }\n                 },\n-                THREAD_NAME+\":\"+connectionId\n+                CONNECTION_RECONNECTION_THREAD_NAME+\":\"+connectionId", "originalCommit": "b7af2b477c526150c91e5853fcb3ddd8b39fe760", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5Mjk0OQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516892949", "bodyText": "same on line 39", "author": "azabbasi", "createdAt": "2020-11-03T19:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5MjQwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwMzc5OQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516903799", "bodyText": "Seems this might take a long time. No way to parallelize?", "author": "drwill-ms", "createdAt": "2020-11-03T19:25:29Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,252 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (this.lock)\n+        {\n+            if (deviceClientList.size() < 1)\n+            {\n+                throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+            }\n+\n+            log.info(\"Opening multiplexing client\");\n+            this.deviceIO.open();\n+            log.info(\"Successfully opened multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        synchronized (this.lock)\n+        {\n+            log.info(\"Closing multiplexing client\");\n+            for (DeviceClient deviceClient : this.deviceClientList)\n+            {\n+                deviceClient.closeFileUpload();", "originalCommit": "b7af2b477c526150c91e5853fcb3ddd8b39fe760", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNjM1Mg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516906352", "bodyText": "Not without spawning other threads, which is a bit much since we should aim to support constrained devices", "author": "timtay-microsoft", "createdAt": "2020-11-03T19:29:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwMzc5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxODc5NA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516918794", "bodyText": "I guess we could make it an option (even later), of how many threads to handle parallelization across the clients. Default would be 1, which would maintain current behavior.", "author": "drwill-ms", "createdAt": "2020-11-03T19:52:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwMzc5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNTE3NA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516905174", "bodyText": "Reads a bit funny. I feel not having a subject on the sentence makes it sound weird too. Thoughts?\nA device client cannot be registered to a multiplexing client that specifies a different transport protocol.", "author": "drwill-ms", "createdAt": "2020-11-03T19:27:59Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,252 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (this.lock)\n+        {\n+            if (deviceClientList.size() < 1)\n+            {\n+                throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+            }\n+\n+            log.info(\"Opening multiplexing client\");\n+            this.deviceIO.open();\n+            log.info(\"Successfully opened multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        synchronized (this.lock)\n+        {\n+            log.info(\"Closing multiplexing client\");\n+            for (DeviceClient deviceClient : this.deviceClientList)\n+            {\n+                deviceClient.closeFileUpload();\n+            }\n+\n+            if (this.deviceIO != null)\n+            {\n+                this.deviceIO.multiplexClose();\n+            }\n+\n+            // Note that this method does not close each of the registered device client instances. This is intentional\n+            // as the calls to deviceClient.close() do nothing besides close the deviceIO layer, which is already closed\n+            // by the above code.\n+\n+            log.info(\"Successfully closed multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client instance must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * The registered device client may have its own retry policy and its own SAS token expiry time, separate from every other multiplexed device.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If this device client is already registered, then this method will throw a {@link IllegalStateException}\n+     * <p>\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        synchronized (this.lock)\n+        {\n+            for (DeviceClient currentClient : deviceClientList)\n+            {\n+                if (currentClient.getConfig().getDeviceId().equalsIgnoreCase(deviceClient.getConfig().getDeviceId()))\n+                {\n+                    throw new IllegalStateException(\"Cannot register device client because a device client for that device identity has already been registered\");\n+                }\n+            }\n+\n+            if (deviceClient.getConfig().getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+            {\n+                throw new UnsupportedOperationException(\"Can only register a device client if it uses SAS token based authentication\");\n+            }\n+\n+            if (deviceClient.getConfig().getProtocol() != this.protocol)\n+            {\n+                throw new UnsupportedOperationException(\"Cannot register a device client that uses a different transport protocol than this multiplexing client uses\");", "originalCommit": "b7af2b477c526150c91e5853fcb3ddd8b39fe760", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNjI2Mg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516906262", "bodyText": "Other errors could use similar clean up", "author": "drwill-ms", "createdAt": "2020-11-03T19:29:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNTE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNjMxOQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516906319", "bodyText": "same for these guys, if this is only applicable to multiplexed sessions, it would be nice to have that in the name.", "author": "azabbasi", "createdAt": "2020-11-03T19:29:56Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/amqps/AmqpsSessionStateCallback.java", "diffHunk": "@@ -52,7 +52,25 @@\n      * closed unexpectedly.\n      *\n      * @param errorCondition the condition of the session that caused the close if the session closed remotely, or the condition\n-     *                       of the link that closed unexpectedly\n+     *                       of the link that closed unexpectedly.\n+     * @param deviceId the device that the session belonged to.\n      */\n-    void onSessionClosedUnexpectedly(ErrorCondition errorCondition);\n+    void onSessionClosedUnexpectedly(ErrorCondition errorCondition, String deviceId);\n+\n+    /**\n+     * Executed if a session closes, but it was expected. Likely due to user calling close on the connection, or\n+     * unregistering a device from an active multiplexed connection\n+     *\n+     * @param deviceId the device whose connection closed.\n+     */\n+    void onSessionClosedAsExpected(String deviceId);", "originalCommit": "b7af2b477c526150c91e5853fcb3ddd8b39fe760", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNzA5NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516907095", "bodyText": "This one isn't limited to multiplexed connections. Even in single device connections, this callback will be fired during cleanup", "author": "timtay-microsoft", "createdAt": "2020-11-03T19:31:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNjMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNjQ1Nw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516906457", "bodyText": "How about we make this 1000 a constant, and refer to it in the error message too?", "author": "drwill-ms", "createdAt": "2020-11-03T19:30:08Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,252 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (this.lock)\n+        {\n+            if (deviceClientList.size() < 1)\n+            {\n+                throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+            }\n+\n+            log.info(\"Opening multiplexing client\");\n+            this.deviceIO.open();\n+            log.info(\"Successfully opened multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        synchronized (this.lock)\n+        {\n+            log.info(\"Closing multiplexing client\");\n+            for (DeviceClient deviceClient : this.deviceClientList)\n+            {\n+                deviceClient.closeFileUpload();\n+            }\n+\n+            if (this.deviceIO != null)\n+            {\n+                this.deviceIO.multiplexClose();\n+            }\n+\n+            // Note that this method does not close each of the registered device client instances. This is intentional\n+            // as the calls to deviceClient.close() do nothing besides close the deviceIO layer, which is already closed\n+            // by the above code.\n+\n+            log.info(\"Successfully closed multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client instance must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * The registered device client may have its own retry policy and its own SAS token expiry time, separate from every other multiplexed device.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If this device client is already registered, then this method will throw a {@link IllegalStateException}\n+     * <p>\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        synchronized (this.lock)\n+        {\n+            for (DeviceClient currentClient : deviceClientList)\n+            {\n+                if (currentClient.getConfig().getDeviceId().equalsIgnoreCase(deviceClient.getConfig().getDeviceId()))\n+                {\n+                    throw new IllegalStateException(\"Cannot register device client because a device client for that device identity has already been registered\");\n+                }\n+            }\n+\n+            if (deviceClient.getConfig().getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+            {\n+                throw new UnsupportedOperationException(\"Can only register a device client if it uses SAS token based authentication\");\n+            }\n+\n+            if (deviceClient.getConfig().getProtocol() != this.protocol)\n+            {\n+                throw new UnsupportedOperationException(\"Cannot register a device client that uses a different transport protocol than this multiplexing client uses\");\n+            }\n+\n+            if (this.protocol == IotHubClientProtocol.AMQPS && this.deviceClientList.size() > 1000)", "originalCommit": "b7af2b477c526150c91e5853fcb3ddd8b39fe760", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNjcyMw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516906723", "bodyText": "Could be a public constant too, to let users know the max number of multiplexed devices", "author": "drwill-ms", "createdAt": "2020-11-03T19:30:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNjQ1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyMTg1Ng==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516921856", "bodyText": "I'm a bit hesitant to make it a public variable because the service may change these limits arbitrarily later. We don't want customers using this value directly if we update it from 1,000 to 100,000 to match the service limits. I'd rather just document it in the headers clearly.", "author": "timtay-microsoft", "createdAt": "2020-11-03T19:58:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNjQ1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyNDI2Ng==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516924266", "bodyText": "If the service updates it, and we've been checking it in our code, they'll be broken anyway. We'd just be making the limits we're adhering to public.\nI'd say either the client SDK doesn't check these limits, and just lets the service return an error, or we share the limits we're abiding by.", "author": "drwill-ms", "createdAt": "2020-11-03T20:03:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNjQ1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk5NTc1Ng==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516995756", "bodyText": "Okay, I can make these public then", "author": "timtay-microsoft", "createdAt": "2020-11-03T22:35:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNjQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNzA3Mg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516907072", "bodyText": ":D why did we have a queue if it wasn't allowed to be larger than 1 !!! strange ...", "author": "azabbasi", "createdAt": "2020-11-03T19:31:16Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/mqtt/MqttIotHubConnection.java", "diffHunk": "@@ -101,14 +101,9 @@ public MqttIotHubConnection(DeviceClientConfig config) throws IllegalArgumentExc\n      *\n      * @throws TransportException if a connection could not to be established.\n      */\n-    public void open(Queue<DeviceClientConfig> deviceClientConfigs) throws TransportException", "originalCommit": "b7af2b477c526150c91e5853fcb3ddd8b39fe760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwODg1NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516908855", "bodyText": "plural", "author": "drwill-ms", "createdAt": "2020-11-03T19:34:32Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -820,21 +901,80 @@ private void handleDisconnection(TransportException transportException)\n         reconnect(transportException);\n     }\n \n+    // should only be called when multiplexing an only a particular device went offline\n+    private void reconnectDeviceSession(TransportException transportException, String deviceId)\n+    {\n+        long reconnectionStartTimeMillis = System.currentTimeMillis();\n+        int reconnectionAttempt = 0;", "originalCommit": "b7af2b477c526150c91e5853fcb3ddd8b39fe760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwOTQwMA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516909400", "bodyText": "Poor grammar. Maybe this?\n\"Attempting device session reconnect: attempt {}\"", "author": "drwill-ms", "createdAt": "2020-11-03T19:35:33Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -820,21 +901,80 @@ private void handleDisconnection(TransportException transportException)\n         reconnect(transportException);\n     }\n \n+    // should only be called when multiplexing an only a particular device went offline\n+    private void reconnectDeviceSession(TransportException transportException, String deviceId)\n+    {\n+        long reconnectionStartTimeMillis = System.currentTimeMillis();\n+        int reconnectionAttempt = 0;\n+        boolean hasReconnectOperationTimedOut = this.hasOperationTimedOut(reconnectionStartTimeMillis, deviceId);\n+        RetryDecision retryDecision = null;\n+\n+        while (this.deviceConnectionStates.get(deviceId) == IotHubConnectionStatus.DISCONNECTED_RETRYING\n+                && !hasReconnectOperationTimedOut)\n+        {\n+            this.log.trace(\"Attempting device session reconnect attempt {}\", reconnectionAttempt);", "originalCommit": "b7af2b477c526150c91e5853fcb3ddd8b39fe760", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMTIwNA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516911204", "bodyText": "How about \"Attempting to reconnect device session: attempt {}\"?", "author": "timtay-microsoft", "createdAt": "2020-11-03T19:38:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwOTQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyNDM3OQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516924379", "bodyText": "sure", "author": "drwill-ms", "createdAt": "2020-11-03T20:03:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwOTQwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwOTg5MA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516909890", "bodyText": "I mentioned it elsewhere, but don't see the comment anymore. Bracing here seems to follow .NET style guidelines, not Java.", "author": "drwill-ms", "createdAt": "2020-11-03T19:36:30Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -820,21 +901,80 @@ private void handleDisconnection(TransportException transportException)\n         reconnect(transportException);\n     }\n \n+    // should only be called when multiplexing an only a particular device went offline\n+    private void reconnectDeviceSession(TransportException transportException, String deviceId)\n+    {\n+        long reconnectionStartTimeMillis = System.currentTimeMillis();\n+        int reconnectionAttempt = 0;\n+        boolean hasReconnectOperationTimedOut = this.hasOperationTimedOut(reconnectionStartTimeMillis, deviceId);\n+        RetryDecision retryDecision = null;\n+\n+        while (this.deviceConnectionStates.get(deviceId) == IotHubConnectionStatus.DISCONNECTED_RETRYING\n+                && !hasReconnectOperationTimedOut)\n+        {\n+            this.log.trace(\"Attempting device session reconnect attempt {}\", reconnectionAttempt);\n+            reconnectionAttempt++;\n+\n+            RetryPolicy retryPolicy = this.getConfig(deviceId).getRetryPolicy();\n+            retryDecision = retryPolicy.getRetryDecision(reconnectionAttempt, transportException);\n+            if (!retryDecision.shouldRetry())\n+            {\n+                break;\n+            }\n+\n+            // This call triggers some async amqp logic, so all this function can do is wait for a bit and check the connection\n+            // status for this device before retrying.\n+            singleDeviceReconnectAttemptAsync(deviceId);\n+\n+            this.log.trace(\"Sleeping between device reconnect attempts for device {}\", deviceId);\n+            IotHubTransport.sleepUninterruptibly(retryDecision.getDuration(), MILLISECONDS);\n+\n+            hasReconnectOperationTimedOut = this.hasOperationTimedOut(reconnectionStartTimeMillis);\n+        }\n+\n+        // reconnection may have failed, so check last retry decision, check for timeout, and check if last exception\n+        // was terminal\n+        try\n+        {\n+            if (retryDecision != null && !retryDecision.shouldRetry())\n+            {", "originalCommit": "b7af2b477c526150c91e5853fcb3ddd8b39fe760", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMTc3OQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516911779", "bodyText": "We have wildly different bracing style in track 1 repos than what we have in track 2. This is standard in our track 1 repo so far, albeit we could certainly change", "author": "timtay-microsoft", "createdAt": "2020-11-03T19:40:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwOTg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxOTU2OA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516919568", "bodyText": "Hey, I'm not going to complain. Let's embrace .NET style everywhere. :)", "author": "drwill-ms", "createdAt": "2020-11-03T19:54:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwOTg5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMDYwNA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516910604", "bodyText": "This might also be slow for 1000 devices. Thoughts on parallelizing?", "author": "drwill-ms", "createdAt": "2020-11-03T19:37:51Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -1142,23 +1297,48 @@ private void updateStatus(IotHubConnectionStatus newConnectionStatus, IotHubConn\n             //invoke connection status callbacks\n             this.log.debug(\"Invoking connection status callbacks with new status details\");\n             invokeConnectionStateCallback(newConnectionStatus, reason);\n-            invokeConnectionStatusChangeCallback(newConnectionStatus, reason, throwable);\n+\n+            if (deviceClientConfigs.size() < 2 || newConnectionStatus != IotHubConnectionStatus.CONNECTED)\n+            {\n+                // When multiplexing, a different method will notify each device-specific callback when that device is online,\n+                // but in cases when the tcp connection is lost and everything is disconnected retrying or disconnected, this is where the\n+                // callback should be fired\n+                invokeConnectionStatusChangeCallback(newConnectionStatus, reason, throwable);\n+\n+                for (DeviceClientConfig config : deviceClientConfigs)\n+                {\n+                    deviceConnectionStates.put(config.getDeviceId(), newConnectionStatus);", "originalCommit": "b7af2b477c526150c91e5853fcb3ddd8b39fe760", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY5MzU1Nw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r517693557", "bodyText": "There isn't a way to speed this up without introducing more threading. This is just putting a key value pair in a hashmap, which shouldn't be much of a bottleneck anyways", "author": "timtay-microsoft", "createdAt": "2020-11-04T23:34:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMDYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMTAxNA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516911014", "bodyText": "Do we not want to log each device's connection status?", "author": "drwill-ms", "createdAt": "2020-11-03T19:38:38Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -1142,23 +1297,48 @@ private void updateStatus(IotHubConnectionStatus newConnectionStatus, IotHubConn\n             //invoke connection status callbacks\n             this.log.debug(\"Invoking connection status callbacks with new status details\");\n             invokeConnectionStateCallback(newConnectionStatus, reason);\n-            invokeConnectionStatusChangeCallback(newConnectionStatus, reason, throwable);\n+\n+            if (deviceClientConfigs.size() < 2 || newConnectionStatus != IotHubConnectionStatus.CONNECTED)\n+            {\n+                // When multiplexing, a different method will notify each device-specific callback when that device is online,\n+                // but in cases when the tcp connection is lost and everything is disconnected retrying or disconnected, this is where the\n+                // callback should be fired\n+                invokeConnectionStatusChangeCallback(newConnectionStatus, reason, throwable);\n+\n+                for (DeviceClientConfig config : deviceClientConfigs)\n+                {\n+                    deviceConnectionStates.put(config.getDeviceId(), newConnectionStatus);\n+                }\n+            }\n+\n             this.deviceIOConnectionStatusChangeCallback.execute(newConnectionStatus, reason, throwable, null);\n+        }\n+    }\n \n-            if (newConnectionStatus == IotHubConnectionStatus.CONNECTED)\n+    private void updateStatus(IotHubConnectionStatus newConnectionStatus, IotHubConnectionStatusChangeReason reason, Throwable throwable, String deviceId)\n+    {\n+        if (this.deviceConnectionStates.containsKey(deviceId) && this.deviceConnectionStates.get(deviceId) != newConnectionStatus)\n+        {\n+            if (throwable == null)\n+            {\n+                this.log.debug(\"Updating device {} status to new status {} with reason {}\", deviceId, newConnectionStatus, reason);\n+            }\n+            else\n             {\n-                //Codes_SRS_IOTHUBTRANSPORT_28_007: [This function shall reset currentReconnectionAttempt and reconnectionAttemptStartTimeMillis if connection status is changed to CONNECTED.]\n-                this.currentReconnectionAttempt = 0;\n-                this.reconnectionAttemptStartTimeMillis = 0;\n+                this.log.warn(\"Updating device {} status to new status {} with reason {}\", deviceId, newConnectionStatus, reason, throwable);\n+            }\n+\n+            synchronized (this.multiplexingDeviceStateLock)\n+            {\n+                this.deviceConnectionStates.put(deviceId, newConnectionStatus);\n+\n+                this.log.debug(\"Invoking connection status callbacks with new status details\");", "originalCommit": "b7af2b477c526150c91e5853fcb3ddd8b39fe760", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMjYzOQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516912639", "bodyText": "We do log them above", "author": "timtay-microsoft", "createdAt": "2020-11-03T19:41:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMTAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMTcyMw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516911723", "bodyText": "Connection reconnection? Seems a bit redundant.", "author": "drwill-ms", "createdAt": "2020-11-03T19:39:55Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/ReconnectionNotifier.java", "diffHunk": "@@ -7,7 +7,8 @@\n \n public final class ReconnectionNotifier\n {\n-    private final static String THREAD_NAME=\"azure-iot-sdk-ReconnectionTask\";\n+    private final static String CONNECTION_RECONNECTION_THREAD_NAME=\"azure-iot-sdk-ConnectionReconnectionTask\";", "originalCommit": "b7af2b477c526150c91e5853fcb3ddd8b39fe760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMjY0Mw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516912643", "bodyText": "plural should be \"Latches\"", "author": "drwill-ms", "createdAt": "2020-11-03T19:41:38Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/amqps/AmqpsIotHubConnection.java", "diffHunk": "@@ -220,7 +269,7 @@ public void onReactorFinal(Event event)\n     {\n         log.trace(\"Amqps reactor finalized\");\n         releaseLatch(authenticationSessionOpenedLatch);\n-        releaseLatch(deviceSessionsOpenedLatch);\n+        releaseDeviceSessionLatchs();", "originalCommit": "b7af2b477c526150c91e5853fcb3ddd8b39fe760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNDQwMA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516914400", "bodyText": "What is CBS besides a TV network?\nIn .NET we'd case this as Cbs. All caps for Java?", "author": "drwill-ms", "createdAt": "2020-11-03T19:44:47Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/amqps/AmqpsIotHubConnection.java", "diffHunk": "@@ -505,17 +584,48 @@ public void onAuthenticationFailed(TransportException transportException)\n     {\n         this.savedException = transportException;\n         releaseLatch(authenticationSessionOpenedLatch);\n-        releaseLatch(deviceSessionsOpenedLatch);\n+        releaseDeviceSessionLatchs();\n+    }\n+\n+    @Override\n+    public void onSessionClosedUnexpectedly(ErrorCondition errorCondition, String deviceId)\n+    {\n+        TransportException savedException = AmqpsExceptionTranslator.convertFromAmqpException(errorCondition);\n+\n+        if (this.deviceClientConfigs.size() > 1)\n+        {\n+            // When multiplexing, don't kill the connection just because a session dropped.\n+            log.error(\"Amqp session closed unexpectedly. notifying the transport layer to start reconnection logic...\", this.savedException);\n+            scheduleDeviceSessionReconnection(savedException, deviceId);\n+        }\n+        else\n+        {\n+            // When not multiplexing, reconnection logic will just spin up the whole connection again.\n+            this.savedException = savedException;\n+            log.error(\"Amqp session closed unexpectedly. Closing this connection...\", this.savedException);\n+            this.connection.close();\n+        }\n     }\n \n     @Override\n-    public void onSessionClosedUnexpectedly(ErrorCondition errorCondition)\n+    public void onCBSSessionClosedUnexpectedly(ErrorCondition errorCondition)", "originalCommit": "b7af2b477c526150c91e5853fcb3ddd8b39fe760", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNjQ5NA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516916494", "bodyText": "\"CBS\" is an acronym for \"Claims Based Security\"", "author": "timtay-microsoft", "createdAt": "2020-11-03T19:48:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNDQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNjc0MQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516916741", "bodyText": "We don't typically lowercase the tail end of an acronym in Java, no", "author": "timtay-microsoft", "createdAt": "2020-11-03T19:49:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNDQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyMDg2NA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516920864", "bodyText": "Can we add some code comments for things like this? Spell out CBS and maybe provide a link to what it is somewhere.", "author": "drwill-ms", "createdAt": "2020-11-03T19:56:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNDQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk5NDQwMg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516994402", "bodyText": "There is no formal documentation on this CBS link that I could link to, but I can add some comments to clarify what CBS is", "author": "timtay-microsoft", "createdAt": "2020-11-03T22:32:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNDQwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNDk3Ng==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516914976", "bodyText": "Grammar, semi-colon instead of comma.", "author": "drwill-ms", "createdAt": "2020-11-03T19:45:52Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/amqps/AmqpsIotHubConnection.java", "diffHunk": "@@ -651,20 +779,110 @@ private void addDeviceSession(DeviceClientConfig deviceClientConfig, boolean aft\n         if (amqpsSessionHandler == null)\n         {\n             amqpsSessionHandler = new AmqpsSessionHandler(deviceClientConfig, this);\n-            this.sessionHandlerList.add(amqpsSessionHandler);\n+            this.sessionHandlers.add(amqpsSessionHandler);\n         }\n \n-        if (afterOpen)\n+        return amqpsSessionHandler;\n+    }\n+\n+    // This function is called periodically from the onTimerTask reactor callback so that any newly registered device sessions\n+    // can be opened on a reactor thread instead of from one of our threads.\n+    private void checkForNewlyRegisteredMultiplexedClientsToStart()\n+    {\n+        DeviceClientConfig configToRegister = this.multiplexingClientsToRegister.poll();\n+        while (configToRegister != null)\n         {\n+            AmqpsSessionHandler amqpsSessionHandler = createSessionHandler(configToRegister);\n+\n+            log.trace(\"Adding device session for device {} to an active connection\", configToRegister.getDeviceId());\n             amqpsSessionHandler.setSession(this.connection.session());\n+            AmqpsSasTokenRenewalHandler amqpsSasTokenRenewalHandler = new AmqpsSasTokenRenewalHandler(amqpsCbsSessionHandler, amqpsSessionHandler);\n+            sasTokenRenewalHandlers.add(amqpsSasTokenRenewalHandler);\n+            try\n+            {\n+                amqpsSasTokenRenewalHandler.sendAuthenticationMessage(this.reactor);\n+            }\n+            catch (TransportException e)\n+            {\n+                log.warn(\"Failed to send authentication message for device {}, will try again.\", amqpsSasTokenRenewalHandler.amqpsSessionHandler.getDeviceId());", "originalCommit": "b7af2b477c526150c91e5853fcb3ddd8b39fe760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNzM1NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516917355", "bodyText": "Any comment here to indicate the transport client is being deprecated?", "author": "drwill-ms", "createdAt": "2020-11-03T19:50:25Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/amqps/IoTHubConnectionType.java", "diffHunk": "@@ -7,5 +7,6 @@\n {\n     UNKNOWN,\n     SINGLE_CLIENT,\n-    USE_TRANSPORTCLIENT\n+    USE_TRANSPORTCLIENT,", "originalCommit": "b7af2b477c526150c91e5853fcb3ddd8b39fe760", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxODEwOQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516918109", "bodyText": "I can deprecate it and add a comment about why, sure", "author": "timtay-microsoft", "createdAt": "2020-11-03T19:51:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNzM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyMTQwMg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516921402", "bodyText": "We don't have a way to distinguish exceptions except by the message?", "author": "drwill-ms", "createdAt": "2020-11-03T19:57:27Z", "path": "iot-e2e-tests/common/src/test/java/tests/integration/com/microsoft/azure/sdk/iot/helpers/rules/ThrottleResistantTestRule.java", "diffHunk": "@@ -49,6 +50,19 @@ public void evaluate() throws Throwable {\n                     log.warn(\"Thottling detected in test {}, waiting for {} milliseconds and then re-running the test\", description.getMethodName(), THROTTLING_RETRY_DELAY_MILLISECONDS, e);\n                     Thread.sleep(THROTTLING_RETRY_DELAY_MILLISECONDS);\n                 }\n+                catch (Exception e)\n+                {\n+                    if (e.getMessage().toLowerCase().contains(CONNECTION_REFUSED))", "originalCommit": "5db894c5cc5bd857420858e32d544b3312eaf92d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyMjU0OQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516922549", "bodyText": "This is for the service client (AMQP) in particular, and we don't have any sort of proper exception hierarchy there, no. This is a pretty special case, I'll admit. I don't have a better way to accomplish this though", "author": "timtay-microsoft", "createdAt": "2020-11-03T19:59:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyMTQwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAxOTY2OQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r517019669", "bodyText": "Is this not already covered by the previous import?", "author": "drwill-ms", "createdAt": "2020-11-03T23:43:28Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexingSample.java", "diffHunk": "@@ -0,0 +1,169 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;", "originalCommit": "cbb5b54eb5573f67b173b33575f240c7d0387fa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUyMjkwMg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r517522902", "bodyText": "You'd think so, but no. The star does not recurse", "author": "timtay-microsoft", "createdAt": "2020-11-04T17:46:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAxOTY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAxOTc5NA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r517019794", "bodyText": "So anyone can change this, not just this class?", "author": "drwill-ms", "createdAt": "2020-11-03T23:44:00Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexingSample.java", "diffHunk": "@@ -0,0 +1,169 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+/**\n+ * Sample that demonstrates creating a multiplexed connection to IoT Hub using AMQPS / AMQPS_WS. It also demonstrates\n+ * removing and adding device clients from the multiplexed connection while it is open.\n+ */\n+public class MultiplexingSample\n+{\n+    // Every multiplexed device will maintain its own connection status callback. Because of that, you can monitor\n+    // if a particular device session goes offline unexpectedly. This connection status callback is also how you\n+    // confirm when a device client is connected after registering it to an active multiplexed connection since the .registerDeviceClient(...)\n+    // call behaves asynchronously when the multiplexing client is already open. Similarly, this callback is used to track\n+    // when a device client is closed when unregistering it from an active connection.\n+    public static class MultiplexedDeviceConnectionStatusChangeTracker implements IotHubConnectionStatusChangeCallback\n+    {\n+        public boolean isOpen = false;", "originalCommit": "cbb5b54eb5573f67b173b33575f240c7d0387fa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUyMzYwNA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r517523604", "bodyText": "I can make these fields private and make getters so they are readonly, sure", "author": "timtay-microsoft", "createdAt": "2020-11-04T17:48:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAxOTc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAyMDExMA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r517020110", "bodyText": "Can we give this a more specific name? TelemetryAckCallback?", "author": "drwill-ms", "createdAt": "2020-11-03T23:44:58Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexingSample.java", "diffHunk": "@@ -0,0 +1,169 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+/**\n+ * Sample that demonstrates creating a multiplexed connection to IoT Hub using AMQPS / AMQPS_WS. It also demonstrates\n+ * removing and adding device clients from the multiplexed connection while it is open.\n+ */\n+public class MultiplexingSample\n+{\n+    // Every multiplexed device will maintain its own connection status callback. Because of that, you can monitor\n+    // if a particular device session goes offline unexpectedly. This connection status callback is also how you\n+    // confirm when a device client is connected after registering it to an active multiplexed connection since the .registerDeviceClient(...)\n+    // call behaves asynchronously when the multiplexing client is already open. Similarly, this callback is used to track\n+    // when a device client is closed when unregistering it from an active connection.\n+    public static class MultiplexedDeviceConnectionStatusChangeTracker implements IotHubConnectionStatusChangeCallback\n+    {\n+        public boolean isOpen = false;\n+        public boolean isDisconnectedRetrying = false;\n+\n+        @Override\n+        public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext)\n+        {\n+            String deviceId = (String) callbackContext;\n+\n+            if (throwable == null)\n+            {\n+                System.out.println(\"CONNECTION STATUS UPDATE FOR DEVICE \" + deviceId + \" - \" + status + \", \" + statusChangeReason);\n+            }\n+            else\n+            {\n+                System.out.println(\"CONNECTION STATUS UPDATE FOR DEVICE \" + deviceId + \" - \" + status + \", \" + statusChangeReason + \", \" + throwable.getMessage());\n+            }\n+\n+            if (status == IotHubConnectionStatus.CONNECTED)\n+            {\n+                isOpen = true;\n+                isDisconnectedRetrying = false;\n+            }\n+            else if (status == IotHubConnectionStatus.DISCONNECTED)\n+            {\n+                isOpen = false;\n+                isDisconnectedRetrying = false;\n+            }\n+            else if (status == IotHubConnectionStatus.DISCONNECTED_RETRYING)\n+            {\n+                isDisconnectedRetrying = true;\n+                isOpen = false;\n+            }\n+        }\n+    }\n+\n+    public static int acknowledgedSentMessages = 0;\n+    protected static class EventCallback implements IotHubEventCallback", "originalCommit": "cbb5b54eb5573f67b173b33575f240c7d0387fa9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAyMDc5Nw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r517020797", "bodyText": "As discussed, I think this would work better as a HashMap of <string deviceId, DeviceClient deviceClient> and illustrate sending telemetry as devices (and other operations) by looking up a device client by the device Id.\nTo iterate, you'd have a list of your registered devices, use that to look up your HashMap, and perform the action on the DeviceClient.", "author": "drwill-ms", "createdAt": "2020-11-03T23:47:10Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexingSample.java", "diffHunk": "@@ -0,0 +1,169 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+/**\n+ * Sample that demonstrates creating a multiplexed connection to IoT Hub using AMQPS / AMQPS_WS. It also demonstrates\n+ * removing and adding device clients from the multiplexed connection while it is open.\n+ */\n+public class MultiplexingSample\n+{\n+    // Every multiplexed device will maintain its own connection status callback. Because of that, you can monitor\n+    // if a particular device session goes offline unexpectedly. This connection status callback is also how you\n+    // confirm when a device client is connected after registering it to an active multiplexed connection since the .registerDeviceClient(...)\n+    // call behaves asynchronously when the multiplexing client is already open. Similarly, this callback is used to track\n+    // when a device client is closed when unregistering it from an active connection.\n+    public static class MultiplexedDeviceConnectionStatusChangeTracker implements IotHubConnectionStatusChangeCallback\n+    {\n+        public boolean isOpen = false;\n+        public boolean isDisconnectedRetrying = false;\n+\n+        @Override\n+        public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext)\n+        {\n+            String deviceId = (String) callbackContext;\n+\n+            if (throwable == null)\n+            {\n+                System.out.println(\"CONNECTION STATUS UPDATE FOR DEVICE \" + deviceId + \" - \" + status + \", \" + statusChangeReason);\n+            }\n+            else\n+            {\n+                System.out.println(\"CONNECTION STATUS UPDATE FOR DEVICE \" + deviceId + \" - \" + status + \", \" + statusChangeReason + \", \" + throwable.getMessage());\n+            }\n+\n+            if (status == IotHubConnectionStatus.CONNECTED)\n+            {\n+                isOpen = true;\n+                isDisconnectedRetrying = false;\n+            }\n+            else if (status == IotHubConnectionStatus.DISCONNECTED)\n+            {\n+                isOpen = false;\n+                isDisconnectedRetrying = false;\n+            }\n+            else if (status == IotHubConnectionStatus.DISCONNECTED_RETRYING)\n+            {\n+                isDisconnectedRetrying = true;\n+                isOpen = false;\n+            }\n+        }\n+    }\n+\n+    public static int acknowledgedSentMessages = 0;\n+    protected static class EventCallback implements IotHubEventCallback\n+    {\n+        public void execute(IotHubStatusCode status, Object context)\n+        {\n+            String messageId = (String) context;\n+            System.out.println(\"IoT Hub responded to message \"+ messageId  + \" with status \" + status.name());\n+            acknowledgedSentMessages++;\n+        }\n+    }\n+\n+    private static final int MULTIPLEXED_DEVICE_CLIENT_COUNT = 3;\n+\n+    /**\n+     * Multiplex devices an IoT Hub using AMQPS / AMQPS_WS\n+     *\n+     * @param args\n+     * args[0] = IoT Hub connection string - Device Client 1\n+     * args[1] = IoT Hub connection string - Device Client 2\n+     * args[2] = IoT Hub connection string - Device Client 3\n+     */\n+    public static void main(String[] args)\n+            throws IOException, URISyntaxException, InterruptedException {\n+        System.out.println(\"Starting...\");\n+        System.out.println(\"Beginning setup.\");\n+\n+        if (args.length != 4)\n+        {\n+            System.out.format(\n+                    \"Expected 3 arguments but received: %d.\\n\"\n+                            + \"The program should be called with the following args: \\n\"\n+                            + \"1. [Device 1 connection string] - String containing Hostname, Device Id & Device Key in one of the following formats: HostName=<iothub_host_name>;DeviceId=<device_id>;SharedAccessKey=<device_key>\\n\"\n+                            + \"2. [Device 2 connection string] - String containing Hostname, Device Id & Device Key in one of the following formats: HostName=<iothub_host_name>;DeviceId=<device_id>;SharedAccessKey=<device_key>\\n\"\n+                            + \"3. [Device 3 connection string] - String containing Hostname, Device Id & Device Key in one of the following formats: HostName=<iothub_host_name>;DeviceId=<device_id>;SharedAccessKey=<device_key>\\n\"\n+                            + \"4. [Protocol]                   - amqps | amqps_ws\\n\",\n+                    args.length);\n+            return;\n+        }\n+\n+        String connString1 = args[0];\n+        String connString2 = args[1];\n+        String connString3 = args[2];\n+        IotHubClientProtocol protocol = IotHubClientProtocol.AMQPS;\n+        if (args[3].equalsIgnoreCase(\"amqps_ws\"))\n+        {\n+            protocol = IotHubClientProtocol.AMQPS_WS;\n+        }\n+\n+        MultiplexingClient multiplexingClient = new MultiplexingClient(protocol);\n+        DeviceClient[] multiplexedDeviceClients = new DeviceClient[MULTIPLEXED_DEVICE_CLIENT_COUNT];", "originalCommit": "cbb5b54eb5573f67b173b33575f240c7d0387fa9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAyMTAwNg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r517021006", "bodyText": "Probably should print the number of messages acked, and how many more you are waiting for.", "author": "drwill-ms", "createdAt": "2020-11-03T23:47:53Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexingSample.java", "diffHunk": "@@ -0,0 +1,169 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+/**\n+ * Sample that demonstrates creating a multiplexed connection to IoT Hub using AMQPS / AMQPS_WS. It also demonstrates\n+ * removing and adding device clients from the multiplexed connection while it is open.\n+ */\n+public class MultiplexingSample\n+{\n+    // Every multiplexed device will maintain its own connection status callback. Because of that, you can monitor\n+    // if a particular device session goes offline unexpectedly. This connection status callback is also how you\n+    // confirm when a device client is connected after registering it to an active multiplexed connection since the .registerDeviceClient(...)\n+    // call behaves asynchronously when the multiplexing client is already open. Similarly, this callback is used to track\n+    // when a device client is closed when unregistering it from an active connection.\n+    public static class MultiplexedDeviceConnectionStatusChangeTracker implements IotHubConnectionStatusChangeCallback\n+    {\n+        public boolean isOpen = false;\n+        public boolean isDisconnectedRetrying = false;\n+\n+        @Override\n+        public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext)\n+        {\n+            String deviceId = (String) callbackContext;\n+\n+            if (throwable == null)\n+            {\n+                System.out.println(\"CONNECTION STATUS UPDATE FOR DEVICE \" + deviceId + \" - \" + status + \", \" + statusChangeReason);\n+            }\n+            else\n+            {\n+                System.out.println(\"CONNECTION STATUS UPDATE FOR DEVICE \" + deviceId + \" - \" + status + \", \" + statusChangeReason + \", \" + throwable.getMessage());\n+            }\n+\n+            if (status == IotHubConnectionStatus.CONNECTED)\n+            {\n+                isOpen = true;\n+                isDisconnectedRetrying = false;\n+            }\n+            else if (status == IotHubConnectionStatus.DISCONNECTED)\n+            {\n+                isOpen = false;\n+                isDisconnectedRetrying = false;\n+            }\n+            else if (status == IotHubConnectionStatus.DISCONNECTED_RETRYING)\n+            {\n+                isDisconnectedRetrying = true;\n+                isOpen = false;\n+            }\n+        }\n+    }\n+\n+    public static int acknowledgedSentMessages = 0;\n+    protected static class EventCallback implements IotHubEventCallback\n+    {\n+        public void execute(IotHubStatusCode status, Object context)\n+        {\n+            String messageId = (String) context;\n+            System.out.println(\"IoT Hub responded to message \"+ messageId  + \" with status \" + status.name());\n+            acknowledgedSentMessages++;\n+        }\n+    }\n+\n+    private static final int MULTIPLEXED_DEVICE_CLIENT_COUNT = 3;\n+\n+    /**\n+     * Multiplex devices an IoT Hub using AMQPS / AMQPS_WS\n+     *\n+     * @param args\n+     * args[0] = IoT Hub connection string - Device Client 1\n+     * args[1] = IoT Hub connection string - Device Client 2\n+     * args[2] = IoT Hub connection string - Device Client 3\n+     */\n+    public static void main(String[] args)\n+            throws IOException, URISyntaxException, InterruptedException {\n+        System.out.println(\"Starting...\");\n+        System.out.println(\"Beginning setup.\");\n+\n+        if (args.length != 4)\n+        {\n+            System.out.format(\n+                    \"Expected 3 arguments but received: %d.\\n\"\n+                            + \"The program should be called with the following args: \\n\"\n+                            + \"1. [Device 1 connection string] - String containing Hostname, Device Id & Device Key in one of the following formats: HostName=<iothub_host_name>;DeviceId=<device_id>;SharedAccessKey=<device_key>\\n\"\n+                            + \"2. [Device 2 connection string] - String containing Hostname, Device Id & Device Key in one of the following formats: HostName=<iothub_host_name>;DeviceId=<device_id>;SharedAccessKey=<device_key>\\n\"\n+                            + \"3. [Device 3 connection string] - String containing Hostname, Device Id & Device Key in one of the following formats: HostName=<iothub_host_name>;DeviceId=<device_id>;SharedAccessKey=<device_key>\\n\"\n+                            + \"4. [Protocol]                   - amqps | amqps_ws\\n\",\n+                    args.length);\n+            return;\n+        }\n+\n+        String connString1 = args[0];\n+        String connString2 = args[1];\n+        String connString3 = args[2];\n+        IotHubClientProtocol protocol = IotHubClientProtocol.AMQPS;\n+        if (args[3].equalsIgnoreCase(\"amqps_ws\"))\n+        {\n+            protocol = IotHubClientProtocol.AMQPS_WS;\n+        }\n+\n+        MultiplexingClient multiplexingClient = new MultiplexingClient(protocol);\n+        DeviceClient[] multiplexedDeviceClients = new DeviceClient[MULTIPLEXED_DEVICE_CLIENT_COUNT];\n+        MultiplexedDeviceConnectionStatusChangeTracker[] connectionStatusTrackers = new MultiplexedDeviceConnectionStatusChangeTracker[MULTIPLEXED_DEVICE_CLIENT_COUNT];\n+\n+        for (int i = 0; i < MULTIPLEXED_DEVICE_CLIENT_COUNT; i++)\n+        {\n+            multiplexedDeviceClients[i] = new DeviceClient(args[i], protocol);\n+            String deviceId = multiplexedDeviceClients[i].getConfig().getDeviceId();\n+            connectionStatusTrackers[i] = new MultiplexedDeviceConnectionStatusChangeTracker();\n+            multiplexedDeviceClients[i].registerConnectionStatusChangeCallback(connectionStatusTrackers[i], deviceId);\n+            multiplexingClient.registerDeviceClient(multiplexedDeviceClients[i]);\n+        }\n+\n+        System.out.println(\"Opening multiplexed connection\");\n+        // All previously registered device clients will be opened alongside this multiplexing client\n+        multiplexingClient.open();\n+        System.out.println(\"Multiplexed connection opened successfully\");\n+\n+        for (int i = 0; i < MULTIPLEXED_DEVICE_CLIENT_COUNT; i++)\n+        {\n+            Message message = new Message(\"some payload\");\n+            multiplexedDeviceClients[i].sendEventAsync(message, new EventCallback(), message.getMessageId());\n+        }\n+\n+        System.out.println(\"Waiting while messages get sent asynchronously...\");\n+        while (acknowledgedSentMessages < MULTIPLEXED_DEVICE_CLIENT_COUNT)\n+        {\n+            Thread.sleep(200);", "originalCommit": "cbb5b54eb5573f67b173b33575f240c7d0387fa9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAyMTE5Mg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r517021192", "bodyText": "Consider adding big comment blocks to announce what the next code block demonstrates.", "author": "drwill-ms", "createdAt": "2020-11-03T23:48:29Z", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexingSample.java", "diffHunk": "@@ -0,0 +1,169 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+/**\n+ * Sample that demonstrates creating a multiplexed connection to IoT Hub using AMQPS / AMQPS_WS. It also demonstrates\n+ * removing and adding device clients from the multiplexed connection while it is open.\n+ */\n+public class MultiplexingSample\n+{\n+    // Every multiplexed device will maintain its own connection status callback. Because of that, you can monitor\n+    // if a particular device session goes offline unexpectedly. This connection status callback is also how you\n+    // confirm when a device client is connected after registering it to an active multiplexed connection since the .registerDeviceClient(...)\n+    // call behaves asynchronously when the multiplexing client is already open. Similarly, this callback is used to track\n+    // when a device client is closed when unregistering it from an active connection.\n+    public static class MultiplexedDeviceConnectionStatusChangeTracker implements IotHubConnectionStatusChangeCallback\n+    {\n+        public boolean isOpen = false;\n+        public boolean isDisconnectedRetrying = false;\n+\n+        @Override\n+        public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext)\n+        {\n+            String deviceId = (String) callbackContext;\n+\n+            if (throwable == null)\n+            {\n+                System.out.println(\"CONNECTION STATUS UPDATE FOR DEVICE \" + deviceId + \" - \" + status + \", \" + statusChangeReason);\n+            }\n+            else\n+            {\n+                System.out.println(\"CONNECTION STATUS UPDATE FOR DEVICE \" + deviceId + \" - \" + status + \", \" + statusChangeReason + \", \" + throwable.getMessage());\n+            }\n+\n+            if (status == IotHubConnectionStatus.CONNECTED)\n+            {\n+                isOpen = true;\n+                isDisconnectedRetrying = false;\n+            }\n+            else if (status == IotHubConnectionStatus.DISCONNECTED)\n+            {\n+                isOpen = false;\n+                isDisconnectedRetrying = false;\n+            }\n+            else if (status == IotHubConnectionStatus.DISCONNECTED_RETRYING)\n+            {\n+                isDisconnectedRetrying = true;\n+                isOpen = false;\n+            }\n+        }\n+    }\n+\n+    public static int acknowledgedSentMessages = 0;\n+    protected static class EventCallback implements IotHubEventCallback\n+    {\n+        public void execute(IotHubStatusCode status, Object context)\n+        {\n+            String messageId = (String) context;\n+            System.out.println(\"IoT Hub responded to message \"+ messageId  + \" with status \" + status.name());\n+            acknowledgedSentMessages++;\n+        }\n+    }\n+\n+    private static final int MULTIPLEXED_DEVICE_CLIENT_COUNT = 3;\n+\n+    /**\n+     * Multiplex devices an IoT Hub using AMQPS / AMQPS_WS\n+     *\n+     * @param args\n+     * args[0] = IoT Hub connection string - Device Client 1\n+     * args[1] = IoT Hub connection string - Device Client 2\n+     * args[2] = IoT Hub connection string - Device Client 3\n+     */\n+    public static void main(String[] args)\n+            throws IOException, URISyntaxException, InterruptedException {\n+        System.out.println(\"Starting...\");\n+        System.out.println(\"Beginning setup.\");\n+\n+        if (args.length != 4)\n+        {\n+            System.out.format(\n+                    \"Expected 3 arguments but received: %d.\\n\"\n+                            + \"The program should be called with the following args: \\n\"\n+                            + \"1. [Device 1 connection string] - String containing Hostname, Device Id & Device Key in one of the following formats: HostName=<iothub_host_name>;DeviceId=<device_id>;SharedAccessKey=<device_key>\\n\"\n+                            + \"2. [Device 2 connection string] - String containing Hostname, Device Id & Device Key in one of the following formats: HostName=<iothub_host_name>;DeviceId=<device_id>;SharedAccessKey=<device_key>\\n\"\n+                            + \"3. [Device 3 connection string] - String containing Hostname, Device Id & Device Key in one of the following formats: HostName=<iothub_host_name>;DeviceId=<device_id>;SharedAccessKey=<device_key>\\n\"\n+                            + \"4. [Protocol]                   - amqps | amqps_ws\\n\",\n+                    args.length);\n+            return;\n+        }\n+\n+        String connString1 = args[0];\n+        String connString2 = args[1];\n+        String connString3 = args[2];\n+        IotHubClientProtocol protocol = IotHubClientProtocol.AMQPS;\n+        if (args[3].equalsIgnoreCase(\"amqps_ws\"))\n+        {\n+            protocol = IotHubClientProtocol.AMQPS_WS;\n+        }\n+\n+        MultiplexingClient multiplexingClient = new MultiplexingClient(protocol);\n+        DeviceClient[] multiplexedDeviceClients = new DeviceClient[MULTIPLEXED_DEVICE_CLIENT_COUNT];\n+        MultiplexedDeviceConnectionStatusChangeTracker[] connectionStatusTrackers = new MultiplexedDeviceConnectionStatusChangeTracker[MULTIPLEXED_DEVICE_CLIENT_COUNT];\n+\n+        for (int i = 0; i < MULTIPLEXED_DEVICE_CLIENT_COUNT; i++)\n+        {\n+            multiplexedDeviceClients[i] = new DeviceClient(args[i], protocol);\n+            String deviceId = multiplexedDeviceClients[i].getConfig().getDeviceId();\n+            connectionStatusTrackers[i] = new MultiplexedDeviceConnectionStatusChangeTracker();\n+            multiplexedDeviceClients[i].registerConnectionStatusChangeCallback(connectionStatusTrackers[i], deviceId);\n+            multiplexingClient.registerDeviceClient(multiplexedDeviceClients[i]);\n+        }\n+\n+        System.out.println(\"Opening multiplexed connection\");\n+        // All previously registered device clients will be opened alongside this multiplexing client\n+        multiplexingClient.open();\n+        System.out.println(\"Multiplexed connection opened successfully\");\n+\n+        for (int i = 0; i < MULTIPLEXED_DEVICE_CLIENT_COUNT; i++)\n+        {\n+            Message message = new Message(\"some payload\");\n+            multiplexedDeviceClients[i].sendEventAsync(message, new EventCallback(), message.getMessageId());\n+        }\n+\n+        System.out.println(\"Waiting while messages get sent asynchronously...\");\n+        while (acknowledgedSentMessages < MULTIPLEXED_DEVICE_CLIENT_COUNT)\n+        {\n+            Thread.sleep(200);\n+        }\n+\n+        int deviceIndexToUnregister = 0;", "originalCommit": "cbb5b54eb5573f67b173b33575f240c7d0387fa9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAyMTc2Mg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r517021762", "bodyText": "what if the deviceIO already exists on this device? (it has already been opened independently from the multiplex connection)\nwhat I mean is that the pre-existing device IO needs to be disposed. we also need tests for that :D", "author": "azabbasi", "createdAt": "2020-11-03T23:50:20Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+    private final Object lock = new Object();\n+\n+    private static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS = 1000;\n+    private static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS = 500;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (this.lock)\n+        {\n+            if (deviceClientList.size() < 1)\n+            {\n+                throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+            }\n+\n+            log.info(\"Opening multiplexing client\");\n+            this.deviceIO.open();\n+            log.info(\"Successfully opened multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        synchronized (this.lock)\n+        {\n+            log.info(\"Closing multiplexing client\");\n+            for (DeviceClient deviceClient : this.deviceClientList)\n+            {\n+                deviceClient.closeFileUpload();\n+            }\n+\n+            if (this.deviceIO != null)\n+            {\n+                this.deviceIO.multiplexClose();\n+            }\n+\n+            // Note that this method does not close each of the registered device client instances. This is intentional\n+            // as the calls to deviceClient.close() do nothing besides close the deviceIO layer, which is already closed\n+            // by the above code.\n+\n+            log.info(\"Successfully closed multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client instance must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * The registered device client may have its own retry policy and its own SAS token expiry time, separate from every other multiplexed device.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If this device client is already registered, then this method will throw a {@link IllegalStateException}\n+     * <p>\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        synchronized (this.lock)\n+        {\n+            for (DeviceClient currentClient : deviceClientList)\n+            {\n+                String currentDeviceId = currentClient.getConfig().getDeviceId();\n+                if (currentDeviceId.equalsIgnoreCase(deviceClient.getConfig().getDeviceId()))\n+                {\n+                    log.warn(\"Device {} won't be registered to the multiplexed connection because it is already registered.\", currentDeviceId);\n+                    return;\n+                }\n+            }\n+\n+            if (deviceClient.getConfig().getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+            {\n+                throw new UnsupportedOperationException(\"Can only register a device client if it uses SAS token based authentication\");\n+            }\n+\n+            if (deviceClient.getConfig().getProtocol() != this.protocol)\n+            {\n+                throw new UnsupportedOperationException(\"A device client cannot be registered to a multiplexing client that specifies a different transport protocol.\");\n+            }\n+\n+            if (this.protocol == IotHubClientProtocol.AMQPS && this.deviceClientList.size() > MAX_MULTIPLEX_DEVICE_COUNT_AMQPS)\n+            {\n+                throw new UnsupportedOperationException(String.format(\"Multiplexed connections over AMQPS only support up to %d devices\", MAX_MULTIPLEX_DEVICE_COUNT_AMQPS));\n+            }\n+\n+            // Typically client side validation is duplicate work, but IoT Hub doesn't give a good error message when closing the\n+            // AMQPS_WS connection so this is the only way that users will know about this limit\n+            if (this.protocol == IotHubClientProtocol.AMQPS_WS && this.deviceClientList.size() > MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS)\n+            {\n+                throw new UnsupportedOperationException(String.format(\"Multiplexed connections over AMQPS_WS only support up to %d devices\", MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS));\n+            }\n+\n+            if (this.deviceClientList.size() > 1 && !this.deviceClientList.get(0).getConfig().getIotHubHostname().equalsIgnoreCase(deviceClient.getConfig().getIotHubHostname()))\n+            {\n+                throw new UnsupportedOperationException(\"Multiplexed device clients must connect to the same host name\");\n+            }\n+\n+            // The first device to be registered will cause this client to build the IO layer with its configuration\n+            if (this.deviceIO == null)\n+            {\n+                log.debug(\"Creating DeviceIO layer for multiplexing client since this is the first registered device\");\n+                this.deviceIO = new DeviceIO(deviceClient.getConfig(), SEND_PERIOD_MILLIS, RECEIVE_PERIOD_MILLIS);\n+            }\n+\n+            deviceClient.setDeviceIO(this.deviceIO);", "originalCommit": "5e463891692c12152a7a402badc1070b64c27f95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY5MzkwNg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r517693906", "bodyText": "I think I'll throw in that scenario. To me, the scenario where a user tries to register a device client instance that is already open sounds more accidental than deliberate", "author": "timtay-microsoft", "createdAt": "2020-11-04T23:35:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAyMTc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAyNjI0MA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r517026240", "bodyText": "how do we prevent users from setting a different proxy setting after they are registered to the multiplexing client? there is a public API on the internal client that allows setting a proxySetting", "author": "azabbasi", "createdAt": "2020-11-04T00:05:28Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS = 1000;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS_WS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS = 500;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (this.lock)\n+        {\n+            if (deviceClientList.size() < 1)\n+            {\n+                throw new IllegalStateException(\"Must register at least one device client before opening a multiplexed connection\");\n+            }\n+\n+            log.info(\"Opening multiplexing client\");\n+            this.deviceIO.open();\n+            log.info(\"Successfully opened multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        synchronized (this.lock)\n+        {\n+            log.info(\"Closing multiplexing client\");\n+            for (DeviceClient deviceClient : this.deviceClientList)\n+            {\n+                deviceClient.closeFileUpload();\n+            }\n+\n+            if (this.deviceIO != null)\n+            {\n+                this.deviceIO.multiplexClose();\n+            }\n+\n+            // Note that this method does not close each of the registered device client instances. This is intentional\n+            // as the calls to deviceClient.close() do nothing besides close the deviceIO layer, which is already closed\n+            // by the above code.\n+\n+            log.info(\"Successfully closed multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client instance must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * The registered device client may have its own retry policy and its own SAS token expiry time, separate from every other multiplexed device.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If this device client is already registered, then this method will throw a {@link IllegalStateException}\n+     * <p>\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        synchronized (this.lock)\n+        {\n+            for (DeviceClient currentClient : deviceClientList)\n+            {\n+                String currentDeviceId = currentClient.getConfig().getDeviceId();\n+                if (currentDeviceId.equalsIgnoreCase(deviceClient.getConfig().getDeviceId()))\n+                {\n+                    log.warn(\"Device {} won't be registered to the multiplexed connection because it is already registered.\", currentDeviceId);\n+                    return;\n+                }\n+            }\n+\n+            if (deviceClient.getConfig().getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+            {\n+                throw new UnsupportedOperationException(\"Can only register to multiplex a device client that uses SAS token based authentication\");\n+            }\n+\n+            if (deviceClient.getConfig().getProtocol() != this.protocol)\n+            {\n+                throw new UnsupportedOperationException(\"A device client cannot be registered to a multiplexing client that specifies a different transport protocol.\");\n+            }\n+\n+            if (this.protocol == IotHubClientProtocol.AMQPS && this.deviceClientList.size() > MAX_MULTIPLEX_DEVICE_COUNT_AMQPS)\n+            {\n+                throw new UnsupportedOperationException(String.format(\"Multiplexed connections over AMQPS only support up to %d devices\", MAX_MULTIPLEX_DEVICE_COUNT_AMQPS));\n+            }\n+\n+            // Typically client side validation is duplicate work, but IoT Hub doesn't give a good error message when closing the\n+            // AMQPS_WS connection so this is the only way that users will know about this limit\n+            if (this.protocol == IotHubClientProtocol.AMQPS_WS && this.deviceClientList.size() > MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS)\n+            {\n+                throw new UnsupportedOperationException(String.format(\"Multiplexed connections over AMQPS_WS only support up to %d devices\", MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS));\n+            }\n+\n+            if (this.deviceClientList.size() > 1 && !this.deviceClientList.get(0).getConfig().getIotHubHostname().equalsIgnoreCase(deviceClient.getConfig().getIotHubHostname()))\n+            {\n+                throw new UnsupportedOperationException(\"A device client cannot be registered to a multiplexing client that specifies a different host name.\");\n+            }\n+\n+            // The first device to be registered will cause this client to build the IO layer with its configuration\n+            if (this.deviceIO == null)\n+            {\n+                log.debug(\"Creating DeviceIO layer for multiplexing client since this is the first registered device\");\n+                this.deviceIO = new DeviceIO(deviceClient.getConfig(), SEND_PERIOD_MILLIS, RECEIVE_PERIOD_MILLIS);\n+            }\n+\n+            deviceClient.setDeviceIO(this.deviceIO);\n+            deviceClient.getConfig().setProxy(this.proxySettings);", "originalCommit": "cbb5b54eb5573f67b173b33575f240c7d0387fa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUyOTY4NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r517529685", "bodyText": "I've added a flag in the internal client for if the client is multiplexing or not. When the flag is set, calls to setProxy will fail", "author": "timtay-microsoft", "createdAt": "2020-11-04T17:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAyNjI0MA=="}], "type": "inlineReview"}, {"oid": "0a90624dbd6bf9f1abbf79bef0783ac6fb4f46e0", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/0a90624dbd6bf9f1abbf79bef0783ac6fb4f46e0", "message": "temporarily add blocking flag to register call", "committedDate": "2020-11-04T22:43:43Z", "type": "forcePushed"}, {"oid": "cde9f0d864965504ae327bf4a8cae258a24c8c61", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/cde9f0d864965504ae327bf4a8cae258a24c8c61", "message": "feat(iot-dev): Add multiplexing client that supports device registration/unregistration during open connection\n\nTransportClient was our multiplexing client, but there was no way to add the ability to add/remove devices from an active connection without breaking the APIs in that class, so this deprecates the transport client in favor of a new MultiplexingClient.\n\nSignificant changes had to made to the IotHubTransport layer so that each multiplexed client could have its own connection state and so that each multiplexed client could have its own focused retry logic. Instead of closing the entire multiplexed connection every time a session drops, the transport layer can re-open individual device sessions", "committedDate": "2020-11-05T01:15:47Z", "type": "forcePushed"}, {"oid": "15ca17d7923d36f54663fbd8722769c315c45156", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/15ca17d7923d36f54663fbd8722769c315c45156", "message": "feat(iot-dev): Add multiplexing client that supports device registration/unregistration during open connection\n\nTransportClient was our multiplexing client, but there was no way to add the ability to add/remove devices from an active connection without breaking the APIs in that class, so this deprecates the transport client in favor of a new MultiplexingClient.\n\nSignificant changes had to made to the IotHubTransport layer so that each multiplexed client could have its own connection state and so that each multiplexed client could have its own focused retry logic. Instead of closing the entire multiplexed connection every time a session drops, the transport layer can re-open individual device sessions", "committedDate": "2020-11-07T00:34:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkwOTE5NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520909195", "bodyText": "nit: this message could be in a const string, similar to MULTIPLEXING_CLOSE_ERROR_MESSAGE.", "author": "abhipsaMisra", "createdAt": "2020-11-10T22:16:46Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceClient.java", "diffHunk": "@@ -376,6 +378,11 @@ private void commonConstructorVerifications() throws UnsupportedOperationExcepti\n      */\n     public void open() throws IOException\n     {\n+        if (this.ioTHubConnectionType == IoTHubConnectionType.USE_MULTIPLEXING_CLIENT)\n+        {\n+            throw new UnsupportedOperationException(\"Cannot open a multiplexed client through this method. Must use multiplexingClient.registerDeviceClients(deviceClient)\");", "originalCommit": "15ca17d7923d36f54663fbd8722769c315c45156", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxMDUyMw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520910523", "bodyText": "I am not really clear what this means; is this set only by a multiplexing client, to indicate to this device client's DeviceIO layer (or someone else) that it is a multiplexed client?", "author": "abhipsaMisra", "createdAt": "2020-11-10T22:19:34Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceClient.java", "diffHunk": "@@ -668,6 +685,12 @@ public void subscribeToDeviceMethod(DeviceMethodCallback deviceMethodCallback, O\n         this.subscribeToMethodsInternal(deviceMethodCallback, deviceMethodCallbackContext, deviceMethodStatusCallback, deviceMethodStatusCallbackContext);\n     }\n \n+    // Used by multiplexing clients to signal to this client what kind of multiplexing client is using this device client", "originalCommit": "15ca17d7923d36f54663fbd8722769c315c45156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU1NjYzNQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521556635", "bodyText": "It is called only by the multiplexing client that \"owns\" this client, yes. The value set here is used in some if cases when a user tries to set options that are only available to non-multiplexed devices for example", "author": "timtay-microsoft", "createdAt": "2020-11-11T18:28:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxMDUyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU1NjkyMg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521556922", "bodyText": "It is also used to differentiate between what the old TransportClient allows vs what the new MultiplexingClient allows, hence why this enum has separate values for those two cases.", "author": "timtay-microsoft", "createdAt": "2020-11-11T18:29:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxMDUyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxMjI2MA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520912260", "bodyText": "q - for a non-multiplexed device, what is the difference between an auth session timeout and a device session timeout?", "author": "abhipsaMisra", "createdAt": "2020-11-10T22:23:23Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceClientConfig.java", "diffHunk": "@@ -31,7 +31,10 @@\n     private static final int DEFAULT_HTTPS_READ_TIMEOUT_MILLIS = 240000;\n     private static final int DEFAULT_HTTPS_CONNECT_TIMEOUT_MILLIS = 0; //no connect timeout\n \n-    private static final int DEFAULT_AMQP_OPEN_AUTHENTICATION_SESSION_TIMEOUT_IN_SECONDS = 20;\n+    // authentication session timeout is public because a multiplexed connection needs this default if no devices\n+    // were registered prior to opening the connection. No device sessions would be opened in that case though, so\n+    // the default device session timeout can stay private.\n+    public static final int DEFAULT_AMQP_OPEN_AUTHENTICATION_SESSION_TIMEOUT_IN_SECONDS = 20;\n     private static final int DEFAULT_AMQP_OPEN_DEVICE_SESSIONS_TIMEOUT_IN_SECONDS = 60;", "originalCommit": "15ca17d7923d36f54663fbd8722769c315c45156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU1ODU2Mw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521558563", "bodyText": "The former is how long the SDK should wait for the CBS session and its links to open, and the latter is how long the SDK should wait for the worker links (twin/telemetry/methods) to open. In the multiplexing case, the authentication session timeout is considered a \"Multiplexing level\" option, whereas the device session timeout can be set per registered device client.", "author": "timtay-microsoft", "createdAt": "2020-11-11T18:32:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxMjI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxMzg3NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520913875", "bodyText": "question on a slightly unrelated-to-multiplexing note - I recently found that if the .NET sdk is initially disconnected right after initialization, it reports a \"Disconnected\" state, even though it is actively retrying at this point. Does java behave as expected?", "author": "abhipsaMisra", "createdAt": "2020-11-10T22:26:41Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -136,6 +130,21 @@\n         this.state = IotHubConnectionStatus.DISCONNECTED;\n     }\n \n+    DeviceIO(String hostName, IotHubClientProtocol protocol, SSLContext sslContext, ProxySettings proxySettings, long sendPeriodInMilliseconds, long receivePeriodInMilliseconds)\n+    {\n+        this.sendPeriodInMilliseconds = sendPeriodInMilliseconds;\n+        this.receivePeriodInMilliseconds = receivePeriodInMilliseconds;\n+\n+        this.state = IotHubConnectionStatus.DISCONNECTED;", "originalCommit": "15ca17d7923d36f54663fbd8722769c315c45156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU1OTA0OQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521559049", "bodyText": "The Java SDK only reports when the connection status changes, so it should work as expected in that case, yes", "author": "timtay-microsoft", "createdAt": "2020-11-11T18:33:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxMzg3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNDI1NA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520914254", "bodyText": "this line and the two below it are repeated in this block - rebase issue?", "author": "abhipsaMisra", "createdAt": "2020-11-10T22:27:32Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -136,6 +130,21 @@\n         this.state = IotHubConnectionStatus.DISCONNECTED;\n     }\n \n+    DeviceIO(String hostName, IotHubClientProtocol protocol, SSLContext sslContext, ProxySettings proxySettings, long sendPeriodInMilliseconds, long receivePeriodInMilliseconds)\n+    {\n+        this.sendPeriodInMilliseconds = sendPeriodInMilliseconds;\n+        this.receivePeriodInMilliseconds = receivePeriodInMilliseconds;\n+\n+        this.state = IotHubConnectionStatus.DISCONNECTED;\n+\n+        this.transport = new IotHubTransport(hostName, protocol, sslContext, proxySettings, this);\n+\n+        this.sendPeriodInMilliseconds = sendPeriodInMilliseconds;", "originalCommit": "15ca17d7923d36f54663fbd8722769c315c45156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU1OTM4NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521559385", "bodyText": "Good catch, it does appear to be a rebase issue", "author": "timtay-microsoft", "createdAt": "2020-11-11T18:33:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNDI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1NDEzMw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520954133", "bodyText": "Q - is this called only for multiplexed devices?", "author": "abhipsaMisra", "createdAt": "2020-11-11T00:09:33Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/InternalClient.java", "diffHunk": "@@ -745,7 +773,18 @@ DeviceIO getDeviceIO()\n      */\n     void setDeviceIO(DeviceIO deviceIO)\n     {\n+        // deviceIO may be set to null in the case when a device client was multiplexing and was unregistered\n         this.deviceIO = deviceIO;\n+\n+        // Since connection status callbacks can be registered before associating a device client with a multiplexing client, the callback and its\n+        // context also need to be registered when the device IO is set.\n+        if (this.deviceIO != null && this.connectionStatusChangeCallback != null)\n+        {\n+            this.deviceIO.registerConnectionStatusChangeCallback(", "originalCommit": "15ca17d7923d36f54663fbd8722769c315c45156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2MDU4Mg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521560582", "bodyText": "Yes, but both the old TransportClient and the new MultiplexingClient call into this. In both cases, they set the deviceIO of each device client to be the same deviceIO instance. That way they all share the same connection, worker threads, etc.", "author": "timtay-microsoft", "createdAt": "2020-11-11T18:35:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1NDEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1NTQ0MQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520955441", "bodyText": "In which scenario would a user set one with a deviceId and without, or do both of them behave the same way? I see that this is publicly exposed under DeviceIO, but I don't think users access this directly, correct?", "author": "abhipsaMisra", "createdAt": "2020-11-11T00:13:31Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -432,10 +446,15 @@ public void registerConnectionStateCallback(IotHubConnectionStateCallback callba\n         this.transport.registerConnectionStateCallback(callback, callbackContext);\n     }\n \n-    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback statusChangeCallback, Object callbackContext)\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback statusChangeCallback, Object callbackContext, String deviceId)\n     {\n         //Codes_SRS_DEVICE_IO_34_020: [This function shall register the callback with the transport.]\n-        this.transport.registerConnectionStatusChangeCallback(statusChangeCallback, callbackContext);\n+        this.transport.registerConnectionStatusChangeCallback(statusChangeCallback, callbackContext, deviceId);\n+    }\n+\n+    public void registerMultiplexingConnectionStateCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)", "originalCommit": "15ca17d7923d36f54663fbd8722769c315c45156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2MTEzOQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521561139", "bodyText": "This actually doesn't need to be public, so I'll make this package private", "author": "timtay-microsoft", "createdAt": "2020-11-11T18:36:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1NTQ0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2MTkzNw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521561937", "bodyText": "The deviceId is specified to indicate that it will be called when connection status events occur to that specific device. For instance if the SAS token expires for just that device, then the user's device level callback would be fired", "author": "timtay-microsoft", "createdAt": "2020-11-11T18:38:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1NTQ0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2MzMxMg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521563312", "bodyText": "registerMultiplexingConnectionStateCallback on the other hand is strictly for multiplexed connection level events, like TCP connection drops", "author": "timtay-microsoft", "createdAt": "2020-11-11T18:40:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1NTQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1ODY1Ng==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520958656", "bodyText": "q - would deviceIO ever be null? Would it be null if I were to call multiplexedClient.close() twice, in succession?", "author": "abhipsaMisra", "createdAt": "2020-11-11T00:23:07Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,456 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.RetryPolicy;\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static final long DEFAULT_SEND_PERIOD_MILLIS = 10L;\n+    public static final long DEFAULT_RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private final DeviceIO deviceIO;\n+    private final ArrayList<DeviceClient> deviceClientList;\n+    private final String hostName;\n+    private final IotHubClientProtocol protocol;\n+\n+    // This lock is used to keep open/close/register/unregister operations atomic to prevent race conditions\n+    private final Object operationLock = new Object();\n+\n+    // Optional settings from MultiplexingClientOptions\n+    private SSLContext sslContext;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS = 1000;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS_WS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS = 500;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol)\n+    {\n+        this(hostName, protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param options The optional parameters to configure this client to use.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol, MultiplexingClientOptions options)\n+    {\n+        Objects.requireNonNull(hostName);\n+        Objects.requireNonNull(protocol);\n+\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.hostName = hostName;\n+        this.protocol = protocol;\n+        this.proxySettings = options != null ? options.getProxySettings() : null;\n+        long sendPeriod = options != null ? options.getSendPeriod() : DEFAULT_SEND_PERIOD_MILLIS;\n+        long receivePeriod = options != null ? options.getReceivePeriod() : DEFAULT_RECEIVE_PERIOD_MILLIS;\n+\n+        if (sendPeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"send period can not be negative\");\n+        }\n+        else if (sendPeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            sendPeriod = DEFAULT_SEND_PERIOD_MILLIS;\n+        }\n+\n+        if (receivePeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"receive period can not be negative\");\n+        }\n+        else if (receivePeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            receivePeriod = DEFAULT_RECEIVE_PERIOD_MILLIS;\n+        }\n+\n+        this.sslContext = options != null ? options.getSslContext() : null;\n+        this.deviceIO = new DeviceIO(hostName, protocol, sslContext, proxySettings, sendPeriod, receivePeriod);\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. This may be done before or after registering any number of device clients.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Opening multiplexing client\");\n+            this.deviceIO.open();\n+            log.info(\"Successfully opened multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve all previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Closing multiplexing client\");\n+            for (DeviceClient deviceClient : this.deviceClientList)\n+            {\n+                deviceClient.closeFileUpload();\n+            }\n+\n+            if (this.deviceIO != null)", "originalCommit": "15ca17d7923d36f54663fbd8722769c315c45156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2NDIxOA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521564218", "bodyText": "It will never be null. This check was a remnant of back when the deviceIO was only created after registering the first device client. Now that the constructor builds this, and it is declared final, I can remove this null check", "author": "timtay-microsoft", "createdAt": "2020-11-11T18:42:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1ODY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2NDU5NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521564595", "bodyText": "Closing/opening the client has no affect on what deviceIO object is set here. Only the constructor sets it. No one else sets it to null", "author": "timtay-microsoft", "createdAt": "2020-11-11T18:43:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1ODY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1ODg5NA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520958894", "bodyText": "q - does deviceIO.close() close the transport layer? (the amqp connection)", "author": "abhipsaMisra", "createdAt": "2020-11-11T00:23:54Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,456 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.RetryPolicy;\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static final long DEFAULT_SEND_PERIOD_MILLIS = 10L;\n+    public static final long DEFAULT_RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private final DeviceIO deviceIO;\n+    private final ArrayList<DeviceClient> deviceClientList;\n+    private final String hostName;\n+    private final IotHubClientProtocol protocol;\n+\n+    // This lock is used to keep open/close/register/unregister operations atomic to prevent race conditions\n+    private final Object operationLock = new Object();\n+\n+    // Optional settings from MultiplexingClientOptions\n+    private SSLContext sslContext;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS = 1000;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS_WS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS = 500;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol)\n+    {\n+        this(hostName, protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param options The optional parameters to configure this client to use.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol, MultiplexingClientOptions options)\n+    {\n+        Objects.requireNonNull(hostName);\n+        Objects.requireNonNull(protocol);\n+\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.hostName = hostName;\n+        this.protocol = protocol;\n+        this.proxySettings = options != null ? options.getProxySettings() : null;\n+        long sendPeriod = options != null ? options.getSendPeriod() : DEFAULT_SEND_PERIOD_MILLIS;\n+        long receivePeriod = options != null ? options.getReceivePeriod() : DEFAULT_RECEIVE_PERIOD_MILLIS;\n+\n+        if (sendPeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"send period can not be negative\");\n+        }\n+        else if (sendPeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            sendPeriod = DEFAULT_SEND_PERIOD_MILLIS;\n+        }\n+\n+        if (receivePeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"receive period can not be negative\");\n+        }\n+        else if (receivePeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            receivePeriod = DEFAULT_RECEIVE_PERIOD_MILLIS;\n+        }\n+\n+        this.sslContext = options != null ? options.getSslContext() : null;\n+        this.deviceIO = new DeviceIO(hostName, protocol, sslContext, proxySettings, sendPeriod, receivePeriod);\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. This may be done before or after registering any number of device clients.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Opening multiplexing client\");\n+            this.deviceIO.open();\n+            log.info(\"Successfully opened multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve all previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Closing multiplexing client\");\n+            for (DeviceClient deviceClient : this.deviceClientList)\n+            {\n+                deviceClient.closeFileUpload();\n+            }\n+\n+            if (this.deviceIO != null)\n+            {\n+                this.deviceIO.multiplexClose();", "originalCommit": "15ca17d7923d36f54663fbd8722769c315c45156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2NDgxMg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521564812", "bodyText": "Yes, and it also stops the worker threads from spawning to handle IO events", "author": "timtay-microsoft", "createdAt": "2020-11-11T18:43:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1ODg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2MTQ4NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520961485", "bodyText": "I remember reading above that each device client can have its own retry policy. Would the device client level retry policy (if provided) override the multiplexing client level retry policy?", "author": "abhipsaMisra", "createdAt": "2020-11-11T00:31:42Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,456 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.RetryPolicy;\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static final long DEFAULT_SEND_PERIOD_MILLIS = 10L;\n+    public static final long DEFAULT_RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private final DeviceIO deviceIO;\n+    private final ArrayList<DeviceClient> deviceClientList;\n+    private final String hostName;\n+    private final IotHubClientProtocol protocol;\n+\n+    // This lock is used to keep open/close/register/unregister operations atomic to prevent race conditions\n+    private final Object operationLock = new Object();\n+\n+    // Optional settings from MultiplexingClientOptions\n+    private SSLContext sslContext;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS = 1000;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS_WS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS = 500;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol)\n+    {\n+        this(hostName, protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param options The optional parameters to configure this client to use.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol, MultiplexingClientOptions options)\n+    {\n+        Objects.requireNonNull(hostName);\n+        Objects.requireNonNull(protocol);\n+\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.hostName = hostName;\n+        this.protocol = protocol;\n+        this.proxySettings = options != null ? options.getProxySettings() : null;\n+        long sendPeriod = options != null ? options.getSendPeriod() : DEFAULT_SEND_PERIOD_MILLIS;\n+        long receivePeriod = options != null ? options.getReceivePeriod() : DEFAULT_RECEIVE_PERIOD_MILLIS;\n+\n+        if (sendPeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"send period can not be negative\");\n+        }\n+        else if (sendPeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            sendPeriod = DEFAULT_SEND_PERIOD_MILLIS;\n+        }\n+\n+        if (receivePeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"receive period can not be negative\");\n+        }\n+        else if (receivePeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            receivePeriod = DEFAULT_RECEIVE_PERIOD_MILLIS;\n+        }\n+\n+        this.sslContext = options != null ? options.getSslContext() : null;\n+        this.deviceIO = new DeviceIO(hostName, protocol, sslContext, proxySettings, sendPeriod, receivePeriod);\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. This may be done before or after registering any number of device clients.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Opening multiplexing client\");\n+            this.deviceIO.open();\n+            log.info(\"Successfully opened multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve all previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Closing multiplexing client\");\n+            for (DeviceClient deviceClient : this.deviceClientList)\n+            {\n+                deviceClient.closeFileUpload();\n+            }\n+\n+            if (this.deviceIO != null)\n+            {\n+                this.deviceIO.multiplexClose();\n+            }\n+\n+            // Note that this method does not close each of the registered device client instances. This is intentional\n+            // as the calls to deviceClient.close() do nothing besides close the deviceIO layer, which is already closed\n+            // by the above code.\n+\n+            log.info(\"Successfully closed multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Register a device client to this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection.\n+     * <p>\n+     * Users should use {@link #registerDeviceClients(Iterable)} for registering multiple devices as it has some\n+     * performance improvements over repeatedly calling this method. This method blocks on each registration, whereas\n+     * {@link #registerDeviceClients(Iterable)} blocks on all of the registrations after starting them all asynchronously.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will add this device client to the\n+     * multiplexed connection, and then will block until the registration has been completed.\n+     * <p>\n+     * Any proxy settings set to the provided device clients will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * Each registered device client may have its own retry policy and its own SAS token expiry time, separate from every other registered device client.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If the provided device client is already registered to this multiplexing client, then then this method will do nothing.\n+     * <p>\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n+     * will never be thrown if the multiplexing client is not open yet.\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient) throws InterruptedException {\n+        Objects.requireNonNull(deviceClient);\n+        List<DeviceClient> clientList = new ArrayList<>();\n+        clientList.add(deviceClient);\n+        registerDeviceClients(clientList);\n+    }\n+\n+    /**\n+     * Register device clients to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then these device clients will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then these device clients will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will asynchronously add each device client to the\n+     * multiplexed connection, and then will block until all registrations have been completed.\n+     * <p>\n+     * Any proxy settings set to the provided device clients will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device clients must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * Each registered device client may have its own retry policy and its own SAS token expiry time, separate from every other registered device client.\n+     * <p>\n+     * The registered device clients must use symmetric key based authentication.\n+     * <p>\n+     * The registered device clients must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If any of these device clients are already registered to this multiplexing client, then then this method will\n+     * not do anything to that particular device client. All other provided device clients will still be registered though.\n+     * <p>\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n+     * will never be thrown if the multiplexing client is not open yet.\n+     * @param deviceClients The device clients to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClients(Iterable<DeviceClient> deviceClients) throws InterruptedException {\n+        Objects.requireNonNull(deviceClients);\n+\n+        synchronized (this.operationLock)\n+        {\n+            List<DeviceClientConfig> deviceClientConfigsToRegister = new ArrayList<>();\n+            for (DeviceClient deviceClientToRegister : deviceClients)\n+            {\n+                DeviceClientConfig configToAdd = deviceClientToRegister.getConfig();\n+\n+                // Overwrite the sslContext of the new client to match the multiplexing client\n+                // settings if it was set. If it wasn't set, defer to the default client to set this ssl context\n+                if (this.sslContext != null)\n+                {\n+                    configToAdd.getAuthenticationProvider().setSSLContext(this.sslContext);\n+                }\n+\n+                // Overwrite the proxy settings of the new client to match the multiplexing client settings\n+                configToAdd.setProxy(this.proxySettings);\n+\n+                boolean deviceAlreadyRegistered = false;\n+                for (DeviceClient currentClient : deviceClientList)\n+                {\n+                    String currentDeviceId = currentClient.getConfig().getDeviceId();\n+                    if (currentDeviceId.equalsIgnoreCase(configToAdd.getDeviceId()))\n+                    {\n+                        deviceAlreadyRegistered = true;\n+                        break;\n+                    }\n+                }\n+\n+                if (deviceAlreadyRegistered)\n+                {\n+                    log.debug(\"Device {} wasn't registered to the multiplexed connection because it is already registered.\", configToAdd.getDeviceId());\n+                    continue;\n+                }\n+\n+                if (configToAdd.getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+                {\n+                    throw new UnsupportedOperationException(\"Can only register to multiplex a device client that uses SAS token based authentication\");\n+                }\n+\n+                if (configToAdd.getProtocol() != this.protocol)\n+                {\n+                    throw new UnsupportedOperationException(\"A device client cannot be registered to a multiplexing client that specifies a different transport protocol.\");\n+                }\n+\n+                if (this.protocol == IotHubClientProtocol.AMQPS && this.deviceClientList.size() > MAX_MULTIPLEX_DEVICE_COUNT_AMQPS)\n+                {\n+                    throw new UnsupportedOperationException(String.format(\"Multiplexed connections over AMQPS only support up to %d devices\", MAX_MULTIPLEX_DEVICE_COUNT_AMQPS));\n+                }\n+\n+                // Typically client side validation is duplicate work, but IoT Hub doesn't give a good error message when closing the\n+                // AMQPS_WS connection so this is the only way that users will know about this limit\n+                if (this.protocol == IotHubClientProtocol.AMQPS_WS && this.deviceClientList.size() > MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS)\n+                {\n+                    throw new UnsupportedOperationException(String.format(\"Multiplexed connections over AMQPS_WS only support up to %d devices\", MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS));\n+                }\n+\n+                if (!this.hostName.equalsIgnoreCase(configToAdd.getIotHubHostname()))\n+                {\n+                    throw new UnsupportedOperationException(\"A device client cannot be registered to a multiplexing client that specifies a different host name.\");\n+                }\n+\n+                if (deviceClientToRegister.getDeviceIO() != null && deviceClientToRegister.getDeviceIO().isOpen())\n+                {\n+                    throw new IllegalStateException(\"Cannot register a device client to a multiplexed connection when it the device client was already opened.\");\n+                }\n+\n+                deviceClientToRegister.setAsMultiplexed();\n+                deviceClientToRegister.setDeviceIO(this.deviceIO);\n+                deviceClientToRegister.setConnectionType(IoTHubConnectionType.USE_MULTIPLEXING_CLIENT);\n+                this.deviceClientList.add(deviceClientToRegister);\n+                deviceClientConfigsToRegister.add(configToAdd);\n+            }\n+\n+            // if the device IO hasn't been created yet, then this client will be registered once it is created.\n+            for (DeviceClientConfig configBeingRegistered : deviceClientConfigsToRegister)\n+            {\n+                log.info(\"Registering device {} to multiplexing client\", configBeingRegistered.getDeviceId());\n+            }\n+            this.deviceIO.registerMultiplexedDeviceClient(deviceClientConfigsToRegister);\n+        }\n+    }\n+\n+    /**\n+     * Unregister a device client from this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection.\n+     * <p>\n+     * Users should use {@link #unregisterDeviceClients(Iterable)} for unregistering multiple devices as it has some\n+     * performance improvements over repeatedly calling this method. This method blocks on each unregistration, whereas\n+     * {@link #registerDeviceClients(Iterable)} blocks on all of the unregistrations after starting them all asynchronously.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will close the AMQP device session associated with\n+     * this device, but it will not close any other registered device sessions or the multiplexing client itself.\n+     * <p>\n+     * If the multiplexed connection is already open, and this call would unregister the last device client,\n+     * the multiplexed connection will remain open. The multiplexed connection can only be closed by calling\n+     * {@link #close()}\n+     * <p>\n+     * Once a device client is unregistered, it may be re-registered to this or any other multiplexing client. It cannot\n+     * be used in non-multiplexing scenarios or used by the deprecated {@link TransportClient}.\n+     * <p>\n+     * @param deviceClient The device client to unregister from this multiplexing client.\n+     */\n+    public void unregisterDeviceClient(DeviceClient deviceClient) throws InterruptedException\n+    {\n+        Objects.requireNonNull(deviceClient);\n+        List<DeviceClient> clientList = new ArrayList<>();\n+        clientList.add(deviceClient);\n+        unregisterDeviceClients(clientList);\n+    }\n+\n+    /**\n+     * Unregister device clients from this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will close the AMQP device session associated with\n+     * this device, but it will not close any other registered device sessions or the multiplexing client itself.\n+     * <p>\n+     * If the multiplexed connection is already open, and this call would unregister the last device clients,\n+     * the multiplexed connection will remain open. The multiplexed connection can only be closed by calling\n+     * {@link #close()}\n+     * <p>\n+     * Once a device client is unregistered, it may be re-registered to this or any other multiplexing client. It cannot\n+     * be used in non-multiplexing scenarios or used by the deprecated {@link TransportClient}.\n+     * <p>\n+     * @param deviceClients The device clients to unregister from this multiplexing client.\n+     */\n+    public void unregisterDeviceClients(Iterable<DeviceClient> deviceClients) throws InterruptedException\n+    {\n+        Objects.requireNonNull(deviceClients);\n+\n+        synchronized (this.operationLock)\n+        {\n+            List<DeviceClientConfig> deviceClientConfigsToRegister = new ArrayList<>();\n+            for (DeviceClient deviceClientToUnregister : deviceClients)\n+            {\n+                DeviceClientConfig configToUnregister = deviceClientToUnregister.getConfig();\n+                deviceClientConfigsToRegister.add(configToUnregister);\n+                log.info(\"Unregistering device {} from multiplexing client\", deviceClientToUnregister.getConfig().getDeviceId());\n+                this.deviceClientList.remove(deviceClientToUnregister);\n+                deviceClientToUnregister.setDeviceIO(null);\n+            }\n+\n+            this.deviceIO.unregisterMultiplexedDeviceClient(deviceClientConfigsToRegister);\n+        }\n+    }\n+\n+    /**\n+     * Registers a callback to be executed when the connection status of the multiplexed connection as a whole changes.\n+     * The callback will be fired with a status and a reason why the multiplexed connection's status changed. When the\n+     * callback is fired, the provided context will be provided alongside the status and reason.\n+     *\n+     * <p>Note that this callback will not be fired for device specific connection status changes. In order to be notified\n+     * when a particular device's connection status changes, you will need to register a connection status change callback\n+     * on that device client instance using {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     *\n+     * <p>Note that the thread used to deliver this callback should not be used to call open()/closeNow() on the client\n+     * that this callback belongs to. All open()/closeNow() operations should be done on a separate thread</p>\n+     *\n+     * @param callback The callback to be fired when the connection status of the multiplexed connection changes.\n+     *                 Can be null to unset this listener as long as the provided callbackContext is also null.\n+     * @param callbackContext a context to be passed to the callback. Can be {@code null}.\n+     */\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)\n+    {\n+        this.deviceIO.registerMultiplexingConnectionStateCallback(callback, callbackContext);\n+    }\n+\n+    /**\n+     * Returns if a device client for the provided device Id is already registered to this multiplexing client.\n+     * @param deviceId The Id of the device client to look for.\n+     * @return True if a device client is already registered with this Id. False otherwise.\n+     */\n+    public boolean isDeviceRegistered(String deviceId)\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            for (DeviceClient client : this.deviceClientList)\n+            {\n+                if (client.getConfig().getDeviceId().equalsIgnoreCase(deviceId))\n+                {\n+                    return true;\n+                }\n+            }\n+\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Get the number of currently registered devices on this multiplexing client.\n+     * @return The number of currently registered devices on this multiplexing client.\n+     */\n+    public int getRegisteredDeviceCount()\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            // O(1) operation since ArrayList saves this value as an integer rather than iterating over each element.\n+            // So there is no need to be more clever about this.\n+            return this.deviceClientList.size();\n+        }\n+    }\n+\n+    /**\n+     * Sets the given retry policy for the multiplexing client level connection management.\n+     * <a href=\"https://github.com/Azure/azure-iot-sdk-java/blob/master/device/iot-device-client/devdoc/requirement_docs/com/microsoft/azure/iothub/retryPolicy.md\">\n+     *     See more details about the default retry policy and about using custom retry policies here</a>\n+     * @param retryPolicy The policy that the multiplexing client will use when reconnecting.\n+     */\n+    public void setRetryPolicy(RetryPolicy retryPolicy)\n+    {\n+        this.deviceIO.setMultiplexingRetryPolicy(retryPolicy);", "originalCommit": "15ca17d7923d36f54663fbd8722769c315c45156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2Njk1NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521566955", "bodyText": "No. Each device client's retry policy is only consulted when a message send on that particular device fails, or if that particular device has its session lost. For connection level events like TCP connection drop, only the multiplexing level retry policy is consulted", "author": "timtay-microsoft", "createdAt": "2020-11-11T18:47:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2MTQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI3NDMxMw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r523274313", "bodyText": "We call it out as such in our javadoc comments, right?", "author": "abhipsaMisra", "createdAt": "2020-11-13T22:54:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2MTQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk4NDAxMw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520984013", "bodyText": "\ud83d\udc4d", "author": "abhipsaMisra", "createdAt": "2020-11-11T01:13:32Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,456 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.RetryPolicy;\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static final long DEFAULT_SEND_PERIOD_MILLIS = 10L;\n+    public static final long DEFAULT_RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private final DeviceIO deviceIO;\n+    private final ArrayList<DeviceClient> deviceClientList;\n+    private final String hostName;\n+    private final IotHubClientProtocol protocol;\n+\n+    // This lock is used to keep open/close/register/unregister operations atomic to prevent race conditions\n+    private final Object operationLock = new Object();\n+\n+    // Optional settings from MultiplexingClientOptions\n+    private SSLContext sslContext;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS = 1000;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS_WS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS = 500;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol)\n+    {\n+        this(hostName, protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param options The optional parameters to configure this client to use.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol, MultiplexingClientOptions options)\n+    {\n+        Objects.requireNonNull(hostName);\n+        Objects.requireNonNull(protocol);\n+\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.hostName = hostName;\n+        this.protocol = protocol;\n+        this.proxySettings = options != null ? options.getProxySettings() : null;\n+        long sendPeriod = options != null ? options.getSendPeriod() : DEFAULT_SEND_PERIOD_MILLIS;\n+        long receivePeriod = options != null ? options.getReceivePeriod() : DEFAULT_RECEIVE_PERIOD_MILLIS;\n+\n+        if (sendPeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"send period can not be negative\");\n+        }\n+        else if (sendPeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            sendPeriod = DEFAULT_SEND_PERIOD_MILLIS;\n+        }\n+\n+        if (receivePeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"receive period can not be negative\");\n+        }\n+        else if (receivePeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            receivePeriod = DEFAULT_RECEIVE_PERIOD_MILLIS;\n+        }\n+\n+        this.sslContext = options != null ? options.getSslContext() : null;\n+        this.deviceIO = new DeviceIO(hostName, protocol, sslContext, proxySettings, sendPeriod, receivePeriod);\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. This may be done before or after registering any number of device clients.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Opening multiplexing client\");\n+            this.deviceIO.open();\n+            log.info(\"Successfully opened multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve all previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Closing multiplexing client\");\n+            for (DeviceClient deviceClient : this.deviceClientList)\n+            {\n+                deviceClient.closeFileUpload();\n+            }\n+\n+            if (this.deviceIO != null)\n+            {\n+                this.deviceIO.multiplexClose();\n+            }\n+\n+            // Note that this method does not close each of the registered device client instances. This is intentional\n+            // as the calls to deviceClient.close() do nothing besides close the deviceIO layer, which is already closed\n+            // by the above code.\n+\n+            log.info(\"Successfully closed multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Register a device client to this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection.\n+     * <p>\n+     * Users should use {@link #registerDeviceClients(Iterable)} for registering multiple devices as it has some\n+     * performance improvements over repeatedly calling this method. This method blocks on each registration, whereas\n+     * {@link #registerDeviceClients(Iterable)} blocks on all of the registrations after starting them all asynchronously.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will add this device client to the\n+     * multiplexed connection, and then will block until the registration has been completed.\n+     * <p>\n+     * Any proxy settings set to the provided device clients will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * Each registered device client may have its own retry policy and its own SAS token expiry time, separate from every other registered device client.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If the provided device client is already registered to this multiplexing client, then then this method will do nothing.\n+     * <p>\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n+     * will never be thrown if the multiplexing client is not open yet.\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient) throws InterruptedException {\n+        Objects.requireNonNull(deviceClient);\n+        List<DeviceClient> clientList = new ArrayList<>();\n+        clientList.add(deviceClient);\n+        registerDeviceClients(clientList);\n+    }\n+\n+    /**\n+     * Register device clients to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then these device clients will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then these device clients will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will asynchronously add each device client to the\n+     * multiplexed connection, and then will block until all registrations have been completed.\n+     * <p>\n+     * Any proxy settings set to the provided device clients will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device clients must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * Each registered device client may have its own retry policy and its own SAS token expiry time, separate from every other registered device client.\n+     * <p>\n+     * The registered device clients must use symmetric key based authentication.\n+     * <p>\n+     * The registered device clients must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If any of these device clients are already registered to this multiplexing client, then then this method will\n+     * not do anything to that particular device client. All other provided device clients will still be registered though.\n+     * <p>\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n+     * will never be thrown if the multiplexing client is not open yet.\n+     * @param deviceClients The device clients to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClients(Iterable<DeviceClient> deviceClients) throws InterruptedException {\n+        Objects.requireNonNull(deviceClients);\n+\n+        synchronized (this.operationLock)", "originalCommit": "15ca17d7923d36f54663fbd8722769c315c45156", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk4ODY2Nw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520988667", "bodyText": "if we perform the registration operation again for a device that is already registered, will there be an issue? I am thinking abut how heavy this for loop will be, for ~1000 devices, and if making registration idempotent is an option.", "author": "abhipsaMisra", "createdAt": "2020-11-11T01:20:20Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,456 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.RetryPolicy;\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static final long DEFAULT_SEND_PERIOD_MILLIS = 10L;\n+    public static final long DEFAULT_RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private final DeviceIO deviceIO;\n+    private final ArrayList<DeviceClient> deviceClientList;\n+    private final String hostName;\n+    private final IotHubClientProtocol protocol;\n+\n+    // This lock is used to keep open/close/register/unregister operations atomic to prevent race conditions\n+    private final Object operationLock = new Object();\n+\n+    // Optional settings from MultiplexingClientOptions\n+    private SSLContext sslContext;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS = 1000;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS_WS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS = 500;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol)\n+    {\n+        this(hostName, protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param options The optional parameters to configure this client to use.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol, MultiplexingClientOptions options)\n+    {\n+        Objects.requireNonNull(hostName);\n+        Objects.requireNonNull(protocol);\n+\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.hostName = hostName;\n+        this.protocol = protocol;\n+        this.proxySettings = options != null ? options.getProxySettings() : null;\n+        long sendPeriod = options != null ? options.getSendPeriod() : DEFAULT_SEND_PERIOD_MILLIS;\n+        long receivePeriod = options != null ? options.getReceivePeriod() : DEFAULT_RECEIVE_PERIOD_MILLIS;\n+\n+        if (sendPeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"send period can not be negative\");\n+        }\n+        else if (sendPeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            sendPeriod = DEFAULT_SEND_PERIOD_MILLIS;\n+        }\n+\n+        if (receivePeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"receive period can not be negative\");\n+        }\n+        else if (receivePeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            receivePeriod = DEFAULT_RECEIVE_PERIOD_MILLIS;\n+        }\n+\n+        this.sslContext = options != null ? options.getSslContext() : null;\n+        this.deviceIO = new DeviceIO(hostName, protocol, sslContext, proxySettings, sendPeriod, receivePeriod);\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. This may be done before or after registering any number of device clients.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Opening multiplexing client\");\n+            this.deviceIO.open();\n+            log.info(\"Successfully opened multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve all previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Closing multiplexing client\");\n+            for (DeviceClient deviceClient : this.deviceClientList)\n+            {\n+                deviceClient.closeFileUpload();\n+            }\n+\n+            if (this.deviceIO != null)\n+            {\n+                this.deviceIO.multiplexClose();\n+            }\n+\n+            // Note that this method does not close each of the registered device client instances. This is intentional\n+            // as the calls to deviceClient.close() do nothing besides close the deviceIO layer, which is already closed\n+            // by the above code.\n+\n+            log.info(\"Successfully closed multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Register a device client to this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection.\n+     * <p>\n+     * Users should use {@link #registerDeviceClients(Iterable)} for registering multiple devices as it has some\n+     * performance improvements over repeatedly calling this method. This method blocks on each registration, whereas\n+     * {@link #registerDeviceClients(Iterable)} blocks on all of the registrations after starting them all asynchronously.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will add this device client to the\n+     * multiplexed connection, and then will block until the registration has been completed.\n+     * <p>\n+     * Any proxy settings set to the provided device clients will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * Each registered device client may have its own retry policy and its own SAS token expiry time, separate from every other registered device client.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If the provided device client is already registered to this multiplexing client, then then this method will do nothing.\n+     * <p>\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n+     * will never be thrown if the multiplexing client is not open yet.\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient) throws InterruptedException {\n+        Objects.requireNonNull(deviceClient);\n+        List<DeviceClient> clientList = new ArrayList<>();\n+        clientList.add(deviceClient);\n+        registerDeviceClients(clientList);\n+    }\n+\n+    /**\n+     * Register device clients to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then these device clients will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then these device clients will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will asynchronously add each device client to the\n+     * multiplexed connection, and then will block until all registrations have been completed.\n+     * <p>\n+     * Any proxy settings set to the provided device clients will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device clients must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * Each registered device client may have its own retry policy and its own SAS token expiry time, separate from every other registered device client.\n+     * <p>\n+     * The registered device clients must use symmetric key based authentication.\n+     * <p>\n+     * The registered device clients must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If any of these device clients are already registered to this multiplexing client, then then this method will\n+     * not do anything to that particular device client. All other provided device clients will still be registered though.\n+     * <p>\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n+     * will never be thrown if the multiplexing client is not open yet.\n+     * @param deviceClients The device clients to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClients(Iterable<DeviceClient> deviceClients) throws InterruptedException {\n+        Objects.requireNonNull(deviceClients);\n+\n+        synchronized (this.operationLock)\n+        {\n+            List<DeviceClientConfig> deviceClientConfigsToRegister = new ArrayList<>();\n+            for (DeviceClient deviceClientToRegister : deviceClients)\n+            {\n+                DeviceClientConfig configToAdd = deviceClientToRegister.getConfig();\n+\n+                // Overwrite the sslContext of the new client to match the multiplexing client\n+                // settings if it was set. If it wasn't set, defer to the default client to set this ssl context\n+                if (this.sslContext != null)\n+                {\n+                    configToAdd.getAuthenticationProvider().setSSLContext(this.sslContext);\n+                }\n+\n+                // Overwrite the proxy settings of the new client to match the multiplexing client settings\n+                configToAdd.setProxy(this.proxySettings);\n+\n+                boolean deviceAlreadyRegistered = false;\n+                for (DeviceClient currentClient : deviceClientList)", "originalCommit": "15ca17d7923d36f54663fbd8722769c315c45156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU4NDg5OA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521584898", "bodyText": "Good point. I can make this list a set instead to make this more idempotent", "author": "timtay-microsoft", "createdAt": "2020-11-11T19:21:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk4ODY2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU4NTIzOA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521585238", "bodyText": "HashSet's in Java are basically O(1) to add, so that will be a nice performance boost", "author": "timtay-microsoft", "createdAt": "2020-11-11T19:22:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk4ODY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk5MjI5Mg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520992292", "bodyText": "I am a bit confused about how deviceIO works. This is what I thought, but now I think I might be misunderstanding it:\n\ndeviceIO is the \"interface\" for transforming device client operations to the transport layer\nthis.deviceIO is the deviceIO associated with the multiplexing client, which is then getting assigned to the device client instance.\nIn that case, how do we differentiate between the deviceIO for device1 vs device2?", "author": "abhipsaMisra", "createdAt": "2020-11-11T01:25:22Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,456 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.RetryPolicy;\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static final long DEFAULT_SEND_PERIOD_MILLIS = 10L;\n+    public static final long DEFAULT_RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private final DeviceIO deviceIO;\n+    private final ArrayList<DeviceClient> deviceClientList;\n+    private final String hostName;\n+    private final IotHubClientProtocol protocol;\n+\n+    // This lock is used to keep open/close/register/unregister operations atomic to prevent race conditions\n+    private final Object operationLock = new Object();\n+\n+    // Optional settings from MultiplexingClientOptions\n+    private SSLContext sslContext;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS = 1000;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS_WS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS = 500;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol)\n+    {\n+        this(hostName, protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param options The optional parameters to configure this client to use.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol, MultiplexingClientOptions options)\n+    {\n+        Objects.requireNonNull(hostName);\n+        Objects.requireNonNull(protocol);\n+\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.hostName = hostName;\n+        this.protocol = protocol;\n+        this.proxySettings = options != null ? options.getProxySettings() : null;\n+        long sendPeriod = options != null ? options.getSendPeriod() : DEFAULT_SEND_PERIOD_MILLIS;\n+        long receivePeriod = options != null ? options.getReceivePeriod() : DEFAULT_RECEIVE_PERIOD_MILLIS;\n+\n+        if (sendPeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"send period can not be negative\");\n+        }\n+        else if (sendPeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            sendPeriod = DEFAULT_SEND_PERIOD_MILLIS;\n+        }\n+\n+        if (receivePeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"receive period can not be negative\");\n+        }\n+        else if (receivePeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            receivePeriod = DEFAULT_RECEIVE_PERIOD_MILLIS;\n+        }\n+\n+        this.sslContext = options != null ? options.getSslContext() : null;\n+        this.deviceIO = new DeviceIO(hostName, protocol, sslContext, proxySettings, sendPeriod, receivePeriod);\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. This may be done before or after registering any number of device clients.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Opening multiplexing client\");\n+            this.deviceIO.open();\n+            log.info(\"Successfully opened multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve all previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Closing multiplexing client\");\n+            for (DeviceClient deviceClient : this.deviceClientList)\n+            {\n+                deviceClient.closeFileUpload();\n+            }\n+\n+            if (this.deviceIO != null)\n+            {\n+                this.deviceIO.multiplexClose();\n+            }\n+\n+            // Note that this method does not close each of the registered device client instances. This is intentional\n+            // as the calls to deviceClient.close() do nothing besides close the deviceIO layer, which is already closed\n+            // by the above code.\n+\n+            log.info(\"Successfully closed multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Register a device client to this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection.\n+     * <p>\n+     * Users should use {@link #registerDeviceClients(Iterable)} for registering multiple devices as it has some\n+     * performance improvements over repeatedly calling this method. This method blocks on each registration, whereas\n+     * {@link #registerDeviceClients(Iterable)} blocks on all of the registrations after starting them all asynchronously.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will add this device client to the\n+     * multiplexed connection, and then will block until the registration has been completed.\n+     * <p>\n+     * Any proxy settings set to the provided device clients will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * Each registered device client may have its own retry policy and its own SAS token expiry time, separate from every other registered device client.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If the provided device client is already registered to this multiplexing client, then then this method will do nothing.\n+     * <p>\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n+     * will never be thrown if the multiplexing client is not open yet.\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient) throws InterruptedException {\n+        Objects.requireNonNull(deviceClient);\n+        List<DeviceClient> clientList = new ArrayList<>();\n+        clientList.add(deviceClient);\n+        registerDeviceClients(clientList);\n+    }\n+\n+    /**\n+     * Register device clients to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then these device clients will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then these device clients will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will asynchronously add each device client to the\n+     * multiplexed connection, and then will block until all registrations have been completed.\n+     * <p>\n+     * Any proxy settings set to the provided device clients will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device clients must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * Each registered device client may have its own retry policy and its own SAS token expiry time, separate from every other registered device client.\n+     * <p>\n+     * The registered device clients must use symmetric key based authentication.\n+     * <p>\n+     * The registered device clients must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If any of these device clients are already registered to this multiplexing client, then then this method will\n+     * not do anything to that particular device client. All other provided device clients will still be registered though.\n+     * <p>\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n+     * will never be thrown if the multiplexing client is not open yet.\n+     * @param deviceClients The device clients to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClients(Iterable<DeviceClient> deviceClients) throws InterruptedException {\n+        Objects.requireNonNull(deviceClients);\n+\n+        synchronized (this.operationLock)\n+        {\n+            List<DeviceClientConfig> deviceClientConfigsToRegister = new ArrayList<>();\n+            for (DeviceClient deviceClientToRegister : deviceClients)\n+            {\n+                DeviceClientConfig configToAdd = deviceClientToRegister.getConfig();\n+\n+                // Overwrite the sslContext of the new client to match the multiplexing client\n+                // settings if it was set. If it wasn't set, defer to the default client to set this ssl context\n+                if (this.sslContext != null)\n+                {\n+                    configToAdd.getAuthenticationProvider().setSSLContext(this.sslContext);\n+                }\n+\n+                // Overwrite the proxy settings of the new client to match the multiplexing client settings\n+                configToAdd.setProxy(this.proxySettings);\n+\n+                boolean deviceAlreadyRegistered = false;\n+                for (DeviceClient currentClient : deviceClientList)\n+                {\n+                    String currentDeviceId = currentClient.getConfig().getDeviceId();\n+                    if (currentDeviceId.equalsIgnoreCase(configToAdd.getDeviceId()))\n+                    {\n+                        deviceAlreadyRegistered = true;\n+                        break;\n+                    }\n+                }\n+\n+                if (deviceAlreadyRegistered)\n+                {\n+                    log.debug(\"Device {} wasn't registered to the multiplexed connection because it is already registered.\", configToAdd.getDeviceId());\n+                    continue;\n+                }\n+\n+                if (configToAdd.getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+                {\n+                    throw new UnsupportedOperationException(\"Can only register to multiplex a device client that uses SAS token based authentication\");\n+                }\n+\n+                if (configToAdd.getProtocol() != this.protocol)\n+                {\n+                    throw new UnsupportedOperationException(\"A device client cannot be registered to a multiplexing client that specifies a different transport protocol.\");\n+                }\n+\n+                if (this.protocol == IotHubClientProtocol.AMQPS && this.deviceClientList.size() > MAX_MULTIPLEX_DEVICE_COUNT_AMQPS)\n+                {\n+                    throw new UnsupportedOperationException(String.format(\"Multiplexed connections over AMQPS only support up to %d devices\", MAX_MULTIPLEX_DEVICE_COUNT_AMQPS));\n+                }\n+\n+                // Typically client side validation is duplicate work, but IoT Hub doesn't give a good error message when closing the\n+                // AMQPS_WS connection so this is the only way that users will know about this limit\n+                if (this.protocol == IotHubClientProtocol.AMQPS_WS && this.deviceClientList.size() > MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS)\n+                {\n+                    throw new UnsupportedOperationException(String.format(\"Multiplexed connections over AMQPS_WS only support up to %d devices\", MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS));\n+                }\n+\n+                if (!this.hostName.equalsIgnoreCase(configToAdd.getIotHubHostname()))\n+                {\n+                    throw new UnsupportedOperationException(\"A device client cannot be registered to a multiplexing client that specifies a different host name.\");\n+                }\n+\n+                if (deviceClientToRegister.getDeviceIO() != null && deviceClientToRegister.getDeviceIO().isOpen())\n+                {\n+                    throw new IllegalStateException(\"Cannot register a device client to a multiplexed connection when it the device client was already opened.\");\n+                }\n+\n+                deviceClientToRegister.setAsMultiplexed();\n+                deviceClientToRegister.setDeviceIO(this.deviceIO);", "originalCommit": "15ca17d7923d36f54663fbd8722769c315c45156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTcwOTUxMg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521709512", "bodyText": "DeviceIO is a layer whose primary responsibility is managing the worker threads of the SDK. When multiplexing, all devices share the same deviceIO instance and the same worker threads. Within the deviceIO layer is a reference to the transport layer. The deviceIO layer more or less just forwards all telemetry/twin/method messages down to the transport layer. I hope that clears it up a bit", "author": "timtay-microsoft", "createdAt": "2020-11-11T23:48:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk5MjI5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTcwOTY1OQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521709659", "bodyText": "In that case, how do we differentiate between the deviceIO for device1 vs device2?\n\nWhen multiplexing, they have the same deviceIO instance", "author": "timtay-microsoft", "createdAt": "2020-11-11T23:49:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk5MjI5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk5ODY5NA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520998694", "bodyText": "it is safe to assume that network or service related disconnection would always be accompanied by by a throwable, correct?", "author": "abhipsaMisra", "createdAt": "2020-11-11T01:34:21Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -267,64 +291,91 @@ public void onConnectionEstablished(String connectionId)\n     {\n         if (connectionId.equals(this.iotHubTransportConnection.getConnectionId()))\n         {\n-            log.info(\"The connection to the IoT Hub has been established\");\n+            log.debug(\"The connection to the IoT Hub has been established\");\n \n-            //Codes_SRS_IOTHUBTRANSPORT_34_014: [If the provided connectionId is associated with the current connection, This function shall invoke updateStatus with status CONNECTED, change\n-            // reason CONNECTION_OK and a null throwable.]\n             this.updateStatus(IotHubConnectionStatus.CONNECTED, IotHubConnectionStatusChangeReason.CONNECTION_OK, null);\n         }\n     }\n \n+    @Override\n+    public void onMultiplexedDeviceSessionEstablished(String connectionId, String deviceId)\n+    {\n+        if (connectionId.equals(this.iotHubTransportConnection.getConnectionId()))\n+        {\n+            log.debug(\"The device session in the multiplexed connection to the IoT Hub has been established for device {}\", deviceId);\n+            this.updateStatus(IotHubConnectionStatus.CONNECTED, IotHubConnectionStatusChangeReason.CONNECTION_OK, null, deviceId);\n+        }\n+    }\n+\n+    @Override\n+    public void onMultiplexedDeviceSessionLost(Throwable e, String connectionId, String deviceId)\n+    {\n+        if (connectionId.equals(this.iotHubTransportConnection.getConnectionId()))\n+        {\n+            log.debug(\"The device session in the multiplexed connection to the IoT Hub has been lost for device {}\", deviceId);\n+            if (e == null)", "originalCommit": "15ca17d7923d36f54663fbd8722769c315c45156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU4NTgxNA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521585814", "bodyText": "Sort of. Sometimes the connection is lost without any meaningful context other than the event itself, but we do build a default throwable in cases like that", "author": "timtay-microsoft", "createdAt": "2020-11-11T19:23:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk5ODY5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU4NjE1Mw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521586153", "bodyText": "For the graceful close case, there will be no throwable though", "author": "timtay-microsoft", "createdAt": "2020-11-11T19:23:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk5ODY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxMjQ5MA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521012490", "bodyText": "Is the call to Open() thread safe?", "author": "abhipsaMisra", "createdAt": "2020-11-11T01:54:16Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -267,64 +291,91 @@ public void onConnectionEstablished(String connectionId)\n     {\n         if (connectionId.equals(this.iotHubTransportConnection.getConnectionId()))\n         {\n-            log.info(\"The connection to the IoT Hub has been established\");\n+            log.debug(\"The connection to the IoT Hub has been established\");\n \n-            //Codes_SRS_IOTHUBTRANSPORT_34_014: [If the provided connectionId is associated with the current connection, This function shall invoke updateStatus with status CONNECTED, change\n-            // reason CONNECTION_OK and a null throwable.]\n             this.updateStatus(IotHubConnectionStatus.CONNECTED, IotHubConnectionStatusChangeReason.CONNECTION_OK, null);\n         }\n     }\n \n+    @Override\n+    public void onMultiplexedDeviceSessionEstablished(String connectionId, String deviceId)\n+    {\n+        if (connectionId.equals(this.iotHubTransportConnection.getConnectionId()))\n+        {\n+            log.debug(\"The device session in the multiplexed connection to the IoT Hub has been established for device {}\", deviceId);\n+            this.updateStatus(IotHubConnectionStatus.CONNECTED, IotHubConnectionStatusChangeReason.CONNECTION_OK, null, deviceId);\n+        }\n+    }\n+\n+    @Override\n+    public void onMultiplexedDeviceSessionLost(Throwable e, String connectionId, String deviceId)\n+    {\n+        if (connectionId.equals(this.iotHubTransportConnection.getConnectionId()))\n+        {\n+            log.debug(\"The device session in the multiplexed connection to the IoT Hub has been lost for device {}\", deviceId);\n+            if (e == null)\n+            {\n+                this.updateStatus(IotHubConnectionStatus.DISCONNECTED, IotHubConnectionStatusChangeReason.CLIENT_CLOSE, null, deviceId);\n+            }\n+            else\n+            {\n+                this.updateStatus(IotHubConnectionStatus.DISCONNECTED_RETRYING, exceptionToStatusChangeReason(e), e, deviceId);\n+\n+                if (e instanceof TransportException)\n+                {\n+                    this.reconnectDeviceSession((TransportException) e, deviceId);\n+                }\n+                else\n+                {\n+                    this.reconnectDeviceSession(new TransportException(e), deviceId);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setMultiplexingRetryPolicy(RetryPolicy retryPolicy)\n+    {\n+        this.multiplexingRetryPolicy = retryPolicy;\n+    }\n+\n     /**\n      * Establishes a communication channel with an IoT Hub. If a channel is\n      * already open, the function shall do nothing.\n      *\n      * If reconnection is occurring when this is called, this function shall block and wait for the reconnection\n      * to finish before trying to open the connection\n      *\n-     * @param deviceClientConfigs the configs for the devices to open\n-     *\n      * @throws DeviceClientException if a communication channel cannot be\n      * established.\n      */\n-    public void open(Collection<DeviceClientConfig> deviceClientConfigs) throws DeviceClientException\n+    public void open() throws DeviceClientException\n     {\n-        if ((deviceClientConfigs == null) || deviceClientConfigs.isEmpty())\n-        {\n-            //Codes_SRS_IOTHUBTRANSPORT_34_015: [If the provided list of configs is null or empty, this function shall\n-            // throw an IllegalArgumentException.]\n-            throw new IllegalArgumentException(\"deviceClientConfigs cannot be null or empty\");\n-        }\n-\n         if (this.connectionStatus == IotHubConnectionStatus.CONNECTED)", "originalCommit": "15ca17d7923d36f54663fbd8722769c315c45156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU4NjQ2Nw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521586467", "bodyText": "Not at this level, but it is at the MultiplexingClient level", "author": "timtay-microsoft", "createdAt": "2020-11-11T19:24:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxMjQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxMzE2NQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521013165", "bodyText": "q - is sas token renewal handled in some other layer?", "author": "abhipsaMisra", "createdAt": "2020-11-11T01:55:07Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -267,64 +291,91 @@ public void onConnectionEstablished(String connectionId)\n     {\n         if (connectionId.equals(this.iotHubTransportConnection.getConnectionId()))\n         {\n-            log.info(\"The connection to the IoT Hub has been established\");\n+            log.debug(\"The connection to the IoT Hub has been established\");\n \n-            //Codes_SRS_IOTHUBTRANSPORT_34_014: [If the provided connectionId is associated with the current connection, This function shall invoke updateStatus with status CONNECTED, change\n-            // reason CONNECTION_OK and a null throwable.]\n             this.updateStatus(IotHubConnectionStatus.CONNECTED, IotHubConnectionStatusChangeReason.CONNECTION_OK, null);\n         }\n     }\n \n+    @Override\n+    public void onMultiplexedDeviceSessionEstablished(String connectionId, String deviceId)\n+    {\n+        if (connectionId.equals(this.iotHubTransportConnection.getConnectionId()))\n+        {\n+            log.debug(\"The device session in the multiplexed connection to the IoT Hub has been established for device {}\", deviceId);\n+            this.updateStatus(IotHubConnectionStatus.CONNECTED, IotHubConnectionStatusChangeReason.CONNECTION_OK, null, deviceId);\n+        }\n+    }\n+\n+    @Override\n+    public void onMultiplexedDeviceSessionLost(Throwable e, String connectionId, String deviceId)\n+    {\n+        if (connectionId.equals(this.iotHubTransportConnection.getConnectionId()))\n+        {\n+            log.debug(\"The device session in the multiplexed connection to the IoT Hub has been lost for device {}\", deviceId);\n+            if (e == null)\n+            {\n+                this.updateStatus(IotHubConnectionStatus.DISCONNECTED, IotHubConnectionStatusChangeReason.CLIENT_CLOSE, null, deviceId);\n+            }\n+            else\n+            {\n+                this.updateStatus(IotHubConnectionStatus.DISCONNECTED_RETRYING, exceptionToStatusChangeReason(e), e, deviceId);\n+\n+                if (e instanceof TransportException)\n+                {\n+                    this.reconnectDeviceSession((TransportException) e, deviceId);\n+                }\n+                else\n+                {\n+                    this.reconnectDeviceSession(new TransportException(e), deviceId);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setMultiplexingRetryPolicy(RetryPolicy retryPolicy)\n+    {\n+        this.multiplexingRetryPolicy = retryPolicy;\n+    }\n+\n     /**\n      * Establishes a communication channel with an IoT Hub. If a channel is\n      * already open, the function shall do nothing.\n      *\n      * If reconnection is occurring when this is called, this function shall block and wait for the reconnection\n      * to finish before trying to open the connection\n      *\n-     * @param deviceClientConfigs the configs for the devices to open\n-     *\n      * @throws DeviceClientException if a communication channel cannot be\n      * established.\n      */\n-    public void open(Collection<DeviceClientConfig> deviceClientConfigs) throws DeviceClientException\n+    public void open() throws DeviceClientException\n     {\n-        if ((deviceClientConfigs == null) || deviceClientConfigs.isEmpty())\n-        {\n-            //Codes_SRS_IOTHUBTRANSPORT_34_015: [If the provided list of configs is null or empty, this function shall\n-            // throw an IllegalArgumentException.]\n-            throw new IllegalArgumentException(\"deviceClientConfigs cannot be null or empty\");\n-        }\n-\n         if (this.connectionStatus == IotHubConnectionStatus.CONNECTED)\n         {\n-            //Codes_SRS_IOTHUBTRANSPORT_34_017: [If the connection status of this object is CONNECTED, this function\n-            // shall do nothing.]\n             return;\n         }\n \n         if (this.connectionStatus == IotHubConnectionStatus.DISCONNECTED_RETRYING)\n         {\n-            //Codes_SRS_IOTHUBTRANSPORT_34_016: [If the connection status of this object is DISCONNECTED_RETRYING, this\n-            // function shall throw a TransportException.]\n             throw new TransportException(\"Open cannot be called while transport is reconnecting\");\n         }\n \n-        if (this.isSasTokenExpired())\n+        // The default config is only null when someone creates a multiplexing client and opens it before\n+        // registering any devices to it. No need to check for SAS token expiry if no devices are registered yet.\n+        if (this.getDefaultConfig() != null)\n         {\n-            //Codes_SRS_IOTHUBTRANSPORT_34_018: [If the saved SAS token has expired, this function shall throw a\n-            // SecurityException.]\n-            throw new SecurityException(\"Your sas token has expired\");\n+            if (this.isSasTokenExpired())\n+            {\n+                throw new SecurityException(\"Your sas token has expired\");", "originalCommit": "15ca17d7923d36f54663fbd8722769c315c45156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU4Njg3Nw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521586877", "bodyText": "To be honest, I don't know why this is here. It isn't very helpful, but I'll leave it alone just in case customers are catching this particular exception because we don't throw it anywhere else", "author": "timtay-microsoft", "createdAt": "2020-11-11T19:25:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxMzE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxNTI1Mg==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521015252", "bodyText": "q - would the user ever create an instance of IotHubTransport directly? The reason I ask is, we already have these checks in the higher layers, so I was wondering if this check was even required.", "author": "abhipsaMisra", "createdAt": "2020-11-11T01:58:06Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -606,17 +657,112 @@ public void registerConnectionStateCallback(IotHubConnectionStateCallback callba\n      * @param callback the callback to be called. Can be null if callbackContext is not null\n      * @param callbackContext a context to be passed to the callback. Can be {@code null}.\n      */\n-    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext, String deviceId)\n     {\n         if (callbackContext != null && callback == null)\n         {\n             //Codes_SRS_IOTHUBTRANSPORT_34_051: [If the provided callback is null but the context is not, this function shall throw an IllegalArgumentException.]\n             throw new IllegalArgumentException(\"Callback cannot be null if callback context is null\");\n         }\n \n-        //Codes_SRS_IOTHUBTRANSPORT_34_052: [This function shall save the provided callback and context.]\n-        this.connectionStatusChangeCallback = callback;\n-        this.connectionStatusChangeCallbackContext = callbackContext;\n+        if (callback == null)\n+        {\n+            this.connectionStatusChangeCallbacks.remove(deviceId);\n+            this.connectionStatusChangeCallbackContexts.remove(deviceId);\n+        }\n+        else\n+        {\n+            this.connectionStatusChangeCallbacks.put(deviceId, callback);\n+\n+            if (callbackContext != null)\n+            {\n+                // ConcurrentHashMaps don't support null values. If user provides null context,\n+                // then calls to connectionStatusChangeCallbackContexts.get(...) will return null which lets this layer still work as expected.\n+                this.connectionStatusChangeCallbackContexts.put(deviceId, callbackContext);\n+            }\n+\n+        }\n+    }\n+\n+    public void registerMultiplexingConnectionStateCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)\n+    {\n+        if (callback == null && callbackContext != null)\n+        {\n+            throw new IllegalArgumentException(\"Cannot have a null callback and a non-null context associated with it\");\n+        }\n+\n+        this.multiplexingStateCallback = callback;\n+        this.multiplexingStateCallbackContext = callbackContext;\n+    }\n+\n+    public void registerMultiplexedDeviceClient(List<DeviceClientConfig> configs) throws InterruptedException {\n+        if (getProtocol() != IotHubClientProtocol.AMQPS && getProtocol() != IotHubClientProtocol.AMQPS_WS)", "originalCommit": "15ca17d7923d36f54663fbd8722769c315c45156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU4ODEzNQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521588135", "bodyText": "Customer's wouldn't create this IotHubTransport object directly, no. These checks aren't something that a customer would hit, but it may be hit by a developer who does something wrong (like tries to multiplex over MQTT or something.)", "author": "timtay-microsoft", "createdAt": "2020-11-11T19:27:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxNTI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU4ODU3MA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521588570", "bodyText": "I can remove it if you'd prefer, but this error message is more helpful to a developer on our team than a class cast failure exception that they'd get when they try to open later.", "author": "timtay-microsoft", "createdAt": "2020-11-11T19:28:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxNTI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI3NTY1MQ==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r523275651", "bodyText": "No, you are right, it'll help against accidental misuse within the library.", "author": "abhipsaMisra", "createdAt": "2020-11-13T22:59:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxNTI1Mg=="}], "type": "inlineReview"}, {"oid": "78ed2325fe5fa867328803b0b83b09e6c4225bf6", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/78ed2325fe5fa867328803b0b83b09e6c4225bf6", "message": "feat(iot-dev): Add multiplexing client that supports device registration/unregistration during open connection\n\nTransportClient was our multiplexing client, but there was no way to add the ability to add/remove devices from an active connection without breaking the APIs in that class, so this deprecates the transport client in favor of a new MultiplexingClient.\n\nSignificant changes had to made to the IotHubTransport layer so that each multiplexed client could have its own connection state and so that each multiplexed client could have its own focused retry logic. Instead of closing the entire multiplexed connection every time a session drops, the transport layer can re-open individual device sessions", "committedDate": "2020-11-11T23:46:32Z", "type": "forcePushed"}, {"oid": "24ea744c50a21731079b72690abb981c43fb9f6c", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/24ea744c50a21731079b72690abb981c43fb9f6c", "message": "feat(iot-dev): Add multiplexing client that supports device registration/unregistration during open connection\n\nTransportClient was our multiplexing client, but there was no way to add the ability to add/remove devices from an active connection without breaking the APIs in that class, so this deprecates the transport client in favor of a new MultiplexingClient.\n\nSignificant changes had to made to the IotHubTransport layer so that each multiplexed client could have its own connection state and so that each multiplexed client could have its own focused retry logic. Instead of closing the entire multiplexed connection every time a session drops, the transport layer can re-open individual device sessions", "committedDate": "2020-11-12T00:21:20Z", "type": "commit"}, {"oid": "24ea744c50a21731079b72690abb981c43fb9f6c", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/24ea744c50a21731079b72690abb981c43fb9f6c", "message": "feat(iot-dev): Add multiplexing client that supports device registration/unregistration during open connection\n\nTransportClient was our multiplexing client, but there was no way to add the ability to add/remove devices from an active connection without breaking the APIs in that class, so this deprecates the transport client in favor of a new MultiplexingClient.\n\nSignificant changes had to made to the IotHubTransport layer so that each multiplexed client could have its own connection state and so that each multiplexed client could have its own focused retry logic. Instead of closing the entire multiplexed connection every time a session drops, the transport layer can re-open individual device sessions", "committedDate": "2020-11-12T00:21:20Z", "type": "forcePushed"}, {"oid": "d8b84f1a3e351158d192f93c169f04c404a136f2", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/d8b84f1a3e351158d192f93c169f04c404a136f2", "message": "fixup", "committedDate": "2020-11-12T18:58:53Z", "type": "forcePushed"}, {"oid": "b83f1727617198d1b8d0912d320be69258acdcbf", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/b83f1727617198d1b8d0912d320be69258acdcbf", "message": "try different emulator", "committedDate": "2020-11-12T19:58:28Z", "type": "commit"}, {"oid": "b83f1727617198d1b8d0912d320be69258acdcbf", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/b83f1727617198d1b8d0912d320be69258acdcbf", "message": "try different emulator", "committedDate": "2020-11-12T19:58:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ0MDIxMw==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r522440213", "bodyText": "For my understanding - What is the difference between status callback and mux status callback?", "author": "vinagesh", "createdAt": "2020-11-12T21:34:29Z", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -428,14 +435,17 @@ public boolean isEmpty()\n      */\n     public void registerConnectionStateCallback(IotHubConnectionStateCallback callback, Object callbackContext)\n     {\n-        /* Codes_SRS_DEVICE_IO_99_001: [The registerConnectionStateCallback shall register the callback with the transport.]*/\n         this.transport.registerConnectionStateCallback(callback, callbackContext);\n     }\n \n-    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback statusChangeCallback, Object callbackContext)\n+    void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback statusChangeCallback, Object callbackContext, String deviceId)\n+    {\n+        this.transport.registerConnectionStatusChangeCallback(statusChangeCallback, callbackContext, deviceId);\n+    }\n+\n+    void registerMultiplexingConnectionStateCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)\n     {\n-        //Codes_SRS_DEVICE_IO_34_020: [This function shall register the callback with the transport.]\n-        this.transport.registerConnectionStatusChangeCallback(statusChangeCallback, callbackContext);\n+        this.transport.registerMultiplexingConnectionStateCallback(callback, callbackContext);", "originalCommit": "b83f1727617198d1b8d0912d320be69258acdcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ3MjMxMA==", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r522472310", "bodyText": "Mux callback is fired for connection level events (like TCP connection drop) whereas device specific callbacks are fired for device specific events (like authentication failed to due the key in use being cycled, or if the device isn't registered)", "author": "timtay-microsoft", "createdAt": "2020-11-12T22:28:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ0MDIxMw=="}], "type": "inlineReview"}, {"oid": "1f3a38ad86495683ecd3aac611a6eae3b327b4d9", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/1f3a38ad86495683ecd3aac611a6eae3b327b4d9", "message": "Revert \"try different emulator\"\n\nThis reverts commit b83f1727617198d1b8d0912d320be69258acdcbf.", "committedDate": "2020-11-12T22:25:26Z", "type": "commit"}, {"oid": "d0b7b474114a725cd77c9aab95972dbb70418245", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/d0b7b474114a725cd77c9aab95972dbb70418245", "message": "ignore", "committedDate": "2020-11-12T22:26:23Z", "type": "commit"}, {"oid": "a3f1dd27c19dc4f3cbd003fc0d7fb71c6b7b54b6", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/a3f1dd27c19dc4f3cbd003fc0d7fb71c6b7b54b6", "message": "fixup", "committedDate": "2020-11-12T23:32:47Z", "type": "commit"}, {"oid": "8e93ec71f1bf73294131e41cffbd483174f64324", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/8e93ec71f1bf73294131e41cffbd483174f64324", "message": "fixup", "committedDate": "2020-11-13T00:31:02Z", "type": "commit"}, {"oid": "d4957b2c903ca6f431f7bef2fee41bd4cc49f1f1", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/d4957b2c903ca6f431f7bef2fee41bd4cc49f1f1", "message": "fixup", "committedDate": "2020-11-13T19:57:07Z", "type": "commit"}, {"oid": "348d726f94e960190e3795b4044c2cfccd1fec5d", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/348d726f94e960190e3795b4044c2cfccd1fec5d", "message": "fixup", "committedDate": "2020-11-13T20:27:58Z", "type": "commit"}, {"oid": "c35f8736bdfcac74e13f3c8b46e4ed5da49ad677", "url": "https://github.com/Azure/azure-iot-sdk-java/commit/c35f8736bdfcac74e13f3c8b46e4ed5da49ad677", "message": "fixup", "committedDate": "2020-11-14T00:00:43Z", "type": "commit"}]}