{"pr_number": 472, "pr_title": "Import all activity with summary", "pr_createdAt": "2020-10-24T19:47:03Z", "pr_url": "https://github.com/OpenTracksApp/OpenTracks/pull/472", "timeline": [{"oid": "8b0bf53f0b8fdddeafa0bc90785d53f126c5ef9a", "url": "https://github.com/OpenTracksApp/OpenTracks/commit/8b0bf53f0b8fdddeafa0bc90785d53f126c5ef9a", "message": "Import activity: handle screen rotation and twice click on back button for cancel importing process.", "committedDate": "2020-10-24T19:48:12Z", "type": "forcePushed"}, {"oid": "da86f05d53a7772a880b0d4878397bf08ae1678c", "url": "https://github.com/OpenTracksApp/OpenTracks/commit/da86f05d53a7772a880b0d4878397bf08ae1678c", "message": "Import activity: handle screen rotation and twice click on back button for cancel importing process.", "committedDate": "2020-10-24T19:59:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU2MjU5MA==", "url": "https://github.com/OpenTracksApp/OpenTracks/pull/472#discussion_r511562590", "bodyText": "Offtopic: have I already expressed my dislike of Javas checked Exceptions?\nThis long list could be omitted by wrapping it in a RuntimeException at line 144, but it is a matter of taste.", "author": "pstorch", "createdAt": "2020-10-25T08:06:37Z", "path": "src/main/java/de/dennisguse/opentracks/io/file/importer/AbstractFileTrackImporter.java", "diffHunk": "@@ -126,7 +127,7 @@ public void characters(char[] ch, int start, int length) {\n     }\n \n     @Override\n-    public Track.Id importFile(InputStream inputStream) {\n+    public Track.Id importFile(InputStream inputStream)  throws SAXException, SQLiteConstraintException, IOException, ParserConfigurationException {", "originalCommit": "da86f05d53a7772a880b0d4878397bf08ae1678c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU2NTAwNw==", "url": "https://github.com/OpenTracksApp/OpenTracks/pull/472#discussion_r511565007", "bodyText": "I don't like either.\nDo you mean something like this (in the line 144)?\nthrow new RuntimeException(e);\nThen, in ImportService, Can I know what exception was triggered? I need it so I know if the error was an already exists (SQLiteConstraintException) or a parser error (SAXException or ParserConfigurationException), so I can inform to the final user in ImportActivity.", "author": "rgmf", "createdAt": "2020-10-25T08:30:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU2MjU5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU2NzU0OQ==", "url": "https://github.com/OpenTracksApp/OpenTracks/pull/472#discussion_r511567549", "bodyText": "That I didn't check, so you need to know the type of exception where you catch it?\nYou can call getCause() to get the wrapped exception, but maybe this is not the ideal thing to do here.", "author": "pstorch", "createdAt": "2020-10-25T08:55:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU2MjU5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU3MDk3NQ==", "url": "https://github.com/OpenTracksApp/OpenTracks/pull/472#discussion_r511570975", "bodyText": "Yes, I need the type of exception to show to the user the cause of the errors in the ImportActivity (look the third screenshot). I do that because I think is really important the user knows the cause of the error (silent errors are unuseful ones). This way the user knows if it is OpenTracks's fault or its files are badly parsed, for example.", "author": "rgmf", "createdAt": "2020-10-25T09:28:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU2MjU5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU3MjM3Mg==", "url": "https://github.com/OpenTracksApp/OpenTracks/pull/472#discussion_r511572372", "bodyText": "A solution in the middle could be to only distinguish between the SQLiteConstraintException and the others. The first is because of duplicate UUID and the others represent errors reading the file.\nBut then you would need two catch clauses, 1 for SQLiteConstraintException which is just rethrown an one for the others to get wrapped into a RuntimeException.\nI suggest not spending too much time here now. When we refactor the UUID check, this might change as well.\nOr dirty: just declare Exception here and don't care. \ud83d\ude09", "author": "pstorch", "createdAt": "2020-10-25T09:40:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU2MjU5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU3Mjg5MQ==", "url": "https://github.com/OpenTracksApp/OpenTracks/pull/472#discussion_r511572891", "bodyText": "Thank you @pstorch\nI'll look at this.", "author": "rgmf", "createdAt": "2020-10-25T09:45:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU2MjU5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU3NzQ5MA==", "url": "https://github.com/OpenTracksApp/OpenTracks/pull/472#discussion_r511577490", "bodyText": "My two cents: don't pass a RuntimeException or even Exception.\nI have seen larger projects where in higher layers of the code have hard time to figure out what broke (just by reading the code).\nNowadays, I am big fan of just declaring a custom (so to say \"business\") exception for each case the implementation needs to distinguish and add the originally catched exception as cause.\nThen it is easy to understand which exceptions were actually expected and the internal implementation logic is not exposed.\nPS: don't declare exception as it is really hard to understand what potential issues might arise.\nPPS: The last months I spent a lot of time refactoring and saw things like this:\ntry {\n Object a = // call to some internal object\n return a;\n} catch (Exception e) {\n  return null;\n}\n\nAnd we are still working on such things, as it takes quite some time to figure out why it is working at all (and if the catch is actually needed etc.). And many cases the exception originates from somewhere in some library and it was passed to some higher layer and then somebody added a try-catch there.\nNot too much fun...", "author": "dennisguse", "createdAt": "2020-10-25T10:29:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU2MjU5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU4MzAzMQ==", "url": "https://github.com/OpenTracksApp/OpenTracks/pull/472#discussion_r511583031", "bodyText": "I feel your pain from larger codebases. Saw all kinds of strange exception handling.\nI would suggest to derive the BusinessException from RuntimeException, so you don't have to declare it everywhere only catch where you know what to do.", "author": "pstorch", "createdAt": "2020-10-25T11:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU2MjU5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTYwNjA0Mw==", "url": "https://github.com/OpenTracksApp/OpenTracks/pull/472#discussion_r511606043", "bodyText": "In my last commit I've added custom exceptions to distinguish the origin of the error's cause.\nI don't know if I've understanded you, @dennisguse and @pstorch is that what you talked about to do? It's something I've never done...\nDon't be hurry...", "author": "rgmf", "createdAt": "2020-10-25T14:43:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU2MjU5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTYxNjY0Mg==", "url": "https://github.com/OpenTracksApp/OpenTracks/pull/472#discussion_r511616642", "bodyText": "Put the whole Exception into the constructor not only the message. Then later you can call getCause() to get the original exception including Stack trace", "author": "pstorch", "createdAt": "2020-10-25T16:11:30Z", "path": "src/main/java/de/dennisguse/opentracks/io/file/importer/AbstractFileTrackImporter.java", "diffHunk": "@@ -127,21 +126,26 @@ public void characters(char[] ch, int start, int length) {\n     }\n \n     @Override\n-    public Track.Id importFile(InputStream inputStream)  throws SAXException, SQLiteConstraintException, IOException, ParserConfigurationException {\n+    public Track.Id importFile(InputStream inputStream) throws ImportParserException, ImportAlreadyExistsException {\n         try {\n             SAXParser saxParser = SAXParserFactory.newInstance().newSAXParser();\n             long start = System.currentTimeMillis();\n \n             saxParser.parse(inputStream, this);\n             Log.d(TAG, \"Total import time: \" + (System.currentTimeMillis() - start) + \"ms\");\n             if (trackIds.size() != 1) {\n-                throw new MultiTracksImportException();\n+                // TODO Multi track is not supported yet.\n+                throw new ImportParserException(\"Multi track not supported\");\n             }\n             return trackIds.get(0);\n-        } catch (MultiTracksImportException | IOException | SAXException | ParserConfigurationException | SQLiteConstraintException e) {\n+        } catch (IOException | SAXException | ParserConfigurationException e) {\n             Log.e(TAG, \"Unable to import file\", e);\n             cleanImport();\n-            throw e;\n+            throw new ImportParserException(e.getMessage());", "originalCommit": "0c9a748d7803f5bd46f7b990e7485c462f2508ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTYyNDQxMg==", "url": "https://github.com/OpenTracksApp/OpenTracks/pull/472#discussion_r511624412", "bodyText": "Okay \ud83d\udc4d", "author": "rgmf", "createdAt": "2020-10-25T17:19:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTYxNjY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTYxNzQ3Ng==", "url": "https://github.com/OpenTracksApp/OpenTracks/pull/472#discussion_r511617476", "bodyText": "Throws declaration of the two new Exceptions is not necessary, because they are unchecked Exceptions.", "author": "pstorch", "createdAt": "2020-10-25T16:18:38Z", "path": "src/main/java/de/dennisguse/opentracks/io/file/importer/KmzTrackImporter.java", "diffHunk": "@@ -71,7 +66,7 @@ public KmzTrackImporter(Context context, Uri uriFile) {\n     }\n \n     @Override\n-    public Track.Id importFile(InputStream inputStream) throws SAXException, SQLiteConstraintException, IOException, ParserConfigurationException {\n+    public Track.Id importFile(InputStream inputStream) throws ImportParserException, ImportAlreadyExistsException {", "originalCommit": "0c9a748d7803f5bd46f7b990e7485c462f2508ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTYyNDQ4MA==", "url": "https://github.com/OpenTracksApp/OpenTracks/pull/472#discussion_r511624480", "bodyText": "Ops!!! Yes, of course.", "author": "rgmf", "createdAt": "2020-10-25T17:20:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTYxNzQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2Njg5Nw==", "url": "https://github.com/OpenTracksApp/OpenTracks/pull/472#discussion_r512166897", "bodyText": "is it sufficient to pass parameters via the constructor?\nIf the activity will be restored all fragments should be created from a bundle.\nLike this:\n\n    public static void showDialog(FragmentManager fragmentManager, Uri documentFileUri, boolean isDirectory) {\n        Bundle bundle = new Bundle();\n        bundle.putParcelable(EXTRA_DATA_URI_KEY, documentFileUri);\n        bundle.putBoolean(EXTRA_IS_TREE_KEY, isDirectory);\n\n        ImportProgressDialogFragment dialogFragment = new ImportProgressDialogFragment();\n        dialogFragment.setArguments(bundle);\n        dialogFragment.setRetainInstance(true);\n        dialogFragment.show(fragmentManager, IMPORT_DIALOG_TAG);\n    }", "author": "dennisguse", "createdAt": "2020-10-26T18:07:19Z", "path": "src/main/java/de/dennisguse/opentracks/io/file/ErrorListDialog.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package de.dennisguse.opentracks.io.file;\n+\n+import android.app.AlertDialog;\n+import android.app.Dialog;\n+import android.os.Bundle;\n+\n+import androidx.fragment.app.DialogFragment;\n+\n+import java.util.List;\n+\n+import de.dennisguse.opentracks.R;\n+\n+public class ErrorListDialog extends DialogFragment {\n+\n+    public static final String TAG = ErrorListDialog.class.getSimpleName();\n+\n+    private List<String> trackErrors;\n+    private String title;\n+\n+    public ErrorListDialog(String title, List<String> trackErrors) {", "originalCommit": "fdd0d45fae1a19409dc7cc74d59a037de3a0cc0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk1MTQyMQ==", "url": "https://github.com/OpenTracksApp/OpenTracks/pull/472#discussion_r512951421", "bodyText": "You're right. What a screw up! I didn't test it \ud83d\ude48", "author": "rgmf", "createdAt": "2020-10-27T18:59:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2Njg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2OTExOA==", "url": "https://github.com/OpenTracksApp/OpenTracks/pull/472#discussion_r512169118", "bodyText": "Initialize here.", "author": "dennisguse", "createdAt": "2020-10-26T18:10:55Z", "path": "src/main/java/de/dennisguse/opentracks/io/file/importer/ImportActivity.java", "diffHunk": "@@ -16,62 +16,255 @@\n \n package de.dennisguse.opentracks.io.file.importer;\n \n-import android.content.ClipData;\n+import android.net.Uri;\n import android.os.Bundle;\n+import android.os.Handler;\n+import android.view.View;\n+import android.widget.Button;\n+import android.widget.ImageView;\n+import android.widget.ProgressBar;\n+import android.widget.TextView;\n+import android.widget.Toast;\n \n import androidx.annotation.NonNull;\n+import androidx.appcompat.widget.Toolbar;\n+import androidx.documentfile.provider.DocumentFile;\n import androidx.fragment.app.FragmentActivity;\n \n-import de.dennisguse.opentracks.fragments.ImportFinishedDialogFragment;\n-import de.dennisguse.opentracks.fragments.ImportProgressDialogFragment;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import de.dennisguse.opentracks.R;\n+import de.dennisguse.opentracks.util.FileUtils;\n+import de.dennisguse.opentracks.util.IoUtils;\n+import de.dennisguse.opentracks.io.file.ErrorListDialog;\n \n /**\n  * An activity to import files from the external storage.\n  *\n  * @author Rodrigo Damazio\n  */\n-public class ImportActivity extends FragmentActivity implements ImportProgressDialogFragment.DismissCallback, ImportFinishedDialogFragment.DismissCallback {\n+public class ImportActivity extends FragmentActivity implements ImportServiceResultReceiver.Receiver {\n \n     private static final String TAG = ImportActivity.class.getSimpleName();\n \n     public static final String EXTRA_DIRECTORY_URI_KEY = \"directory_uri\";\n \n-    private static final String BUNDLE_ACTIVITY_RECREATED = \"activity_recreated\";\n+    private static final String BUNDLE_TOOLBAR_TITLE = \"toolbar_title\";\n+    private static final String BUNDLE_URI_LIST = \"uri_list\";\n+    private static final String BUNDLE_DOCUMENT_URI = \"document_uri\";\n+    private static final String BUNDLE_IS_DIRECTORY = \"is_directory\";\n+    private static final String BUNDLE_FILE_IMPORT_TOTAL_COUNT = \"file_import_total_count\";\n+    private static final String BUNDLE_FILE_IMPORT_SUCCESS_COUNT = \"file_import_success_count\";\n+    private static final String BUNDLE_FILE_IMPORT_ERROR_COUNT = \"file_import_error_count\";\n+    private static final String BUNDLE_FILE_ALREADY_EXISTS_COUNT = \"file_import_alreayd_exists_count\";\n+    private static final String BUNDLE_FILE_ERRORS = \"files_errors\";\n+\n+    private ImportServiceResultReceiver resultReceiver;\n+\n+    private int fileImportTotalCount;\n+    private int fileImportSuccessCount;\n+    private int fileAlreadyExistsCount;\n+    private int fileImportErrorCount;\n+\n+    private TextView viewTotal;\n+    private TextView viewDone;\n+    private TextView viewSummary;\n+    private ProgressBar viewProgressBar;\n+    private ImageView viewAlertIcon;\n+    private TextView viewAlertMsg;\n+    private Button viewLeftButton;\n+    private Button viewRightButton;\n+\n+    boolean doubleBackToCancel = false;\n+\n+    private Uri documentUri;\n+    private boolean isDirectory;\n+    private List<DocumentFile> fileList;", "originalCommit": "fdd0d45fae1a19409dc7cc74d59a037de3a0cc0c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE3MDM4OA==", "url": "https://github.com/OpenTracksApp/OpenTracks/pull/472#discussion_r512170388", "bodyText": "rename to count?", "author": "dennisguse", "createdAt": "2020-10-26T18:13:10Z", "path": "src/main/java/de/dennisguse/opentracks/io/file/importer/ImportActivity.java", "diffHunk": "@@ -16,62 +16,255 @@\n \n package de.dennisguse.opentracks.io.file.importer;\n \n-import android.content.ClipData;\n+import android.net.Uri;\n import android.os.Bundle;\n+import android.os.Handler;\n+import android.view.View;\n+import android.widget.Button;\n+import android.widget.ImageView;\n+import android.widget.ProgressBar;\n+import android.widget.TextView;\n+import android.widget.Toast;\n \n import androidx.annotation.NonNull;\n+import androidx.appcompat.widget.Toolbar;\n+import androidx.documentfile.provider.DocumentFile;\n import androidx.fragment.app.FragmentActivity;\n \n-import de.dennisguse.opentracks.fragments.ImportFinishedDialogFragment;\n-import de.dennisguse.opentracks.fragments.ImportProgressDialogFragment;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import de.dennisguse.opentracks.R;\n+import de.dennisguse.opentracks.util.FileUtils;\n+import de.dennisguse.opentracks.util.IoUtils;\n+import de.dennisguse.opentracks.io.file.ErrorListDialog;\n \n /**\n  * An activity to import files from the external storage.\n  *\n  * @author Rodrigo Damazio\n  */\n-public class ImportActivity extends FragmentActivity implements ImportProgressDialogFragment.DismissCallback, ImportFinishedDialogFragment.DismissCallback {\n+public class ImportActivity extends FragmentActivity implements ImportServiceResultReceiver.Receiver {\n \n     private static final String TAG = ImportActivity.class.getSimpleName();\n \n     public static final String EXTRA_DIRECTORY_URI_KEY = \"directory_uri\";\n \n-    private static final String BUNDLE_ACTIVITY_RECREATED = \"activity_recreated\";\n+    private static final String BUNDLE_TOOLBAR_TITLE = \"toolbar_title\";\n+    private static final String BUNDLE_URI_LIST = \"uri_list\";\n+    private static final String BUNDLE_DOCUMENT_URI = \"document_uri\";\n+    private static final String BUNDLE_IS_DIRECTORY = \"is_directory\";\n+    private static final String BUNDLE_FILE_IMPORT_TOTAL_COUNT = \"file_import_total_count\";\n+    private static final String BUNDLE_FILE_IMPORT_SUCCESS_COUNT = \"file_import_success_count\";\n+    private static final String BUNDLE_FILE_IMPORT_ERROR_COUNT = \"file_import_error_count\";\n+    private static final String BUNDLE_FILE_ALREADY_EXISTS_COUNT = \"file_import_alreayd_exists_count\";\n+    private static final String BUNDLE_FILE_ERRORS = \"files_errors\";\n+\n+    private ImportServiceResultReceiver resultReceiver;\n+\n+    private int fileImportTotalCount;\n+    private int fileImportSuccessCount;\n+    private int fileAlreadyExistsCount;\n+    private int fileImportErrorCount;\n+\n+    private TextView viewTotal;\n+    private TextView viewDone;\n+    private TextView viewSummary;\n+    private ProgressBar viewProgressBar;\n+    private ImageView viewAlertIcon;\n+    private TextView viewAlertMsg;\n+    private Button viewLeftButton;\n+    private Button viewRightButton;\n+\n+    boolean doubleBackToCancel = false;\n+\n+    private Uri documentUri;\n+    private boolean isDirectory;\n+    private List<DocumentFile> fileList;\n+    private String toolbarTitle;\n+\n+    private ArrayList<String> fileErrors = new ArrayList<>();\n \n     @Override\n     public void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n+        setContentView(R.layout.import_progress_activity);\n+\n+        Toolbar toolbar = findViewById(R.id.toolbar);\n+\n+        viewTotal = findViewById(R.id.import_progress_total);\n+        viewDone = findViewById(R.id.import_progress_done);\n+        viewSummary = findViewById(R.id.import_progress_summary);\n+        viewProgressBar = findViewById(R.id.import_progress_bar);\n+        viewAlertIcon = findViewById(R.id.import_progress_alert_icon);\n+        viewAlertMsg = findViewById(R.id.import_progress_alert_msg);\n+        viewLeftButton = findViewById(R.id.import_progress_left_button);\n+        viewRightButton = findViewById(R.id.import_progress_right_button);\n \n-        if (savedInstanceState == null || !savedInstanceState.getBoolean(BUNDLE_ACTIVITY_RECREATED, false)) {\n+        resultReceiver = new ImportServiceResultReceiver(new Handler());\n+        resultReceiver.setReceiver(this);\n+\n+        if (savedInstanceState == null) {\n             if (getIntent().getData() != null) {\n-                ImportProgressDialogFragment.showDialog(getSupportFragmentManager(), getIntent().getData(), false);\n+                documentUri = getIntent().getData();\n+                isDirectory = false;\n+                fileImportTotalCount = 1;\n             } else if (getIntent().getClipData() != null && getIntent().getClipData().getItemCount() > 0) {\n-                ImportProgressDialogFragment.showDialog(getSupportFragmentManager(), getIntent().getClipData().getItemAt(0).getUri(), false);\n+                documentUri = getIntent().getClipData().getItemAt(0).getUri();\n+                isDirectory = false;\n+                fileImportTotalCount = 1;\n             } else {\n                 // Started from DirectoryChooserActivity\n-                ImportProgressDialogFragment.showDialog(getSupportFragmentManager(), getIntent().getParcelableExtra(EXTRA_DIRECTORY_URI_KEY), true);\n+                documentUri = getIntent().getParcelableExtra(EXTRA_DIRECTORY_URI_KEY);\n+                isDirectory = true;\n+                fileImportTotalCount = IoUtils.getAllFiles(this, DocumentFile.fromTreeUri(this, documentUri).getUri()).size();\n+            }\n+\n+            final DocumentFile documentFile = isDirectory ? DocumentFile.fromTreeUri(this, documentUri) : DocumentFile.fromSingleUri(this, documentUri);\n+            toolbarTitle = getString(R.string.import_progress_message, documentFile.getName());\n+            fileList = FileUtils.getFiles(documentFile);\n+        } else {\n+            documentUri = savedInstanceState.getParcelable(BUNDLE_DOCUMENT_URI);\n+            toolbarTitle = savedInstanceState.getString(BUNDLE_TOOLBAR_TITLE);\n+            isDirectory = savedInstanceState.getBoolean(BUNDLE_IS_DIRECTORY);\n+            fileImportTotalCount = savedInstanceState.getInt(BUNDLE_FILE_IMPORT_TOTAL_COUNT);\n+            fileImportSuccessCount = savedInstanceState.getInt(BUNDLE_FILE_IMPORT_SUCCESS_COUNT);\n+            fileImportErrorCount = savedInstanceState.getInt(BUNDLE_FILE_IMPORT_ERROR_COUNT);\n+            fileAlreadyExistsCount = savedInstanceState.getInt(BUNDLE_FILE_ALREADY_EXISTS_COUNT);\n+            fileErrors = savedInstanceState.getStringArrayList(BUNDLE_FILE_ERRORS);\n+            ArrayList<String> urisString = savedInstanceState.getStringArrayList(BUNDLE_URI_LIST);\n+            fileList = new ArrayList<>();\n+            for (String uriString : urisString) {\n+                fileList.add(DocumentFile.fromSingleUri(this, Uri.parse(uriString)));\n             }\n         }\n+\n+        toolbar.setTitle(toolbarTitle);\n+        setProgress();\n+        initImport();\n+    }\n+\n+    @Override\n+    protected void onDestroy() {\n+        super.onDestroy();\n+        fileList.clear();\n     }\n \n     @Override\n     protected void onSaveInstanceState(@NonNull Bundle outState) {\n         super.onSaveInstanceState(outState);\n-        outState.putBoolean(BUNDLE_ACTIVITY_RECREATED, true);\n+        outState.putParcelable(BUNDLE_DOCUMENT_URI, documentUri);\n+        outState.putBoolean(BUNDLE_IS_DIRECTORY, isDirectory);\n+        outState.putInt(BUNDLE_FILE_IMPORT_TOTAL_COUNT, fileImportTotalCount);\n+        outState.putInt(BUNDLE_FILE_IMPORT_SUCCESS_COUNT, fileImportSuccessCount);\n+        outState.putInt(BUNDLE_FILE_IMPORT_ERROR_COUNT, fileImportErrorCount);\n+        outState.putInt(BUNDLE_FILE_ALREADY_EXISTS_COUNT, fileAlreadyExistsCount);\n+        outState.putString(BUNDLE_TOOLBAR_TITLE, toolbarTitle);\n+        outState.putStringArrayList(BUNDLE_FILE_ERRORS, fileErrors);\n+        ArrayList<String> urisString = new ArrayList<>();\n+        for (DocumentFile df : fileList) {\n+            urisString.add(df.getUri().toString());\n+        }\n+        outState.putStringArrayList(BUNDLE_URI_LIST, urisString);\n     }\n \n     @Override\n-    public void onImportCanceled(String directoryDisplayName, int successCount, int fileCount) {\n-        onImportFinished(directoryDisplayName, successCount, fileCount);\n+    public void onBackPressed() {\n+        if (doubleBackToCancel || getTotalDone() == fileImportTotalCount) {\n+            super.onBackPressed();\n+            return;\n+        }\n+\n+        this.doubleBackToCancel = true;\n+        Toast.makeText(this, getString(R.string.generic_click_twice_cancel), Toast.LENGTH_SHORT).show();\n+\n+        new Handler().postDelayed(() -> doubleBackToCancel=false, 2000);\n     }\n \n     @Override\n-    public void onImportFinished(final String directoryDisplayName, final int successCount, final int fileCount) {\n-        runOnUiThread(() -> ImportFinishedDialogFragment.showDialog(getSupportFragmentManager(), directoryDisplayName, successCount, fileCount));\n+    public void onReceiveResult(int resultCode, Bundle resultData) {\n+        if (resultData == null) {\n+            throw new RuntimeException(TAG + \": onReceiveResult resultData NULL\");\n+        }\n+\n+        String fileName = resultData.getString(ImportServiceResultReceiver.RESULT_EXTRA_FILENAME);\n+        String message = resultData.getString(ImportServiceResultReceiver.RESULT_EXTRA_MESSAGE);\n+\n+        switch (resultCode) {\n+            case ImportServiceResultReceiver.RESULT_CODE_ERROR:\n+                fileImportErrorCount++;\n+                fileErrors.add(getString(R.string.import_error_info, fileName, message));\n+                break;\n+            case ImportServiceResultReceiver.RESULT_CODE_IMPORTED:\n+                fileImportSuccessCount++;\n+                break;\n+            case ImportServiceResultReceiver.RESULT_CODE_ALREADY_EXISTS:\n+                fileAlreadyExistsCount++;\n+                break;\n+            default:\n+                throw new RuntimeException(TAG + \": import service result code invalid: \" + resultCode);\n+        }\n+\n+        onImportCompleted();\n     }\n \n-    @Override\n-    public void onDismissed() {\n-        finish();\n+    private void initImport() {\n+        if (getTotalDone() == fileImportTotalCount) {\n+            onImportCompleted();\n+        } else {\n+            importNextFile();\n+        }\n+    }\n+\n+    private void importNextFile() {\n+        int i = getTotalDone();", "originalCommit": "fdd0d45fae1a19409dc7cc74d59a037de3a0cc0c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE3MTI4OQ==", "url": "https://github.com/OpenTracksApp/OpenTracks/pull/472#discussion_r512171289", "bodyText": "Can we change to pass a DocumentFile instead of Uri?", "author": "dennisguse", "createdAt": "2020-10-26T18:14:41Z", "path": "src/main/java/de/dennisguse/opentracks/io/file/importer/ImportService.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package de.dennisguse.opentracks.io.file.importer;\n+\n+import android.app.job.JobService;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.net.Uri;\n+import android.os.Bundle;\n+import android.os.ResultReceiver;\n+import android.util.Log;\n+\n+import androidx.annotation.NonNull;\n+import androidx.core.app.JobIntentService;\n+import androidx.documentfile.provider.DocumentFile;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import de.dennisguse.opentracks.R;\n+import de.dennisguse.opentracks.content.data.Track;\n+import de.dennisguse.opentracks.io.file.TrackFileFormat;\n+import de.dennisguse.opentracks.util.FileUtils;\n+\n+public class ImportService extends JobIntentService {\n+\n+    private static final String TAG = ImportService.class.getSimpleName();\n+\n+    private static final int JOB_ID = 2;\n+\n+    private static final String EXTRA_RECEIVER = \"extra_receiver\";\n+    private static final String EXTRA_URI = \"extra_uri\";\n+\n+    private ResultReceiver resultReceiver;\n+\n+    public static void enqueue(Context context, ImportServiceResultReceiver receiver, Uri uri) {", "originalCommit": "fdd0d45fae1a19409dc7cc74d59a037de3a0cc0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk1MzUzMA==", "url": "https://github.com/OpenTracksApp/OpenTracks/pull/472#discussion_r512953530", "bodyText": "No, we can't. DocumentFile doesn't implement Parcelable so we cannot pass it through Extra.", "author": "rgmf", "createdAt": "2020-10-27T19:03:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE3MTI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE3MjEyMw==", "url": "https://github.com/OpenTracksApp/OpenTracks/pull/472#discussion_r512172123", "bodyText": "Why not pass in the constructor?\nIt should never be null right?", "author": "dennisguse", "createdAt": "2020-10-26T18:16:04Z", "path": "src/main/java/de/dennisguse/opentracks/io/file/importer/ImportServiceResultReceiver.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package de.dennisguse.opentracks.io.file.importer;\n+\n+import android.os.Bundle;\n+import android.os.Handler;\n+import android.os.ResultReceiver;\n+\n+/**\n+ * Create a new ResultReceive to receive results.\n+ * Your {@link #onReceiveResult} method will be called from the thread running <var>handler</var> if given, or from an arbitrary thread if null.\n+ */\n+public class ImportServiceResultReceiver extends ResultReceiver {\n+\n+    public static final int RESULT_CODE_ERROR = 0;\n+    public static final int RESULT_CODE_IMPORTED = 1;\n+    public static final int RESULT_CODE_ALREADY_EXISTS = 2;\n+\n+    public static final String RESULT_EXTRA_TRACK_ID = \"result_track_id\";\n+    public static final String RESULT_EXTRA_FILENAME = \"result_extra_filename\";\n+    public static final String RESULT_EXTRA_MESSAGE = \"result_extra_message\";\n+\n+    private Receiver receiver;\n+\n+    public ImportServiceResultReceiver(Handler handler) {\n+        super(handler);\n+    }\n+\n+    @Override\n+    protected void onReceiveResult(int resultCode, Bundle resultData) {\n+        if (receiver != null) {\n+            receiver.onReceiveResult(resultCode, resultData);\n+        }\n+    }\n+\n+    public void setReceiver(Receiver receiver) {", "originalCommit": "fdd0d45fae1a19409dc7cc74d59a037de3a0cc0c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f101f4ee12a780ed6dac1d3d29f4a104785a2c3c", "url": "https://github.com/OpenTracksApp/OpenTracks/commit/f101f4ee12a780ed6dac1d3d29f4a104785a2c3c", "message": "Activity with progress and summary for import all option. Fixes #471.\nErrorListDialog shared by ExportActivity and ImportActivity.", "committedDate": "2020-10-31T19:22:34Z", "type": "commit"}, {"oid": "d4ced73c0aa23cb6cd909bc833a0fe5b6bc1295d", "url": "https://github.com/OpenTracksApp/OpenTracks/commit/d4ced73c0aa23cb6cd909bc833a0fe5b6bc1295d", "message": "Small cleanups and improvements code.", "committedDate": "2020-10-31T19:22:34Z", "type": "commit"}, {"oid": "d4ced73c0aa23cb6cd909bc833a0fe5b6bc1295d", "url": "https://github.com/OpenTracksApp/OpenTracks/commit/d4ced73c0aa23cb6cd909bc833a0fe5b6bc1295d", "message": "Small cleanups and improvements code.", "committedDate": "2020-10-31T19:22:34Z", "type": "forcePushed"}]}