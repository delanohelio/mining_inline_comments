{"pr_number": 5137, "pr_title": "[Productionizing GetSortedColumns] Part 1: Row Column Range Traps", "pr_createdAt": "2020-11-27T19:57:17Z", "pr_url": "https://github.com/palantir/atlasdb/pull/5137", "timeline": [{"oid": "5dfce3f810b81801ec48d0d97c2eecdc4c9a386a", "url": "https://github.com/palantir/atlasdb/commit/5dfce3f810b81801ec48d0d97c2eecdc4c9a386a", "message": "broken test with iterator", "committedDate": "2020-11-27T19:03:55Z", "type": "commit"}, {"oid": "7c80cb4eae8487cf4e8bd39e8a97b979f2e7d679", "url": "https://github.com/palantir/atlasdb/commit/7c80cb4eae8487cf4e8bd39e8a97b979f2e7d679", "message": "fixes part 1", "committedDate": "2020-11-27T19:14:40Z", "type": "commit"}, {"oid": "f08db9dcde985cc439c135474ba9250d565d7225", "url": "https://github.com/palantir/atlasdb/commit/f08db9dcde985cc439c135474ba9250d565d7225", "message": "bv version test", "committedDate": "2020-11-27T19:21:53Z", "type": "commit"}, {"oid": "59b098efa895909f76699a6048c3e694e8bf287d", "url": "https://github.com/palantir/atlasdb/commit/59b098efa895909f76699a6048c3e694e8bf287d", "message": "SnapTrans", "committedDate": "2020-11-27T19:52:45Z", "type": "commit"}, {"oid": "3c7329cda68904448cc8c5eca426d0e1096ed3da", "url": "https://github.com/palantir/atlasdb/commit/3c7329cda68904448cc8c5eca426d0e1096ed3da", "message": "updates", "committedDate": "2020-11-27T20:06:24Z", "type": "commit"}, {"oid": "b4c9599a4908217a2ed82a12ab979befbcb3a8be", "url": "https://github.com/palantir/atlasdb/commit/b4c9599a4908217a2ed82a12ab979befbcb3a8be", "message": "Add generated changelog entries", "committedDate": "2020-11-27T20:06:24Z", "type": "commit"}, {"oid": "ac47a2047503aea6c05e286ff577a44f0fd7e4d3", "url": "https://github.com/palantir/atlasdb/commit/ac47a2047503aea6c05e286ff577a44f0fd7e4d3", "message": "fixes", "committedDate": "2020-11-30T17:28:54Z", "type": "commit"}, {"oid": "0ad34a6bec3b7da2e85d435614fd3b0c10e086e3", "url": "https://github.com/palantir/atlasdb/commit/0ad34a6bec3b7da2e85d435614fd3b0c10e086e3", "message": "argha2932j h24031", "committedDate": "2020-11-30T20:22:34Z", "type": "commit"}, {"oid": "8499d5998c787615b8ed82b70a5f5cb25f84c1a7", "url": "https://github.com/palantir/atlasdb/commit/8499d5998c787615b8ed82b70a5f5cb25f84c1a7", "message": "unsignedbytes", "committedDate": "2020-11-30T20:37:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE3OTg0OA==", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r539179848", "bodyText": "[Sanity check]: This collection is consistent with the one in SnapshotTransaction after this PR. I need to validate that this is equivalent before, too.\nIs there a way that we can force this coupling? I.e. what if someone in the future changes one of the collectors and not the other?", "author": "Jolyon-S", "createdAt": "2020-12-09T10:16:31Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SerializableTransaction.java", "diffHunk": "@@ -191,23 +193,9 @@ public SerializableTransaction(\n             TableReference tableRef, Iterable<byte[]> rows, BatchColumnRangeSelection columnRangeSelection) {\n         Map<byte[], BatchingVisitable<Map.Entry<Cell, byte[]>>> ret =\n                 super.getRowsColumnRange(tableRef, rows, columnRangeSelection);\n-        return Maps.transformEntries(ret, (row, visitable) -> new BatchingVisitable<Map.Entry<Cell, byte[]>>() {\n-            @Override\n-            public <K extends Exception> boolean batchAccept(\n-                    int batchSize, AbortingVisitor<? super List<Map.Entry<Cell, byte[]>>, K> visitor) throws K {\n-                boolean hitEnd = visitable.batchAccept(batchSize, items -> {\n-                    if (items.size() < batchSize) {\n-                        reachedEndOfColumnRange(tableRef, row, columnRangeSelection);\n-                    }\n-                    markRowColumnRangeRead(tableRef, row, columnRangeSelection, items);\n-                    return visitor.visit(items);\n-                });\n-                if (hitEnd) {\n-                    reachedEndOfColumnRange(tableRef, row, columnRangeSelection);\n-                }\n-                return hitEnd;\n-            }\n-        });\n+        return KeyedStream.stream(ret)\n+                .map((row, visitable) -> wrapWithColumnRangeChecking(tableRef, columnRangeSelection, row, visitable))\n+                .collectTo(() -> new TreeMap<>(UnsignedBytes.lexicographicalComparator()));", "originalCommit": "8499d5998c787615b8ed82b70a5f5cb25f84c1a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI4NTQ5OQ==", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r542285499", "bodyText": "This is equivalent before (see javadoc of Maps#transformValues: it takes on properties of the previous map).\nThat said, in general, it is not wrong for these to be different types, as long as they satisfy the properties we need (here, mainly that a map can be looked up by value of byte[]) so they don't need to be coupled. The tests should fail pretty quickly if that property is broken (since they do perform lookups).", "author": "jeremyk-91", "createdAt": "2020-12-14T10:44:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE3OTg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI5MTQxOA==", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r542291418", "bodyText": "I'm convinced this is the same as before, but my concern is that someone depends on this being ordered (i.e. not just a lookup but also an ordering), and that this could be broken in a later PR.\nOther comments make me less concerned about this.", "author": "Jolyon-S", "createdAt": "2020-12-14T10:53:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE3OTg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwMzc0Nw==", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r542303747", "bodyText": "I'd be fine with breaking someone on that - the API documentation (see Transaction) does not guarantee that behaviour.", "author": "jeremyk-91", "createdAt": "2020-12-14T11:13:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE3OTg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwNDExMA==", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r542304110", "bodyText": "If we wanted to guarantee that we'd probably return SortedMap as interface type as well", "author": "jeremyk-91", "createdAt": "2020-12-14T11:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE3OTg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4MTcyMQ==", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r539181721", "bodyText": "[Sanity check]: This code is semantically the same as the previous code, right? As far as I can tell, the main change in this class is the use of KeyedStream over Maps.transformEntries?", "author": "Jolyon-S", "createdAt": "2020-12-09T10:19:10Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SerializableTransaction.java", "diffHunk": "@@ -865,6 +827,66 @@ private void handleTransactionConflict(TableReference tableRef) {\n                 tableRef, getTimestamp(), System.currentTimeMillis() - timeCreated);\n     }\n \n+    private BatchingVisitable<Map.Entry<Cell, byte[]>> wrapWithColumnRangeChecking(", "originalCommit": "8499d5998c787615b8ed82b70a5f5cb25f84c1a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI1NzMzNg==", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r542257336", "bodyText": "Yep, that's right.", "author": "jeremyk-91", "createdAt": "2020-12-14T10:02:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4MTcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4Mzg5OA==", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r539183898", "bodyText": "Ah, so the ordering actually comes from getRowsColumnRangeIterator. As mentioned elsewhere, is there any way we can be defensive and make sure that we always use a sorted collector? I guess tests would fail if you just used any random collector?", "author": "Jolyon-S", "createdAt": "2020-12-09T10:22:21Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java", "diffHunk": "@@ -381,9 +383,9 @@ public void markTableInvolved(TableReference tableRef) {\n     @Override\n     public Map<byte[], BatchingVisitable<Map.Entry<Cell, byte[]>>> getRowsColumnRange(\n             TableReference tableRef, Iterable<byte[]> rows, BatchColumnRangeSelection columnRangeSelection) {\n-        return Maps.transformEntries(\n-                getRowsColumnRangeIterator(tableRef, rows, columnRangeSelection),\n-                (row, iterator) -> BatchingVisitableFromIterable.create(iterator));\n+        return KeyedStream.stream(getRowsColumnRangeIterator(tableRef, rows, columnRangeSelection))\n+                .map((row, iterator) -> BatchingVisitableFromIterable.create(iterator))\n+                .collectTo(() -> new TreeMap<>(UnsignedBytes.lexicographicalComparator()));", "originalCommit": "8499d5998c787615b8ed82b70a5f5cb25f84c1a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwMDUxOA==", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r542300518", "bodyText": "Yep, as discussed on the test comments - there are tests that verify that elements are returned in order.\nThe interface demands a Map (but not a SortedMap and we can't change that super easily), so the best we can do is maybe something like\n    @Override\n    public Map<byte[], BatchingVisitable<Map.Entry<Cell, byte[]>>> getRowsColumnRange(\n            TableReference tableRef, Iterable<byte[]> rows, BatchColumnRangeSelection columnRangeSelection) {\n        SortedMap<byte[], BatchingVisitable<Entry<Cell, byte[]>>> sortedVisitables =\n                KeyedStream.stream(getRowsColumnRangeIterator(tableRef, rows, columnRangeSelection))\n                        .map((row, iterator) -> BatchingVisitableFromIterable.create(iterator))\n                        .collectTo(() -> new TreeMap<>(UnsignedBytes.lexicographicalComparator()));\n        return sortedVisitables;\n    }\n\nthough given the tests I think that's unnecessary.", "author": "jeremyk-91", "createdAt": "2020-12-14T11:08:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4Mzg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwMjY2MQ==", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r542302661", "bodyText": "Reasonable - I suppose the fact that it is not a SortedMap makes anyone's reliance on the ordering a bit suspicious. And either way, so long as the tests catch this we should catch any regressions.", "author": "Jolyon-S", "createdAt": "2020-12-14T11:11:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4Mzg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NTg2OQ==", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r539185869", "bodyText": "What happens if you call iterator2.next()?", "author": "Jolyon-S", "createdAt": "2020-12-09T10:25:12Z", "path": "atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/AbstractSerializableTransactionTest.java", "diffHunk": "@@ -1091,6 +1095,68 @@ public void testDisableReadWriteConflictChecking() {\n         t2.commit();\n     }\n \n+    @Test\n+    public void testGetRowsColumnRangeMultipleIteratorsWorkSafely() {\n+        byte[] row = PtBytes.toBytes(\"ryan\");\n+        Cell cell = Cell.create(row, PtBytes.toBytes(\"c\"));\n+        byte[] value = PtBytes.toBytes(\"victor\");\n+\n+        Transaction t1 = startTransaction();\n+        t1.put(TEST_TABLE, ImmutableMap.of(cell, value));\n+        t1.commit();\n+\n+        Transaction t2 = startTransaction();\n+        Map<byte[], BatchingVisitable<Map.Entry<Cell, byte[]>>> iterators = t2.getRowsColumnRange(\n+                TEST_TABLE,\n+                ImmutableList.of(row),\n+                BatchColumnRangeSelection.create(PtBytes.EMPTY_BYTE_ARRAY, PtBytes.EMPTY_BYTE_ARRAY, 1000));\n+\n+        BatchingVisitable<Map.Entry<Cell, byte[]>> visitable1 = iterators.get(row);\n+        List<Map.Entry<Cell, byte[]>> entriesFromVisitable1 = new ArrayList<>();\n+\n+        BatchingVisitable<Map.Entry<Cell, byte[]>> visitable2 = iterators.get(row);\n+\n+        visitable1.batchAccept(10, cells -> {\n+            entriesFromVisitable1.addAll(cells);\n+            return true;\n+        });\n+\n+        assertThatThrownBy(() -> visitable2.batchAccept(10, cells -> true))\n+                .isExactlyInstanceOf(SafeIllegalStateException.class)\n+                .hasMessageContaining(\"This class has already been called once before\");\n+\n+        assertThat(Iterables.getOnlyElement(entriesFromVisitable1)).satisfies(entry -> {\n+            assertThat(entry.getKey()).isEqualTo(cell);\n+            assertThat(Arrays.equals(entry.getValue(), value)).isTrue();\n+        });\n+    }\n+\n+    @Test\n+    public void testGetRowsColumnRangeIteratorMultipleIteratorsWorkSafely() {\n+        byte[] row = PtBytes.toBytes(\"row\");\n+        Cell cell = Cell.create(row, PtBytes.toBytes(\"col\"));\n+        byte[] value = PtBytes.toBytes(\"val\");\n+\n+        Transaction t1 = startTransaction();\n+        t1.put(TEST_TABLE, ImmutableMap.of(cell, value));\n+        t1.commit();\n+\n+        Transaction t2 = startTransaction();\n+        Map<byte[], Iterator<Map.Entry<Cell, byte[]>>> iterators = t2.getRowsColumnRangeIterator(\n+                TEST_TABLE,\n+                ImmutableList.of(row),\n+                BatchColumnRangeSelection.create(PtBytes.EMPTY_BYTE_ARRAY, PtBytes.EMPTY_BYTE_ARRAY, 1000));\n+\n+        Iterator<Map.Entry<Cell, byte[]>> iterator1 = iterators.get(row);\n+        Iterator<Map.Entry<Cell, byte[]>> iterator2 = iterators.get(row);\n+        assertThat(iterator1.hasNext()).isTrue();\n+        assertThat(iterator2.hasNext()).isTrue();\n+\n+        Map.Entry<Cell, byte[]> entry = iterator1.next();\n+        assertThat(entry.getKey()).isEqualTo(cell);\n+        assertThat(Arrays.equals(entry.getValue(), value)).isTrue();", "originalCommit": "8499d5998c787615b8ed82b70a5f5cb25f84c1a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI5ODcwMA==", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r542298700", "bodyText": "NoSuchElementException - I've added a pair of false hasNext() calls after the value is read.", "author": "jeremyk-91", "createdAt": "2020-12-14T11:05:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NTg2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NjIzMg==", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r539186232", "bodyText": "Is there a test somewhere in this class that checks the output is correctly ordered? If not, can we add one such test? Even if there is a test in SnapshotTransaction there should be one here too, to confirm that the ordering stays the same.", "author": "Jolyon-S", "createdAt": "2020-12-09T10:25:41Z", "path": "atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/AbstractSerializableTransactionTest.java", "diffHunk": "@@ -1091,6 +1095,68 @@ public void testDisableReadWriteConflictChecking() {\n         t2.commit();\n     }\n \n+    @Test\n+    public void testGetRowsColumnRangeMultipleIteratorsWorkSafely() {", "originalCommit": "8499d5998c787615b8ed82b70a5f5cb25f84c1a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI5MDM3OA==", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r542290378", "bodyText": "Yes (though it's a bit non-obvious to find): AbstractTransactionTest#testColumnRangePagingTransaction_batchingVisitable()", "author": "jeremyk-91", "createdAt": "2020-12-14T10:52:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NjIzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NzE3MQ==", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r539187171", "bodyText": "You added two tests for the SerializableTransaction, why only one here?", "author": "Jolyon-S", "createdAt": "2020-12-09T10:27:04Z", "path": "atlasdb-tests-shared/src/test/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionTest.java", "diffHunk": "@@ -1220,6 +1221,41 @@ public void cleanup() {}\n         assertEquals(ImmutableList.of(firstCell, secondCell), cells);\n     }\n \n+    @Test\n+    public void testGetRowsColumnRangeMultipleIteratorsWorkSafely() {", "originalCommit": "8499d5998c787615b8ed82b70a5f5cb25f84c1a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NzQzMQ==", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r539187431", "bodyText": "Also, similar comment as above - do we test for the right ordering of values read?", "author": "Jolyon-S", "createdAt": "2020-12-09T10:27:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NzE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI5NjY3MQ==", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r542296671", "bodyText": "I changed two methods in SerializableTransaction but only one in SnapshotTransaction: getRowsColumnRangeIterator was already safely implemented in SnapshotTransaction but not in SerializableTransaction. That said I think I'll move the two in the AbSTT to the general AbTT, so this test shouldn't be needed any more.\nIn terms of value testing: yes - this is in the abstract transaction test.", "author": "jeremyk-91", "createdAt": "2020-12-14T11:02:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NzE3MQ=="}], "type": "inlineReview"}, {"oid": "e80357af20574e173e6d73fcbd3cc75ace63a182", "url": "https://github.com/palantir/atlasdb/commit/e80357af20574e173e6d73fcbd3cc75ace63a182", "message": "Move AbSTT tests to AbTT", "committedDate": "2020-12-14T11:09:38Z", "type": "commit"}]}