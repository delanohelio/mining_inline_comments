{"pr_number": 4711, "pr_title": "[ETE] Batching Txns, Attempt 2", "pr_createdAt": "2020-04-16T10:13:29Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4711", "timeline": [{"oid": "720aa3f84b14ed855dc7b53ad50e1e3d97434cc2", "url": "https://github.com/palantir/atlasdb/commit/720aa3f84b14ed855dc7b53ad50e1e3d97434cc2", "message": "wow this is a mess", "committedDate": "2020-04-15T14:40:39Z", "type": "commit"}, {"oid": "7538acafca7800e64f22cebc9ee8115af66d4ea5", "url": "https://github.com/palantir/atlasdb/commit/7538acafca7800e64f22cebc9ee8115af66d4ea5", "message": "more fixup", "committedDate": "2020-04-15T15:02:27Z", "type": "commit"}, {"oid": "c9106b2fd10913269fd80667dcb64321ef8afb91", "url": "https://github.com/palantir/atlasdb/commit/c9106b2fd10913269fd80667dcb64321ef8afb91", "message": "some more shimmy", "committedDate": "2020-04-16T09:06:34Z", "type": "commit"}, {"oid": "e288d0f1730e24fdaa8cd77e7b37c6ad62fd3eb4", "url": "https://github.com/palantir/atlasdb/commit/e288d0f1730e24fdaa8cd77e7b37c6ad62fd3eb4", "message": "re-jig a load of things", "committedDate": "2020-04-16T09:40:28Z", "type": "commit"}, {"oid": "7c82cbbaf24a7271bccbfc8276cfbb2af0bcf064", "url": "https://github.com/palantir/atlasdb/commit/7c82cbbaf24a7271bccbfc8276cfbb2af0bcf064", "message": "load more cleaning up I guess", "committedDate": "2020-04-16T10:06:14Z", "type": "commit"}, {"oid": "0eedf8ab5318fc7f55d961c0fba2e21f44262d16", "url": "https://github.com/palantir/atlasdb/commit/0eedf8ab5318fc7f55d961c0fba2e21f44262d16", "message": "add comment", "committedDate": "2020-04-16T10:19:21Z", "type": "commit"}, {"oid": "59f246f24630aecd97841ab1191cd73d8a76a2e1", "url": "https://github.com/palantir/atlasdb/commit/59f246f24630aecd97841ab1191cd73d8a76a2e1", "message": "Undo crazy aggressive formatting", "committedDate": "2020-04-16T10:23:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ0OTU4Ng==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r409449586", "bodyText": "This class is copied from bottom of SnapshotTransactionManager - probably want to merge the two (if I can find a place where it makes sense to live in the project hierarchy).", "author": "Jolyon-S", "createdAt": "2020-04-16T10:26:15Z", "path": "lock-api-objects/src/main/java/com/palantir/lock/v2/ExceptionHandlingRunner.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.v2;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+\n+public final class ExceptionHandlingRunner implements AutoCloseable {", "originalCommit": "59f246f24630aecd97841ab1191cd73d8a76a2e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "27f3e9ce14063f2009d3da8fb12eaa26bc2178c9", "url": "https://github.com/palantir/atlasdb/commit/27f3e9ce14063f2009d3da8fb12eaa26bc2178c9", "message": "remove batch manager", "committedDate": "2020-04-16T10:26:40Z", "type": "commit"}, {"oid": "fd559d34b3508f8d60707bb338666e299b5ee5dd", "url": "https://github.com/palantir/atlasdb/commit/fd559d34b3508f8d60707bb338666e299b5ee5dd", "message": "undo more formatting", "committedDate": "2020-04-16T10:29:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ1NDkwNA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r409454904", "bodyText": "I need to spend a bit of time confirming what these do and determine the most efficient way to do this.", "author": "Jolyon-S", "createdAt": "2020-04-16T10:35:15Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockService.java", "diffHunk": "@@ -78,6 +89,21 @@ public StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransacti\n         return timestampContainer;\n     }\n \n+    // pretty weird, I haven't put much effort into this, just to plug the gap really\n+    private <T, R> T checkAndUpdateLowerBoundBatch(Supplier<T> timestampContainerSupplier,\n+            Function<T, List<R>> responseExtractor,\n+            ToLongFunction<R> lowerBoundExtractor,\n+            ToLongFunction<R> upperBoundExtractor) {\n+        long threadLocalLowerBound = lowerBound.get();\n+        T timestampContainers = timestampContainerSupplier.get();\n+        List<R> responses = responseExtractor.apply(timestampContainers);\n+        responses.forEach(timestampContainer -> {\n+            checkTimestamp(threadLocalLowerBound, lowerBoundExtractor.applyAsLong(timestampContainer));\n+            updateLowerBound(upperBoundExtractor.applyAsLong(timestampContainer));", "originalCommit": "fd559d34b3508f8d60707bb338666e299b5ee5dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "04826a2d5c5cbde41cebe0f7deb0f1d6f6d82dfa", "url": "https://github.com/palantir/atlasdb/commit/04826a2d5c5cbde41cebe0f7deb0f1d6f6d82dfa", "message": "cleanup autobatcher", "committedDate": "2020-04-16T12:08:33Z", "type": "commit"}, {"oid": "26320aa39011fdb69889bcb1cc3d410ba2f1233a", "url": "https://github.com/palantir/atlasdb/commit/26320aa39011fdb69889bcb1cc3d410ba2f1233a", "message": "Don't auto format....", "committedDate": "2020-04-16T12:09:00Z", "type": "commit"}, {"oid": "e08ab50545dd61aeb40a499e9bedb016c1271993", "url": "https://github.com/palantir/atlasdb/commit/e08ab50545dd61aeb40a499e9bedb016c1271993", "message": "Clean up method in corrobating timelock service", "committedDate": "2020-04-16T12:19:47Z", "type": "commit"}, {"oid": "a33bd09307a5ae7d7bd0d3b50ab7d0f3432d14da", "url": "https://github.com/palantir/atlasdb/commit/a33bd09307a5ae7d7bd0d3b50ab7d0f3432d14da", "message": "Improve the batch code significantly", "committedDate": "2020-04-16T12:36:40Z", "type": "commit"}, {"oid": "9e54c2b1bb79dddd3ef889298202e790af45a995", "url": "https://github.com/palantir/atlasdb/commit/9e54c2b1bb79dddd3ef889298202e790af45a995", "message": "Register locks in a batch", "committedDate": "2020-04-16T12:41:53Z", "type": "commit"}, {"oid": "f9c20aeccaf67369513132f46c4dddcab1543e8e", "url": "https://github.com/palantir/atlasdb/commit/f9c20aeccaf67369513132f46c4dddcab1543e8e", "message": "Move and further cleaning", "committedDate": "2020-04-16T12:53:09Z", "type": "commit"}, {"oid": "670687d377e83ad92f8cb1fc14e19003e48db17c", "url": "https://github.com/palantir/atlasdb/commit/670687d377e83ad92f8cb1fc14e19003e48db17c", "message": "Move and further cleaning", "committedDate": "2020-04-16T12:55:29Z", "type": "commit"}, {"oid": "1453b54c8b9b8b2f37c9e8a74044af66a9c4088e", "url": "https://github.com/palantir/atlasdb/commit/1453b54c8b9b8b2f37c9e8a74044af66a9c4088e", "message": "Remove unused import", "committedDate": "2020-04-16T13:05:28Z", "type": "commit"}, {"oid": "ce6bdcbe612ea10db4c6e45f86c087e723483659", "url": "https://github.com/palantir/atlasdb/commit/ce6bdcbe612ea10db4c6e45f86c087e723483659", "message": "Rewrite java doc", "committedDate": "2020-04-16T13:37:50Z", "type": "commit"}, {"oid": "6515aa215db4bcd9f5dc02fafaa0a4205c104405", "url": "https://github.com/palantir/atlasdb/commit/6515aa215db4bcd9f5dc02fafaa0a4205c104405", "message": "Add test for exceptionHandlingRunner", "committedDate": "2020-04-16T13:55:08Z", "type": "commit"}, {"oid": "1a629cb8a74f2c969ed14039ad734497acf342e6", "url": "https://github.com/palantir/atlasdb/commit/1a629cb8a74f2c969ed14039ad734497acf342e6", "message": "Remove SnapshotTransactionManager's private shutdown runner", "committedDate": "2020-04-16T13:56:32Z", "type": "commit"}, {"oid": "91a210f4f490aed49fed05e0872be29a8aad88c8", "url": "https://github.com/palantir/atlasdb/commit/91a210f4f490aed49fed05e0872be29a8aad88c8", "message": "Add test to TimestampCorrobatingTimelockServiceTest", "committedDate": "2020-04-16T14:02:52Z", "type": "commit"}, {"oid": "107b08a8e31864fea19d96a88f811292c9064f17", "url": "https://github.com/palantir/atlasdb/commit/107b08a8e31864fea19d96a88f811292c9064f17", "message": "Add SnapshotTransactionManager test", "committedDate": "2020-04-16T14:29:07Z", "type": "commit"}, {"oid": "07a56a9c69cac73bfe20387f74798bfde6967ffb", "url": "https://github.com/palantir/atlasdb/commit/07a56a9c69cac73bfe20387f74798bfde6967ffb", "message": "Add line to hit the batch part in profilling timelock service test", "committedDate": "2020-04-16T14:36:03Z", "type": "commit"}, {"oid": "9b007048b7f5d4dd340c010e06484aad2b5cc43e", "url": "https://github.com/palantir/atlasdb/commit/9b007048b7f5d4dd340c010e06484aad2b5cc43e", "message": "Add batch test to TransactionStarter", "committedDate": "2020-04-16T15:03:13Z", "type": "commit"}, {"oid": "bd91381447e811bd9154a7f6209a254db3d0f5fd", "url": "https://github.com/palantir/atlasdb/commit/bd91381447e811bd9154a7f6209a254db3d0f5fd", "message": "Fix some checkstyle", "committedDate": "2020-04-17T08:10:45Z", "type": "commit"}, {"oid": "0e708dc67a87d4a16606a6fb40576efd62044e17", "url": "https://github.com/palantir/atlasdb/commit/0e708dc67a87d4a16606a6fb40576efd62044e17", "message": "Rename argument", "committedDate": "2020-04-17T08:12:27Z", "type": "commit"}, {"oid": "0fcda8cb6c02188ae333a3f95619fd3e7a9ce477", "url": "https://github.com/palantir/atlasdb/commit/0fcda8cb6c02188ae333a3f95619fd3e7a9ce477", "message": "Fix further checkstyles", "committedDate": "2020-04-17T08:13:28Z", "type": "commit"}, {"oid": "e7840a561b60d4abb3f16747e9fbcbf253d75eee", "url": "https://github.com/palantir/atlasdb/commit/e7840a561b60d4abb3f16747e9fbcbf253d75eee", "message": "Add extra close call in case of empty responses", "committedDate": "2020-04-17T08:20:43Z", "type": "commit"}, {"oid": "c232d369b2adae5168a9ed5ede1851000fa964fe", "url": "https://github.com/palantir/atlasdb/commit/c232d369b2adae5168a9ed5ede1851000fa964fe", "message": "Merge branch 'develop' into fork-batch-txns", "committedDate": "2020-04-17T08:28:54Z", "type": "commit"}, {"oid": "50971350ec6a3b166f2b236c02bbb44809a06256", "url": "https://github.com/palantir/atlasdb/commit/50971350ec6a3b166f2b236c02bbb44809a06256", "message": "Factor out shutdown runner", "committedDate": "2020-04-17T08:37:31Z", "type": "commit"}, {"oid": "65df14408e6d004599712b74029fc0f310249372", "url": "https://github.com/palantir/atlasdb/commit/65df14408e6d004599712b74029fc0f310249372", "message": "Add generated changelog entries", "committedDate": "2020-04-17T08:37:31Z", "type": "commit"}, {"oid": "034408c8d419931c04d1200a003cb6ad0b36719a", "url": "https://github.com/palantir/atlasdb/commit/034408c8d419931c04d1200a003cb6ad0b36719a", "message": "Merge branch 'extract-exception-handler' into fork-batch-txns\n\n# Conflicts:\n#\tatlasdb-commons/src/test/java/com/palantir/util/ExceptionHandlingRunnerTests.java", "committedDate": "2020-04-17T08:43:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA5NDA1OQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r410094059", "bodyText": "We can probably optimise this in the batched case (only update once), if that is a performance concern.", "author": "Jolyon-S", "createdAt": "2020-04-17T09:09:18Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -166,26 +169,50 @@ public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(Pr\n         StartIdentifiedAtlasDbTransactionResponse transactionResponse\n                 = timelockService.startIdentifiedAtlasDbTransaction();\n         try {\n-            LockToken immutableTsLock = transactionResponse.immutableTimestamp().getLock();\n-            long immutableTs = transactionResponse.immutableTimestamp().getImmutableTimestamp();\n-            recordImmutableTimestamp(immutableTs);\n-\n-            cleaner.punch(transactionResponse.startTimestampAndPartition().timestamp());\n-            Supplier<Long> startTimestampSupplier = Suppliers.ofInstance(\n-                    transactionResponse.startTimestampAndPartition().timestamp());\n-\n-            Transaction transaction = createTransaction(\n-                    immutableTs,\n-                    startTimestampSupplier,\n-                    immutableTsLock,\n-                    condition);\n-            return TransactionAndImmutableTsLock.of(transaction, immutableTsLock);\n+            return wrapResponse(condition, transactionResponse);\n         } catch (Throwable e) {\n             timelockService.tryUnlock(ImmutableSet.of(transactionResponse.immutableTimestamp().getLock()));\n             throw Throwables.rewrapAndThrowUncheckedException(e);\n         }\n     }\n \n+    @Override\n+    public List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n+            List<PreCommitCondition> conditions) {\n+        Preconditions.checkArgument(!conditions.isEmpty(), \"Trying to start an empty batch\");\n+        try (StartIdentifiedAtlasDbTransactionResponseBatch responses =\n+                timelockService.startIdentifiedAtlasDbTransactionsBatch(conditions.size())) {\n+            if (responses.size() != conditions.size()) {\n+                throw new TransactionBatchFailedRetriableException(\n+                        \"The number of transactions started does not match the size of the batch.\");\n+            }\n+\n+            List<TransactionAndImmutableTsLock> transactions = Streams.zip(\n+                    responses.getResponses().stream(),\n+                    conditions.stream(),\n+                    (response, condition) -> wrapResponse(condition, response)).collect(Collectors.toList());\n+            return responses.successful(transactions);\n+        }\n+    }\n+\n+    private TransactionAndImmutableTsLock wrapResponse(PreCommitCondition condition,\n+            StartIdentifiedAtlasDbTransactionResponse transactionResponse) {\n+        LockToken immutableTsLock = transactionResponse.immutableTimestamp().getLock();\n+        long immutableTs = transactionResponse.immutableTimestamp().getImmutableTimestamp();\n+        recordImmutableTimestamp(immutableTs);", "originalCommit": "034408c8d419931c04d1200a003cb6ad0b36719a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4MTg3NA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413081874", "bodyText": "@jeremyk-91 to help verify; also probably need metrics to help answer this", "author": "jkozlowski", "createdAt": "2020-04-22T15:26:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA5NDA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIxOTY5MQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413219691", "bodyText": "Hard to say: this does a single atomic CAS so it shouldn't be too bad. Maybe just have a method wrapResponses that does the atomic update just once (with either the max of the immutable timestamps across the list, if we choose to be defensive, or the first element, if we want to rely on how creating batches normally goes)?", "author": "jeremyk-91", "createdAt": "2020-04-22T18:29:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA5NDA1OQ=="}], "type": "inlineReview"}, {"oid": "8c616629f5c7011f455ad4b4c729020cd59e521d", "url": "https://github.com/palantir/atlasdb/commit/8c616629f5c7011f455ad4b4c729020cd59e521d", "message": "Change to use AtlasFutures", "committedDate": "2020-04-17T10:00:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA1NDgwNg==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413054806", "bodyText": "What does \"for the tasks\" mean?", "author": "jkozlowski", "createdAt": "2020-04-22T14:54:29Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java", "diffHunk": "@@ -433,6 +434,17 @@ default LockWatchManager getLockWatchManager() {\n     @Timed\n     TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition);\n \n+    /**\n+     * This method exposes the ability to start a batch of transactions with pre-commit conditions in a single call.\n+     * The result is similar to calling {@link #setupRunTaskWithConditionThrowOnConflict(PreCommitCondition)}, except\n+     * the code has been specifically optimised with respect to batching and error handling.\n+     *\n+     * @return a list of transactions and their associated immutable timestamp locks for the tasks", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY1MzExNg==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r415653116", "bodyText": "Read the javadoc for the old method - was simply mirroring what was said there but in plural form.", "author": "Jolyon-S", "createdAt": "2020-04-27T09:23:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA1NDgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA2Nzc2Mg==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413067762", "bodyText": "Refactor this check to a method.", "author": "jkozlowski", "createdAt": "2020-04-22T15:09:28Z", "path": "atlasdb-autobatch/src/main/java/com/palantir/atlasdb/autobatch/DisruptorAutobatcher.java", "diffHunk": "@@ -86,11 +89,31 @@ private static ThreadFactory createThreadFactory(String safeLoggablePurpose) {\n     public ListenableFuture<R> apply(T argument) {\n         Preconditions.checkState(!closed, \"Autobatcher is already shut down\");\n         DisruptorFuture<R> result = new DisruptorFuture<R>(safeLoggablePurpose);\n-        buffer.publishEvent((refresh, sequence) -> {\n+        buffer.publishEvent(createTranslator(argument, result));\n+        return result;\n+    }\n+\n+    public List<ListenableFuture<R>> applyBatch(List<T> arguments) {\n+        Preconditions.checkState(!closed, \"Autobatcher is already shut down\");", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA2ODkwMA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413068900", "bodyText": "Tests for this method, and I suppose for this whole class? The batching code is tricky, so definitely need tests for batching code.", "author": "jkozlowski", "createdAt": "2020-04-22T15:10:50Z", "path": "atlasdb-autobatch/src/main/java/com/palantir/atlasdb/autobatch/DisruptorAutobatcher.java", "diffHunk": "@@ -86,11 +89,31 @@ private static ThreadFactory createThreadFactory(String safeLoggablePurpose) {\n     public ListenableFuture<R> apply(T argument) {\n         Preconditions.checkState(!closed, \"Autobatcher is already shut down\");\n         DisruptorFuture<R> result = new DisruptorFuture<R>(safeLoggablePurpose);\n-        buffer.publishEvent((refresh, sequence) -> {\n+        buffer.publishEvent(createTranslator(argument, result));\n+        return result;\n+    }\n+\n+    public List<ListenableFuture<R>> applyBatch(List<T> arguments) {\n+        Preconditions.checkState(!closed, \"Autobatcher is already shut down\");\n+        List<ListenableFuture<R>> results = new ArrayList<>();\n+\n+        EventTranslator<DefaultBatchElement<T, R>>[] translators = arguments.stream().map(argument -> {\n+            DisruptorFuture<R> result = new DisruptorFuture<>(safeLoggablePurpose);\n+            EventTranslator<DefaultBatchElement<T, R>> translator = createTranslator(argument, result);\n+            results.add(result);\n+            return translator;\n+        }).toArray(EventTranslator[]::new);\n+\n+        buffer.publishEvents(translators);\n+\n+        return results;", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA3MTA5OQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413071099", "bodyText": "Would it be a lot of overhead for removing the non-batched method here?", "author": "jkozlowski", "createdAt": "2020-04-22T15:13:28Z", "path": "atlasdb-autobatch/src/main/java/com/palantir/atlasdb/autobatch/DisruptorAutobatcher.java", "diffHunk": "@@ -86,11 +89,31 @@ private static ThreadFactory createThreadFactory(String safeLoggablePurpose) {\n     public ListenableFuture<R> apply(T argument) {\n         Preconditions.checkState(!closed, \"Autobatcher is already shut down\");\n         DisruptorFuture<R> result = new DisruptorFuture<R>(safeLoggablePurpose);\n-        buffer.publishEvent((refresh, sequence) -> {\n+        buffer.publishEvent(createTranslator(argument, result));\n+        return result;\n+    }\n+\n+    public List<ListenableFuture<R>> applyBatch(List<T> arguments) {", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY1NDQxNw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r415654417", "bodyText": "I think so - it is used in quite a few places.\nWe could instead just have apply call applyBatch instead.", "author": "Jolyon-S", "createdAt": "2020-04-27T09:25:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA3MTA5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA3MTUxOA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413071518", "bodyText": "Again, would it make sense to only keep the batched method? count=1 should be simple to handle.", "author": "jkozlowski", "createdAt": "2020-04-22T15:13:58Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockService.java", "diffHunk": "@@ -67,6 +68,13 @@ public StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransacti\n                 r -> r.startTimestampAndPartition().timestamp());\n     }\n \n+    @Override\n+    public StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA3NjQyOQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413076429", "bodyText": "Running close should be enforced to only ever happen once. Also you should probably not allow adding more callbacks after close is called.", "author": "jkozlowski", "createdAt": "2020-04-22T15:20:00Z", "path": "atlasdb-commons/src/main/java/com/palantir/util/ExceptionHandlingRunner.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.util;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+\n+/**\n+ * Runs runnables and suppliers that may throw exceptions, and swallows those exceptions until later. Can be used as a\n+ * resource in a try block, or delegated to by another resource.\n+ */\n+public final class ExceptionHandlingRunner implements AutoCloseable {\n+    private final List<Throwable> failures = new ArrayList<>();\n+\n+    public ExceptionHandlingRunner() {}\n+\n+    /**\n+     * Instantiates the runner with a throwable that has already been caught, to be rethrown when close is complete.\n+     */\n+    public ExceptionHandlingRunner(Throwable t) {\n+        failures.add(t);\n+    }\n+\n+    public void runSafely(Runnable shutdownCallback) {\n+        try {\n+            shutdownCallback.run();\n+        } catch (Throwable throwable) {\n+            failures.add(throwable);\n+        }\n+    }\n+\n+    public <T> Optional<T> supplySafely(Supplier<T> shutdownCallback) {\n+        try {\n+            return Optional.of(shutdownCallback.get());\n+        } catch (Throwable throwable) {\n+            failures.add(throwable);\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Calling close with no failures should be a no-op; equally, calling close multiple times will re-throw a runtime\n+     * exception with the same suppressed errors (plus any additional errors suppressed since the last close call).\n+     */\n+    @Override\n+    public void close() {\n+        if (!failures.isEmpty()) {", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA3NzYxOQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413077619", "bodyText": "2 arguments of the same type, wink wink \ud83d\ude09", "author": "jkozlowski", "createdAt": "2020-04-22T15:21:26Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockService.java", "diffHunk": "@@ -67,6 +68,13 @@ public StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransacti\n                 r -> r.startTimestampAndPartition().timestamp());\n     }\n \n+    @Override\n+    public StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {\n+        return checkAndUpdateLowerBound(() -> delegate.startIdentifiedAtlasDbTransactionsBatch(count),\n+                StartIdentifiedAtlasDbTransactionResponseBatch::getMinTimestamp,\n+                StartIdentifiedAtlasDbTransactionResponseBatch::getMaxTimestamp);\n+    }\n+\n     private <T> T checkAndUpdateLowerBound(Supplier<T> timestampContainerSupplier,\n             ToLongFunction<T> lowerBoundExtractor,", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA3ODk1OA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413078958", "bodyText": "Generally it's nicer to allow fall through like this (so allow empty list), I think this is what the usage of this in internal ski product assumed.", "author": "jkozlowski", "createdAt": "2020-04-22T15:23:05Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -166,26 +169,50 @@ public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(Pr\n         StartIdentifiedAtlasDbTransactionResponse transactionResponse\n                 = timelockService.startIdentifiedAtlasDbTransaction();\n         try {\n-            LockToken immutableTsLock = transactionResponse.immutableTimestamp().getLock();\n-            long immutableTs = transactionResponse.immutableTimestamp().getImmutableTimestamp();\n-            recordImmutableTimestamp(immutableTs);\n-\n-            cleaner.punch(transactionResponse.startTimestampAndPartition().timestamp());\n-            Supplier<Long> startTimestampSupplier = Suppliers.ofInstance(\n-                    transactionResponse.startTimestampAndPartition().timestamp());\n-\n-            Transaction transaction = createTransaction(\n-                    immutableTs,\n-                    startTimestampSupplier,\n-                    immutableTsLock,\n-                    condition);\n-            return TransactionAndImmutableTsLock.of(transaction, immutableTsLock);\n+            return wrapResponse(condition, transactionResponse);\n         } catch (Throwable e) {\n             timelockService.tryUnlock(ImmutableSet.of(transactionResponse.immutableTimestamp().getLock()));\n             throw Throwables.rewrapAndThrowUncheckedException(e);\n         }\n     }\n \n+    @Override\n+    public List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n+            List<PreCommitCondition> conditions) {\n+        Preconditions.checkArgument(!conditions.isEmpty(), \"Trying to start an empty batch\");", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4MDYwNQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413080605", "bodyText": "This feels like a weird thing to check, the method you call should not return you a small response, that doesn't feel like a great API.", "author": "jkozlowski", "createdAt": "2020-04-22T15:25:03Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -166,26 +169,50 @@ public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(Pr\n         StartIdentifiedAtlasDbTransactionResponse transactionResponse\n                 = timelockService.startIdentifiedAtlasDbTransaction();\n         try {\n-            LockToken immutableTsLock = transactionResponse.immutableTimestamp().getLock();\n-            long immutableTs = transactionResponse.immutableTimestamp().getImmutableTimestamp();\n-            recordImmutableTimestamp(immutableTs);\n-\n-            cleaner.punch(transactionResponse.startTimestampAndPartition().timestamp());\n-            Supplier<Long> startTimestampSupplier = Suppliers.ofInstance(\n-                    transactionResponse.startTimestampAndPartition().timestamp());\n-\n-            Transaction transaction = createTransaction(\n-                    immutableTs,\n-                    startTimestampSupplier,\n-                    immutableTsLock,\n-                    condition);\n-            return TransactionAndImmutableTsLock.of(transaction, immutableTsLock);\n+            return wrapResponse(condition, transactionResponse);\n         } catch (Throwable e) {\n             timelockService.tryUnlock(ImmutableSet.of(transactionResponse.immutableTimestamp().getLock()));\n             throw Throwables.rewrapAndThrowUncheckedException(e);\n         }\n     }\n \n+    @Override\n+    public List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n+            List<PreCommitCondition> conditions) {\n+        Preconditions.checkArgument(!conditions.isEmpty(), \"Trying to start an empty batch\");\n+        try (StartIdentifiedAtlasDbTransactionResponseBatch responses =\n+                timelockService.startIdentifiedAtlasDbTransactionsBatch(conditions.size())) {\n+            if (responses.size() != conditions.size()) {", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4MTIwMA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413081200", "bodyText": "Shouldn't this method or something lower from here retry this instead? Feels like a bad thing to ask the users of this API to handle.", "author": "jkozlowski", "createdAt": "2020-04-22T15:25:44Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -166,26 +169,50 @@ public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(Pr\n         StartIdentifiedAtlasDbTransactionResponse transactionResponse\n                 = timelockService.startIdentifiedAtlasDbTransaction();\n         try {\n-            LockToken immutableTsLock = transactionResponse.immutableTimestamp().getLock();\n-            long immutableTs = transactionResponse.immutableTimestamp().getImmutableTimestamp();\n-            recordImmutableTimestamp(immutableTs);\n-\n-            cleaner.punch(transactionResponse.startTimestampAndPartition().timestamp());\n-            Supplier<Long> startTimestampSupplier = Suppliers.ofInstance(\n-                    transactionResponse.startTimestampAndPartition().timestamp());\n-\n-            Transaction transaction = createTransaction(\n-                    immutableTs,\n-                    startTimestampSupplier,\n-                    immutableTsLock,\n-                    condition);\n-            return TransactionAndImmutableTsLock.of(transaction, immutableTsLock);\n+            return wrapResponse(condition, transactionResponse);\n         } catch (Throwable e) {\n             timelockService.tryUnlock(ImmutableSet.of(transactionResponse.immutableTimestamp().getLock()));\n             throw Throwables.rewrapAndThrowUncheckedException(e);\n         }\n     }\n \n+    @Override\n+    public List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n+            List<PreCommitCondition> conditions) {\n+        Preconditions.checkArgument(!conditions.isEmpty(), \"Trying to start an empty batch\");\n+        try (StartIdentifiedAtlasDbTransactionResponseBatch responses =\n+                timelockService.startIdentifiedAtlasDbTransactionsBatch(conditions.size())) {\n+            if (responses.size() != conditions.size()) {\n+                throw new TransactionBatchFailedRetriableException(", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEyNzcwNQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413127705", "bodyText": "Either I'm missing something, or we don't currently perform any retries in the old method - I was following suit in this one (but that can be changed if that is our desired behaviour, i.e. to retry on certain exceptions).", "author": "Jolyon-S", "createdAt": "2020-04-22T16:24:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4MTIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4MzUxOQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413083519", "bodyText": "Thoughts on returning something like TransactionAndImmutableTsLock, but that additionally has some sort of close method that users of this can call instead of using #finishRunTaskWithLockThrowOnConflict?", "author": "jkozlowski", "createdAt": "2020-04-22T15:28:31Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -166,26 +169,50 @@ public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(Pr\n         StartIdentifiedAtlasDbTransactionResponse transactionResponse\n                 = timelockService.startIdentifiedAtlasDbTransaction();\n         try {\n-            LockToken immutableTsLock = transactionResponse.immutableTimestamp().getLock();\n-            long immutableTs = transactionResponse.immutableTimestamp().getImmutableTimestamp();\n-            recordImmutableTimestamp(immutableTs);\n-\n-            cleaner.punch(transactionResponse.startTimestampAndPartition().timestamp());\n-            Supplier<Long> startTimestampSupplier = Suppliers.ofInstance(\n-                    transactionResponse.startTimestampAndPartition().timestamp());\n-\n-            Transaction transaction = createTransaction(\n-                    immutableTs,\n-                    startTimestampSupplier,\n-                    immutableTsLock,\n-                    condition);\n-            return TransactionAndImmutableTsLock.of(transaction, immutableTsLock);\n+            return wrapResponse(condition, transactionResponse);\n         } catch (Throwable e) {\n             timelockService.tryUnlock(ImmutableSet.of(transactionResponse.immutableTimestamp().getLock()));\n             throw Throwables.rewrapAndThrowUncheckedException(e);\n         }\n     }\n \n+    @Override\n+    public List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI3OTQ5OA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417279498", "bodyText": "I think I won't do that in this PR - we can maybe do that improvement in a separate task.", "author": "Jolyon-S", "createdAt": "2020-04-29T12:34:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4MzUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4NDI4NQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413084285", "bodyText": "Should be @deprecated", "author": "jkozlowski", "createdAt": "2020-04-22T15:29:23Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java", "diffHunk": "@@ -433,6 +434,17 @@ default LockWatchManager getLockWatchManager() {\n     @Timed\n     TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition);\n \n+    /**\n+     * This method exposes the ability to start a batch of transactions with pre-commit conditions in a single call.\n+     * The result is similar to calling {@link #setupRunTaskWithConditionThrowOnConflict(PreCommitCondition)}, except\n+     * the code has been specifically optimised with respect to batching and error handling.\n+     *\n+     * @return a list of transactions and their associated immutable timestamp locks for the tasks\n+     */\n+    @Timed\n+    List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4NDY4OQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413084689", "bodyText": "Please document that PreCommitConditions do not get cleaned up on errors.", "author": "jkozlowski", "createdAt": "2020-04-22T15:29:51Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java", "diffHunk": "@@ -433,6 +434,17 @@ default LockWatchManager getLockWatchManager() {\n     @Timed\n     TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition);\n \n+    /**\n+     * This method exposes the ability to start a batch of transactions with pre-commit conditions in a single call.\n+     * The result is similar to calling {@link #setupRunTaskWithConditionThrowOnConflict(PreCommitCondition)}, except\n+     * the code has been specifically optimised with respect to batching and error handling.", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4NjAwNA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413086004", "bodyText": "We need to remove this method, since it is only supposed to be used by internal ski product.", "author": "jkozlowski", "createdAt": "2020-04-22T15:31:21Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java", "diffHunk": "@@ -433,6 +434,17 @@ default LockWatchManager getLockWatchManager() {\n     @Timed\n     TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition);", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4NzYwMQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413087601", "bodyText": "Please check that this code you're moving is covered by extensive tests first, especially around resource cleanup on errors.", "author": "jkozlowski", "createdAt": "2020-04-22T15:33:18Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -166,26 +169,50 @@ public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(Pr\n         StartIdentifiedAtlasDbTransactionResponse transactionResponse\n                 = timelockService.startIdentifiedAtlasDbTransaction();\n         try {\n-            LockToken immutableTsLock = transactionResponse.immutableTimestamp().getLock();\n-            long immutableTs = transactionResponse.immutableTimestamp().getImmutableTimestamp();\n-            recordImmutableTimestamp(immutableTs);\n-\n-            cleaner.punch(transactionResponse.startTimestampAndPartition().timestamp());\n-            Supplier<Long> startTimestampSupplier = Suppliers.ofInstance(\n-                    transactionResponse.startTimestampAndPartition().timestamp());\n-\n-            Transaction transaction = createTransaction(\n-                    immutableTs,\n-                    startTimestampSupplier,\n-                    immutableTsLock,\n-                    condition);\n-            return TransactionAndImmutableTsLock.of(transaction, immutableTsLock);\n+            return wrapResponse(condition, transactionResponse);", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4OTQwNw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413089407", "bodyText": "Again, how bad would it be to only have the batched method?", "author": "jkozlowski", "createdAt": "2020-04-22T15:35:30Z", "path": "lock-api/src/main/java/com/palantir/lock/client/LockRefresher.java", "diffHunk": "@@ -85,6 +85,10 @@ public void registerLock(LockToken token) {\n         tokensToRefresh.add(token);\n     }\n \n+    public void registerLocks(Collection<LockToken> tokens) {", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1NDQ4Mg==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418554482", "bodyText": "Checked that no one uses this", "author": "jeremyk-91", "createdAt": "2020-05-01T14:03:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4OTQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5MDMyNA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413090324", "bodyText": "Batched method only.", "author": "jkozlowski", "createdAt": "2020-04-22T15:36:38Z", "path": "lock-api/src/main/java/com/palantir/lock/client/ProfilingTimelockService.java", "diffHunk": "@@ -116,6 +117,12 @@ public StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransacti\n         return runTaskTimed(\"startIdentifiedAtlasDbTransaction\", delegate::startIdentifiedAtlasDbTransaction);\n     }\n \n+    @Override\n+    public StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {\n+        return runTaskTimed(\"startIdentifiedAtlasDbTransactionsBatch\",", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5MTI3Mg==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413091272", "bodyText": "Only batched method", "author": "jkozlowski", "createdAt": "2020-04-22T15:37:48Z", "path": "lock-impl/src/main/java/com/palantir/lock/impl/LegacyTimelockService.java", "diffHunk": "@@ -123,6 +125,21 @@ public StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransacti\n         }\n     }\n \n+    @Override\n+    public StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEwNzAzNA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413107034", "bodyText": "Oh wait this is legacy; @jeremyk-91 this is mostly unused now right so don't need to worry about perf?", "author": "jkozlowski", "createdAt": "2020-04-22T15:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5MTI3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE1NzU3Mg==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413157572", "bodyText": "Fine by me: this is largely used in embedded contexts. There is large internal product, but in any case the algorithm here is not really worse than what people will probably end up writing anyway", "author": "jeremyk-91", "createdAt": "2020-04-22T17:03:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5MTI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5MjcyNA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413092724", "bodyText": "Batched only.", "author": "jkozlowski", "createdAt": "2020-04-22T15:39:35Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java", "diffHunk": "@@ -70,12 +71,17 @@ static TransactionStarter create(LockLeaseService lockLeaseService, LockWatchEve\n     }\n \n     StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        try {\n-            return autobatcher.apply(null).get();\n-        } catch (ExecutionException e) {\n-            throw Throwables.throwUncheckedException(e.getCause());\n-        } catch (Throwable t) {\n-            throw Throwables.throwUncheckedException(t);\n+        return AtlasFutures.getUnchecked(autobatcher.apply(null));\n+    }\n+\n+    StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5NTE2MA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413095160", "bodyText": "Can someone explain why do we have this bizarre interface here with passing nulls?", "author": "jkozlowski", "createdAt": "2020-04-22T15:42:32Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java", "diffHunk": "@@ -70,12 +71,17 @@ static TransactionStarter create(LockLeaseService lockLeaseService, LockWatchEve\n     }\n \n     StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        try {\n-            return autobatcher.apply(null).get();\n-        } catch (ExecutionException e) {\n-            throw Throwables.throwUncheckedException(e.getCause());\n-        } catch (Throwable t) {\n-            throw Throwables.throwUncheckedException(t);\n+        return AtlasFutures.getUnchecked(autobatcher.apply(null));", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5NzQ1Ng==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413097456", "bodyText": "Hmm, I guess we sometimes need to pass an actual argument here.", "author": "jkozlowski", "createdAt": "2020-04-22T15:45:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5NTE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEwMjQ0Ng==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413102446", "bodyText": "I think there's an argument for rewriting this to pass actual number of requested transactions to start? So that internal ski product's disruptors would actually become extremely tiny! Then the batch processor could just count number of transactions requested across the batch and send that to timelock?\n\nwe would save on a bunch of allocations for futures and lists for args here\nWe would get rid of the weird \"null\" passing of arguments?\n\n@jeremyk-91 interested in your thoughts", "author": "jkozlowski", "createdAt": "2020-04-22T15:51:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5NTE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEyMzk1NQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413123955", "bodyText": "Would you mean that, instead of passing null, you pass in say count, and then the autobatcher batches several counts together into a larger batch and fans those out? If so, that would definitely reduce the size of the autobatcher (or at least, the ring buffer underneath).", "author": "Jolyon-S", "createdAt": "2020-04-22T16:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5NTE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE5MjExOQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413192119", "bodyText": "Rewriting to add numbers makes sense - as noted null is just because we need to pass something. This isn't really a thing raw AtlasDB users would think about as much, but I see how it's useful in ski product (though let's do that in a separate self-contained piece please)", "author": "jeremyk-91", "createdAt": "2020-04-22T17:50:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5NTE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEwMjc2MA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413102760", "bodyText": "Yeah, this is hopefully unnecessary.", "author": "jkozlowski", "createdAt": "2020-04-22T15:51:49Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java", "diffHunk": "@@ -70,12 +71,17 @@ static TransactionStarter create(LockLeaseService lockLeaseService, LockWatchEve\n     }\n \n     StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        try {\n-            return autobatcher.apply(null).get();\n-        } catch (ExecutionException e) {\n-            throw Throwables.throwUncheckedException(e.getCause());\n-        } catch (Throwable t) {\n-            throw Throwables.throwUncheckedException(t);\n+        return AtlasFutures.getUnchecked(autobatcher.apply(null));\n+    }\n+\n+    StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {\n+        try (StartIdentifiedAtlasDbTransactionResponseBatch.Builder batchBuilder =\n+                new StartIdentifiedAtlasDbTransactionResponseBatch.Builder(response ->\n+                        unlock(ImmutableSet.of(response.immutableTimestamp().getLock())))) {\n+            List<Void> inputs = IntStream.range(0, count).mapToObj($ -> (Void) null).collect(Collectors.toList());", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEwNTM4OQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413105389", "bodyText": "So in this class we call #getStartTransactionResponses which is obviously already batched. But it's implementation can call timelock multiple times, without any cleanup of resources between calls: @jeremyk-91 does StartIdentifiedAtlasDbTransactionResponse not require any cleanup if we fail mid batch in this method?", "author": "jkozlowski", "createdAt": "2020-04-22T15:55:15Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java", "diffHunk": "@@ -70,12 +71,17 @@ static TransactionStarter create(LockLeaseService lockLeaseService, LockWatchEve\n     }\n \n     StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        try {\n-            return autobatcher.apply(null).get();\n-        } catch (ExecutionException e) {\n-            throw Throwables.throwUncheckedException(e.getCause());\n-        } catch (Throwable t) {\n-            throw Throwables.throwUncheckedException(t);\n+        return AtlasFutures.getUnchecked(autobatcher.apply(null));\n+    }\n+\n+    StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {\n+        try (StartIdentifiedAtlasDbTransactionResponseBatch.Builder batchBuilder =\n+                new StartIdentifiedAtlasDbTransactionResponseBatch.Builder(response ->\n+                        unlock(ImmutableSet.of(response.immutableTimestamp().getLock())))) {\n+            List<Void> inputs = IntStream.range(0, count).mapToObj($ -> (Void) null).collect(Collectors.toList());\n+            autobatcher.applyBatch(inputs).forEach(\n+                    response -> batchBuilder.safeAddToBatch(() -> AtlasFutures.getUnchecked(response)));\n+            return batchBuilder.build();", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEyMTkyMw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413121923", "bodyText": "The purpose of the Batch class is that if this does fail midway, we will call unlock (hence the passing in of the closing callback on line 80), unless you are referring to something else?", "author": "Jolyon-S", "createdAt": "2020-04-22T16:16:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEwNTM4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIzMDExMA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413230110", "bodyText": "The timestamps are safe to drop on the floor, so the main thing we'd need to worry about here is the immutable timestamp lock, which you've handled.\nI think @jkozlowski is asking about the impl of the existing getStartTransactionResponses method.\nThis is a good spot, and a bit of a spicy one: that method has a bug, though it is mostly benign. It does forget to unlock locks it may have taken on its way to completion, but as it is is unlikely to actively cause problems beyond delaying targeted sweep by 20 seconds. The failure mode is of course batch 1 succeeding but not having enough transactions, and batch 2 failing. In this case we still hold the locks, but they haven't been registered in the lock refresher yet so they go away after the lock timeout (20 seconds).\nSo this should be fixed, and it's probably an interesting one to do separately, but probably not a massive priority.", "author": "jeremyk-91", "createdAt": "2020-04-22T18:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEwNTM4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczMTQ4Mw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413731483", "bodyText": "Cool, I added tracking for this, we'll fix this next.", "author": "jkozlowski", "createdAt": "2020-04-23T11:20:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEwNTM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEwNTg5Mw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413105893", "bodyText": "Again, batched only.", "author": "jkozlowski", "createdAt": "2020-04-22T15:55:50Z", "path": "lock-api-objects/src/main/java/com/palantir/lock/v2/TimelockService.java", "diffHunk": "@@ -53,6 +53,8 @@ default boolean isInitialized() {\n \n     WaitForLocksResponse waitForLocks(WaitForLocksRequest request);\n \n+    StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count);", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEwNzU1NA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413107554", "bodyText": "What's the cost of this #unlock call here, should it be batched?", "author": "jkozlowski", "createdAt": "2020-04-22T15:57:55Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java", "diffHunk": "@@ -70,12 +71,17 @@ static TransactionStarter create(LockLeaseService lockLeaseService, LockWatchEve\n     }\n \n     StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        try {\n-            return autobatcher.apply(null).get();\n-        } catch (ExecutionException e) {\n-            throw Throwables.throwUncheckedException(e.getCause());\n-        } catch (Throwable t) {\n-            throw Throwables.throwUncheckedException(t);\n+        return AtlasFutures.getUnchecked(autobatcher.apply(null));\n+    }\n+\n+    StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {\n+        try (StartIdentifiedAtlasDbTransactionResponseBatch.Builder batchBuilder =\n+                new StartIdentifiedAtlasDbTransactionResponseBatch.Builder(response ->\n+                        unlock(ImmutableSet.of(response.immutableTimestamp().getLock())))) {", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczMDU0Nw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413730547", "bodyText": "This isn't entirely safe implementation: if someone later decides to add something other than the response.ifPresent below here, you'll leak. You should somehow tie the below line to the supplySafely", "author": "jkozlowski", "createdAt": "2020-04-23T11:18:40Z", "path": "lock-api-objects/src/main/java/com/palantir/lock/v2/StartIdentifiedAtlasDbTransactionResponseBatch.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.v2;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.util.ExceptionHandlingRunner;\n+\n+public final class StartIdentifiedAtlasDbTransactionResponseBatch implements AutoCloseable {\n+\n+    private final List<StartIdentifiedAtlasDbTransactionResponse> responses;\n+    private final Consumer<StartIdentifiedAtlasDbTransactionResponse> cleaner;\n+    private boolean closed;\n+    private final long minTimestamp;\n+    private final long maxTimestamp;\n+\n+    private StartIdentifiedAtlasDbTransactionResponseBatch(List<StartIdentifiedAtlasDbTransactionResponse> responses,\n+            Consumer<StartIdentifiedAtlasDbTransactionResponse> cleaner) {\n+        // This will only be called if the builder is built without any attempts at adding responses\n+        Preconditions.checkState(!responses.isEmpty(),\n+                \"Batch created with no transaction responses - something has gone wrong\");\n+        this.responses = responses;\n+        this.cleaner = cleaner;\n+        this.closed = false;\n+        List<Long> timestamps = responses\n+                .stream()\n+                .map(response -> response.immutableTimestamp().getImmutableTimestamp())\n+                .collect(Collectors.toList());\n+        this.minTimestamp = Collections.min(timestamps);\n+        this.maxTimestamp = Collections.max(timestamps);\n+    }\n+\n+    public int size() {\n+        return responses.size();\n+    }\n+\n+    public List<StartIdentifiedAtlasDbTransactionResponse> getResponses() {\n+        return responses;\n+    }\n+\n+    public <R> R successful(R value) {\n+        closed = true;\n+        return value;\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (!closed) {\n+            try (ExceptionHandlingRunner closer = new ExceptionHandlingRunner()) {\n+                responses.forEach(resource -> closer.runSafely(() -> cleaner.accept(resource)));\n+            }\n+        }\n+    }\n+\n+    public long getMinTimestamp() {\n+        return minTimestamp;\n+    }\n+\n+    public long getMaxTimestamp() {\n+        return maxTimestamp;\n+    }\n+\n+    public static class Builder implements AutoCloseable {\n+        private final List<StartIdentifiedAtlasDbTransactionResponse> responses = new ArrayList<>();\n+        private final ExceptionHandlingRunner runner = new ExceptionHandlingRunner();\n+        private final Consumer<StartIdentifiedAtlasDbTransactionResponse> cleaner;\n+\n+        public Builder(Consumer<StartIdentifiedAtlasDbTransactionResponse> cleaner) {\n+            this.cleaner = cleaner;\n+        }\n+\n+        public void safeAddToBatch(\n+                Supplier<StartIdentifiedAtlasDbTransactionResponse> supplier) {\n+            Optional<StartIdentifiedAtlasDbTransactionResponse> response = runner.supplySafely(supplier);", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc1OTgzOA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413759838", "bodyText": "As in:\nrunner.runSafely(() -> { BlahResponse x = supplier.get(); responses.add(x); });?", "author": "Jolyon-S", "createdAt": "2020-04-23T12:08:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczMDU0Nw=="}], "type": "inlineReview"}, {"oid": "9156f1ebdbdcfd0c72ddf066c5a6554dda67a867", "url": "https://github.com/palantir/atlasdb/commit/9156f1ebdbdcfd0c72ddf066c5a6554dda67a867", "message": "Merge branch 'develop' into fork-batch-txns", "committedDate": "2020-04-24T12:51:08Z", "type": "commit"}, {"oid": "d120274e287339ea54e597fd651295877fed39cf", "url": "https://github.com/palantir/atlasdb/commit/d120274e287339ea54e597fd651295877fed39cf", "message": "ga", "committedDate": "2020-04-27T09:10:48Z", "type": "commit"}, {"oid": "6a02f39ddcdb8c42096bc40565dd04254a9370dd", "url": "https://github.com/palantir/atlasdb/commit/6a02f39ddcdb8c42096bc40565dd04254a9370dd", "message": "perform some cleanup", "committedDate": "2020-04-27T09:26:15Z", "type": "commit"}, {"oid": "e121494be4138788db21c4511f9837eb8feabb6b", "url": "https://github.com/palantir/atlasdb/commit/e121494be4138788db21c4511f9837eb8feabb6b", "message": "move in right direction", "committedDate": "2020-04-28T09:58:31Z", "type": "commit"}, {"oid": "45f48e328d044b8d31779b9af4a4d37e38cdd179", "url": "https://github.com/palantir/atlasdb/commit/45f48e328d044b8d31779b9af4a4d37e38cdd179", "message": "change everything", "committedDate": "2020-04-28T13:45:06Z", "type": "commit"}, {"oid": "d0107d6a57b2bb4aacf42fbfcf99ce74342fcd09", "url": "https://github.com/palantir/atlasdb/commit/d0107d6a57b2bb4aacf42fbfcf99ce74342fcd09", "message": "sort of works", "committedDate": "2020-04-28T14:13:11Z", "type": "commit"}, {"oid": "888ccfd9638a9e56fb458677e18a683725c674b0", "url": "https://github.com/palantir/atlasdb/commit/888ccfd9638a9e56fb458677e18a683725c674b0", "message": "considerable cleanup", "committedDate": "2020-04-28T14:43:33Z", "type": "commit"}, {"oid": "7ac1892cf5f0d36a6347e54e18442b6be74fff69", "url": "https://github.com/palantir/atlasdb/commit/7ac1892cf5f0d36a6347e54e18442b6be74fff69", "message": "remove imports on test", "committedDate": "2020-04-28T14:44:14Z", "type": "commit"}, {"oid": "87d34e92bb5d5939222674ecdba17f309e065903", "url": "https://github.com/palantir/atlasdb/commit/87d34e92bb5d5939222674ecdba17f309e065903", "message": "Re-tidy the javadoc", "committedDate": "2020-04-28T14:47:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1NjA1MQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417156051", "bodyText": "Test, will fixup later.", "author": "Jolyon-S", "createdAt": "2020-04-29T08:41:36Z", "path": "atlasdb-config/src/test/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockServiceTest.java", "diffHunk": "@@ -71,14 +72,28 @@ public void getFreshTimestampsShouldFail() {\n     @Test\n     public void startIdentifiedAtlasDbTransactionShouldFail() {\n         StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransactionResponse =\n-                StartIdentifiedAtlasDbTransactionResponse.of(LOCK_IMMUTABLE_TIMESTAMP_RESPONSE,\n-                        TimestampAndPartition.of(1L, 0));\n+                makeResponse(1L);\n \n-        when(rawTimelockService.startIdentifiedAtlasDbTransaction())\n-                .thenReturn(startIdentifiedAtlasDbTransactionResponse);\n+        when(rawTimelockService.startIdentifiedAtlasDbTransactionBatch(1))\n+                .thenReturn(ImmutableList.of(startIdentifiedAtlasDbTransactionResponse));\n \n-        assertThrowsOnSecondCall(() -> timelockService.startIdentifiedAtlasDbTransaction());\n+        assertThrowsOnSecondCall(() -> timelockService.startIdentifiedAtlasDbTransactionBatch(1));\n     }\n+//", "originalCommit": "87d34e92bb5d5939222674ecdba17f309e065903", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "02037f646df11b598a216b87c26e980b37f82713", "url": "https://github.com/palantir/atlasdb/commit/02037f646df11b598a216b87c26e980b37f82713", "message": "Remove old method", "committedDate": "2020-04-29T08:43:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1ODQyNQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417158425", "bodyText": "The interesting thing here is that I've moved away from doing the approach requiring a specialised object, and I believe the reason it is OK to do so is:\n\nThe batch will either be in one piece from TransactionStarter or it won't (and therefore will have thrown itself);\nIf we fail mid-batch, we still unlock all of them - and there is only a single call, so we don't have to handle cases where the closing itself fails midway, because it either fails or succeeds.", "author": "Jolyon-S", "createdAt": "2020-04-29T08:45:29Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -163,29 +168,52 @@ protected boolean shouldStopRetrying(int numTimesFailed) {\n \n     @Override\n     public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition) {\n-        StartIdentifiedAtlasDbTransactionResponse transactionResponse\n-                = timelockService.startIdentifiedAtlasDbTransaction();\n+        return Iterables.getOnlyElement(setupRunTaskBatchWithConditionThrowOnConflict(ImmutableList.of(condition)));\n+    }\n+\n+    @Override\n+    public List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n+            List<PreCommitCondition> conditions) {\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses =\n+                timelockService.startIdentifiedAtlasDbTransactionBatch(conditions.size());\n         try {\n-            LockToken immutableTsLock = transactionResponse.immutableTimestamp().getLock();\n-            long immutableTs = transactionResponse.immutableTimestamp().getImmutableTimestamp();\n-            recordImmutableTimestamp(immutableTs);\n-\n-            cleaner.punch(transactionResponse.startTimestampAndPartition().timestamp());\n-            Supplier<Long> startTimestampSupplier = Suppliers.ofInstance(\n-                    transactionResponse.startTimestampAndPartition().timestamp());\n-\n-            Transaction transaction = createTransaction(\n-                    immutableTs,\n-                    startTimestampSupplier,\n-                    immutableTsLock,\n-                    condition);\n-            return TransactionAndImmutableTsLock.of(transaction, immutableTsLock);\n-        } catch (Throwable e) {\n-            timelockService.tryUnlock(ImmutableSet.of(transactionResponse.immutableTimestamp().getLock()));\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n+            return wrapResponseBatch(conditions, responses);\n+        } catch (Throwable t) {\n+            timelockService.tryUnlock(\n+                    responses.stream()\n+                            .map(response -> response.immutableTimestamp().getLock())\n+                            .collect(Collectors.toSet()));\n+            throw Throwables.rewrapAndThrowUncheckedException(t);", "originalCommit": "87d34e92bb5d5939222674ecdba17f309e065903", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5d9751180ad9c90656bbc59275048234162816c1", "url": "https://github.com/palantir/atlasdb/commit/5d9751180ad9c90656bbc59275048234162816c1", "message": "Remove old method", "committedDate": "2020-04-29T08:46:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE2MTM2Mw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417161363", "bodyText": "This code is a bit messy, for sure - but more a proof of concept of how it would work.\nShould definitely go in its own PR.", "author": "Jolyon-S", "createdAt": "2020-04-29T08:50:26Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java", "diffHunk": "@@ -138,16 +131,21 @@ public void close() {\n     }\n \n     @VisibleForTesting\n-    static Consumer<List<BatchElement<Void, StartIdentifiedAtlasDbTransactionResponse>>> consumer(\n+    static Consumer<List<BatchElement<Integer, List<StartIdentifiedAtlasDbTransactionResponse>>>> consumer(\n             LockLeaseService lockLeaseService, LockWatchEventCache lockWatchEventCache) {\n         return batch -> {\n-            int numTransactions = batch.size();\n+            int numTransactions = batch.stream().map(BatchElement::argument).reduce(0, Integer::sum);\n \n             List<StartIdentifiedAtlasDbTransactionResponse> startTransactionResponses =\n                     getStartTransactionResponses(lockLeaseService, lockWatchEventCache, numTransactions);\n \n-            for (int i = 0; i < numTransactions; i++) {\n-                batch.get(i).result().set(startTransactionResponses.get(i));\n+            int start = 0;\n+            int end;\n+            for (BatchElement<Integer, List<StartIdentifiedAtlasDbTransactionResponse>> batchElement\n+                    : batch) {\n+                end = start + batchElement.argument();\n+                batchElement.result().set(startTransactionResponses.subList(start, end));\n+                start = end;", "originalCommit": "5d9751180ad9c90656bbc59275048234162816c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE2MTk4Ng==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417161986", "bodyText": "Again, this is now a single call, so there is no handling for what happens if there is a failure half-way through closing, as such a failure cannot occur.", "author": "Jolyon-S", "createdAt": "2020-04-29T08:51:27Z", "path": "lock-impl/src/main/java/com/palantir/lock/impl/LegacyTimelockService.java", "diffHunk": "@@ -107,15 +109,17 @@ public LockImmutableTimestampResponse lockImmutableTimestamp() {\n     }\n \n     @Override\n-    public StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        LockImmutableTimestampResponse immutableTimestamp = lockImmutableTimestamp();\n+    public List<StartIdentifiedAtlasDbTransactionResponse> startIdentifiedAtlasDbTransactionBatch(int count) {\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses = new ArrayList<>();\n         try {\n-            return StartIdentifiedAtlasDbTransactionResponse.of(\n-                    immutableTimestamp,\n-                    TimestampAndPartition.of(getFreshTimestamp(), 0));\n+            IntStream.range(0, count).forEach(\n+                    $ -> responses.add(StartIdentifiedAtlasDbTransactionResponse.of(lockImmutableTimestamp(),\n+                            TimestampAndPartition.of(getFreshTimestamp(), 0))));\n+            return responses;\n         } catch (RuntimeException | Error throwable) {\n             try {\n-                unlock(ImmutableSet.of(immutableTimestamp.getLock()));\n+                unlock(responses.stream().map(response -> response.immutableTimestamp().getLock()).collect(\n+                        Collectors.toSet()));", "originalCommit": "5d9751180ad9c90656bbc59275048234162816c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dd3f34c50b9fe549b1ca67fe1c4be3a361686af7", "url": "https://github.com/palantir/atlasdb/commit/dd3f34c50b9fe549b1ca67fe1c4be3a361686af7", "message": "Small cleanup", "committedDate": "2020-04-29T10:40:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIzOTI5Ng==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417239296", "bodyText": "Haven't looked at puncher in a while, so unclear if you can do this once for the whole batch same as immutable timestamp.", "author": "jkozlowski", "createdAt": "2020-04-29T11:17:37Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -162,27 +168,40 @@ protected boolean shouldStopRetrying(int numTimesFailed) {\n     }\n \n     @Override\n-    public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition) {\n-        StartIdentifiedAtlasDbTransactionResponse transactionResponse\n-                = timelockService.startIdentifiedAtlasDbTransaction();\n+    public List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n+            List<PreCommitCondition> conditions) {\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses =\n+                timelockService.startIdentifiedAtlasDbTransactionBatch(conditions.size());\n         try {\n-            LockToken immutableTsLock = transactionResponse.immutableTimestamp().getLock();\n-            long immutableTs = transactionResponse.immutableTimestamp().getImmutableTimestamp();\n+            long immutableTs = Collections.max(responses.stream()\n+                    .map(response -> response.immutableTimestamp().getImmutableTimestamp())\n+                    .collect(Collectors.toList()));\n             recordImmutableTimestamp(immutableTs);\n \n-            cleaner.punch(transactionResponse.startTimestampAndPartition().timestamp());\n-            Supplier<Long> startTimestampSupplier = Suppliers.ofInstance(\n-                    transactionResponse.startTimestampAndPartition().timestamp());\n-\n-            Transaction transaction = createTransaction(\n-                    immutableTs,\n-                    startTimestampSupplier,\n-                    immutableTsLock,\n-                    condition);\n-            return TransactionAndImmutableTsLock.of(transaction, immutableTsLock);\n-        } catch (Throwable e) {\n-            timelockService.tryUnlock(ImmutableSet.of(transactionResponse.immutableTimestamp().getLock()));\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n+            return Streams.zip(\n+                    responses.stream(),\n+                    conditions.stream(),\n+                    (response, condition) -> {\n+                        LockToken immutableTsLock = response.immutableTimestamp().getLock();\n+                        cleaner.punch(response.startTimestampAndPartition().timestamp());", "originalCommit": "dd3f34c50b9fe549b1ca67fe1c4be3a361686af7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI4MzUxNw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417283517", "bodyText": "From the javadoc:\n * Indicate that the given timestamp has just been created. This must be called frequently\n * (preferably on each transaction commit) so that the Cleaner can keep track of the\n * wall-clock/timestamp mapping. If it is never called, semantically nothing goes wrong, but the\n * sweeper won't sweep, since it cannot know what things are old enough to be swept.\n\nI interpret this as something we could conceivably do once per batch. @jeremyk-91 to sanity check that.", "author": "Jolyon-S", "createdAt": "2020-04-29T12:41:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIzOTI5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1MjUwMw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418552503", "bodyText": "Once per batch is fine, yep. Right now this is being called on every element right? I'd suggest we move it out and stick it next to the recordImmutableTimestamp", "author": "jeremyk-91", "createdAt": "2020-05-01T13:58:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIzOTI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIzOTcyOA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417239728", "bodyText": "I quite like this, it's just an unwrapping and you're done. You could have a private method for setup*, but I'm not fussed either way.", "author": "jkozlowski", "createdAt": "2020-04-29T11:18:27Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -153,7 +158,8 @@ protected boolean shouldStopRetrying(int numTimesFailed) {\n         checkOpen();\n         try {\n             TransactionAndImmutableTsLock txAndLock =\n-                    runTimed(() -> setupRunTaskWithConditionThrowOnConflict(condition), \"setupTask\");\n+                    runTimed(() -> Iterables.getOnlyElement(\n+                            setupRunTaskBatchWithConditionThrowOnConflict(ImmutableList.of(condition))), \"setupTask\");", "originalCommit": "dd3f34c50b9fe549b1ca67fe1c4be3a361686af7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0MDI4NQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417240285", "bodyText": "You need to propagate the count?", "author": "jkozlowski", "createdAt": "2020-04-29T11:19:35Z", "path": "lock-api/src/main/java/com/palantir/lock/client/ProfilingTimelockService.java", "diffHunk": "@@ -112,8 +113,8 @@ public LockImmutableTimestampResponse lockImmutableTimestamp() {\n     }\n \n     @Override\n-    public StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        return runTaskTimed(\"startIdentifiedAtlasDbTransaction\", delegate::startIdentifiedAtlasDbTransaction);\n+    public List<StartIdentifiedAtlasDbTransactionResponse> startIdentifiedAtlasDbTransactionBatch(int count) {\n+        return runTaskTimed(\"startIdentifiedAtlasDbTransactionBatch\", () -> delegate.startIdentifiedAtlasDbTransactionBatch(1));", "originalCommit": "dd3f34c50b9fe549b1ca67fe1c4be3a361686af7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI5OTM4NA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417299384", "bodyText": "Good catch - autoreplaced the code and I obviously missed this.", "author": "Jolyon-S", "createdAt": "2020-04-29T13:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0MDI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0MTU3NA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417241574", "bodyText": "You're relying on this not throwing. I think it's fine in this refactoring, but need to track fixing this, same as the other bug.", "author": "jkozlowski", "createdAt": "2020-04-29T11:22:14Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TimeLockClient.java", "diffHunk": "@@ -88,16 +91,19 @@ public TimestampRange getFreshTimestamps(int numTimestampsRequested) {\n     @Override\n     public LockImmutableTimestampResponse lockImmutableTimestamp() {\n         LockImmutableTimestampResponse response = executeOnTimeLock(delegate::lockImmutableTimestamp);\n-        lockRefresher.registerLock(response.getLock());\n+        lockRefresher.registerLocks(ImmutableList.of(response.getLock()));\n         return response;\n     }\n \n     @Override\n-    public StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        StartIdentifiedAtlasDbTransactionResponse response = executeOnTimeLock(\n-                delegate::startIdentifiedAtlasDbTransaction);\n-        lockRefresher.registerLock(response.immutableTimestamp().getLock());\n-        return response;\n+    public List<StartIdentifiedAtlasDbTransactionResponse> startIdentifiedAtlasDbTransactionBatch(int count) {\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses = executeOnTimeLock(\n+                () -> delegate.startIdentifiedAtlasDbTransactionBatch(count));\n+        lockRefresher.registerLocks(responses", "originalCommit": "dd3f34c50b9fe549b1ca67fe1c4be3a361686af7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMwMTI1Mw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417301253", "bodyText": "Either the whole batch will return OK, or will throw as a whole - because of how the delegate does so. So yes, there is an outcome where half of the batch completes before throwing, and thus we have locks that we have not registeredor unlocked, but as noted above that is a separate issue.", "author": "Jolyon-S", "createdAt": "2020-04-29T13:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0MTU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0NDU4MA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417244580", "bodyText": "This is a bit sucky, since we're having to allocate Integers, while disruptor is optimised for that and reuses the actual instances of arguments, but I don't think it's worth obsessing about this. @jeremyk-91", "author": "jkozlowski", "createdAt": "2020-04-29T11:28:31Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java", "diffHunk": "@@ -45,38 +44,32 @@\n  * A service responsible for coalescing multiple start transaction calls into a single start transactions call. This\n  * service also handles creating {@link LockTokenShare}'s to enable multiple transactions sharing a single immutable\n  * timestamp.\n- *\n+ * <p>\n  * Callers of this class should use {@link #unlock(Set)} and {@link #refreshLockLeases(Set)} for returned lock tokens,\n  * rather than directly calling delegate lock service.\n  */\n final class TransactionStarter implements AutoCloseable {\n-    private final DisruptorAutobatcher<Void, StartIdentifiedAtlasDbTransactionResponse> autobatcher;\n+    private final DisruptorAutobatcher<Integer, List<StartIdentifiedAtlasDbTransactionResponse>> autobatcher;", "originalCommit": "dd3f34c50b9fe549b1ca67fe1c4be3a361686af7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1NTM3Mg==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418555372", "bodyText": "fair enough. I think we have metrics for this? If we look at the delta between the rpc clients and setupRunTask... and that explodes that should give us a hint that this might be relevant.", "author": "jeremyk-91", "createdAt": "2020-05-01T14:05:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0NDU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0NTY0NQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417245645", "bodyText": "Probably want a test what happens when you push 0 here. Also should throw on negative.", "author": "jkozlowski", "createdAt": "2020-04-29T11:30:48Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java", "diffHunk": "@@ -45,38 +44,32 @@\n  * A service responsible for coalescing multiple start transaction calls into a single start transactions call. This\n  * service also handles creating {@link LockTokenShare}'s to enable multiple transactions sharing a single immutable\n  * timestamp.\n- *\n+ * <p>\n  * Callers of this class should use {@link #unlock(Set)} and {@link #refreshLockLeases(Set)} for returned lock tokens,\n  * rather than directly calling delegate lock service.\n  */\n final class TransactionStarter implements AutoCloseable {\n-    private final DisruptorAutobatcher<Void, StartIdentifiedAtlasDbTransactionResponse> autobatcher;\n+    private final DisruptorAutobatcher<Integer, List<StartIdentifiedAtlasDbTransactionResponse>> autobatcher;\n     private final LockLeaseService lockLeaseService;\n \n     private TransactionStarter(\n-            DisruptorAutobatcher<Void, StartIdentifiedAtlasDbTransactionResponse> autobatcher,\n+            DisruptorAutobatcher<Integer, List<StartIdentifiedAtlasDbTransactionResponse>> autobatcher,\n             LockLeaseService lockLeaseService) {\n         this.autobatcher = autobatcher;\n         this.lockLeaseService = lockLeaseService;\n     }\n \n     static TransactionStarter create(LockLeaseService lockLeaseService, LockWatchEventCache lockWatchEventCache) {\n-        DisruptorAutobatcher<Void, StartIdentifiedAtlasDbTransactionResponse> autobatcher = Autobatchers\n+        DisruptorAutobatcher<Integer, List<StartIdentifiedAtlasDbTransactionResponse>> autobatcher = Autobatchers\n                 .independent(consumer(lockLeaseService, lockWatchEventCache))\n                 .safeLoggablePurpose(\"transaction-starter\")\n                 .build();\n         return new TransactionStarter(autobatcher,\n                 lockLeaseService);\n     }\n \n-    StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        try {\n-            return autobatcher.apply(null).get();\n-        } catch (ExecutionException e) {\n-            throw Throwables.throwUncheckedException(e.getCause());\n-        } catch (Throwable t) {\n-            throw Throwables.throwUncheckedException(t);\n-        }\n+    List<StartIdentifiedAtlasDbTransactionResponse> startIdentifiedAtlasDbTransactionBatch(int count) {", "originalCommit": "dd3f34c50b9fe549b1ca67fe1c4be3a361686af7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0NjMyMQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417246321", "bodyText": "Hmm, just think very carefully about what this subList does here. @jeremyk-91", "author": "jkozlowski", "createdAt": "2020-04-29T11:32:04Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java", "diffHunk": "@@ -138,16 +131,20 @@ public void close() {\n     }\n \n     @VisibleForTesting\n-    static Consumer<List<BatchElement<Void, StartIdentifiedAtlasDbTransactionResponse>>> consumer(\n+    static Consumer<List<BatchElement<Integer, List<StartIdentifiedAtlasDbTransactionResponse>>>> consumer(\n             LockLeaseService lockLeaseService, LockWatchEventCache lockWatchEventCache) {\n         return batch -> {\n-            int numTransactions = batch.size();\n+            int numTransactions = batch.stream().map(BatchElement::argument).reduce(0, Integer::sum);\n \n             List<StartIdentifiedAtlasDbTransactionResponse> startTransactionResponses =\n                     getStartTransactionResponses(lockLeaseService, lockWatchEventCache, numTransactions);\n \n-            for (int i = 0; i < numTransactions; i++) {\n-                batch.get(i).result().set(startTransactionResponses.get(i));\n+            int start = 0;\n+            for (BatchElement<Integer, List<StartIdentifiedAtlasDbTransactionResponse>> batchElement\n+                    : batch) {\n+                int end = start + batchElement.argument();\n+                batchElement.result().set(startTransactionResponses.subList(start, end));", "originalCommit": "dd3f34c50b9fe549b1ca67fe1c4be3a361686af7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMxODM2MQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417318361", "bodyText": "Yes, since all of the returned lists are a view of the original list startTransactionResponses, we can get ConcurrentModificationExceptions or other such things if the lists returned are abused (i.e. elements are removed). I don't think this will be a problem given that we don't do that, but we could change this to return a fresh list for each result if it is a concern.", "author": "Jolyon-S", "createdAt": "2020-04-29T13:35:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0NjMyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU4Njk1NA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418586954", "bodyText": "@Jolyon-S The tricky thing here is that subList keeps a reference to the original list, so the entire response will remain live in terms of memory as long as any consumer keeps a reference to their chunk of the list. This looks like it would probably be safe from tracing through the code, but I'd prefer to just create a new list in case there's something silly around threads contending over updateAndGet() or things like that.", "author": "jeremyk-91", "createdAt": "2020-05-01T15:17:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0NjMyMQ=="}], "type": "inlineReview"}, {"oid": "51247c4974389fcc607ea4d59310e5167c5037f7", "url": "https://github.com/palantir/atlasdb/commit/51247c4974389fcc607ea4d59310e5167c5037f7", "message": "Fix javadoc", "committedDate": "2020-04-29T12:30:47Z", "type": "commit"}, {"oid": "5567bfe2179f26c218bf3e47b3e6a116b3d8cc70", "url": "https://github.com/palantir/atlasdb/commit/5567bfe2179f26c218bf3e47b3e6a116b3d8cc70", "message": "Fix batching case in TimestampCorroboratingTimelockServiceTest", "committedDate": "2020-04-29T12:33:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI4NjY1NA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417286654", "bodyText": "Just want to check that this simple substitution still makes sense in the context above.", "author": "Jolyon-S", "createdAt": "2020-04-29T12:46:55Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/service/WriteBatchingTransactionService.java", "diffHunk": "@@ -123,7 +123,7 @@ public void close() {\n      *\n      * Retrying does theoretically mean that in the worst case with N transactions in our batch, we may actually\n      * require N calls to the database, though this is extremely unlikely especially because of the semantics of\n-     * {@link TimelockService#startIdentifiedAtlasDbTransaction()}.\n+     * {@link TimelockService#startIdentifiedAtlasDbTransactionBatch(int)}.", "originalCommit": "dd3f34c50b9fe549b1ca67fe1c4be3a361686af7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1MzkwOQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418553909", "bodyText": "Yep, still correct.", "author": "jeremyk-91", "createdAt": "2020-05-01T14:02:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI4NjY1NA=="}], "type": "inlineReview"}, {"oid": "46d18f17206d8bb6faf4a365c1da9e3de0ff6dc9", "url": "https://github.com/palantir/atlasdb/commit/46d18f17206d8bb6faf4a365c1da9e3de0ff6dc9", "message": "Continue fixing up tests", "committedDate": "2020-04-29T13:02:27Z", "type": "commit"}, {"oid": "59ffc1087acd754fad98efa60b7b4867c064c7bb", "url": "https://github.com/palantir/atlasdb/commit/59ffc1087acd754fad98efa60b7b4867c064c7bb", "message": "Cleanup lock refresher test", "committedDate": "2020-04-29T13:06:42Z", "type": "commit"}, {"oid": "0499cf880c992e6f31d37fed6fb46f356085fa47", "url": "https://github.com/palantir/atlasdb/commit/0499cf880c992e6f31d37fed6fb46f356085fa47", "message": "Properly propogate the param", "committedDate": "2020-04-29T13:07:52Z", "type": "commit"}, {"oid": "b665cf78fc6b33d4ef3f0a2aed301a955c410548", "url": "https://github.com/palantir/atlasdb/commit/b665cf78fc6b33d4ef3f0a2aed301a955c410548", "message": "Fixup tests", "committedDate": "2020-04-29T13:46:51Z", "type": "commit"}, {"oid": "2388c8cee27ad91f59615ca624b7c3b5a3bb8905", "url": "https://github.com/palantir/atlasdb/commit/2388c8cee27ad91f59615ca624b7c3b5a3bb8905", "message": "Remove nullable", "committedDate": "2020-04-29T13:47:31Z", "type": "commit"}, {"oid": "6f30fb495021baa63f8a8545ab020081fd5a7fe5", "url": "https://github.com/palantir/atlasdb/commit/6f30fb495021baa63f8a8545ab020081fd5a7fe5", "message": "Update to use new method", "committedDate": "2020-04-29T13:48:43Z", "type": "commit"}, {"oid": "be8d3608c8ecc887c1db055b6f971edf3cd40951", "url": "https://github.com/palantir/atlasdb/commit/be8d3608c8ecc887c1db055b6f971edf3cd40951", "message": "Improve testing", "committedDate": "2020-04-29T13:58:38Z", "type": "commit"}, {"oid": "2b21adc878d5b6cf5b8f6e2dad881ad1b51873b1", "url": "https://github.com/palantir/atlasdb/commit/2b21adc878d5b6cf5b8f6e2dad881ad1b51873b1", "message": "Remove another non-batched endpoint", "committedDate": "2020-04-29T14:06:11Z", "type": "commit"}, {"oid": "65a20ac51ffa1f1425ee280d5db66fae718ab517", "url": "https://github.com/palantir/atlasdb/commit/65a20ac51ffa1f1425ee280d5db66fae718ab517", "message": "Yet another aggressive auto format on this particular paragraph", "committedDate": "2020-04-29T14:06:44Z", "type": "commit"}, {"oid": "6935f4685d406b497ec0cd97cd24ced3883da29c", "url": "https://github.com/palantir/atlasdb/commit/6935f4685d406b497ec0cd97cd24ced3883da29c", "message": "merge in develop", "committedDate": "2020-04-30T08:17:37Z", "type": "commit"}, {"oid": "efffdec6af871ab339e4255a17b74e43609d3703", "url": "https://github.com/palantir/atlasdb/commit/efffdec6af871ab339e4255a17b74e43609d3703", "message": "style", "committedDate": "2020-04-30T08:19:37Z", "type": "commit"}, {"oid": "f8178f966f1cafe5d1a34998460775eb5f4e1f4e", "url": "https://github.com/palantir/atlasdb/commit/f8178f966f1cafe5d1a34998460775eb5f4e1f4e", "message": "Checkstyle", "committedDate": "2020-04-30T09:18:06Z", "type": "commit"}, {"oid": "740679248ef4216ce1659287f686d6612efb579d", "url": "https://github.com/palantir/atlasdb/commit/740679248ef4216ce1659287f686d6612efb579d", "message": "Get start timestamp instead of immutable timestamp", "committedDate": "2020-04-30T09:22:22Z", "type": "commit"}, {"oid": "8fb4294b079544e18d053327970bdf337fcfc799", "url": "https://github.com/palantir/atlasdb/commit/8fb4294b079544e18d053327970bdf337fcfc799", "message": "Fix small bug in unlocking in legacy timelock service", "committedDate": "2020-04-30T09:45:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1MDAzNQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418550035", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * be vvalid, the transaction must be committed, preferably by calling\n          \n          \n            \n                 * be valid, the transaction must be committed, preferably by calling", "author": "jeremyk-91", "createdAt": "2020-05-01T13:52:50Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java", "diffHunk": "@@ -418,24 +419,24 @@ default LockWatchManager getLockWatchManager() {\n     void registerClosingCallback(Runnable closingCallback);\n \n     /**\n-     * This method can be used for direct control of a transaction's life cycle. For example, if the work done in\n-     * the transaction is interactive and cannot be expressed as a {@link TransactionTask} ahead of time, this method\n-     * allows for a long lived transaction object. For the any data read or written to the transaction to be valid,\n-     * the transaction must be committed, preferably by calling\n+     * This method can be used for direct control over the lifecycle of a batch of transactions. For example, if the\n+     * work done in each given transaction is interactive and cannot be expressed as a {@link TransactionTask} ahead of\n+     * time, this method allows for a long lived transaction object. For any data read or written to the transaction to\n+     * be vvalid, the transaction must be committed, preferably by calling", "originalCommit": "8fb4294b079544e18d053327970bdf337fcfc799", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1MTQxOA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418551418", "bodyText": "Are there any conditions on the ordering of transactions responses returned? Might be good to say what's allowed/not in case downstream users decide that looking at the first or last entry in the list to find some information", "author": "jeremyk-91", "createdAt": "2020-05-01T13:55:56Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java", "diffHunk": "@@ -418,24 +419,24 @@ default LockWatchManager getLockWatchManager() {\n     void registerClosingCallback(Runnable closingCallback);\n \n     /**\n-     * This method can be used for direct control of a transaction's life cycle. For example, if the work done in\n-     * the transaction is interactive and cannot be expressed as a {@link TransactionTask} ahead of time, this method\n-     * allows for a long lived transaction object. For the any data read or written to the transaction to be valid,\n-     * the transaction must be committed, preferably by calling\n+     * This method can be used for direct control over the lifecycle of a batch of transactions. For example, if the\n+     * work done in each given transaction is interactive and cannot be expressed as a {@link TransactionTask} ahead of\n+     * time, this method allows for a long lived transaction object. For any data read or written to the transaction to\n+     * be vvalid, the transaction must be committed, preferably by calling\n      * {@link #finishRunTaskWithLockThrowOnConflict(TransactionAndImmutableTsLock, TransactionTask)} to also perform\n-     * additional cleanup.\n+     * additional cleanup. Note that this does not clean up the pre commit condition associated with that task.\n      *\n+     * @return a batch of transactions with associated immutable timestamp locks\n      * @deprecated Similar functionality will exist, but this method is likely to change in the future\n-     *\n-     * @return the transaction and associated immutable timestamp lock for the task\n      */\n     @Deprecated\n     @Timed\n-    TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition);\n+    List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(", "originalCommit": "8fb4294b079544e18d053327970bdf337fcfc799", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU5MjQ0Mw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418592443", "bodyText": "hmmm, feels to me the interface is pretty simple, the ordering should absolutely match; so at index 1, returned transaction should be matched to the precondition at index 1 in the request list.", "author": "jkozlowski", "createdAt": "2020-05-01T15:29:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1MTQxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0OTM2Mw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r420049363", "bodyText": "I think I meant more in terms of the timestamps (e.g. can you assume response[0].getTimestamp() is the min?)", "author": "jeremyk-91", "createdAt": "2020-05-05T11:49:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1MTQxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA1MzU4NQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r420053585", "bodyText": "Ah, I see what you mean. I don't think we should make that assumption anywhere (although I suspect, looking through the code at TransactionStarter, that it is the case anyway). Perhaps a bit of additional javadoc would cover this?", "author": "Jolyon-S", "createdAt": "2020-05-05T11:57:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1MTQxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA2MTEzOA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r420061138", "bodyText": "Yeah, let's say that we can't assume that then", "author": "jeremyk-91", "createdAt": "2020-05-05T12:12:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1MTQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1MzQ5NQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418553495", "bodyText": "I guess this is fine - but depends on implementation, most of the time they are all going to be the same I think?", "author": "jeremyk-91", "createdAt": "2020-05-01T14:00:56Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -162,27 +168,43 @@ protected boolean shouldStopRetrying(int numTimesFailed) {\n     }\n \n     @Override\n-    public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition) {\n-        StartIdentifiedAtlasDbTransactionResponse transactionResponse\n-                = timelockService.startIdentifiedAtlasDbTransaction();\n+    public List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n+            List<PreCommitCondition> conditions) {\n+        if (conditions.isEmpty()) {\n+            return ImmutableList.of();\n+        }\n+\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses =\n+                timelockService.startIdentifiedAtlasDbTransactionBatch(conditions.size());\n         try {\n-            LockToken immutableTsLock = transactionResponse.immutableTimestamp().getLock();\n-            long immutableTs = transactionResponse.immutableTimestamp().getImmutableTimestamp();\n+            long immutableTs = Collections.max(responses.stream()\n+                    .map(response -> response.immutableTimestamp().getImmutableTimestamp())", "originalCommit": "8fb4294b079544e18d053327970bdf337fcfc799", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMxMjgwNg==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r419312806", "bodyText": "I was assuming that it is possible for the batch to be made out of several ConjureStartTransactionsResponses, and therefore there being a possibility that the immutable timestamp differs, but if it is not a problem then we could equally just take the first element's value.", "author": "Jolyon-S", "createdAt": "2020-05-04T09:28:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1MzQ5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA2NDAyOA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r420064028", "bodyText": "Makes sense, let's just stick with this. We don't actually need the most up to date value for the tracker here (it's only for metrics), a good approximation is fine, but there isn't a regression here.", "author": "jeremyk-91", "createdAt": "2020-05-05T12:18:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1MzQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1Njg5Mw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418556893", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        int numTransactions = batch.stream().map(BatchElement::argument).reduce(0, Integer::sum);\n          \n          \n            \n                        int numTransactions = batch.stream().mapToInt(BatchElement::argument).reduce(0, Integer::sum);\n          \n      \n    \n    \n  \n\nThis does a bunch of unnecessary boxing. I think you can do mapToInt(BatchElement::argument) instead of just map().", "author": "jeremyk-91", "createdAt": "2020-05-01T14:09:13Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java", "diffHunk": "@@ -138,16 +133,20 @@ public void close() {\n     }\n \n     @VisibleForTesting\n-    static Consumer<List<BatchElement<Void, StartIdentifiedAtlasDbTransactionResponse>>> consumer(\n+    static Consumer<List<BatchElement<Integer, List<StartIdentifiedAtlasDbTransactionResponse>>>> consumer(\n             LockLeaseService lockLeaseService, LockWatchEventCache lockWatchEventCache) {\n         return batch -> {\n-            int numTransactions = batch.size();\n+            int numTransactions = batch.stream().map(BatchElement::argument).reduce(0, Integer::sum);", "originalCommit": "8fb4294b079544e18d053327970bdf337fcfc799", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU4NzU0Mw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418587543", "bodyText": "\u2764\ufe0f Nice!", "author": "jeremyk-91", "createdAt": "2020-05-01T15:18:26Z", "path": "lock-api/src/test/java/com/palantir/lock/client/TransactionStarterTest.java", "diffHunk": "@@ -98,49 +101,99 @@ public void after() {\n     public void shouldDeriveStartTransactionResponseFromBatchedResponse_singleTransaction() {\n         ConjureStartTransactionsResponse startTransactionResponse = getStartTransactionResponse(12, 1);\n \n-        when(lockLeaseService.startTransactionsWithWatches(Optional.empty(), 1))\n-                .thenReturn(startTransactionResponse);\n-        StartIdentifiedAtlasDbTransactionResponse response = transactionStarter.startIdentifiedAtlasDbTransaction();\n+        when(lockLeaseService.startTransactionsWithWatches(Optional.empty(), 1)).thenReturn(startTransactionResponse);\n+        StartIdentifiedAtlasDbTransactionResponse response =\n+                Iterables.getOnlyElement(transactionStarter.startIdentifiedAtlasDbTransactionBatch(1));\n \n         assertDerivableFromBatchedResponse(response, startTransactionResponse);\n     }\n \n+    @Test\n+    public void shouldDeriveStartTransactionResponseBatchFromBatchedResponse_multipleTransactions() {\n+        ConjureStartTransactionsResponse batchResponse = getStartTransactionResponse(12, 5);\n+\n+        when(lockLeaseService.startTransactionsWithWatches(Optional.empty(), 5)).thenReturn(batchResponse);\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses =\n+                transactionStarter.startIdentifiedAtlasDbTransactionBatch(5);\n+\n+        assertThat(responses)\n+                .satisfies(TransactionStarterTest::assertThatStartTransactionResponsesAreUnique)\n+                .hasSize(5)\n+                .allSatisfy(startTxnResponse -> assertDerivableFromBatchedResponse(startTxnResponse, batchResponse));\n+    }\n+\n+    @Test\n+    public void shouldThrowWhenTryingToStartIllegalNumberOfTransactions() {\n+        assertThatThrownBy(() -> transactionStarter.startIdentifiedAtlasDbTransactionBatch(0))\n+                .isInstanceOf(SafeIllegalArgumentException.class)\n+                .hasMessage(\"Cannot start 0 or fewer transactions\");\n+    }\n+\n     @Test\n     public void shouldDeriveStartTransactionResponseFromBatchedResponse_multipleTransactions() {\n         ConjureStartTransactionsResponse batchResponse = getStartTransactionResponse(40, 3);\n         when(lockLeaseService.startTransactionsWithWatches(Optional.empty(), 3))\n                 .thenReturn(batchResponse);\n \n-        List<StartIdentifiedAtlasDbTransactionResponse> responses = requestBatches(3);\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses = requestSingularBatches(3);\n         assertThat(responses)\n                 .satisfies(TransactionStarterTest::assertThatStartTransactionResponsesAreUnique)\n                 .hasSize(3)\n                 .allSatisfy(startTxnResponse -> assertDerivableFromBatchedResponse(startTxnResponse, batchResponse));\n     }\n \n+    @Test\n+    public void shouldDeriveStartTransactionResponseFromBatchedResponse_nonTrivialBatchSize() {\n+        ConjureStartTransactionsResponse batchResponse = getStartTransactionResponse(40, 10);\n+        when(lockLeaseService.startTransactionsWithWatches(Optional.empty(), 10))\n+                .thenReturn(batchResponse);\n+\n+        ImmutableList<Integer> sizes = ImmutableList.of(2, 3, 4, 1);\n+        List<List<StartIdentifiedAtlasDbTransactionResponse>> responses = requestBatches(sizes);\n+        Streams.forEachPair(responses.stream(), sizes.stream(),\n+                (response, size) -> assertThat(response)\n+                        .hasSize(size)\n+                        .allSatisfy(startTxnResponse -> assertDerivableFromBatchedResponse(startTxnResponse,\n+                                batchResponse)));\n+\n+        assertThat(flattenResponses(responses)).satisfies(\n+                TransactionStarterTest::assertThatStartTransactionResponsesAreUnique);\n+    }", "originalCommit": "8fb4294b079544e18d053327970bdf337fcfc799", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU4ODA4NQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418588085", "bodyText": "good reuse here :)", "author": "jeremyk-91", "createdAt": "2020-05-01T15:19:36Z", "path": "timelock-server/src/integTest/java/com/palantir/atlasdb/timelock/AsyncTimelockServiceIntegrationTest.java", "diffHunk": "@@ -458,44 +458,49 @@ public void waitForLockRequestsAreIdempotent() {\n     @Test\n     public void startIdentifiedAtlasDbTransactionGivesUsTimestampsInSequence() {\n         StartIdentifiedAtlasDbTransactionResponse firstResponse =\n-                namespace.timelockService().startIdentifiedAtlasDbTransaction();\n+                startSingleTransaction(namespace.timelockService());\n         StartIdentifiedAtlasDbTransactionResponse secondResponse =\n-                namespace.timelockService().startIdentifiedAtlasDbTransaction();\n+                startSingleTransaction(namespace.timelockService());\n \n-        // Note that we technically cannot guarantee an ordering between the fresh timestamp on response 1 and the\n-        // immutable timestamp on response 2. Most of the time, we will have IT on response 2 = IT on response 1\n-        // < FT on response 1, as the lock token on response 1 has not expired yet. However, if we sleep for long\n-        // enough between the first and second call that the immutable timestamp lock expires, then\n-        // IT on response 2 > FT on response 1.\n-        assertThat(ImmutableList.of(\n-                firstResponse.immutableTimestamp().getImmutableTimestamp(),\n-                firstResponse.startTimestampAndPartition().timestamp(),\n-                secondResponse.startTimestampAndPartition().timestamp())).isSorted();\n-        assertThat(ImmutableList.of(\n-                firstResponse.immutableTimestamp().getImmutableTimestamp(),\n-                secondResponse.immutableTimestamp().getImmutableTimestamp(),\n-                secondResponse.startTimestampAndPartition().timestamp())).isSorted();\n+        assertThatStartIdentifiedTransactionResponseTimestampsInSequence(firstResponse, secondResponse);\n+    }\n+\n+    @Test\n+    public void startIdentifiedAtlasDbTransactionBatchGivesUsTimestampsInSequence() {\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses =\n+                namespace.timelockService().startIdentifiedAtlasDbTransactionBatch(2);\n+\n+        assertThatStartIdentifiedTransactionResponseTimestampsInSequence(responses.get(0), responses.get(1));\n     }\n \n     @Test\n     public void startIdentifiedAtlasDbTransactionGivesUsStartTimestampsInTheSamePartition() {\n         StartIdentifiedAtlasDbTransactionResponse firstResponse =\n-                namespace.timelockService().startIdentifiedAtlasDbTransaction();\n+                startSingleTransaction(namespace.timelockService());\n         StartIdentifiedAtlasDbTransactionResponse secondResponse =\n-                namespace.timelockService().startIdentifiedAtlasDbTransaction();\n+                startSingleTransaction(namespace.timelockService());\n \n-        assertThat(firstResponse.startTimestampAndPartition().partition())\n-                .isEqualTo(secondResponse.startTimestampAndPartition().partition());\n+        assertThatStartIdentifiedTransactionResponseTimestampsInSamePartition(firstResponse, secondResponse);\n+    }\n+\n+    @Test\n+    public void startIdentifiedAtlasDbTransactionBatchGivesUsStartTimestampsInTheSamePartition() {\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses =\n+                namespace.timelockService().startIdentifiedAtlasDbTransactionBatch(2);\n+\n+        assertThatStartIdentifiedTransactionResponseTimestampsInSamePartition(responses.get(0), responses.get(1));", "originalCommit": "8fb4294b079544e18d053327970bdf337fcfc799", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d0a5f0b201eee2a13121ebec5862eff042d5b4df", "url": "https://github.com/palantir/atlasdb/commit/d0a5f0b201eee2a13121ebec5862eff042d5b4df", "message": "Add unlock if failing mid-way through starting txns", "committedDate": "2020-05-01T15:25:38Z", "type": "commit"}, {"oid": "fd01a34f0fd44a7b497d99dd155b7ee8b87fdf7f", "url": "https://github.com/palantir/atlasdb/commit/fd01a34f0fd44a7b497d99dd155b7ee8b87fdf7f", "message": "Remove unused param", "committedDate": "2020-05-04T08:56:51Z", "type": "commit"}, {"oid": "9258d3b49ade78b5f409e45693f75a886db6c10c", "url": "https://github.com/palantir/atlasdb/commit/9258d3b49ade78b5f409e45693f75a886db6c10c", "message": "Fix method args", "committedDate": "2020-05-04T09:12:40Z", "type": "commit"}, {"oid": "b6dc3021301f1e55f115408138eab0e6de662c34", "url": "https://github.com/palantir/atlasdb/commit/b6dc3021301f1e55f115408138eab0e6de662c34", "message": "Nits from review", "committedDate": "2020-05-04T09:29:49Z", "type": "commit"}, {"oid": "012a0061912546ad0c09e8ce4925197a3d5b865a", "url": "https://github.com/palantir/atlasdb/commit/012a0061912546ad0c09e8ce4925197a3d5b865a", "message": "Add generated changelog entries", "committedDate": "2020-05-04T09:29:49Z", "type": "commit"}, {"oid": "aedfe92cdd40a18073233d403489e54ca3efdc63", "url": "https://github.com/palantir/atlasdb/commit/aedfe92cdd40a18073233d403489e54ca3efdc63", "message": "Fix bug when fail to register lock", "committedDate": "2020-05-04T10:43:43Z", "type": "commit"}, {"oid": "d3f0fe2ec976c34422f2bc5ba45b1dbe85ef12a2", "url": "https://github.com/palantir/atlasdb/commit/d3f0fe2ec976c34422f2bc5ba45b1dbe85ef12a2", "message": "Remove unnecessary diff", "committedDate": "2020-05-04T10:48:14Z", "type": "commit"}, {"oid": "a83408a2948cac9a8c9ce323154ca568843c8da1", "url": "https://github.com/palantir/atlasdb/commit/a83408a2948cac9a8c9ce323154ca568843c8da1", "message": "merge in fix-start-txn bug", "committedDate": "2020-05-04T12:37:14Z", "type": "commit"}, {"oid": "f159470ff8e11f9ee9eff7f837de49cd9c28456c", "url": "https://github.com/palantir/atlasdb/commit/f159470ff8e11f9ee9eff7f837de49cd9c28456c", "message": "merge in transaction starter fix", "committedDate": "2020-05-04T12:41:54Z", "type": "commit"}, {"oid": "5b12874f48c177cfbc9f47d9ad78de79ef734ec2", "url": "https://github.com/palantir/atlasdb/commit/5b12874f48c177cfbc9f47d9ad78de79ef734ec2", "message": "Merge branch 'develop' into fork-batch-txns", "committedDate": "2020-05-05T09:19:22Z", "type": "commit"}, {"oid": "00892feb28a67db48749bb287ed353046e5c2cd1", "url": "https://github.com/palantir/atlasdb/commit/00892feb28a67db48749bb287ed353046e5c2cd1", "message": "fix merge conflicts", "committedDate": "2020-05-05T09:25:59Z", "type": "commit"}, {"oid": "2bee6ba068054e2586147d8efab8f4a59aed06db", "url": "https://github.com/palantir/atlasdb/commit/2bee6ba068054e2586147d8efab8f4a59aed06db", "message": "Remove unused import", "committedDate": "2020-05-05T10:42:49Z", "type": "commit"}, {"oid": "4aeb3d2fa61c220c6a9be709b6b8c42813a96b8f", "url": "https://github.com/palantir/atlasdb/commit/4aeb3d2fa61c220c6a9be709b6b8c42813a96b8f", "message": "Add additional javadoc clarification", "committedDate": "2020-05-05T13:50:03Z", "type": "commit"}]}