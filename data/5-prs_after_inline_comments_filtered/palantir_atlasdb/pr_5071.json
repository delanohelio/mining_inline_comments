{"pr_number": 5071, "pr_title": "[Timelock Corruption]: Final Wiring part 1", "pr_createdAt": "2020-10-22T09:20:04Z", "pr_url": "https://github.com/palantir/atlasdb/pull/5071", "timeline": [{"oid": "2e0899101c3958b369530b0927e68bb1bf2c10a8", "url": "https://github.com/palantir/atlasdb/commit/2e0899101c3958b369530b0927e68bb1bf2c10a8", "message": "Wire through - part 1", "committedDate": "2020-10-22T09:10:39Z", "type": "commit"}, {"oid": "d5594fe0b14679eb55cdee28427720bbe6f2d67b", "url": "https://github.com/palantir/atlasdb/commit/d5594fe0b14679eb55cdee28427720bbe6f2d67b", "message": "Refactor", "committedDate": "2020-10-22T11:25:54Z", "type": "commit"}, {"oid": "9bd0d732e98fdf361bdc2233de454317ec970cb3", "url": "https://github.com/palantir/atlasdb/commit/9bd0d732e98fdf361bdc2233de454317ec970cb3", "message": "Fix + tests", "committedDate": "2020-10-22T14:57:05Z", "type": "commit"}, {"oid": "ddd99f2053a61a0d6f050e6b717b5875b45211de", "url": "https://github.com/palantir/atlasdb/commit/ddd99f2053a61a0d6f050e6b717b5875b45211de", "message": "Refactor", "committedDate": "2020-10-22T14:59:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI0MTkyMA==", "url": "https://github.com/palantir/atlasdb/pull/5071#discussion_r510241920", "bodyText": "this feels a bit weird (although maybe it's an Atlas thing?) - that is, using a List to represent two and exactly two distinct things here. I'd prefer if you just made a small Immutables to hold the local and remote, then you only need one field and can call something like corruptionDetectors.local() (although naturally this doesn't lend itself trivially to your streams).", "author": "Jolyon-S", "createdAt": "2020-10-22T15:11:13Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/CorruptionHealthCheck.java", "diffHunk": "@@ -16,16 +16,24 @@\n \n package com.palantir.timelock.corruption.detection;\n \n+import com.google.common.collect.ImmutableList;\n import java.util.List;\n \n public class CorruptionHealthCheck {\n-    private final List<CorruptionDetector> corruptionDetectors;\n+    private final LocalCorruptionDetector localCorruptionDetector;\n+    private final List<CorruptionDetector> localAndRemoteCorruptionDetectors;", "originalCommit": "ddd99f2053a61a0d6f050e6b717b5875b45211de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI4NzQ5OA==", "url": "https://github.com/palantir/atlasdb/pull/5071#discussion_r510287498", "bodyText": "Have a look at LocalAndRemotes? It's a bit more powerful than what you need here, but has a nice way of accessing all or specifically the local.", "author": "jeremyk-91", "createdAt": "2020-10-22T16:12:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI0MTkyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI0MjY3MQ==", "url": "https://github.com/palantir/atlasdb/pull/5071#discussion_r510242671", "bodyText": "nit: unnecessary diff.", "author": "Jolyon-S", "createdAt": "2020-10-22T15:12:18Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/LocalCorruptionDetector.java", "diffHunk": "@@ -31,46 +32,63 @@\n \n     private final ScheduledExecutorService executor = PTExecutors.newSingleThreadScheduledExecutor(\n             new NamedThreadFactory(CORRUPTION_DETECTOR_THREAD_PREFIX, true));\n+", "originalCommit": "ddd99f2053a61a0d6f050e6b717b5875b45211de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI0MzE2OQ==", "url": "https://github.com/palantir/atlasdb/pull/5071#discussion_r510243169", "bodyText": "I'm not really a fan of shootTimelock - it feels pretty ambiguous (particularly as this is a boolean!)", "author": "Jolyon-S", "createdAt": "2020-10-22T15:13:00Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/handle/JerseyCorruptionFilter.java", "diffHunk": "@@ -32,7 +32,7 @@ public JerseyCorruptionFilter(CorruptionHealthCheck healthCheck) {\n \n     @Override\n     public void filter(ContainerRequestContext requestContext) {\n-        if (!healthCheck.isHealthy()) {\n+        if (healthCheck.shootTimeLock()) {", "originalCommit": "ddd99f2053a61a0d6f050e6b717b5875b45211de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI4NjAxOA==", "url": "https://github.com/palantir/atlasdb/pull/5071#discussion_r510286018", "bodyText": "maybe shouldRejectRequests()? The impression I get if I come across a method like this is that it actually makes the server stop requests and returns true if successful/false if not", "author": "jeremyk-91", "createdAt": "2020-10-22T16:10:23Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/CorruptionDetector.java", "diffHunk": "@@ -17,5 +17,5 @@\n package com.palantir.timelock.corruption.detection;\n \n public interface CorruptionDetector {\n-    boolean hasDetectedCorruption();\n+    boolean shootTimeLock();", "originalCommit": "ddd99f2053a61a0d6f050e6b717b5875b45211de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI5MDM4Mw==", "url": "https://github.com/palantir/atlasdb/pull/5071#discussion_r510290383", "bodyText": "Let's name this based on what the map actually does: namespacesExhibitingViolations or something like this.", "author": "jeremyk-91", "createdAt": "2020-10-22T16:16:31Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java", "diffHunk": "@@ -36,15 +43,49 @@ private HistoryAnalyzer() {\n         // do not create instance of this class\n     }\n \n+    public static CorruptionHealthReport corruptionHealthReportForHistory(\n+            List<CompletePaxosHistoryForNamespaceAndUseCase> history) {\n+\n+        Map<NamespaceAndUseCase, CorruptionCheckViolation> namespaceAndUseCaseCorruptionCheckViolationMap =\n+                history.stream()\n+                        .collect(Collectors.toMap(\n+                                HistoryAnalyzer::extractNamespaceAndUseCase,\n+                                HistoryAnalyzer::violatedCorruptionChecksForNamespaceAndUseCase));\n+\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> entryEntrySetMultimap = KeyedStream.stream(", "originalCommit": "ddd99f2053a61a0d6f050e6b717b5875b45211de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI5NDEzMg==", "url": "https://github.com/palantir/atlasdb/pull/5071#discussion_r510294132", "bodyText": "I think this should return List or some Collection given the name?", "author": "jeremyk-91", "createdAt": "2020-10-22T16:21:58Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java", "diffHunk": "@@ -36,15 +43,49 @@ private HistoryAnalyzer() {\n         // do not create instance of this class\n     }\n \n+    public static CorruptionHealthReport corruptionHealthReportForHistory(\n+            List<CompletePaxosHistoryForNamespaceAndUseCase> history) {\n+\n+        Map<NamespaceAndUseCase, CorruptionCheckViolation> namespaceAndUseCaseCorruptionCheckViolationMap =\n+                history.stream()\n+                        .collect(Collectors.toMap(\n+                                HistoryAnalyzer::extractNamespaceAndUseCase,\n+                                HistoryAnalyzer::violatedCorruptionChecksForNamespaceAndUseCase));\n+\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> entryEntrySetMultimap = KeyedStream.stream(\n+                        namespaceAndUseCaseCorruptionCheckViolationMap)\n+                .mapEntries((k, v) -> Maps.immutableEntry(v, k))\n+                .filterKeys(CorruptionCheckViolation::raiseErrorAlert)\n+                .collectToSetMultimap();\n+\n+        return ImmutableCorruptionHealthReport.builder()\n+                .statusesToNamespaceAndUseCase(entryEntrySetMultimap)\n+                .build();\n+    }\n+\n+    private static NamespaceAndUseCase extractNamespaceAndUseCase(\n+            CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase) {\n+        return ImmutableNamespaceAndUseCase.builder()\n+                .namespace(historyForNamespaceAndUseCase.namespace())\n+                .useCase(historyForNamespaceAndUseCase.useCase())\n+                .build();\n+    }\n+\n     @VisibleForTesting\n-    static List<CorruptionCheckViolation> violatedCorruptionChecksForNamespaceAndUseCase(\n+    static CorruptionCheckViolation violatedCorruptionChecksForNamespaceAndUseCase(", "originalCommit": "ddd99f2053a61a0d6f050e6b717b5875b45211de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM0Mzg1MA==", "url": "https://github.com/palantir/atlasdb/pull/5071#discussion_r510343850", "bodyText": "Right, the issue is that (and I missed this while writing #5057) these checks are to be executed in an order, e.g. the check for acceptor quorum for a learned value does not hold value if the learners have diverged as we anyway do not have a learner value to compare accepted values against.", "author": "sudiksha27", "createdAt": "2020-10-22T17:41:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI5NDEzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI5NDYwMg==", "url": "https://github.com/palantir/atlasdb/pull/5071#discussion_r510294602", "bodyText": "Might be worth extracting a constant for the set of checks", "author": "jeremyk-91", "createdAt": "2020-10-22T16:22:44Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java", "diffHunk": "@@ -36,15 +43,49 @@ private HistoryAnalyzer() {\n         // do not create instance of this class\n     }\n \n+    public static CorruptionHealthReport corruptionHealthReportForHistory(\n+            List<CompletePaxosHistoryForNamespaceAndUseCase> history) {\n+\n+        Map<NamespaceAndUseCase, CorruptionCheckViolation> namespaceAndUseCaseCorruptionCheckViolationMap =\n+                history.stream()\n+                        .collect(Collectors.toMap(\n+                                HistoryAnalyzer::extractNamespaceAndUseCase,\n+                                HistoryAnalyzer::violatedCorruptionChecksForNamespaceAndUseCase));\n+\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> entryEntrySetMultimap = KeyedStream.stream(\n+                        namespaceAndUseCaseCorruptionCheckViolationMap)\n+                .mapEntries((k, v) -> Maps.immutableEntry(v, k))\n+                .filterKeys(CorruptionCheckViolation::raiseErrorAlert)\n+                .collectToSetMultimap();\n+\n+        return ImmutableCorruptionHealthReport.builder()\n+                .statusesToNamespaceAndUseCase(entryEntrySetMultimap)\n+                .build();\n+    }\n+\n+    private static NamespaceAndUseCase extractNamespaceAndUseCase(\n+            CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase) {\n+        return ImmutableNamespaceAndUseCase.builder()\n+                .namespace(historyForNamespaceAndUseCase.namespace())\n+                .useCase(historyForNamespaceAndUseCase.useCase())\n+                .build();\n+    }\n+\n     @VisibleForTesting\n-    static List<CorruptionCheckViolation> violatedCorruptionChecksForNamespaceAndUseCase(\n+    static CorruptionCheckViolation violatedCorruptionChecksForNamespaceAndUseCase(\n             CompletePaxosHistoryForNamespaceAndUseCase history) {\n-        return Stream.of(\n-                        divergedLearners(history),\n-                        learnedValueWithoutQuorum(history),\n-                        greatestAcceptedValueNotLearned(history))\n-                .filter(CorruptionCheckViolation::raiseErrorAlert)\n-                .collect(Collectors.toList());\n+        Function<CompletePaxosHistoryForNamespaceAndUseCase, CorruptionCheckViolation> divergedLearnedCheck =\n+                HistoryAnalyzer::divergedLearners;\n+        Function<CompletePaxosHistoryForNamespaceAndUseCase, CorruptionCheckViolation> learnedValueWithoutQuorum =\n+                HistoryAnalyzer::learnedValueWithoutQuorum;\n+        Function<CompletePaxosHistoryForNamespaceAndUseCase, CorruptionCheckViolation> greatestAcceptedValueNotLearned =\n+                HistoryAnalyzer::greatestAcceptedValueNotLearned;\n+\n+        return Stream.of(divergedLearnedCheck, learnedValueWithoutQuorum, greatestAcceptedValueNotLearned)", "originalCommit": "ddd99f2053a61a0d6f050e6b717b5875b45211de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI5ODI4Ng==", "url": "https://github.com/palantir/atlasdb/pull/5071#discussion_r510298286", "bodyText": "as flagged elsewhere, this gets confusing, I think because it looks like a command, but it's not", "author": "jeremyk-91", "createdAt": "2020-10-22T16:28:17Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/LocalCorruptionDetector.java", "diffHunk": "@@ -31,46 +32,63 @@\n \n     private final ScheduledExecutorService executor = PTExecutors.newSingleThreadScheduledExecutor(\n             new NamedThreadFactory(CORRUPTION_DETECTOR_THREAD_PREFIX, true));\n+\n     private final LocalCorruptionHandler corruptionHandler;\n+    private final PaxosLogHistoryProvider historyProvider;\n \n     private volatile CorruptionStatus localCorruptionState = CorruptionStatus.HEALTHY;\n+    private volatile CorruptionHealthReport localCorruptionReport = CorruptionHealthReport.defaultHealthyReport();\n \n-    public static LocalCorruptionDetector create(List<TimeLockCorruptionNotifier> corruptionNotifiers) {\n-        LocalCorruptionDetector localCorruptionDetector = new LocalCorruptionDetector(corruptionNotifiers);\n+    public static LocalCorruptionDetector create(\n+            PaxosLogHistoryProvider historyProvider, List<TimeLockCorruptionNotifier> corruptionNotifiers) {\n+        LocalCorruptionDetector localCorruptionDetector =\n+                new LocalCorruptionDetector(historyProvider, corruptionNotifiers);\n \n         //        TODO(snanda) - uncomment when TL corruption detection goes live\n         //        timeLockLocalCorruptionDetector.scheduleWithFixedDelay();\n         return localCorruptionDetector;\n     }\n \n-    private LocalCorruptionDetector(List<TimeLockCorruptionNotifier> corruptionNotifiers) {\n+    private LocalCorruptionDetector(\n+            PaxosLogHistoryProvider historyProvider, List<TimeLockCorruptionNotifier> corruptionNotifiers) {\n+        this.historyProvider = historyProvider;\n         this.corruptionHandler = new LocalCorruptionHandler(corruptionNotifiers);\n     }\n \n     private void scheduleWithFixedDelay() {\n         executor.scheduleWithFixedDelay(\n                 () -> {\n-                    if (detectedSignsOfCorruption()) {\n-                        killTimeLock();\n-                    }\n+                    localCorruptionReport = analyzeHistoryAndBuildCorruptionHealthReport();\n+                    processLocalHealthReport();\n                 },\n                 TIMELOCK_CORRUPTION_ANALYSIS_INTERVAL.getSeconds(),\n                 TIMELOCK_CORRUPTION_ANALYSIS_INTERVAL.getSeconds(),\n                 TimeUnit.SECONDS);\n     }\n \n-    private void killTimeLock() {\n-        localCorruptionState = CorruptionStatus.DEFINITIVE_CORRUPTION_DETECTED_BY_LOCAL;\n-        corruptionHandler.notifyRemoteServersOfCorruption();\n+    private CorruptionHealthReport analyzeHistoryAndBuildCorruptionHealthReport() {\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(historyProvider.getHistory());\n+    }\n+\n+    private void processLocalHealthReport() {\n+        localCorruptionState = getLocalCorruptionState(localCorruptionReport);\n+        if (localCorruptionState.shootTimeLock()) {", "originalCommit": "ddd99f2053a61a0d6f050e6b717b5875b45211de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDMwMDA5OQ==", "url": "https://github.com/palantir/atlasdb/pull/5071#discussion_r510300099", "bodyText": "nit: Prefer isEmpty()", "author": "jeremyk-91", "createdAt": "2020-10-22T16:30:58Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java", "diffHunk": "@@ -81,9 +83,15 @@ public void correctlyPassesIfThereIsNotCorruption() {\n         remoteStateLogComponents.stream().forEach(server -> writeLogsOnServer(server, 1, 10));\n \n         List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+\n         assertThat(HistoryAnalyzer.violatedCorruptionChecksForNamespaceAndUseCase(\n                         Iterables.getOnlyElement(historyForAll)))\n-                .hasSize(0);\n+                .isEqualTo(CorruptionCheckViolation.NONE);\n+\n+        assertThat(HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll)\n+                        .statusesToNamespaceAndUseCase()\n+                        .size())\n+                .isEqualTo(0);", "originalCommit": "ddd99f2053a61a0d6f050e6b717b5875b45211de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDMwMDQyOQ==", "url": "https://github.com/palantir/atlasdb/pull/5071#discussion_r510300429", "bodyText": "could we rename this violatingStatuses... or something like that?", "author": "jeremyk-91", "createdAt": "2020-10-22T16:31:27Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java", "diffHunk": "@@ -81,9 +83,15 @@ public void correctlyPassesIfThereIsNotCorruption() {\n         remoteStateLogComponents.stream().forEach(server -> writeLogsOnServer(server, 1, 10));\n \n         List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+\n         assertThat(HistoryAnalyzer.violatedCorruptionChecksForNamespaceAndUseCase(\n                         Iterables.getOnlyElement(historyForAll)))\n-                .hasSize(0);\n+                .isEqualTo(CorruptionCheckViolation.NONE);\n+\n+        assertThat(HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll)\n+                        .statusesToNamespaceAndUseCase()", "originalCommit": "ddd99f2053a61a0d6f050e6b717b5875b45211de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bd0285652f06c8c5f7801ee12fc7b906defbbeb2", "url": "https://github.com/palantir/atlasdb/commit/bd0285652f06c8c5f7801ee12fc7b906defbbeb2", "message": "Address comments - part 1", "committedDate": "2020-10-22T18:11:52Z", "type": "commit"}, {"oid": "4c6c7574d5810274688274671218cda4ae95a3e2", "url": "https://github.com/palantir/atlasdb/commit/4c6c7574d5810274688274671218cda4ae95a3e2", "message": "Fix build", "committedDate": "2020-10-22T21:26:21Z", "type": "commit"}, {"oid": "bbe834d2978cc3d112a6ad47723114bc4d233c84", "url": "https://github.com/palantir/atlasdb/commit/bbe834d2978cc3d112a6ad47723114bc4d233c84", "message": "Refactor", "committedDate": "2020-10-23T10:25:32Z", "type": "commit"}]}