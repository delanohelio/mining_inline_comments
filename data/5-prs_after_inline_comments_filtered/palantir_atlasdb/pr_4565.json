{"pr_number": 4565, "pr_title": "[Timelock Partitioning] Part 51: Wiremock integration tests for multi leader", "pr_createdAt": "2020-02-11T17:44:06Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4565", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE0OTM4OA==", "url": "https://github.com/palantir/atlasdb/pull/4565#discussion_r378149388", "bodyText": "\ud83c\uddeb\ud83c\uddf7", "author": "jeremyk-91", "createdAt": "2020-02-12T10:03:14Z", "path": "timelock-server/src/integTest/java/com/palantir/atlasdb/timelock/PaxosTimeLockServerIntegrationTest.java", "diffHunk": "@@ -94,7 +98,7 @@ public static void waitForClusterToStabilize() {\n                         NAMESPACES.forEach(client -> TIMELOCK.client(client).legacyLockService().currentTimeMillis());\n                         return TIMELOCK.pinger().ping(NAMESPACES).containsAll(NAMESPACES);\n                     } catch (Throwable t) {\n-                        LoggerFactory.getLogger(PaxosTimeLockServerIntegrationTest.class).error(\"erreur!\", t);\n+                        log.error(\"erreur!\", t);", "originalCommit": "b94da329be84d89c534781fbd266b4f36be995a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE5ODk2NQ==", "url": "https://github.com/palantir/atlasdb/pull/4565#discussion_r378198965", "bodyText": "nit: 308", "author": "jeremyk-91", "createdAt": "2020-02-12T11:40:02Z", "path": "timelock-server/src/suiteTest/java/com/palantir/atlasdb/timelock/MultiLeaderMultiNodePaxosTimeLockIntegrationTest.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.atlasdb.timelock.suite.MultiLeaderPaxosSuite;\n+import com.palantir.atlasdb.timelock.util.ParameterInjector;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.conjure.java.api.errors.QosException;\n+\n+@RunWith(Parameterized.class)\n+public class MultiLeaderMultiNodePaxosTimeLockIntegrationTest {\n+\n+    @ClassRule\n+    public static ParameterInjector<TestableTimelockCluster> injector =\n+            ParameterInjector.withFallBackConfiguration(() -> MultiLeaderPaxosSuite.MULTI_LEADER_PAXOS);\n+\n+    @Parameterized.Parameter\n+    public TestableTimelockCluster cluster;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Iterable<TestableTimelockCluster> params() {\n+        return injector.getParameter();\n+    }\n+\n+\n+    @Test\n+    public void eachNamespaceGetsAssignedDifferentLeaders() {\n+        SetMultimap<TestableTimelockServer, String> allocations = allocateRandomNamespacesToAllNodes(3);\n+\n+        Set<String> allNamespaces = ImmutableSet.copyOf(allocations.values());\n+\n+        allNamespaces.stream()\n+                .map(cluster::client)\n+                .map(NamespacedClients::throughWireMockProxy)\n+                .forEach(NamespacedClients::getFreshTimestamp);\n+\n+        SetMultimap<TestableTimelockServer, String> namespacesByLeader =\n+                ImmutableSetMultimap.copyOf(cluster.currentLeaders(allNamespaces)).inverse();\n+\n+        assertThat(namespacesByLeader)\n+                .isEqualTo(allocations);\n+\n+        cluster.servers().forEach(TestableTimelockServer::allowAllNamespaces);\n+    }\n+\n+    @Test\n+    public void nonLeadersCorrectly308() {\n+        SetMultimap<TestableTimelockServer, String> allocations = allocateRandomNamespacesToAllNodes(1);\n+        String randomNamespace = Iterables.get(allocations.values(), 0);\n+        NamespacedClients clientForRandomNamespace = cluster.client(randomNamespace).throughWireMockProxy();\n+        clientForRandomNamespace.getFreshTimestamp();\n+\n+        cluster.servers().forEach(TestableTimelockServer::allowAllNamespaces);\n+\n+        TestableTimelockServer allocatedLeader = Iterables.getOnlyElement(\n+                ImmutableSetMultimap.copyOf(allocations).inverse().get(randomNamespace));\n+\n+        assertThat(cluster.currentLeaderFor(randomNamespace))\n+                .isEqualTo(allocatedLeader);\n+\n+        cluster.nonLeaders(randomNamespace).get(randomNamespace).forEach(nonLeader ->\n+                assertThatThrownBy(() -> nonLeader.client(randomNamespace).getFreshTimestamp())\n+                        .as(\"non leaders should return 503\")", "originalCommit": "b94da329be84d89c534781fbd266b4f36be995a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE5OTc4Ng==", "url": "https://github.com/palantir/atlasdb/pull/4565#discussion_r378199786", "bodyText": "Discussed offline: The reason this test works is because in the setup, if we have assigned namespace NAMESPACE to node A, then only A knows about NAMESPACE. So only A will propose in the Paxos sequence for NAMESPACE, and thus A should become the leader. Also, before we allowAllNamespaces the other nodes will just reply with 503s that are in front of the direct proxy, so it's not possible that there will be another election in any namespaces causing cluster.currentLeaders(...) to change.\nThis is pretty clever! Maybe worth a comment somewhere.", "author": "jeremyk-91", "createdAt": "2020-02-12T11:41:55Z", "path": "timelock-server/src/suiteTest/java/com/palantir/atlasdb/timelock/MultiLeaderMultiNodePaxosTimeLockIntegrationTest.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.atlasdb.timelock.suite.MultiLeaderPaxosSuite;\n+import com.palantir.atlasdb.timelock.util.ParameterInjector;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.conjure.java.api.errors.QosException;\n+\n+@RunWith(Parameterized.class)\n+public class MultiLeaderMultiNodePaxosTimeLockIntegrationTest {\n+\n+    @ClassRule\n+    public static ParameterInjector<TestableTimelockCluster> injector =\n+            ParameterInjector.withFallBackConfiguration(() -> MultiLeaderPaxosSuite.MULTI_LEADER_PAXOS);\n+\n+    @Parameterized.Parameter\n+    public TestableTimelockCluster cluster;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Iterable<TestableTimelockCluster> params() {\n+        return injector.getParameter();\n+    }\n+\n+\n+    @Test\n+    public void eachNamespaceGetsAssignedDifferentLeaders() {\n+        SetMultimap<TestableTimelockServer, String> allocations = allocateRandomNamespacesToAllNodes(3);\n+\n+        Set<String> allNamespaces = ImmutableSet.copyOf(allocations.values());\n+\n+        allNamespaces.stream()\n+                .map(cluster::client)\n+                .map(NamespacedClients::throughWireMockProxy)\n+                .forEach(NamespacedClients::getFreshTimestamp);\n+\n+        SetMultimap<TestableTimelockServer, String> namespacesByLeader =\n+                ImmutableSetMultimap.copyOf(cluster.currentLeaders(allNamespaces)).inverse();\n+\n+        assertThat(namespacesByLeader)\n+                .isEqualTo(allocations);\n+\n+        cluster.servers().forEach(TestableTimelockServer::allowAllNamespaces);", "originalCommit": "b94da329be84d89c534781fbd266b4f36be995a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk4MjkyNA==", "url": "https://github.com/palantir/atlasdb/pull/4565#discussion_r394982924", "bodyText": "with some of my other work, we can probably use the takeover primitive instead to more reliably deal with this.", "author": "felixdesouza", "createdAt": "2020-03-19T12:16:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE5OTc4Ng=="}], "type": "inlineReview"}, {"oid": "301a67b5e7e2c7855348136032782aa9fdbbf9de", "url": "https://github.com/palantir/atlasdb/commit/301a67b5e7e2c7855348136032782aa9fdbbf9de", "message": "Add wiremock capabilities to the tests.", "committedDate": "2020-03-19T12:23:56Z", "type": "commit"}, {"oid": "c9ccaf72a785a1d8e533ea9c03f370495a7b5be7", "url": "https://github.com/palantir/atlasdb/commit/c9ccaf72a785a1d8e533ea9c03f370495a7b5be7", "message": "Add some multi leader tests.", "committedDate": "2020-03-19T12:23:56Z", "type": "commit"}, {"oid": "9b442ddaedcf39311188330a375368419b3764ef", "url": "https://github.com/palantir/atlasdb/commit/9b442ddaedcf39311188330a375368419b3764ef", "message": "Fix checkstyle and broken tests.", "committedDate": "2020-03-19T12:23:56Z", "type": "commit"}, {"oid": "b088e51874478706e87286893a8e4215437c8226", "url": "https://github.com/palantir/atlasdb/commit/b088e51874478706e87286893a8e4215437c8226", "message": "Use correct truststore and password.", "committedDate": "2020-03-19T12:23:56Z", "type": "commit"}, {"oid": "b16f364c158ce6cb3a1dec68c58845f394bf03b6", "url": "https://github.com/palantir/atlasdb/commit/b16f364c158ce6cb3a1dec68c58845f394bf03b6", "message": "Checkstyle and remove truststore.", "committedDate": "2020-03-19T12:23:56Z", "type": "commit"}, {"oid": "e4f9e2220b3e7f82ba5efa11354264c910524071", "url": "https://github.com/palantir/atlasdb/commit/e4f9e2220b3e7f82ba5efa11354264c910524071", "message": "Address comments.", "committedDate": "2020-03-19T12:23:56Z", "type": "commit"}, {"oid": "e4f9e2220b3e7f82ba5efa11354264c910524071", "url": "https://github.com/palantir/atlasdb/commit/e4f9e2220b3e7f82ba5efa11354264c910524071", "message": "Address comments.", "committedDate": "2020-03-19T12:23:56Z", "type": "forcePushed"}, {"oid": "35b237ff96aa0f04338024eed9fd1241271e4a52", "url": "https://github.com/palantir/atlasdb/commit/35b237ff96aa0f04338024eed9fd1241271e4a52", "message": "Support conjure endpoints.", "committedDate": "2020-03-19T12:40:59Z", "type": "commit"}]}