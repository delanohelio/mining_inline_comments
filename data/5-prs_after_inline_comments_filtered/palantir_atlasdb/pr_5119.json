{"pr_number": 5119, "pr_title": "[Cross Client Batching - 1d] | Modify leaderTimes api", "pr_createdAt": "2020-11-18T18:14:04Z", "pr_url": "https://github.com/palantir/atlasdb/pull/5119", "timeline": [{"oid": "f87c24e46252ee4f88156501d8cd5aba2adcff8d", "url": "https://github.com/palantir/atlasdb/commit/f87c24e46252ee4f88156501d8cd5aba2adcff8d", "message": "Modify leaderTimes api + remove getCommitTimestamps", "committedDate": "2020-11-18T18:07:32Z", "type": "commit"}, {"oid": "ad2898bcc661357253d5afd1d516365254096b3b", "url": "https://github.com/palantir/atlasdb/commit/ad2898bcc661357253d5afd1d516365254096b3b", "message": " Fix tests + remove redundant tests", "committedDate": "2020-11-18T18:09:55Z", "type": "commit"}, {"oid": "64526e998aa6f23adeaa55cda45d32acd8a1f15d", "url": "https://github.com/palantir/atlasdb/commit/64526e998aa6f23adeaa55cda45d32acd8a1f15d", "message": "Minor refactor", "committedDate": "2020-11-18T18:32:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc1MDgwNQ==", "url": "https://github.com/palantir/atlasdb/pull/5119#discussion_r526750805", "bodyText": "Hmm. I think this test really should target two underlying timelock services which return different times, and we should check that the wiring is correct. (This test would allow for a couple of bad behaviours!)", "author": "jeremyk-91", "createdAt": "2020-11-19T10:25:49Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/batch/MultiClientConjureTimelockResourceTest.java", "diffHunk": "@@ -67,59 +58,23 @@ public void before() {\n     @Test\n     public void canGetLeaderTimesForMultipleClients() {\n         when(timelockService.leaderTime()).thenReturn(Futures.immediateFuture(leaderTime));\n-        Set<String> namespaces = ImmutableSet.of(\"client1\", \"client2\");\n+        Set<Namespace> namespaces = ImmutableSet.of(Namespace.of(\"client1\"), Namespace.of(\"client2\"));\n         assertThat(Futures.getUnchecked(resource.leaderTimes(AUTH_HEADER, namespaces)))\n                 .isEqualTo(getLeaderTimesForNamespaces(namespaces));\n     }\n \n-    @Test\n-    public void canGetCommitTimestampsForMultipleClients() {\n-        GetCommitTimestampsResponse getCommitTimestampsResponse = GetCommitTimestampsResponse.of(\n-                COMMIT_TS_LOWER_INCLUSIVE, COMMIT_TS_UPPER_INCLUSIVE, lockWatchStateUpdate);\n-\n-        when(timelockService.getCommitTimestamps(anyInt(), any()))\n-                .thenReturn(Futures.immediateFuture(getCommitTimestampsResponse));\n-\n-        Set<String> namespaces = ImmutableSet.of(\"client1\", \"client2\");\n-        assertThat(Futures.getUnchecked(\n-                        resource.getCommitTimestamps(AUTH_HEADER, getGetCommitTimestampsRequests(namespaces))))\n-                .isEqualTo(getGetCommitTimestampsResponseList(namespaces));\n-    }\n-\n     @Test\n     public void requestThrowsIfAnyQueryFails() {\n         when(timelockService.leaderTime())\n                 .thenReturn(Futures.immediateFuture(leaderTime))\n                 .thenThrow(new BlockingTimeoutException(\"\"));\n-        Set<String> namespaces = ImmutableSet.of(\"client1\", \"client2\");\n+        Set<Namespace> namespaces = ImmutableSet.of(Namespace.of(\"client1\"), Namespace.of(\"client2\"));\n         assertThatThrownBy(() -> Futures.getUnchecked(resource.leaderTimes(AUTH_HEADER, namespaces)))\n                 .isInstanceOf(BlockingTimeoutException.class);\n     }\n \n-    private List<NamespacedGetCommitTimestampsResponse> getGetCommitTimestampsResponseList(Set<String> namespaces) {\n-        return namespaces.stream()\n-                .map(namespace -> NamespacedGetCommitTimestampsResponse.builder()\n-                        .namespace(namespace)\n-                        .inclusiveLower(COMMIT_TS_LOWER_INCLUSIVE)\n-                        .inclusiveUpper(COMMIT_TS_UPPER_INCLUSIVE)\n-                        .lockWatchUpdate(lockWatchStateUpdate)\n-                        .build())\n-                .collect(Collectors.toList());\n-    }\n-\n-    private List<NamespacedGetCommitTimestampsRequest> getGetCommitTimestampsRequests(Set<String> namespaces) {\n-        return namespaces.stream()\n-                .map(namespace -> NamespacedGetCommitTimestampsRequest.builder()\n-                        .namespace(namespace)\n-                        .numTimestamps(4)\n-                        .build())\n-                .collect(Collectors.toList());\n-    }\n-\n-    private List<NamespacedLeaderTime> getLeaderTimesForNamespaces(Set<String> namespaces) {\n-        return namespaces.stream()\n-                .map(namespace -> NamespacedLeaderTime.of(namespace, leaderTime))\n-                .collect(Collectors.toList());\n+    private LeaderTimes getLeaderTimesForNamespaces(Set<Namespace> namespaces) {\n+        return LeaderTimes.of(namespaces.stream().collect(Collectors.toMap(x -> x, x -> leaderTime)));", "originalCommit": "64526e998aa6f23adeaa55cda45d32acd8a1f15d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ced70611e32487dcb539d113405169705fc730e4", "url": "https://github.com/palantir/atlasdb/commit/ced70611e32487dcb539d113405169705fc730e4", "message": "Address comments", "committedDate": "2020-11-19T11:00:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA4MDE5MQ==", "url": "https://github.com/palantir/atlasdb/pull/5119#discussion_r527080191", "bodyText": "nit: just use one instance of client1? This won't really test multiple requests because the immutableset will kill off the doubles before we call resource.getLeaderTimes", "author": "jeremyk-91", "createdAt": "2020-11-19T17:46:32Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/batch/MultiClientConjureTimelockResourceTest.java", "diffHunk": "@@ -46,35 +51,58 @@\n     private static final RedirectRetryTargeter TARGETER =\n             RedirectRetryTargeter.create(LOCAL, ImmutableList.of(LOCAL, REMOTE));\n \n-    private AsyncTimelockService timelockService = mock(AsyncTimelockService.class);\n-    private LeaderTime leaderTime = mock(LeaderTime.class);\n+    private Map<String, AsyncTimelockService> namespaces = new HashMap();\n+    private Map<String, LeadershipId> namespaceToLeaderMap = new HashMap();\n+\n     private MultiClientConjureTimelockResource resource;\n \n     @Before\n     public void before() {\n-        resource = new MultiClientConjureTimelockResource(TARGETER, unused -> timelockService);\n+        resource = new MultiClientConjureTimelockResource(TARGETER, this::getServiceForClient);\n     }\n \n     @Test\n     public void canGetLeaderTimesForMultipleClients() {\n-        when(timelockService.leaderTime()).thenReturn(Futures.immediateFuture(leaderTime));\n-        Set<Namespace> namespaces = ImmutableSet.of(Namespace.of(\"client1\"), Namespace.of(\"client2\"));\n-        assertThat(Futures.getUnchecked(resource.leaderTimes(AUTH_HEADER, namespaces)))\n-                .isEqualTo(getLeaderTimesForNamespaces(namespaces));\n+        Namespace client1 = Namespace.of(\"client1\");\n+        Namespace client2 = Namespace.of(\"client2\");\n+        Set<Namespace> namespaces = ImmutableSet.of(client1, client1, client2);", "originalCommit": "ced70611e32487dcb539d113405169705fc730e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA4MDk2Mg==", "url": "https://github.com/palantir/atlasdb/pull/5119#discussion_r527080962", "bodyText": "nice!", "author": "jeremyk-91", "createdAt": "2020-11-19T17:47:45Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/batch/MultiClientConjureTimelockResourceTest.java", "diffHunk": "@@ -46,35 +51,58 @@\n     private static final RedirectRetryTargeter TARGETER =\n             RedirectRetryTargeter.create(LOCAL, ImmutableList.of(LOCAL, REMOTE));\n \n-    private AsyncTimelockService timelockService = mock(AsyncTimelockService.class);\n-    private LeaderTime leaderTime = mock(LeaderTime.class);\n+    private Map<String, AsyncTimelockService> namespaces = new HashMap();\n+    private Map<String, LeadershipId> namespaceToLeaderMap = new HashMap();\n+\n     private MultiClientConjureTimelockResource resource;\n \n     @Before\n     public void before() {\n-        resource = new MultiClientConjureTimelockResource(TARGETER, unused -> timelockService);\n+        resource = new MultiClientConjureTimelockResource(TARGETER, this::getServiceForClient);\n     }\n \n     @Test\n     public void canGetLeaderTimesForMultipleClients() {\n-        when(timelockService.leaderTime()).thenReturn(Futures.immediateFuture(leaderTime));\n-        Set<Namespace> namespaces = ImmutableSet.of(Namespace.of(\"client1\"), Namespace.of(\"client2\"));\n-        assertThat(Futures.getUnchecked(resource.leaderTimes(AUTH_HEADER, namespaces)))\n-                .isEqualTo(getLeaderTimesForNamespaces(namespaces));\n+        Namespace client1 = Namespace.of(\"client1\");\n+        Namespace client2 = Namespace.of(\"client2\");\n+        Set<Namespace> namespaces = ImmutableSet.of(client1, client1, client2);\n+\n+        LeaderTimes leaderTimesResponse = Futures.getUnchecked(resource.leaderTimes(AUTH_HEADER, namespaces));\n+        Map<Namespace, LeaderTime> leaderTimes = leaderTimesResponse.getLeaderTimes();\n+\n+        // leaderTimes for namespaces are computed by their respective underlying AsyncTimelockService instances\n+        leaderTimes.forEach((namespace, leaderTime) -> {\n+            assertThat(leaderTime.id()).isEqualTo(namespaceToLeaderMap.get(namespace.get()));", "originalCommit": "ced70611e32487dcb539d113405169705fc730e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9cffb3adf4b20c77be42239713f18e0506e0619b", "url": "https://github.com/palantir/atlasdb/commit/9cffb3adf4b20c77be42239713f18e0506e0619b", "message": "Address comments", "committedDate": "2020-11-19T17:56:52Z", "type": "commit"}]}