{"pr_number": 4820, "pr_title": "Remove LockWatchStateUpdate#Failed.", "pr_createdAt": "2020-06-02T22:37:50Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4820", "timeline": [{"oid": "57eb2b153dc00761dc279b53a56f2e26892a84b4", "url": "https://github.com/palantir/atlasdb/commit/57eb2b153dc00761dc279b53a56f2e26892a84b4", "message": "Naive fix for this.", "committedDate": "2020-06-02T21:29:09Z", "type": "commit"}, {"oid": "5df122ab0bfdb9532f237b1f125927a159c9c721", "url": "https://github.com/palantir/atlasdb/commit/5df122ab0bfdb9532f237b1f125927a159c9c721", "message": "Remove fancy synchronization.", "committedDate": "2020-06-02T22:37:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIzMzk4NA==", "url": "https://github.com/palantir/atlasdb/pull/4820#discussion_r434233984", "bodyText": "The thing to understand here is what does this snapshot actually mean: it's a best effort thing to indicate if there are any open locks and return them. This snapshot isn't really a consistent snapshot: while we're locked here in the log, the HeldLocksCollection is still granting locks, which, as soon as we unlock the log, will add their events. But as per the RFC, this doesn't matter for any transactions that end up working with this snapshot: what matters for conflict checking is that there were no events for cached rows in between the transaction starting and trying to commit.\nAfter these changes (and possibly before them), if we compute a snapshot, the node might later receive events it already knows about from the snapshot again. And that should be fine.", "author": "jkozlowski", "createdAt": "2020-06-02T23:45:37Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/LockEventLogImpl.java", "diffHunk": "@@ -50,58 +50,67 @@\n     }\n \n     @Override\n-    public LockWatchStateUpdate getLogDiff(Optional<IdentifiedVersion> fromVersion) {\n-        return getLogDiff(fromVersion, slidingWindow.lastVersion());\n+    public synchronized LockWatchStateUpdate getLogDiff(Optional<IdentifiedVersion> fromVersion) {\n+        if (shouldCalculateSnapshot(fromVersion)) {\n+            return calculateSnapshot();\n+        }\n+        List<LockWatchEvent> events = slidingWindow.getFromVersion(fromVersion.get().version());\n+        return LockWatchStateUpdate.success(logId, slidingWindow.lastVersion(), events);\n     }\n \n     @Override\n-    public LockWatchStateUpdate getLogDiff(Optional<IdentifiedVersion> fromVersion, long toVersion) {\n-        if (isVersionStale(fromVersion)) {\n-            return attemptToCalculateSnapshot();\n-        }\n-        Optional<List<LockWatchEvent>> maybeEvents = slidingWindow.getFromTo(fromVersion.get().version(), toVersion);\n-        if (!maybeEvents.isPresent()) {\n-            return attemptToCalculateSnapshot();\n+    public synchronized <T> AtomicValue<T> runTaskAndAtomicallyReturnLockWatchStateUpdate(\n+            Optional<IdentifiedVersion> lastKnownVersion, Supplier<T> task) {\n+        T t = task.get();\n+        LockWatchStateUpdate logDiff = getLogDiff(lastKnownVersion);\n+        return AtomicValue.of(logDiff, t);\n+    }\n+\n+    @Override\n+    public synchronized void logLock(Set<LockDescriptor> locksTakenOut, LockToken lockToken) {\n+        // I feel like this would be simpler if the isEmpty check was done somewhere else, it's weird API\n+        if (!locksTakenOut.isEmpty()) {\n+            synchronized (this) {\n+                slidingWindow.add(LockEvent.builder(locksTakenOut, lockToken));\n+            }\n         }\n-        List<LockWatchEvent> events = maybeEvents.get();\n-        return LockWatchStateUpdate.success(logId, toVersion, events);\n     }\n \n-    private boolean isVersionStale(Optional<IdentifiedVersion> fromVersion) {\n-        return !fromVersion.isPresent() || !fromVersion.get().id().equals(logId);\n+    @Override\n+    public void logUnlock(Set<LockDescriptor> locksUnlocked) {\n+        if (!locksUnlocked.isEmpty()) {\n+            synchronized (this) {\n+                slidingWindow.add(UnlockEvent.builder(locksUnlocked));\n+            }\n+        }\n     }\n \n-    /**\n-     * Gets a snapshot estimate, then replays all lock watch events that occurred in the meantime on top of it\n-     * to correct any inconsistencies as discussed in {@link this#calculateOpenLocks(RangeSet)}.\n-     */\n-    private LockWatchStateUpdate attemptToCalculateSnapshot() {\n-        long startVersion = slidingWindow.lastVersion();\n-        SnapshotEventReplayer eventReplayer = getSnapshotEstimateAndCreateReplayer();\n-        long endVersion = slidingWindow.lastVersion();\n+    @Override\n+    public synchronized void logLockWatchCreated(LockWatches newWatches) {\n+        Set<LockDescriptor> openLocks = calculateOpenLocks(newWatches.ranges());\n+        slidingWindow.add(LockWatchCreatedEvent.builder(newWatches.references(), openLocks));\n+    }\n \n-        Optional<List<LockWatchEvent>> eventsToReplay = slidingWindow.getFromTo(startVersion, endVersion);\n-        if (!eventsToReplay.isPresent()) {\n-            return LockWatchStateUpdate.failed(logId);\n-        }\n-        eventsToReplay.get().forEach(eventReplayer::replay);\n-        return LockWatchStateUpdate.snapshot(\n-                logId,\n-                endVersion,\n-                eventReplayer.locked,\n-                eventReplayer.watches);\n+    private boolean shouldCalculateSnapshot(Optional<IdentifiedVersion> fromVersion) {\n+        return !fromVersion.isPresent() || !fromVersion.get().id().equals(logId) || !slidingWindow.contains(\n+                fromVersion.get().version());\n     }\n \n-    private SnapshotEventReplayer getSnapshotEstimateAndCreateReplayer() {\n+    private LockWatchStateUpdate calculateSnapshot() {\n+        long lastVersion = slidingWindow.lastVersion();\n         LockWatches currentWatches = watchesSupplier.get();\n-        Set<LockWatchReference> watched = new HashSet<>(currentWatches.references());\n-        Set<LockDescriptor> estimatedLocks = calculateOpenLocks(currentWatches.ranges());\n-        return new SnapshotEventReplayer(watched, estimatedLocks);\n+        Set<LockWatchReference> watches = new HashSet<>(currentWatches.references());\n+        Set<LockDescriptor> openLocks = calculateOpenLocks(currentWatches.ranges());", "originalCommit": "5df122ab0bfdb9532f237b1f125927a159c9c721", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2ba7a8e92e420121869d2ab8cd13583e3c4cd094", "url": "https://github.com/palantir/atlasdb/commit/2ba7a8e92e420121869d2ab8cd13583e3c4cd094", "message": "Merge branch 'develop' into failure-is-not-an-option-2", "committedDate": "2020-06-23T15:27:52Z", "type": "commit"}, {"oid": "bdcd89cd276bcb0e21ab91fdca8864522ddfe90a", "url": "https://github.com/palantir/atlasdb/commit/bdcd89cd276bcb0e21ab91fdca8864522ddfe90a", "message": "Merge branch 'develop' into failure-is-not-an-option-2", "committedDate": "2020-06-23T20:27:14Z", "type": "commit"}, {"oid": "f3ece14eae213c947e8ebd9a226f44e7e425d363", "url": "https://github.com/palantir/atlasdb/commit/f3ece14eae213c947e8ebd9a226f44e7e425d363", "message": "Fixup", "committedDate": "2020-06-23T20:29:43Z", "type": "commit"}, {"oid": "c3e9b5c0001315ac93549679d5fff6be63873a65", "url": "https://github.com/palantir/atlasdb/commit/c3e9b5c0001315ac93549679d5fff6be63873a65", "message": "Cleanup some more.", "committedDate": "2020-06-23T20:53:36Z", "type": "commit"}, {"oid": "3c93c41d67f5c19556c583e47855b096ea27f7fb", "url": "https://github.com/palantir/atlasdb/commit/3c93c41d67f5c19556c583e47855b096ea27f7fb", "message": "Fix test", "committedDate": "2020-06-23T21:08:33Z", "type": "commit"}, {"oid": "70a37f287093424d304a663d82abebc4270f6bf4", "url": "https://github.com/palantir/atlasdb/commit/70a37f287093424d304a663d82abebc4270f6bf4", "message": "Add a bit of comments and rename methods.", "committedDate": "2020-06-23T21:28:26Z", "type": "commit"}, {"oid": "762d644d647a9ebdf9d4319c352ab5f57e4c51c4", "url": "https://github.com/palantir/atlasdb/commit/762d644d647a9ebdf9d4319c352ab5f57e4c51c4", "message": "Cleanup test", "committedDate": "2020-06-23T21:40:26Z", "type": "commit"}, {"oid": "83ea431fa3d8c1edbdb53b4e11ab35fc42a62683", "url": "https://github.com/palantir/atlasdb/commit/83ea431fa3d8c1edbdb53b4e11ab35fc42a62683", "message": "Reflow.", "committedDate": "2020-06-23T21:42:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2OTMyMQ==", "url": "https://github.com/palantir/atlasdb/pull/4820#discussion_r445169321", "bodyText": "This returns true if the version is unloadable, which I find strange. Maybe either flip this, or isVersionUnknown or something along those lines.", "author": "jeremyk-91", "createdAt": "2020-06-24T21:01:03Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/ArrayLockEventSlidingWindow.java", "diffHunk": "@@ -44,92 +38,43 @@ long lastVersion() {\n         return nextSequence - 1;\n     }\n \n-    /**\n-     * Adds an event to the sliding window. Assigns a unique sequence to the event.\n-     *\n-     * Note on concurrency:\n-     * 1. Each write to buffer is followed by a write to nextSequence, which is volatile.\n-     */\n-    synchronized void add(LockWatchEvent.Builder eventBuilder) {\n+    void add(LockWatchEvent.Builder eventBuilder) {\n         LockWatchEvent event = eventBuilder.build(nextSequence);\n         buffer[LongMath.mod(nextSequence, maxSize)] = event;\n         nextSequence++;\n     }\n \n-    synchronized void finalizeAndAddSnapshot(long startVersion, LockWatchCreatedEventReplayer eventReplayer) {\n-        Optional<List<LockWatchEvent>> remaining = getFromVersion(startVersion);\n-        if (remaining.isPresent()) {\n-            remaining.get().forEach(eventReplayer::replay);\n-            add(LockWatchCreatedEvent.builder(eventReplayer.getReferences(), eventReplayer.getLockedDescriptors()));\n-        }\n+    boolean hasNextEvents(long version) {\n+        return !validateVersion(version);\n     }\n \n-    /**\n-     * Warning: this will block all lock and unlock requests until the task is done. Improper use of this method can\n-     * result in a deadlock.\n-     */\n-    synchronized <T> ValueAndVersion<T> runTaskAndAtomicallyReturnVersion(Supplier<T> task) {\n-        return ValueAndVersion.of(lastVersion(), task.get());\n-    }\n-\n-    /**\n-     * Returns a list of all events that occurred immediately after the requested version up to the most recent version,\n-     * ordered by consecutively increasing sequence numbers. If the list cannot be created, either a priori or because\n-     * new events are added to the window during execution of this method causing eviction an event before it was read,\n-     * the method will return {@link Optional#empty()}.\n-     *\n-     * Note on concurrency:\n-     * 2. Before reading from buffer, we read nextSequence.\n-     *\n-     * 1. and 2. ensure that calls to this method have an up to date view of buffer, containing all updates made so\n-     * far. The buffer may be updated after the volatile read of nextSequence, and these updates may or may not be\n-     * visible. This does not affect correctness:\n-     *   a) the newer updates are not expected to be reflected in the returned list\n-     *   b) if (some of) the newer updates are visible and overwrite a value that should have been included in the\n-     *      returned list, it may end up included in the candidate result. This will be detected by\n-     *      validateConsistencyOrReturnEmpty, and {@link Optional#empty()} will be returned. This correctly reflects\n-     *      the state where, even though all the necessary events were in the requested window at the start of executing\n-     *      this method, that is no longer the case when the method returns.\n-     */\n-    public Optional<List<LockWatchEvent>> getFromVersion(long version) {\n-        return getFromTo(version, lastVersion());\n-    }\n-\n-    public Optional<List<LockWatchEvent>> getFromTo(long startVersion, long endVersion) {\n-        if (versionInTheFuture(startVersion, endVersion) || versionTooOld(startVersion, endVersion)) {\n-            return Optional.empty();\n-        }\n-\n-        int startIndex = LongMath.mod(startVersion + 1, maxSize);\n-        int windowSize = Ints.saturatedCast(endVersion - startVersion);\n+    public List<LockWatchEvent> getNextEvents(long version) {\n+        Preconditions.checkArgument(hasNextEvents(version), \"Version not in the log\");\n+        int startIndex = LongMath.mod(version + 1, maxSize);\n+        int windowSize = Ints.saturatedCast(lastVersion() - version);\n         List<LockWatchEvent> events = new ArrayList<>(windowSize);\n \n         for (int i = startIndex; events.size() < windowSize; i = incrementAndMod(i)) {\n             events.add(buffer[i]);\n         }\n \n-        return validateConsistencyOrReturnEmpty(startVersion, events);\n+        return events;\n     }\n \n     private int incrementAndMod(int num) {\n         num++;\n         return num >= maxSize ? num % maxSize : num;\n     }\n \n-    private boolean versionInTheFuture(long lastVersion, long lastWrittenSequence) {\n-        return lastVersion > lastWrittenSequence;\n+    private boolean validateVersion(long version) {", "originalCommit": "83ea431fa3d8c1edbdb53b4e11ab35fc42a62683", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4MjEwOQ==", "url": "https://github.com/palantir/atlasdb/pull/4820#discussion_r445182109", "bodyText": "Yeah, I tried not to rewrite this because that's how Grgur wrote these. But you're right, this reads weird. I'll actually rewrite this to read completely differently, with just getNextEvents that returns Optional of events, for when it can't satisfy the query. And the fallback will be to calculate snapshot.", "author": "jkozlowski", "createdAt": "2020-06-24T21:28:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2OTMyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4NTkyNw==", "url": "https://github.com/palantir/atlasdb/pull/4820#discussion_r445185927", "bodyText": "Actually, correction: I rewrote this to be weird, so just gonna fix that.", "author": "jkozlowski", "createdAt": "2020-06-24T21:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2OTMyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5Njg2NQ==", "url": "https://github.com/palantir/atlasdb/pull/4820#discussion_r445196865", "bodyText": "Done", "author": "jkozlowski", "createdAt": "2020-06-24T22:02:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2OTMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MDE0Nw==", "url": "https://github.com/palantir/atlasdb/pull/4820#discussion_r445170147", "bodyText": "sanity check: Is hasNextEvents() queried at the last version intentionally true?\nnon-actionable: this is basically hasEventsFromHereToLastKnown though that is kind of verbose so just hasNextEvents is fine.", "author": "jeremyk-91", "createdAt": "2020-06-24T21:02:46Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/ArrayLockEventSlidingWindow.java", "diffHunk": "@@ -44,92 +38,43 @@ long lastVersion() {\n         return nextSequence - 1;\n     }\n \n-    /**\n-     * Adds an event to the sliding window. Assigns a unique sequence to the event.\n-     *\n-     * Note on concurrency:\n-     * 1. Each write to buffer is followed by a write to nextSequence, which is volatile.\n-     */\n-    synchronized void add(LockWatchEvent.Builder eventBuilder) {\n+    void add(LockWatchEvent.Builder eventBuilder) {\n         LockWatchEvent event = eventBuilder.build(nextSequence);\n         buffer[LongMath.mod(nextSequence, maxSize)] = event;\n         nextSequence++;\n     }\n \n-    synchronized void finalizeAndAddSnapshot(long startVersion, LockWatchCreatedEventReplayer eventReplayer) {\n-        Optional<List<LockWatchEvent>> remaining = getFromVersion(startVersion);\n-        if (remaining.isPresent()) {\n-            remaining.get().forEach(eventReplayer::replay);\n-            add(LockWatchCreatedEvent.builder(eventReplayer.getReferences(), eventReplayer.getLockedDescriptors()));\n-        }\n+    boolean hasNextEvents(long version) {\n+        return !validateVersion(version);", "originalCommit": "83ea431fa3d8c1edbdb53b4e11ab35fc42a62683", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4MTY2NQ==", "url": "https://github.com/palantir/atlasdb/pull/4820#discussion_r445181665", "bodyText": "Yes, if you present the last version, that means you're up to date, and we're return you last version and empty list of events. This method is used to calculate if the query to get the client up to date can be satisfied from the log, or else we need to calculate a snapshot.", "author": "jkozlowski", "createdAt": "2020-06-24T21:27:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MDE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MTk1NQ==", "url": "https://github.com/palantir/atlasdb/pull/4820#discussion_r445171955", "bodyText": "nit: Might be worth calling out @NotThreadSafe (it's really obvious, but worth noting)", "author": "jeremyk-91", "createdAt": "2020-06-24T21:06:32Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/ArrayLockEventSlidingWindow.java", "diffHunk": "@@ -18,22 +18,16 @@\n \n import java.util.ArrayList;\n import java.util.List;\n-import java.util.Optional;\n-import java.util.function.Supplier;\n-\n-import javax.annotation.concurrent.ThreadSafe;\n \n import com.google.common.math.LongMath;\n import com.google.common.primitives.Ints;\n-import com.palantir.atlasdb.timelock.lock.watch.LockEventLogImpl.LockWatchCreatedEventReplayer;\n-import com.palantir.lock.watch.LockWatchCreatedEvent;\n import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.logsafe.Preconditions;\n \n-@ThreadSafe\n public class ArrayLockEventSlidingWindow {", "originalCommit": "83ea431fa3d8c1edbdb53b4e11ab35fc42a62683", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4MTg3MA==", "url": "https://github.com/palantir/atlasdb/pull/4820#discussion_r445181870", "bodyText": "Done", "author": "jkozlowski", "createdAt": "2020-06-24T21:28:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MTk1NQ=="}], "type": "inlineReview"}, {"oid": "6f8170617ac83626e4437137339405e42d179bb0", "url": "https://github.com/palantir/atlasdb/commit/6f8170617ac83626e4437137339405e42d179bb0", "message": "CR", "committedDate": "2020-06-24T21:39:44Z", "type": "commit"}]}