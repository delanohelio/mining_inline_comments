{"pr_number": 4775, "pr_title": "[PaxosStateLog] Wire up and Migrate To Verifying PSL", "pr_createdAt": "2020-05-14T13:04:33Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4775", "timeline": [{"oid": "9d3071306389687cd9b05f48902a1641a3b791a3", "url": "https://github.com/palantir/atlasdb/commit/9d3071306389687cd9b05f48902a1641a3b791a3", "message": "Implement different state support", "committedDate": "2020-05-13T16:07:34Z", "type": "commit"}, {"oid": "40f00c368317882a67160675e25ef35a4e0db70a", "url": "https://github.com/palantir/atlasdb/commit/40f00c368317882a67160675e25ef35a4e0db70a", "message": "Add migrated state", "committedDate": "2020-05-13T16:17:19Z", "type": "commit"}, {"oid": "f279ca043c6de9bf195afe5990d4f9fe3114505e", "url": "https://github.com/palantir/atlasdb/commit/f279ca043c6de9bf195afe5990d4f9fe3114505e", "message": "Wiring and integration tests", "committedDate": "2020-05-14T12:39:35Z", "type": "commit"}, {"oid": "8bc4cd00a6dcc9f70fb90cec90003e8175d11d44", "url": "https://github.com/palantir/atlasdb/commit/8bc4cd00a6dcc9f70fb90cec90003e8175d11d44", "message": "Small fixes", "committedDate": "2020-05-14T13:04:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE3NjE0NA==", "url": "https://github.com/palantir/atlasdb/pull/4775#discussion_r425176144", "bodyText": "\ud83c\udf89", "author": "jeremyk-91", "createdAt": "2020-05-14T14:22:22Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/paxos/PaxosStateLogMigrationIntegrationTest.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import com.palantir.atlasdb.util.MetricsManagers;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.ImmutablePaxosStorageParameters;\n+import com.palantir.paxos.PaxosLearner;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosStateLogImpl;\n+import com.palantir.paxos.PaxosStorageParameters;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+\n+public class PaxosStateLogMigrationIntegrationTest {\n+    private static final Client CLIENT = Client.of(\"test\");\n+\n+    @Rule\n+    public final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();\n+\n+    private LocalPaxosComponents paxosComponents;\n+    private PaxosUseCase useCase = PaxosUseCase.LEADER_FOR_ALL_CLIENTS;\n+    private Path legacyDirectory;\n+    private Path sqliteDirectory;\n+\n+    @Before\n+    public void setUp() throws IOException {\n+        legacyDirectory = TEMPORARY_FOLDER.newFolder(\"legacy\").toPath();\n+        sqliteDirectory = TEMPORARY_FOLDER.newFolder(\"sqlite\").toPath();\n+        resetPaxosComponents();\n+    }\n+\n+    @Test\n+    public void learnerMigratesLogStateCorrectly() throws IOException {\n+        int round = 100;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        assertValuePresent(round, sqliteLog);\n+        assertValueLearned(round, learner);\n+    }\n+\n+    @Test\n+    public void legacyLogIsTheSourceOfTruthWhenValueOnlyInLegacy() throws IOException {\n+        int migratedRound = 100;\n+        int nonMigratedRound = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(migratedRound, valueForRound(migratedRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(nonMigratedRound, valueForRound(nonMigratedRound));\n+\n+        assertValueAbsent(nonMigratedRound, sqliteLog);\n+        assertValuePresent(nonMigratedRound, fileBasedLog);\n+        assertValueLearned(nonMigratedRound, learner);\n+    }\n+\n+    @Test\n+    public void legacyLogIsTheSourceOfTruthWhenValueAbsentFromLegacy() throws IOException {\n+        int migratedRound = 100;\n+        int rogueValue = 200;", "originalCommit": "8bc4cd00a6dcc9f70fb90cec90003e8175d11d44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE3ODMzMg==", "url": "https://github.com/palantir/atlasdb/pull/4775#discussion_r425178332", "bodyText": "I think it's already done in 162", "author": "jeremyk-91", "createdAt": "2020-05-14T14:25:02Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/paxos/PaxosStateLogMigrationIntegrationTest.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import com.palantir.atlasdb.util.MetricsManagers;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.ImmutablePaxosStorageParameters;\n+import com.palantir.paxos.PaxosLearner;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosStateLogImpl;\n+import com.palantir.paxos.PaxosStorageParameters;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+\n+public class PaxosStateLogMigrationIntegrationTest {\n+    private static final Client CLIENT = Client.of(\"test\");\n+\n+    @Rule\n+    public final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();\n+\n+    private LocalPaxosComponents paxosComponents;\n+    private PaxosUseCase useCase = PaxosUseCase.LEADER_FOR_ALL_CLIENTS;\n+    private Path legacyDirectory;\n+    private Path sqliteDirectory;\n+\n+    @Before\n+    public void setUp() throws IOException {\n+        legacyDirectory = TEMPORARY_FOLDER.newFolder(\"legacy\").toPath();\n+        sqliteDirectory = TEMPORARY_FOLDER.newFolder(\"sqlite\").toPath();\n+        resetPaxosComponents();\n+    }\n+\n+    @Test\n+    public void learnerMigratesLogStateCorrectly() throws IOException {\n+        int round = 100;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        assertValuePresent(round, sqliteLog);\n+        assertValueLearned(round, learner);\n+    }\n+\n+    @Test\n+    public void legacyLogIsTheSourceOfTruthWhenValueOnlyInLegacy() throws IOException {\n+        int migratedRound = 100;\n+        int nonMigratedRound = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(migratedRound, valueForRound(migratedRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(nonMigratedRound, valueForRound(nonMigratedRound));\n+\n+        assertValueAbsent(nonMigratedRound, sqliteLog);\n+        assertValuePresent(nonMigratedRound, fileBasedLog);\n+        assertValueLearned(nonMigratedRound, learner);\n+    }\n+\n+    @Test\n+    public void legacyLogIsTheSourceOfTruthWhenValueAbsentFromLegacy() throws IOException {\n+        int migratedRound = 100;\n+        int rogueValue = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(migratedRound, valueForRound(migratedRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        sqliteLog.writeRound(rogueValue, valueForRound(rogueValue));\n+\n+        assertValuePresent(rogueValue, sqliteLog);\n+        assertValueAbsent(rogueValue, fileBasedLog);\n+        assertValueNotLearned(rogueValue, learner);\n+    }\n+\n+    @Test\n+    public void doesNotMigrateAgainIfGreatestSequencesMatch() throws IOException {\n+        int firstRound = 100;\n+        int secondRound = 200;\n+        int nonMigratedRound = 150;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(firstRound, valueForRound(firstRound));\n+        fileBasedLog.writeRound(secondRound, valueForRound(secondRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(nonMigratedRound, valueForRound(nonMigratedRound));\n+\n+        resetPaxosComponents();\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        assertValuePresent(firstRound, sqliteLog);\n+        assertValuePresent(secondRound, sqliteLog);\n+        assertValueAbsent(nonMigratedRound, sqliteLog);\n+        assertValueLearned(nonMigratedRound, learner);\n+    }\n+\n+    @Test\n+    public void migratesAgainIfOutOfSyncDetected() throws IOException {\n+        int firstRound = 100;\n+        int secondRound = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(firstRound, valueForRound(firstRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(secondRound, valueForRound(secondRound));\n+\n+        resetPaxosComponents();\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        assertValuePresent(secondRound, sqliteLog);\n+        assertValueLearned(secondRound, learner);\n+    }\n+\n+    @Test\n+    public void noCrossClientPollution() throws IOException {\n+        int round = 200;\n+        int otherRound = 100;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        Client otherClient = Client.of(\"other\");\n+        PaxosStateLog<PaxosValue> otherFileBasedLog = createFileSystemLog(otherClient);\n+        otherFileBasedLog.writeRound(otherRound, valueForRound(otherRound));\n+        fileBasedLog.writeRound(round, valueForRound(round));", "originalCommit": "8bc4cd00a6dcc9f70fb90cec90003e8175d11d44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE3OTQ3NA==", "url": "https://github.com/palantir/atlasdb/pull/4775#discussion_r425179474", "bodyText": "Bit of a funky param name for something that is supposed to exist \ud83d\ude04", "author": "jeremyk-91", "createdAt": "2020-05-14T14:26:23Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/paxos/PaxosStateLogMigrationIntegrationTest.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import com.palantir.atlasdb.util.MetricsManagers;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.ImmutablePaxosStorageParameters;\n+import com.palantir.paxos.PaxosLearner;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosStateLogImpl;\n+import com.palantir.paxos.PaxosStorageParameters;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+\n+public class PaxosStateLogMigrationIntegrationTest {\n+    private static final Client CLIENT = Client.of(\"test\");\n+\n+    @Rule\n+    public final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();\n+\n+    private LocalPaxosComponents paxosComponents;\n+    private PaxosUseCase useCase = PaxosUseCase.LEADER_FOR_ALL_CLIENTS;\n+    private Path legacyDirectory;\n+    private Path sqliteDirectory;\n+\n+    @Before\n+    public void setUp() throws IOException {\n+        legacyDirectory = TEMPORARY_FOLDER.newFolder(\"legacy\").toPath();\n+        sqliteDirectory = TEMPORARY_FOLDER.newFolder(\"sqlite\").toPath();\n+        resetPaxosComponents();\n+    }\n+\n+    @Test\n+    public void learnerMigratesLogStateCorrectly() throws IOException {\n+        int round = 100;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        assertValuePresent(round, sqliteLog);\n+        assertValueLearned(round, learner);\n+    }\n+\n+    @Test\n+    public void legacyLogIsTheSourceOfTruthWhenValueOnlyInLegacy() throws IOException {\n+        int migratedRound = 100;\n+        int nonMigratedRound = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(migratedRound, valueForRound(migratedRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(nonMigratedRound, valueForRound(nonMigratedRound));\n+\n+        assertValueAbsent(nonMigratedRound, sqliteLog);\n+        assertValuePresent(nonMigratedRound, fileBasedLog);\n+        assertValueLearned(nonMigratedRound, learner);\n+    }\n+\n+    @Test\n+    public void legacyLogIsTheSourceOfTruthWhenValueAbsentFromLegacy() throws IOException {\n+        int migratedRound = 100;\n+        int rogueValue = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(migratedRound, valueForRound(migratedRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        sqliteLog.writeRound(rogueValue, valueForRound(rogueValue));\n+\n+        assertValuePresent(rogueValue, sqliteLog);\n+        assertValueAbsent(rogueValue, fileBasedLog);\n+        assertValueNotLearned(rogueValue, learner);\n+    }\n+\n+    @Test\n+    public void doesNotMigrateAgainIfGreatestSequencesMatch() throws IOException {\n+        int firstRound = 100;\n+        int secondRound = 200;\n+        int nonMigratedRound = 150;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(firstRound, valueForRound(firstRound));\n+        fileBasedLog.writeRound(secondRound, valueForRound(secondRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(nonMigratedRound, valueForRound(nonMigratedRound));\n+\n+        resetPaxosComponents();\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        assertValuePresent(firstRound, sqliteLog);\n+        assertValuePresent(secondRound, sqliteLog);\n+        assertValueAbsent(nonMigratedRound, sqliteLog);\n+        assertValueLearned(nonMigratedRound, learner);\n+    }\n+\n+    @Test\n+    public void migratesAgainIfOutOfSyncDetected() throws IOException {\n+        int firstRound = 100;\n+        int secondRound = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(firstRound, valueForRound(firstRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(secondRound, valueForRound(secondRound));\n+\n+        resetPaxosComponents();\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        assertValuePresent(secondRound, sqliteLog);\n+        assertValueLearned(secondRound, learner);\n+    }\n+\n+    @Test\n+    public void noCrossClientPollution() throws IOException {\n+        int round = 200;\n+        int otherRound = 100;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        Client otherClient = Client.of(\"other\");\n+        PaxosStateLog<PaxosValue> otherFileBasedLog = createFileSystemLog(otherClient);\n+        otherFileBasedLog.writeRound(otherRound, valueForRound(otherRound));\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosLearner otherLearner = paxosComponents.learner(otherClient);\n+        PaxosStorageParameters otherParameters = getParametersForClient(otherClient);\n+        PaxosStateLog<PaxosValue> otherSqliteLog = createSqliteLog(otherParameters);\n+\n+        assertValueAbsent(round, otherSqliteLog);\n+        assertValuePresent(otherRound, otherSqliteLog);\n+        assertValueLearned(round, learner);\n+        assertValueNotLearned(otherRound, learner);\n+        assertValueNotLearned(round, otherLearner);\n+        assertValueLearned(otherRound, otherLearner);\n+    }\n+\n+    private void assertValueLearned(int secondRound, PaxosLearner learner) {\n+        assertThat(learner.getLearnedValue(secondRound)).hasValue(valueForRound(secondRound));\n+    }\n+\n+    private void assertValueNotLearned(int rogueValue, PaxosLearner learner) {\n+        assertThat(learner.getLearnedValue(rogueValue)).isEmpty();\n+    }\n+\n+    private void assertValuePresent(int rogueValue, PaxosStateLog<PaxosValue> sqliteLog) throws IOException {", "originalCommit": "8bc4cd00a6dcc9f70fb90cec90003e8175d11d44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE4MDM1MA==", "url": "https://github.com/palantir/atlasdb/pull/4775#discussion_r425180350", "bodyText": "nit: dir.resolve(PaxosTimeLockConstants.LEARNER_SUBDIRECTORY_PATH).toString()?", "author": "jeremyk-91", "createdAt": "2020-05-14T14:27:35Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/paxos/PaxosStateLogMigrationIntegrationTest.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import com.palantir.atlasdb.util.MetricsManagers;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.ImmutablePaxosStorageParameters;\n+import com.palantir.paxos.PaxosLearner;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosStateLogImpl;\n+import com.palantir.paxos.PaxosStorageParameters;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+\n+public class PaxosStateLogMigrationIntegrationTest {\n+    private static final Client CLIENT = Client.of(\"test\");\n+\n+    @Rule\n+    public final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();\n+\n+    private LocalPaxosComponents paxosComponents;\n+    private PaxosUseCase useCase = PaxosUseCase.LEADER_FOR_ALL_CLIENTS;\n+    private Path legacyDirectory;\n+    private Path sqliteDirectory;\n+\n+    @Before\n+    public void setUp() throws IOException {\n+        legacyDirectory = TEMPORARY_FOLDER.newFolder(\"legacy\").toPath();\n+        sqliteDirectory = TEMPORARY_FOLDER.newFolder(\"sqlite\").toPath();\n+        resetPaxosComponents();\n+    }\n+\n+    @Test\n+    public void learnerMigratesLogStateCorrectly() throws IOException {\n+        int round = 100;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        assertValuePresent(round, sqliteLog);\n+        assertValueLearned(round, learner);\n+    }\n+\n+    @Test\n+    public void legacyLogIsTheSourceOfTruthWhenValueOnlyInLegacy() throws IOException {\n+        int migratedRound = 100;\n+        int nonMigratedRound = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(migratedRound, valueForRound(migratedRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(nonMigratedRound, valueForRound(nonMigratedRound));\n+\n+        assertValueAbsent(nonMigratedRound, sqliteLog);\n+        assertValuePresent(nonMigratedRound, fileBasedLog);\n+        assertValueLearned(nonMigratedRound, learner);\n+    }\n+\n+    @Test\n+    public void legacyLogIsTheSourceOfTruthWhenValueAbsentFromLegacy() throws IOException {\n+        int migratedRound = 100;\n+        int rogueValue = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(migratedRound, valueForRound(migratedRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        sqliteLog.writeRound(rogueValue, valueForRound(rogueValue));\n+\n+        assertValuePresent(rogueValue, sqliteLog);\n+        assertValueAbsent(rogueValue, fileBasedLog);\n+        assertValueNotLearned(rogueValue, learner);\n+    }\n+\n+    @Test\n+    public void doesNotMigrateAgainIfGreatestSequencesMatch() throws IOException {\n+        int firstRound = 100;\n+        int secondRound = 200;\n+        int nonMigratedRound = 150;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(firstRound, valueForRound(firstRound));\n+        fileBasedLog.writeRound(secondRound, valueForRound(secondRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(nonMigratedRound, valueForRound(nonMigratedRound));\n+\n+        resetPaxosComponents();\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        assertValuePresent(firstRound, sqliteLog);\n+        assertValuePresent(secondRound, sqliteLog);\n+        assertValueAbsent(nonMigratedRound, sqliteLog);\n+        assertValueLearned(nonMigratedRound, learner);\n+    }\n+\n+    @Test\n+    public void migratesAgainIfOutOfSyncDetected() throws IOException {\n+        int firstRound = 100;\n+        int secondRound = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(firstRound, valueForRound(firstRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(secondRound, valueForRound(secondRound));\n+\n+        resetPaxosComponents();\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        assertValuePresent(secondRound, sqliteLog);\n+        assertValueLearned(secondRound, learner);\n+    }\n+\n+    @Test\n+    public void noCrossClientPollution() throws IOException {\n+        int round = 200;\n+        int otherRound = 100;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        Client otherClient = Client.of(\"other\");\n+        PaxosStateLog<PaxosValue> otherFileBasedLog = createFileSystemLog(otherClient);\n+        otherFileBasedLog.writeRound(otherRound, valueForRound(otherRound));\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosLearner otherLearner = paxosComponents.learner(otherClient);\n+        PaxosStorageParameters otherParameters = getParametersForClient(otherClient);\n+        PaxosStateLog<PaxosValue> otherSqliteLog = createSqliteLog(otherParameters);\n+\n+        assertValueAbsent(round, otherSqliteLog);\n+        assertValuePresent(otherRound, otherSqliteLog);\n+        assertValueLearned(round, learner);\n+        assertValueNotLearned(otherRound, learner);\n+        assertValueNotLearned(round, otherLearner);\n+        assertValueLearned(otherRound, otherLearner);\n+    }\n+\n+    private void assertValueLearned(int secondRound, PaxosLearner learner) {\n+        assertThat(learner.getLearnedValue(secondRound)).hasValue(valueForRound(secondRound));\n+    }\n+\n+    private void assertValueNotLearned(int rogueValue, PaxosLearner learner) {\n+        assertThat(learner.getLearnedValue(rogueValue)).isEmpty();\n+    }\n+\n+    private void assertValuePresent(int rogueValue, PaxosStateLog<PaxosValue> sqliteLog) throws IOException {\n+        assertThat(PaxosValue.BYTES_HYDRATOR.hydrateFromBytes(sqliteLog.readRound(rogueValue)))\n+                .isEqualTo(valueForRound(rogueValue));\n+    }\n+\n+    private void assertValueAbsent(int nonMigratedRound, PaxosStateLog<PaxosValue> sqliteLog)\n+            throws IOException {\n+        assertThat(sqliteLog.readRound(nonMigratedRound)).isNull();\n+    }\n+\n+    private void resetPaxosComponents() {\n+        paxosComponents = new LocalPaxosComponents(\n+                TimelockPaxosMetrics.of(useCase, MetricsManagers.createForTests()),\n+                useCase,\n+                legacyDirectory,\n+                sqliteDirectory, UUID.randomUUID(), true);\n+    }\n+\n+    private PaxosValue valueForRound(int i) {\n+        return new PaxosValue(\"value\", i, new byte[] {1});\n+    }\n+\n+    private PaxosStateLog<PaxosValue> createFileSystemLog(Client client) {\n+        Path dir = useCase.logDirectoryRelativeToDataDirectory(legacyDirectory).resolve(client.value());\n+        String learnerLogDir = Paths.get(dir.toString(), PaxosTimeLockConstants.LEARNER_SUBDIRECTORY_PATH).toString();", "originalCommit": "8bc4cd00a6dcc9f70fb90cec90003e8175d11d44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIzOTI5NA==", "url": "https://github.com/palantir/atlasdb/pull/4775#discussion_r425239294", "bodyText": "Scratch the previous comment. Changed, but left the old version in the production codepath because I'm paranoid about refactoring things I am not 100% certain about", "author": "gmaretic", "createdAt": "2020-05-14T15:45:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE4MDM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE4MTg3Mw==", "url": "https://github.com/palantir/atlasdb/pull/4775#discussion_r425181873", "bodyText": "consider @VisibleForTesting in other class", "author": "jeremyk-91", "createdAt": "2020-05-14T14:29:33Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/paxos/PaxosStateLogMigrationIntegrationTest.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import com.palantir.atlasdb.util.MetricsManagers;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.ImmutablePaxosStorageParameters;\n+import com.palantir.paxos.PaxosLearner;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosStateLogImpl;\n+import com.palantir.paxos.PaxosStorageParameters;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+\n+public class PaxosStateLogMigrationIntegrationTest {\n+    private static final Client CLIENT = Client.of(\"test\");\n+\n+    @Rule\n+    public final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();\n+\n+    private LocalPaxosComponents paxosComponents;\n+    private PaxosUseCase useCase = PaxosUseCase.LEADER_FOR_ALL_CLIENTS;\n+    private Path legacyDirectory;\n+    private Path sqliteDirectory;\n+\n+    @Before\n+    public void setUp() throws IOException {\n+        legacyDirectory = TEMPORARY_FOLDER.newFolder(\"legacy\").toPath();\n+        sqliteDirectory = TEMPORARY_FOLDER.newFolder(\"sqlite\").toPath();\n+        resetPaxosComponents();\n+    }\n+\n+    @Test\n+    public void learnerMigratesLogStateCorrectly() throws IOException {\n+        int round = 100;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        assertValuePresent(round, sqliteLog);\n+        assertValueLearned(round, learner);\n+    }\n+\n+    @Test\n+    public void legacyLogIsTheSourceOfTruthWhenValueOnlyInLegacy() throws IOException {\n+        int migratedRound = 100;\n+        int nonMigratedRound = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(migratedRound, valueForRound(migratedRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(nonMigratedRound, valueForRound(nonMigratedRound));\n+\n+        assertValueAbsent(nonMigratedRound, sqliteLog);\n+        assertValuePresent(nonMigratedRound, fileBasedLog);\n+        assertValueLearned(nonMigratedRound, learner);\n+    }\n+\n+    @Test\n+    public void legacyLogIsTheSourceOfTruthWhenValueAbsentFromLegacy() throws IOException {\n+        int migratedRound = 100;\n+        int rogueValue = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(migratedRound, valueForRound(migratedRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        sqliteLog.writeRound(rogueValue, valueForRound(rogueValue));\n+\n+        assertValuePresent(rogueValue, sqliteLog);\n+        assertValueAbsent(rogueValue, fileBasedLog);\n+        assertValueNotLearned(rogueValue, learner);\n+    }\n+\n+    @Test\n+    public void doesNotMigrateAgainIfGreatestSequencesMatch() throws IOException {\n+        int firstRound = 100;\n+        int secondRound = 200;\n+        int nonMigratedRound = 150;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(firstRound, valueForRound(firstRound));\n+        fileBasedLog.writeRound(secondRound, valueForRound(secondRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(nonMigratedRound, valueForRound(nonMigratedRound));\n+\n+        resetPaxosComponents();\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        assertValuePresent(firstRound, sqliteLog);\n+        assertValuePresent(secondRound, sqliteLog);\n+        assertValueAbsent(nonMigratedRound, sqliteLog);\n+        assertValueLearned(nonMigratedRound, learner);\n+    }\n+\n+    @Test\n+    public void migratesAgainIfOutOfSyncDetected() throws IOException {\n+        int firstRound = 100;\n+        int secondRound = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(firstRound, valueForRound(firstRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(secondRound, valueForRound(secondRound));\n+\n+        resetPaxosComponents();\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        assertValuePresent(secondRound, sqliteLog);\n+        assertValueLearned(secondRound, learner);\n+    }\n+\n+    @Test\n+    public void noCrossClientPollution() throws IOException {\n+        int round = 200;\n+        int otherRound = 100;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        Client otherClient = Client.of(\"other\");\n+        PaxosStateLog<PaxosValue> otherFileBasedLog = createFileSystemLog(otherClient);\n+        otherFileBasedLog.writeRound(otherRound, valueForRound(otherRound));\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosLearner otherLearner = paxosComponents.learner(otherClient);\n+        PaxosStorageParameters otherParameters = getParametersForClient(otherClient);\n+        PaxosStateLog<PaxosValue> otherSqliteLog = createSqliteLog(otherParameters);\n+\n+        assertValueAbsent(round, otherSqliteLog);\n+        assertValuePresent(otherRound, otherSqliteLog);\n+        assertValueLearned(round, learner);\n+        assertValueNotLearned(otherRound, learner);\n+        assertValueNotLearned(round, otherLearner);\n+        assertValueLearned(otherRound, otherLearner);\n+    }\n+\n+    private void assertValueLearned(int secondRound, PaxosLearner learner) {\n+        assertThat(learner.getLearnedValue(secondRound)).hasValue(valueForRound(secondRound));\n+    }\n+\n+    private void assertValueNotLearned(int rogueValue, PaxosLearner learner) {\n+        assertThat(learner.getLearnedValue(rogueValue)).isEmpty();\n+    }\n+\n+    private void assertValuePresent(int rogueValue, PaxosStateLog<PaxosValue> sqliteLog) throws IOException {\n+        assertThat(PaxosValue.BYTES_HYDRATOR.hydrateFromBytes(sqliteLog.readRound(rogueValue)))\n+                .isEqualTo(valueForRound(rogueValue));\n+    }\n+\n+    private void assertValueAbsent(int nonMigratedRound, PaxosStateLog<PaxosValue> sqliteLog)\n+            throws IOException {\n+        assertThat(sqliteLog.readRound(nonMigratedRound)).isNull();\n+    }\n+\n+    private void resetPaxosComponents() {\n+        paxosComponents = new LocalPaxosComponents(\n+                TimelockPaxosMetrics.of(useCase, MetricsManagers.createForTests()),\n+                useCase,\n+                legacyDirectory,\n+                sqliteDirectory, UUID.randomUUID(), true);\n+    }\n+\n+    private PaxosValue valueForRound(int i) {\n+        return new PaxosValue(\"value\", i, new byte[] {1});\n+    }\n+\n+    private PaxosStateLog<PaxosValue> createFileSystemLog(Client client) {\n+        Path dir = useCase.logDirectoryRelativeToDataDirectory(legacyDirectory).resolve(client.value());\n+        String learnerLogDir = Paths.get(dir.toString(), PaxosTimeLockConstants.LEARNER_SUBDIRECTORY_PATH).toString();\n+        return new PaxosStateLogImpl<>(learnerLogDir);\n+    }\n+\n+    private PaxosStateLog<PaxosValue> createSqliteLog(PaxosStorageParameters parameters) {\n+        Supplier<Connection> conn = SqliteConnections\n+                .createDefaultNamedSqliteDatabaseAtPath(parameters.sqliteBasedLogDirectory());\n+        return SqlitePaxosStateLog.create(parameters.namespaceAndUseCase(), conn);\n+    }\n+\n+    private PaxosStorageParameters getParametersForClient(Client client) {", "originalCommit": "8bc4cd00a6dcc9f70fb90cec90003e8175d11d44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE4MzMwNQ==", "url": "https://github.com/palantir/atlasdb/pull/4775#discussion_r425183305", "bodyText": "This should just be sqliteLogDirectory: we don't need to have separate SQLite instances for each of the use cases.", "author": "jeremyk-91", "createdAt": "2020-05-14T14:31:25Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/paxos/LocalPaxosComponents.java", "diffHunk": "@@ -50,12 +52,14 @@\n \n     LocalPaxosComponents(TimelockPaxosMetrics metrics,\n             PaxosUseCase paxosUseCase,\n-            Path baseLogDirectory,\n+            Path legacyLogDirectory,\n+            Path sqliteLogDirectory,\n             UUID leaderUuid,\n             boolean canCreateNewClients) {\n         this.metrics = metrics;\n         this.paxosUseCase = paxosUseCase;\n-        this.baseLogDirectory = baseLogDirectory;\n+        this.baseLogDirectory = legacyLogDirectory;\n+        this.sqliteLogDirectory = paxosUseCase.logDirectoryRelativeToDataDirectory(sqliteLogDirectory).toAbsolutePath();", "originalCommit": "8bc4cd00a6dcc9f70fb90cec90003e8175d11d44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE5NTMzMQ==", "url": "https://github.com/palantir/atlasdb/pull/4775#discussion_r425195331", "bodyText": "\ud83c\udf89", "author": "jeremyk-91", "createdAt": "2020-05-14T14:47:22Z", "path": "leader-election-impl/src/test/java/com/palantir/paxos/PaxosConsensusTestUtils.java", "diffHunk": "@@ -59,14 +62,15 @@ public static PaxosTestState setup(int numLeaders,\n         for (int i = 0; i < numLeaders; i++) {\n             failureToggles.add(new AtomicBoolean(false));\n \n-            PaxosLearner learner = PaxosLearnerImpl.newLearner(getLearnerLogDir(i));\n+            PaxosLearner learner = PaxosLearnerImpl\n+                    .newVerifyingLearner(getLearnerStorageParameters(i), PaxosKnowledgeEventRecorder.NO_OP);", "originalCommit": "8bc4cd00a6dcc9f70fb90cec90003e8175d11d44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3944229a48755017de6d51c4f7845eac089d762f", "url": "https://github.com/palantir/atlasdb/commit/3944229a48755017de6d51c4f7845eac089d762f", "message": "Implement different state support", "committedDate": "2020-05-14T15:26:04Z", "type": "commit"}, {"oid": "94d3595deb6cfeb690befe0f4a0e6509ebfbeb78", "url": "https://github.com/palantir/atlasdb/commit/94d3595deb6cfeb690befe0f4a0e6509ebfbeb78", "message": "Add migrated state", "committedDate": "2020-05-14T15:27:47Z", "type": "commit"}, {"oid": "997dd6c79f0f6eb7adec467d34ba39cb74363727", "url": "https://github.com/palantir/atlasdb/commit/997dd6c79f0f6eb7adec467d34ba39cb74363727", "message": "Wiring and integration tests", "committedDate": "2020-05-14T15:27:47Z", "type": "commit"}, {"oid": "39767cc205e35471b3adb439a1d79d4693fd01e7", "url": "https://github.com/palantir/atlasdb/commit/39767cc205e35471b3adb439a1d79d4693fd01e7", "message": "Small fixes", "committedDate": "2020-05-14T15:27:47Z", "type": "commit"}, {"oid": "ad67539449fd3fe8338d8585fa40fd55934ac005", "url": "https://github.com/palantir/atlasdb/commit/ad67539449fd3fe8338d8585fa40fd55934ac005", "message": "Merge and address old comments", "committedDate": "2020-05-14T15:29:48Z", "type": "commit"}, {"oid": "5f8215469f582839e6687a1e7258309ba1ee7e7e", "url": "https://github.com/palantir/atlasdb/commit/5f8215469f582839e6687a1e7258309ba1ee7e7e", "message": "Address CR", "committedDate": "2020-05-14T15:56:45Z", "type": "commit"}, {"oid": "b09124bddad335d5e79d6ff32298325a2d86bc89", "url": "https://github.com/palantir/atlasdb/commit/b09124bddad335d5e79d6ff32298325a2d86bc89", "message": "Add generated changelog entries", "committedDate": "2020-05-14T15:56:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTczNDY5Mg==", "url": "https://github.com/palantir/atlasdb/pull/4775#discussion_r425734692", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void migirateAgainIfMismatchDetected() throws IOException {\n          \n          \n            \n                public void migrateAgainIfMismatchDetected() throws IOException {", "author": "jeremyk-91", "createdAt": "2020-05-15T11:19:05Z", "path": "leader-election-impl/src/test/java/com/palantir/paxos/PaxosStateLogMigratorTest.java", "diffHunk": "@@ -93,19 +93,44 @@ public void migrationDeletesExistingState() {\n     }\n \n     @Test\n-    public void doNotMigrateIfAlreadyMigrated() {\n-        migrationState.migrateToValidationState();\n+    public void doNotMigrateIfAlreadyMigratedAndNoMismatchDetected() throws IOException {\n+        long lowerBound = 10;\n+        long upperBound = 25;\n+        List<PaxosValue> expectedValues = insertValuesWithinBounds(lowerBound, upperBound, source);\n \n-        long lowerBound = 1;\n-        long upperBound = 22;\n-        List<PaxosValue> valuesWritten = insertValuesWithinBounds(lowerBound, upperBound, source);\n+        migrateFrom(source);\n+        assertThat(migrationState.hasMigratedFromInitialState()).isTrue();\n+        assertThat(target.getLeastLogEntry()).isEqualTo(lowerBound);\n+        assertThat(target.getGreatestLogEntry()).isEqualTo(upperBound);\n \n+        List<PaxosValue> unExpectedValues = insertValuesWithinBounds(1, 2, source);\n         migrateFrom(source);\n \n+        assertThat(target.getLeastLogEntry()).isNotEqualTo(source.getLeastLogEntry());\n+        expectedValues.forEach(value -> assertThat(getPaxosValue(target, value.seq)).isEqualTo(value));\n+        unExpectedValues.forEach(value -> assertThat(readRoundUnchecked(target, value.seq)).isNull());\n+    }\n+\n+    @Test\n+    public void migirateAgainIfMismatchDetected() throws IOException {", "originalCommit": "b09124bddad335d5e79d6ff32298325a2d86bc89", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTczNzE1MA==", "url": "https://github.com/palantir/atlasdb/pull/4775#discussion_r425737150", "bodyText": "Could we add a bit more information (e.g. namespace, use-case, current/intended version) as args?", "author": "jeremyk-91", "createdAt": "2020-05-15T11:24:28Z", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLogMigrationState.java", "diffHunk": "@@ -54,29 +56,45 @@ private void initialize() {\n     }\n \n     public void migrateToValidationState() {\n-        execute(dao -> dao.migrateToVersion(namespace, useCase, States.VALIDATION.schemaVersion));\n+        execute(migrateToState(States.VALIDATION));\n     }\n \n     public void migrateToMigratedState() {\n-        execute(dao -> dao.migrateToVersion(namespace, useCase, States.MIGRATED.schemaVersion));\n+        execute(migrateToState(States.MIGRATED));\n     }\n \n     public boolean hasMigratedFromInitialState() {\n-        return !Objects.equals(States.NONE.getSchemaVersion(), execute(dao -> dao.getVersion(namespace, useCase)));\n+        return execute(dao -> dao.getVersion(namespace, useCase).isPresent());\n     }\n \n     public boolean isInValidationState() {\n-        return States.VALIDATION.getSchemaVersion().equals(execute(dao -> dao.getVersion(namespace, useCase)));\n+        return execute(dao -> dao.getVersion(namespace, useCase)\n+                .map(States.VALIDATION.getSchemaVersion()::equals)\n+                .orElse(false));\n     }\n \n     public boolean isInMigratedState() {\n-        return States.MIGRATED.getSchemaVersion().equals(execute(dao -> dao.getVersion(namespace, useCase)));\n+        return execute(dao -> dao.getVersion(namespace, useCase)\n+                .map(States.MIGRATED.getSchemaVersion()::equals)\n+                .orElse(false));\n     }\n \n     private <T> T execute(Function<Queries, T> call) {\n         return jdbi.withExtension(Queries.class, call::apply);\n     }\n \n+    private Function<Queries, Boolean> migrateToState(States state) {\n+        return dao -> {\n+            assertCurrentStateAtMost(dao, state);\n+            return dao.migrateToVersion(namespace, useCase, state.getSchemaVersion());\n+        };\n+    }\n+\n+    private void assertCurrentStateAtMost(Queries dao, States state) {\n+        dao.getVersion(namespace, useCase).ifPresent(currentVersion ->\n+                Preconditions.checkState(currentVersion <= state.getSchemaVersion()));", "originalCommit": "b09124bddad335d5e79d6ff32298325a2d86bc89", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "48e5b08acb3fec47eda7d210f069ba95b5d58653", "url": "https://github.com/palantir/atlasdb/commit/48e5b08acb3fec47eda7d210f069ba95b5d58653", "message": "Address CR", "committedDate": "2020-05-15T12:05:23Z", "type": "commit"}, {"oid": "bcc23e49fa9daf3aa206ce68a531e0af19475f47", "url": "https://github.com/palantir/atlasdb/commit/bcc23e49fa9daf3aa206ce68a531e0af19475f47", "message": "Merge branch 'develop' of github.com:palantir/atlasdb into psl/validation-wiring", "committedDate": "2020-05-15T12:05:29Z", "type": "commit"}, {"oid": "dd4ddadd62049dc790fafe7d5b0162e00266cfb9", "url": "https://github.com/palantir/atlasdb/commit/dd4ddadd62049dc790fafe7d5b0162e00266cfb9", "message": "Add release notes", "committedDate": "2020-05-15T12:06:32Z", "type": "commit"}]}