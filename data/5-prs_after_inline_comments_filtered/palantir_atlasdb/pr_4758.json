{"pr_number": 4758, "pr_title": "[PaxosStateLog] Parallel reads and processing", "pr_createdAt": "2020-05-07T16:35:32Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4758", "timeline": [{"oid": "ff728ba114d9aec7b8137feea576a1fffcce6ac9", "url": "https://github.com/palantir/atlasdb/commit/ff728ba114d9aec7b8137feea576a1fffcce6ac9", "message": "Read faster", "committedDate": "2020-05-07T16:10:11Z", "type": "commit"}, {"oid": "34f4ddabca168b2b5e1da64357db323ebb3b479c", "url": "https://github.com/palantir/atlasdb/commit/34f4ddabca168b2b5e1da64357db323ebb3b479c", "message": "Nits", "committedDate": "2020-05-07T16:35:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA4MTAzOQ==", "url": "https://github.com/palantir/atlasdb/pull/4758#discussion_r422081039", "bodyText": "Doesn't #readRound have a exclusive lock in PaxosStateLogImpl? How are you going to rewire this stuff, will there be a different impl just for reading the files that doesn't log?", "author": "jkozlowski", "createdAt": "2020-05-08T11:00:29Z", "path": "leader-election-impl/src/main/java/com/palantir/paxos/PaxosStateLogBatchReader.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListeningExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.palantir.atlasdb.futures.AtlasFutures;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.common.concurrent.NamedThreadFactory;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.common.persist.Persistable;\n+\n+public class PaxosStateLogBatchReader<V extends Persistable & Versionable> implements AutoCloseable {\n+    private final PaxosStateLog<V> delegate;\n+    private final Persistable.Hydrator<V> hydrator;\n+    private final ListeningExecutorService executor;\n+\n+    public PaxosStateLogBatchReader(PaxosStateLog<V> delegate, Persistable.Hydrator<V> hydrator, int numThreads) {\n+        this.delegate = delegate;\n+        this.hydrator = hydrator;\n+        this.executor = MoreExecutors.listeningDecorator(\n+                PTExecutors.newFixedThreadPool(numThreads, new NamedThreadFactory(\"psl-reader\", true)));\n+    }\n+\n+    /**\n+     * Reads entries from startSequence (inclusive) to startSequence + numEntries (exclusive) from the delegate log.\n+     *\n+     * @param startSequence first sequence to read\n+     * @param numEntries number of entries to read\n+     * @return a list of paxos rounds for all the present entries in the delegate log\n+     */\n+    public List<PaxosRound<V>> readBatch(long startSequence, int numEntries) {\n+        return AtlasFutures.getUnchecked(\n+                Futures.allAsList(\n+                        LongStream.range(startSequence, startSequence + numEntries)\n+                                .mapToObj(sequence -> executor.submit(() -> singleRead(sequence)))\n+                                .collect(Collectors.toList())))\n+                .stream()\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Optional<PaxosRound<V>> singleRead(long sequence) {\n+        try {\n+            return Optional.ofNullable(delegate.readRound(sequence))", "originalCommit": "34f4ddabca168b2b5e1da64357db323ebb3b479c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjExOTMzMg==", "url": "https://github.com/palantir/atlasdb/pull/4758#discussion_r422119332", "bodyText": "Yeah, that's something we have to discuss, but it's a solvable problem just outside the scope of this PR", "author": "gmaretic", "createdAt": "2020-05-08T12:39:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA4MTAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA2ODY0Ng==", "url": "https://github.com/palantir/atlasdb/pull/4758#discussion_r423068646", "bodyText": "Yep, I think we should be good to change that to a R/W lock (though be careful when reading that class to make sure it's safe!)", "author": "jeremyk-91", "createdAt": "2020-05-11T14:11:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA4MTAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA2NzYyNw==", "url": "https://github.com/palantir/atlasdb/pull/4758#discussion_r423067627", "bodyText": "nit: might be worth extracting a local predicate", "author": "jeremyk-91", "createdAt": "2020-05-11T14:10:23Z", "path": "leader-election-impl/src/test/java/com/palantir/paxos/PaxosStateLogBatchReaderTest.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+\n+import org.junit.Test;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+\n+public class PaxosStateLogBatchReaderTest {\n+    private static final int START_SEQUENCE = 123;\n+    private static final int BATCH_SIZE = 250;\n+    private static final List<PaxosRound<PaxosValue>> EXPECTED_ROUNDS = LongStream\n+            .range(START_SEQUENCE, START_SEQUENCE + BATCH_SIZE)\n+            .mapToObj(PaxosStateLogBatchReaderTest::valueForRound)\n+            .map(value -> PaxosRound.of(value.seq, value))\n+            .collect(Collectors.toList());\n+\n+    private PaxosStateLog<PaxosValue> mockLog = mock(PaxosStateLog.class);\n+\n+    @Test\n+    public void readConsecutiveBatch() throws IOException {\n+        when(mockLog.readRound(anyLong()))\n+                .thenAnswer(invocation -> valueForRound((long) invocation.getArguments()[0]).persistToBytes());\n+\n+        try (PaxosStateLogBatchReader<PaxosValue> reader = createReader()) {\n+            assertThat(reader.readBatch(START_SEQUENCE, BATCH_SIZE)).isEqualTo(EXPECTED_ROUNDS);\n+        }\n+    }\n+\n+    @Test\n+    public void exceptionsArePropagated() throws IOException {\n+        IOException ioException = new IOException(\"test\");\n+        when(mockLog.readRound(anyLong()))\n+                .thenAnswer(invocation -> {\n+                    long sequence = (long) invocation.getArguments()[0];\n+                    if (sequence == 200) {\n+                        throw ioException;\n+                    }\n+                    return valueForRound(sequence).persistToBytes();\n+                });\n+\n+        try (PaxosStateLogBatchReader<PaxosValue> reader = createReader()) {\n+            assertThatThrownBy(() -> reader.readBatch(START_SEQUENCE, BATCH_SIZE)).isInstanceOf(RuntimeException.class);\n+        }\n+    }\n+\n+    @Test\n+    public void readBatchFiltersOutNulls() throws IOException {\n+        when(mockLog.readRound(anyLong()))\n+                .thenAnswer(invocation -> {\n+                    long sequence = (long) invocation.getArguments()[0];\n+                    if (sequence % 2 == 0) {\n+                        return null;\n+                    }\n+                    return valueForRound(sequence).persistToBytes();\n+                });\n+\n+        try (PaxosStateLogBatchReader<PaxosValue> reader = createReader()) {\n+            assertThat(reader.readBatch(START_SEQUENCE, BATCH_SIZE))\n+                    .isEqualTo(EXPECTED_ROUNDS.stream()\n+                            .filter(round -> round.sequence() % 2 != 0)", "originalCommit": "34f4ddabca168b2b5e1da64357db323ebb3b479c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2e6658fbfef28e7c3073b1f6afc8a371dfbbf5d3", "url": "https://github.com/palantir/atlasdb/commit/2e6658fbfef28e7c3073b1f6afc8a371dfbbf5d3", "message": "Fix locking in PSLImpl", "committedDate": "2020-05-11T14:33:34Z", "type": "commit"}, {"oid": "89e8a0dfb7f7c82aa6072b1d0bbab992bb45729e", "url": "https://github.com/palantir/atlasdb/commit/89e8a0dfb7f7c82aa6072b1d0bbab992bb45729e", "message": "Add generated changelog entries", "committedDate": "2020-05-11T14:33:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzEyMDAxNQ==", "url": "https://github.com/palantir/atlasdb/pull/4758#discussion_r423120015", "bodyText": "Hmm. Could we put @GuardedBy(\"lock.writeLock()\"), or more defensively and probably better make this a concurrent hash map? Right now it's fine, but if later on a reader tries to use this (e.g. for caching) then memory visibility becomes a bit tricky.", "author": "jeremyk-91", "createdAt": "2020-05-11T15:22:37Z", "path": "leader-election-impl/src/main/java/com/palantir/paxos/PaxosStateLogImpl.java", "diffHunk": "@@ -50,7 +51,7 @@\n \n public class PaxosStateLogImpl<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n \n-    private final ReentrantLock lock = new ReentrantLock();\n+    private final ReadWriteLock lock = new ReentrantReadWriteLock();\n     private final Map<Long, Long> seqToVersionMap = Maps.newHashMap();", "originalCommit": "89e8a0dfb7f7c82aa6072b1d0bbab992bb45729e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "85f1f93c8f04bddbb2dd9473635e92eeb0c0d936", "url": "https://github.com/palantir/atlasdb/commit/85f1f93c8f04bddbb2dd9473635e92eeb0c0d936", "message": "CR", "committedDate": "2020-05-11T15:49:28Z", "type": "commit"}, {"oid": "a36f88888bd34221993e807c701abea8fc690f31", "url": "https://github.com/palantir/atlasdb/commit/a36f88888bd34221993e807c701abea8fc690f31", "message": "Make map concurrent", "committedDate": "2020-05-11T16:19:48Z", "type": "commit"}]}