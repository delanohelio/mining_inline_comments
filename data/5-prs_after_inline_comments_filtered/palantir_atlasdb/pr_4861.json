{"pr_number": 4861, "pr_title": "Feedback integration ii", "pr_createdAt": "2020-06-24T10:01:01Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4861", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk3NjM2NA==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r444976364", "bodyText": "make enum comparable", "author": "sudiksha27", "createdAt": "2020-06-24T15:22:05Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/HealthStatus.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+public enum HealthStatus {\n+    HEALTHY(true, 1),\n+    UNKNOWN(true, 2),\n+    UNHEALTHY(false, 3);\n+\n+    private final boolean isHealthy;\n+    private final int value;\n+\n+    HealthStatus(boolean isHealthy, int value) {\n+        this.isHealthy = isHealthy;\n+        this.value = value;\n+    }\n+\n+    public boolean isHealthy() {\n+        return isHealthy;\n+    }", "originalCommit": "e0df8dfd484c8b3cc51f0b9dae9e5312efa88ab6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk3NjQzOQ==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r444976439", "bodyText": "move to enum", "author": "sudiksha27", "createdAt": "2020-06-24T15:22:12Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/FeedbackProvider.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.timelock.feedback.ConjureTimeLockClientFeedback;\n+import com.palantir.timelock.feedback.EndpointStatistics;\n+\n+public final class FeedbackProvider {\n+\n+    private FeedbackProvider() {\n+        // no op\n+    }\n+\n+    public static HealthStatus getTimeLockHealthStatus() {\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports =\n+                TimeLockClientFeedbackSink.getTrackedFeedbackReports();\n+\n+        Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizedFeedback =\n+                organizeFeedbackReports(trackedFeedbackReports);\n+\n+        return healthStateOfTimeLock(organizedFeedback);\n+    }\n+\n+    @VisibleForTesting\n+    static Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizeFeedbackReports(\n+            List<ConjureTimeLockClientFeedback> trackedFeedbackReports) {\n+        Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizedFeedback = Maps.newHashMap();\n+\n+        for (ConjureTimeLockClientFeedback feedback : trackedFeedbackReports) {\n+            Map<UUID, List<ConjureTimeLockClientFeedback>> nodesForService = organizedFeedback.computeIfAbsent(\n+                    feedback.getServiceName(), service -> Maps.newHashMap());\n+\n+            List<ConjureTimeLockClientFeedback> feedbackForNode = nodesForService\n+                    .computeIfAbsent(feedback.getNodeId(), nodeId -> Lists.newLinkedList());\n+\n+            feedbackForNode.add(feedback);\n+        }\n+        return organizedFeedback;\n+    }\n+\n+    @VisibleForTesting\n+    static HealthStatus healthStateOfTimeLock(\n+            Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizedFeedback) {\n+        int maxAllowedUnhealthyServices = (int) (organizedFeedback.size()\n+                * Constants.UNHEALTHY_CLIENTS_PROPORTION_LIMIT);\n+\n+        return KeyedStream.stream(organizedFeedback).values().filter(\n+                nodeWiseStats -> getHealthStatusForService(nodeWiseStats) == HealthStatus.UNHEALTHY).count()\n+                > maxAllowedUnhealthyServices ? HealthStatus.UNHEALTHY : HealthStatus.HEALTHY;\n+    }\n+\n+    static HealthStatus getHealthStatusForService(Map<UUID, List<ConjureTimeLockClientFeedback>> nodeWiseStats) {\n+        // only the status that appears majority number of times is considered,\n+        // otherwise the health status for service is 'unknown'\n+\n+        return getHealthStatusOfMajority(nodeWiseStats.values().stream(),\n+                FeedbackProvider::getHealthStatusForNode,\n+                nodeWiseStats.size() / 2);\n+    }\n+\n+    static HealthStatus getHealthStatusForNode(List<ConjureTimeLockClientFeedback> feedbackForNode) {\n+        // only the status that appears majority number of times is considered,\n+        // otherwise the health status for node is 'unknown'\n+\n+        return getHealthStatusOfMajority(feedbackForNode.stream(),\n+                FeedbackProvider::pointFeedbackHealthStatus,\n+                feedbackForNode.size() / 2);\n+    }\n+\n+    private static <T> HealthStatus getHealthStatusOfMajority(Stream<T> feedbackForNode,\n+            Function<T, HealthStatus> mapper,\n+            int minThresholdToBeMajority) {\n+        return KeyedStream.stream(getFrequencyMap(feedbackForNode\n+                .map(mapper)))\n+                .filterEntries((key, val) -> val > minThresholdToBeMajority)\n+                .keys()\n+                .findFirst()\n+                .orElse(HealthStatus.UNKNOWN);\n+    }\n+\n+    static HealthStatus pointFeedbackHealthStatus(ConjureTimeLockClientFeedback healthReport) {\n+        if (Constants.ATLAS_BLACKLISTED_VERSIONS.contains(healthReport.getAtlasVersion())) {\n+            return HealthStatus.UNKNOWN;\n+        }\n+\n+        // considering the worst performing metric only, the health check should fail even if one end-point is unhealthy\n+        int healthNumericValue = 0;\n+        if (healthReport.getLeaderTime().isPresent()) {\n+            healthNumericValue = Math.max(healthNumericValue,\n+                    getHealthStatusForService(healthReport.getLeaderTime().get(),\n+                    Constants.MIN_REQUIRED_LEADER_TIME_ONE_MINUTE_RATE,\n+                    Constants.MAX_ACCEPTABLE_LEADER_TIME_P99_MILLI)\n+                            .getNumericValue());\n+        }\n+\n+        if (healthReport.getStartTransaction().isPresent()) {\n+            healthNumericValue = Math.max(healthNumericValue,\n+                    getHealthStatusForService(healthReport.getStartTransaction().get(),\n+                    Constants.MIN_REQUIRED_START_TXN_ONE_MINUTE_RATE,\n+                    Constants.MAX_ACCEPTABLE_START_TXN_P99_MILLI)\n+                    .getNumericValue());\n+        }\n+\n+        return healthStatusForNumericValue(healthNumericValue);\n+    }\n+\n+    static private HealthStatus getHealthStatusForService(EndpointStatistics endpointStatistics,\n+            int rateThreshold,\n+            int p99Limit) {\n+\n+        if (endpointStatistics.getOneMin() < rateThreshold) {\n+            return HealthStatus.UNKNOWN;\n+        }\n+\n+        return endpointStatistics.getP99() > p99Limit\n+                ? HealthStatus.UNHEALTHY : HealthStatus.HEALTHY;\n+    }\n+\n+\n+    private static HealthStatus healthStatusForNumericValue(int majorityStatus) {\n+        return majorityStatus > 1 ? (majorityStatus > 2 ? HealthStatus.UNHEALTHY : HealthStatus.UNKNOWN)\n+                : HealthStatus.HEALTHY;", "originalCommit": "e0df8dfd484c8b3cc51f0b9dae9e5312efa88ab6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk3NjYzMA==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r444976630", "bodyText": "move it to util", "author": "sudiksha27", "createdAt": "2020-06-24T15:22:26Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/FeedbackProvider.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.timelock.feedback.ConjureTimeLockClientFeedback;\n+import com.palantir.timelock.feedback.EndpointStatistics;\n+\n+public final class FeedbackProvider {\n+\n+    private FeedbackProvider() {\n+        // no op\n+    }\n+\n+    public static HealthStatus getTimeLockHealthStatus() {\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports =\n+                TimeLockClientFeedbackSink.getTrackedFeedbackReports();\n+\n+        Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizedFeedback =\n+                organizeFeedbackReports(trackedFeedbackReports);\n+\n+        return healthStateOfTimeLock(organizedFeedback);\n+    }\n+\n+    @VisibleForTesting\n+    static Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizeFeedbackReports(\n+            List<ConjureTimeLockClientFeedback> trackedFeedbackReports) {\n+        Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizedFeedback = Maps.newHashMap();\n+\n+        for (ConjureTimeLockClientFeedback feedback : trackedFeedbackReports) {\n+            Map<UUID, List<ConjureTimeLockClientFeedback>> nodesForService = organizedFeedback.computeIfAbsent(\n+                    feedback.getServiceName(), service -> Maps.newHashMap());\n+\n+            List<ConjureTimeLockClientFeedback> feedbackForNode = nodesForService\n+                    .computeIfAbsent(feedback.getNodeId(), nodeId -> Lists.newLinkedList());\n+\n+            feedbackForNode.add(feedback);\n+        }\n+        return organizedFeedback;\n+    }\n+\n+    @VisibleForTesting\n+    static HealthStatus healthStateOfTimeLock(\n+            Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizedFeedback) {\n+        int maxAllowedUnhealthyServices = (int) (organizedFeedback.size()\n+                * Constants.UNHEALTHY_CLIENTS_PROPORTION_LIMIT);\n+\n+        return KeyedStream.stream(organizedFeedback).values().filter(\n+                nodeWiseStats -> getHealthStatusForService(nodeWiseStats) == HealthStatus.UNHEALTHY).count()\n+                > maxAllowedUnhealthyServices ? HealthStatus.UNHEALTHY : HealthStatus.HEALTHY;\n+    }\n+\n+    static HealthStatus getHealthStatusForService(Map<UUID, List<ConjureTimeLockClientFeedback>> nodeWiseStats) {\n+        // only the status that appears majority number of times is considered,\n+        // otherwise the health status for service is 'unknown'\n+\n+        return getHealthStatusOfMajority(nodeWiseStats.values().stream(),\n+                FeedbackProvider::getHealthStatusForNode,\n+                nodeWiseStats.size() / 2);\n+    }\n+\n+    static HealthStatus getHealthStatusForNode(List<ConjureTimeLockClientFeedback> feedbackForNode) {\n+        // only the status that appears majority number of times is considered,\n+        // otherwise the health status for node is 'unknown'\n+\n+        return getHealthStatusOfMajority(feedbackForNode.stream(),\n+                FeedbackProvider::pointFeedbackHealthStatus,\n+                feedbackForNode.size() / 2);\n+    }\n+\n+    private static <T> HealthStatus getHealthStatusOfMajority(Stream<T> feedbackForNode,\n+            Function<T, HealthStatus> mapper,\n+            int minThresholdToBeMajority) {\n+        return KeyedStream.stream(getFrequencyMap(feedbackForNode\n+                .map(mapper)))\n+                .filterEntries((key, val) -> val > minThresholdToBeMajority)\n+                .keys()\n+                .findFirst()\n+                .orElse(HealthStatus.UNKNOWN);\n+    }\n+\n+    static HealthStatus pointFeedbackHealthStatus(ConjureTimeLockClientFeedback healthReport) {\n+        if (Constants.ATLAS_BLACKLISTED_VERSIONS.contains(healthReport.getAtlasVersion())) {\n+            return HealthStatus.UNKNOWN;\n+        }\n+\n+        // considering the worst performing metric only, the health check should fail even if one end-point is unhealthy\n+        int healthNumericValue = 0;\n+        if (healthReport.getLeaderTime().isPresent()) {\n+            healthNumericValue = Math.max(healthNumericValue,\n+                    getHealthStatusForService(healthReport.getLeaderTime().get(),\n+                    Constants.MIN_REQUIRED_LEADER_TIME_ONE_MINUTE_RATE,\n+                    Constants.MAX_ACCEPTABLE_LEADER_TIME_P99_MILLI)\n+                            .getNumericValue());\n+        }\n+\n+        if (healthReport.getStartTransaction().isPresent()) {\n+            healthNumericValue = Math.max(healthNumericValue,\n+                    getHealthStatusForService(healthReport.getStartTransaction().get(),\n+                    Constants.MIN_REQUIRED_START_TXN_ONE_MINUTE_RATE,\n+                    Constants.MAX_ACCEPTABLE_START_TXN_P99_MILLI)\n+                    .getNumericValue());\n+        }\n+\n+        return healthStatusForNumericValue(healthNumericValue);\n+    }\n+\n+    static private HealthStatus getHealthStatusForService(EndpointStatistics endpointStatistics,\n+            int rateThreshold,\n+            int p99Limit) {\n+\n+        if (endpointStatistics.getOneMin() < rateThreshold) {\n+            return HealthStatus.UNKNOWN;\n+        }\n+\n+        return endpointStatistics.getP99() > p99Limit\n+                ? HealthStatus.UNHEALTHY : HealthStatus.HEALTHY;\n+    }\n+\n+\n+    private static HealthStatus healthStatusForNumericValue(int majorityStatus) {\n+        return majorityStatus > 1 ? (majorityStatus > 2 ? HealthStatus.UNHEALTHY : HealthStatus.UNKNOWN)\n+                : HealthStatus.HEALTHY;\n+    }\n+\n+    static <T> Map<T, Long> getFrequencyMap(Stream<T> streamOfStuff) {\n+        return streamOfStuff\n+                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n+    }\n+", "originalCommit": "e0df8dfd484c8b3cc51f0b9dae9e5312efa88ab6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk3OTAxMQ==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r444979011", "bodyText": "Have a cache injector, there;s a way to test that does not req 2 min | testing method on cache, allows to pass a ticker", "author": "sudiksha27", "createdAt": "2020-06-24T15:25:42Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/TimeLockClientFeedbackSink.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.timelock.feedback.ConjureTimeLockClientFeedback;\n+\n+public final class TimeLockClientFeedbackSink {\n+    private static Cache<Integer, ConjureTimeLockClientFeedback> trackedFeedbackReports = Caffeine.newBuilder()\n+            .expireAfterWrite(Constants.HEALTH_FEEDBACK_REPORT_EXPIRATION_MINUTES, TimeUnit.MINUTES)\n+            .build();\n+\n+    private TimeLockClientFeedbackSink() {\n+        // no op", "originalCommit": "e0df8dfd484c8b3cc51f0b9dae9e5312efa88ab6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk4MjY2Nw==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r444982667", "bodyText": "test id expiry is happening", "author": "sudiksha27", "createdAt": "2020-06-24T15:30:31Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/adjudicate/FeedbackSinkTest.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.junit.Test;\n+\n+import com.palantir.timelock.feedback.ConjureTimeLockClientFeedback;\n+\n+public class FeedbackSinkTest {\n+    private static final ConjureTimeLockClientFeedback TEST_REPORT = getTestReport();\n+\n+    static {\n+        TimeLockClientFeedbackSink.registerFeedback(TEST_REPORT);\n+    }\n+\n+    @Test\n+    public void feedbackIsRegistered() {\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports =\n+                TimeLockClientFeedbackSink.getTrackedFeedbackReports();\n+        assertThat(trackedFeedbackReports.size()).isEqualTo(1);\n+        assertThat(trackedFeedbackReports).containsExactly(TEST_REPORT);\n+    }\n+\n+    @Test\n+    public void feedbackRetrievedFromSinkIsImmutable() {\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports =\n+                TimeLockClientFeedbackSink.getTrackedFeedbackReports();\n+        assertThatThrownBy(() -> trackedFeedbackReports.add(TEST_REPORT))\n+                .isInstanceOf(UnsupportedOperationException.class);\n+    }\n+\n+    static ConjureTimeLockClientFeedback getTestReport() {\n+        return ConjureTimeLockClientFeedback.builder()\n+                .nodeId(UUID.randomUUID())\n+                .serviceName(\"client_1\")\n+                .atlasVersion(\"0.1.0\")\n+                .build();\n+    }", "originalCommit": "e0df8dfd484c8b3cc51f0b9dae9e5312efa88ab6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fedcd23504c61f5ceec23b7cb1a300664316c150", "url": "https://github.com/palantir/atlasdb/commit/fedcd23504c61f5ceec23b7cb1a300664316c150", "message": "Basic layer", "committedDate": "2020-06-24T19:21:08Z", "type": "commit"}, {"oid": "9f0ffdc16e97faaf75c9db96480455a52288ba7f", "url": "https://github.com/palantir/atlasdb/commit/9f0ffdc16e97faaf75c9db96480455a52288ba7f", "message": "remove todo", "committedDate": "2020-06-24T19:21:27Z", "type": "commit"}, {"oid": "9f0ffdc16e97faaf75c9db96480455a52288ba7f", "url": "https://github.com/palantir/atlasdb/commit/9f0ffdc16e97faaf75c9db96480455a52288ba7f", "message": "remove todo", "committedDate": "2020-06-24T19:21:27Z", "type": "forcePushed"}, {"oid": "0a576b666e19b747b1940f6d5d0c22d1c6ec0ae1", "url": "https://github.com/palantir/atlasdb/commit/0a576b666e19b747b1940f6d5d0c22d1c6ec0ae1", "message": "Address comments", "committedDate": "2020-06-24T20:24:56Z", "type": "commit"}, {"oid": "b65f0af6d8a3768fe7092a36e3d740c9b6aa5fa0", "url": "https://github.com/palantir/atlasdb/commit/b65f0af6d8a3768fe7092a36e3d740c9b6aa5fa0", "message": "Tests", "committedDate": "2020-06-24T21:29:56Z", "type": "commit"}, {"oid": "85abdf32a718599e42e6252aac8f8b6c52a38295", "url": "https://github.com/palantir/atlasdb/commit/85abdf32a718599e42e6252aac8f8b6c52a38295", "message": "Moree tests", "committedDate": "2020-06-24T21:55:25Z", "type": "commit"}, {"oid": "d7b9d85646a6d36f3c310129d47a0fcc539cf22d", "url": "https://github.com/palantir/atlasdb/commit/d7b9d85646a6d36f3c310129d47a0fcc539cf22d", "message": "Add generated changelog entries", "committedDate": "2020-06-24T21:55:25Z", "type": "commit"}, {"oid": "19382bb71607c43ad0e1517574ab84529edda709", "url": "https://github.com/palantir/atlasdb/commit/19382bb71607c43ad0e1517574ab84529edda709", "message": "Modify HealthState + tests", "committedDate": "2020-06-25T09:22:27Z", "type": "commit"}, {"oid": "b0fae302d94552f9aa159c07d797c3c07d9b8295", "url": "https://github.com/palantir/atlasdb/commit/b0fae302d94552f9aa159c07d797c3c07d9b8295", "message": "Merge branch 'feedback_integration_ii' of github.com:palantir/atlasdb into feedback_integration_ii", "committedDate": "2020-06-25T09:22:41Z", "type": "commit"}, {"oid": "70545d66256e9730e0306277d398f16abe53736c", "url": "https://github.com/palantir/atlasdb/commit/70545d66256e9730e0306277d398f16abe53736c", "message": "Refactor", "committedDate": "2020-06-25T09:41:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ2MDY0MQ==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r445460641", "bodyText": "I think it's preferred to define the times as durations (with units in the name).\nAlso for the proportion it's probably fine to use 1. / 3 as opposed to 0.34.", "author": "jeremyk-91", "createdAt": "2020-06-25T10:27:31Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/Constants.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import java.util.Set;\n+\n+import com.google.common.collect.Sets;\n+\n+public final class Constants {\n+    private Constants() {\n+        // no op\n+    }\n+\n+    public static final int HEALTH_FEEDBACK_REPORT_EXPIRATION_MINUTES = 2;\n+    public static final double UNHEALTHY_CLIENTS_PROPORTION_LIMIT = 0.34;\n+    public static final int MIN_REQUIRED_LEADER_TIME_ONE_MINUTE_RATE = 60;\n+    public static final int MAX_ACCEPTABLE_LEADER_TIME_P99_MILLI = 200;\n+    public static final int MIN_REQUIRED_START_TXN_ONE_MINUTE_RATE = 60;\n+    public static final int MAX_ACCEPTABLE_START_TXN_P99_MILLI = 500;", "originalCommit": "70545d66256e9730e0306277d398f16abe53736c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ2MTM1NQ==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r445461355", "bodyText": "non-actionable: This is fine for now. We might end up wanting to do range blacklists, so I don't know if long term a Set is the correct structure, but let's stick with this. (For generality you'd probably want a range-set, especially as Large Internal Product moves to TimeLock, but not right now!)", "author": "jeremyk-91", "createdAt": "2020-06-25T10:29:01Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/Constants.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import java.util.Set;\n+\n+import com.google.common.collect.Sets;\n+\n+public final class Constants {\n+    private Constants() {\n+        // no op\n+    }\n+\n+    public static final int HEALTH_FEEDBACK_REPORT_EXPIRATION_MINUTES = 2;\n+    public static final double UNHEALTHY_CLIENTS_PROPORTION_LIMIT = 0.34;\n+    public static final int MIN_REQUIRED_LEADER_TIME_ONE_MINUTE_RATE = 60;\n+    public static final int MAX_ACCEPTABLE_LEADER_TIME_P99_MILLI = 200;\n+    public static final int MIN_REQUIRED_START_TXN_ONE_MINUTE_RATE = 60;\n+    public static final int MAX_ACCEPTABLE_START_TXN_P99_MILLI = 500;\n+\n+\n+    public static final Set<String> ATLAS_BLACKLISTED_VERSIONS = Sets.newHashSet();", "originalCommit": "70545d66256e9730e0306277d398f16abe53736c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ2MjQyNw==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r445462427", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static  HealthStatus getHealthStatusForService(EndpointStatistics endpointStatistics,\n          \n          \n            \n                private static HealthStatus getHealthStatusForService(EndpointStatistics endpointStatistics,", "author": "jeremyk-91", "createdAt": "2020-06-25T10:31:03Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/FeedbackProvider.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.timelock.feedback.ConjureTimeLockClientFeedback;\n+import com.palantir.timelock.feedback.EndpointStatistics;\n+\n+public final class FeedbackProvider {\n+\n+    private FeedbackProvider() {\n+        // no op\n+    }\n+\n+    public static HealthStatus getTimeLockHealthStatus(TimeLockClientFeedbackSink timeLockClientFeedbackSink) {\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports =\n+                timeLockClientFeedbackSink.getTrackedFeedbackReports();\n+\n+        Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizedFeedback =\n+                organizeFeedbackReports(trackedFeedbackReports);\n+\n+        return healthStateOfTimeLock(organizedFeedback);\n+    }\n+\n+    private static Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizeFeedbackReports(\n+            List<ConjureTimeLockClientFeedback> trackedFeedbackReports) {\n+        Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizedFeedback = Maps.newHashMap();\n+\n+        for (ConjureTimeLockClientFeedback feedback : trackedFeedbackReports) {\n+            Map<UUID, List<ConjureTimeLockClientFeedback>> nodesForService = organizedFeedback.computeIfAbsent(\n+                    feedback.getServiceName(), service -> Maps.newHashMap());\n+\n+            List<ConjureTimeLockClientFeedback> feedbackForNode = nodesForService\n+                    .computeIfAbsent(feedback.getNodeId(), nodeId -> Lists.newLinkedList());\n+\n+            feedbackForNode.add(feedback);\n+        }\n+        return organizedFeedback;\n+    }\n+\n+    private static HealthStatus healthStateOfTimeLock(\n+            Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizedFeedback) {\n+        int maxAllowedUnhealthyServices = (int) (organizedFeedback.size()\n+                * Constants.UNHEALTHY_CLIENTS_PROPORTION_LIMIT);\n+\n+        return KeyedStream.stream(organizedFeedback).values().filter(\n+                nodeWiseStats -> getHealthStatusForService(nodeWiseStats) == HealthStatus.UNHEALTHY).count()\n+                > maxAllowedUnhealthyServices ? HealthStatus.UNHEALTHY : HealthStatus.HEALTHY;\n+    }\n+\n+    private static HealthStatus getHealthStatusForService(Map<UUID, List<ConjureTimeLockClientFeedback>> nodeWiseStats) {\n+        // only the status that appears majority number of times is considered,\n+        // otherwise the health status for service is 'unknown'\n+\n+        return getHealthStatusOfMajority(nodeWiseStats.values().stream(),\n+                FeedbackProvider::getHealthStatusForNode,\n+                nodeWiseStats.size() / 2);\n+    }\n+\n+    private static HealthStatus getHealthStatusForNode(List<ConjureTimeLockClientFeedback> feedbackForNode) {\n+        // only the status that appears majority number of times is considered,\n+        // otherwise the health status for node is 'unknown'\n+\n+        return getHealthStatusOfMajority(feedbackForNode.stream(),\n+                FeedbackProvider::pointFeedbackHealthStatus,\n+                feedbackForNode.size() / 2);\n+    }\n+\n+    private static <T> HealthStatus getHealthStatusOfMajority(Stream<T> feedbackForNode,\n+            Function<T, HealthStatus> mapper,\n+            int minThresholdToBeMajority) {\n+        return KeyedStream.stream(Utils.getFrequencyMap(feedbackForNode\n+                .map(mapper)))\n+                .filterEntries((key, val) -> val > minThresholdToBeMajority)\n+                .keys()\n+                .findFirst()\n+                .orElse(HealthStatus.UNKNOWN);\n+    }\n+\n+    @VisibleForTesting\n+    static HealthStatus pointFeedbackHealthStatus(ConjureTimeLockClientFeedback healthReport) {\n+        if (Constants.ATLAS_BLACKLISTED_VERSIONS.contains(healthReport.getAtlasVersion())) {\n+            return HealthStatus.UNKNOWN;\n+        }\n+        // considering the worst performing metric only, the health check should fail even if one end-point is unhealthy\n+        HealthStatus healthStatus = HealthStatus.HEALTHY;\n+\n+        if (healthReport.getLeaderTime().isPresent()) {\n+            healthStatus = HealthStatus.getWorseState(healthStatus,\n+                    getHealthStatusForService(healthReport.getLeaderTime().get(),\n+                            Constants.MIN_REQUIRED_LEADER_TIME_ONE_MINUTE_RATE,\n+                            Constants.MAX_ACCEPTABLE_LEADER_TIME_P99_MILLI));\n+        }\n+\n+        if (healthReport.getStartTransaction().isPresent()) {\n+            healthStatus = HealthStatus.getWorseState(healthStatus,\n+                    getHealthStatusForService(healthReport.getStartTransaction().get(),\n+                            Constants.MIN_REQUIRED_START_TXN_ONE_MINUTE_RATE,\n+                            Constants.MAX_ACCEPTABLE_START_TXN_P99_MILLI));\n+        }\n+\n+        return healthStatus;\n+    }\n+\n+    private static  HealthStatus getHealthStatusForService(EndpointStatistics endpointStatistics,", "originalCommit": "70545d66256e9730e0306277d398f16abe53736c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ2MjY3Mg==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r445462672", "bodyText": "nit: getWorst (you can provide more than two)", "author": "jeremyk-91", "createdAt": "2020-06-25T10:31:37Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/HealthStatus.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import java.util.HashSet;\n+\n+import com.google.common.collect.Sets;\n+\n+public enum HealthStatus {\n+    HEALTHY(true),\n+    UNKNOWN(true),\n+    UNHEALTHY(false);\n+\n+    private final boolean isHealthy;\n+\n+    HealthStatus(boolean isHealthy) {\n+        this.isHealthy = isHealthy;\n+    }\n+\n+    public boolean isHealthy() {\n+        return isHealthy;\n+    }\n+\n+    public static HealthStatus getWorseState(HealthStatus... statuses) {", "originalCommit": "70545d66256e9730e0306277d398f16abe53736c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ2MzEwNA==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r445463104", "bodyText": "Yep, if we added a severity field, then you could just do Arrays.stream(statuses).max(Comparator.comparingLong(HealthStatus::severity)). Or if we made the enums comparable based on that, then this could just be the max.", "author": "jeremyk-91", "createdAt": "2020-06-25T10:32:29Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/HealthStatus.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import java.util.HashSet;\n+\n+import com.google.common.collect.Sets;\n+\n+public enum HealthStatus {\n+    HEALTHY(true),\n+    UNKNOWN(true),\n+    UNHEALTHY(false);\n+\n+    private final boolean isHealthy;\n+\n+    HealthStatus(boolean isHealthy) {\n+        this.isHealthy = isHealthy;\n+    }\n+\n+    public boolean isHealthy() {\n+        return isHealthy;\n+    }\n+\n+    public static HealthStatus getWorseState(HealthStatus... statuses) {\n+        HashSet<HealthStatus> healthStatusSet = Sets.newHashSet(statuses);\n+        return healthStatusSet.contains(HealthStatus.UNHEALTHY) ? HealthStatus.UNHEALTHY\n+                : (healthStatusSet.contains(HealthStatus.UNKNOWN) ? HealthStatus.UNKNOWN : HealthStatus.HEALTHY);", "originalCommit": "70545d66256e9730e0306277d398f16abe53736c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ2NjA2MA==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r445466060", "bodyText": "nit: I'd suggest using a UUID to avoid collisions - hashCode has only 32 bits of entropy", "author": "jeremyk-91", "createdAt": "2020-06-25T10:38:23Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/TimeLockClientFeedbackSink.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import java.util.List;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.timelock.feedback.ConjureTimeLockClientFeedback;\n+\n+public final class TimeLockClientFeedbackSink {\n+    private Cache<Integer, ConjureTimeLockClientFeedback> trackedFeedbackReports;\n+\n+    private TimeLockClientFeedbackSink(Cache<Integer, ConjureTimeLockClientFeedback> trackedFeedbackReports) {\n+        this.trackedFeedbackReports = trackedFeedbackReports;\n+    }\n+\n+    public static TimeLockClientFeedbackSink create(\n+            Cache<Integer, ConjureTimeLockClientFeedback> trackedFeedbackReports) {\n+        return new TimeLockClientFeedbackSink(trackedFeedbackReports);\n+    }\n+\n+    public void registerFeedback(ConjureTimeLockClientFeedback feedback) {\n+        trackedFeedbackReports.put(feedback.hashCode(), feedback);", "originalCommit": "70545d66256e9730e0306277d398f16abe53736c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ2NjE3NQ==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r445466175", "bodyText": "nit: just stream will do here :)", "author": "jeremyk-91", "createdAt": "2020-06-25T10:38:38Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/Utils.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class Utils {\n+\n+    static <T> Map<T, Long> getFrequencyMap(Stream<T> streamOfStuff) {", "originalCommit": "70545d66256e9730e0306277d398f16abe53736c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ2Njk1Nw==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r445466957", "bodyText": "Interesting: is there a reason we wrote this as opposed to just nanos.get();? The memory semantics are different (this does a volatile write as well), though I don't understand why we need it", "author": "jeremyk-91", "createdAt": "2020-06-25T10:40:20Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/adjudicate/FakeTicker.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import com.github.benmanes.caffeine.cache.Ticker;\n+\n+class FakeTicker implements Ticker {\n+\n+    private final AtomicLong nanos = new AtomicLong();\n+\n+    public FakeTicker advance(long time, TimeUnit timeUnit) {\n+        nanos.addAndGet(timeUnit.toNanos(time));\n+        return this;\n+    }\n+\n+    @Override\n+    public long read() {\n+        long value = nanos.getAndAdd(0);\n+        return value;", "originalCommit": "70545d66256e9730e0306277d398f16abe53736c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ3NjQyMQ==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r445476421", "bodyText": "While this is fine, it's usually preferable to have structures for the intermediate layers, because it makes things easier to reason about. So I'd think\n\nthe inner one could be a Multimap<UUID, List<ConjureTimeLockClientFeedback>>. But really this is a mapping of nodes to feedback reports. I might call this intermediate structure ServiceFeedback.\nthe top level concept here as a String is a service name. I'd consider naming it maybe organizeFeedbackReportsByService and/or have a string wrapping class", "author": "jeremyk-91", "createdAt": "2020-06-25T11:00:08Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/FeedbackProvider.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.timelock.feedback.ConjureTimeLockClientFeedback;\n+import com.palantir.timelock.feedback.EndpointStatistics;\n+\n+public final class FeedbackProvider {\n+\n+    private FeedbackProvider() {\n+        // no op\n+    }\n+\n+    public static HealthStatus getTimeLockHealthStatus(TimeLockClientFeedbackSink timeLockClientFeedbackSink) {\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports =\n+                timeLockClientFeedbackSink.getTrackedFeedbackReports();\n+\n+        Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizedFeedback =", "originalCommit": "70545d66256e9730e0306277d398f16abe53736c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ3ODc1Ng==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r445478756", "bodyText": "ArrayList is normally preferred here, because of locality (i.e. the entries are stored close together in memory, which is useful because  we will end up accessing them sequentially later on).", "author": "jeremyk-91", "createdAt": "2020-06-25T11:05:10Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/FeedbackProvider.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.timelock.feedback.ConjureTimeLockClientFeedback;\n+import com.palantir.timelock.feedback.EndpointStatistics;\n+\n+public final class FeedbackProvider {\n+\n+    private FeedbackProvider() {\n+        // no op\n+    }\n+\n+    public static HealthStatus getTimeLockHealthStatus(TimeLockClientFeedbackSink timeLockClientFeedbackSink) {\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports =\n+                timeLockClientFeedbackSink.getTrackedFeedbackReports();\n+\n+        Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizedFeedback =\n+                organizeFeedbackReports(trackedFeedbackReports);\n+\n+        return healthStateOfTimeLock(organizedFeedback);\n+    }\n+\n+    private static Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizeFeedbackReports(\n+            List<ConjureTimeLockClientFeedback> trackedFeedbackReports) {\n+        Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizedFeedback = Maps.newHashMap();\n+\n+        for (ConjureTimeLockClientFeedback feedback : trackedFeedbackReports) {\n+            Map<UUID, List<ConjureTimeLockClientFeedback>> nodesForService = organizedFeedback.computeIfAbsent(\n+                    feedback.getServiceName(), service -> Maps.newHashMap());\n+\n+            List<ConjureTimeLockClientFeedback> feedbackForNode = nodesForService\n+                    .computeIfAbsent(feedback.getNodeId(), nodeId -> Lists.newLinkedList());", "originalCommit": "70545d66256e9730e0306277d398f16abe53736c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ3OTM2Mg==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r445479362", "bodyText": "I think we should use the error rate here as well?", "author": "jeremyk-91", "createdAt": "2020-06-25T11:06:23Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/FeedbackProvider.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.timelock.feedback.ConjureTimeLockClientFeedback;\n+import com.palantir.timelock.feedback.EndpointStatistics;\n+\n+public final class FeedbackProvider {\n+\n+    private FeedbackProvider() {\n+        // no op\n+    }\n+\n+    public static HealthStatus getTimeLockHealthStatus(TimeLockClientFeedbackSink timeLockClientFeedbackSink) {\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports =\n+                timeLockClientFeedbackSink.getTrackedFeedbackReports();\n+\n+        Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizedFeedback =\n+                organizeFeedbackReports(trackedFeedbackReports);\n+\n+        return healthStateOfTimeLock(organizedFeedback);\n+    }\n+\n+    private static Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizeFeedbackReports(\n+            List<ConjureTimeLockClientFeedback> trackedFeedbackReports) {\n+        Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizedFeedback = Maps.newHashMap();\n+\n+        for (ConjureTimeLockClientFeedback feedback : trackedFeedbackReports) {\n+            Map<UUID, List<ConjureTimeLockClientFeedback>> nodesForService = organizedFeedback.computeIfAbsent(\n+                    feedback.getServiceName(), service -> Maps.newHashMap());\n+\n+            List<ConjureTimeLockClientFeedback> feedbackForNode = nodesForService\n+                    .computeIfAbsent(feedback.getNodeId(), nodeId -> Lists.newLinkedList());\n+\n+            feedbackForNode.add(feedback);\n+        }\n+        return organizedFeedback;\n+    }\n+\n+    private static HealthStatus healthStateOfTimeLock(\n+            Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizedFeedback) {\n+        int maxAllowedUnhealthyServices = (int) (organizedFeedback.size()\n+                * Constants.UNHEALTHY_CLIENTS_PROPORTION_LIMIT);\n+\n+        return KeyedStream.stream(organizedFeedback).values().filter(\n+                nodeWiseStats -> getHealthStatusForService(nodeWiseStats) == HealthStatus.UNHEALTHY).count()\n+                > maxAllowedUnhealthyServices ? HealthStatus.UNHEALTHY : HealthStatus.HEALTHY;\n+    }\n+\n+    private static HealthStatus getHealthStatusForService(Map<UUID, List<ConjureTimeLockClientFeedback>> nodeWiseStats) {\n+        // only the status that appears majority number of times is considered,\n+        // otherwise the health status for service is 'unknown'\n+\n+        return getHealthStatusOfMajority(nodeWiseStats.values().stream(),\n+                FeedbackProvider::getHealthStatusForNode,\n+                nodeWiseStats.size() / 2);\n+    }\n+\n+    private static HealthStatus getHealthStatusForNode(List<ConjureTimeLockClientFeedback> feedbackForNode) {\n+        // only the status that appears majority number of times is considered,\n+        // otherwise the health status for node is 'unknown'\n+\n+        return getHealthStatusOfMajority(feedbackForNode.stream(),\n+                FeedbackProvider::pointFeedbackHealthStatus,\n+                feedbackForNode.size() / 2);\n+    }\n+\n+    private static <T> HealthStatus getHealthStatusOfMajority(Stream<T> feedbackForNode,\n+            Function<T, HealthStatus> mapper,\n+            int minThresholdToBeMajority) {\n+        return KeyedStream.stream(Utils.getFrequencyMap(feedbackForNode\n+                .map(mapper)))\n+                .filterEntries((key, val) -> val > minThresholdToBeMajority)\n+                .keys()\n+                .findFirst()\n+                .orElse(HealthStatus.UNKNOWN);\n+    }\n+\n+    @VisibleForTesting\n+    static HealthStatus pointFeedbackHealthStatus(ConjureTimeLockClientFeedback healthReport) {\n+        if (Constants.ATLAS_BLACKLISTED_VERSIONS.contains(healthReport.getAtlasVersion())) {\n+            return HealthStatus.UNKNOWN;\n+        }\n+        // considering the worst performing metric only, the health check should fail even if one end-point is unhealthy\n+        HealthStatus healthStatus = HealthStatus.HEALTHY;\n+\n+        if (healthReport.getLeaderTime().isPresent()) {\n+            healthStatus = HealthStatus.getWorseState(healthStatus,\n+                    getHealthStatusForService(healthReport.getLeaderTime().get(),\n+                            Constants.MIN_REQUIRED_LEADER_TIME_ONE_MINUTE_RATE,\n+                            Constants.MAX_ACCEPTABLE_LEADER_TIME_P99_MILLI));\n+        }\n+\n+        if (healthReport.getStartTransaction().isPresent()) {\n+            healthStatus = HealthStatus.getWorseState(healthStatus,\n+                    getHealthStatusForService(healthReport.getStartTransaction().get(),\n+                            Constants.MIN_REQUIRED_START_TXN_ONE_MINUTE_RATE,\n+                            Constants.MAX_ACCEPTABLE_START_TXN_P99_MILLI));\n+        }\n+\n+        return healthStatus;\n+    }\n+\n+    private static  HealthStatus getHealthStatusForService(EndpointStatistics endpointStatistics,\n+            int rateThreshold,\n+            int p99Limit) {\n+\n+        if (endpointStatistics.getOneMin() < rateThreshold) {\n+            return HealthStatus.UNKNOWN;\n+        }\n+\n+        return endpointStatistics.getP99() > p99Limit\n+                ? HealthStatus.UNHEALTHY : HealthStatus.HEALTHY;", "originalCommit": "70545d66256e9730e0306277d398f16abe53736c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4MTM3Nw==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r445481377", "bodyText": "Like the internal proxy we have for checking whether our service is well-behaved, it is probably a good idea to include in the UNHEALTHY case some information about why we think things are unhealthy.", "author": "jeremyk-91", "createdAt": "2020-06-25T11:10:39Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/HealthStatus.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import java.util.HashSet;\n+\n+import com.google.common.collect.Sets;\n+\n+public enum HealthStatus {", "originalCommit": "70545d66256e9730e0306277d398f16abe53736c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA5NDEwMA==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r446094100", "bodyText": "we ended up adding this at a different layer, but this information is still reported, so we should be good here.", "author": "jeremyk-91", "createdAt": "2020-06-26T10:09:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4MTM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4MzY2OA==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r445483668", "bodyText": "I think there should be a test for multiple feedback reports as well - add 100 and verify they're still there.", "author": "jeremyk-91", "createdAt": "2020-06-25T11:15:45Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/adjudicate/FeedbackSinkTest.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Test;\n+\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.palantir.timelock.feedback.ConjureTimeLockClientFeedback;\n+\n+public class FeedbackSinkTest {\n+    private static final FakeTicker FAKE_TICKER = new FakeTicker();\n+    private static final ConjureTimeLockClientFeedback TEST_REPORT = getTestReport();\n+\n+    @Test\n+    public void feedbackIsRegistered() {\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports =\n+                createSinkAndAddTestReport().getTrackedFeedbackReports();\n+        assertThat(trackedFeedbackReports.size()).isEqualTo(1);\n+        assertThat(trackedFeedbackReports).containsExactly(TEST_REPORT);\n+    }\n+\n+    @Test\n+    public void feedbackRetrievedFromSinkIsImmutable() {\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports =\n+                createSinkAndAddTestReport().getTrackedFeedbackReports();\n+        assertThatThrownBy(() -> trackedFeedbackReports.add(TEST_REPORT))\n+                .isInstanceOf(UnsupportedOperationException.class);\n+    }\n+\n+    @Test\n+    public void feedbackReportIsEvictedAfterExpiry() {\n+        TimeLockClientFeedbackSink sink = createSinkAndAddTestReport();\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports =\n+                sink.getTrackedFeedbackReports();\n+        assertThat(trackedFeedbackReports.size()).isEqualTo(1);\n+        assertThat(trackedFeedbackReports).containsExactly(TEST_REPORT);\n+\n+        FAKE_TICKER.advance(Constants.HEALTH_FEEDBACK_REPORT_EXPIRATION_MINUTES, TimeUnit.MINUTES);\n+        assertThat(sink.getTrackedFeedbackReports().size()).isEqualTo(0);\n+    }\n+", "originalCommit": "70545d66256e9730e0306277d398f16abe53736c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4NDIyNw==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r445484227", "bodyText": "I think the feedback sink should be non-static, in which case a new instance is created for each of the tests and therefore you wouldn't need to worry about this.", "author": "jeremyk-91", "createdAt": "2020-06-25T11:16:57Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/adjudicate/FeedbackAnalysisTest.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.After;\n+import org.junit.Test;\n+\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.timelock.feedback.ConjureTimeLockClientFeedback;\n+import com.palantir.timelock.feedback.EndpointStatistics;\n+\n+public class FeedbackAnalysisTest {\n+    private static final FakeTicker FAKE_TICKER = new FakeTicker();\n+    private static final String CLIENT = \"client_1\";\n+    private static final String CLIENT_2 = \"client_2\";\n+    private static final String CLIENT_3 = \"client_3\";\n+\n+\n+    private static TimeLockClientFeedbackSink timeLockClientFeedbackSink = TimeLockClientFeedbackSink\n+            .create(Caffeine.newBuilder()\n+                    .expireAfterWrite(Constants.HEALTH_FEEDBACK_REPORT_EXPIRATION_MINUTES, TimeUnit.MINUTES)\n+                    .ticker(FAKE_TICKER)\n+                    .build());\n+\n+    @After\n+    public void resetCache() {\n+        FAKE_TICKER.advance(Constants.HEALTH_FEEDBACK_REPORT_EXPIRATION_MINUTES, TimeUnit.MINUTES);", "originalCommit": "70545d66256e9730e0306277d398f16abe53736c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4NTg2OA==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r445485868", "bodyText": "in terms of class design, I'd prefer to maintain a reference to the FeedbackProvider instead of the sink in this class (the idea being that users should talk to the provider, not retrieve the reports directly)", "author": "jeremyk-91", "createdAt": "2020-06-25T11:20:22Z", "path": "timelock-agent/src/main/java/com/palantir/timelock/paxos/TimeLockAgent.java", "diffHunk": "@@ -95,6 +101,12 @@\n     private LeaderPingHealthCheck healthCheck;\n     private TimelockNamespaces namespaces;\n \n+    private final TimeLockClientFeedbackSink timeLockClientFeedbackSink = TimeLockClientFeedbackSink", "originalCommit": "70545d66256e9730e0306277d398f16abe53736c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4NjAwNA==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r445486004", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void timeLockIsHealthyIfNoFeedbackIsRegister() {\n          \n          \n            \n                public void timeLockIsHealthyIfNoFeedbackIsRegistered() {", "author": "jeremyk-91", "createdAt": "2020-06-25T11:20:40Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/adjudicate/FeedbackAnalysisTest.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.After;\n+import org.junit.Test;\n+\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.timelock.feedback.ConjureTimeLockClientFeedback;\n+import com.palantir.timelock.feedback.EndpointStatistics;\n+\n+public class FeedbackAnalysisTest {\n+    private static final FakeTicker FAKE_TICKER = new FakeTicker();\n+    private static final String CLIENT = \"client_1\";\n+    private static final String CLIENT_2 = \"client_2\";\n+    private static final String CLIENT_3 = \"client_3\";\n+\n+\n+    private static TimeLockClientFeedbackSink timeLockClientFeedbackSink = TimeLockClientFeedbackSink\n+            .create(Caffeine.newBuilder()\n+                    .expireAfterWrite(Constants.HEALTH_FEEDBACK_REPORT_EXPIRATION_MINUTES, TimeUnit.MINUTES)\n+                    .ticker(FAKE_TICKER)\n+                    .build());\n+\n+    @After\n+    public void resetCache() {\n+        FAKE_TICKER.advance(Constants.HEALTH_FEEDBACK_REPORT_EXPIRATION_MINUTES, TimeUnit.MINUTES);\n+    }\n+\n+    // TimeLock Level analysis\n+    @Test\n+    public void timeLockIsHealthyIfNoFeedbackIsRegister() {", "originalCommit": "70545d66256e9730e0306277d398f16abe53736c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4NjIyOA==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r445486228", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void timeLockIsHealthyIfAllClientsAreUnhealthy() {\n          \n          \n            \n                public void timeLockIsUnhealthyIfAllClientsAreUnhealthy() {", "author": "jeremyk-91", "createdAt": "2020-06-25T11:21:03Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/adjudicate/FeedbackAnalysisTest.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.After;\n+import org.junit.Test;\n+\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.timelock.feedback.ConjureTimeLockClientFeedback;\n+import com.palantir.timelock.feedback.EndpointStatistics;\n+\n+public class FeedbackAnalysisTest {\n+    private static final FakeTicker FAKE_TICKER = new FakeTicker();\n+    private static final String CLIENT = \"client_1\";\n+    private static final String CLIENT_2 = \"client_2\";\n+    private static final String CLIENT_3 = \"client_3\";\n+\n+\n+    private static TimeLockClientFeedbackSink timeLockClientFeedbackSink = TimeLockClientFeedbackSink\n+            .create(Caffeine.newBuilder()\n+                    .expireAfterWrite(Constants.HEALTH_FEEDBACK_REPORT_EXPIRATION_MINUTES, TimeUnit.MINUTES)\n+                    .ticker(FAKE_TICKER)\n+                    .build());\n+\n+    @After\n+    public void resetCache() {\n+        FAKE_TICKER.advance(Constants.HEALTH_FEEDBACK_REPORT_EXPIRATION_MINUTES, TimeUnit.MINUTES);\n+    }\n+\n+    // TimeLock Level analysis\n+    @Test\n+    public void timeLockIsHealthyIfNoFeedbackIsRegister() {\n+        assertThat(FeedbackProvider.getTimeLockHealthStatus(timeLockClientFeedbackSink))\n+                .isEqualTo(HealthStatus.HEALTHY);\n+    }\n+\n+    @Test\n+    public void timeLockIsHealthyIfAllClientsAreHealthy() {\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports = ImmutableList.of(\n+                getHealthyClientFeedbackReport(CLIENT, UUID.randomUUID()));\n+        trackedFeedbackReports.forEach(timeLockClientFeedbackSink::registerFeedback);\n+        assertThat(FeedbackProvider.getTimeLockHealthStatus(timeLockClientFeedbackSink))\n+                .isEqualTo(HealthStatus.HEALTHY);\n+    }\n+\n+    @Test\n+    public void timeLockIsHealthyIfAllClientsAreUnhealthy() {", "originalCommit": "70545d66256e9730e0306277d398f16abe53736c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4NjY0MA==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r445486640", "bodyText": "nit: I know this is extracted but we should probably name the parameters to be what they are", "author": "jeremyk-91", "createdAt": "2020-06-25T11:21:57Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/adjudicate/FeedbackAnalysisTest.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.After;\n+import org.junit.Test;\n+\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.timelock.feedback.ConjureTimeLockClientFeedback;\n+import com.palantir.timelock.feedback.EndpointStatistics;\n+\n+public class FeedbackAnalysisTest {\n+    private static final FakeTicker FAKE_TICKER = new FakeTicker();\n+    private static final String CLIENT = \"client_1\";\n+    private static final String CLIENT_2 = \"client_2\";\n+    private static final String CLIENT_3 = \"client_3\";\n+\n+\n+    private static TimeLockClientFeedbackSink timeLockClientFeedbackSink = TimeLockClientFeedbackSink\n+            .create(Caffeine.newBuilder()\n+                    .expireAfterWrite(Constants.HEALTH_FEEDBACK_REPORT_EXPIRATION_MINUTES, TimeUnit.MINUTES)\n+                    .ticker(FAKE_TICKER)\n+                    .build());\n+\n+    @After\n+    public void resetCache() {\n+        FAKE_TICKER.advance(Constants.HEALTH_FEEDBACK_REPORT_EXPIRATION_MINUTES, TimeUnit.MINUTES);\n+    }\n+\n+    // TimeLock Level analysis\n+    @Test\n+    public void timeLockIsHealthyIfNoFeedbackIsRegister() {\n+        assertThat(FeedbackProvider.getTimeLockHealthStatus(timeLockClientFeedbackSink))\n+                .isEqualTo(HealthStatus.HEALTHY);\n+    }\n+\n+    @Test\n+    public void timeLockIsHealthyIfAllClientsAreHealthy() {\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports = ImmutableList.of(\n+                getHealthyClientFeedbackReport(CLIENT, UUID.randomUUID()));\n+        trackedFeedbackReports.forEach(timeLockClientFeedbackSink::registerFeedback);\n+        assertThat(FeedbackProvider.getTimeLockHealthStatus(timeLockClientFeedbackSink))\n+                .isEqualTo(HealthStatus.HEALTHY);\n+    }\n+\n+    @Test\n+    public void timeLockIsHealthyIfAllClientsAreUnhealthy() {\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports = ImmutableList.of(\n+                getUnhealthyClientFeedbackReport(CLIENT, UUID.randomUUID()));\n+        trackedFeedbackReports.forEach(timeLockClientFeedbackSink::registerFeedback);\n+        assertThat(FeedbackProvider.getTimeLockHealthStatus(timeLockClientFeedbackSink))\n+                .isEqualTo(HealthStatus.UNHEALTHY);\n+    }\n+\n+    @Test\n+    public void timeLockIsHealthyIfAllClientStatusesAreUnknown() {\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports = ImmutableList.of(\n+                getUnknownClientFeedbackReport(CLIENT, UUID.randomUUID()));\n+        trackedFeedbackReports.forEach(timeLockClientFeedbackSink::registerFeedback);\n+        assertThat(FeedbackProvider.getTimeLockHealthStatus(timeLockClientFeedbackSink))\n+                .isEqualTo(HealthStatus.HEALTHY);\n+    }\n+\n+    @Test\n+    public void timeLockIsHealthyIfLessThanThresholdClientStatusesAreUnHealthy() {\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports = ImmutableList.of(\n+                getHealthyClientFeedbackReport(CLIENT, UUID.randomUUID()),\n+                getHealthyClientFeedbackReport(CLIENT_2, UUID.randomUUID()),\n+                getUnhealthyClientFeedbackReport(CLIENT_3, UUID.randomUUID()));\n+        trackedFeedbackReports.forEach(timeLockClientFeedbackSink::registerFeedback);\n+        assertThat(FeedbackProvider.getTimeLockHealthStatus(timeLockClientFeedbackSink))\n+                .isEqualTo(HealthStatus.HEALTHY);\n+    }\n+\n+    @Test\n+    public void timeLockIsUnhealthyIfMoreThanThresholdClientStatusesAreUnHealthy() {\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports = ImmutableList.of(\n+                getHealthyClientFeedbackReport(CLIENT, UUID.randomUUID()),\n+                getUnhealthyClientFeedbackReport(CLIENT_2, UUID.randomUUID()),\n+                getUnhealthyClientFeedbackReport(CLIENT_3, UUID.randomUUID()));\n+        trackedFeedbackReports.forEach(timeLockClientFeedbackSink::registerFeedback);\n+        assertThat(FeedbackProvider.getTimeLockHealthStatus(timeLockClientFeedbackSink))\n+                .isEqualTo(HealthStatus.UNHEALTHY);\n+    }\n+\n+    // Client Level analysis\n+    @Test\n+    public void serviceIsHealthyIfMajorityNodesAreHealthy() {\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports = ImmutableList.of(\n+                getHealthyClientFeedbackReport(CLIENT, UUID.randomUUID()),\n+                getHealthyClientFeedbackReport(CLIENT, UUID.randomUUID()),\n+                getUnhealthyClientFeedbackReport(CLIENT, UUID.randomUUID()));\n+        trackedFeedbackReports.forEach(timeLockClientFeedbackSink::registerFeedback);\n+        assertThat(FeedbackProvider.getTimeLockHealthStatus(timeLockClientFeedbackSink))\n+                .isEqualTo(HealthStatus.HEALTHY);\n+    }\n+\n+    @Test\n+    public void serviceIsUnhealthyIfMajorityNodesAreUnhealthy() {\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports = ImmutableList.of(\n+                getHealthyClientFeedbackReport(CLIENT, UUID.randomUUID()),\n+                getUnhealthyClientFeedbackReport(CLIENT, UUID.randomUUID()),\n+                getUnhealthyClientFeedbackReport(CLIENT, UUID.randomUUID()));\n+        trackedFeedbackReports.forEach(timeLockClientFeedbackSink::registerFeedback);\n+        assertThat(FeedbackProvider.getTimeLockHealthStatus(timeLockClientFeedbackSink))\n+                .isEqualTo(HealthStatus.UNHEALTHY);\n+    }\n+\n+    @Test\n+    public void fallbackToHealthyIfThereIsNoMajority() {\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports = ImmutableList.of(\n+                getHealthyClientFeedbackReport(CLIENT, UUID.randomUUID()),\n+                getUnhealthyClientFeedbackReport(CLIENT, UUID.randomUUID()));\n+        trackedFeedbackReports.forEach(timeLockClientFeedbackSink::registerFeedback);\n+        assertThat(FeedbackProvider.getTimeLockHealthStatus(timeLockClientFeedbackSink))\n+                .isEqualTo(HealthStatus.HEALTHY);\n+    }\n+\n+    // node level analysis\n+    @Test\n+    public void nodeIsHealthyIfMajorityReportsHealthy() {\n+        UUID nodeId = UUID.randomUUID();\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports = ImmutableList.of(\n+                getHealthyClientFeedbackReport(CLIENT, nodeId),\n+                getHealthyClientFeedbackReport(CLIENT, nodeId),\n+                getUnhealthyClientFeedbackReport(CLIENT, nodeId));\n+        trackedFeedbackReports.forEach(timeLockClientFeedbackSink::registerFeedback);\n+        assertThat(FeedbackProvider.getTimeLockHealthStatus(timeLockClientFeedbackSink))\n+                .isEqualTo(HealthStatus.HEALTHY);\n+    }\n+\n+    @Test\n+    public void nodeIsUnhealthyIfMajorityReportsUnhealthy() {\n+        UUID nodeId = UUID.randomUUID();\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports = ImmutableList.of(\n+                getHealthyClientFeedbackReport(CLIENT, nodeId),\n+                getReportWithLeaderTimeMetricInUnhealthyState(CLIENT, nodeId),\n+                getReportWithStartTxnMetricInUnHealthyState(CLIENT, nodeId));\n+        trackedFeedbackReports.forEach(timeLockClientFeedbackSink::registerFeedback);\n+        assertThat(FeedbackProvider.getTimeLockHealthStatus(timeLockClientFeedbackSink))\n+                .isEqualTo(HealthStatus.UNHEALTHY);\n+    }\n+\n+    @Test\n+    public void fallbackToHealthyIfNoMajority() {\n+        UUID nodeId = UUID.randomUUID();\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports = ImmutableList.of(\n+                getUnknownClientFeedbackReport(CLIENT, nodeId),\n+                getUnknownClientFeedbackReport(CLIENT, nodeId),\n+                getUnhealthyClientFeedbackReport(CLIENT, nodeId));\n+        trackedFeedbackReports.forEach(timeLockClientFeedbackSink::registerFeedback);\n+        assertThat(FeedbackProvider.getTimeLockHealthStatus(timeLockClientFeedbackSink))\n+                .isEqualTo(HealthStatus.HEALTHY);\n+    }\n+\n+    // point analysis\n+    @Test\n+    public void reportIsHealthyIfAllMetricsAreHealthy() {\n+        assertThat(FeedbackProvider.pointFeedbackHealthStatus(\n+                getHealthyClientFeedbackReport(CLIENT, UUID.randomUUID())))\n+                .isEqualTo(HealthStatus.HEALTHY);\n+    }\n+\n+    @Test\n+    public void reportIsUnknownIfEvenOneMetricIsInUnknownState() {\n+        assertThat(FeedbackProvider.pointFeedbackHealthStatus(\n+                getReportWithLeaderTimeMetricInUnknownState(CLIENT, UUID.randomUUID())))\n+                .isEqualTo(HealthStatus.UNKNOWN);\n+\n+\n+        assertThat(FeedbackProvider.pointFeedbackHealthStatus(\n+                getReportWithStartTxnMetricInUnknownState(CLIENT, UUID.randomUUID())))\n+                .isEqualTo(HealthStatus.UNKNOWN);\n+    }\n+\n+    @Test\n+    public void reportIsUnhealthyIfEvenOneMetricIsInUnhealthy() {\n+        assertThat(FeedbackProvider.pointFeedbackHealthStatus(\n+                getReportWithLeaderTimeMetricInUnhealthyState(CLIENT, UUID.randomUUID())))\n+                .isEqualTo(HealthStatus.UNHEALTHY);\n+\n+\n+        assertThat(FeedbackProvider.pointFeedbackHealthStatus(\n+                getReportWithStartTxnMetricInUnHealthyState(CLIENT, UUID.randomUUID())))\n+                .isEqualTo(HealthStatus.UNHEALTHY);\n+    }\n+\n+    // utils\n+    private ConjureTimeLockClientFeedback getUnhealthyClientFeedbackReport(String serviceName, UUID nodeId) {\n+        return getClientFeedbackReport(serviceName,\n+                nodeId,\n+                Constants.MIN_REQUIRED_LEADER_TIME_ONE_MINUTE_RATE + 1,\n+                Constants.MAX_ACCEPTABLE_LEADER_TIME_P99_MILLI + 1,\n+                Constants.MIN_REQUIRED_START_TXN_ONE_MINUTE_RATE + 1,\n+                Constants.MAX_ACCEPTABLE_START_TXN_P99_MILLI + 1);\n+    }\n+\n+    private ConjureTimeLockClientFeedback getHealthyClientFeedbackReport(String serviceName, UUID nodeId) {\n+        return getClientFeedbackReport(serviceName,\n+                nodeId,\n+                Constants.MIN_REQUIRED_LEADER_TIME_ONE_MINUTE_RATE + 1,\n+                Constants.MAX_ACCEPTABLE_LEADER_TIME_P99_MILLI - 1,\n+                Constants.MIN_REQUIRED_START_TXN_ONE_MINUTE_RATE + 1,\n+                Constants.MAX_ACCEPTABLE_START_TXN_P99_MILLI - 1);\n+    }\n+\n+    private ConjureTimeLockClientFeedback getUnknownClientFeedbackReport(String serviceName, UUID nodeId) {\n+        return getClientFeedbackReport(serviceName,\n+                nodeId,\n+                Constants.MIN_REQUIRED_LEADER_TIME_ONE_MINUTE_RATE - 1,\n+                Constants.MAX_ACCEPTABLE_LEADER_TIME_P99_MILLI - 1,\n+                Constants.MIN_REQUIRED_START_TXN_ONE_MINUTE_RATE - 1,\n+                Constants.MAX_ACCEPTABLE_START_TXN_P99_MILLI - 1);\n+    }\n+\n+    private ConjureTimeLockClientFeedback getReportWithLeaderTimeMetricInUnknownState(String serviceName, UUID nodeId) {\n+        return getClientFeedbackReport(serviceName,\n+                nodeId,\n+                Constants.MIN_REQUIRED_LEADER_TIME_ONE_MINUTE_RATE - 1,\n+                Constants.MAX_ACCEPTABLE_LEADER_TIME_P99_MILLI - 1,\n+                Constants.MIN_REQUIRED_START_TXN_ONE_MINUTE_RATE + 1,\n+                Constants.MAX_ACCEPTABLE_START_TXN_P99_MILLI - 1);\n+    }\n+\n+    private ConjureTimeLockClientFeedback getReportWithStartTxnMetricInUnknownState(String serviceName, UUID nodeId) {\n+        return getClientFeedbackReport(serviceName,\n+                nodeId,\n+                Constants.MIN_REQUIRED_LEADER_TIME_ONE_MINUTE_RATE + 1,\n+                Constants.MAX_ACCEPTABLE_LEADER_TIME_P99_MILLI - 1,\n+                Constants.MIN_REQUIRED_START_TXN_ONE_MINUTE_RATE - 1,\n+                Constants.MAX_ACCEPTABLE_START_TXN_P99_MILLI - 1);\n+    }\n+\n+    private ConjureTimeLockClientFeedback getReportWithLeaderTimeMetricInUnhealthyState(String serviceName, UUID nodeId) {\n+        return getClientFeedbackReport(serviceName,\n+                nodeId,\n+                Constants.MIN_REQUIRED_LEADER_TIME_ONE_MINUTE_RATE + 1,\n+                Constants.MAX_ACCEPTABLE_LEADER_TIME_P99_MILLI + 1,\n+                Constants.MIN_REQUIRED_START_TXN_ONE_MINUTE_RATE + 1,\n+                Constants.MAX_ACCEPTABLE_START_TXN_P99_MILLI - 1);\n+    }\n+\n+    private ConjureTimeLockClientFeedback getReportWithStartTxnMetricInUnHealthyState(String serviceName, UUID nodeId) {\n+        return getClientFeedbackReport(serviceName,\n+                nodeId,\n+                Constants.MIN_REQUIRED_LEADER_TIME_ONE_MINUTE_RATE + 1,\n+                Constants.MAX_ACCEPTABLE_LEADER_TIME_P99_MILLI - 1,\n+                Constants.MIN_REQUIRED_START_TXN_ONE_MINUTE_RATE + 1,\n+                Constants.MAX_ACCEPTABLE_START_TXN_P99_MILLI + 1);\n+    }\n+\n+    private ConjureTimeLockClientFeedback getClientFeedbackReport(String serviceName, UUID nodeId,\n+            int i1, int i2, int i3, int i4) {", "originalCommit": "70545d66256e9730e0306277d398f16abe53736c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4Njg2OA==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r445486868", "bodyText": "I'm tempted to say we should have a hard minimum of one (one unhealthy service should always be accepted)", "author": "jeremyk-91", "createdAt": "2020-06-25T11:22:30Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/FeedbackProvider.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.timelock.feedback.ConjureTimeLockClientFeedback;\n+import com.palantir.timelock.feedback.EndpointStatistics;\n+\n+public final class FeedbackProvider {\n+\n+    private FeedbackProvider() {\n+        // no op\n+    }\n+\n+    public static HealthStatus getTimeLockHealthStatus(TimeLockClientFeedbackSink timeLockClientFeedbackSink) {\n+        List<ConjureTimeLockClientFeedback> trackedFeedbackReports =\n+                timeLockClientFeedbackSink.getTrackedFeedbackReports();\n+\n+        Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizedFeedback =\n+                organizeFeedbackReports(trackedFeedbackReports);\n+\n+        return healthStateOfTimeLock(organizedFeedback);\n+    }\n+\n+    private static Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizeFeedbackReports(\n+            List<ConjureTimeLockClientFeedback> trackedFeedbackReports) {\n+        Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizedFeedback = Maps.newHashMap();\n+\n+        for (ConjureTimeLockClientFeedback feedback : trackedFeedbackReports) {\n+            Map<UUID, List<ConjureTimeLockClientFeedback>> nodesForService = organizedFeedback.computeIfAbsent(\n+                    feedback.getServiceName(), service -> Maps.newHashMap());\n+\n+            List<ConjureTimeLockClientFeedback> feedbackForNode = nodesForService\n+                    .computeIfAbsent(feedback.getNodeId(), nodeId -> Lists.newLinkedList());\n+\n+            feedbackForNode.add(feedback);\n+        }\n+        return organizedFeedback;\n+    }\n+\n+    private static HealthStatus healthStateOfTimeLock(\n+            Map<String, Map<UUID, List<ConjureTimeLockClientFeedback>>> organizedFeedback) {\n+        int maxAllowedUnhealthyServices = (int) (organizedFeedback.size()\n+                * Constants.UNHEALTHY_CLIENTS_PROPORTION_LIMIT);", "originalCommit": "70545d66256e9730e0306277d398f16abe53736c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bd33635084a083e9065fb30507912a4c9ea90480", "url": "https://github.com/palantir/atlasdb/commit/bd33635084a083e9065fb30507912a4c9ea90480", "message": "Address comments", "committedDate": "2020-06-25T12:26:27Z", "type": "commit"}, {"oid": "25e59304fdd2fd0d97246749557c0e717388ef61", "url": "https://github.com/palantir/atlasdb/commit/25e59304fdd2fd0d97246749557c0e717388ef61", "message": "error rate", "committedDate": "2020-06-25T13:55:50Z", "type": "commit"}, {"oid": "f8ff19f608955f33c82f0bfa9f7a15f69570f891", "url": "https://github.com/palantir/atlasdb/commit/f8ff19f608955f33c82f0bfa9f7a15f69570f891", "message": "Address comments", "committedDate": "2020-06-25T14:24:15Z", "type": "commit"}, {"oid": "895573d6cdf39dfbbd11b93a79699635a05cfefc", "url": "https://github.com/palantir/atlasdb/commit/895573d6cdf39dfbbd11b93a79699635a05cfefc", "message": "Min unhealthy services", "committedDate": "2020-06-25T15:07:34Z", "type": "commit"}, {"oid": "1ca43d35aa75a3cfda2ff12125b03066f234eda4", "url": "https://github.com/palantir/atlasdb/commit/1ca43d35aa75a3cfda2ff12125b03066f234eda4", "message": "Address comment | refactor", "committedDate": "2020-06-25T15:53:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY3OTg4Mw==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r445679883", "bodyText": "Do not need separate processor class", "author": "sudiksha27", "createdAt": "2020-06-25T16:19:30Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/FeedbackHandler.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.palantir.timelock.feedback.ConjureTimeLockClientFeedback;\n+\n+public class FeedbackHandler {\n+\n+    private final TimeLockClientFeedbackSink timeLockClientFeedbackSink = TimeLockClientFeedbackSink\n+            .create(Caffeine\n+            .newBuilder()\n+            .expireAfterWrite(Constants.HEALTH_FEEDBACK_REPORT_EXPIRATION_MINUTES, TimeUnit.MINUTES)\n+                        .build());\n+\n+    public HealthStatus getTimeLockHealthStatus() {\n+        return FeedbackProcessor.getTimeLockHealthStatus(timeLockClientFeedbackSink.getTrackedFeedbackReports());\n+    }", "originalCommit": "1ca43d35aa75a3cfda2ff12125b03066f234eda4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY4MDYzMw==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r445680633", "bodyText": "Duration", "author": "sudiksha27", "createdAt": "2020-06-25T16:20:37Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/Constants.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import java.time.Duration;\n+import java.util.Set;\n+\n+import org.apache.commons.lang3.math.Fraction;\n+\n+import com.google.common.collect.Sets;\n+\n+public final class Constants {\n+    private Constants() {\n+        // no op\n+    }\n+\n+    public static final int HEALTH_FEEDBACK_REPORT_EXPIRATION_MINUTES = 2;", "originalCommit": "1ca43d35aa75a3cfda2ff12125b03066f234eda4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "59a944ff9e0ed5ae1a5858ed86ae1e41cfd088e7", "url": "https://github.com/palantir/atlasdb/commit/59a944ff9e0ed5ae1a5858ed86ae1e41cfd088e7", "message": "Address comment | reefactor", "committedDate": "2020-06-25T17:57:14Z", "type": "commit"}, {"oid": "3a27507c553d2bebef7af99ee65e516e3289d7fc", "url": "https://github.com/palantir/atlasdb/commit/3a27507c553d2bebef7af99ee65e516e3289d7fc", "message": "Message with unhealthy state", "committedDate": "2020-06-25T19:38:01Z", "type": "commit"}, {"oid": "6e43e79fbc72dd0fcb639de037b813730ebc0cdb", "url": "https://github.com/palantir/atlasdb/commit/6e43e79fbc72dd0fcb639de037b813730ebc0cdb", "message": "Refactor + typo", "committedDate": "2020-06-25T19:41:04Z", "type": "commit"}, {"oid": "88652a619d75aafa336672d5c854c5a6c35bcfaf", "url": "https://github.com/palantir/atlasdb/commit/88652a619d75aafa336672d5c854c5a6c35bcfaf", "message": "Fix tests for now", "committedDate": "2020-06-25T19:43:55Z", "type": "commit"}, {"oid": "5648255b67fa738c23191a67ff518a721b3d710c", "url": "https://github.com/palantir/atlasdb/commit/5648255b67fa738c23191a67ff518a721b3d710c", "message": "Add linespace", "committedDate": "2020-06-26T10:02:37Z", "type": "commit"}, {"oid": "480796f5ee5e78b7eac9c6c8ef5ee9c76a43daef", "url": "https://github.com/palantir/atlasdb/commit/480796f5ee5e78b7eac9c6c8ef5ee9c76a43daef", "message": "Fix fake ticker", "committedDate": "2020-06-26T11:07:34Z", "type": "commit"}, {"oid": "919e4edb975eb038fe8bd460d84d6014d32f4792", "url": "https://github.com/palantir/atlasdb/commit/919e4edb975eb038fe8bd460d84d6014d32f4792", "message": "Bug fix | time in nanos", "committedDate": "2020-06-26T13:03:29Z", "type": "commit"}, {"oid": "00033e900f4d1410d9d880cb25539fe56447a2ed", "url": "https://github.com/palantir/atlasdb/commit/00033e900f4d1410d9d880cb25539fe56447a2ed", "message": "SLO specification refactor (#4870)", "committedDate": "2020-06-26T14:28:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA5NDU2OA==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r446094568", "bodyText": "nit: HealthStatusReport?", "author": "jeremyk-91", "createdAt": "2020-06-26T10:10:57Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/ReportHealthStatus.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.immutables.value.Value;\n+\n+@Value.Immutable\n+public interface ReportHealthStatus {", "originalCommit": "5648255b67fa738c23191a67ff518a721b3d710c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA5NTMxMA==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r446095310", "bodyText": "nit: inline?", "author": "jeremyk-91", "createdAt": "2020-06-26T10:12:33Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/adjudicate/FakeTicker.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import com.github.benmanes.caffeine.cache.Ticker;\n+\n+class FakeTicker implements Ticker {\n+\n+    private final AtomicLong nanos = new AtomicLong();\n+\n+    public FakeTicker advance(long time, TimeUnit timeUnit) {\n+        nanos.addAndGet(timeUnit.toNanos(time));\n+        return this;\n+    }\n+\n+    @Override\n+    public long read() {\n+        long value = nanos.get();\n+        return value;", "originalCommit": "5648255b67fa738c23191a67ff518a721b3d710c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA5NjAxOA==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r446096018", "bodyText": "This lets you chain the tickers, though I don't think we used this functionality", "author": "jeremyk-91", "createdAt": "2020-06-26T10:14:06Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/adjudicate/FakeTicker.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import com.github.benmanes.caffeine.cache.Ticker;\n+\n+class FakeTicker implements Ticker {\n+\n+    private final AtomicLong nanos = new AtomicLong();\n+\n+    public FakeTicker advance(long time, TimeUnit timeUnit) {", "originalCommit": "5648255b67fa738c23191a67ff518a721b3d710c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA5NjE5OA==", "url": "https://github.com/palantir/atlasdb/pull/4861#discussion_r446096198", "bodyText": "be consistent with above", "author": "jeremyk-91", "createdAt": "2020-06-26T10:14:27Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/adjudicate/FeedbackAnalysisTest.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.UUID;\n+import java.util.stream.IntStream;\n+\n+import org.junit.Test;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.timelock.feedback.ConjureTimeLockClientFeedback;\n+import com.palantir.timelock.feedback.EndpointStatistics;\n+\n+public class FeedbackAnalysisTest {\n+    private static final String CLIENT = \"client_1\";\n+    private static final String CLIENT_2 = \"client_2\";\n+    private static final String CLIENT_3 = \"client_3\";\n+\n+    long maxAcceptableLeaderTimeP99Milli = Constants.MAX_ACCEPTABLE_LEADER_TIME_P99_MILLI.toMillis();\n+    long maxAcceptableStartTxnTime = Constants.MAX_ACCEPTABLE_START_TXN_P99_MILLI.toMillis();", "originalCommit": "5648255b67fa738c23191a67ff518a721b3d710c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "16595caace05fa3fe5e2baf78b7338fbd7ce1d13", "url": "https://github.com/palantir/atlasdb/commit/16595caace05fa3fe5e2baf78b7338fbd7ce1d13", "message": "Address comments", "committedDate": "2020-06-26T14:39:01Z", "type": "commit"}, {"oid": "9c2d6b8433b0e70495ab2fdc36e311836e558b70", "url": "https://github.com/palantir/atlasdb/commit/9c2d6b8433b0e70495ab2fdc36e311836e558b70", "message": "save from NaN", "committedDate": "2020-06-26T14:41:41Z", "type": "commit"}, {"oid": "1acd6177b1d32591160426a34f2e107cbba81cc9", "url": "https://github.com/palantir/atlasdb/commit/1acd6177b1d32591160426a34f2e107cbba81cc9", "message": "Some more", "committedDate": "2020-06-26T15:14:29Z", "type": "commit"}]}