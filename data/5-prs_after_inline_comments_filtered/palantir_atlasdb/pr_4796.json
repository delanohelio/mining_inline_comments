{"pr_number": 4796, "pr_title": "[PaxosStateLog] Migrate from Cutoff + Persist Cutoff", "pr_createdAt": "2020-05-22T12:27:41Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4796", "timeline": [{"oid": "45ae2b292cc899122f759734abf9a71b7b476d97", "url": "https://github.com/palantir/atlasdb/commit/45ae2b292cc899122f759734abf9a71b7b476d97", "message": "Actually commit", "committedDate": "2020-05-22T11:56:54Z", "type": "commit"}, {"oid": "1ef25cf72b35146324c233e8e21969ef22357f3c", "url": "https://github.com/palantir/atlasdb/commit/1ef25cf72b35146324c233e8e21969ef22357f3c", "message": "Add test for validation -> migrated", "committedDate": "2020-05-22T12:18:03Z", "type": "commit"}, {"oid": "79ea66b4e43e64d27a31a135dc16e97c6089f00c", "url": "https://github.com/palantir/atlasdb/commit/79ea66b4e43e64d27a31a135dc16e97c6089f00c", "message": "Fix merge conflicts", "committedDate": "2020-05-26T10:47:10Z", "type": "commit"}, {"oid": "18812dcee0920c41d024491a80fbf388003ed086", "url": "https://github.com/palantir/atlasdb/commit/18812dcee0920c41d024491a80fbf388003ed086", "message": "Add retrying for migration", "committedDate": "2020-05-26T11:22:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM5NTU2OQ==", "url": "https://github.com/palantir/atlasdb/pull/4796#discussion_r430395569", "bodyText": "discuss: either make this non-Optional, or add a safety buffer in the ranges above before doing the actual migration", "author": "jeremyk-91", "createdAt": "2020-05-26T13:04:29Z", "path": "leader-election-impl/src/main/java/com/palantir/paxos/PaxosStateLogMigrator.java", "diffHunk": "@@ -83,5 +91,25 @@ private long lowestSequenceToMigrate() {\n         PaxosStateLog<V> destinationLog();\n         Persistable.Hydrator<V> hydrator();\n         SqlitePaxosStateLogMigrationState migrationState();\n+        OptionalLong migrateFrom();", "originalCommit": "18812dcee0920c41d024491a80fbf388003ed086", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM5NzM5MA==", "url": "https://github.com/palantir/atlasdb/pull/4796#discussion_r430397390", "bodyText": "For debugging: Would it make sense to log the exceptions here?", "author": "jeremyk-91", "createdAt": "2020-05-26T13:07:17Z", "path": "leader-election-impl/src/main/java/com/palantir/paxos/PaxosStateLogMigrator.java", "diffHunk": "@@ -29,52 +38,51 @@\n \n     private final PaxosStateLog<V> sourceLog;\n     private final PaxosStateLog<V> destinationLog;\n-    private final Persistable.Hydrator<V> hydrator;\n-    private final SqlitePaxosStateLogMigrationState migrationState;\n \n-    private PaxosStateLogMigrator(PaxosStateLog<V> sourceLog,\n-            PaxosStateLog<V> destinationLog,\n-            Persistable.Hydrator<V> hydrator,\n-            SqlitePaxosStateLogMigrationState migrationState) {\n+    private PaxosStateLogMigrator(PaxosStateLog<V> sourceLog, PaxosStateLog<V> destinationLog) {\n         this.sourceLog = sourceLog;\n         this.destinationLog = destinationLog;\n-        this.hydrator = hydrator;\n-        this.migrationState = migrationState;\n     }\n \n-    public static <V extends Persistable & Versionable> void migrateToValidation(MigrationContext<V> context) {\n-        PaxosStateLogMigrator<V> migrator = new PaxosStateLogMigrator<>(\n-                context.sourceLog(),\n-                context.destinationLog(),\n-                context.hydrator(),\n-                context.migrationState());\n-        if (!context.migrationState().hasMigratedFromInitialState()\n-                || context.destinationLog().getGreatestLogEntry() != context.sourceLog().getGreatestLogEntry()) {\n-            migrator.runMigration();\n-            context.migrationState().migrateToValidationState();\n+    public static <V extends Persistable & Versionable> long migrateAndReturnCutoff(MigrationContext<V> context) {\n+        PaxosStateLogMigrator<V> migrator = new PaxosStateLogMigrator<>(context.sourceLog(), context.destinationLog());\n+        if (!context.migrationState().isInMigratedState()) {\n+            long migrationLowerBound = context.migrateFrom().orElse(context.sourceLog().getGreatestLogEntry());\n+            migrator.runMigration(migrationLowerBound, context.hydrator());\n+            context.migrationState().setCutoff(migrationLowerBound);\n+            context.migrationState().migrateToMigratedState();\n+            return migrationLowerBound;\n         }\n+        return context.migrationState().getCutoff();\n     }\n \n-    private void runMigration() {\n+    private void runMigration(long lowerBound, Persistable.Hydrator<V> hydrator) {\n         destinationLog.truncate(destinationLog.getGreatestLogEntry());\n-        long lowerBound = lowestSequenceToMigrate();\n         long upperBound = sourceLog.getGreatestLogEntry();\n         if (upperBound == PaxosAcceptor.NO_LOG_ENTRY) {\n             return;\n         }\n \n-        try (PaxosStateLogBatchReader<V> reader = new PaxosStateLogBatchReader<>(sourceLog, hydrator, 100)) {\n-            long numberOfBatches = (upperBound - lowerBound) / BATCH_SIZE + 1;\n-            LongStream.iterate(lowerBound, x -> x + BATCH_SIZE)\n-                    .limit(numberOfBatches)\n-                    .mapToObj(sequence -> reader.readBatch(sequence, BATCH_SIZE))\n-                    .forEach(destinationLog::writeBatchOfRounds);\n-        }\n+        LogReader<V> reader = new LogReader<>(sourceLog, hydrator);\n+        List<PaxosRound<V>> roundsToMigrate = LongStream.rangeClosed(lowerBound, upperBound)\n+                .mapToObj(reader::read)\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .collect(Collectors.toList());\n+        Iterables.partition(roundsToMigrate, BATCH_SIZE)\n+                .forEach(batch -> writeBatchRetryingUpToFiveTimes(destinationLog, batch));\n     }\n \n-    private long lowestSequenceToMigrate() {\n-        long leastLogEntry = sourceLog.getLeastLogEntry();\n-        return leastLogEntry == PaxosAcceptor.NO_LOG_ENTRY ? 0L : leastLogEntry;\n+    private void writeBatchRetryingUpToFiveTimes(PaxosStateLog<V> target, List<PaxosRound<V>> batch) {\n+        for (int retryCount = 0; retryCount < 5; retryCount++) {\n+            try {\n+                target.writeBatchOfRounds(batch);\n+                return;\n+            } catch (Exception e) {\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);", "originalCommit": "18812dcee0920c41d024491a80fbf388003ed086", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQwMTA0Mw==", "url": "https://github.com/palantir/atlasdb/pull/4796#discussion_r430401043", "bodyText": "\ud83d\ude80", "author": "jeremyk-91", "createdAt": "2020-05-26T13:13:05Z", "path": "leader-election-impl/src/test/java/com/palantir/paxos/FileToSqlitePaxosStateLogIntegrationTest.java", "diffHunk": "@@ -79,9 +85,19 @@ private void migrateAndVerifyValuesForSequences(LongStream sequences) {\n         source.writeBatchOfRounds(rounds);\n \n         migrate();\n-        List<PaxosValue> migratedValues = readMigratedValuesFor(expectedValues);\n-\n-        assertThat(migratedValues).isEqualTo(roundsToValues(rounds));\n+        long cutoff = source.getGreatestLogEntry() - 10;\n+        Map<Long, byte[]> targetEntries = readMigratedValuesFor(expectedValues);\n+\n+        targetEntries.entrySet().stream()\n+                .filter(entry -> entry.getKey() < cutoff)\n+                .map(Map.Entry::getValue)\n+                .map(Assertions::assertThat)\n+                .forEach(AbstractAssert::isNull);", "originalCommit": "18812dcee0920c41d024491a80fbf388003ed086", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQwMjk1NA==", "url": "https://github.com/palantir/atlasdb/pull/4796#discussion_r430402954", "bodyText": "discussed offline: PaxosAcceptor.NO_LOG_ENTRY seems more appropriate", "author": "jeremyk-91", "createdAt": "2020-05-26T13:15:56Z", "path": "leader-election-impl/src/test/java/com/palantir/paxos/SqlitePaxosStateLogMigrationStateTest.java", "diffHunk": "@@ -105,4 +105,16 @@ public void finishingMigrationForOneUseCaseDoesNotSetFlagForOthers() {\n         otherState.migrateToValidationState();\n         assertThat(otherState.hasMigratedFromInitialState()).isTrue();\n     }\n+\n+    @Test\n+    public void defaultCutoffIsLongMinValue() {\n+        assertThat(migrationState.getCutoff()).isEqualTo(Long.MIN_VALUE);", "originalCommit": "18812dcee0920c41d024491a80fbf388003ed086", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQwMzY2Mw==", "url": "https://github.com/palantir/atlasdb/pull/4796#discussion_r430403663", "bodyText": "note: This test is expected to change because we plan on making the migrator remember a buffer of entries before the one externally specified.", "author": "jeremyk-91", "createdAt": "2020-05-26T13:16:56Z", "path": "leader-election-impl/src/test/java/com/palantir/paxos/PaxosStateLogMigratorTest.java", "diffHunk": "@@ -66,75 +81,104 @@ public void emptyLogMigrationSuccessfullyMarksAsMigrated() {\n     }\n \n     @Test\n-    public void logMigrationSuccessfullyMigratesEntries() {\n+    public void logMigrationWithNoLowerBoundMigratesOnlyGreatest() {", "originalCommit": "18812dcee0920c41d024491a80fbf388003ed086", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQwNTYyMg==", "url": "https://github.com/palantir/atlasdb/pull/4796#discussion_r430405622", "bodyText": "Let's document the behaviour where expectedCutoff > upperBound (which currently is not migrating anything, which is weird but we may not want to ban that).", "author": "jeremyk-91", "createdAt": "2020-05-26T13:19:48Z", "path": "leader-election-impl/src/test/java/com/palantir/paxos/PaxosStateLogMigratorTest.java", "diffHunk": "@@ -66,75 +81,104 @@ public void emptyLogMigrationSuccessfullyMarksAsMigrated() {\n     }\n \n     @Test\n-    public void logMigrationSuccessfullyMigratesEntries() {\n+    public void logMigrationWithNoLowerBoundMigratesOnlyGreatest() {\n         long lowerBound = 10;\n         long upperBound = 25;\n-        List<PaxosValue> valuesWritten = insertValuesWithinBounds(lowerBound, upperBound, source);\n+        insertValuesWithinBounds(lowerBound, upperBound, source);\n \n-        migrateFrom(source);\n+        long cutoff = migrateFrom(source);\n+\n+        assertThat(cutoff).isEqualTo(upperBound);\n         assertThat(migrationState.hasMigratedFromInitialState()).isTrue();\n-        assertThat(target.getLeastLogEntry()).isEqualTo(lowerBound);\n+        assertThat(migrationState.isInMigratedState()).isTrue();\n+        assertThat(target.getLeastLogEntry()).isEqualTo(upperBound);\n         assertThat(target.getGreatestLogEntry()).isEqualTo(upperBound);\n \n-        valuesWritten.forEach(value -> assertThat(getPaxosValue(target, value.seq)).isEqualTo(value));\n+        LongStream.rangeClosed(lowerBound, upperBound - 1)\n+                .mapToObj(sequence -> readRoundUnchecked(target, sequence))\n+                .map(Assertions::assertThat)\n+                .forEach(AbstractAssert::isNull);\n+        assertThat(getPaxosValue(target, upperBound)).isEqualTo(valueForRound(upperBound));\n+    }\n+\n+    @Test\n+    public void logMigrationWithLowerBoundMigratesFromBound() {\n+        long lowerBound = 10;\n+        long upperBound = 25;\n+        insertValuesWithinBounds(lowerBound, upperBound, source);\n+\n+        long expectedCutoff = 17;\n+        long cutoff = migrateFrom(source, OptionalLong.of(expectedCutoff));\n+\n+        assertThat(cutoff).isEqualTo(expectedCutoff);\n+        assertThat(migrationState.hasMigratedFromInitialState()).isTrue();\n+        assertThat(migrationState.isInMigratedState()).isTrue();\n+        assertThat(target.getLeastLogEntry()).isEqualTo(expectedCutoff);\n+        assertThat(target.getGreatestLogEntry()).isEqualTo(upperBound);\n+\n+        LongStream.rangeClosed(lowerBound, expectedCutoff - 1)\n+                .mapToObj(sequence -> readRoundUnchecked(target, sequence))\n+                .map(Assertions::assertThat)\n+                .forEach(AbstractAssert::isNull);\n+        KeyedStream.of(LongStream.rangeClosed(expectedCutoff, upperBound).boxed())\n+                .map(sequence -> getPaxosValue(target, sequence))\n+                .mapKeys(PaxosStateLogTestUtils::valueForRound)\n+                .entries()\n+                .forEach(entry -> assertThat(entry.getKey()).isEqualTo(entry.getValue()));\n     }", "originalCommit": "18812dcee0920c41d024491a80fbf388003ed086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE2NDUyNg==", "url": "https://github.com/palantir/atlasdb/pull/4796#discussion_r431164526", "bodyText": "Yeah, this actually doesn't play nice with splitting log so changed", "author": "gmaretic", "createdAt": "2020-05-27T14:13:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQwNTYyMg=="}], "type": "inlineReview"}, {"oid": "697dd5c344d90d79a7eb36282882898227c26a9a", "url": "https://github.com/palantir/atlasdb/commit/697dd5c344d90d79a7eb36282882898227c26a9a", "message": "Fix merge conflicts", "committedDate": "2020-05-27T13:30:25Z", "type": "commit"}, {"oid": "fdd0eb639d09f940341b50021b5c999bb0da7d5f", "url": "https://github.com/palantir/atlasdb/commit/fdd0eb639d09f940341b50021b5c999bb0da7d5f", "message": "Address CR and always migrate at least one entry if possible", "committedDate": "2020-05-27T14:16:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE4MjU2MA==", "url": "https://github.com/palantir/atlasdb/pull/4796#discussion_r431182560", "bodyText": "nit: private", "author": "jeremyk-91", "createdAt": "2020-05-27T14:33:16Z", "path": "leader-election-impl/src/main/java/com/palantir/paxos/PaxosStateLogMigrator.java", "diffHunk": "@@ -33,8 +35,12 @@\n import com.palantir.common.persist.Persistable;\n \n public final class PaxosStateLogMigrator<V extends Persistable & Versionable> {\n+    public static final Logger log = LoggerFactory.getLogger(PaxosStateLogMigrator.class);", "originalCommit": "fdd0eb639d09f940341b50021b5c999bb0da7d5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d3425c5e02a1d1d72455d4bb6a69de69b906bd74", "url": "https://github.com/palantir/atlasdb/commit/d3425c5e02a1d1d72455d4bb6a69de69b906bd74", "message": "Fix semantic merge conflict", "committedDate": "2020-05-27T16:08:38Z", "type": "commit"}, {"oid": "1f4110cd9e90aa7a52fe089fc24fe04a9d999a50", "url": "https://github.com/palantir/atlasdb/commit/1f4110cd9e90aa7a52fe089fc24fe04a9d999a50", "message": "Address nit and re-add 5 second timeout", "committedDate": "2020-05-27T16:13:11Z", "type": "commit"}]}