{"pr_number": 4750, "pr_title": "Fix case when fail to register lock after starting transaction", "pr_createdAt": "2020-05-04T10:48:17Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4750", "timeline": [{"oid": "aedfe92cdd40a18073233d403489e54ca3efdc63", "url": "https://github.com/palantir/atlasdb/commit/aedfe92cdd40a18073233d403489e54ca3efdc63", "message": "Fix bug when fail to register lock", "committedDate": "2020-05-04T10:43:43Z", "type": "commit"}, {"oid": "d3f0fe2ec976c34422f2bc5ba45b1dbe85ef12a2", "url": "https://github.com/palantir/atlasdb/commit/d3f0fe2ec976c34422f2bc5ba45b1dbe85ef12a2", "message": "Remove unnecessary diff", "committedDate": "2020-05-04T10:48:14Z", "type": "commit"}, {"oid": "41af889c56d4bfab1d2572842f1a674529b092ca", "url": "https://github.com/palantir/atlasdb/commit/41af889c56d4bfab1d2572842f1a674529b092ca", "message": "Add generated changelog entries", "committedDate": "2020-05-04T10:48:14Z", "type": "commit"}, {"oid": "a41d88a0c81426c95862e0450c03cac6e93fc1f0", "url": "https://github.com/palantir/atlasdb/commit/a41d88a0c81426c95862e0450c03cac6e93fc1f0", "message": "Add generated changelog entries", "committedDate": "2020-05-04T10:48:14Z", "type": "commit"}, {"oid": "e37e504a686571115f38ab46a9f824c4177df84a", "url": "https://github.com/palantir/atlasdb/commit/e37e504a686571115f38ab46a9f824c4177df84a", "message": "Add generated changelog entries", "committedDate": "2020-05-04T10:48:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQwMjI4OQ==", "url": "https://github.com/palantir/atlasdb/pull/4750#discussion_r419402289", "bodyText": "When does LockRefresher.registerLock throw exception? Why don't we want to retry registering in that case?", "author": "sudiksha27", "createdAt": "2020-05-04T12:35:21Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TimeLockClient.java", "diffHunk": "@@ -96,7 +97,12 @@ public LockImmutableTimestampResponse lockImmutableTimestamp() {\n     public StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n         StartIdentifiedAtlasDbTransactionResponse response = executeOnTimeLock(\n                 delegate::startIdentifiedAtlasDbTransaction);\n-        lockRefresher.registerLock(response.immutableTimestamp().getLock());\n+        try {\n+            lockRefresher.registerLock(response.immutableTimestamp().getLock());\n+        } catch (Throwable t) {\n+            unlock(ImmutableSet.of(response.immutableTimestamp().getLock()));", "originalCommit": "41af889c56d4bfab1d2572842f1a674529b092ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ0MDgyMg==", "url": "https://github.com/palantir/atlasdb/pull/4750#discussion_r419440822", "bodyText": "registerLock (which in the future PR becomes registerLocks, i.e. a batched variant) essentially performs addAll on a ConcurrentHashMap. The only documented exceptions here are NullPointerException in the case when the lock is null (which will naturally throw when trying to unlock also), or UnsupportedOperationException which really should not throw unless something is really wrong.\nSo all in all, there is little-to-no chance that, in practice, this would happen anyway; however, to be technically correct we should do this (or if it takes on additional behaviour in the future). We probably don't want to retry because that probably means something really wrong has happened, and in that case we want that to propagate up.", "author": "Jolyon-S", "createdAt": "2020-05-04T13:36:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQwMjI4OQ=="}], "type": "inlineReview"}]}