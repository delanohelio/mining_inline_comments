{"pr_number": 5131, "pr_title": "Clock went backwards corruption check", "pr_createdAt": "2020-11-25T10:17:30Z", "pr_url": "https://github.com/palantir/atlasdb/pull/5131", "timeline": [{"oid": "31b54ba39160f3adff0fc8dd3cd9682200086785", "url": "https://github.com/palantir/atlasdb/commit/31b54ba39160f3adff0fc8dd3cd9682200086785", "message": "Clock went backwards corruption check", "committedDate": "2020-11-25T10:00:55Z", "type": "commit"}, {"oid": "ed2aa51a2c1f7de1a8fe08cf88d8f47805478ef6", "url": "https://github.com/palantir/atlasdb/commit/ed2aa51a2c1f7de1a8fe08cf88d8f47805478ef6", "message": "Add generated changelog entries", "committedDate": "2020-11-25T10:00:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3MDQ0NA==", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r530470444", "bodyText": "Technically, I don't think we guarantee non-negative timestamps, so this should be Long.MIN_VALUE", "author": "gmaretic", "createdAt": "2020-11-25T15:46:00Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java", "diffHunk": "@@ -195,4 +206,35 @@ private static int getQuorumSize(List<ConsolidatedLearnerAndAcceptorRecord> reco\n     private static byte[] getPaxosValueData(Optional<PaxosValue> learnedValue) {\n         return learnedValue.map(PaxosValue::getData).orElse(null);\n     }\n+\n+    private static boolean clockWentBackwardsOnNode(ConsolidatedLearnerAndAcceptorRecord record) {\n+        List<SequenceAndTimestampPair> seqAndTimestampPairs = KeyedStream.stream(record.record())\n+                .map(val -> getPaxosValueData(val.learnedValue()))\n+                .filter(Predicates.notNull())\n+                .mapEntries((sequence, timestamp) -> Maps.immutableEntry(\n+                        sequence, ImmutableSequenceAndTimestampPair.of(sequence, PtBytes.toLong(timestamp))))\n+                .values()\n+                .sorted(Comparator.comparingLong(SequenceAndTimestampPair::sequence))\n+                .collect(Collectors.toList());\n+\n+        long greatestTimestampSoFar = -1L;", "originalCommit": "ed2aa51a2c1f7de1a8fe08cf88d8f47805478ef6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUwMTI0Ng==", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r530501246", "bodyText": "If you want to be a bit fancy:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<SequenceAndTimestampPair> seqAndTimestampPairs = KeyedStream.stream(record.record())\n          \n          \n            \n                            .map(val -> getPaxosValueData(val.learnedValue()))\n          \n          \n            \n                            .filter(Predicates.notNull())\n          \n          \n            \n                            .mapEntries((sequence, timestamp) -> Maps.immutableEntry(\n          \n          \n            \n                                    sequence, ImmutableSequenceAndTimestampPair.of(sequence, PtBytes.toLong(timestamp))))\n          \n          \n            \n                            .values()\n          \n          \n            \n                            .sorted(Comparator.comparingLong(SequenceAndTimestampPair::sequence))\n          \n          \n            \n                            .collect(Collectors.toList());\n          \n          \n            \n            \n          \n          \n            \n                    long greatestTimestampSoFar = -1L;\n          \n          \n            \n                    long currentTimestamp;\n          \n          \n            \n                    for (SequenceAndTimestampPair sequenceAndTimestampPair : seqAndTimestampPairs) {\n          \n          \n            \n                        currentTimestamp = sequenceAndTimestampPair.timestamp();\n          \n          \n            \n                        if (currentTimestamp <= greatestTimestampSoFar) {\n          \n          \n            \n                            return true;\n          \n          \n            \n                        }\n          \n          \n            \n                        greatestTimestampSoFar = currentTimestamp;\n          \n          \n            \n                    }\n          \n          \n            \n                    return false;\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                @Value.Immutable\n          \n          \n            \n                interface SequenceAndTimestampPair {\n          \n          \n            \n                    @Value.Parameter\n          \n          \n            \n                    long sequence();\n          \n          \n            \n            \n          \n          \n            \n                    @Value.Parameter\n          \n          \n            \n                    long timestamp();\n          \n          \n            \n                }\n          \n          \n            \n                    Stream<Long> expectedSortedTimestamps = KeyedStream.stream(record.record())\n          \n          \n            \n                            .map(val -> getPaxosValueData(val.learnedValue()))\n          \n          \n            \n                            .filter(Predicates.notNull())\n          \n          \n            \n                            .mapEntries((sequence, timestamp) -> Maps.immutableEntry(sequence, PtBytes.toLong(timestamp)))\n          \n          \n            \n                            .entries()\n          \n          \n            \n                            .sorted(Comparator.comparingLong(Entry::getKey))\n          \n          \n            \n                            .map(Entry::getValue);\n          \n          \n            \n                    return StreamEx.of(expectedSortedTimestamps)\n          \n          \n            \n                            .pairMap((first, second) -> first >= second)\n          \n          \n            \n                            .anyMatch(x -> x);\n          \n      \n    \n    \n  \n\nIf you don't want to use StreamEx, you can still avoid the immutable by checking expectedSortedTimestamps in a for loop, but just compare neighbours instead of maintaining a global maximum", "author": "gmaretic", "createdAt": "2020-11-25T16:28:57Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java", "diffHunk": "@@ -195,4 +206,35 @@ private static int getQuorumSize(List<ConsolidatedLearnerAndAcceptorRecord> reco\n     private static byte[] getPaxosValueData(Optional<PaxosValue> learnedValue) {\n         return learnedValue.map(PaxosValue::getData).orElse(null);\n     }\n+\n+    private static boolean clockWentBackwardsOnNode(ConsolidatedLearnerAndAcceptorRecord record) {\n+        List<SequenceAndTimestampPair> seqAndTimestampPairs = KeyedStream.stream(record.record())\n+                .map(val -> getPaxosValueData(val.learnedValue()))\n+                .filter(Predicates.notNull())\n+                .mapEntries((sequence, timestamp) -> Maps.immutableEntry(\n+                        sequence, ImmutableSequenceAndTimestampPair.of(sequence, PtBytes.toLong(timestamp))))\n+                .values()\n+                .sorted(Comparator.comparingLong(SequenceAndTimestampPair::sequence))\n+                .collect(Collectors.toList());\n+\n+        long greatestTimestampSoFar = -1L;\n+        long currentTimestamp;\n+        for (SequenceAndTimestampPair sequenceAndTimestampPair : seqAndTimestampPairs) {\n+            currentTimestamp = sequenceAndTimestampPair.timestamp();\n+            if (currentTimestamp <= greatestTimestampSoFar) {\n+                return true;\n+            }\n+            greatestTimestampSoFar = currentTimestamp;\n+        }\n+        return false;\n+    }\n+\n+    @Value.Immutable\n+    interface SequenceAndTimestampPair {\n+        @Value.Parameter\n+        long sequence();\n+\n+        @Value.Parameter\n+        long timestamp();\n+    }", "originalCommit": "ed2aa51a2c1f7de1a8fe08cf88d8f47805478ef6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0cd816b10c140b97e74da379fe1a05ed1768a68d", "url": "https://github.com/palantir/atlasdb/commit/0cd816b10c140b97e74da379fe1a05ed1768a68d", "message": "Redesign - WIP", "committedDate": "2020-11-25T19:21:01Z", "type": "commit"}, {"oid": "d17e7fb53d20f629e538411139944f4f02d07243", "url": "https://github.com/palantir/atlasdb/commit/d17e7fb53d20f629e538411139944f4f02d07243", "message": "Revert \"Clock went backwards corruption check\"\n\nThis reverts commit 31b54ba39160f3adff0fc8dd3cd9682200086785.", "committedDate": "2020-11-25T19:22:02Z", "type": "commit"}, {"oid": "0ed9dbcfa1cb3ee6ec933621f42ea9c7d5a7d4ab", "url": "https://github.com/palantir/atlasdb/commit/0ed9dbcfa1cb3ee6ec933621f42ea9c7d5a7d4ab", "message": "Keep required changes", "committedDate": "2020-11-25T19:27:03Z", "type": "commit"}, {"oid": "9d48095200ead345e2381f8eb6267c00a17bb346", "url": "https://github.com/palantir/atlasdb/commit/9d48095200ead345e2381f8eb6267c00a17bb346", "message": "Update check for edge cases + add tests", "committedDate": "2020-11-30T10:26:56Z", "type": "commit"}, {"oid": "a195ecffbdad984192d9c668ba02ce7b41717c96", "url": "https://github.com/palantir/atlasdb/commit/a195ecffbdad984192d9c668ba02ce7b41717c96", "message": "Fix test", "committedDate": "2020-11-30T12:08:25Z", "type": "commit"}, {"oid": "b62c445e67a80d9073ffac47ab719d812c81a7a7", "url": "https://github.com/palantir/atlasdb/commit/b62c445e67a80d9073ffac47ab719d812c81a7a7", "message": "Bug fix - WIP", "committedDate": "2020-11-30T12:20:25Z", "type": "commit"}, {"oid": "efcae68f1ca68ae6914b69cfc18c4890cd8d0568", "url": "https://github.com/palantir/atlasdb/commit/efcae68f1ca68ae6914b69cfc18c4890cd8d0568", "message": "Some more fixes", "committedDate": "2020-11-30T14:42:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY2NjY2MA==", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r532666660", "bodyText": "This won't work, need to fetch the next seq number > upper and use range [lower, next_seq_after_upper] for analysis.", "author": "sudiksha27", "createdAt": "2020-11-30T15:08:46Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/LocalTimestampInvariantsVerifier.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Predicates;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.history.HistoryQuerySequenceBounds;\n+import com.palantir.timelock.history.PaxosLogHistoryProgressTracker;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.util.UseCaseUtils;\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.sql.DataSource;\n+import one.util.streamex.StreamEx;\n+\n+public class LocalTimestampInvariantsVerifier {\n+    @VisibleForTesting\n+    static final int DELTA = 5;\n+\n+    private final SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory;", "originalCommit": "efcae68f1ca68ae6914b69cfc18c4890cd8d0568", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c6a3cfd48bceb97bd77be178a7849077d6d906a3", "url": "https://github.com/palantir/atlasdb/commit/c6a3cfd48bceb97bd77be178a7849077d6d906a3", "message": "Resign - II", "committedDate": "2020-12-01T00:59:26Z", "type": "commit"}, {"oid": "59d1471a2271cd58e20b8779581494a79a788c53", "url": "https://github.com/palantir/atlasdb/commit/59d1471a2271cd58e20b8779581494a79a788c53", "message": "Clean", "committedDate": "2020-12-01T09:49:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM3NDcxMQ==", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r533374711", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        .putAllViolatingStatusesToNamespaceAndUseCase(\n          \n          \n            \n                                                paxosRoundCorruptionReport.violatingStatusesToNamespaceAndUseCase())\n          \n          \n            \n                                                                    .from(paxosRoundCorruptionReport)", "author": "gmaretic", "createdAt": "2020-12-01T12:34:37Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/LocalCorruptionDetector.java", "diffHunk": "@@ -34,30 +34,44 @@\n             new NamedThreadFactory(CORRUPTION_DETECTOR_THREAD_PREFIX, true));\n     private final LocalCorruptionHandler corruptionHandler;\n     private final PaxosLogHistoryProvider historyProvider;\n+    private final LocalTimestampInvariantsVerifier timestampInvariantsVerifier;\n \n     private volatile CorruptionStatus localCorruptionState = CorruptionStatus.HEALTHY;\n     private volatile CorruptionHealthReport localCorruptionReport = CorruptionHealthReport.defaultHealthyReport();\n \n     public static LocalCorruptionDetector create(\n-            PaxosLogHistoryProvider historyProvider, List<TimeLockCorruptionNotifier> corruptionNotifiers) {\n+            PaxosLogHistoryProvider historyProvider,\n+            List<TimeLockCorruptionNotifier> corruptionNotifiers,\n+            LocalTimestampInvariantsVerifier timestampInvariants) {\n         LocalCorruptionDetector localCorruptionDetector =\n-                new LocalCorruptionDetector(historyProvider, corruptionNotifiers);\n+                new LocalCorruptionDetector(historyProvider, corruptionNotifiers, timestampInvariants);\n \n         localCorruptionDetector.scheduleWithFixedDelay();\n         return localCorruptionDetector;\n     }\n \n     private LocalCorruptionDetector(\n-            PaxosLogHistoryProvider historyProvider, List<TimeLockCorruptionNotifier> corruptionNotifiers) {\n+            PaxosLogHistoryProvider historyProvider,\n+            List<TimeLockCorruptionNotifier> corruptionNotifiers,\n+            LocalTimestampInvariantsVerifier timestampInvariantsVerifier) {\n \n         this.historyProvider = historyProvider;\n+        this.timestampInvariantsVerifier = timestampInvariantsVerifier;\n         this.corruptionHandler = new LocalCorruptionHandler(corruptionNotifiers);\n     }\n \n     private void scheduleWithFixedDelay() {\n         executor.scheduleWithFixedDelay(\n                 () -> {\n-                    localCorruptionReport = analyzeHistoryAndBuildCorruptionHealthReport();\n+                    CorruptionHealthReport paxosRoundCorruptionReport = analyzeHistoryAndBuildCorruptionHealthReport();\n+                    CorruptionHealthReport timestampInvariantsReport =\n+                            timestampInvariantsVerifier.timestampInvariantsHealthReport();\n+                    localCorruptionReport = ImmutableCorruptionHealthReport.builder()\n+                            .putAllViolatingStatusesToNamespaceAndUseCase(\n+                                    paxosRoundCorruptionReport.violatingStatusesToNamespaceAndUseCase())", "originalCommit": "59d1471a2271cd58e20b8779581494a79a788c53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM3Njg1NQ==", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r533376855", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .filter(Predicates.notNull())\n          \n          \n            \n                            .filter(Objects::nonNull)", "author": "gmaretic", "createdAt": "2020-12-01T12:38:36Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/LocalTimestampInvariantsVerifier.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Predicates;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.util.UseCaseUtils;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.sql.DataSource;\n+import one.util.streamex.StreamEx;\n+\n+/**\n+ * This class validates that timestamp bounds increase with increasing sequence numbers.\n+ *\n+ * The validation is done batch wise, e.g. [1, n], [n, 2 * n - 1] and so on. Two consecutive batches share\n+ * boundaries, this is expected and is done to catch inversion at batch end.\n+ * */\n+public class LocalTimestampInvariantsVerifier {\n+    @VisibleForTesting\n+    public static final int LEARNER_LOG_BATCH_SIZE_LIMIT = 250;\n+\n+    public static final long MIN_SEQUENCE_TO_BE_VERIFIED = -1L;\n+\n+    private final SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory;\n+    private Map<NamespaceAndUseCase, Long> minInclusiveSeqBoundsToBeVerified = new ConcurrentHashMap<>();\n+\n+    public LocalTimestampInvariantsVerifier(DataSource dataSource) {\n+        this.sqlitePaxosStateLogHistory = SqlitePaxosStateLogHistory.create(dataSource);\n+    }\n+\n+    public CorruptionHealthReport timestampInvariantsHealthReport() {\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> namespacesExhibitingViolations = KeyedStream.of(\n+                        getNamespaceAndUseCaseTuples())\n+                .map(this::timestampInvariantsViolationLevel)\n+                .filter(CorruptionCheckViolation::raiseErrorAlert)\n+                .mapEntries((k, v) -> Maps.immutableEntry(v, k))\n+                .collectToSetMultimap();\n+        return ImmutableCorruptionHealthReport.builder()\n+                .violatingStatusesToNamespaceAndUseCase(namespacesExhibitingViolations)\n+                .build();\n+    }\n+\n+    private CorruptionCheckViolation timestampInvariantsViolationLevel(NamespaceAndUseCase namespaceAndUseCase) {\n+        Stream<Long> expectedSortedTimestamps = KeyedStream.stream(getLearnerLogs(namespaceAndUseCase))\n+                .map(PaxosValue::getData)\n+                .filter(Predicates.notNull())", "originalCommit": "59d1471a2271cd58e20b8779581494a79a788c53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM3ODQ3NQ==", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r533378475", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final long MIN_SEQUENCE_TO_BE_VERIFIED = -1L;\n          \n          \n            \n                public static final long MIN_SEQUENCE_TO_BE_VERIFIED = Long.MIN_VALUE;", "author": "gmaretic", "createdAt": "2020-12-01T12:41:26Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/LocalTimestampInvariantsVerifier.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Predicates;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.util.UseCaseUtils;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.sql.DataSource;\n+import one.util.streamex.StreamEx;\n+\n+/**\n+ * This class validates that timestamp bounds increase with increasing sequence numbers.\n+ *\n+ * The validation is done batch wise, e.g. [1, n], [n, 2 * n - 1] and so on. Two consecutive batches share\n+ * boundaries, this is expected and is done to catch inversion at batch end.\n+ * */\n+public class LocalTimestampInvariantsVerifier {\n+    @VisibleForTesting\n+    public static final int LEARNER_LOG_BATCH_SIZE_LIMIT = 250;\n+\n+    public static final long MIN_SEQUENCE_TO_BE_VERIFIED = -1L;", "originalCommit": "59d1471a2271cd58e20b8779581494a79a788c53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MjQzMw==", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r533382433", "bodyText": "This method name is kinda misleading, it's actually forcing the timestamp to go forward / sequence to go backwards. It's only making the timestamp go backwards for the sequence after, right?", "author": "gmaretic", "createdAt": "2020-12-01T12:48:16Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/LocalTimestampInvariantsVerifierTest.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static com.palantir.timelock.corruption.detection.LocalTimestampInvariantsVerifier.LEARNER_LOG_BATCH_SIZE_LIMIT;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class LocalTimestampInvariantsVerifierTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionIfClockWentBackwardsOnNode() {\n+        helper.writeLogsOnDefaultLocalServer(1, LEARNER_LOG_BATCH_SIZE_LIMIT - 1);\n+        helper.forceTimestampToGoBackwards(5);", "originalCommit": "59d1471a2271cd58e20b8779581494a79a788c53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzMTEzMg==", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r533431132", "bodyText": "Ah yes, that makes sense. Basically what I mean is - create inversion b/w this sequence and the next. I have changed the name to createTimestampInversion now.", "author": "sudiksha27", "createdAt": "2020-12-01T14:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MjQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MzEwOQ==", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r533383109", "bodyText": "Shouldn't this then be helper.forceTimestampToGoBackwards(LEARNER_LOG_BATCH_SIZE_LIMIT - 1);?", "author": "gmaretic", "createdAt": "2020-12-01T12:49:26Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/LocalTimestampInvariantsVerifierTest.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static com.palantir.timelock.corruption.detection.LocalTimestampInvariantsVerifier.LEARNER_LOG_BATCH_SIZE_LIMIT;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class LocalTimestampInvariantsVerifierTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionIfClockWentBackwardsOnNode() {\n+        helper.writeLogsOnDefaultLocalServer(1, LEARNER_LOG_BATCH_SIZE_LIMIT - 1);\n+        helper.forceTimestampToGoBackwards(5);\n+        helper.assertClockWentBackwards();\n+    }\n+\n+    @Test\n+    public void detectIfClockWentBackwardsAtBatchStart() {\n+        helper.writeLogsOnDefaultLocalServer(1, LEARNER_LOG_BATCH_SIZE_LIMIT);\n+        helper.forceTimestampToGoBackwards(1);\n+        helper.assertClockWentBackwards();\n+    }\n+\n+    @Test\n+    public void detectIfClockWentBackwardsAtBatchEnd() {\n+        helper.writeLogsOnDefaultLocalServer(1, LEARNER_LOG_BATCH_SIZE_LIMIT);\n+        helper.forceTimestampToGoBackwards(LEARNER_LOG_BATCH_SIZE_LIMIT / 2);", "originalCommit": "59d1471a2271cd58e20b8779581494a79a788c53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzMTc1Nw==", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r533431757", "bodyText": "Good catch! yes, this is a copy pasting mistake.", "author": "sudiksha27", "createdAt": "2020-12-01T14:06:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MzEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4NDM1MA==", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r533384350", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    helper.forceTimestampToGoBackwards(LEARNER_LOG_BATCH_SIZE_LIMIT / 2);\n          \n          \n            \n                    helper.forceTimestampToGoBackwards(1);\n          \n      \n    \n    \n  \n\nThis way we test that we don't skip the one entry from first check. Also I guess do this before the first check to be consistent", "author": "gmaretic", "createdAt": "2020-12-01T12:51:38Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/LocalTimestampInvariantsVerifierTest.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static com.palantir.timelock.corruption.detection.LocalTimestampInvariantsVerifier.LEARNER_LOG_BATCH_SIZE_LIMIT;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class LocalTimestampInvariantsVerifierTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionIfClockWentBackwardsOnNode() {\n+        helper.writeLogsOnDefaultLocalServer(1, LEARNER_LOG_BATCH_SIZE_LIMIT - 1);\n+        helper.forceTimestampToGoBackwards(5);\n+        helper.assertClockWentBackwards();\n+    }\n+\n+    @Test\n+    public void detectIfClockWentBackwardsAtBatchStart() {\n+        helper.writeLogsOnDefaultLocalServer(1, LEARNER_LOG_BATCH_SIZE_LIMIT);\n+        helper.forceTimestampToGoBackwards(1);\n+        helper.assertClockWentBackwards();\n+    }\n+\n+    @Test\n+    public void detectIfClockWentBackwardsAtBatchEnd() {\n+        helper.writeLogsOnDefaultLocalServer(1, LEARNER_LOG_BATCH_SIZE_LIMIT);\n+        helper.forceTimestampToGoBackwards(LEARNER_LOG_BATCH_SIZE_LIMIT / 2);\n+        helper.assertClockWentBackwards();\n+    }\n+\n+    @Test\n+    public void detectIfClockWentBackwardsStartOfNextBatch() {\n+        helper.writeLogsOnDefaultLocalServer(1, 2 * LEARNER_LOG_BATCH_SIZE_LIMIT);\n+        helper.forceTimestampToGoBackwards(LEARNER_LOG_BATCH_SIZE_LIMIT);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertLocalTimestampInvariantsStand();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertClockWentBackwards();\n+    }\n+\n+    @Test\n+    public void detectIfClockWentBackwardsInLaterBatch() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 2 * LEARNER_LOG_BATCH_SIZE_LIMIT);\n+        helper.forceTimestampToGoBackwards(3 * LEARNER_LOG_BATCH_SIZE_LIMIT / 2);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertLocalTimestampInvariantsStand();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertClockWentBackwards();\n+    }\n+\n+    @Test\n+    public void resetsProgressIfNotEnoughLogsForVerification() {\n+        helper.writeLogsOnDefaultLocalServer(1, 1);\n+        // No signs of corruption\n+        helper.assertLocalTimestampInvariantsStand();\n+\n+        helper.writeLogsOnDefaultLocalServer(2, LEARNER_LOG_BATCH_SIZE_LIMIT);\n+        helper.forceTimestampToGoBackwards(LEARNER_LOG_BATCH_SIZE_LIMIT / 2);", "originalCommit": "59d1471a2271cd58e20b8779581494a79a788c53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzMjI1OQ==", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r533432259", "bodyText": "Done.", "author": "sudiksha27", "createdAt": "2020-12-01T14:06:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4NDM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4NTA5MQ==", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r533385091", "bodyText": "Maybe rename to assertClockWentBackwardsInNextBatch to be clearer? Same for the method below", "author": "gmaretic", "createdAt": "2020-12-01T12:53:00Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -105,6 +105,31 @@ void assertViolationDetectedForNamespaceAndUseCases(\n         return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n+    void assertClockWentBackwards() {", "originalCommit": "59d1471a2271cd58e20b8779581494a79a788c53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b25cf690794236dff2eda53a3fa62d24e5e63b25", "url": "https://github.com/palantir/atlasdb/commit/b25cf690794236dff2eda53a3fa62d24e5e63b25", "message": "Address comments", "committedDate": "2020-12-01T14:03:07Z", "type": "commit"}]}