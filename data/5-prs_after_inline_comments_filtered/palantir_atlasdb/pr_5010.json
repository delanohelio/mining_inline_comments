{"pr_number": 5010, "pr_title": "Dbkvs invalidate", "pr_createdAt": "2020-09-30T12:35:06Z", "pr_url": "https://github.com/palantir/atlasdb/pull/5010", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUyMDUzNQ==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r497520535", "bodyText": "InDbTimestampBoundStoreInitializer", "author": "gmaretic", "createdAt": "2020-09-30T13:44:16Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/timestamp/InDbTimestampBoundStoreHelper.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs.timestamp;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.palantir.atlasdb.keyvalue.dbkvs.OracleErrorConstants;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.nexus.db.DBType;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+\n+public class InDbTimestampBoundStoreHelper {", "originalCommit": "e8e3e8874736f0a7662e7919eba515b6fba9af2d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUyMDk0OA==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r497520948", "bodyText": "Uh, I don't see any snchronisation mechanism, although this is not a regression", "author": "gmaretic", "createdAt": "2020-09-30T13:44:48Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/timestamp/InDbTimestampBoundStoreHelper.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs.timestamp;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.palantir.atlasdb.keyvalue.dbkvs.OracleErrorConstants;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.nexus.db.DBType;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+\n+public class InDbTimestampBoundStoreHelper {\n+    private static final Logger log = LoggerFactory.getLogger(InDbTimestampBoundStore.class);\n+    private final ConnectionManager connManager;\n+\n+    @GuardedBy(\"this\") // lazy init to avoid db connections in constructors\n+    private DBType dbType;\n+\n+    public InDbTimestampBoundStoreHelper(ConnectionManager connManager) {\n+        this.connManager = connManager;\n+    }\n+\n+    public void createTableIfDoesNotExist(String prefixedTimestampTableName) {\n+        try (Connection conn = connManager.getConnection()) {\n+            createTimestampTable(conn, prefixedTimestampTableName);\n+        } catch (SQLException error) {\n+            throw PalantirSqlException.create(error);\n+        }\n+    }\n+\n+    private void createTimestampTable(Connection connection, String prefixedTimestampTableName) throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            if (getDbType(connection).equals(DBType.ORACLE)) {\n+                createTimestampTableIgnoringAlreadyExistsError(statement, prefixedTimestampTableName);\n+            } else {\n+                statement.execute(String.format(\"CREATE TABLE IF NOT EXISTS %s ( last_allocated int8 NOT NULL )\",\n+                        prefixedTimestampTableName));\n+            }\n+        }\n+    }\n+\n+    private void createTimestampTableIgnoringAlreadyExistsError(Statement statement, String prefixedTimestampTableName)\n+            throws SQLException {\n+        try {\n+            statement.execute(String.format(\"CREATE TABLE %s ( last_allocated NUMBER(38) NOT NULL )\",\n+                    prefixedTimestampTableName));\n+        } catch (SQLException e) {\n+            if (!e.getMessage().contains(OracleErrorConstants.ORACLE_ALREADY_EXISTS_ERROR)) {\n+                log.error(\"Error occurred creating the Oracle timestamp table\", e);\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    @GuardedBy(\"this\")", "originalCommit": "e8e3e8874736f0a7662e7919eba515b6fba9af2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUyMTgwNg==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r497521806", "bodyText": "Maybe just remove the annotation since it's not true? Or just make it synchronized to be on the safe side", "author": "gmaretic", "createdAt": "2020-09-30T13:45:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUyMDk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUzMTQxOA==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r497531418", "bodyText": "It's not ideal to have this hardcoded, but then again we do the same for Cassandra", "author": "gmaretic", "createdAt": "2020-09-30T13:57:49Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/InvalidationRunner.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.OptionalLong;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.immutables.value.Value;\n+\n+import com.palantir.atlasdb.AtlasDbConstants;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.ConnectionDbTypes;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.InDbTimestampBoundStoreHelper;\n+import com.palantir.atlasdb.spi.AtlasDbFactory;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.nexus.db.DBType;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+import com.palantir.nexus.db.pool.RetriableTransactions;\n+import com.palantir.nexus.db.pool.RetriableWriteTransaction;\n+\n+public class InvalidationRunner {\n+    private static final String LAST_ALLOCATED = \"last_allocated\";\n+    private static final String LEGACY_LAST_ALLOCATED = \"legacy_last_allocated\";\n+\n+    private final ConnectionManager connManager;\n+    private final InDbTimestampBoundStoreHelper helper;\n+\n+    public InvalidationRunner(ConnectionManager connManager) {\n+        this.connManager = connManager;\n+        this.helper = new InDbTimestampBoundStoreHelper(connManager);\n+    }\n+\n+    public void createTableIfDoesNotExist() {\n+        helper.createTableIfDoesNotExist(prefixedTimestampTableName());\n+    }\n+\n+    public long getLastAllocatedAndPoison() {\n+        RetriableTransactions.TransactionResult<Long> result = RetriableTransactions.run(connManager,\n+                new RetriableWriteTransaction<Long>() {\n+                    @Override\n+                    public Long run(Connection connection) throws SQLException {\n+                        Limits limits = getLimits(connection);\n+                        TableStatus tableStatus = checkTableStatus(limits);\n+\n+                        if (tableStatus == TableStatus.POISONED) {\n+                            return limits.legacyUpperLimit().value()\n+                                    .orElse(AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP);\n+                        }\n+\n+                        long lastAllocated;\n+\n+                        if (tableStatus == TableStatus.NO_DATA) {\n+                            lastAllocated = AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+                        } else {\n+                            lastAllocated = limits.upperLimit().value()\n+                                    .orElse(AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP);\n+                        }\n+\n+                        poisonTable(connection);\n+                        return lastAllocated;\n+                    }\n+                });\n+        switch (result.getStatus()) {\n+            case SUCCESSFUL:\n+                return result.getResultValue();\n+            case UNKNOWN:\n+            case FAILED:\n+                Throwable error = result.getError();\n+                if (error instanceof SQLException) {\n+                    throw PalantirSqlException.create((SQLException) error);\n+                }\n+                throw Throwables.rewrapAndThrowUncheckedException(error);\n+            default:\n+                throw new IllegalStateException(\"Unrecognized transaction status \" + result.getStatus());\n+        }\n+    }\n+\n+    private void poisonTable(Connection connection) throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            if (ConnectionDbTypes.getDbType(connection).equals(DBType.ORACLE)) {\n+                statement.execute(String.format(\"ALTER TABLE %s RENAME COLUMN last_allocated TO LEGACY_last_allocated\",\n+                        prefixedTimestampTableName()));\n+            } else {\n+                statement.execute(String.format(\"ALTER TABLE %s RENAME last_allocated TO LEGACY_last_allocated\",\n+                        prefixedTimestampTableName()));\n+            }\n+        }\n+    }\n+\n+    private Limits getLimits(Connection connection) throws SQLException {\n+        ImmutableLimits.Builder limitsBuilder = ImmutableLimits.builder();\n+        DatabaseMetaData metaData = connection.getMetaData();\n+        ResultSet res = metaData.getTables(null, null, prefixedTimestampTableName(), null);\n+\n+        Preconditions.checkState(res.next(), \"We are in the process of invalidating the \"\n+                + \"InDbTimestampBoundStore but the data table does not exist. \"\n+                + \"We should never reach here. Please contact support.\");\n+\n+        return limitsBuilder\n+                .upperLimit(getColumnStatus(LAST_ALLOCATED, metaData, connection))\n+                .legacyUpperLimit(getColumnStatus(LEGACY_LAST_ALLOCATED, metaData, connection))\n+                .build();\n+    }\n+\n+    private ColumnStatus getColumnStatus(String colName, DatabaseMetaData metaData, Connection connection)\n+            throws SQLException {\n+        ImmutableColumnStatus.Builder columnStatusBuilder = ImmutableColumnStatus.builder();\n+        ResultSet columns = metaData.getColumns(null, null, prefixedTimestampTableName(), colName);\n+\n+        if (columns.next()) {\n+            columnStatusBuilder.exists(true);\n+\n+            String sql = String.format(\"SELECT %s FROM %s FOR UPDATE\", colName, prefixedTimestampTableName());\n+            QueryRunner run = new QueryRunner();\n+            return run.query(connection, sql, rs -> {\n+                if (rs.next()) {\n+                    return columnStatusBuilder.value(rs.getLong(colName)).build();\n+                }\n+                return columnStatusBuilder.build();\n+            });\n+\n+        } else {\n+            return columnStatusBuilder.build();\n+        }\n+    }\n+\n+    private String prefixedTimestampTableName() {\n+        return AtlasDbConstants.TIMELOCK_TIMESTAMP_TABLE.getQualifiedName();", "originalCommit": "e8e3e8874736f0a7662e7919eba515b6fba9af2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxMTc2Mw==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r498411763", "bodyText": "Actually, I don't think this is right: you want AtlasDbConstants.TIMESTAMP_TABLE, or maybe even take in an argument. This is meant to invalidate a timestamp table from embedded -> timelock migration, so it needs to be the table a user previously ran an InDbTimestampBoundStore against.\nI'm aware there is one internal deployment where some special handling is required, but we'll help them as a special case.\nHope this made sense! Happy to catch up offline to clarify things if needed.", "author": "jeremyk-91", "createdAt": "2020-10-01T17:39:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUzMTQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU3MzE5Ng==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r497573196", "bodyText": "Move to after the tests", "author": "gmaretic", "createdAt": "2020-09-30T14:50:55Z", "path": "atlasdb-dbkvs-tests/src/test/java/com/palantir/atlasdb/keyvalue/dbkvs/DbKvsPostgresInvalidationRunnerTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import static com.palantir.atlasdb.spi.AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.palantir.atlasdb.AtlasDbConstants;\n+import com.palantir.atlasdb.keyvalue.dbkvs.impl.ConnectionManagerAwareDbKvs;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.InDbTimestampBoundStore;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.timestamp.TimestampBoundStore;\n+\n+public class DbKvsPostgresInvalidationRunnerTest {\n+    private final ConnectionManagerAwareDbKvs kvs = DbkvsPostgresTestSuite.createKvs();\n+    private final TimestampBoundStore store = getStore();\n+    private final InvalidationRunner invalidationRunner = new InvalidationRunner(kvs.getConnectionManager());\n+    private static final long TIMESTAMP_1 = 12000;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        kvs.dropTable(AtlasDbConstants.TIMELOCK_TIMESTAMP_TABLE);\n+        invalidationRunner.createTableIfDoesNotExist();\n+    }\n+\n+    public InDbTimestampBoundStore getStore() {", "originalCommit": "e017b134c21d314822c2d6b901a9fa3869db848d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYzMDMwNQ==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r497630305", "bodyText": "Currently this keeps retrying for a long time and then fails. So also when we poison the store, readers will behave the same. This is good because there is no risk of corruption, but it would be better to fail more quickly. We can change the read behaviour to allow for that, but in general we cannot succeed in this in case of an atlasdb downgrade.", "author": "gmaretic", "createdAt": "2020-09-30T16:07:44Z", "path": "atlasdb-dbkvs-tests/src/test/java/com/palantir/atlasdb/keyvalue/dbkvs/DbKvsPostgresInvalidationRunnerTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import static com.palantir.atlasdb.spi.AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.palantir.atlasdb.AtlasDbConstants;\n+import com.palantir.atlasdb.keyvalue.dbkvs.impl.ConnectionManagerAwareDbKvs;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.InDbTimestampBoundStore;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.timestamp.TimestampBoundStore;\n+\n+public class DbKvsPostgresInvalidationRunnerTest {\n+    private final ConnectionManagerAwareDbKvs kvs = DbkvsPostgresTestSuite.createKvs();\n+    private final TimestampBoundStore store = getStore();\n+    private final InvalidationRunner invalidationRunner = new InvalidationRunner(kvs.getConnectionManager());\n+    private static final long TIMESTAMP_1 = 12000;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        kvs.dropTable(AtlasDbConstants.TIMELOCK_TIMESTAMP_TABLE);\n+        invalidationRunner.createTableIfDoesNotExist();\n+    }\n+\n+    public InDbTimestampBoundStore getStore() {\n+        return InDbTimestampBoundStore.create(\n+                kvs.getConnectionManager(),\n+                AtlasDbConstants.TIMELOCK_TIMESTAMP_TABLE,\n+                DbkvsPostgresTestSuite.getKvsConfig().ddl().tablePrefix());\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        kvs.close();\n+    }\n+\n+    @Test\n+    public void poisonsEmptyTableAndReturnsNoOpTs() {\n+        assertThat(invalidationRunner.getLastAllocatedAndPoison()).isEqualTo(NO_OP_FAST_FORWARD_TIMESTAMP);\n+    }\n+\n+    @Test\n+    public void poisonsEmptyTableAndReturnsStoredBound() {\n+        store.getUpperLimit();\n+        store.storeUpperLimit(TIMESTAMP_1);\n+        assertThat(invalidationRunner.getLastAllocatedAndPoison()).isEqualTo(TIMESTAMP_1);\n+    }\n+\n+    @Test\n+    public void cannotReadAfterBeingPoisoned() {\n+        invalidationRunner.getLastAllocatedAndPoison();\n+        assertBoundNotReadable();\n+    }\n+\n+    @Test\n+    public void poisoningMultipleTimesIsAllowed() {\n+        store.storeUpperLimit(TIMESTAMP_1);\n+        store.getUpperLimit();\n+        assertThat(invalidationRunner.getLastAllocatedAndPoison()).isEqualTo(TIMESTAMP_1);\n+        assertThat(invalidationRunner.getLastAllocatedAndPoison()).isEqualTo(TIMESTAMP_1);\n+        assertThat(invalidationRunner.getLastAllocatedAndPoison()).isEqualTo(TIMESTAMP_1);\n+    }\n+\n+    @Test\n+    public void poisoningEmptyTableMultipleTimesIsAllowed() {\n+        assertThat(invalidationRunner.getLastAllocatedAndPoison()).isEqualTo(NO_OP_FAST_FORWARD_TIMESTAMP);\n+        assertThat(invalidationRunner.getLastAllocatedAndPoison()).isEqualTo(NO_OP_FAST_FORWARD_TIMESTAMP);\n+        assertThat(invalidationRunner.getLastAllocatedAndPoison()).isEqualTo(NO_OP_FAST_FORWARD_TIMESTAMP);\n+        assertBoundNotReadable();\n+    }\n+\n+    private void assertBoundNotReadable() {\n+        assertThatThrownBy(store::getUpperLimit).isInstanceOf(PalantirSqlException.class);", "originalCommit": "e8e3e8874736f0a7662e7919eba515b6fba9af2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYzMDc5MQ==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r497630791", "bodyText": "We can check in the store if there is the poison column first, and if yes, then fail immediately", "author": "gmaretic", "createdAt": "2020-09-30T16:08:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYzMDMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYzMjk4Mg==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r497632982", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final ConnectionManagerAwareDbKvs kvs = DbkvsPostgresTestSuite.createKvs();\n          \n          \n            \n                @ClassRule\n          \n          \n            \n                public static final TestResourceManager TRM = new TestResourceManager(DbkvsPostgresTestSuite::createKvs);\n          \n          \n            \n                \n          \n          \n            \n                private final ConnectionManagerAwareDbKvs kvs = (ConnectionManagerAwareDbKvs) TRM.getDefaultKvs();\n          \n          \n            \n                private final TimestampBoundStore store = InDbTimestampBoundStore.create(\n          \n          \n            \n                        kvs.getConnectionManager(),\n          \n          \n            \n                        AtlasDbConstants.TIMELOCK_TIMESTAMP_TABLE,\n          \n          \n            \n                        DbkvsPostgresTestSuite.getKvsConfig().ddl().tablePrefix());\n          \n          \n            \n                private final InvalidationRunner invalidationRunner = new InvalidationRunner(kvs.getConnectionManager());\n          \n          \n            \n                private static final long TIMESTAMP_1 = 12000;\n          \n          \n            \n            \n          \n          \n            \n                @Before\n          \n          \n            \n                public void setUp() {\n          \n          \n            \n                    kvs.dropTable(AtlasDbConstants.TIMELOCK_TIMESTAMP_TABLE);\n          \n          \n            \n                    invalidationRunner.createTableIfDoesNotExist();\n          \n          \n            \n                }", "author": "gmaretic", "createdAt": "2020-09-30T16:11:42Z", "path": "atlasdb-dbkvs-tests/src/test/java/com/palantir/atlasdb/keyvalue/dbkvs/DbKvsPostgresInvalidationRunnerTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import static com.palantir.atlasdb.spi.AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.palantir.atlasdb.AtlasDbConstants;\n+import com.palantir.atlasdb.keyvalue.dbkvs.impl.ConnectionManagerAwareDbKvs;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.InDbTimestampBoundStore;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.timestamp.TimestampBoundStore;\n+\n+public class DbKvsPostgresInvalidationRunnerTest {\n+    private final ConnectionManagerAwareDbKvs kvs = DbkvsPostgresTestSuite.createKvs();", "originalCommit": "e8e3e8874736f0a7662e7919eba515b6fba9af2d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYzMzcxOQ==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r497633719", "bodyText": "Maybe add some java docs", "author": "gmaretic", "createdAt": "2020-09-30T16:12:43Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/InvalidationRunner.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.OptionalLong;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.immutables.value.Value;\n+\n+import com.palantir.atlasdb.AtlasDbConstants;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.ConnectionDbTypes;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.InDbTimestampBoundStoreHelper;\n+import com.palantir.atlasdb.spi.AtlasDbFactory;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.nexus.db.DBType;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+import com.palantir.nexus.db.pool.RetriableTransactions;\n+import com.palantir.nexus.db.pool.RetriableWriteTransaction;\n+\n+public class InvalidationRunner {\n+    private static final String LAST_ALLOCATED = \"last_allocated\";\n+    private static final String LEGACY_LAST_ALLOCATED = \"legacy_last_allocated\";\n+\n+    private final ConnectionManager connManager;\n+    private final InDbTimestampBoundStoreHelper helper;\n+\n+    public InvalidationRunner(ConnectionManager connManager) {\n+        this.connManager = connManager;\n+        this.helper = new InDbTimestampBoundStoreHelper(connManager);\n+    }\n+\n+    public void createTableIfDoesNotExist() {\n+        helper.createTableIfDoesNotExist(prefixedTimestampTableName());\n+    }\n+\n+    public long getLastAllocatedAndPoison() {", "originalCommit": "e8e3e8874736f0a7662e7919eba515b6fba9af2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYzODI2NQ==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r497638265", "bodyText": "Actually, implements TimestampStoreInvalidator", "author": "gmaretic", "createdAt": "2020-09-30T16:19:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYzMzcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYzNTIyNw==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r497635227", "bodyText": "Maybe whenTableIsEmpty...", "author": "gmaretic", "createdAt": "2020-09-30T16:14:56Z", "path": "atlasdb-dbkvs-tests/src/test/java/com/palantir/atlasdb/keyvalue/dbkvs/DbKvsPostgresInvalidationRunnerTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import static com.palantir.atlasdb.spi.AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.palantir.atlasdb.AtlasDbConstants;\n+import com.palantir.atlasdb.keyvalue.dbkvs.impl.ConnectionManagerAwareDbKvs;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.InDbTimestampBoundStore;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.timestamp.TimestampBoundStore;\n+\n+public class DbKvsPostgresInvalidationRunnerTest {\n+    private final ConnectionManagerAwareDbKvs kvs = DbkvsPostgresTestSuite.createKvs();\n+    private final TimestampBoundStore store = getStore();\n+    private final InvalidationRunner invalidationRunner = new InvalidationRunner(kvs.getConnectionManager());\n+    private static final long TIMESTAMP_1 = 12000;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        kvs.dropTable(AtlasDbConstants.TIMELOCK_TIMESTAMP_TABLE);\n+        invalidationRunner.createTableIfDoesNotExist();\n+    }\n+\n+    public InDbTimestampBoundStore getStore() {\n+        return InDbTimestampBoundStore.create(\n+                kvs.getConnectionManager(),\n+                AtlasDbConstants.TIMELOCK_TIMESTAMP_TABLE,\n+                DbkvsPostgresTestSuite.getKvsConfig().ddl().tablePrefix());\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        kvs.close();\n+    }\n+\n+    @Test\n+    public void poisonsEmptyTableAndReturnsNoOpTs() {", "originalCommit": "e8e3e8874736f0a7662e7919eba515b6fba9af2d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE0NDU3NQ==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r498144575", "bodyText": "nit: static", "author": "jeremyk-91", "createdAt": "2020-10-01T10:32:37Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/InvalidationRunner.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.immutables.value.Value;\n+\n+import com.palantir.atlasdb.AtlasDbConstants;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.ConnectionDbTypes;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.InDbTimestampBoundStoreInitializer;\n+import com.palantir.atlasdb.spi.AtlasDbFactory;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.nexus.db.DBType;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+import com.palantir.nexus.db.pool.RetriableTransactions;\n+\n+public class InvalidationRunner {\n+    private static final String LAST_ALLOCATED = \"last_allocated\";\n+    private static final String LEGACY_LAST_ALLOCATED = \"legacy_last_allocated\";\n+\n+    private final ConnectionManager connManager;\n+    private final InDbTimestampBoundStoreInitializer helper;\n+\n+    public InvalidationRunner(ConnectionManager connManager) {\n+        this.connManager = connManager;\n+        this.helper = new InDbTimestampBoundStoreInitializer(connManager);\n+    }\n+\n+    public void createTableIfDoesNotExist() {\n+        helper.createTableIfDoesNotExist(prefixedTimestampTableName());\n+    }\n+\n+    public long getLastAllocatedTimestampAndPoisonInDbStore() {\n+        RetriableTransactions.TransactionResult<Long> result = RetriableTransactions.run(connManager,\n+                connection -> {\n+                    Limits limits = getLimits(connection);\n+                    TableStatus tableStatus = checkTableStatus(limits);\n+\n+                    if (tableStatus == TableStatus.POISONED) {\n+                        return limits.legacyUpperLimit().value();\n+                    }\n+\n+                    long lastAllocated;\n+                    if (tableStatus == TableStatus.NO_DATA) {\n+                        lastAllocated = AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+                    } else {\n+                        lastAllocated = limits.upperLimit().value();\n+                    }\n+\n+                    poisonTable(connection);\n+                    return lastAllocated;\n+                });\n+        switch (result.getStatus()) {\n+            case SUCCESSFUL:\n+                return result.getResultValue();\n+            case UNKNOWN:\n+            case FAILED:\n+                Throwable error = result.getError();\n+                if (error instanceof SQLException) {\n+                    throw PalantirSqlException.create((SQLException) error);\n+                }\n+                throw Throwables.rewrapAndThrowUncheckedException(error);\n+            default:\n+                throw new IllegalStateException(\"Unrecognized transaction status \" + result.getStatus());\n+        }\n+    }\n+\n+    private void poisonTable(Connection connection) throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            if (ConnectionDbTypes.getDbType(connection).equals(DBType.ORACLE)) {\n+                statement.execute(String.format(\"ALTER TABLE %s RENAME COLUMN last_allocated TO LEGACY_last_allocated\",\n+                        prefixedTimestampTableName()));\n+            } else {\n+                statement.execute(String.format(\"ALTER TABLE %s RENAME last_allocated TO LEGACY_last_allocated\",\n+                        prefixedTimestampTableName()));\n+            }\n+        }\n+    }\n+\n+    private Limits getLimits(Connection connection) throws SQLException {\n+        DatabaseMetaData metaData = connection.getMetaData();\n+        ResultSet res = metaData.getTables(null, null, prefixedTimestampTableName(), null);\n+\n+        Preconditions.checkState(res.next(), \"We are in the process of invalidating the \"\n+                + \"InDbTimestampBoundStore but the data table does not exist. \"\n+                + \"We should never reach here. Please contact support.\");\n+\n+        return ImmutableLimits.builder()\n+                .upperLimit(getColumnStatus(LAST_ALLOCATED, connection))\n+                .legacyUpperLimit(getColumnStatus(LEGACY_LAST_ALLOCATED, connection))\n+                .build();\n+    }\n+\n+    private ColumnStatus getColumnStatus(String colName, Connection connection) throws SQLException {\n+        if (hasColumn(connection, colName)) {\n+            String sql = String.format(\"SELECT %s FROM %s FOR UPDATE\", colName, prefixedTimestampTableName());\n+            QueryRunner run = new QueryRunner();\n+            return run.query(connection, sql, rs -> {\n+                if (rs.next()) {\n+                    return ColumnStatus.columnStatusWithValue(rs.getLong(colName));\n+                }\n+                return ColumnStatus.columnStatusWithoutValue();\n+            });\n+\n+        } else {\n+            return ColumnStatus.voidColumnStatus();\n+        }\n+    }\n+\n+    private boolean hasColumn(Connection connection, String colName) throws SQLException {\n+        return connection.getMetaData()\n+                .getColumns(null, null, prefixedTimestampTableName(), colName)\n+                .next();\n+    }\n+\n+    private String prefixedTimestampTableName() {", "originalCommit": "b5e77fa5b822a83c401bb9682e53cc5df4a261b8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE0NjU3Ng==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r498146576", "bodyText": "would suggest extracting a method for this part", "author": "jeremyk-91", "createdAt": "2020-10-01T10:36:37Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/InvalidationRunner.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.immutables.value.Value;\n+\n+import com.palantir.atlasdb.AtlasDbConstants;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.ConnectionDbTypes;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.InDbTimestampBoundStoreInitializer;\n+import com.palantir.atlasdb.spi.AtlasDbFactory;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.nexus.db.DBType;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+import com.palantir.nexus.db.pool.RetriableTransactions;\n+\n+public class InvalidationRunner {\n+    private static final String LAST_ALLOCATED = \"last_allocated\";\n+    private static final String LEGACY_LAST_ALLOCATED = \"legacy_last_allocated\";\n+\n+    private final ConnectionManager connManager;\n+    private final InDbTimestampBoundStoreInitializer helper;\n+\n+    public InvalidationRunner(ConnectionManager connManager) {\n+        this.connManager = connManager;\n+        this.helper = new InDbTimestampBoundStoreInitializer(connManager);\n+    }\n+\n+    public void createTableIfDoesNotExist() {\n+        helper.createTableIfDoesNotExist(prefixedTimestampTableName());\n+    }\n+\n+    public long getLastAllocatedTimestampAndPoisonInDbStore() {\n+        RetriableTransactions.TransactionResult<Long> result = RetriableTransactions.run(connManager,\n+                connection -> {\n+                    Limits limits = getLimits(connection);\n+                    TableStatus tableStatus = checkTableStatus(limits);\n+\n+                    if (tableStatus == TableStatus.POISONED) {\n+                        return limits.legacyUpperLimit().value();\n+                    }\n+\n+                    long lastAllocated;\n+                    if (tableStatus == TableStatus.NO_DATA) {\n+                        lastAllocated = AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+                    } else {\n+                        lastAllocated = limits.upperLimit().value();\n+                    }\n+\n+                    poisonTable(connection);\n+                    return lastAllocated;", "originalCommit": "b5e77fa5b822a83c401bb9682e53cc5df4a261b8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE0NzE4NQ==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r498147185", "bodyText": "nit: please use SafeIllegalStateException/an arg", "author": "jeremyk-91", "createdAt": "2020-10-01T10:37:50Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/InvalidationRunner.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.immutables.value.Value;\n+\n+import com.palantir.atlasdb.AtlasDbConstants;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.ConnectionDbTypes;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.InDbTimestampBoundStoreInitializer;\n+import com.palantir.atlasdb.spi.AtlasDbFactory;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.nexus.db.DBType;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+import com.palantir.nexus.db.pool.RetriableTransactions;\n+\n+public class InvalidationRunner {\n+    private static final String LAST_ALLOCATED = \"last_allocated\";\n+    private static final String LEGACY_LAST_ALLOCATED = \"legacy_last_allocated\";\n+\n+    private final ConnectionManager connManager;\n+    private final InDbTimestampBoundStoreInitializer helper;\n+\n+    public InvalidationRunner(ConnectionManager connManager) {\n+        this.connManager = connManager;\n+        this.helper = new InDbTimestampBoundStoreInitializer(connManager);\n+    }\n+\n+    public void createTableIfDoesNotExist() {\n+        helper.createTableIfDoesNotExist(prefixedTimestampTableName());\n+    }\n+\n+    public long getLastAllocatedTimestampAndPoisonInDbStore() {\n+        RetriableTransactions.TransactionResult<Long> result = RetriableTransactions.run(connManager,\n+                connection -> {\n+                    Limits limits = getLimits(connection);\n+                    TableStatus tableStatus = checkTableStatus(limits);\n+\n+                    if (tableStatus == TableStatus.POISONED) {\n+                        return limits.legacyUpperLimit().value();\n+                    }\n+\n+                    long lastAllocated;\n+                    if (tableStatus == TableStatus.NO_DATA) {\n+                        lastAllocated = AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+                    } else {\n+                        lastAllocated = limits.upperLimit().value();\n+                    }\n+\n+                    poisonTable(connection);\n+                    return lastAllocated;\n+                });\n+        switch (result.getStatus()) {\n+            case SUCCESSFUL:\n+                return result.getResultValue();\n+            case UNKNOWN:\n+            case FAILED:\n+                Throwable error = result.getError();\n+                if (error instanceof SQLException) {\n+                    throw PalantirSqlException.create((SQLException) error);\n+                }\n+                throw Throwables.rewrapAndThrowUncheckedException(error);\n+            default:\n+                throw new IllegalStateException(\"Unrecognized transaction status \" + result.getStatus());", "originalCommit": "b5e77fa5b822a83c401bb9682e53cc5df4a261b8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE0NzM5Mw==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r498147393", "bodyText": "nit: you have constants :)", "author": "jeremyk-91", "createdAt": "2020-10-01T10:38:13Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/InvalidationRunner.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.immutables.value.Value;\n+\n+import com.palantir.atlasdb.AtlasDbConstants;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.ConnectionDbTypes;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.InDbTimestampBoundStoreInitializer;\n+import com.palantir.atlasdb.spi.AtlasDbFactory;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.nexus.db.DBType;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+import com.palantir.nexus.db.pool.RetriableTransactions;\n+\n+public class InvalidationRunner {\n+    private static final String LAST_ALLOCATED = \"last_allocated\";\n+    private static final String LEGACY_LAST_ALLOCATED = \"legacy_last_allocated\";\n+\n+    private final ConnectionManager connManager;\n+    private final InDbTimestampBoundStoreInitializer helper;\n+\n+    public InvalidationRunner(ConnectionManager connManager) {\n+        this.connManager = connManager;\n+        this.helper = new InDbTimestampBoundStoreInitializer(connManager);\n+    }\n+\n+    public void createTableIfDoesNotExist() {\n+        helper.createTableIfDoesNotExist(prefixedTimestampTableName());\n+    }\n+\n+    public long getLastAllocatedTimestampAndPoisonInDbStore() {\n+        RetriableTransactions.TransactionResult<Long> result = RetriableTransactions.run(connManager,\n+                connection -> {\n+                    Limits limits = getLimits(connection);\n+                    TableStatus tableStatus = checkTableStatus(limits);\n+\n+                    if (tableStatus == TableStatus.POISONED) {\n+                        return limits.legacyUpperLimit().value();\n+                    }\n+\n+                    long lastAllocated;\n+                    if (tableStatus == TableStatus.NO_DATA) {\n+                        lastAllocated = AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+                    } else {\n+                        lastAllocated = limits.upperLimit().value();\n+                    }\n+\n+                    poisonTable(connection);\n+                    return lastAllocated;\n+                });\n+        switch (result.getStatus()) {\n+            case SUCCESSFUL:\n+                return result.getResultValue();\n+            case UNKNOWN:\n+            case FAILED:\n+                Throwable error = result.getError();\n+                if (error instanceof SQLException) {\n+                    throw PalantirSqlException.create((SQLException) error);\n+                }\n+                throw Throwables.rewrapAndThrowUncheckedException(error);\n+            default:\n+                throw new IllegalStateException(\"Unrecognized transaction status \" + result.getStatus());\n+        }\n+    }\n+\n+    private void poisonTable(Connection connection) throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            if (ConnectionDbTypes.getDbType(connection).equals(DBType.ORACLE)) {\n+                statement.execute(String.format(\"ALTER TABLE %s RENAME COLUMN last_allocated TO LEGACY_last_allocated\",", "originalCommit": "b5e77fa5b822a83c401bb9682e53cc5df4a261b8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE1MDQ0Mg==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r498150442", "bodyText": "I'd suggest having an OptionalLong for value here, and have users just use an Optional<ColumnStatus> rather than the null object pattern we're trying here", "author": "jeremyk-91", "createdAt": "2020-10-01T10:43:53Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/InvalidationRunner.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.immutables.value.Value;\n+\n+import com.palantir.atlasdb.AtlasDbConstants;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.ConnectionDbTypes;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.InDbTimestampBoundStoreInitializer;\n+import com.palantir.atlasdb.spi.AtlasDbFactory;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.nexus.db.DBType;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+import com.palantir.nexus.db.pool.RetriableTransactions;\n+\n+public class InvalidationRunner {\n+    private static final String LAST_ALLOCATED = \"last_allocated\";\n+    private static final String LEGACY_LAST_ALLOCATED = \"legacy_last_allocated\";\n+\n+    private final ConnectionManager connManager;\n+    private final InDbTimestampBoundStoreInitializer helper;\n+\n+    public InvalidationRunner(ConnectionManager connManager) {\n+        this.connManager = connManager;\n+        this.helper = new InDbTimestampBoundStoreInitializer(connManager);\n+    }\n+\n+    public void createTableIfDoesNotExist() {\n+        helper.createTableIfDoesNotExist(prefixedTimestampTableName());\n+    }\n+\n+    public long getLastAllocatedTimestampAndPoisonInDbStore() {\n+        RetriableTransactions.TransactionResult<Long> result = RetriableTransactions.run(connManager,\n+                connection -> {\n+                    Limits limits = getLimits(connection);\n+                    TableStatus tableStatus = checkTableStatus(limits);\n+\n+                    if (tableStatus == TableStatus.POISONED) {\n+                        return limits.legacyUpperLimit().value();\n+                    }\n+\n+                    long lastAllocated;\n+                    if (tableStatus == TableStatus.NO_DATA) {\n+                        lastAllocated = AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+                    } else {\n+                        lastAllocated = limits.upperLimit().value();\n+                    }\n+\n+                    poisonTable(connection);\n+                    return lastAllocated;\n+                });\n+        switch (result.getStatus()) {\n+            case SUCCESSFUL:\n+                return result.getResultValue();\n+            case UNKNOWN:\n+            case FAILED:\n+                Throwable error = result.getError();\n+                if (error instanceof SQLException) {\n+                    throw PalantirSqlException.create((SQLException) error);\n+                }\n+                throw Throwables.rewrapAndThrowUncheckedException(error);\n+            default:\n+                throw new IllegalStateException(\"Unrecognized transaction status \" + result.getStatus());\n+        }\n+    }\n+\n+    private void poisonTable(Connection connection) throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            if (ConnectionDbTypes.getDbType(connection).equals(DBType.ORACLE)) {\n+                statement.execute(String.format(\"ALTER TABLE %s RENAME COLUMN last_allocated TO LEGACY_last_allocated\",\n+                        prefixedTimestampTableName()));\n+            } else {\n+                statement.execute(String.format(\"ALTER TABLE %s RENAME last_allocated TO LEGACY_last_allocated\",\n+                        prefixedTimestampTableName()));\n+            }\n+        }\n+    }\n+\n+    private Limits getLimits(Connection connection) throws SQLException {\n+        DatabaseMetaData metaData = connection.getMetaData();\n+        ResultSet res = metaData.getTables(null, null, prefixedTimestampTableName(), null);\n+\n+        Preconditions.checkState(res.next(), \"We are in the process of invalidating the \"\n+                + \"InDbTimestampBoundStore but the data table does not exist. \"\n+                + \"We should never reach here. Please contact support.\");\n+\n+        return ImmutableLimits.builder()\n+                .upperLimit(getColumnStatus(LAST_ALLOCATED, connection))\n+                .legacyUpperLimit(getColumnStatus(LEGACY_LAST_ALLOCATED, connection))\n+                .build();\n+    }\n+\n+    private ColumnStatus getColumnStatus(String colName, Connection connection) throws SQLException {\n+        if (hasColumn(connection, colName)) {\n+            String sql = String.format(\"SELECT %s FROM %s FOR UPDATE\", colName, prefixedTimestampTableName());\n+            QueryRunner run = new QueryRunner();\n+            return run.query(connection, sql, rs -> {\n+                if (rs.next()) {\n+                    return ColumnStatus.columnStatusWithValue(rs.getLong(colName));\n+                }\n+                return ColumnStatus.columnStatusWithoutValue();\n+            });\n+\n+        } else {\n+            return ColumnStatus.voidColumnStatus();\n+        }\n+    }\n+\n+    private boolean hasColumn(Connection connection, String colName) throws SQLException {\n+        return connection.getMetaData()\n+                .getColumns(null, null, prefixedTimestampTableName(), colName)\n+                .next();\n+    }\n+\n+    private String prefixedTimestampTableName() {\n+        return AtlasDbConstants.TIMELOCK_TIMESTAMP_TABLE.getQualifiedName();\n+    }\n+\n+    private TableStatus checkTableStatus(Limits limits) {\n+        TableStatus status = getTableStatus(limits);\n+\n+        Preconditions.checkState(status != TableStatus.ILLEGAL_COLUMNS,\n+                \"We detected the table has both current as well as legacy columns.\"\n+                        + \"This is unexpected. Please contact support.\");\n+        return status;\n+    }\n+\n+    private TableStatus getTableStatus(Limits limits) {\n+        boolean upperLimitExists = limits.upperLimit().exists();\n+        boolean legacyUpperLimitExists = limits.legacyUpperLimit().exists();\n+\n+        if (upperLimitExists) {\n+            return legacyUpperLimitExists ? TableStatus.ILLEGAL_COLUMNS : TableStatus.HEALTHY;\n+        }\n+        return legacyUpperLimitExists ? TableStatus.POISONED : TableStatus.NO_DATA; // no data in table\n+    }\n+\n+    @Value.Immutable\n+    interface Limits {\n+        ColumnStatus upperLimit();\n+        ColumnStatus legacyUpperLimit();\n+    }\n+\n+    @Value.Immutable\n+    interface ColumnStatus {", "originalCommit": "b5e77fa5b822a83c401bb9682e53cc5df4a261b8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE1MDkxNg==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r498150916", "bodyText": "nit: the if above returns, so else here isn't needed.", "author": "jeremyk-91", "createdAt": "2020-10-01T10:44:57Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/InvalidationRunner.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.immutables.value.Value;\n+\n+import com.palantir.atlasdb.AtlasDbConstants;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.ConnectionDbTypes;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.InDbTimestampBoundStoreInitializer;\n+import com.palantir.atlasdb.spi.AtlasDbFactory;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.nexus.db.DBType;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+import com.palantir.nexus.db.pool.RetriableTransactions;\n+\n+public class InvalidationRunner {\n+    private static final String LAST_ALLOCATED = \"last_allocated\";\n+    private static final String LEGACY_LAST_ALLOCATED = \"legacy_last_allocated\";\n+\n+    private final ConnectionManager connManager;\n+    private final InDbTimestampBoundStoreInitializer helper;\n+\n+    public InvalidationRunner(ConnectionManager connManager) {\n+        this.connManager = connManager;\n+        this.helper = new InDbTimestampBoundStoreInitializer(connManager);\n+    }\n+\n+    public void createTableIfDoesNotExist() {\n+        helper.createTableIfDoesNotExist(prefixedTimestampTableName());\n+    }\n+\n+    public long getLastAllocatedTimestampAndPoisonInDbStore() {\n+        RetriableTransactions.TransactionResult<Long> result = RetriableTransactions.run(connManager,\n+                connection -> {\n+                    Limits limits = getLimits(connection);\n+                    TableStatus tableStatus = checkTableStatus(limits);\n+\n+                    if (tableStatus == TableStatus.POISONED) {\n+                        return limits.legacyUpperLimit().value();\n+                    }\n+\n+                    long lastAllocated;\n+                    if (tableStatus == TableStatus.NO_DATA) {\n+                        lastAllocated = AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+                    } else {\n+                        lastAllocated = limits.upperLimit().value();\n+                    }\n+\n+                    poisonTable(connection);\n+                    return lastAllocated;\n+                });\n+        switch (result.getStatus()) {\n+            case SUCCESSFUL:\n+                return result.getResultValue();\n+            case UNKNOWN:\n+            case FAILED:\n+                Throwable error = result.getError();\n+                if (error instanceof SQLException) {\n+                    throw PalantirSqlException.create((SQLException) error);\n+                }\n+                throw Throwables.rewrapAndThrowUncheckedException(error);\n+            default:\n+                throw new IllegalStateException(\"Unrecognized transaction status \" + result.getStatus());\n+        }\n+    }\n+\n+    private void poisonTable(Connection connection) throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            if (ConnectionDbTypes.getDbType(connection).equals(DBType.ORACLE)) {\n+                statement.execute(String.format(\"ALTER TABLE %s RENAME COLUMN last_allocated TO LEGACY_last_allocated\",\n+                        prefixedTimestampTableName()));\n+            } else {\n+                statement.execute(String.format(\"ALTER TABLE %s RENAME last_allocated TO LEGACY_last_allocated\",\n+                        prefixedTimestampTableName()));\n+            }\n+        }\n+    }\n+\n+    private Limits getLimits(Connection connection) throws SQLException {\n+        DatabaseMetaData metaData = connection.getMetaData();\n+        ResultSet res = metaData.getTables(null, null, prefixedTimestampTableName(), null);\n+\n+        Preconditions.checkState(res.next(), \"We are in the process of invalidating the \"\n+                + \"InDbTimestampBoundStore but the data table does not exist. \"\n+                + \"We should never reach here. Please contact support.\");\n+\n+        return ImmutableLimits.builder()\n+                .upperLimit(getColumnStatus(LAST_ALLOCATED, connection))\n+                .legacyUpperLimit(getColumnStatus(LEGACY_LAST_ALLOCATED, connection))\n+                .build();\n+    }\n+\n+    private ColumnStatus getColumnStatus(String colName, Connection connection) throws SQLException {\n+        if (hasColumn(connection, colName)) {\n+            String sql = String.format(\"SELECT %s FROM %s FOR UPDATE\", colName, prefixedTimestampTableName());\n+            QueryRunner run = new QueryRunner();\n+            return run.query(connection, sql, rs -> {\n+                if (rs.next()) {\n+                    return ColumnStatus.columnStatusWithValue(rs.getLong(colName));\n+                }\n+                return ColumnStatus.columnStatusWithoutValue();\n+            });\n+\n+        } else {\n+            return ColumnStatus.voidColumnStatus();", "originalCommit": "b5e77fa5b822a83c401bb9682e53cc5df4a261b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE1MTI4Ng==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r498151286", "bodyText": "in fact, it's probably nicer to have if(!hasColumn(...)) return ... and then the rest doesn't need to be in an if-block", "author": "jeremyk-91", "createdAt": "2020-10-01T10:45:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE1MDkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE1MTQyMQ==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r498151421", "bodyText": "nit: Might be worth clarifying what ILLEGAL_COLUMNS means", "author": "jeremyk-91", "createdAt": "2020-10-01T10:45:53Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/InvalidationRunner.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.immutables.value.Value;\n+\n+import com.palantir.atlasdb.AtlasDbConstants;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.ConnectionDbTypes;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.InDbTimestampBoundStoreInitializer;\n+import com.palantir.atlasdb.spi.AtlasDbFactory;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.nexus.db.DBType;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+import com.palantir.nexus.db.pool.RetriableTransactions;\n+\n+public class InvalidationRunner {\n+    private static final String LAST_ALLOCATED = \"last_allocated\";\n+    private static final String LEGACY_LAST_ALLOCATED = \"legacy_last_allocated\";\n+\n+    private final ConnectionManager connManager;\n+    private final InDbTimestampBoundStoreInitializer helper;\n+\n+    public InvalidationRunner(ConnectionManager connManager) {\n+        this.connManager = connManager;\n+        this.helper = new InDbTimestampBoundStoreInitializer(connManager);\n+    }\n+\n+    public void createTableIfDoesNotExist() {\n+        helper.createTableIfDoesNotExist(prefixedTimestampTableName());\n+    }\n+\n+    public long getLastAllocatedTimestampAndPoisonInDbStore() {\n+        RetriableTransactions.TransactionResult<Long> result = RetriableTransactions.run(connManager,\n+                connection -> {\n+                    Limits limits = getLimits(connection);\n+                    TableStatus tableStatus = checkTableStatus(limits);\n+\n+                    if (tableStatus == TableStatus.POISONED) {\n+                        return limits.legacyUpperLimit().value();\n+                    }\n+\n+                    long lastAllocated;\n+                    if (tableStatus == TableStatus.NO_DATA) {\n+                        lastAllocated = AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+                    } else {\n+                        lastAllocated = limits.upperLimit().value();\n+                    }\n+\n+                    poisonTable(connection);\n+                    return lastAllocated;\n+                });\n+        switch (result.getStatus()) {\n+            case SUCCESSFUL:\n+                return result.getResultValue();\n+            case UNKNOWN:\n+            case FAILED:\n+                Throwable error = result.getError();\n+                if (error instanceof SQLException) {\n+                    throw PalantirSqlException.create((SQLException) error);\n+                }\n+                throw Throwables.rewrapAndThrowUncheckedException(error);\n+            default:\n+                throw new IllegalStateException(\"Unrecognized transaction status \" + result.getStatus());\n+        }\n+    }\n+\n+    private void poisonTable(Connection connection) throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            if (ConnectionDbTypes.getDbType(connection).equals(DBType.ORACLE)) {\n+                statement.execute(String.format(\"ALTER TABLE %s RENAME COLUMN last_allocated TO LEGACY_last_allocated\",\n+                        prefixedTimestampTableName()));\n+            } else {\n+                statement.execute(String.format(\"ALTER TABLE %s RENAME last_allocated TO LEGACY_last_allocated\",\n+                        prefixedTimestampTableName()));\n+            }\n+        }\n+    }\n+\n+    private Limits getLimits(Connection connection) throws SQLException {\n+        DatabaseMetaData metaData = connection.getMetaData();\n+        ResultSet res = metaData.getTables(null, null, prefixedTimestampTableName(), null);\n+\n+        Preconditions.checkState(res.next(), \"We are in the process of invalidating the \"\n+                + \"InDbTimestampBoundStore but the data table does not exist. \"\n+                + \"We should never reach here. Please contact support.\");\n+\n+        return ImmutableLimits.builder()\n+                .upperLimit(getColumnStatus(LAST_ALLOCATED, connection))\n+                .legacyUpperLimit(getColumnStatus(LEGACY_LAST_ALLOCATED, connection))\n+                .build();\n+    }\n+\n+    private ColumnStatus getColumnStatus(String colName, Connection connection) throws SQLException {\n+        if (hasColumn(connection, colName)) {\n+            String sql = String.format(\"SELECT %s FROM %s FOR UPDATE\", colName, prefixedTimestampTableName());\n+            QueryRunner run = new QueryRunner();\n+            return run.query(connection, sql, rs -> {\n+                if (rs.next()) {\n+                    return ColumnStatus.columnStatusWithValue(rs.getLong(colName));\n+                }\n+                return ColumnStatus.columnStatusWithoutValue();\n+            });\n+\n+        } else {\n+            return ColumnStatus.voidColumnStatus();\n+        }\n+    }\n+\n+    private boolean hasColumn(Connection connection, String colName) throws SQLException {\n+        return connection.getMetaData()\n+                .getColumns(null, null, prefixedTimestampTableName(), colName)\n+                .next();\n+    }\n+\n+    private String prefixedTimestampTableName() {\n+        return AtlasDbConstants.TIMELOCK_TIMESTAMP_TABLE.getQualifiedName();\n+    }\n+\n+    private TableStatus checkTableStatus(Limits limits) {\n+        TableStatus status = getTableStatus(limits);\n+\n+        Preconditions.checkState(status != TableStatus.ILLEGAL_COLUMNS,\n+                \"We detected the table has both current as well as legacy columns.\"\n+                        + \"This is unexpected. Please contact support.\");\n+        return status;\n+    }\n+\n+    private TableStatus getTableStatus(Limits limits) {\n+        boolean upperLimitExists = limits.upperLimit().exists();\n+        boolean legacyUpperLimitExists = limits.legacyUpperLimit().exists();\n+\n+        if (upperLimitExists) {\n+            return legacyUpperLimitExists ? TableStatus.ILLEGAL_COLUMNS : TableStatus.HEALTHY;\n+        }\n+        return legacyUpperLimitExists ? TableStatus.POISONED : TableStatus.NO_DATA; // no data in table\n+    }\n+\n+    @Value.Immutable\n+    interface Limits {\n+        ColumnStatus upperLimit();\n+        ColumnStatus legacyUpperLimit();\n+    }\n+\n+    @Value.Immutable\n+    interface ColumnStatus {\n+        @Value.Default\n+        default Boolean exists() {\n+            return false;\n+        }\n+\n+        @Value.Default\n+        default long value() {\n+            return AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+        }\n+\n+        static ColumnStatus columnStatusWithValue(long value) {\n+            return ImmutableColumnStatus.builder().exists(true).value(value).build();\n+        }\n+\n+        static ColumnStatus columnStatusWithoutValue() {\n+            return ImmutableColumnStatus.builder().exists(true).build();\n+        }\n+\n+        static ColumnStatus voidColumnStatus() {\n+            return ImmutableColumnStatus.builder().build();\n+        }\n+    }\n+\n+    private enum TableStatus {\n+        NO_DATA,\n+        POISONED,\n+        HEALTHY,\n+        ILLEGAL_COLUMNS,", "originalCommit": "b5e77fa5b822a83c401bb9682e53cc5df4a261b8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxMDI2Ng==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r498410266", "bodyText": "nit: didn't mention this first time, but initializer is maybe more accurate?", "author": "jeremyk-91", "createdAt": "2020-10-01T17:36:20Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/InvalidationRunner.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Optional;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.immutables.value.Value;\n+\n+import com.palantir.atlasdb.AtlasDbConstants;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.BoundStoreUtils;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.ConnectionDbTypes;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.InDbTimestampBoundStoreInitializer;\n+import com.palantir.atlasdb.spi.AtlasDbFactory;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.exceptions.SafeIllegalStateException;\n+import com.palantir.nexus.db.DBType;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+import com.palantir.nexus.db.pool.RetriableTransactions;\n+\n+public class InvalidationRunner {\n+    private static final String LAST_ALLOCATED = \"last_allocated\";\n+    private static final String LEGACY_LAST_ALLOCATED = \"legacy_last_allocated\";\n+\n+    private final ConnectionManager connManager;\n+    private final InDbTimestampBoundStoreInitializer helper;\n+\n+    public InvalidationRunner(ConnectionManager connManager) {\n+        this.connManager = connManager;\n+        this.helper = new InDbTimestampBoundStoreInitializer(connManager);\n+    }\n+\n+    public void createTableIfDoesNotExist() {\n+        helper.createTableIfDoesNotExist(prefixedTimestampTableName());", "originalCommit": "091025420a282133a147ff2d04846841763afe7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxMDg2Ng==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r498410866", "bodyText": "nit: does this one need to be public? might have missed something but it feels like a private thing!", "author": "jeremyk-91", "createdAt": "2020-10-01T17:37:30Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/InvalidationRunner.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Optional;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.immutables.value.Value;\n+\n+import com.palantir.atlasdb.AtlasDbConstants;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.BoundStoreUtils;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.ConnectionDbTypes;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.InDbTimestampBoundStoreInitializer;\n+import com.palantir.atlasdb.spi.AtlasDbFactory;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.exceptions.SafeIllegalStateException;\n+import com.palantir.nexus.db.DBType;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+import com.palantir.nexus.db.pool.RetriableTransactions;\n+\n+public class InvalidationRunner {\n+    private static final String LAST_ALLOCATED = \"last_allocated\";\n+    private static final String LEGACY_LAST_ALLOCATED = \"legacy_last_allocated\";\n+\n+    private final ConnectionManager connManager;\n+    private final InDbTimestampBoundStoreInitializer helper;\n+\n+    public InvalidationRunner(ConnectionManager connManager) {\n+        this.connManager = connManager;\n+        this.helper = new InDbTimestampBoundStoreInitializer(connManager);\n+    }\n+\n+    public void createTableIfDoesNotExist() {\n+        helper.createTableIfDoesNotExist(prefixedTimestampTableName());\n+    }\n+\n+    public long ensureInDbStoreIsPoisonedAndGetLastAllocatedTimestamp() {\n+        RetriableTransactions.TransactionResult<Long> result = RetriableTransactions.run(connManager,\n+                connection -> {\n+                    Limits limits = getLimits(connection);\n+                    TableStatus tableStatus = checkTableStatus(limits);\n+\n+                    if (tableStatus == TableStatus.POISONED) {\n+                        return limits.legacyUpperLimit().get().value();\n+                    }\n+                    return poisonStoreAndGetLastAllocatedTimestamp(connection, limits, tableStatus);\n+                });\n+\n+        switch (result.getStatus()) {\n+            case SUCCESSFUL:\n+                return result.getResultValue();\n+            case UNKNOWN:\n+            case FAILED:\n+                Throwable error = result.getError();\n+                if (error instanceof SQLException) {\n+                    throw PalantirSqlException.create((SQLException) error);\n+                }\n+                throw Throwables.rewrapAndThrowUncheckedException(error);\n+            default:\n+                throw new SafeIllegalStateException(\"Unrecognized transaction status.\",\n+                        SafeArg.of(\"status\", result.getStatus()));\n+        }\n+    }\n+\n+    public Long poisonStoreAndGetLastAllocatedTimestamp(Connection connection, Limits limits,", "originalCommit": "091025420a282133a147ff2d04846841763afe7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxMjE4Nw==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r498412187", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public BoundStoreUtils() {\n          \n          \n            \n                private BoundStoreUtils() {\n          \n      \n    \n    \n  \n\n\ud83d\ude05", "author": "jeremyk-91", "createdAt": "2020-10-01T17:39:50Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/timestamp/BoundStoreUtils.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs.timestamp;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+public class BoundStoreUtils {\n+\n+    public BoundStoreUtils() {", "originalCommit": "091025420a282133a147ff2d04846841763afe7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxMjM0OA==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r498412348", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class BoundStoreUtils {\n          \n          \n            \n            public final class BoundStoreUtils {\n          \n      \n    \n    \n  \n\nsince there's no point extending this", "author": "jeremyk-91", "createdAt": "2020-10-01T17:40:03Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/timestamp/BoundStoreUtils.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs.timestamp;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+public class BoundStoreUtils {", "originalCommit": "091025420a282133a147ff2d04846841763afe7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxMjYzNA==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r498412634", "bodyText": "Ah! This is a nice touch. I did not think of this...", "author": "jeremyk-91", "createdAt": "2020-10-01T17:40:35Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/timestamp/InDbTimestampBoundStore.java", "diffHunk": "@@ -182,6 +170,10 @@ public synchronized void storeUpperLimit(final long limit) {\n     }\n \n     private Long readLimit(Connection connection) throws SQLException {\n+        if (!BoundStoreUtils.hasColumn(connection, prefixedTimestampTableName(), \"last_allocated\")) {\n+            throw new SafeIllegalStateException(\"The store will not service requests as it had been poisoned during\"", "originalCommit": "091025420a282133a147ff2d04846841763afe7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxMzE5NA==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r498413194", "bodyText": "Good coverage \ud83d\udc4d", "author": "jeremyk-91", "createdAt": "2020-10-01T17:41:43Z", "path": "atlasdb-dbkvs-tests/src/test/java/com/palantir/atlasdb/keyvalue/dbkvs/DbKvsPostgresInvalidationRunnerTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import static com.palantir.atlasdb.spi.AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+import com.palantir.atlasdb.AtlasDbConstants;\n+import com.palantir.atlasdb.keyvalue.dbkvs.impl.ConnectionManagerAwareDbKvs;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.InDbTimestampBoundStore;\n+import com.palantir.atlasdb.keyvalue.impl.TestResourceManager;\n+import com.palantir.logsafe.exceptions.SafeIllegalStateException;\n+import com.palantir.timestamp.TimestampBoundStore;\n+\n+public class DbKvsPostgresInvalidationRunnerTest {", "originalCommit": "091025420a282133a147ff2d04846841763afe7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "61daed52dd448a570c48bfd221b30738b72fc9ec", "url": "https://github.com/palantir/atlasdb/commit/61daed52dd448a570c48bfd221b30738b72fc9ec", "message": "Invalidate DB Kvs store", "committedDate": "2020-10-01T18:19:45Z", "type": "commit"}, {"oid": "685d72ed411512aa6e2d5c3cb404ec23903980be", "url": "https://github.com/palantir/atlasdb/commit/685d72ed411512aa6e2d5c3cb404ec23903980be", "message": "Test", "committedDate": "2020-10-01T18:19:45Z", "type": "commit"}, {"oid": "426a4918b84644e6c17905b13ecf5b2a25415730", "url": "https://github.com/palantir/atlasdb/commit/426a4918b84644e6c17905b13ecf5b2a25415730", "message": "Checkstyle", "committedDate": "2020-10-01T18:19:45Z", "type": "commit"}, {"oid": "8ab7fc83ac5eaf126e9a6b1164ddc753f8c6c01c", "url": "https://github.com/palantir/atlasdb/commit/8ab7fc83ac5eaf126e9a6b1164ddc753f8c6c01c", "message": "Minor", "committedDate": "2020-10-01T18:19:45Z", "type": "commit"}, {"oid": "f19a952c1fc74606e1b0c48c5004804687e51032", "url": "https://github.com/palantir/atlasdb/commit/f19a952c1fc74606e1b0c48c5004804687e51032", "message": "Add generated changelog entries", "committedDate": "2020-10-01T18:19:45Z", "type": "commit"}, {"oid": "fe38b6889cedf24bc56b6e054b9da525d32f92c0", "url": "https://github.com/palantir/atlasdb/commit/fe38b6889cedf24bc56b6e054b9da525d32f92c0", "message": "Refactor + Address comments", "committedDate": "2020-10-01T18:20:33Z", "type": "commit"}, {"oid": "db05031c9cda531130c1ccaf65129dcc976aa0bd", "url": "https://github.com/palantir/atlasdb/commit/db05031c9cda531130c1ccaf65129dcc976aa0bd", "message": "Address comments - 1", "committedDate": "2020-10-01T18:20:33Z", "type": "commit"}, {"oid": "c526d477d409e310ee850e597b356f4658a25230", "url": "https://github.com/palantir/atlasdb/commit/c526d477d409e310ee850e597b356f4658a25230", "message": "Refactor", "committedDate": "2020-10-01T18:20:33Z", "type": "commit"}, {"oid": "2198ed6fe347f18ee718a089a6af0b59a65b7b10", "url": "https://github.com/palantir/atlasdb/commit/2198ed6fe347f18ee718a089a6af0b59a65b7b10", "message": "Refactor", "committedDate": "2020-10-01T18:20:33Z", "type": "commit"}, {"oid": "88aece214077b7e181ad7542bb0dc4c3732e0fdf", "url": "https://github.com/palantir/atlasdb/commit/88aece214077b7e181ad7542bb0dc4c3732e0fdf", "message": "Fail fast", "committedDate": "2020-10-01T18:21:06Z", "type": "commit"}, {"oid": "8b40b4dc645bc26fea3766a0fa27ae11b66a7593", "url": "https://github.com/palantir/atlasdb/commit/8b40b4dc645bc26fea3766a0fa27ae11b66a7593", "message": "Rebase", "committedDate": "2020-10-01T19:07:21Z", "type": "commit"}, {"oid": "8b40b4dc645bc26fea3766a0fa27ae11b66a7593", "url": "https://github.com/palantir/atlasdb/commit/8b40b4dc645bc26fea3766a0fa27ae11b66a7593", "message": "Rebase", "committedDate": "2020-10-01T19:07:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ3Njg0MA==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r498476840", "bodyText": "nit: missing line?", "author": "jeremyk-91", "createdAt": "2020-10-01T19:47:25Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/DbTimestampStoreInvalidator.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import com.palantir.atlasdb.keyvalue.api.KeyValueService;\n+import com.palantir.atlasdb.keyvalue.api.TableReference;\n+import com.palantir.atlasdb.keyvalue.dbkvs.impl.ConnectionManagerAwareDbKvs;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.timestamp.TimestampStoreInvalidator;\n+\n+public class DbTimestampStoreInvalidator implements TimestampStoreInvalidator {\n+    private final InvalidationRunner invalidationRunner;\n+\n+    public DbTimestampStoreInvalidator(ConnectionManagerAwareDbKvs kvs,\n+            TableReference timestampTable,\n+            String tablePrefixString) {\n+        this.invalidationRunner = new InvalidationRunner(kvs.getConnectionManager(), timestampTable, tablePrefixString);\n+    }\n+\n+    public static TimestampStoreInvalidator create(KeyValueService kvs,\n+            TableReference timestampTable,\n+            String tablePrefixString) {\n+        Preconditions.checkArgument(kvs instanceof ConnectionManagerAwareDbKvs,\n+                \"DbTimestampStoreInvalidator should be instantiated with a ConnectionManagerAwareDbKvs!\");\n+        return new DbTimestampStoreInvalidator((ConnectionManagerAwareDbKvs) kvs, timestampTable, tablePrefixString);\n+    }\n+\n+    @Override\n+    public long backupAndInvalidate() {\n+        invalidationRunner.createTableIfDoesNotExist();\n+        return invalidationRunner.ensureInDbStoreIsPoisonedAndGetLastAllocatedTimestamp();\n+    }\n+}", "originalCommit": "8b40b4dc645bc26fea3766a0fa27ae11b66a7593", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ3NzQzNw==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r498477437", "bodyText": "as above: missing line", "author": "jeremyk-91", "createdAt": "2020-10-01T19:48:42Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/timestamp/CreateTimestampTableQueries.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs.timestamp;\n+\n+import org.immutables.value.Value;\n+\n+@Value.Immutable\n+public interface CreateTimestampTableQueries {\n+    String postgresQuery();\n+    String oracleQuery();\n+\n+    static CreateTimestampTableQueries getCreateTableQueriesForLegacyStore(String prefixedTimestampTableName) {\n+        return ImmutableCreateTimestampTableQueries.builder()\n+                .postgresQuery(String.format(\"CREATE TABLE IF NOT EXISTS %s ( last_allocated int8 NOT NULL )\",\n+                        prefixedTimestampTableName))\n+                .oracleQuery(String.format(\"CREATE TABLE %s ( last_allocated NUMBER(38) NOT NULL )\",\n+                        prefixedTimestampTableName))\n+                .build();\n+    }\n+}", "originalCommit": "8b40b4dc645bc26fea3766a0fa27ae11b66a7593", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ3NzY4Ng==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r498477686", "bodyText": "nit: ?", "author": "jeremyk-91", "createdAt": "2020-10-01T19:49:12Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/timestamp/InDbTimestampBoundStore.java", "diffHunk": "@@ -34,6 +34,7 @@\n import com.palantir.timestamp.MultipleRunningTimestampServiceError;\n import com.palantir.timestamp.TimestampBoundStore;\n \n+", "originalCommit": "8b40b4dc645bc26fea3766a0fa27ae11b66a7593", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ3ODE1OQ==", "url": "https://github.com/palantir/atlasdb/pull/5010#discussion_r498478159", "bodyText": "nit: I'd put these above the interfaces/enums here; typically inner classes come at the end of the file.", "author": "jeremyk-91", "createdAt": "2020-10-01T19:50:11Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/InvalidationRunner.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Optional;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.immutables.value.Value;\n+\n+import com.palantir.atlasdb.keyvalue.api.TableReference;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.ConnectionDbTypes;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.CreateTimestampTableQueries;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.PhysicalBoundStoreDatabaseUtils;\n+import com.palantir.atlasdb.spi.AtlasDbFactory;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.exceptions.SafeIllegalStateException;\n+import com.palantir.nexus.db.DBType;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+import com.palantir.nexus.db.pool.RetriableTransactions;\n+\n+public class InvalidationRunner {\n+    private static final String LAST_ALLOCATED = \"last_allocated\";\n+    private static final String LEGACY_LAST_ALLOCATED = \"legacy_last_allocated\";\n+\n+    private final ConnectionManager connManager;\n+    private final TableReference timestampTable;\n+    private final String tablePrefix;\n+\n+    public InvalidationRunner(ConnectionManager connManager, TableReference timestampTable, String tablePrefixString) {\n+        this.connManager = connManager;\n+        this.timestampTable = timestampTable;\n+        this.tablePrefix = tablePrefixString;\n+    }\n+\n+    public void createTableIfDoesNotExist() {\n+        try (Connection conn = connManager.getConnection()) {\n+            createTimestampTable(conn);\n+        } catch (SQLException error) {\n+            throw PalantirSqlException.create(error);\n+        }\n+    }\n+\n+    public void createTimestampTable(Connection conn) throws SQLException {\n+        PhysicalBoundStoreDatabaseUtils.createTimestampTable(\n+                conn,\n+                ConnectionDbTypes::getDbType,\n+                CreateTimestampTableQueries.getCreateTableQueriesForLegacyStore(prefixedTimestampTableName()));\n+    }\n+\n+    public long ensureInDbStoreIsPoisonedAndGetLastAllocatedTimestamp() {\n+        RetriableTransactions.TransactionResult<Long> result = RetriableTransactions.run(connManager,\n+                connection -> {\n+                    Limits limits = getLimits(connection);\n+                    TableStatus tableStatus = checkTableStatus(limits);\n+\n+                    if (tableStatus == TableStatus.POISONED) {\n+                        return limits.legacyUpperLimit().get().value();\n+                    }\n+                    return poisonStoreAndGetLastAllocatedTimestamp(connection, limits, tableStatus);\n+                });\n+\n+        switch (result.getStatus()) {\n+            case SUCCESSFUL:\n+                return result.getResultValue();\n+            case UNKNOWN:\n+            case FAILED:\n+                Throwable error = result.getError();\n+                if (error instanceof SQLException) {\n+                    throw PalantirSqlException.create((SQLException) error);\n+                }\n+                throw Throwables.rewrapAndThrowUncheckedException(error);\n+            default:\n+                throw new SafeIllegalStateException(\"Unrecognized transaction status.\",\n+                        SafeArg.of(\"status\", result.getStatus()));\n+        }\n+    }\n+\n+    private Long poisonStoreAndGetLastAllocatedTimestamp(Connection connection, Limits limits,\n+            TableStatus tableStatus) throws SQLException {\n+\n+        long lastAllocated;\n+        if (tableStatus == TableStatus.NO_DATA) {\n+            lastAllocated = AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+        } else {\n+            lastAllocated = limits.upperLimit().get().value();\n+        }\n+        poisonTable(connection);\n+        return lastAllocated;\n+    }\n+\n+    private void poisonTable(Connection connection) throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            if (ConnectionDbTypes.getDbType(connection).equals(DBType.ORACLE)) {\n+                statement.execute(String.format(\"ALTER TABLE %s RENAME COLUMN %s TO %s\",\n+                        prefixedTimestampTableName(), LAST_ALLOCATED, LEGACY_LAST_ALLOCATED));\n+            } else {\n+                statement.execute(String.format(\"ALTER TABLE %s RENAME %s TO %s\",\n+                        prefixedTimestampTableName(), LAST_ALLOCATED, LEGACY_LAST_ALLOCATED));\n+            }\n+        }\n+    }\n+\n+    private Limits getLimits(Connection connection) throws SQLException {\n+        DatabaseMetaData metaData = connection.getMetaData();\n+        ResultSet res = metaData.getTables(null, null, prefixedTimestampTableName(), null);\n+\n+        Preconditions.checkState(res.next(), \"We are in the process of invalidating the \"\n+                + \"InDbTimestampBoundStore but the data table does not exist. \"\n+                + \"We should never reach here. Please contact support.\");\n+\n+        return ImmutableLimits.builder()\n+                .upperLimit(getColumnStatus(LAST_ALLOCATED, connection))\n+                .legacyUpperLimit(getColumnStatus(LEGACY_LAST_ALLOCATED, connection))\n+                .build();\n+    }\n+\n+    private Optional<ColumnStatus> getColumnStatus(String colName, Connection connection) throws SQLException {\n+        if (!PhysicalBoundStoreDatabaseUtils.hasColumn(connection, prefixedTimestampTableName(), colName)) {\n+            return Optional.empty();\n+        }\n+\n+        String sql = String.format(\"SELECT %s FROM %s FOR UPDATE\", colName, prefixedTimestampTableName());\n+        QueryRunner run = new QueryRunner();\n+        return run.query(connection, sql, rs -> {\n+            if (rs.next()) {\n+                return ColumnStatus.columnStatusWithValue(rs.getLong(colName));\n+            }\n+            return ColumnStatus.columnStatusWithoutValue();\n+        });\n+    }\n+\n+    private TableStatus checkTableStatus(Limits limits) {\n+        TableStatus status = getTableStatus(limits);\n+\n+        Preconditions.checkState(status != TableStatus.BOTH_COLUMNS,\n+                \"We detected the table has been poisoned but last_allocated column still exists.\"\n+                        + \"This is unexpected. Please contact support.\");\n+        return status;\n+    }\n+\n+    private TableStatus getTableStatus(Limits limits) {\n+        boolean upperLimitExists = limits.upperLimit().isPresent();\n+        boolean legacyUpperLimitExists = limits.legacyUpperLimit().isPresent();\n+\n+        if (upperLimitExists) {\n+            return legacyUpperLimitExists ? TableStatus.BOTH_COLUMNS : TableStatus.HEALTHY;\n+        }\n+        return legacyUpperLimitExists ? TableStatus.POISONED : TableStatus.NO_DATA; // no data in table\n+    }\n+\n+    @Value.Immutable\n+    interface Limits {\n+        Optional<ColumnStatus> upperLimit();\n+        Optional<ColumnStatus> legacyUpperLimit();\n+    }\n+\n+    @Value.Immutable\n+    interface ColumnStatus {\n+        @Value.Default\n+        default long value() {\n+            return AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+        }\n+\n+        static Optional<ColumnStatus> columnStatusWithValue(long value) {\n+            return Optional.of(ImmutableColumnStatus.builder().value(value).build());\n+        }\n+\n+        static Optional<ColumnStatus> columnStatusWithoutValue() {\n+            return Optional.of(ImmutableColumnStatus.builder().build());\n+        }\n+    }\n+\n+    private String prefixedTimestampTableName() {\n+        return tablePrefix + timestampTable.getQualifiedName();\n+    }", "originalCommit": "8b40b4dc645bc26fea3766a0fa27ae11b66a7593", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4fb213d174c683827bb07eb78f7efbdf65ce2a5a", "url": "https://github.com/palantir/atlasdb/commit/4fb213d174c683827bb07eb78f7efbdf65ce2a5a", "message": "Clean up", "committedDate": "2020-10-01T19:52:46Z", "type": "commit"}, {"oid": "8de96706a87f72a64e1c47b1ec0308d08b9601ed", "url": "https://github.com/palantir/atlasdb/commit/8de96706a87f72a64e1c47b1ec0308d08b9601ed", "message": "Add generated changelog entries", "committedDate": "2020-10-01T19:52:46Z", "type": "commit"}]}