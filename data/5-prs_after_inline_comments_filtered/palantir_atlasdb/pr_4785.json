{"pr_number": 4785, "pr_title": "[PaxosStateLog] Implement locking for SqlitePSL", "pr_createdAt": "2020-05-18T13:38:48Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4785", "timeline": [{"oid": "afd6e832ab908fb148ff21dea957a7b7ce7a2469", "url": "https://github.com/palantir/atlasdb/commit/afd6e832ab908fb148ff21dea957a7b7ce7a2469", "message": "Implement locking for SqlitePSL", "committedDate": "2020-05-18T13:36:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5ODg4MA==", "url": "https://github.com/palantir/atlasdb/pull/4785#discussion_r426698880", "bodyText": "\u2b50", "author": "jeremyk-91", "createdAt": "2020-05-18T15:11:36Z", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "diffHunk": "@@ -38,60 +40,95 @@\n     private final Client namespace;\n     private final String useCase;\n     private final Jdbi jdbi;\n+    private final ReadWriteLock sharedLock;\n \n-    private SqlitePaxosStateLog(NamespaceAndUseCase namespaceAndUseCase, Jdbi jdbi) {\n+    private SqlitePaxosStateLog(NamespaceAndUseCase namespaceAndUseCase, Jdbi jdbi, ReadWriteLock sharedLock) {\n         this.namespace = namespaceAndUseCase.namespace();\n         this.useCase = namespaceAndUseCase.useCase();\n         this.jdbi = jdbi;\n+        this.sharedLock = sharedLock;\n     }\n \n-    public static <V extends Persistable & Versionable> PaxosStateLog<V> create(NamespaceAndUseCase namespaceAndUseCase,\n-            Supplier<Connection> connectionSupplier) {\n+    private static <V extends Persistable & Versionable> PaxosStateLog<V> create(\n+            NamespaceAndUseCase namespaceAndUseCase,\n+            Supplier<Connection> connectionSupplier, ReadWriteLock sharedLock) {\n         Jdbi jdbi = Jdbi.create(connectionSupplier::get).installPlugin(new SqlObjectPlugin());\n         jdbi.getConfig(JdbiImmutables.class).registerImmutable(Client.class, PaxosRound.class);\n-        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(namespaceAndUseCase, jdbi);\n+        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(namespaceAndUseCase, jdbi, sharedLock);\n         log.initialize();\n         return log;\n     }\n \n+    public static SqlitePaxosStateLogFactory createFactory() {\n+        return new SqlitePaxosStateLogFactory();\n+    }\n+\n     private void initialize() {\n-        execute(Queries::createTable);\n+        executeWrite(Queries::createTable);\n     }\n \n     @Override\n     public void writeRound(long seq, V round) {\n-        execute(dao -> dao.writeRound(namespace, useCase, seq, round.persistToBytes()));\n+        executeWrite(dao -> dao.writeRound(namespace, useCase, seq, round.persistToBytes()));\n     }\n \n     @Override\n     public void writeBatchOfRounds(Iterable<PaxosRound<V>> rounds) {\n-        execute(dao -> dao.writeBatchOfRounds(namespace, useCase, rounds));\n+        executeWrite(dao -> dao.writeBatchOfRounds(namespace, useCase, rounds));\n     }\n \n     @Override\n     public byte[] readRound(long seq) {\n-        return execute(dao -> dao.readRound(namespace, useCase, seq));\n+        return executeRead(dao -> dao.readRound(namespace, useCase, seq));\n     }\n \n     @Override\n     public long getLeastLogEntry() {\n-        return execute(dao -> dao.getLeastLogEntry(namespace, useCase)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n+        return executeRead(dao -> dao.getLeastLogEntry(namespace, useCase)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n     }\n \n     @Override\n     public long getGreatestLogEntry() {\n-        return execute(dao -> dao.getGreatestLogEntry(namespace, useCase)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n+        return executeRead(dao -> dao.getGreatestLogEntry(namespace, useCase)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n     }\n \n     @Override\n     public void truncate(long toDeleteInclusive) {\n-        execute(dao -> dao.truncate(namespace, useCase, toDeleteInclusive));\n+        executeWrite(dao -> dao.truncate(namespace, useCase, toDeleteInclusive));\n+    }\n+\n+    private <T> T executeWrite(Function<Queries, T> call) {\n+        sharedLock.writeLock().lock();\n+        try {\n+            return execute(call);\n+        } finally {\n+            sharedLock.writeLock().unlock();\n+        }\n+    }\n+\n+    private <T> T executeRead(Function<Queries, T> call) {\n+        sharedLock.readLock().lock();\n+        try {\n+            return execute(call);\n+        } finally {\n+            sharedLock.readLock().unlock();\n+        }\n     }", "originalCommit": "afd6e832ab908fb148ff21dea957a7b7ce7a2469", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwMTk3Ng==", "url": "https://github.com/palantir/atlasdb/pull/4785#discussion_r426701976", "bodyText": "This is kind of unpleasant but I didn't find a better way to write it", "author": "jeremyk-91", "createdAt": "2020-05-18T15:15:53Z", "path": "leader-election-impl/src/test/java/com/palantir/paxos/SqlitePaxosStateLogTest.java", "diffHunk": "@@ -179,14 +186,27 @@ public void valuesAreDistinguishedAcrossSequenceIdentifiers() throws IOException\n \n     @Test\n     public void differentLogsToTheSameNamespaceShareState() throws IOException {\n-        PaxosStateLog<PaxosValue> otherLogWithSameNamespace\n-                = SqlitePaxosStateLog.create(wrap(CLIENT_1, USE_CASE_1), connSupplier);\n+        PaxosStateLog<PaxosValue> otherLogWithSameNamespace = FACTORY.create(wrap(CLIENT_1, USE_CASE_1), conn);\n         writeValueForRound(1L);\n \n         assertThat(stateLog.readRound(1L)).isNotNull();\n         assertThat(otherLogWithSameNamespace.readRound(1L)).isEqualTo(stateLog.readRound(1L));\n     }\n \n+    @Test\n+    public void highConcurrencyDoesNotTimeoutWithSharedLock() {\n+        int numThreads = 100;\n+        ExecutorService executor = PTExecutors.newFixedThreadPool(numThreads);\n+        List<Future<?>> futures = IntStream.range(0, numThreads)\n+                .mapToObj(ignore -> executor.submit(() -> {\n+                    PaxosStateLog<PaxosValue> log = FACTORY.create(wrap(CLIENT_1, USE_CASE_1), conn);\n+                    for (int i = 0; i < 30; i++) {\n+                        log.writeRound(i, valueForRound(i));\n+                    }\n+                })).collect(Collectors.toList());\n+        futures.forEach(future -> assertThatCode(() -> Futures.getUnchecked(future)).doesNotThrowAnyException());", "originalCommit": "afd6e832ab908fb148ff21dea957a7b7ce7a2469", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}