{"pr_number": 4623, "pr_title": "[Timelock Partitioning] Part 52: ManualBatchingLeaderPinger", "pr_createdAt": "2020-03-02T16:26:45Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4623", "timeline": [{"oid": "4a3c757c223158ec55d6cad637d0b2a9c86ad615", "url": "https://github.com/palantir/atlasdb/commit/4a3c757c223158ec55d6cad637d0b2a9c86ad615", "message": "Put exceptions in the correct place for logs.", "committedDate": "2020-03-02T11:55:08Z", "type": "commit"}, {"oid": "281395819e2d5838a029d04a7ef0b75ca5f90816", "url": "https://github.com/palantir/atlasdb/commit/281395819e2d5838a029d04a7ef0b75ca5f90816", "message": "Don't spin up a new thread just so we can have timeouts.", "committedDate": "2020-03-02T11:55:09Z", "type": "commit"}, {"oid": "90465fa78104678c80d2d9176d3f4af9061c1005", "url": "https://github.com/palantir/atlasdb/commit/90465fa78104678c80d2d9176d3f4af9061c1005", "message": "Try bounded leader pinger.", "committedDate": "2020-03-02T11:55:38Z", "type": "commit"}, {"oid": "653ce0cbb504272b5ae53ac35f1bf77ba13a3f8f", "url": "https://github.com/palantir/atlasdb/commit/653ce0cbb504272b5ae53ac35f1bf77ba13a3f8f", "message": "Actually wire in the ping rate.", "committedDate": "2020-03-02T11:55:39Z", "type": "commit"}, {"oid": "7f4eb5ace6b34c1b3d57f3b6ec9f55508cf6cad0", "url": "https://github.com/palantir/atlasdb/commit/7f4eb5ace6b34c1b3d57f3b6ec9f55508cf6cad0", "message": "Log when the pinger itself times out, and also make sure the timeout logic is correct.", "committedDate": "2020-03-02T11:55:39Z", "type": "commit"}, {"oid": "0ad45f6fa29a4ba1954baf05e54a32a4105554ba", "url": "https://github.com/palantir/atlasdb/commit/0ad45f6fa29a4ba1954baf05e54a32a4105554ba", "message": "Update comments and log lines.", "committedDate": "2020-03-02T15:18:21Z", "type": "commit"}, {"oid": "fbe2f35dc6b93dc6d38f85c48016107b397071d3", "url": "https://github.com/palantir/atlasdb/commit/fbe2f35dc6b93dc6d38f85c48016107b397071d3", "message": "Remove tag from testing.", "committedDate": "2020-03-02T16:12:19Z", "type": "commit"}, {"oid": "7f0f5e760a824e320d2cc346a65ff498b806f78d", "url": "https://github.com/palantir/atlasdb/commit/7f0f5e760a824e320d2cc346a65ff498b806f78d", "message": "Add tests for ManualBatchingPingableLeader", "committedDate": "2020-03-02T16:12:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUxNTQ4MA==", "url": "https://github.com/palantir/atlasdb/pull/4623#discussion_r386515480", "bodyText": "nit: you repeated not in this sentence: to check whether or not the remote client is the leader or not", "author": "Jolyon-S", "createdAt": "2020-03-02T16:50:08Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/paxos/ManualBatchingPingableLeader.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.Histogram;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Maps;\n+import com.google.common.net.HostAndPort;\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.common.util.concurrent.FluentFuture;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.SettableFuture;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.paxos.LeaderPingResult;\n+import com.palantir.paxos.LeaderPingResults;\n+import com.palantir.paxos.LeaderPingerContext;\n+import com.palantir.tritium.metrics.registry.MetricName;\n+import com.palantir.tritium.metrics.registry.SharedTaggedMetricRegistries;\n+\n+final class ManualBatchingPingableLeader extends AbstractScheduledService implements ClientAwarePingableLeader {\n+\n+    private static final Logger log = LoggerFactory.getLogger(ManualBatchingPingableLeader.class);\n+\n+    private final LeaderPingerContext<BatchPingableLeader> remoteClient;\n+    private final Duration leaderPingRate;\n+    private final Duration leaderPingResponseWait;\n+    private final UUID nodeUuid;\n+\n+    private final Map<Client, SettableFuture<Void>> hasProcessedFirstRequest = Maps.newConcurrentMap();\n+    private final AtomicReference<LastResult> lastResult = new AtomicReference<>();\n+    private final Histogram histogram;\n+\n+    ManualBatchingPingableLeader(\n+            LeaderPingerContext<BatchPingableLeader> remoteClient,\n+            Duration leaderPingRate,\n+            Duration leaderPingResponseWait,\n+            UUID nodeUuid) {\n+        this.remoteClient = remoteClient;\n+        this.leaderPingRate = leaderPingRate;\n+        this.leaderPingResponseWait = leaderPingResponseWait;\n+        this.nodeUuid = nodeUuid;\n+\n+        // for comparison to the previous autobatching version, can easily remove later\n+        MetricName metricName = MetricName.builder()\n+                .safeName(\"atlasdb.autobatcherMeter\")\n+                .putSafeTags(\"identifier\", \"batch-pingable-leader.ping\")\n+                .putSafeTags(\"remoteHostAndPort\", remoteClient.hostAndPort().toString())\n+                .build();\n+        this.histogram = SharedTaggedMetricRegistries.getSingleton().histogram(metricName);\n+    }\n+\n+    @Override\n+    public Future<LeaderPingResult> ping(UUID requestedUuid, Client client) {\n+        // register client with the batcher to check whether or not the remote client is the leader or not", "originalCommit": "7f0f5e760a824e320d2cc346a65ff498b806f78d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUxNjgwNQ==", "url": "https://github.com/palantir/atlasdb/pull/4623#discussion_r386516805", "bodyText": "nit: generally this comment is hard to read (all one sentence and not much punctuation).", "author": "Jolyon-S", "createdAt": "2020-03-02T16:52:05Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/paxos/ManualBatchingPingableLeader.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.Histogram;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Maps;\n+import com.google.common.net.HostAndPort;\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.common.util.concurrent.FluentFuture;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.SettableFuture;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.paxos.LeaderPingResult;\n+import com.palantir.paxos.LeaderPingResults;\n+import com.palantir.paxos.LeaderPingerContext;\n+import com.palantir.tritium.metrics.registry.MetricName;\n+import com.palantir.tritium.metrics.registry.SharedTaggedMetricRegistries;\n+\n+final class ManualBatchingPingableLeader extends AbstractScheduledService implements ClientAwarePingableLeader {\n+\n+    private static final Logger log = LoggerFactory.getLogger(ManualBatchingPingableLeader.class);\n+\n+    private final LeaderPingerContext<BatchPingableLeader> remoteClient;\n+    private final Duration leaderPingRate;\n+    private final Duration leaderPingResponseWait;\n+    private final UUID nodeUuid;\n+\n+    private final Map<Client, SettableFuture<Void>> hasProcessedFirstRequest = Maps.newConcurrentMap();\n+    private final AtomicReference<LastResult> lastResult = new AtomicReference<>();\n+    private final Histogram histogram;\n+\n+    ManualBatchingPingableLeader(\n+            LeaderPingerContext<BatchPingableLeader> remoteClient,\n+            Duration leaderPingRate,\n+            Duration leaderPingResponseWait,\n+            UUID nodeUuid) {\n+        this.remoteClient = remoteClient;\n+        this.leaderPingRate = leaderPingRate;\n+        this.leaderPingResponseWait = leaderPingResponseWait;\n+        this.nodeUuid = nodeUuid;\n+\n+        // for comparison to the previous autobatching version, can easily remove later\n+        MetricName metricName = MetricName.builder()\n+                .safeName(\"atlasdb.autobatcherMeter\")\n+                .putSafeTags(\"identifier\", \"batch-pingable-leader.ping\")\n+                .putSafeTags(\"remoteHostAndPort\", remoteClient.hostAndPort().toString())\n+                .build();\n+        this.histogram = SharedTaggedMetricRegistries.getSingleton().histogram(metricName);\n+    }\n+\n+    @Override\n+    public Future<LeaderPingResult> ping(UUID requestedUuid, Client client) {\n+        // register client with the batcher to check whether or not the remote client is the leader or not\n+        // since there is a case where we'll miss the window, we must wait until the client has been registered and\n+        // been included in an existing batch before reading from the in memory state\n+        // wait up to leaderPingResponseRate each time until it has been included and requested in a batch", "originalCommit": "7f0f5e760a824e320d2cc346a65ff498b806f78d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUxODczMQ==", "url": "https://github.com/palantir/atlasdb/pull/4623#discussion_r386518731", "bodyText": "nit: the first line of the comment reads as if it is a separate sentence but its adjacency to the rest of the comment makes it feel like it should be connected to the rest (thus not making much sense)", "author": "Jolyon-S", "createdAt": "2020-03-02T16:55:11Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/paxos/ManualBatchingPingableLeader.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.Histogram;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Maps;\n+import com.google.common.net.HostAndPort;\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.common.util.concurrent.FluentFuture;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.SettableFuture;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.paxos.LeaderPingResult;\n+import com.palantir.paxos.LeaderPingResults;\n+import com.palantir.paxos.LeaderPingerContext;\n+import com.palantir.tritium.metrics.registry.MetricName;\n+import com.palantir.tritium.metrics.registry.SharedTaggedMetricRegistries;\n+\n+final class ManualBatchingPingableLeader extends AbstractScheduledService implements ClientAwarePingableLeader {\n+\n+    private static final Logger log = LoggerFactory.getLogger(ManualBatchingPingableLeader.class);\n+\n+    private final LeaderPingerContext<BatchPingableLeader> remoteClient;\n+    private final Duration leaderPingRate;\n+    private final Duration leaderPingResponseWait;\n+    private final UUID nodeUuid;\n+\n+    private final Map<Client, SettableFuture<Void>> hasProcessedFirstRequest = Maps.newConcurrentMap();\n+    private final AtomicReference<LastResult> lastResult = new AtomicReference<>();\n+    private final Histogram histogram;\n+\n+    ManualBatchingPingableLeader(\n+            LeaderPingerContext<BatchPingableLeader> remoteClient,\n+            Duration leaderPingRate,\n+            Duration leaderPingResponseWait,\n+            UUID nodeUuid) {\n+        this.remoteClient = remoteClient;\n+        this.leaderPingRate = leaderPingRate;\n+        this.leaderPingResponseWait = leaderPingResponseWait;\n+        this.nodeUuid = nodeUuid;\n+\n+        // for comparison to the previous autobatching version, can easily remove later\n+        MetricName metricName = MetricName.builder()\n+                .safeName(\"atlasdb.autobatcherMeter\")\n+                .putSafeTags(\"identifier\", \"batch-pingable-leader.ping\")\n+                .putSafeTags(\"remoteHostAndPort\", remoteClient.hostAndPort().toString())\n+                .build();\n+        this.histogram = SharedTaggedMetricRegistries.getSingleton().histogram(metricName);\n+    }\n+\n+    @Override\n+    public Future<LeaderPingResult> ping(UUID requestedUuid, Client client) {\n+        // register client with the batcher to check whether or not the remote client is the leader or not\n+        // since there is a case where we'll miss the window, we must wait until the client has been registered and\n+        // been included in an existing batch before reading from the in memory state\n+        // wait up to leaderPingResponseRate each time until it has been included and requested in a batch\n+        Instant requestTime = Instant.now();\n+\n+        return FluentFuture.from(hasProcessedFirstRequest.computeIfAbsent(client, $ -> SettableFuture.create()))\n+                .transform(\n+                        // this will never be null, since we waited for our request to be processed at least once\n+                        // semantic difference here is that values are effectively cached for leaderPingResponseWait\n+                        // in the event that things are not good, but in the bigger picture these *should* be\n+                        // equivalent.", "originalCommit": "7f0f5e760a824e320d2cc346a65ff498b806f78d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYwMzYyNw==", "url": "https://github.com/palantir/atlasdb/pull/4623#discussion_r386603627", "bodyText": "checking: safe because of guarantees of the guava Service class, right?", "author": "jeremyk-91", "createdAt": "2020-03-02T19:31:25Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/paxos/ManualBatchingPingableLeader.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.Histogram;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Maps;\n+import com.google.common.net.HostAndPort;\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.common.util.concurrent.FluentFuture;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.SettableFuture;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.paxos.LeaderPingResult;\n+import com.palantir.paxos.LeaderPingResults;\n+import com.palantir.paxos.LeaderPingerContext;\n+import com.palantir.tritium.metrics.registry.MetricName;\n+import com.palantir.tritium.metrics.registry.SharedTaggedMetricRegistries;\n+\n+final class ManualBatchingPingableLeader extends AbstractScheduledService implements ClientAwarePingableLeader {\n+\n+    private static final Logger log = LoggerFactory.getLogger(ManualBatchingPingableLeader.class);\n+\n+    private final LeaderPingerContext<BatchPingableLeader> remoteClient;\n+    private final Duration leaderPingRate;\n+    private final Duration leaderPingResponseWait;\n+    private final UUID nodeUuid;\n+\n+    private final Map<Client, SettableFuture<Void>> hasProcessedFirstRequest = Maps.newConcurrentMap();\n+    private final AtomicReference<LastResult> lastResult = new AtomicReference<>();\n+    private final Histogram histogram;\n+\n+    ManualBatchingPingableLeader(\n+            LeaderPingerContext<BatchPingableLeader> remoteClient,\n+            Duration leaderPingRate,\n+            Duration leaderPingResponseWait,\n+            UUID nodeUuid) {\n+        this.remoteClient = remoteClient;\n+        this.leaderPingRate = leaderPingRate;\n+        this.leaderPingResponseWait = leaderPingResponseWait;\n+        this.nodeUuid = nodeUuid;\n+\n+        // for comparison to the previous autobatching version, can easily remove later\n+        MetricName metricName = MetricName.builder()\n+                .safeName(\"atlasdb.autobatcherMeter\")\n+                .putSafeTags(\"identifier\", \"batch-pingable-leader.ping\")\n+                .putSafeTags(\"remoteHostAndPort\", remoteClient.hostAndPort().toString())\n+                .build();\n+        this.histogram = SharedTaggedMetricRegistries.getSingleton().histogram(metricName);\n+    }\n+\n+    @Override\n+    public Future<LeaderPingResult> ping(UUID requestedUuid, Client client) {\n+        // register client with the batcher to check whether or not the remote client is the leader or not\n+        // since there is a case where we'll miss the window, we must wait until the client has been registered and\n+        // been included in an existing batch before reading from the in memory state\n+        // wait up to leaderPingResponseRate each time until it has been included and requested in a batch\n+        Instant requestTime = Instant.now();\n+\n+        return FluentFuture.from(hasProcessedFirstRequest.computeIfAbsent(client, $ -> SettableFuture.create()))\n+                .transform(\n+                        // this will never be null, since we waited for our request to be processed at least once\n+                        // semantic difference here is that values are effectively cached for leaderPingResponseWait\n+                        // in the event that things are not good, but in the bigger picture these *should* be\n+                        // equivalent.\n+                        $ -> {\n+                            // if for any reason we've stopped, bubble up the exception\n+                            checkNotShutdown();\n+                            return lastResult.get().result(\n+                                    client,\n+                                    requestTime.minus(leaderPingResponseWait),\n+                                    remoteClient.hostAndPort(),\n+                                    requestedUuid);\n+                        },\n+                        MoreExecutors.directExecutor());\n+    }\n+\n+    private void checkNotShutdown() {\n+        State state = state();\n+        Preconditions.checkState(state != State.STOPPING && state != State.TERMINATED,\n+                \"pinger is either shutdown or in the process of shutting down\");\n+    }\n+\n+    @Override\n+    protected String serviceName() {\n+        return String.format(\"ManualBatchingPingableLeader %s -> %s\", nodeUuid.toString(), remoteClient.hostAndPort());\n+    }\n+\n+    @Override\n+    public LeaderPingerContext<BatchPingableLeader> underlyingRpcClient() {\n+        return remoteClient;\n+    }\n+\n+    @Override\n+    protected void runOneIteration() {\n+        try {\n+            Set<Client> clientsToCheck = ImmutableSet.copyOf(hasProcessedFirstRequest.keySet());\n+            Instant before = Instant.now();\n+            Set<Client> clientsThisNodeIsTheLeaderFor = remoteClient.pinger().ping(clientsToCheck);\n+            Instant after = Instant.now();\n+\n+            Duration pingDuration = Duration.between(before, after);\n+            if (pingDuration.compareTo(leaderPingResponseWait) >= 0) {\n+                log.info(\"Ping took more than ping response wait, any waiters will report that ping timed out\",\n+                        SafeArg.of(\"pingDuration\", pingDuration),\n+                        SafeArg.of(\"leaderPingResponseWait\", leaderPingResponseWait));\n+            }\n+            LastResult newResult = ImmutableLastResult.of(after, clientsThisNodeIsTheLeaderFor);\n+            this.lastResult.set(newResult);", "originalCommit": "7f0f5e760a824e320d2cc346a65ff498b806f78d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYwNjU0Nw==", "url": "https://github.com/palantir/atlasdb/pull/4623#discussion_r386606547", "bodyText": "I find this class a little confusing, perhaps because of the naming similarity to Autobatchers and co. In particular, if a given client is requested once, it will continue to be requested for the life of the object, while in most things that batch I would not expect the request to be sent after the first time it is processed.\nThe logic makes sense (as you do mention in the comments, the worry here is serialization cost - but I think it's worth a shot, we can test with an RC if you'd prefer).", "author": "jeremyk-91", "createdAt": "2020-03-02T19:37:03Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/paxos/ManualBatchingPingableLeader.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.Histogram;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Maps;\n+import com.google.common.net.HostAndPort;\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.common.util.concurrent.FluentFuture;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.SettableFuture;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.paxos.LeaderPingResult;\n+import com.palantir.paxos.LeaderPingResults;\n+import com.palantir.paxos.LeaderPingerContext;\n+import com.palantir.tritium.metrics.registry.MetricName;\n+import com.palantir.tritium.metrics.registry.SharedTaggedMetricRegistries;\n+\n+final class ManualBatchingPingableLeader extends AbstractScheduledService implements ClientAwarePingableLeader {", "originalCommit": "7f0f5e760a824e320d2cc346a65ff498b806f78d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYxMTkyMQ==", "url": "https://github.com/palantir/atlasdb/pull/4623#discussion_r386611921", "bodyText": "There's a test that I think is quite important that's missing here:\n\nrunOneIteration will ping (and continue to ping) services that haven't been requested since the last iteration - this is the behaviour I was confused by, but given its usage I think would be good to codify it", "author": "jeremyk-91", "createdAt": "2020-03-02T19:48:04Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/paxos/ManualBatchingPingableLeaderTest.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.only;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.net.HostAndPort;\n+import com.google.common.util.concurrent.Futures;\n+import com.palantir.atlasdb.timelock.paxos.ManualBatchingPingableLeader.LastResult;\n+import com.palantir.paxos.ImmutableLeaderPingerContext;\n+import com.palantir.paxos.LeaderPingResult;\n+import com.palantir.paxos.LeaderPingResults;\n+import com.palantir.paxos.LeaderPingerContext;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class ManualBatchingPingableLeaderTest {\n+\n+    private static final Client CLIENT_WHO_IS_LED = Client.of(\"client-1\");\n+    private static final Client CLIENT_WHO_IS_NOT_LED = Client.of(\"client-2\");\n+\n+    private static final HostAndPort HOST_AND_PORT = HostAndPort.fromParts(\"localhost\", 1234);\n+    private static final UUID HOST_UUID = UUID.randomUUID();\n+\n+    @Mock\n+    private BatchPingableLeader batchPingableLeader;\n+    private LeaderPingerContext<BatchPingableLeader> pingerWithContext;\n+\n+    @Before\n+    public void setUp() {\n+        pingerWithContext = ImmutableLeaderPingerContext.of(batchPingableLeader, HOST_AND_PORT);\n+    }\n+\n+    @Test\n+    public void testTooOldResultReturnsTimeOut() {\n+        Instant completedAt = Instant.now();\n+        Instant earliestCompletedDeadline = completedAt.plus(Duration.ofMillis(10));\n+        LastResult lastResult = ImmutableLastResult.of(completedAt, ImmutableSet.of(CLIENT_WHO_IS_LED));\n+        LeaderPingResult result =\n+                lastResult.result(CLIENT_WHO_IS_LED, earliestCompletedDeadline, HOST_AND_PORT, HOST_UUID);\n+\n+        assertThat(result)\n+                .as(\"earliest completed deadline was not met, meaning we've timed out\")\n+                .isEqualTo(LeaderPingResults.pingTimedOut());\n+    }\n+\n+    @Test\n+    public void testClientBeingLedShowsUpAsTrue() {\n+        Instant completedAt = Instant.now();\n+        Instant earliestCompletedDeadline = completedAt.minus(Duration.ofMillis(10));\n+        LastResult lastResult = ImmutableLastResult.of(completedAt, ImmutableSet.of(CLIENT_WHO_IS_LED));\n+        LeaderPingResult result =\n+                lastResult.result(CLIENT_WHO_IS_LED, earliestCompletedDeadline, HOST_AND_PORT, HOST_UUID);\n+\n+        assertThat(result)\n+                .isEqualTo(LeaderPingResults.pingReturnedTrue(HOST_UUID, HOST_AND_PORT));\n+    }\n+\n+    @Test\n+    public void testClientNotBeingLedShowsUpAsFalse() {\n+        Instant completedAt = Instant.now();\n+        Instant earliestCompletedDeadline = completedAt.minus(Duration.ofMillis(10));\n+        LastResult lastResult = ImmutableLastResult.of(completedAt, ImmutableSet.of(CLIENT_WHO_IS_LED));\n+        LeaderPingResult result =\n+                lastResult.result(CLIENT_WHO_IS_NOT_LED, earliestCompletedDeadline, HOST_AND_PORT, HOST_UUID);\n+\n+        assertThat(result)\n+                .isEqualTo(LeaderPingResults.pingReturnedFalse());\n+    }\n+\n+    @Test\n+    public void singleIterationUpdatesInMemoryReference() {\n+        ManualBatchingPingableLeader manualBatchingPingableLeader = new ManualBatchingPingableLeader(\n+                pingerWithContext,\n+                Duration.ofSeconds(1),\n+                Duration.ofSeconds(1),\n+                HOST_UUID);\n+\n+        Future<LeaderPingResult> clientWhoIsLed = manualBatchingPingableLeader.ping(HOST_UUID, CLIENT_WHO_IS_LED);\n+        Future<LeaderPingResult> clientWhoIsNotLed =\n+                manualBatchingPingableLeader.ping(HOST_UUID, CLIENT_WHO_IS_NOT_LED);\n+\n+        when(batchPingableLeader.ping(ImmutableSet.of(CLIENT_WHO_IS_LED, CLIENT_WHO_IS_NOT_LED)))\n+                .thenReturn(ImmutableSet.of(CLIENT_WHO_IS_LED));\n+\n+        manualBatchingPingableLeader.runOneIteration();\n+\n+        assertThat(Futures.getUnchecked(clientWhoIsLed))\n+                .isEqualTo(LeaderPingResults.pingReturnedTrue(HOST_UUID, HOST_AND_PORT));\n+\n+        assertThat(Futures.getUnchecked(clientWhoIsNotLed))\n+                .isEqualTo(LeaderPingResults.pingReturnedFalse());\n+    }\n+\n+    @Test\n+    public void getUnresolvedFutureUntilSingleIterationHasRun() {\n+        ManualBatchingPingableLeader manualBatchingPingableLeader = new ManualBatchingPingableLeader(\n+                pingerWithContext,\n+                Duration.ofSeconds(1),\n+                Duration.ofSeconds(1),\n+                HOST_UUID);\n+\n+        Future<LeaderPingResult> clientWhoIsLed = manualBatchingPingableLeader.ping(HOST_UUID, CLIENT_WHO_IS_LED);\n+\n+        assertThat(clientWhoIsLed)\n+                .as(\"it's hard to test that it never gets resolved prior to running the single iteration\")\n+                .isNotDone();\n+\n+        when(batchPingableLeader.ping(ImmutableSet.of(CLIENT_WHO_IS_LED)))\n+                .thenReturn(ImmutableSet.of(CLIENT_WHO_IS_LED));\n+\n+        manualBatchingPingableLeader.runOneIteration();\n+\n+        assertThat(clientWhoIsLed)\n+                .as(\"we expect this to be done, everything is running within a single thread in this test\")\n+                .isDone();\n+    }\n+\n+    @Test\n+    public void getBackCachedResultIfTryingToPingTwice() {\n+        ManualBatchingPingableLeader manualBatchingPingableLeader = new ManualBatchingPingableLeader(\n+                pingerWithContext,\n+                Duration.ofSeconds(1),\n+                Duration.ofSeconds(1),\n+                HOST_UUID);\n+\n+        Future<LeaderPingResult> clientWhoIsLed = manualBatchingPingableLeader.ping(HOST_UUID, CLIENT_WHO_IS_LED);\n+\n+        when(batchPingableLeader.ping(ImmutableSet.of(CLIENT_WHO_IS_LED)))\n+                .thenReturn(ImmutableSet.of(CLIENT_WHO_IS_LED))\n+                .thenReturn(ImmutableSet.of());\n+\n+        manualBatchingPingableLeader.runOneIteration();\n+\n+        assertThat(Futures.getUnchecked(clientWhoIsLed))\n+                .isEqualTo(LeaderPingResults.pingReturnedTrue(HOST_UUID, HOST_AND_PORT));\n+\n+        Future<LeaderPingResult> clientWhoIsLedSecondRequest =\n+                manualBatchingPingableLeader.ping(HOST_UUID, CLIENT_WHO_IS_LED);\n+\n+        assertThat(Futures.getUnchecked(clientWhoIsLedSecondRequest))\n+                .isEqualTo(LeaderPingResults.pingReturnedTrue(HOST_UUID, HOST_AND_PORT));\n+\n+        verify(batchPingableLeader, only()).ping(ImmutableSet.of(CLIENT_WHO_IS_LED));\n+    }", "originalCommit": "7f0f5e760a824e320d2cc346a65ff498b806f78d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0d0b3b003b3e68a4e94e5a082af3db35a3381561", "url": "https://github.com/palantir/atlasdb/commit/0d0b3b003b3e68a4e94e5a082af3db35a3381561", "message": "Address PR comments.", "committedDate": "2020-03-03T14:38:43Z", "type": "commit"}]}