{"pr_number": 4933, "pr_title": "Bound lock acquire timeout", "pr_createdAt": "2020-08-07T13:57:02Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4933", "timeline": [{"oid": "70db92492036b1302afe5351e41e22ad5ca07e88", "url": "https://github.com/palantir/atlasdb/commit/70db92492036b1302afe5351e41e22ad5ca07e88", "message": "Bound lock acquire timeout", "committedDate": "2020-08-07T13:56:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA3MzQzOQ==", "url": "https://github.com/palantir/atlasdb/pull/4933#discussion_r467073439", "bodyText": "This needs to be slightly less - a client's connect timeout also covers the time timelock takes to deserialize the request, check it is the leader etc.", "author": "jeremyk-91", "createdAt": "2020-08-07T14:24:03Z", "path": "lock-api/src/main/java/com/palantir/lock/client/BlockEnforcingLockService.java", "diffHunk": "@@ -46,6 +46,13 @@\n  * Fairness is admittedly compromised, but this is a closer approximation than the previous behaviour.\n  */\n final class BlockEnforcingLockService {\n+    /**\n+     * Bound lock acquire timeout by client read timeout because 1. the async request expires before server cancels\n+     * the request thus avoiding {@link java.util.concurrent.CancellationException} and\n+     * 2. this ensures locks are not given out to phantom client.\n+     */\n+    private static final Duration MAX_PERMISSIBLE_LOCK_ACQUIRE_TIMEOUT = Duration.ofSeconds(65);", "originalCommit": "70db92492036b1302afe5351e41e22ad5ca07e88", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7b96f0a0858adf9f3423e24645da499cf564eab8", "url": "https://github.com/palantir/atlasdb/commit/7b96f0a0858adf9f3423e24645da499cf564eab8", "message": "Test effort 1", "committedDate": "2020-08-10T15:15:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAwNjcwNA==", "url": "https://github.com/palantir/atlasdb/pull/4933#discussion_r468006704", "bodyText": "Not sure I understand the separate verifies here.", "author": "jeremyk-91", "createdAt": "2020-08-10T15:51:30Z", "path": "lock-api/src/test/java/com/palantir/lock/client/LockLeaseServiceTest.java", "diffHunk": "@@ -141,6 +148,33 @@ public void leasedTokenShouldHaveValidLeaseForTheLeasePeriod() {\n         assertValid(lockResponse.getToken());\n     }\n \n+    @Test\n+    public void lockAcquireTimeoutIsBounded() {\n+        when(lockRequest.getAcquireTimeoutMs()).thenReturn(TIMEOUT_GREATER_THAN_MAX_PERMISSIBLE_TIMEOUT.toMillis());\n+        when(timelock.lock(any()))\n+                .thenReturn(ConjureLockResponse.successful(SuccessfulLockResponse.of(LOCK_TOKEN, getLease())));\n+        LockResponse lockResponse = lockLeaseService.lock(lockRequest);\n+        assertValid(lockResponse.getToken());\n+        verify(timelock, times(1)).lock(any());\n+        verify(timelock)\n+                .lock(argThat(req -> req.getAcquireTimeoutMs()\n+                        == BlockEnforcingLockService.MAX_PERMISSIBLE_LOCK_ACQUIRE_TIMEOUT.toMillis()));", "originalCommit": "7b96f0a0858adf9f3423e24645da499cf564eab8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAwNjg4Mw==", "url": "https://github.com/palantir/atlasdb/pull/4933#discussion_r468006883", "bodyText": "Can we have a test for retrying until failure?", "author": "jeremyk-91", "createdAt": "2020-08-10T15:51:47Z", "path": "lock-api/src/test/java/com/palantir/lock/client/LockLeaseServiceTest.java", "diffHunk": "@@ -141,6 +148,33 @@ public void leasedTokenShouldHaveValidLeaseForTheLeasePeriod() {\n         assertValid(lockResponse.getToken());\n     }\n \n+    @Test\n+    public void lockAcquireTimeoutIsBounded() {\n+        when(lockRequest.getAcquireTimeoutMs()).thenReturn(TIMEOUT_GREATER_THAN_MAX_PERMISSIBLE_TIMEOUT.toMillis());\n+        when(timelock.lock(any()))\n+                .thenReturn(ConjureLockResponse.successful(SuccessfulLockResponse.of(LOCK_TOKEN, getLease())));\n+        LockResponse lockResponse = lockLeaseService.lock(lockRequest);\n+        assertValid(lockResponse.getToken());\n+        verify(timelock, times(1)).lock(any());\n+        verify(timelock)\n+                .lock(argThat(req -> req.getAcquireTimeoutMs()\n+                        == BlockEnforcingLockService.MAX_PERMISSIBLE_LOCK_ACQUIRE_TIMEOUT.toMillis()));\n+    }\n+\n+    @Test\n+    public void lockAcquireTimeoutIsBoundedAndRequestRetried() {\n+        when(lockRequest.getAcquireTimeoutMs()).thenReturn(TIMEOUT_GREATER_THAN_MAX_PERMISSIBLE_TIMEOUT.toMillis());\n+        when(timelock.lock(any()))\n+                .thenThrow(TIMEOUT_EXCEPTION)\n+                .thenReturn(ConjureLockResponse.successful(SuccessfulLockResponse.of(LOCK_TOKEN, getLease())));\n+\n+        LockResponse lockResponse = lockLeaseService.lock(lockRequest);\n+        assertValid(lockResponse.getToken());\n+        verify(timelock, times(2)).lock(any());\n+    }", "originalCommit": "7b96f0a0858adf9f3423e24645da499cf564eab8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAzMjA4NQ==", "url": "https://github.com/palantir/atlasdb/pull/4933#discussion_r468032085", "bodyText": "Discussed offline: That's hard because it requires you to inject a clock.", "author": "jeremyk-91", "createdAt": "2020-08-10T16:32:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAwNjg4Mw=="}], "type": "inlineReview"}, {"oid": "99c8524f20a001091dceeb76786cc0b69e618f21", "url": "https://github.com/palantir/atlasdb/commit/99c8524f20a001091dceeb76786cc0b69e618f21", "message": "Address comments", "committedDate": "2020-08-10T17:21:19Z", "type": "commit"}, {"oid": "ab9b23ba87278a1c6c9cdb3279398fefe5dfa7c8", "url": "https://github.com/palantir/atlasdb/commit/ab9b23ba87278a1c6c9cdb3279398fefe5dfa7c8", "message": "Add generated changelog entries", "committedDate": "2020-08-10T17:21:19Z", "type": "commit"}]}