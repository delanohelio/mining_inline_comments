{"pr_number": 4953, "pr_title": "Pingv2 fallback", "pr_createdAt": "2020-08-18T15:08:57Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4953", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIwODYzNw==", "url": "https://github.com/palantir/atlasdb/pull/4953#discussion_r474208637", "bodyText": "nit: For readability, I think this is better as two calls actually (verifyPingV2Requests and verifyLegacyPingRequests)?", "author": "jeremyk-91", "createdAt": "2020-08-20T19:07:33Z", "path": "atlasdb-config/src/test/java/com/palantir/atlasdb/SinglePingableLeaderTest.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;\n+\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import com.github.tomakehurst.wiremock.client.MappingBuilder;\n+import com.github.tomakehurst.wiremock.client.WireMock;\n+import com.github.tomakehurst.wiremock.core.WireMockConfiguration;\n+import com.github.tomakehurst.wiremock.junit.WireMockRule;\n+import com.github.tomakehurst.wiremock.verification.LoggedRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.palantir.atlasdb.config.RemotingClientConfigs;\n+import com.palantir.atlasdb.factory.Leaders;\n+import com.palantir.atlasdb.factory.ServiceCreator;\n+import com.palantir.common.concurrent.CheckedRejectionExecutorService;\n+import com.palantir.conjure.java.api.config.service.UserAgent;\n+import com.palantir.conjure.java.api.config.ssl.SslConfiguration;\n+import com.palantir.leader.PingableLeader;\n+import com.palantir.paxos.LeaderPinger;\n+import com.palantir.paxos.LeaderPingerContext;\n+import com.palantir.paxos.SingleLeaderPinger;\n+import com.palantir.sls.versions.OrderableSlsVersion;\n+\n+public class SinglePingableLeaderTest {\n+    private static final UUID LOCAL_UUID = UUID.randomUUID();\n+    private static final UUID REMOTE_UUID = UUID.randomUUID();\n+    private static final UserAgent USER_AGENT = UserAgent.of(UserAgent.Agent.of(\"user-agent\", \"0.27.1\"));\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private static final String PING = \"/leader/ping\";\n+    private static final String PING_V2 = \"/leader/pingV2\";\n+    private static final String UUID_PATH = \"/leader/uuid\";\n+\n+    private static final MappingBuilder PING_MAPPING = WireMock.get(WireMock.urlEqualTo(PING));\n+    private static final MappingBuilder PING_V2_MAPPING = WireMock.get(WireMock.urlEqualTo(PING_V2));\n+    private static final MappingBuilder UUID_MAPPING = WireMock.get(WireMock.urlEqualTo(UUID_PATH));\n+\n+    private static final SslConfiguration SSL_CONFIGURATION\n+            = SslConfiguration.of(Paths.get(\"var/security/trustStore.jks\"));\n+\n+    private int availablePort;\n+    private String serverUri;\n+\n+    @Rule\n+    public WireMockRule availableServer = new WireMockRule(WireMockConfiguration.wireMockConfig().dynamicPort());\n+\n+    @Before\n+    public void setup() {\n+        availableServer.stubFor(UUID_MAPPING.willReturn(aResponse().withStatus(200).withBody(\n+                (\"\\\"\" + REMOTE_UUID.toString() + \"\\\"\").getBytes())));\n+\n+        availableServer.stubFor(PING_MAPPING.willReturn(WireMock.aResponse().withStatus(204)));\n+\n+        availablePort = availableServer.port();\n+        serverUri = String.format(\"http://%s:%s\", WireMockConfiguration.DEFAULT_BIND_ADDRESS, availablePort);\n+    }\n+\n+    @Test\n+    public void doesNotFallbackOnPingWhenPingV2Responds() {\n+        availableServer.stubFor(PING_V2_MAPPING.willReturn(WireMock.aResponse().withStatus(200)\n+                .withBody(\"{\\\"isLeader\\\":false}\")));\n+        verifyPingRequests(1, 0);\n+    }\n+\n+    @Test\n+    public void fallbackOnPingWhenPingV2DoesNotExist() {\n+        availableServer.stubFor(PING_V2_MAPPING.willReturn(WireMock.aResponse().withStatus(404)));\n+        verifyPingRequests(1, 1);\n+    }\n+\n+    @Test\n+    public void fallbackOnPingWhenPingV2Throws() {\n+        availableServer.stubFor(PING_V2_MAPPING.willReturn(WireMock.aResponse().withStatus(500)));\n+        verifyPingRequests(1, 1);\n+    }\n+\n+    public void verifyPingRequests(int pingV2RequestCount, int pingRequestCount) {\n+        LeaderPinger pinger = pingerWithVersion(OrderableSlsVersion.valueOf(\"1.1.1\"));\n+        pinger.pingLeaderWithUuid(REMOTE_UUID);\n+        List<LoggedRequest> requests = WireMock.findAll(WireMock.getRequestedFor(WireMock.urlMatching(PING_V2)));\n+        assertThat(requests.size()).isEqualTo(pingV2RequestCount);\n+        requests = WireMock.findAll(WireMock.getRequestedFor(WireMock.urlMatching(PING)));\n+        assertThat(requests.size()).isEqualTo(pingRequestCount);", "originalCommit": "5d1dda41bac626c7119518b22480be69dc83772e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIwOTA3MQ==", "url": "https://github.com/palantir/atlasdb/pull/4953#discussion_r474209071", "bodyText": "nit: is there a reason we can't use e?", "author": "jeremyk-91", "createdAt": "2020-08-20T19:08:31Z", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SingleLeaderPinger.java", "diffHunk": "@@ -88,20 +89,48 @@ public LeaderPingResult pingLeaderWithUuid(UUID uuid) {\n         if (!suspectedLeader.isPresent()) {\n             return LeaderPingResults.pingReturnedFalse();\n         }\n-\n         LeaderPingerContext<PingableLeader> leader = suspectedLeader.get();\n \n         MultiplexingCompletionService<LeaderPingerContext<PingableLeader>, PingResult> multiplexingCompletionService\n                 = MultiplexingCompletionService.createFromCheckedExecutors(leaderPingExecutors);\n+        try {\n+            return actuallyPingLeaderWithUuid(multiplexingCompletionService,\n+                    uuid,\n+                    leader,\n+                    leader.pinger()::pingV2);\n+        } catch (ExecutionException e) {\n+            log.warn(\"Could not ping the leader using pingV2 endpoint, \", e);\n+        }\n+\n+        try {\n+            return actuallyPingLeaderWithUuid(multiplexingCompletionService,\n+                    uuid,\n+                    leader,\n+                    () -> getPingResultFromLegacyEndpoint(leader));\n+        } catch (ExecutionException ex) {\n+            return LeaderPingResults.pingCallFailure(ex.getCause());\n+        }\n+    }\n+\n+    private PingResult getPingResultFromLegacyEndpoint(LeaderPingerContext<PingableLeader> leader) {\n+        boolean isLeader = leader.pinger().ping();\n+        return PingResult.builder().isLeader(isLeader).build();\n+    }\n \n+    private LeaderPingResult actuallyPingLeaderWithUuid(\n+            MultiplexingCompletionService<LeaderPingerContext<PingableLeader>, PingResult>\n+                    multiplexingCompletionService,\n+            UUID uuid,\n+            LeaderPingerContext<PingableLeader> leader,\n+            Callable<PingResult> pingEndpoint) throws ExecutionException {\n         try {\n-            multiplexingCompletionService.submit(leader, () -> leader.pinger().pingV2());\n+            multiplexingCompletionService.submit(leader, pingEndpoint);\n             Future<Map.Entry<LeaderPingerContext<PingableLeader>, PingResult>> pingFuture\n                     = multiplexingCompletionService.poll(leaderPingResponseWait.toMillis(), TimeUnit.MILLISECONDS);\n             return getLeaderPingResult(uuid, pingFuture, timeLockVersion);\n-        } catch (InterruptedException e) {\n+        } catch (InterruptedException exc) {", "originalCommit": "5d1dda41bac626c7119518b22480be69dc83772e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIwOTg1Mg==", "url": "https://github.com/palantir/atlasdb/pull/4953#discussion_r474209852", "bodyText": "nit: We're basically using exceptions for control flow I think, which is not great. Can we just return the PingCallFailure and check whether there was a failure higher up? It's possible there's something I've missed", "author": "jeremyk-91", "createdAt": "2020-08-20T19:10:08Z", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SingleLeaderPinger.java", "diffHunk": "@@ -111,23 +140,20 @@ public LeaderPingResult pingLeaderWithUuid(UUID uuid) {\n     private static LeaderPingResult getLeaderPingResult(\n             UUID uuid,\n             @Nullable Future<Map.Entry<LeaderPingerContext<PingableLeader>, PingResult>> pingFuture,\n-            Optional<OrderableSlsVersion> timeLockVersion) {\n+            Optional<OrderableSlsVersion> timeLockVersion) throws ExecutionException {", "originalCommit": "5d1dda41bac626c7119518b22480be69dc83772e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxMzMyMg==", "url": "https://github.com/palantir/atlasdb/pull/4953#discussion_r474213322", "bodyText": "My main concern with this is that for users who may not have access to ping v2, this is going to make performance of ping worse by a full RPC. It's not really the hottest codepath so this may not necessarily be terrible, but is there something we can do to avoid repeatedly trying if there is no ping v2?", "author": "jeremyk-91", "createdAt": "2020-08-20T19:16:35Z", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SingleLeaderPinger.java", "diffHunk": "@@ -88,20 +89,48 @@ public LeaderPingResult pingLeaderWithUuid(UUID uuid) {\n         if (!suspectedLeader.isPresent()) {\n             return LeaderPingResults.pingReturnedFalse();\n         }\n-\n         LeaderPingerContext<PingableLeader> leader = suspectedLeader.get();\n \n         MultiplexingCompletionService<LeaderPingerContext<PingableLeader>, PingResult> multiplexingCompletionService\n                 = MultiplexingCompletionService.createFromCheckedExecutors(leaderPingExecutors);\n+        try {\n+            return actuallyPingLeaderWithUuid(multiplexingCompletionService,\n+                    uuid,\n+                    leader,\n+                    leader.pinger()::pingV2);\n+        } catch (ExecutionException e) {\n+            log.warn(\"Could not ping the leader using pingV2 endpoint, \", e);\n+        }\n+\n+        try {\n+            return actuallyPingLeaderWithUuid(multiplexingCompletionService,\n+                    uuid,\n+                    leader,\n+                    () -> getPingResultFromLegacyEndpoint(leader));\n+        } catch (ExecutionException ex) {\n+            return LeaderPingResults.pingCallFailure(ex.getCause());\n+        }", "originalCommit": "5d1dda41bac626c7119518b22480be69dc83772e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY0MDYzNA==", "url": "https://github.com/palantir/atlasdb/pull/4953#discussion_r475640634", "bodyText": "Let's not reuse the set, for readability.", "author": "jeremyk-91", "createdAt": "2020-08-24T14:09:55Z", "path": "atlasdb-config/src/test/java/com/palantir/atlasdb/SinglePingableLeaderTest.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;\n+\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.IntStream;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import com.github.tomakehurst.wiremock.client.MappingBuilder;\n+import com.github.tomakehurst.wiremock.client.WireMock;\n+import com.github.tomakehurst.wiremock.core.WireMockConfiguration;\n+import com.github.tomakehurst.wiremock.junit.WireMockRule;\n+import com.github.tomakehurst.wiremock.verification.LoggedRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.palantir.atlasdb.config.RemotingClientConfigs;\n+import com.palantir.atlasdb.factory.Leaders;\n+import com.palantir.atlasdb.factory.ServiceCreator;\n+import com.palantir.common.concurrent.CheckedRejectionExecutorService;\n+import com.palantir.conjure.java.api.config.service.UserAgent;\n+import com.palantir.conjure.java.api.config.ssl.SslConfiguration;\n+import com.palantir.leader.PingableLeader;\n+import com.palantir.paxos.LeaderPinger;\n+import com.palantir.paxos.LeaderPingerContext;\n+import com.palantir.paxos.SingleLeaderPinger;\n+import com.palantir.sls.versions.OrderableSlsVersion;\n+\n+public class SinglePingableLeaderTest {\n+    private static final UUID LOCAL_UUID = UUID.randomUUID();\n+    private static final UUID REMOTE_UUID = UUID.randomUUID();\n+    private static final UserAgent USER_AGENT = UserAgent.of(UserAgent.Agent.of(\"user-agent\", \"0.27.1\"));\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private static final String PING = \"/leader/ping\";\n+    private static final String PING_V2 = \"/leader/pingV2\";\n+    private static final String UUID_PATH = \"/leader/uuid\";\n+\n+    private static final MappingBuilder PING_MAPPING = WireMock.get(WireMock.urlEqualTo(PING));\n+    private static final MappingBuilder PING_V2_MAPPING = WireMock.get(WireMock.urlEqualTo(PING_V2));\n+    private static final MappingBuilder UUID_MAPPING = WireMock.get(WireMock.urlEqualTo(UUID_PATH));\n+\n+    private static final SslConfiguration SSL_CONFIGURATION\n+            = SslConfiguration.of(Paths.get(\"var/security/trustStore.jks\"));\n+\n+    private int availablePort;\n+    private String serverUri;\n+\n+    @Rule\n+    public WireMockRule availableServer = new WireMockRule(WireMockConfiguration.wireMockConfig().dynamicPort());\n+\n+    @Before\n+    public void setup() {\n+        availableServer.stubFor(UUID_MAPPING.willReturn(aResponse().withStatus(200).withBody(\n+                (\"\\\"\" + REMOTE_UUID.toString() + \"\\\"\").getBytes())));\n+\n+        availableServer.stubFor(PING_MAPPING.willReturn(WireMock.aResponse().withStatus(204)));\n+\n+        availablePort = availableServer.port();\n+        serverUri = String.format(\"http://%s:%s\", WireMockConfiguration.DEFAULT_BIND_ADDRESS, availablePort);\n+    }\n+\n+    @Test\n+    public void doesNotFallbackOnPingWhenPingV2Responds() {\n+        availableServer.stubFor(PING_V2_MAPPING.willReturn(WireMock.aResponse().withStatus(200)\n+                .withBody(\"{\\\"isLeader\\\":false}\")));\n+        pingerWithVersion(OrderableSlsVersion.valueOf(\"1.1.1\")).pingLeaderWithUuid(REMOTE_UUID);\n+        List<LoggedRequest> requests = WireMock.findAll(WireMock.getRequestedFor(WireMock.urlMatching(PING_V2)));\n+        assertThat(requests.size()).isEqualTo(1);\n+        requests = WireMock.findAll(WireMock.getRequestedFor(WireMock.urlMatching(PING)));", "originalCommit": "58b3c37316e9d71b5129d4bc757e64708823e1e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY0MTI3Nw==", "url": "https://github.com/palantir/atlasdb/pull/4953#discussion_r475641277", "bodyText": "I would suggest having this be two methods: one for assertLegacyPingRequestsMade(int) and one for assertPingV2RequestsMadeAreAtMost(int). The 2 numbers is a bit messy to read.", "author": "jeremyk-91", "createdAt": "2020-08-24T14:10:50Z", "path": "atlasdb-config/src/test/java/com/palantir/atlasdb/SinglePingableLeaderTest.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;\n+\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.IntStream;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import com.github.tomakehurst.wiremock.client.MappingBuilder;\n+import com.github.tomakehurst.wiremock.client.WireMock;\n+import com.github.tomakehurst.wiremock.core.WireMockConfiguration;\n+import com.github.tomakehurst.wiremock.junit.WireMockRule;\n+import com.github.tomakehurst.wiremock.verification.LoggedRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.palantir.atlasdb.config.RemotingClientConfigs;\n+import com.palantir.atlasdb.factory.Leaders;\n+import com.palantir.atlasdb.factory.ServiceCreator;\n+import com.palantir.common.concurrent.CheckedRejectionExecutorService;\n+import com.palantir.conjure.java.api.config.service.UserAgent;\n+import com.palantir.conjure.java.api.config.ssl.SslConfiguration;\n+import com.palantir.leader.PingableLeader;\n+import com.palantir.paxos.LeaderPinger;\n+import com.palantir.paxos.LeaderPingerContext;\n+import com.palantir.paxos.SingleLeaderPinger;\n+import com.palantir.sls.versions.OrderableSlsVersion;\n+\n+public class SinglePingableLeaderTest {\n+    private static final UUID LOCAL_UUID = UUID.randomUUID();\n+    private static final UUID REMOTE_UUID = UUID.randomUUID();\n+    private static final UserAgent USER_AGENT = UserAgent.of(UserAgent.Agent.of(\"user-agent\", \"0.27.1\"));\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private static final String PING = \"/leader/ping\";\n+    private static final String PING_V2 = \"/leader/pingV2\";\n+    private static final String UUID_PATH = \"/leader/uuid\";\n+\n+    private static final MappingBuilder PING_MAPPING = WireMock.get(WireMock.urlEqualTo(PING));\n+    private static final MappingBuilder PING_V2_MAPPING = WireMock.get(WireMock.urlEqualTo(PING_V2));\n+    private static final MappingBuilder UUID_MAPPING = WireMock.get(WireMock.urlEqualTo(UUID_PATH));\n+\n+    private static final SslConfiguration SSL_CONFIGURATION\n+            = SslConfiguration.of(Paths.get(\"var/security/trustStore.jks\"));\n+\n+    private int availablePort;\n+    private String serverUri;\n+\n+    @Rule\n+    public WireMockRule availableServer = new WireMockRule(WireMockConfiguration.wireMockConfig().dynamicPort());\n+\n+    @Before\n+    public void setup() {\n+        availableServer.stubFor(UUID_MAPPING.willReturn(aResponse().withStatus(200).withBody(\n+                (\"\\\"\" + REMOTE_UUID.toString() + \"\\\"\").getBytes())));\n+\n+        availableServer.stubFor(PING_MAPPING.willReturn(WireMock.aResponse().withStatus(204)));\n+\n+        availablePort = availableServer.port();\n+        serverUri = String.format(\"http://%s:%s\", WireMockConfiguration.DEFAULT_BIND_ADDRESS, availablePort);\n+    }\n+\n+    @Test\n+    public void doesNotFallbackOnPingWhenPingV2Responds() {\n+        availableServer.stubFor(PING_V2_MAPPING.willReturn(WireMock.aResponse().withStatus(200)\n+                .withBody(\"{\\\"isLeader\\\":false}\")));\n+        pingerWithVersion(OrderableSlsVersion.valueOf(\"1.1.1\")).pingLeaderWithUuid(REMOTE_UUID);\n+        List<LoggedRequest> requests = WireMock.findAll(WireMock.getRequestedFor(WireMock.urlMatching(PING_V2)));\n+        assertThat(requests.size()).isEqualTo(1);\n+        requests = WireMock.findAll(WireMock.getRequestedFor(WireMock.urlMatching(PING)));\n+        assertThat(requests.size()).isEqualTo(0);\n+    }\n+\n+    @Test\n+    public void fallbackOnPingWhenPingV2DoesNotExist() {\n+        availableServer.stubFor(PING_V2_MAPPING.willReturn(WireMock.aResponse().withStatus(404)));\n+        verifyPingRequests(5, 5);\n+    }\n+\n+    @Test\n+    public void fallbackOnPingWhenPingV2Throws() {\n+        availableServer.stubFor(PING_V2_MAPPING.willReturn(WireMock.aResponse().withStatus(500)));\n+        verifyPingRequests(5, 5);\n+    }\n+\n+    @Test\n+    public void samplesRequestsToFailingPing2() {\n+        availableServer.stubFor(PING_V2_MAPPING.willReturn(WireMock.aResponse().withStatus(500)));\n+        verifyPingRequests(100, 100);\n+    }\n+\n+    public void verifyPingRequests(int totalNumOfPings, int verifyLegacyPingRequests) {\n+        LeaderPinger pinger = pingerWithVersion(OrderableSlsVersion.valueOf(\"1.1.1\"));\n+        IntStream.range(0, totalNumOfPings).forEach(idx -> pinger.pingLeaderWithUuid(REMOTE_UUID));\n+\n+        List<LoggedRequest> requests = WireMock.findAll(WireMock.getRequestedFor(WireMock.urlMatching(PING_V2)));\n+        assertThat(requests.size()).isLessThan(totalNumOfPings);\n+        requests = WireMock.findAll(WireMock.getRequestedFor(WireMock.urlMatching(PING)));\n+        assertThat(requests.size()).isEqualTo(verifyLegacyPingRequests);", "originalCommit": "58b3c37316e9d71b5129d4bc757e64708823e1e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY0MTYxNg==", "url": "https://github.com/palantir/atlasdb/pull/4953#discussion_r475641616", "bodyText": "Unclear if this is something we want to specify in the tests. I guess it's not wrong.", "author": "jeremyk-91", "createdAt": "2020-08-24T14:11:22Z", "path": "atlasdb-config/src/test/java/com/palantir/atlasdb/SinglePingableLeaderTest.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;\n+\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.IntStream;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import com.github.tomakehurst.wiremock.client.MappingBuilder;\n+import com.github.tomakehurst.wiremock.client.WireMock;\n+import com.github.tomakehurst.wiremock.core.WireMockConfiguration;\n+import com.github.tomakehurst.wiremock.junit.WireMockRule;\n+import com.github.tomakehurst.wiremock.verification.LoggedRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.palantir.atlasdb.config.RemotingClientConfigs;\n+import com.palantir.atlasdb.factory.Leaders;\n+import com.palantir.atlasdb.factory.ServiceCreator;\n+import com.palantir.common.concurrent.CheckedRejectionExecutorService;\n+import com.palantir.conjure.java.api.config.service.UserAgent;\n+import com.palantir.conjure.java.api.config.ssl.SslConfiguration;\n+import com.palantir.leader.PingableLeader;\n+import com.palantir.paxos.LeaderPinger;\n+import com.palantir.paxos.LeaderPingerContext;\n+import com.palantir.paxos.SingleLeaderPinger;\n+import com.palantir.sls.versions.OrderableSlsVersion;\n+\n+public class SinglePingableLeaderTest {\n+    private static final UUID LOCAL_UUID = UUID.randomUUID();\n+    private static final UUID REMOTE_UUID = UUID.randomUUID();\n+    private static final UserAgent USER_AGENT = UserAgent.of(UserAgent.Agent.of(\"user-agent\", \"0.27.1\"));\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private static final String PING = \"/leader/ping\";\n+    private static final String PING_V2 = \"/leader/pingV2\";\n+    private static final String UUID_PATH = \"/leader/uuid\";\n+\n+    private static final MappingBuilder PING_MAPPING = WireMock.get(WireMock.urlEqualTo(PING));\n+    private static final MappingBuilder PING_V2_MAPPING = WireMock.get(WireMock.urlEqualTo(PING_V2));\n+    private static final MappingBuilder UUID_MAPPING = WireMock.get(WireMock.urlEqualTo(UUID_PATH));\n+\n+    private static final SslConfiguration SSL_CONFIGURATION\n+            = SslConfiguration.of(Paths.get(\"var/security/trustStore.jks\"));\n+\n+    private int availablePort;\n+    private String serverUri;\n+\n+    @Rule\n+    public WireMockRule availableServer = new WireMockRule(WireMockConfiguration.wireMockConfig().dynamicPort());\n+\n+    @Before\n+    public void setup() {\n+        availableServer.stubFor(UUID_MAPPING.willReturn(aResponse().withStatus(200).withBody(\n+                (\"\\\"\" + REMOTE_UUID.toString() + \"\\\"\").getBytes())));\n+\n+        availableServer.stubFor(PING_MAPPING.willReturn(WireMock.aResponse().withStatus(204)));\n+\n+        availablePort = availableServer.port();\n+        serverUri = String.format(\"http://%s:%s\", WireMockConfiguration.DEFAULT_BIND_ADDRESS, availablePort);\n+    }\n+\n+    @Test\n+    public void doesNotFallbackOnPingWhenPingV2Responds() {\n+        availableServer.stubFor(PING_V2_MAPPING.willReturn(WireMock.aResponse().withStatus(200)\n+                .withBody(\"{\\\"isLeader\\\":false}\")));\n+        pingerWithVersion(OrderableSlsVersion.valueOf(\"1.1.1\")).pingLeaderWithUuid(REMOTE_UUID);\n+        List<LoggedRequest> requests = WireMock.findAll(WireMock.getRequestedFor(WireMock.urlMatching(PING_V2)));\n+        assertThat(requests.size()).isEqualTo(1);\n+        requests = WireMock.findAll(WireMock.getRequestedFor(WireMock.urlMatching(PING)));\n+        assertThat(requests.size()).isEqualTo(0);\n+    }\n+\n+    @Test\n+    public void fallbackOnPingWhenPingV2DoesNotExist() {\n+        availableServer.stubFor(PING_V2_MAPPING.willReturn(WireMock.aResponse().withStatus(404)));\n+        verifyPingRequests(5, 5);\n+    }\n+\n+    @Test\n+    public void fallbackOnPingWhenPingV2Throws() {", "originalCommit": "58b3c37316e9d71b5129d4bc757e64708823e1e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY0MzM2Mw==", "url": "https://github.com/palantir/atlasdb/pull/4953#discussion_r475643363", "bodyText": "Let's not use statics - this should likely be injected into each SingleLeaderPinger.\nThis is \"once every 5 minutes\" - could you include a comment to that effect, and/or extract a constant explaining what this value is?", "author": "jeremyk-91", "createdAt": "2020-08-24T14:13:55Z", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SingleLeaderPinger.java", "diffHunk": "@@ -46,15 +49,17 @@\n import com.palantir.sls.versions.VersionComparator;\n \n public class SingleLeaderPinger implements LeaderPinger {\n-\n     private static final Logger log = LoggerFactory.getLogger(SingleLeaderPinger.class);\n+    private static final RateLimiter pingV2RateLimiter = RateLimiter.create(1.0 / (5 * 60));", "originalCommit": "4a7213328e9d4de4eef5b94ecedf93f0420d818d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9e3d2b3dbc949f6b179040bf9f8a919b391eb365", "url": "https://github.com/palantir/atlasdb/commit/9e3d2b3dbc949f6b179040bf9f8a919b391eb365", "message": "Draft", "committedDate": "2020-08-24T18:53:51Z", "type": "commit"}, {"oid": "d08ed368462a71b326a83450ec388214cbcfbb89", "url": "https://github.com/palantir/atlasdb/commit/d08ed368462a71b326a83450ec388214cbcfbb89", "message": "Estimated effort", "committedDate": "2020-08-24T18:53:51Z", "type": "commit"}, {"oid": "ac206bb367c628fd43b49a01df1d979af66106c3", "url": "https://github.com/palantir/atlasdb/commit/ac206bb367c628fd43b49a01df1d979af66106c3", "message": "Logs", "committedDate": "2020-08-24T18:53:51Z", "type": "commit"}, {"oid": "9bd57c49439dd8abb916c553aa9d6724993f8f7e", "url": "https://github.com/palantir/atlasdb/commit/9bd57c49439dd8abb916c553aa9d6724993f8f7e", "message": "PingableLeaderTest", "committedDate": "2020-08-24T18:53:51Z", "type": "commit"}, {"oid": "ec5addf67f525ec0f1210cb611fad19f6fca89f3", "url": "https://github.com/palantir/atlasdb/commit/ec5addf67f525ec0f1210cb611fad19f6fca89f3", "message": "Cleanup", "committedDate": "2020-08-24T18:53:51Z", "type": "commit"}, {"oid": "c80e0b4e5a04994a8472126e420f4ae67ccbb727", "url": "https://github.com/palantir/atlasdb/commit/c80e0b4e5a04994a8472126e420f4ae67ccbb727", "message": "Refactor | minor", "committedDate": "2020-08-24T18:53:51Z", "type": "commit"}, {"oid": "698056cdb37c61de0a4f1bdf6858533c51827206", "url": "https://github.com/palantir/atlasdb/commit/698056cdb37c61de0a4f1bdf6858533c51827206", "message": "Fix tests", "committedDate": "2020-08-24T18:53:51Z", "type": "commit"}, {"oid": "7ca4ee810f512d4cdf1eafca86ed93ab870e6f54", "url": "https://github.com/palantir/atlasdb/commit/7ca4ee810f512d4cdf1eafca86ed93ab870e6f54", "message": "Add generated changelog entries", "committedDate": "2020-08-24T18:53:51Z", "type": "commit"}, {"oid": "af5c2e329872a713083e265b9e84b5364a874920", "url": "https://github.com/palantir/atlasdb/commit/af5c2e329872a713083e265b9e84b5364a874920", "message": "This is experimental and needs revision", "committedDate": "2020-08-24T18:53:51Z", "type": "commit"}, {"oid": "03e8fc7c7a7fbe5241fe02b8eb386d8dcf328d72", "url": "https://github.com/palantir/atlasdb/commit/03e8fc7c7a7fbe5241fe02b8eb386d8dcf328d72", "message": "More eexperiments", "committedDate": "2020-08-24T18:53:51Z", "type": "commit"}, {"oid": "3e652d220ca92e748697bbfee968266dcbaa0b0d", "url": "https://github.com/palantir/atlasdb/commit/3e652d220ca92e748697bbfee968266dcbaa0b0d", "message": "Ping result for execution exception", "committedDate": "2020-08-24T18:53:51Z", "type": "commit"}, {"oid": "b2049be4d747bf5e1d3f630a8103c7e72cdd24a2", "url": "https://github.com/palantir/atlasdb/commit/b2049be4d747bf5e1d3f630a8103c7e72cdd24a2", "message": "Remove redundant changes", "committedDate": "2020-08-24T18:53:51Z", "type": "commit"}, {"oid": "4249d699fbe9caff1a78b124e192d9dc10e95c9b", "url": "https://github.com/palantir/atlasdb/commit/4249d699fbe9caff1a78b124e192d9dc10e95c9b", "message": "Fix", "committedDate": "2020-08-24T18:53:51Z", "type": "commit"}, {"oid": "73012f79323c7b0dafcefeb8b430c4f45303c44a", "url": "https://github.com/palantir/atlasdb/commit/73012f79323c7b0dafcefeb8b430c4f45303c44a", "message": "Fix test", "committedDate": "2020-08-24T18:53:51Z", "type": "commit"}, {"oid": "34213c2b2e11c62a27064f32c213cf603f286d59", "url": "https://github.com/palantir/atlasdb/commit/34213c2b2e11c62a27064f32c213cf603f286d59", "message": "Modify tests", "committedDate": "2020-08-24T18:53:51Z", "type": "commit"}, {"oid": "0b1631090de700dc8e3010659de9c7a26189da8a", "url": "https://github.com/palantir/atlasdb/commit/0b1631090de700dc8e3010659de9c7a26189da8a", "message": "Refactor", "committedDate": "2020-08-24T18:53:51Z", "type": "commit"}, {"oid": "ddc8a29bb136c45406a76933474669349dc2ee6f", "url": "https://github.com/palantir/atlasdb/commit/ddc8a29bb136c45406a76933474669349dc2ee6f", "message": "Fixes", "committedDate": "2020-08-24T18:53:51Z", "type": "commit"}, {"oid": "479d433fd98c1163bebd509dc9eb6e1e5a141ecd", "url": "https://github.com/palantir/atlasdb/commit/479d433fd98c1163bebd509dc9eb6e1e5a141ecd", "message": "RateLimiter", "committedDate": "2020-08-24T18:53:51Z", "type": "commit"}, {"oid": "260fe4e4a30953c15362ffcc49a42459fd2bf3f7", "url": "https://github.com/palantir/atlasdb/commit/260fe4e4a30953c15362ffcc49a42459fd2bf3f7", "message": "Address comments", "committedDate": "2020-08-24T18:53:51Z", "type": "commit"}, {"oid": "72f85cf6fe4d8a8b97fd8fd8cf54617cca321903", "url": "https://github.com/palantir/atlasdb/commit/72f85cf6fe4d8a8b97fd8fd8cf54617cca321903", "message": "Fix tests", "committedDate": "2020-08-24T18:53:51Z", "type": "commit"}, {"oid": "b684272eb9584e97084bf1ca407a43e732eaa9f0", "url": "https://github.com/palantir/atlasdb/commit/b684272eb9584e97084bf1ca407a43e732eaa9f0", "message": "Refactor", "committedDate": "2020-08-24T18:53:51Z", "type": "commit"}, {"oid": "6a3e3080b075dcba6cb4c4b697083fb95c620e22", "url": "https://github.com/palantir/atlasdb/commit/6a3e3080b075dcba6cb4c4b697083fb95c620e22", "message": "Refactor", "committedDate": "2020-08-24T18:53:51Z", "type": "commit"}, {"oid": "6a3e3080b075dcba6cb4c4b697083fb95c620e22", "url": "https://github.com/palantir/atlasdb/commit/6a3e3080b075dcba6cb4c4b697083fb95c620e22", "message": "Refactor", "committedDate": "2020-08-24T18:53:51Z", "type": "forcePushed"}]}