{"pr_number": 5105, "pr_title": "add cache warming option to ssm", "pr_createdAt": "2020-11-06T19:20:15Z", "pr_url": "https://github.com/palantir/atlasdb/pull/5105", "timeline": [{"oid": "86cd9d783b15ffcc9082247995fe14f182793816", "url": "https://github.com/palantir/atlasdb/commit/86cd9d783b15ffcc9082247995fe14f182793816", "message": "Add generated changelog entries", "committedDate": "2020-11-06T19:22:33Z", "type": "forcePushed"}, {"oid": "c4d841b60769133ca5c7cad52afd42fd894bbe2f", "url": "https://github.com/palantir/atlasdb/commit/c4d841b60769133ca5c7cad52afd42fd894bbe2f", "message": "Add generated changelog entries", "committedDate": "2020-11-06T22:03:42Z", "type": "forcePushed"}, {"oid": "0c8ffccc03163ec45490e8ddd64528def1243081", "url": "https://github.com/palantir/atlasdb/commit/0c8ffccc03163ec45490e8ddd64528def1243081", "message": "add limited cache warming option to ssm\n\nAdds a CacheWarming option that can control how the SweepStrategyManager\ncache is warmed on initialization. The possible options are FULL,\nLIMITED, and NONE. FULL remains the default (so default behavior is not\nchanging). LIMITED causes only a max of 50 tables to be used for warming\nthe cache. NONE skips warming the cache.", "committedDate": "2020-11-06T22:10:15Z", "type": "commit"}, {"oid": "7925a61ccc2da46f102eaede70eddbeeefffd1d2", "url": "https://github.com/palantir/atlasdb/commit/7925a61ccc2da46f102eaede70eddbeeefffd1d2", "message": "Add generated changelog entries", "committedDate": "2020-11-06T22:10:15Z", "type": "commit"}, {"oid": "7925a61ccc2da46f102eaede70eddbeeefffd1d2", "url": "https://github.com/palantir/atlasdb/commit/7925a61ccc2da46f102eaede70eddbeeefffd1d2", "message": "Add generated changelog entries", "committedDate": "2020-11-06T22:10:15Z", "type": "forcePushed"}, {"oid": "1c4c40ad591bfa0d6df700646e298c930ac4d383", "url": "https://github.com/palantir/atlasdb/commit/1c4c40ad591bfa0d6df700646e298c930ac4d383", "message": "fix limited metadata tests for cassandra\n\nThe Cassandra integration tests leave table metadata in an inconsistent\nstate which was causing the new test to fail. Adds a workaround where\nall tables are dropped at the start of this test.", "committedDate": "2020-11-07T00:08:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5MTYzNA==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520091634", "bodyText": "do we want a max size on this cache to limit memory footprint?", "author": "schlosna", "createdAt": "2020-11-09T20:13:04Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java", "diffHunk": "@@ -45,9 +56,8 @@ public static SweepStrategyManager createDefault(KeyValueService kvs) {\n                             .expireAfterAccess(1, TimeUnit.DAYS)", "originalCommit": "1c4c40ad591bfa0d6df700646e298c930ac4d383", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIzMjc5OA==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520232798", "bodyText": "I don't think so, considering the default is to pre-warm the cache with all tables. The intended use case is that there won't be very many tables. If we had a max size here it seems like you could get very bad sweep perf once you have more than that amount of tables.", "author": "berler", "createdAt": "2020-11-10T01:44:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5MTYzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5MjYzNA==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520092634", "bodyText": "How much value is there in having a separate LIMITED mode between FULL and NONE? If we set to NONE and just let the cache warm up on its own based on requests, what behavior would we see? How did we pick 50? Are the first 50 tables actually the ones we want cached?", "author": "schlosna", "createdAt": "2020-11-09T20:14:49Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java", "diffHunk": "@@ -84,9 +94,18 @@ public static SweepStrategyManager completelyConservative() {\n         return tableRef -> SweepStrategy.from(TableMetadataPersistence.SweepStrategy.CONSERVATIVE);\n     }\n \n-    private static Map<TableReference, SweepStrategy> getSweepStrategies(KeyValueService kvs) {\n-        return ImmutableMap.copyOf(\n-                Maps.transformValues(kvs.getMetadataForTables(), SweepStrategyManagers::getSweepStrategy));\n+    private static Map<TableReference, SweepStrategy> getSweepStrategiesForWarmingCache(\n+            KeyValueService kvs, CacheWarming cacheWarming) {\n+        switch (cacheWarming) {\n+            case FULL:\n+                return Maps.transformValues(kvs.getMetadataForTables(), SweepStrategyManagers::getSweepStrategy);\n+            case LIMITED:\n+                return Maps.transformValues(\n+                        kvs.getLimitedMetadataForTables(50), SweepStrategyManagers::getSweepStrategy);", "originalCommit": "1c4c40ad591bfa0d6df700646e298c930ac4d383", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIzMzU2OA==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520233568", "bodyText": "50 was recommended I believe by @jeremyk-91 when this was discussed a while ago internally", "author": "berler", "createdAt": "2020-11-10T01:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5MjYzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5NDU1NA==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520094554", "bodyText": "Should this be a paged result? What is the epoch for concurrent consistency (e.g. tables created while this is executing)? What happens if one specifies various values for maxResults, say 0, -1, Integer.MAX_VALUE? I'm a little skeptical we even need these methods, but wondering if we actually do should instead consider something like Stream<TableReference> getTableNames() and let consumers filter/limit/transform/collect as desired.", "author": "schlosna", "createdAt": "2020-11-09T20:18:23Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/KeyValueService.java", "diffHunk": "@@ -524,6 +524,14 @@ void deleteAllTimestamps(TableReference tableRef, Map<Cell, TimestampRangeDelete\n     @Idempotent\n     Set<TableReference> getAllTableNames();\n \n+    /**\n+     * Returns a list of up to {@code maxResults} tables stored in this key value service.\n+     *\n+     * This should be preferred over {@link #getAllTableNames()} if possible because the number of tables may be\n+     * unbounded.\n+     */\n+    Iterable<TableReference> getLimitedTableNames(int maxResults);", "originalCommit": "1c4c40ad591bfa0d6df700646e298c930ac4d383", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3MTY1Mg==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520171652", "bodyText": "I was thinking about that, but it is significantly more complicated to implement correctly. Additionally the caller would need to call close() on the Stream, which is not something that is usually done in general (calling .collect() etc doesn't do it), so it would be really easy for people to leak resources if we made this a Stream.\nCloseableIterator or something similar might make more sense, but it would also be more complicated to implement.\nIn general I think we should be discouraging anything that would try to enumerate all tables in the system. Clients can only interact with tables if they know about some Schema, and clients should be using the Schema to know what tables it needs to care about.", "author": "berler", "createdAt": "2020-11-09T22:50:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5NDU1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyMzUzNg==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520423536", "bodyText": "The guarantees are exactly the same as with getAllTableNames, so I'm OK with that", "author": "gmaretic", "createdAt": "2020-11-10T09:43:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5NDU1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5NDY3Mg==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520094672", "bodyText": "same comment as above", "author": "schlosna", "createdAt": "2020-11-09T20:18:39Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/KeyValueService.java", "diffHunk": "@@ -543,6 +551,14 @@ void deleteAllTimestamps(TableReference tableRef, Map<Cell, TimestampRangeDelete\n     @Idempotent\n     Map<TableReference, byte[]> getMetadataForTables();\n \n+    /**\n+     * Gets the metadata for up to {@code maxResults} tables.\n+     *\n+     * This should be preferred over {@link #getMetadataForTables()} if possible because the number of tables may be\n+     * unbounded.\n+     */\n+    Map<TableReference, byte[]> getLimitedMetadataForTables(int maxResults);", "originalCommit": "1c4c40ad591bfa0d6df700646e298c930ac4d383", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5NTI2OQ==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520095269", "bodyText": "Similar to above, should these lines (same as in getAllTableNames())  be pulled out to a separate method that returns Stream<TableReference>?", "author": "schlosna", "createdAt": "2020-11-09T20:19:41Z", "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -1481,6 +1481,16 @@ public void createTables(final Map<TableReference, byte[]> tablesToMetadata) {\n                 .collect(Collectors.toSet());\n     }\n \n+    @Override\n+    public Iterable<TableReference> getLimitedTableNames(int maxResults) {\n+        // Note: This is not optimal since getTableReferencesWithoutFiltering() loads *all* names, even though it\n+        // returns a Stream. Getting a partial list of table names might not be possible with cassandra thrift.\n+        return cassandraTables\n+                .getTableReferencesWithoutFiltering()\n+                .filter(tr -> !HiddenTables.isHidden(tr))", "originalCommit": "1c4c40ad591bfa0d6df700646e298c930ac4d383", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzMDA1Mw==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520430053", "bodyText": "This comment seems to have been wron all along, has nothing to do with async initialisation?", "author": "gmaretic", "createdAt": "2020-11-10T09:53:09Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java", "diffHunk": "@@ -45,9 +56,8 @@ public static SweepStrategyManager createDefault(KeyValueService kvs) {\n                             .expireAfterAccess(1, TimeUnit.DAYS)\n                             .build(tableRef -> getSweepStrategy(kvs.getMetadataForTable(tableRef)));\n \n-                    // On async initialization, add all tables to optimize for cases when using mostly non-dynamic\n-                    // tables.\n-                    cache.putAll(getSweepStrategies(kvs));\n+                    // On async initialization, add a possibly limited number of tables to the cache.", "originalCommit": "1c4c40ad591bfa0d6df700646e298c930ac4d383", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxOTIxNQ==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520919215", "bodyText": "things do init async -- this happens the first time it attempts to be used because this is inside a RecomputingSupplier", "author": "berler", "createdAt": "2020-11-10T22:38:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzMDA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzNTY4OA==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520435688", "bodyText": "Any reason why not to slab on a \"LIMIT maxResults\"?", "author": "gmaretic", "createdAt": "2020-11-10T10:01:03Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/impl/DbKvs.java", "diffHunk": "@@ -1137,6 +1138,26 @@ public void createTable(TableReference tableRef, byte[] tableMetadata) {\n         });\n     }\n \n+    @Override\n+    public Iterable<TableReference> getLimitedTableNames(int maxResults) {\n+        if (maxResults <= 0) {\n+            return Collections.emptyList();\n+        }\n+        return run(conn -> {\n+            try (AgnosticLightResultSet rows = conn.selectLightResultSetUnregisteredQuery(\n+                    \"SELECT table_name FROM \" + config.metadataTable().getQualifiedName())) {", "originalCommit": "1c4c40ad591bfa0d6df700646e298c930ac4d383", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MTA1Mw==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520761053", "bodyText": "The limit syntax is completely different in postgres and oracle. We cannot just add a limit clause here unless we do something completely different for postgres and oracle.\nFrom a perf standpoint there shouldn't be very much difference between using a limit and only iterating through the ResultSet part way unless the configured prefetch is huge -- the AgnosticIterator impl in AgnosticLightResultSetImpl always sets the initial prefetch to 10, and doubles it (up to a max) after each batch is fetched.", "author": "berler", "createdAt": "2020-11-10T17:58:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzNTY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzNjI1OQ==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520436259", "bodyText": "Same as above", "author": "gmaretic", "createdAt": "2020-11-10T10:01:52Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/impl/DbKvs.java", "diffHunk": "@@ -1163,6 +1184,26 @@ public void putMetadataForTable(TableReference tableRef, byte[] metadata) {\n         });\n     }\n \n+    @Override\n+    public Map<TableReference, byte[]> getLimitedMetadataForTables(int maxResults) {\n+        if (maxResults <= 0) {\n+            return Collections.emptyMap();\n+        }\n+        return run(conn -> {\n+            try (AgnosticLightResultSet rows = conn.selectLightResultSetUnregisteredQuery(\n+                    \"SELECT table_name, value FROM \" + config.metadataTable().getQualifiedName())) {", "originalCommit": "1c4c40ad591bfa0d6df700646e298c930ac4d383", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzNzg3Mg==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520437872", "bodyText": "Pretty clever \ud83d\udc4d", "author": "gmaretic", "createdAt": "2020-11-10T10:04:17Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/impl/TableSplittingKeyValueService.java", "diffHunk": "@@ -195,6 +195,23 @@ public void dropTables(Set<TableReference> tableRefs) {\n         return ret;\n     }\n \n+    @Override\n+    public Iterable<TableReference> getLimitedTableNames(int maxResults) {\n+        Set<TableReference> ret = new HashSet<>();\n+        for (KeyValueService delegate : delegates) {\n+            // Note that this looks suboptimal, but there could be some overlap to the tables in each delegate.\n+            // If there is some overlap, we should at least reach maxResults (or the true total) by requesting\n+            // maxResults from each underlying KVS.\n+            for (TableReference tableRef : delegate.getLimitedTableNames(maxResults)) {", "originalCommit": "1c4c40ad591bfa0d6df700646e298c930ac4d383", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7ff34c808b6069446eaabd422d2e07232938aece", "url": "https://github.com/palantir/atlasdb/commit/7ff34c808b6069446eaabd422d2e07232938aece", "message": "remove getLimited versions of get tables/metadata\n\nTo avoid complexity, reducing change to just support FULL and NONE as\npossible options for cache warming. If desired we could implement\nlimited versions later with streams etc, but NONE should fix the\ninternal issue.", "committedDate": "2020-11-10T22:39:42Z", "type": "commit"}, {"oid": "7ff34c808b6069446eaabd422d2e07232938aece", "url": "https://github.com/palantir/atlasdb/commit/7ff34c808b6069446eaabd422d2e07232938aece", "message": "remove getLimited versions of get tables/metadata\n\nTo avoid complexity, reducing change to just support FULL and NONE as\npossible options for cache warming. If desired we could implement\nlimited versions later with streams etc, but NONE should fix the\ninternal issue.", "committedDate": "2020-11-10T22:39:42Z", "type": "forcePushed"}]}