{"pr_number": 4806, "pr_title": "[LW] Client side event cache", "pr_createdAt": "2020-05-27T14:43:16Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4806", "timeline": [{"oid": "166d1e5a081cb800d7f2be010ad796e60e4efa5c", "url": "https://github.com/palantir/atlasdb/commit/166d1e5a081cb800d7f2be010ad796e60e4efa5c", "message": "even more synchreo", "committedDate": "2020-06-02T12:08:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgyNjU1Mw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433826553", "bodyText": "I think this needs a fix, for in-memory: you need to put dummy values into startTsToSequence for the passed transactions. Otherwise, atlasdb-proxy will start throwing.", "author": "jkozlowski", "createdAt": "2020-06-02T12:09:13Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/NoOpLockWatchEventCache.java", "diffHunk": "@@ -19,15 +19,13 @@\n import java.util.Collection;\n import java.util.Optional;\n import java.util.Set;\n-import java.util.UUID;\n-\n-import com.google.common.collect.ImmutableSet;\n \n @SuppressWarnings(\"FinalClass\") // mocks\n public class NoOpLockWatchEventCache implements LockWatchEventCache {\n     public static final LockWatchEventCache INSTANCE = new NoOpLockWatchEventCache();\n-    private static final TransactionsLockWatchEvents NONE = TransactionsLockWatchEvents.failure(\n-            LockWatchStateUpdate.snapshot(UUID.randomUUID(), -1L, ImmutableSet.of(), ImmutableSet.of()));\n+    private static final TransactionsLockWatchEvents NONE = ImmutableTransactionsLockWatchEvents.builder()\n+            .clearCache(true)", "originalCommit": "b37f0b3357c7717268efec75c15489a0f74be40a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgzMzc1NA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433833754", "bodyText": "Good catch", "author": "Jolyon-S", "createdAt": "2020-06-02T12:22:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgyNjU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgyODc5NA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433828794", "bodyText": "The return type here feels wrong: why are you returning a builder?", "author": "jkozlowski", "createdAt": "2020-06-02T12:13:23Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLog.java", "diffHunk": "@@ -16,17 +16,12 @@\n \n package com.palantir.lock.watch;\n \n-import java.util.Collection;\n import java.util.Optional;\n-import java.util.Set;\n \n-public interface LockWatchEventCache {\n-    Optional<IdentifiedVersion> lastKnownVersion();\n-    void processStartTransactionsUpdate(Set<Long> startTimestamps, LockWatchStateUpdate update);\n-    void processGetCommitTimestampsUpdate(Collection<TransactionUpdate> transactionUpdates,\n-            LockWatchStateUpdate update);\n-    CommitUpdate getCommitUpdate(long startTs);\n-    TransactionsLockWatchEvents getEventsForTransactions(Set<Long> startTimestamps,\n-            Optional<IdentifiedVersion> version);\n-    void removeTransactionStateFromCache(long startTimestamp);\n+public interface ClientLockWatchEventLog {\n+    ImmutableTransactionsLockWatchEvents.Builder getEventsBetweenVersions(", "originalCommit": "166d1e5a081cb800d7f2be010ad796e60e4efa5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgzNDQwMA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433834400", "bodyText": "Reason is that we need to return\na) whether we had a snapshot or not;\nb) a list of events\nThat's 2/3 of the return object at the cache level anyway. So we can either create a new type for this particular method, or return the builder for the cache to add the map and return it up. I'm open to going for the other route if you think that makes it cleaner.", "author": "Jolyon-S", "createdAt": "2020-06-02T12:24:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgyODc5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg0NTg3NA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433845874", "bodyText": "Let's not do it the way you have it right now, it rather breaks the usual mental model with builders and whatnot. And you introduce a rather hidden and weird dependency between them.", "author": "jkozlowski", "createdAt": "2020-06-02T12:44:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgyODc5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg2MzM5OA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433863398", "bodyText": "Done", "author": "Jolyon-S", "createdAt": "2020-06-02T13:12:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgyODc5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg3MzUwMw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433873503", "bodyText": "Done", "author": "Jolyon-S", "createdAt": "2020-06-02T13:27:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgyODc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgzMDIwNw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433830207", "bodyText": "Going to read through these later, but given my gut feeling that these 2 classes will be rather coupled, would be good to have a single integration test that tests it end to end.", "author": "jkozlowski", "createdAt": "2020-06-02T12:16:10Z", "path": "lock-api/src/test/java/com/palantir/lock/watch/ClientLockWatchEventLogImplTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.v2.LockToken;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public final class ClientLockWatchEventLogImplTest {\n+    private static final UUID LEADER = UUID.randomUUID();\n+    private static final IdentifiedVersion VERSION_1 = IdentifiedVersion.of(LEADER, 17L);\n+    private static final IdentifiedVersion VERSION_2 = IdentifiedVersion.of(LEADER, 25L);\n+    private static final LockWatchEvent EVENT_1 =\n+            LockEvent.builder(ImmutableSet.of(), LockToken.of(UUID.randomUUID())).build(17L);\n+    private static final LockWatchEvent EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(), LockToken.of(UUID.randomUUID())).build(25L);\n+    private static final LockWatchStateUpdate.Snapshot SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(VERSION_1.id(), VERSION_1.version(), ImmutableSet.of(), ImmutableSet.of());\n+    private static final LockWatchStateUpdate.Success SUCCESS =\n+            LockWatchStateUpdate.success(VERSION_2.id(), VERSION_2.version(), ImmutableList.of(EVENT_1, EVENT_2));\n+    private static final LockWatchStateUpdate.Failed FAILED =\n+            LockWatchStateUpdate.failed(LEADER);\n+\n+    @Mock\n+    private ClientLockWatchSnapshotUpdater snapshotUpdater;", "originalCommit": "166d1e5a081cb800d7f2be010ad796e60e4efa5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg4NjE2Mw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433886163", "bodyText": "I agree with this, will write an integration test once I'm done with other comments", "author": "Jolyon-S", "createdAt": "2020-06-02T13:44:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgzMDIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0MjY3MA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434442670", "bodyText": "Done", "author": "Jolyon-S", "createdAt": "2020-06-03T09:43:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgzMDIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgzMjk3Nw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433832977", "bodyText": "So I understand that you added this in response to @j-baker comment, but I think as it is it's not really adding much value, beyond detecting a failure and not letting yourself continue to get corrupted. I quite like the defensiveness here in case we have bugs, but I think you need to finish the stroke and switch to a NoOpCache at runtime.\nAlso, I would argue this will be implemented cleaner as FailureCheckingLockWatchEventCache, as a proxy.", "author": "jkozlowski", "createdAt": "2020-06-02T12:21:21Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class ClientLockWatchEventLogImpl implements ClientLockWatchEventLog {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final ClientLockWatchSnapshotUpdater snapshotUpdater;\n+    private final TreeMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    @GuardedBy(\"this\")\n+    private boolean failed = false;\n+    @GuardedBy(\"this\")\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    public static ClientLockWatchEventLogImpl create() {\n+        return create(ClientLockWatchSnapshotUpdaterImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static ClientLockWatchEventLogImpl create(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        return new ClientLockWatchEventLogImpl(snapshotUpdater);\n+    }\n+\n+    private ClientLockWatchEventLogImpl(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        this.snapshotUpdater = snapshotUpdater;\n+    }\n+\n+    @Override\n+    public synchronized Optional<IdentifiedVersion> processUpdate(LockWatchStateUpdate update) {\n+        ensureNotFailed(() -> {\n+            final ProcessingVisitor visitor;\n+            if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+                visitor = new NewLeaderVisitor();\n+            } else {\n+                visitor = new ProcessingVisitor();\n+            }\n+            update.accept(visitor);\n+        });\n+        return latestVersion;\n+    }\n+\n+    @Override\n+    public synchronized void removeOldEntries(IdentifiedVersion earliestVersion) {\n+        ensureNotFailed(() -> {\n+            Set<Map.Entry<Long, LockWatchEvent>> eventsToBeRemoved =\n+                    eventMap.headMap(earliestVersion.version()).entrySet();\n+            snapshotUpdater.processEvents(\n+                    eventsToBeRemoved.stream().map(Map.Entry::getValue).collect(Collectors.toList()));\n+            eventsToBeRemoved.clear();\n+        });\n+    }\n+\n+    /**\n+     * @param startVersion latest version that the client knows about; should be before timestamps in the mapping;\n+     * @param endVersion   mapping from timestamp to identified version from client-side event cache;\n+     * @return lock watch events that occurred from (exclusive) the provided version, up to (inclusive) the latest\n+     * version in the timestamp to version map.\n+     */\n+    @Override\n+    public synchronized ImmutableTransactionsLockWatchEvents.Builder getEventsBetweenVersions(\n+            Optional<IdentifiedVersion> startVersion,\n+            IdentifiedVersion endVersion) {\n+        checkNotFailed();\n+        Optional<IdentifiedVersion> versionInclusive = startVersion.map(this::createInclusiveVersion);\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(endVersion);\n+        ImmutableTransactionsLockWatchEvents.Builder eventBuilder = ImmutableTransactionsLockWatchEvents.builder();\n+        List<LockWatchEvent> events = new ArrayList<>();\n+        final long fromSequence;\n+\n+        if (!versionInclusive.isPresent() || differentLeaderOrTooFarBehind(currentVersion, versionInclusive.get())) {\n+            events.add(LockWatchCreatedEvent.fromSnapshot(snapshotUpdater.getSnapshot(currentVersion)));\n+            fromSequence = eventMap.firstKey();\n+            eventBuilder.clearCache(true);\n+        } else {\n+            fromSequence = versionInclusive.get().version();\n+            eventBuilder.clearCache(false);\n+        }\n+\n+        events.addAll(eventMap.subMap(fromSequence, INCLUSIVE, endVersion.version(), INCLUSIVE).values());\n+        return eventBuilder.events(events);\n+    }\n+\n+    @Override\n+    public synchronized Optional<IdentifiedVersion> getLatestKnownVersion() {\n+        checkNotFailed();\n+        return latestVersion;\n+    }\n+\n+    private synchronized void ensureNotFailed(Runnable runnable) {\n+        checkNotFailed();", "originalCommit": "166d1e5a081cb800d7f2be010ad796e60e4efa5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzUwMA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433857500", "bodyText": "Done", "author": "Jolyon-S", "createdAt": "2020-06-02T13:03:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgzMjk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgzNDE2Mg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433834162", "bodyText": "Similarly to previous comments, you probably want this implemented just once and poison the entire thing.", "author": "jkozlowski", "createdAt": "2020-06-02T12:23:41Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final HashMap<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    @GuardedBy(\"this\")\n+    private boolean failed = false;", "originalCommit": "166d1e5a081cb800d7f2be010ad796e60e4efa5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg2MzI0Mg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433863242", "bodyText": "Done", "author": "Jolyon-S", "createdAt": "2020-06-02T13:12:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgzNDE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgzOTMzMw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433839333", "bodyText": "I don't feel like this comparator should be here: it's a pretty specific assumption/underlying design decision in your LockWatchEventCacheImpl, so should be implemented there.", "author": "jkozlowski", "createdAt": "2020-06-02T12:33:03Z", "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/IdentifiedVersion.java", "diffHunk": "@@ -16,14 +16,28 @@\n \n package com.palantir.lock.watch;\n \n+import java.util.Comparator;\n import java.util.UUID;\n \n import org.immutables.value.Value;\n \n+import com.palantir.logsafe.Preconditions;\n+\n @Value.Immutable\n public interface IdentifiedVersion {\n     @Value.Parameter\n     UUID id();\n     @Value.Parameter\n     long version();\n+\n+    static IdentifiedVersion of(UUID id, long version) {\n+        return ImmutableIdentifiedVersion.of(id, version);\n+    }\n+\n+    static Comparator<IdentifiedVersion> comparator() {\n+        return (version1, version2) -> {\n+            Preconditions.checkArgument(version1.id().equals(version2.id()), \"Versions do not have same leader id\");", "originalCommit": "166d1e5a081cb800d7f2be010ad796e60e4efa5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg2OTMzMA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433869330", "bodyText": "I use it once in ClientLockWatchEventLogImpl too, hence my reluctance to remove from that class.", "author": "Jolyon-S", "createdAt": "2020-06-02T13:21:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgzOTMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyNDY5MQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433924691", "bodyText": "And now is used across three classes (since I split it out), so I will leave there.", "author": "Jolyon-S", "createdAt": "2020-06-02T14:33:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgzOTMzMw=="}], "type": "inlineReview"}, {"oid": "355f5e2029025c9ee5a89497eab6c6d8c96f7dcb", "url": "https://github.com/palantir/atlasdb/commit/355f5e2029025c9ee5a89497eab6c6d8c96f7dcb", "message": "use proxy with event cache instad of implementing with methods", "committedDate": "2020-06-02T12:46:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg0Nzg1Mw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433847853", "bodyText": "Is this the only case here? I feel like there's a legitimate case of \"leader switched\", in which case you should throw an exception that will cause the transaction to retry.\nPlease review all places that you throw here and probably introduce some custom exceptions that extend TransactionFailedRetriableException.", "author": "jkozlowski", "createdAt": "2020-06-02T12:47:37Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final HashMap<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    @GuardedBy(\"this\")\n+    private boolean failed = false;\n+\n+\n+    private LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+    }\n+\n+    public static LockWatchEventCacheImpl create() {\n+        return create(ClientLockWatchEventLogImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventCacheImpl create(ClientLockWatchEventLog eventLog) {\n+        return new LockWatchEventCacheImpl(eventLog);\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public synchronized void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        ensureNotFailed(() -> {\n+            Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+            latestVersion.ifPresent(\n+                    version -> startTimestamps.forEach(timestamp -> {\n+                        timestampMap.put(timestamp, MapEntry.of(version));\n+                        aliveVersions.put(version, timestamp);\n+                    }));\n+        });\n+    }\n+\n+    @Override\n+    public synchronized void processGetCommitTimestampsUpdate(\n+            Collection<TransactionUpdate> transactionUpdates,\n+            LockWatchStateUpdate update) {\n+        ensureNotFailed(() -> {\n+            Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+            latestVersion.ifPresent(version ->\n+                    transactionUpdates.forEach(transactionUpdate -> {\n+                        MapEntry previousEntry = timestampMap.get(transactionUpdate.startTs());\n+                        Preconditions.checkNotNull(previousEntry, \"Start timestamp missing from cache\");\n+                        timestampMap.replace(transactionUpdate.startTs(), previousEntry.withCommitInfo(\n+                                CommitInfo.of(transactionUpdate.commitTs(),\n+                                        transactionUpdate.writesToken(),\n+                                        version)));\n+                    }));\n+        });\n+    }\n+\n+    @Override\n+    public synchronized CommitUpdate getCommitUpdate(long startTs) {\n+        checkNotFailed();\n+        MapEntry entry = timestampMap.get(startTs);\n+        Preconditions.checkState(entry.commitInfo().isPresent(), \"Commit timestamp update not yet processed\");", "originalCommit": "166d1e5a081cb800d7f2be010ad796e60e4efa5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg0ODMwNQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433848305", "bodyText": "Oh wait, this one is fine.", "author": "jkozlowski", "createdAt": "2020-06-02T12:48:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg0Nzg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg0ODQ1OQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433848459", "bodyText": "I mentioned this in a comment today - I think throwing a retriable exception sounds reasonable.", "author": "Jolyon-S", "createdAt": "2020-06-02T12:48:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg0Nzg1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg0ODYzMQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433848631", "bodyText": "What if this returns null? I feel like there's a legitimate case of \"leader switched therefore I nuked all my state\", in which case you should throw an exception that will cause the transaction to retry.\nPlease review all places that you throw here and probably introduce some custom exceptions that extend TransactionFailedRetriableException.", "author": "jkozlowski", "createdAt": "2020-06-02T12:48:58Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final HashMap<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    @GuardedBy(\"this\")\n+    private boolean failed = false;\n+\n+\n+    private LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+    }\n+\n+    public static LockWatchEventCacheImpl create() {\n+        return create(ClientLockWatchEventLogImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventCacheImpl create(ClientLockWatchEventLog eventLog) {\n+        return new LockWatchEventCacheImpl(eventLog);\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public synchronized void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        ensureNotFailed(() -> {\n+            Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+            latestVersion.ifPresent(\n+                    version -> startTimestamps.forEach(timestamp -> {\n+                        timestampMap.put(timestamp, MapEntry.of(version));\n+                        aliveVersions.put(version, timestamp);\n+                    }));\n+        });\n+    }\n+\n+    @Override\n+    public synchronized void processGetCommitTimestampsUpdate(\n+            Collection<TransactionUpdate> transactionUpdates,\n+            LockWatchStateUpdate update) {\n+        ensureNotFailed(() -> {\n+            Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+            latestVersion.ifPresent(version ->\n+                    transactionUpdates.forEach(transactionUpdate -> {\n+                        MapEntry previousEntry = timestampMap.get(transactionUpdate.startTs());\n+                        Preconditions.checkNotNull(previousEntry, \"Start timestamp missing from cache\");\n+                        timestampMap.replace(transactionUpdate.startTs(), previousEntry.withCommitInfo(\n+                                CommitInfo.of(transactionUpdate.commitTs(),\n+                                        transactionUpdate.writesToken(),\n+                                        version)));\n+                    }));\n+        });\n+    }\n+\n+    @Override\n+    public synchronized CommitUpdate getCommitUpdate(long startTs) {\n+        checkNotFailed();\n+        MapEntry entry = timestampMap.get(startTs);", "originalCommit": "166d1e5a081cb800d7f2be010ad796e60e4efa5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg4Njc2Mg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433886762", "bodyText": "Done for this class; the places that throw in the underlying class should only throw if it is in some inconsistent state.", "author": "Jolyon-S", "createdAt": "2020-06-02T13:45:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg0ODYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1MTQ4OQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433851489", "bodyText": "I think you should make this whole class use synchronized on all it's methods, and not bother with synchronized everywhere else, feels to me like unnecessary noise.", "author": "jkozlowski", "createdAt": "2020-06-02T12:53:38Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final HashMap<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    @GuardedBy(\"this\")\n+    private boolean failed = false;\n+\n+\n+    private LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+    }\n+\n+    public static LockWatchEventCacheImpl create() {\n+        return create(ClientLockWatchEventLogImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventCacheImpl create(ClientLockWatchEventLog eventLog) {\n+        return new LockWatchEventCacheImpl(eventLog);\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public synchronized void processStartTransactionsUpdate(", "originalCommit": "166d1e5a081cb800d7f2be010ad796e60e4efa5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxODE0MA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433918140", "bodyText": "Done via the proxy.", "author": "Jolyon-S", "createdAt": "2020-06-02T14:24:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1MTQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1MjM0OA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433852348", "bodyText": "This should hopefully go away once we get rid of Failure case in the timelock API.", "author": "jkozlowski", "createdAt": "2020-06-02T12:55:04Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchSnapshotUpdater.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.List;\n+\n+public interface ClientLockWatchSnapshotUpdater {\n+    LockWatchStateUpdate.Snapshot getSnapshot(IdentifiedVersion identifiedVersion);\n+    void processEvents(List<LockWatchEvent> events);\n+    void resetWithSnapshot(LockWatchStateUpdate.Snapshot snapshot);\n+    void reset();", "originalCommit": "166d1e5a081cb800d7f2be010ad796e60e4efa5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg3MjEwMw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433872103", "bodyText": "Yes it will.", "author": "Jolyon-S", "createdAt": "2020-06-02T13:25:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1MjM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1MzQwNg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433853406", "bodyText": "Now that you have this proxy, perhaps you can remove sychronized everywhere else?", "author": "jkozlowski", "createdAt": "2020-06-02T12:56:45Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/FailureCheckingLockWatchEventCache.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+\n+import com.google.common.reflect.AbstractInvocationHandler;\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+\n+public final class FailureCheckingLockWatchEventCache extends AbstractInvocationHandler {\n+\n+    public static LockWatchEventCache newProxyInstance(LockWatchEventCache defaultCache) {\n+        return (LockWatchEventCache) Proxy.newProxyInstance(\n+                LockWatchEventCache.class.getClassLoader(),\n+                new Class<?>[] {LockWatchEventCache.class},\n+                new FailureCheckingLockWatchEventCache(defaultCache));\n+    }\n+\n+    private final LockWatchEventCache defaultCache;\n+    private final LockWatchEventCache noOpCache;\n+\n+    @GuardedBy(\"this\")\n+    private boolean hasFailed = false;\n+\n+    private FailureCheckingLockWatchEventCache(LockWatchEventCache defaultCache) {\n+        this.defaultCache = defaultCache;\n+        this.noOpCache = NoOpLockWatchEventCache.INSTANCE;\n+    }\n+\n+    @Override\n+    protected synchronized Object handleInvocation(Object proxy, Method method, Object[] args) throws Throwable {", "originalCommit": "355f5e2029025c9ee5a89497eab6c6d8c96f7dcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5MDM5NQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433890395", "bodyText": "Done, although the downside is that it makes it a little less clear from the outside that this is a single-threaded class (I've added some javadoc to hopefully remediate that).", "author": "Jolyon-S", "createdAt": "2020-06-02T13:50:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1MzQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NDQwMg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433854402", "bodyText": "This constructor should ideally return LockWatchEventCache and be already wrapped in the FailureDetecting thing", "author": "jkozlowski", "createdAt": "2020-06-02T12:58:25Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final HashMap<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    private LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+    }\n+\n+    public static LockWatchEventCacheImpl create() {", "originalCommit": "355f5e2029025c9ee5a89497eab6c6d8c96f7dcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg3MTkzOQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433871939", "bodyText": "Done", "author": "Jolyon-S", "createdAt": "2020-06-02T13:25:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NDQwMg=="}], "type": "inlineReview"}, {"oid": "3c1e82d4b57d44af79ca61d308a9c1a4e0a5fb6c", "url": "https://github.com/palantir/atlasdb/commit/3c1e82d4b57d44af79ca61d308a9c1a4e0a5fb6c", "message": "Remove builder return type", "committedDate": "2020-06-02T13:03:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzcwMA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433857700", "bodyText": "I feel you might want to have a separate class that manipulates these 2 datastructures in tandem, separate from this class which orchestrates all the datastructures.", "author": "jkozlowski", "createdAt": "2020-06-02T13:03:42Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final HashMap<Long, MapEntry> timestampMap = new HashMap<>();", "originalCommit": "355f5e2029025c9ee5a89497eab6c6d8c96f7dcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxNzg5NQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433917895", "bodyText": "Done, and I think its a bit nicer.", "author": "Jolyon-S", "createdAt": "2020-06-02T14:24:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1ODYwNQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433858605", "bodyText": "You probably want:\nOptional.ofNullable(timestampMap.remove(startTimestamp)).ifPresent(entry -> {\n  aliveVersions.remove(...);\n});", "author": "jkozlowski", "createdAt": "2020-06-02T13:05:08Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final HashMap<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    private LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+    }\n+\n+    public static LockWatchEventCacheImpl create() {\n+        return create(ClientLockWatchEventLogImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventCacheImpl create(ClientLockWatchEventLog eventLog) {\n+        return new LockWatchEventCacheImpl(eventLog);\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public synchronized void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(\n+                version -> startTimestamps.forEach(timestamp -> {\n+                    timestampMap.put(timestamp, MapEntry.of(version));\n+                    aliveVersions.put(version, timestamp);\n+                }));\n+    }\n+\n+    @Override\n+    public synchronized void processGetCommitTimestampsUpdate(\n+            Collection<TransactionUpdate> transactionUpdates,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(version ->\n+                transactionUpdates.forEach(transactionUpdate -> {\n+                    MapEntry previousEntry = timestampMap.get(transactionUpdate.startTs());\n+                    Preconditions.checkNotNull(previousEntry, \"Start timestamp missing from cache\");\n+                    timestampMap.replace(transactionUpdate.startTs(), previousEntry.withCommitInfo(\n+                            CommitInfo.of(transactionUpdate.commitTs(),\n+                                    transactionUpdate.writesToken(),\n+                                    version)));\n+                }));\n+    }\n+\n+    @Override\n+    public synchronized CommitUpdate getCommitUpdate(long startTs) {\n+        MapEntry entry = timestampMap.get(startTs);\n+        Preconditions.checkState(entry.commitInfo().isPresent(), \"Commit timestamp update not yet processed\");\n+        CommitInfo commitInfo = entry.commitInfo().get();\n+\n+        TransactionsLockWatchEvents update =\n+                eventLog.getEventsBetweenVersions(Optional.of(entry.version()), commitInfo.commitVersion()).build();\n+\n+        if (update.clearCache()) {\n+            return ImmutableInvalidateAll.builder().build();\n+        }\n+\n+        return constructCommitUpdate(commitInfo, update.events());\n+    }\n+\n+    @Override\n+    public synchronized TransactionsLockWatchEvents getEventsForTransactions(\n+            Set<Long> startTimestamps,\n+            Optional<IdentifiedVersion> startVersion) {\n+        Preconditions.checkArgument(!startTimestamps.isEmpty(), \"Cannot get events for empty set of tranasctions\");\n+        Map<Long, IdentifiedVersion> timestampToVersion = getTimestampToVersionMap(startTimestamps);\n+        IdentifiedVersion endVersion = Collections.max(timestampToVersion.values(), IdentifiedVersion.comparator());\n+        return eventLog.getEventsBetweenVersions(startVersion, endVersion)\n+                .startTsToSequence(timestampToVersion)\n+                .build();\n+    }\n+\n+    @Override\n+    public synchronized void removeTransactionStateFromCache(long startTimestamp) {\n+        MapEntry entryToRemove = timestampMap.get(startTimestamp);", "originalCommit": "355f5e2029025c9ee5a89497eab6c6d8c96f7dcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg3MjkzOA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433872938", "bodyText": "That's pretty inspired, done.", "author": "Jolyon-S", "createdAt": "2020-06-02T13:26:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1ODYwNQ=="}], "type": "inlineReview"}, {"oid": "37e6105ce1cc66439455c08594352de6a0b82387", "url": "https://github.com/palantir/atlasdb/commit/37e6105ce1cc66439455c08594352de6a0b82387", "message": "change static constructor", "committedDate": "2020-06-02T13:25:14Z", "type": "commit"}, {"oid": "af3bf4993c0801e46809aa0cd75ad9e600f26409", "url": "https://github.com/palantir/atlasdb/commit/af3bf4993c0801e46809aa0cd75ad9e600f26409", "message": "change to use exceptions instead", "committedDate": "2020-06-02T13:46:21Z", "type": "commit"}, {"oid": "d43e058bf98284726b0b9f173b8a754d716f9fe8", "url": "https://github.com/palantir/atlasdb/commit/d43e058bf98284726b0b9f173b8a754d716f9fe8", "message": "remove synchro", "committedDate": "2020-06-02T13:50:49Z", "type": "commit"}, {"oid": "6819fae07adc08b1f37d68f9bc7acd3592713c05", "url": "https://github.com/palantir/atlasdb/commit/6819fae07adc08b1f37d68f9bc7acd3592713c05", "message": "fix up a few more things", "committedDate": "2020-06-02T14:11:54Z", "type": "commit"}, {"oid": "69dffcc4114acb33ca3161c7af6ec96bbf2a4a49", "url": "https://github.com/palantir/atlasdb/commit/69dffcc4114acb33ca3161c7af6ec96bbf2a4a49", "message": "fix exception problem", "committedDate": "2020-06-02T14:32:12Z", "type": "commit"}, {"oid": "06527fbda2ff4e64536443316c30e0c6f1c84e61", "url": "https://github.com/palantir/atlasdb/commit/06527fbda2ff4e64536443316c30e0c6f1c84e61", "message": "work the integration test", "committedDate": "2020-06-03T09:28:16Z", "type": "commit"}, {"oid": "4af7d98c71f2340c390ea5aabf71e918bc62f28e", "url": "https://github.com/palantir/atlasdb/commit/4af7d98c71f2340c390ea5aabf71e918bc62f28e", "message": "fix diff", "committedDate": "2020-06-03T09:30:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzNTAxNw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434435017", "bodyText": "It's a bit awkward, but the only way to properly put these as TransactionFailedRetriableExceptions given the awkward dependency loop.", "author": "Jolyon-S", "createdAt": "2020-06-03T09:31:31Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchManagerImpl.java", "diffHunk": "@@ -55,12 +57,20 @@ public LockWatchManagerImpl(LockWatchEventCache lockWatchEventCache,\n     }\n \n     CommitUpdate getCommitUpdate(long startTs) {\n-        return lockWatchEventCache.getCommitUpdate(startTs);\n+        try {\n+            return lockWatchEventCache.getCommitUpdate(startTs);\n+        } catch (LockWatchFailedException e) {\n+            throw new TransactionLockWatchFailedException(\"Failed to get commit update\", e);\n+        }", "originalCommit": "4af7d98c71f2340c390ea5aabf71e918bc62f28e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYyNzY1NA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434627654", "bodyText": "Can you explain the dependency loop? This is weird and there should be a different solution. i.e. it feels to me like all the cache code should live alongside this class, or at least in this sub-project?", "author": "jkozlowski", "createdAt": "2020-06-03T14:51:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzNTAxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzMDIzNg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434630236", "bodyText": "TransactionFailedRetriableException, and others like it, live in com.palantir.atlasdb.transaction.api, which depends on lock-api (which in turn depends on lock-api-objects). To use retriable exceptions in this piece would require lock-api to depend on com.palantir.atlasdb.transaction.api, which creates a loop.\nSomething needs to move to avoid this awkwardness.", "author": "Jolyon-S", "createdAt": "2020-06-03T14:54:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzNTAxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1NDY0NQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434654645", "bodyText": "That's what I mean, you should probably move the event cache code somewhere else. It feels weird that it's in an *-api subproject, where it clearly is an implementation?", "author": "jkozlowski", "createdAt": "2020-06-03T15:27:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzNTAxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY4NjA2OQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434686069", "bodyText": "com.palantir.atlasdb.keyvalue.api.watch is used for LockWatchManagerImpl so clearly there are impls in *-apis elsewhere.\nStill, absolutely not averse to moving it - I will try and see where makes sense (without break decencies on the things that use it).", "author": "Jolyon-S", "createdAt": "2020-06-03T16:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzNTAxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzOTMzNw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435139337", "bodyText": "Moved to the same place as LockWatchManagerImpl - I think this is a better place.", "author": "Jolyon-S", "createdAt": "2020-06-04T10:04:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzNTAxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzNzkxMg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434437912", "bodyText": "Turns out it makes sense for the snapshot to know the version that it has processed thus far. This version is essentially the latest version that is no longer in the log.", "author": "Jolyon-S", "createdAt": "2020-06-03T09:36:15Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchSnapshotUpdaterImpl.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class ClientLockWatchSnapshotUpdaterImpl implements ClientLockWatchSnapshotUpdater {\n+    private final Set<LockWatchReferences.LockWatchReference> watches;\n+    private final Set<LockDescriptor> locked;\n+    private final EventVisitor visitor;\n+    private Optional<IdentifiedVersion> snapshotVersion;", "originalCommit": "4af7d98c71f2340c390ea5aabf71e918bc62f28e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0MDcxMw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434440713", "bodyText": "Just wondering if perhaps, for the sake of atlasdb-proxy, that we should fall through on this case instead (i.e. return no updates, and an empty map).", "author": "Jolyon-S", "createdAt": "2020-06-03T09:40:39Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.TimestampToVersionMap.CommitInfo;\n+import com.palantir.lock.watch.TimestampToVersionMap.MapEntry;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This class should only be used through {@link FailureCheckingLockWatchEventCache} as a proxy; failure to do so will\n+ * result in concurrency issues and inconsistency in the cache state.\n+ */\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final TimestampToVersionMap timestampMap;\n+\n+    public static LockWatchEventCache create() {\n+        return FailureCheckingLockWatchEventCache.newProxyInstance(\n+                new LockWatchEventCacheImpl(ClientLockWatchEventLogImpl.create()));\n+    }\n+\n+    @VisibleForTesting\n+    LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+        timestampMap = new TimestampToVersionMap();\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(version -> startTimestamps.forEach(timestamp -> timestampMap.put(timestamp, version)));\n+\n+        getEarliestVersion().ifPresent(eventLog::removeOldEntries);\n+    }\n+\n+    @Override\n+    public void processGetCommitTimestampsUpdate(\n+            Collection<TransactionUpdate> transactionUpdates,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(version -> transactionUpdates.forEach(\n+                transactionUpdate -> checkConditionOrThrow(!timestampMap.replace(transactionUpdate, version),\n+                        \"start timestamp missing from map\")));\n+    }\n+\n+    @Override\n+    public CommitUpdate getCommitUpdate(long startTs) {\n+        Optional<MapEntry> maybeEntry = timestampMap.get(startTs);\n+        Optional<CommitInfo> maybeCommitInfo = maybeEntry.flatMap(MapEntry::commitInfo);\n+\n+        checkConditionOrThrow(!maybeCommitInfo.isPresent(), \"commit info not processed for start timestamp\");\n+\n+        CommitInfo commitInfo = maybeCommitInfo.get();\n+\n+        ClientLogEvents update =\n+                eventLog.getEventsBetweenVersions(Optional.of(maybeEntry.get().version()), commitInfo.commitVersion());\n+\n+        if (update.clearCache()) {\n+            return ImmutableInvalidateAll.builder().build();\n+        }\n+\n+        return constructCommitUpdate(commitInfo, update.events());\n+    }\n+\n+    @Override\n+    public TransactionsLockWatchEvents getEventsForTransactions(\n+            Set<Long> startTimestamps,\n+            Optional<IdentifiedVersion> startVersion) {\n+        Preconditions.checkArgument(!startTimestamps.isEmpty(), \"Cannot get events for empty set of tranasctions\");", "originalCommit": "4af7d98c71f2340c390ea5aabf71e918bc62f28e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2MzgwMA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434563800", "bodyText": "Let's go with what you have and see how we handle this upstream. And adjust if we need to. But this feels correct, it already has something similar by starting a throwaway transaction for getting a schema version, so we probably can just bundle those together.", "author": "jkozlowski", "createdAt": "2020-06-03T13:25:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0MDcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2ODUzMA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434568530", "bodyText": "Ok, lets see how that goes.", "author": "Jolyon-S", "createdAt": "2020-06-03T13:32:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0MDcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1MDExNQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434550115", "bodyText": "Entries are only ever removed when a certain method is called, which is called on finish. However, we do not guarantee that a user calls finish; as such, there is a potential case where throwaway transactions are created, added to this map, but never deleted.\nHow do we want to go about handling this case? We could implement a retention policy but would that be a problem for long-running transactions (or do we care about those)?", "author": "Jolyon-S", "createdAt": "2020-06-03T13:04:18Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.TimestampToVersionMap.CommitInfo;\n+import com.palantir.lock.watch.TimestampToVersionMap.MapEntry;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This class should only be used through {@link FailureCheckingLockWatchEventCache} as a proxy; failure to do so will\n+ * result in concurrency issues and inconsistency in the cache state.\n+ */\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final TimestampToVersionMap timestampMap;", "originalCommit": "4af7d98c71f2340c390ea5aabf71e918bc62f28e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1MjI1MA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434552250", "bodyText": "Or is this just a matter of letting people be responsible for calling finish on their transactions? I feel like that is an approach prone to memory leaks.", "author": "Jolyon-S", "createdAt": "2020-06-03T13:07:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1MDExNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2MDM4MQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434560381", "bodyText": "So, 2 pieces:\n\nWe need to make sure that this cleanup always happens when users are using #runWithRetry. I think this is happening right now:\n\nOpenTransaction openTransaction =\n                    runTimed(() -> Iterables.getOnlyElement(startTransactions(ImmutableList.of(condition))),\n                            \"setupTask\");\n            return openTransaction.finish(transaction -> task.execute(transaction, condition));\n\n\nFor anyone using OpenTransaction, we need to rely on them calling #finish.\n\nThe only potentially problematic piece right now feels like SnapshotTransactionManager#startTransactions will not call #finish if anything in that try-catch block throws, so that needs fixing.", "author": "jkozlowski", "createdAt": "2020-06-03T13:20:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1MDExNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3MzQ1OQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434573459", "bodyText": "Fixed.", "author": "Jolyon-S", "createdAt": "2020-06-03T13:39:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1MDExNQ=="}], "type": "inlineReview"}, {"oid": "2d27558e5abad40815edc00bdec5ef696636362b", "url": "https://github.com/palantir/atlasdb/commit/2d27558e5abad40815edc00bdec5ef696636362b", "message": "rename method", "committedDate": "2020-06-03T13:09:09Z", "type": "commit"}, {"oid": "8a2570ed072df9b7adcfa7484adc0f178b4ccb1a", "url": "https://github.com/palantir/atlasdb/commit/8a2570ed072df9b7adcfa7484adc0f178b4ccb1a", "message": "Fail to start transaction no longer leaks to LW map", "committedDate": "2020-06-03T13:38:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxNzkxMQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434617911", "bodyText": "So this is fine, only because of the way we wire things up: the timelockService above is TimeLockClient, and in there the tryUnlock is non-blocking and does not throw. Ideally we would not rely on that, but I think it's fine here, and you can follow up with a PR to not rely on that later.", "author": "jkozlowski", "createdAt": "2020-06-03T14:37:46Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -205,6 +205,8 @@ protected boolean shouldStopRetrying(int numTimesFailed) {\n                     responses.stream()\n                             .map(response -> response.immutableTimestamp().getLock())\n                             .collect(Collectors.toSet()));\n+            responses.forEach(response -> lockWatchEventCache.removeTransactionStateFromCache(", "originalCommit": "8a2570ed072df9b7adcfa7484adc0f178b4ccb1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxOTk1MQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434619951", "bodyText": "Discussed offline", "author": "Jolyon-S", "createdAt": "2020-06-03T14:40:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxNzkxMQ=="}], "type": "inlineReview"}, {"oid": "7341d3dc89d901986325c8ac143045a3c42d1867", "url": "https://github.com/palantir/atlasdb/commit/7341d3dc89d901986325c8ac143045a3c42d1867", "message": "Avoid hashmap and tree multimap", "committedDate": "2020-06-03T15:01:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzMTY1OQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434631659", "bodyText": "So I still don't think this is the right place for this. e.g.\n\nin TimestampToVersionMap, your map should be keyed on Long, not IdentifiedVersion. This instance is always cleared on leader election, so it can only ever contain things pertaining to a single leader. So it's weird it then maintain a datastructure keyed based off the whole key", "author": "jkozlowski", "createdAt": "2020-06-03T14:56:40Z", "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/IdentifiedVersion.java", "diffHunk": "@@ -16,14 +16,28 @@\n \n package com.palantir.lock.watch;\n \n+import java.util.Comparator;\n import java.util.UUID;\n \n import org.immutables.value.Value;\n \n+import com.palantir.logsafe.Preconditions;\n+\n @Value.Immutable\n public interface IdentifiedVersion {\n     @Value.Parameter\n     UUID id();\n     @Value.Parameter\n     long version();\n+\n+    static IdentifiedVersion of(UUID id, long version) {\n+        return ImmutableIdentifiedVersion.of(id, version);\n+    }\n+\n+    static Comparator<IdentifiedVersion> comparator() {", "originalCommit": "8a2570ed072df9b7adcfa7484adc0f178b4ccb1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE1NTEzNw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435155137", "bodyText": "Keying on IdentifiedVersion makes a few things a bit simpler, but changed anyway.", "author": "Jolyon-S", "createdAt": "2020-06-04T10:32:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzMTY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzMjgwOQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434632809", "bodyText": "This terseness is probably fine, but I'd consider something along the lines of: \"Unable to retrieve information for this transaction; this means there was a leader election and this transaction will be retried\". Similarly below. But up to you", "author": "jkozlowski", "createdAt": "2020-06-03T14:58:09Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchManagerImpl.java", "diffHunk": "@@ -55,12 +57,20 @@ public LockWatchManagerImpl(LockWatchEventCache lockWatchEventCache,\n     }\n \n     CommitUpdate getCommitUpdate(long startTs) {\n-        return lockWatchEventCache.getCommitUpdate(startTs);\n+        try {\n+            return lockWatchEventCache.getCommitUpdate(startTs);\n+        } catch (LockWatchFailedException e) {\n+            throw new TransactionLockWatchFailedException(\"Failed to get commit update\", e);", "originalCommit": "8a2570ed072df9b7adcfa7484adc0f178b4ccb1a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzNTIxOA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434635218", "bodyText": "This whole block should be:\nOptional.ofNullable(aliveVersions.keySet().pollFirst())", "author": "jkozlowski", "createdAt": "2020-06-03T15:01:18Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/TimestampToVersionMap.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.HashMap;\n+import java.util.Optional;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.v2.LockToken;\n+\n+final class TimestampToVersionMap {\n+    private final HashMap<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    void put(long startTimestamp, IdentifiedVersion version) {\n+        timestampMap.put(startTimestamp, MapEntry.of(version));\n+        aliveVersions.put(version, startTimestamp);\n+    }\n+\n+    boolean replace(TransactionUpdate transactionUpdate, IdentifiedVersion newVersion) {\n+        MapEntry previousEntry = timestampMap.get(transactionUpdate.startTs());\n+        if (previousEntry == null) {\n+            return false;\n+        }\n+\n+        timestampMap.replace(transactionUpdate.startTs(), previousEntry.withCommitInfo(\n+                CommitInfo.of(transactionUpdate.commitTs(), transactionUpdate.writesToken(), newVersion)));\n+\n+        return true;\n+    }\n+\n+    void remove(long startTimestamp) {\n+        Optional.ofNullable(timestampMap.remove(startTimestamp))\n+                .ifPresent(entry -> aliveVersions.remove(entry.version(), startTimestamp));\n+    }\n+\n+    void clear() {\n+        timestampMap.clear();\n+        aliveVersions.clear();\n+    }\n+\n+    Optional<IdentifiedVersion> getEarliestVersion() {\n+        if (aliveVersions.isEmpty()) {", "originalCommit": "8a2570ed072df9b7adcfa7484adc0f178b4ccb1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY4MjU4Nw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434682587", "bodyText": "It should not use pollFirst as that removes the version, which we do not want. And first throws if the set is empty.", "author": "Jolyon-S", "createdAt": "2020-06-03T16:04:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzNTIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE2MDcwOQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435160709", "bodyText": "Optional.ofNullable(Iterables.getFirst(aliveVersions.keySet(), null))\n\nMaybe that then", "author": "jkozlowski", "createdAt": "2020-06-04T10:43:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzNTIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzNzAwOA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434637008", "bodyText": "I think you should throw somewhere in here if this is called twice, i.e. you already have the commit info. Just to be extra defensive.", "author": "jkozlowski", "createdAt": "2020-06-03T15:03:46Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/TimestampToVersionMap.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.v2.LockToken;\n+\n+final class TimestampToVersionMap {\n+    private final Map<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    void put(long startTimestamp, IdentifiedVersion version) {\n+        timestampMap.put(startTimestamp, MapEntry.of(version));\n+        aliveVersions.put(version, startTimestamp);\n+    }\n+\n+    boolean replace(TransactionUpdate transactionUpdate, IdentifiedVersion newVersion) {\n+        MapEntry previousEntry = timestampMap.get(transactionUpdate.startTs());", "originalCommit": "7341d3dc89d901986325c8ac143045a3c42d1867", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NTgzNg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435095836", "bodyText": "Returning false would be equivalent - i.e. it denotes a failure of some kind. Will do that.", "author": "Jolyon-S", "createdAt": "2020-06-04T08:52:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzNzAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzODI5OA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434638298", "bodyText": "nit: maybe think about different names for put/replace. Maybe putLogVersion and putTransactionUpdate? or onStartTransaction and onCommit or something to indicate when they are called, because there is an encoded state machine here (i.e. you call put and then replace;", "author": "jkozlowski", "createdAt": "2020-06-03T15:05:24Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/TimestampToVersionMap.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.v2.LockToken;\n+\n+final class TimestampToVersionMap {\n+    private final Map<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    void put(long startTimestamp, IdentifiedVersion version) {", "originalCommit": "7341d3dc89d901986325c8ac143045a3c42d1867", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NjkwOQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435096909", "bodyText": "Done", "author": "Jolyon-S", "createdAt": "2020-06-04T08:54:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzODI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0MDc5MQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434640791", "bodyText": "nit: this might be a stylistic thing, but similar to how you have put/replace, I've have 2 different getters, so you are not exposing your internal datastructure (MapEntry).", "author": "jkozlowski", "createdAt": "2020-06-03T15:08:44Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/TimestampToVersionMap.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.v2.LockToken;\n+\n+final class TimestampToVersionMap {\n+    private final Map<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    void put(long startTimestamp, IdentifiedVersion version) {\n+        timestampMap.put(startTimestamp, MapEntry.of(version));\n+        aliveVersions.put(version, startTimestamp);\n+    }\n+\n+    boolean replace(TransactionUpdate transactionUpdate, IdentifiedVersion newVersion) {\n+        MapEntry previousEntry = timestampMap.get(transactionUpdate.startTs());\n+        if (previousEntry == null) {\n+            return false;\n+        }\n+\n+        timestampMap.replace(transactionUpdate.startTs(), previousEntry.withCommitInfo(\n+                CommitInfo.of(transactionUpdate.commitTs(), transactionUpdate.writesToken(), newVersion)));\n+\n+        return true;\n+    }\n+\n+    void remove(long startTimestamp) {\n+        Optional.ofNullable(timestampMap.remove(startTimestamp))\n+                .ifPresent(entry -> aliveVersions.remove(entry.version(), startTimestamp));\n+    }\n+\n+    void clear() {\n+        timestampMap.clear();\n+        aliveVersions.clear();\n+    }\n+\n+    Optional<IdentifiedVersion> getEarliestVersion() {\n+        if (aliveVersions.isEmpty()) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(aliveVersions.keySet().first());\n+        }\n+    }\n+\n+    Optional<MapEntry> get(long startTimestamp) {", "originalCommit": "7341d3dc89d901986325c8ac143045a3c42d1867", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0Mzc5NQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434643795", "bodyText": "Nice! For extra safety, I would probably generate a new UUID every time, but I think this will translate to a snapshot and a clear cache for each transaction that starts this way.", "author": "jkozlowski", "createdAt": "2020-06-03T15:12:57Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/NoOpLockWatchEventCache.java", "diffHunk": "@@ -55,7 +53,11 @@ public CommitUpdate getCommitUpdate(long startTs) {\n     @Override\n     public TransactionsLockWatchEvents getEventsForTransactions(Set<Long> startTimestamps,\n             Optional<IdentifiedVersion> version) {\n-        return NONE;\n+        return ImmutableTransactionsLockWatchEvents.builder()\n+                .clearCache(true)\n+                .startTsToSequence(\n+                        startTimestamps.stream().collect(Collectors.toMap(startTs -> startTs, $ -> FAKE_VERSION)))", "originalCommit": "7341d3dc89d901986325c8ac143045a3c42d1867", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0NDAxMQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434644011", "bodyText": "Let's keep the eventId as -1 here, it indicates the log is empty.", "author": "jkozlowski", "createdAt": "2020-06-03T15:13:14Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/NoOpLockWatchEventCache.java", "diffHunk": "@@ -20,14 +20,12 @@\n import java.util.Optional;\n import java.util.Set;\n import java.util.UUID;\n-\n-import com.google.common.collect.ImmutableSet;\n+import java.util.stream.Collectors;\n \n @SuppressWarnings(\"FinalClass\") // mocks\n public class NoOpLockWatchEventCache implements LockWatchEventCache {\n     public static final LockWatchEventCache INSTANCE = new NoOpLockWatchEventCache();\n-    private static final TransactionsLockWatchEvents NONE = TransactionsLockWatchEvents.failure(\n-            LockWatchStateUpdate.snapshot(UUID.randomUUID(), -1L, ImmutableSet.of(), ImmutableSet.of()));\n+    private static final IdentifiedVersion FAKE_VERSION = IdentifiedVersion.of(UUID.randomUUID(), 0L);", "originalCommit": "7341d3dc89d901986325c8ac143045a3c42d1867", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1MDc5NA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434650794", "bodyText": "This is quite clever, but kinda non-trivial to read and also not entirely correct. You are missing not failing on your expected exceptions!\nI would rewrite it to:\nprivate final LockWatchEventCache delegate;\n\nprivate FailureCheckingLockWatchEventCache(LockWatchEventCache defaultCache) {\n        this.delegate = defaultCache;\n}\n\nand then #handleInvocation:\ntry {\n  return method.invoke(noOpCache, args);\n} catch (Throwable e) {\n  if (e instance of TransactionLockWatchFailedException) {\n   throw e;\n  }\n  delegate = NoOpLockWatchEventCache.INSTANCE;\n  // You still don't want to cause an outage, so should make the transaction retry.\n  throw new TransactionLockWatchFailedException(\"Unexpected failure\", e);\n}\n\nOr something to that effect.", "author": "jkozlowski", "createdAt": "2020-06-03T15:22:25Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/FailureCheckingLockWatchEventCache.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+\n+import com.google.common.reflect.AbstractInvocationHandler;\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+\n+final class FailureCheckingLockWatchEventCache extends AbstractInvocationHandler {\n+\n+    static LockWatchEventCache newProxyInstance(LockWatchEventCache defaultCache) {\n+        return (LockWatchEventCache) Proxy.newProxyInstance(\n+                LockWatchEventCache.class.getClassLoader(),\n+                new Class<?>[] {LockWatchEventCache.class},\n+                new FailureCheckingLockWatchEventCache(defaultCache));\n+    }\n+\n+    private final LockWatchEventCache defaultCache;\n+    private final LockWatchEventCache noOpCache;\n+\n+    @GuardedBy(\"this\")\n+    private boolean hasFailed = false;\n+\n+    private FailureCheckingLockWatchEventCache(LockWatchEventCache defaultCache) {\n+        this.defaultCache = defaultCache;\n+        this.noOpCache = NoOpLockWatchEventCache.INSTANCE;\n+    }\n+\n+    @Override\n+    protected synchronized Object handleInvocation(Object proxy, Method method, Object[] args) throws Throwable {\n+        if (hasFailed) {\n+            return method.invoke(noOpCache, args);\n+        } else {\n+            hasFailed = true;", "originalCommit": "7341d3dc89d901986325c8ac143045a3c42d1867", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzMjYzMw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435132633", "bodyText": "Done", "author": "Jolyon-S", "createdAt": "2020-06-04T09:53:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1MDc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1MjA2MA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434652060", "bodyText": "You probably want to just pass the cache you want to fallback to into its constructor. It is weird to rely on this behavior for something you're testing, when there's a simple solution like I described.", "author": "jkozlowski", "createdAt": "2020-06-03T15:24:06Z", "path": "lock-api/src/test/java/com/palantir/lock/watch/FailureCheckingLockWatchEventCacheTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public final class FailureCheckingLockWatchEventCacheTest {\n+\n+    @Mock\n+    private LockWatchEventCache defaultCache;\n+    private LockWatchEventCache proxyCache;\n+\n+    @Before\n+    public void before() {\n+        proxyCache = FailureCheckingLockWatchEventCache.newProxyInstance(defaultCache);\n+    }\n+\n+    @Test\n+    public void failCausesNoOpCacheToBeUsed() {\n+        RuntimeException runtimeException = new RuntimeException();\n+        when(defaultCache.getCommitUpdate(anyLong())).thenThrow(runtimeException);\n+        assertThatThrownBy(() -> proxyCache.getCommitUpdate(0L)).hasRootCause(runtimeException);\n+\n+        when(defaultCache.lastKnownVersion()).thenReturn(Optional.of(IdentifiedVersion.of(UUID.randomUUID(), 1L)));\n+\n+        // no op cache returns empty on last known version, so this should prove that we delegate there correctly", "originalCommit": "7341d3dc89d901986325c8ac143045a3c42d1867", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzODIwOQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435138209", "bodyText": "Done", "author": "Jolyon-S", "createdAt": "2020-06-04T10:02:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1MjA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1MzI2MA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434653260", "bodyText": "nit: Maaaybe consider a different name, because we also rely on the synchronized being here for correctness! First thing that came to my mind was \"ResilientLockWatchEventCache\", or \"SynchronizedLockWatchEventCache\".", "author": "jkozlowski", "createdAt": "2020-06-03T15:25:43Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/FailureCheckingLockWatchEventCache.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+\n+import com.google.common.reflect.AbstractInvocationHandler;\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+\n+final class FailureCheckingLockWatchEventCache extends AbstractInvocationHandler {", "originalCommit": "7341d3dc89d901986325c8ac143045a3c42d1867", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzOTAxNA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435139014", "bodyText": "Went with the former.", "author": "Jolyon-S", "createdAt": "2020-06-04T10:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1MzI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1NjMyMQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434656321", "bodyText": "I would consider tests for this, for anything that's hard to test in your integration test. I haven't read through that yet, so unclear if this comment is useful.", "author": "jkozlowski", "createdAt": "2020-06-03T15:29:38Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/TimestampToVersionMap.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.v2.LockToken;\n+\n+final class TimestampToVersionMap {", "originalCommit": "7341d3dc89d901986325c8ac143045a3c42d1867", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE1NTE4Mw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435155183", "bodyText": "Done.", "author": "Jolyon-S", "createdAt": "2020-06-04T10:33:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1NjMyMQ=="}], "type": "inlineReview"}, {"oid": "c5a4a3ff428f3a2632d33571a8cd9a8e5b43a882", "url": "https://github.com/palantir/atlasdb/commit/c5a4a3ff428f3a2632d33571a8cd9a8e5b43a882", "message": "fix checkstyle", "committedDate": "2020-06-04T08:49:29Z", "type": "commit"}, {"oid": "5b14885ebc543a81863a87309816f853ba693e5c", "url": "https://github.com/palantir/atlasdb/commit/5b14885ebc543a81863a87309816f853ba693e5c", "message": "fixup ttvm per comments", "committedDate": "2020-06-04T08:53:12Z", "type": "commit"}, {"oid": "e9a1f47bd790c8a0bdc3cba7bf2e83b9f2c0707d", "url": "https://github.com/palantir/atlasdb/commit/e9a1f47bd790c8a0bdc3cba7bf2e83b9f2c0707d", "message": "rename methods", "committedDate": "2020-06-04T08:54:19Z", "type": "commit"}, {"oid": "da2feb533929882178a9344642990b58bcd14ee1", "url": "https://github.com/palantir/atlasdb/commit/da2feb533929882178a9344642990b58bcd14ee1", "message": "tidy commit update a bit", "committedDate": "2020-06-04T09:11:31Z", "type": "commit"}, {"oid": "3726bd054af7a1d6ac7bc437a3553bac9f935285", "url": "https://github.com/palantir/atlasdb/commit/3726bd054af7a1d6ac7bc437a3553bac9f935285", "message": "remove unused imports", "committedDate": "2020-06-04T09:12:19Z", "type": "commit"}, {"oid": "afadfeda7ac29a5e1976ac51a5e07078a08cb6ae", "url": "https://github.com/palantir/atlasdb/commit/afadfeda7ac29a5e1976ac51a5e07078a08cb6ae", "message": "fix fake version to have different uuid each time", "committedDate": "2020-06-04T09:17:00Z", "type": "commit"}, {"oid": "a1b0280e1eef2f5713558e13fe6976a4f0d2ee60", "url": "https://github.com/palantir/atlasdb/commit/a1b0280e1eef2f5713558e13fe6976a4f0d2ee60", "message": "modify failure checking cache", "committedDate": "2020-06-04T09:45:44Z", "type": "commit"}, {"oid": "92038aa2cb79533791037c6c86cbda2e82f00d69", "url": "https://github.com/palantir/atlasdb/commit/92038aa2cb79533791037c6c86cbda2e82f00d69", "message": "comments", "committedDate": "2020-06-04T09:55:39Z", "type": "commit"}, {"oid": "ea5fe626acfb2287ea41e9731ec1753a5f5fdde1", "url": "https://github.com/palantir/atlasdb/commit/ea5fe626acfb2287ea41e9731ec1753a5f5fdde1", "message": "fix test", "committedDate": "2020-06-04T10:02:31Z", "type": "commit"}, {"oid": "b6e3a24459f83e6257fbfc7e60532fc6a850d9a5", "url": "https://github.com/palantir/atlasdb/commit/b6e3a24459f83e6257fbfc7e60532fc6a850d9a5", "message": "rename", "committedDate": "2020-06-04T10:03:41Z", "type": "commit"}, {"oid": "969a6620acf65a186e28f95d091f1a38a4d5cb8f", "url": "https://github.com/palantir/atlasdb/commit/969a6620acf65a186e28f95d091f1a38a4d5cb8f", "message": "Fix typos", "committedDate": "2020-06-04T10:08:45Z", "type": "commit"}, {"oid": "b786af77c25e622909573f7dadff54ae836d5492", "url": "https://github.com/palantir/atlasdb/commit/b786af77c25e622909573f7dadff54ae836d5492", "message": "add timestamp to version map test", "committedDate": "2020-06-04T10:24:39Z", "type": "commit"}, {"oid": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344", "url": "https://github.com/palantir/atlasdb/commit/a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344", "message": "fix up more comments", "committedDate": "2020-06-04T10:31:16Z", "type": "commit"}, {"oid": "0b5c5163688e4a03b23acb148c627c6adacad271", "url": "https://github.com/palantir/atlasdb/commit/0b5c5163688e4a03b23acb148c627c6adacad271", "message": "change type to sortedsetmap and oneline it", "committedDate": "2020-06-04T12:00:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4MTU3Mg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435181572", "bodyText": "At least a logline, but ideally a metric so you can setup some alerts for rollout.", "author": "jkozlowski", "createdAt": "2020-06-04T11:25:06Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/ResilientLockWatchEventCache.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+\n+import com.google.common.reflect.AbstractInvocationHandler;\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import com.palantir.atlasdb.transaction.api.TransactionLockWatchFailedException;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+\n+final class ResilientLockWatchEventCache extends AbstractInvocationHandler {\n+\n+    static LockWatchEventCache newProxyInstance(LockWatchEventCache defaultCache, LockWatchEventCache fallbackCache) {\n+        return (LockWatchEventCache) Proxy.newProxyInstance(\n+                LockWatchEventCache.class.getClassLoader(),\n+                new Class<?>[] {LockWatchEventCache.class},\n+                new ResilientLockWatchEventCache(defaultCache, fallbackCache));\n+    }\n+\n+    private final LockWatchEventCache fallbackCache;\n+\n+    @GuardedBy(\"this\")\n+    private LockWatchEventCache delegate;\n+\n+    private ResilientLockWatchEventCache(LockWatchEventCache defaultCache, LockWatchEventCache fallbackCache) {\n+        this.delegate = defaultCache;\n+        this.fallbackCache = fallbackCache;\n+    }\n+\n+    @Override\n+    protected synchronized Object handleInvocation(Object proxy, Method method, Object[] args) {\n+        try {\n+            return method.invoke(delegate, args);\n+        } catch (TransactionLockWatchFailedException e) {\n+            throw e;\n+        } catch (Throwable t) {\n+            delegate = fallbackCache;", "originalCommit": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIzOTkzOQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435239939", "bodyText": "Done both", "author": "Jolyon-S", "createdAt": "2020-06-04T13:10:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4MTU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4MzIwMg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435183202", "bodyText": "If commit info is present, you should throw right? It's unexpected and indicates a bug?", "author": "jkozlowski", "createdAt": "2020-06-04T11:28:24Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/TimestampToVersionMap.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.TransactionUpdate;\n+\n+final class TimestampToVersionMap {\n+    private final Map<Long, MapEntry> timestampMap = new HashMap<>();\n+    @SuppressWarnings(\"IllegalTypeCheck\")\n+    private final TreeMultimap<Long, Long> aliveVersions = TreeMultimap.create();\n+\n+    void putStartVersion(long startTimestamp, IdentifiedVersion version) {\n+        timestampMap.put(startTimestamp, MapEntry.of(version));\n+        aliveVersions.put(version.version(), startTimestamp);\n+    }\n+\n+    boolean putCommitUpdate(TransactionUpdate transactionUpdate, IdentifiedVersion newVersion) {\n+        MapEntry previousEntry = timestampMap.get(transactionUpdate.startTs());\n+        if (previousEntry == null || previousEntry.commitInfo().isPresent()) {", "originalCommit": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI0MDU1MQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435240551", "bodyText": "I suppose if previousEntry is null, then it is a retriable exception (i.e. we had a leader election), but if the commitInfo is present, then it is a bug as we should not put the update more than once. Will change.", "author": "Jolyon-S", "createdAt": "2020-06-04T13:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4MzIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4Mzc4Nw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435183787", "bodyText": "nit: This should be something like TransactionStateStore or something. You don't only store versions here, and *Map is also not accurate because 1. it tells you about it's internal implementation. 2. It actually contains multiple maps!", "author": "jkozlowski", "createdAt": "2020-06-04T11:29:39Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/TimestampToVersionMap.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.TransactionUpdate;\n+\n+final class TimestampToVersionMap {", "originalCommit": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI0MTYzNg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435241636", "bodyText": "I'm reluctant to put Store in the name given the connotation of store with some sort of internal table, but I'll think of something\neh I think it is good enough, can't think of something", "author": "Jolyon-S", "createdAt": "2020-06-04T13:12:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4Mzc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NDUwOA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435184508", "bodyText": "I think by convention, cause can be nullable, so you shouldn't need the second constructor.", "author": "jkozlowski", "createdAt": "2020-06-04T11:31:07Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionLockWatchFailedException.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.transaction.api;\n+\n+public final class TransactionLockWatchFailedException extends TransactionFailedRetriableException {\n+    public TransactionLockWatchFailedException(String message, Throwable cause) {", "originalCommit": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI0NDM3OA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435244378", "bodyText": "Just following the standard in TransactionFailedRetriableException and all the other exceptions it inherits from", "author": "Jolyon-S", "createdAt": "2020-06-04T13:16:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NDUwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NzQyMQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435187421", "bodyText": "Same here, I have a feeling you should use putIfAbsent and throw if already present.", "author": "jkozlowski", "createdAt": "2020-06-04T11:36:49Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/TimestampToVersionMap.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.TransactionUpdate;\n+\n+final class TimestampToVersionMap {\n+    private final Map<Long, MapEntry> timestampMap = new HashMap<>();\n+    @SuppressWarnings(\"IllegalTypeCheck\")\n+    private final TreeMultimap<Long, Long> aliveVersions = TreeMultimap.create();\n+\n+    void putStartVersion(long startTimestamp, IdentifiedVersion version) {\n+        timestampMap.put(startTimestamp, MapEntry.of(version));", "originalCommit": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI0NjAxMA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435246010", "bodyText": "Done", "author": "Jolyon-S", "createdAt": "2020-06-04T13:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NzQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NzU5Mw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435187593", "bodyText": "What does this mean?", "author": "jkozlowski", "createdAt": "2020-06-04T11:37:11Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/TimestampToVersionMap.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.TransactionUpdate;\n+\n+final class TimestampToVersionMap {\n+    private final Map<Long, MapEntry> timestampMap = new HashMap<>();\n+    @SuppressWarnings(\"IllegalTypeCheck\")", "originalCommit": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI0Njg4MQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435246881", "bodyText": "Removed; needed it when I was using aliveVersions.keySet().first() as only TreeMultiMap guarantees that keySet() is a NavigableMap and checkstyle doesn't like that; but using Iterables.getFirst circumnavigates this and I need only use a SortedSetMultiMap.", "author": "Jolyon-S", "createdAt": "2020-06-04T13:20:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NzU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MDAyOQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435190029", "bodyText": "Should take long here, that will probably simplify your upstream code.", "author": "jkozlowski", "createdAt": "2020-06-04T11:41:59Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLog.java", "diffHunk": "@@ -16,17 +16,12 @@\n \n package com.palantir.lock.watch;\n \n-import java.util.Collection;\n import java.util.Optional;\n-import java.util.Set;\n \n-public interface LockWatchEventCache {\n-    Optional<IdentifiedVersion> lastKnownVersion();\n-    void processStartTransactionsUpdate(Set<Long> startTimestamps, LockWatchStateUpdate update);\n-    void processGetCommitTimestampsUpdate(Collection<TransactionUpdate> transactionUpdates,\n-            LockWatchStateUpdate update);\n-    CommitUpdate getCommitUpdate(long startTs);\n-    TransactionsLockWatchEvents getEventsForTransactions(Set<Long> startTimestamps,\n-            Optional<IdentifiedVersion> version);\n-    void removeTransactionStateFromCache(long startTimestamp);\n+public interface ClientLockWatchEventLog {\n+    ClientLogEvents getEventsBetweenVersions(\n+            Optional<IdentifiedVersion> startVersion, IdentifiedVersion endVersion);\n+    Optional<IdentifiedVersion> getLatestKnownVersion();\n+    Optional<IdentifiedVersion> processUpdate(LockWatchStateUpdate update);\n+    void removeOldEntries(IdentifiedVersion earliestVersion);", "originalCommit": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI0NzU3NQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435247575", "bodyText": "Done", "author": "Jolyon-S", "createdAt": "2020-06-04T13:21:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MDAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MTQzNA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435191434", "bodyText": "I feel like you should invert this, you use it as checkConditionOrThrow(! everywhere. And maybe call assertTrue.", "author": "jkozlowski", "createdAt": "2020-06-04T11:44:46Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.atlasdb.keyvalue.api.watch.TimestampToVersionMap.CommitInfo;\n+import com.palantir.atlasdb.transaction.api.TransactionLockWatchFailedException;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.ClientLockWatchEventLog;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableInvalidateAll;\n+import com.palantir.lock.watch.ImmutableInvalidateSome;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.NoOpLockWatchEventCache;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchEvents;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This class should only be used through {@link ResilientLockWatchEventCache} as a proxy; failure to do so will result\n+ * in concurrency issues and inconsistency in the cache state.\n+ */\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final TimestampToVersionMap timestampMap;\n+\n+    public static LockWatchEventCache create() {\n+        return ResilientLockWatchEventCache.newProxyInstance(\n+                new LockWatchEventCacheImpl(ClientLockWatchEventLogImpl.create()), NoOpLockWatchEventCache.INSTANCE);\n+    }\n+\n+    @VisibleForTesting\n+    LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+        timestampMap = new TimestampToVersionMap();\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(\n+                version -> startTimestamps.forEach(timestamp -> timestampMap.putStartVersion(timestamp, version)));\n+\n+        getEarliestVersion().ifPresent(eventLog::removeOldEntries);\n+    }\n+\n+    @Override\n+    public void processGetCommitTimestampsUpdate(\n+            Collection<TransactionUpdate> transactionUpdates,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(version -> transactionUpdates.forEach(\n+                transactionUpdate -> checkConditionOrThrow(!timestampMap.putCommitUpdate(transactionUpdate, version),\n+                        \"start timestamp missing from map\")));\n+    }\n+\n+    @Override\n+    public CommitUpdate getCommitUpdate(long startTs) {\n+        Optional<IdentifiedVersion> startVersion = timestampMap.getStartVersion(startTs);\n+        Optional<CommitInfo> maybeCommitInfo = timestampMap.getCommitInfo(startTs);\n+\n+        checkConditionOrThrow(!maybeCommitInfo.isPresent() || !startVersion.isPresent(),\n+                \"start or commit info not processed for start timestamp\");\n+\n+        CommitInfo commitInfo = maybeCommitInfo.get();\n+\n+        ClientLogEvents update = eventLog.getEventsBetweenVersions(startVersion, commitInfo.commitVersion());\n+\n+        if (update.clearCache()) {\n+            return ImmutableInvalidateAll.builder().build();\n+        }\n+\n+        return constructCommitUpdate(commitInfo, update.events());\n+    }\n+\n+    @Override\n+    public TransactionsLockWatchEvents getEventsForTransactions(\n+            Set<Long> startTimestamps,\n+            Optional<IdentifiedVersion> startVersion) {\n+        Preconditions.checkArgument(!startTimestamps.isEmpty(), \"Cannot get events for empty set of transactions\");\n+        Map<Long, IdentifiedVersion> timestampToVersion = getTimestampMappings(startTimestamps);\n+        IdentifiedVersion endVersion = Collections.max(timestampToVersion.values(),\n+                Comparator.comparingLong(IdentifiedVersion::version));\n+        return eventLog.getEventsBetweenVersions(startVersion, endVersion).map(timestampToVersion);\n+    }\n+\n+    @Override\n+    public void removeTransactionStateFromCache(long startTimestamp) {\n+        timestampMap.remove(startTimestamp);\n+    }\n+\n+    @VisibleForTesting\n+    Map<Long, IdentifiedVersion> getTimestampMappings(Set<Long> startTimestamps) {\n+        Map<Long, IdentifiedVersion> timestampToVersion = new HashMap<>();\n+        startTimestamps.forEach(timestamp -> {\n+            Optional<IdentifiedVersion> entry = timestampMap.getStartVersion(timestamp);\n+            checkConditionOrThrow(!entry.isPresent(), \"start timestamp missing from map\");\n+            timestampToVersion.put(timestamp, entry.get());\n+        });\n+        return timestampToVersion;\n+    }\n+\n+    @VisibleForTesting\n+    Optional<IdentifiedVersion> getEarliestVersion() {\n+        Optional<IdentifiedVersion> currentVersion = eventLog.getLatestKnownVersion();\n+        return timestampMap.getEarliestVersion().flatMap(sequence ->\n+                currentVersion.map(version -> IdentifiedVersion.of(version.id(), sequence)));\n+    }\n+\n+    private void checkConditionOrThrow(boolean condition, String message) {", "originalCommit": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI0ODI1OQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435248259", "bodyText": "Good call", "author": "Jolyon-S", "createdAt": "2020-06-04T13:22:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MTQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MjA2MQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435192061", "bodyText": "This should be a hard failure, it's a bug?\nActually, it's hard to know, because this is legitimate on a leader switch once we've cleared the cache. Good catch!", "author": "jkozlowski", "createdAt": "2020-06-04T11:46:01Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.atlasdb.keyvalue.api.watch.TimestampToVersionMap.CommitInfo;\n+import com.palantir.atlasdb.transaction.api.TransactionLockWatchFailedException;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.ClientLockWatchEventLog;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableInvalidateAll;\n+import com.palantir.lock.watch.ImmutableInvalidateSome;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.NoOpLockWatchEventCache;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchEvents;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This class should only be used through {@link ResilientLockWatchEventCache} as a proxy; failure to do so will result\n+ * in concurrency issues and inconsistency in the cache state.\n+ */\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final TimestampToVersionMap timestampMap;\n+\n+    public static LockWatchEventCache create() {\n+        return ResilientLockWatchEventCache.newProxyInstance(\n+                new LockWatchEventCacheImpl(ClientLockWatchEventLogImpl.create()), NoOpLockWatchEventCache.INSTANCE);\n+    }\n+\n+    @VisibleForTesting\n+    LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+        timestampMap = new TimestampToVersionMap();\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(\n+                version -> startTimestamps.forEach(timestamp -> timestampMap.putStartVersion(timestamp, version)));\n+\n+        getEarliestVersion().ifPresent(eventLog::removeOldEntries);\n+    }\n+\n+    @Override\n+    public void processGetCommitTimestampsUpdate(\n+            Collection<TransactionUpdate> transactionUpdates,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(version -> transactionUpdates.forEach(\n+                transactionUpdate -> checkConditionOrThrow(!timestampMap.putCommitUpdate(transactionUpdate, version),\n+                        \"start timestamp missing from map\")));\n+    }\n+\n+    @Override\n+    public CommitUpdate getCommitUpdate(long startTs) {\n+        Optional<IdentifiedVersion> startVersion = timestampMap.getStartVersion(startTs);\n+        Optional<CommitInfo> maybeCommitInfo = timestampMap.getCommitInfo(startTs);\n+\n+        checkConditionOrThrow(!maybeCommitInfo.isPresent() || !startVersion.isPresent(),", "originalCommit": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5Mzk0Ng==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435193946", "bodyText": "This looks rather scary here: I would think you'd want the return type of #processUpdate to indicate whether there was an event that should cause everything to be reset?", "author": "jkozlowski", "createdAt": "2020-06-04T11:50:12Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.atlasdb.keyvalue.api.watch.TimestampToVersionMap.CommitInfo;\n+import com.palantir.atlasdb.transaction.api.TransactionLockWatchFailedException;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.ClientLockWatchEventLog;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableInvalidateAll;\n+import com.palantir.lock.watch.ImmutableInvalidateSome;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.NoOpLockWatchEventCache;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchEvents;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This class should only be used through {@link ResilientLockWatchEventCache} as a proxy; failure to do so will result\n+ * in concurrency issues and inconsistency in the cache state.\n+ */\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final TimestampToVersionMap timestampMap;\n+\n+    public static LockWatchEventCache create() {\n+        return ResilientLockWatchEventCache.newProxyInstance(\n+                new LockWatchEventCacheImpl(ClientLockWatchEventLogImpl.create()), NoOpLockWatchEventCache.INSTANCE);\n+    }\n+\n+    @VisibleForTesting\n+    LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+        timestampMap = new TimestampToVersionMap();\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(\n+                version -> startTimestamps.forEach(timestamp -> timestampMap.putStartVersion(timestamp, version)));\n+\n+        getEarliestVersion().ifPresent(eventLog::removeOldEntries);\n+    }\n+\n+    @Override\n+    public void processGetCommitTimestampsUpdate(\n+            Collection<TransactionUpdate> transactionUpdates,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(version -> transactionUpdates.forEach(\n+                transactionUpdate -> checkConditionOrThrow(!timestampMap.putCommitUpdate(transactionUpdate, version),\n+                        \"start timestamp missing from map\")));\n+    }\n+\n+    @Override\n+    public CommitUpdate getCommitUpdate(long startTs) {\n+        Optional<IdentifiedVersion> startVersion = timestampMap.getStartVersion(startTs);\n+        Optional<CommitInfo> maybeCommitInfo = timestampMap.getCommitInfo(startTs);\n+\n+        checkConditionOrThrow(!maybeCommitInfo.isPresent() || !startVersion.isPresent(),\n+                \"start or commit info not processed for start timestamp\");\n+\n+        CommitInfo commitInfo = maybeCommitInfo.get();\n+\n+        ClientLogEvents update = eventLog.getEventsBetweenVersions(startVersion, commitInfo.commitVersion());\n+\n+        if (update.clearCache()) {\n+            return ImmutableInvalidateAll.builder().build();\n+        }\n+\n+        return constructCommitUpdate(commitInfo, update.events());\n+    }\n+\n+    @Override\n+    public TransactionsLockWatchEvents getEventsForTransactions(\n+            Set<Long> startTimestamps,\n+            Optional<IdentifiedVersion> startVersion) {\n+        Preconditions.checkArgument(!startTimestamps.isEmpty(), \"Cannot get events for empty set of transactions\");\n+        Map<Long, IdentifiedVersion> timestampToVersion = getTimestampMappings(startTimestamps);\n+        IdentifiedVersion endVersion = Collections.max(timestampToVersion.values(),\n+                Comparator.comparingLong(IdentifiedVersion::version));\n+        return eventLog.getEventsBetweenVersions(startVersion, endVersion).map(timestampToVersion);\n+    }\n+\n+    @Override\n+    public void removeTransactionStateFromCache(long startTimestamp) {\n+        timestampMap.remove(startTimestamp);\n+    }\n+\n+    @VisibleForTesting\n+    Map<Long, IdentifiedVersion> getTimestampMappings(Set<Long> startTimestamps) {\n+        Map<Long, IdentifiedVersion> timestampToVersion = new HashMap<>();\n+        startTimestamps.forEach(timestamp -> {\n+            Optional<IdentifiedVersion> entry = timestampMap.getStartVersion(timestamp);\n+            checkConditionOrThrow(!entry.isPresent(), \"start timestamp missing from map\");\n+            timestampToVersion.put(timestamp, entry.get());\n+        });\n+        return timestampToVersion;\n+    }\n+\n+    @VisibleForTesting\n+    Optional<IdentifiedVersion> getEarliestVersion() {\n+        Optional<IdentifiedVersion> currentVersion = eventLog.getLatestKnownVersion();\n+        return timestampMap.getEarliestVersion().flatMap(sequence ->\n+                currentVersion.map(version -> IdentifiedVersion.of(version.id(), sequence)));\n+    }\n+\n+    private void checkConditionOrThrow(boolean condition, String message) {\n+        if (condition) {\n+            throw new TransactionLockWatchFailedException(message);\n+        }\n+    }\n+\n+    private CommitUpdate constructCommitUpdate(CommitInfo commitInfo, List<LockWatchEvent> events) {\n+        LockEventVisitor eventVisitor = new LockEventVisitor(commitInfo.commitLockToken());\n+        Set<LockDescriptor> locksTakenOut = new HashSet<>();\n+        events.forEach(event -> locksTakenOut.addAll(event.accept(eventVisitor)));\n+        return ImmutableInvalidateSome.builder().invalidatedLocks(locksTakenOut).build();\n+    }\n+\n+    private Optional<IdentifiedVersion> processEventLogUpdate(LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> currentVersion = eventLog.getLatestKnownVersion();\n+        Optional<IdentifiedVersion> latestVersion = eventLog.processUpdate(update);\n+\n+        if (!(latestVersion.isPresent()", "originalCommit": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI1MjgwNA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435252804", "bodyText": "there are 4 checks here:\n\nis the version at all present? This corresponds to a failure LockWatchStateUpdate\nis the current version (i.e. the one before the update) present? Should only be if we are going from either initialisation or a failure to a snapshot/success (and in which case, we want to reset the timestamp store)\ndid the version change?\nwas it a successful update?\n\nJust thinking this through, I could just as easily return a boolean that states whether it was a successful update or not, and then just ask for the latest version on the next line; since this is all synchronised, this won't cause problems and would handle this.", "author": "Jolyon-S", "createdAt": "2020-06-04T13:28:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5Mzk0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI2NDk4OA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435264988", "bodyText": "Changed.", "author": "Jolyon-S", "createdAt": "2020-06-04T13:43:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5Mzk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5NDcwMQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435194701", "bodyText": "This feels like it's in the wrong place? You should be cleaning up when transactions are removed from the cache, not when they're added right? Otherwise, this will not be prompt.", "author": "jkozlowski", "createdAt": "2020-06-04T11:51:42Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.atlasdb.keyvalue.api.watch.TimestampToVersionMap.CommitInfo;\n+import com.palantir.atlasdb.transaction.api.TransactionLockWatchFailedException;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.ClientLockWatchEventLog;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableInvalidateAll;\n+import com.palantir.lock.watch.ImmutableInvalidateSome;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.NoOpLockWatchEventCache;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchEvents;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This class should only be used through {@link ResilientLockWatchEventCache} as a proxy; failure to do so will result\n+ * in concurrency issues and inconsistency in the cache state.\n+ */\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final TimestampToVersionMap timestampMap;\n+\n+    public static LockWatchEventCache create() {\n+        return ResilientLockWatchEventCache.newProxyInstance(\n+                new LockWatchEventCacheImpl(ClientLockWatchEventLogImpl.create()), NoOpLockWatchEventCache.INSTANCE);\n+    }\n+\n+    @VisibleForTesting\n+    LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+        timestampMap = new TimestampToVersionMap();\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(\n+                version -> startTimestamps.forEach(timestamp -> timestampMap.putStartVersion(timestamp, version)));\n+\n+        getEarliestVersion().ifPresent(eventLog::removeOldEntries);", "originalCommit": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI2NzU2Ng==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435267566", "bodyText": "I've considered this before - the reason I went for it is that this will be called once per batch, as opposed to once per every transaction. But then again, this should be fast and I probably shouldn't micro-optimise at the cost of clarity, so I'll move it.", "author": "Jolyon-S", "createdAt": "2020-06-04T13:45:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5NDcwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQwMTQ5Nw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435401497", "bodyText": "Went back on this decision, as I think it's more correct in process on start: what if you are tracking events before you ever put a timestamp in? This way, you will clear all of those events out when you do a first put.", "author": "Jolyon-S", "createdAt": "2020-06-04T16:46:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5NDcwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5NjUzNw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435196537", "bodyText": "Both of these, I feel, should take the Collection/Collection, so the code upstairs doesn't have to iterate by itself.", "author": "jkozlowski", "createdAt": "2020-06-04T11:55:30Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/TimestampToVersionMap.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.TransactionUpdate;\n+\n+final class TimestampToVersionMap {\n+    private final Map<Long, MapEntry> timestampMap = new HashMap<>();\n+    @SuppressWarnings(\"IllegalTypeCheck\")\n+    private final TreeMultimap<Long, Long> aliveVersions = TreeMultimap.create();\n+\n+    void putStartVersion(long startTimestamp, IdentifiedVersion version) {", "originalCommit": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIxNDUzMg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435214532", "bodyText": "nit: createCommitUpdate", "author": "jkozlowski", "createdAt": "2020-06-04T12:29:06Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.atlasdb.keyvalue.api.watch.TimestampToVersionMap.CommitInfo;\n+import com.palantir.atlasdb.transaction.api.TransactionLockWatchFailedException;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.ClientLockWatchEventLog;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableInvalidateAll;\n+import com.palantir.lock.watch.ImmutableInvalidateSome;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.NoOpLockWatchEventCache;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchEvents;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This class should only be used through {@link ResilientLockWatchEventCache} as a proxy; failure to do so will result\n+ * in concurrency issues and inconsistency in the cache state.\n+ */\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final TimestampToVersionMap timestampMap;\n+\n+    public static LockWatchEventCache create() {\n+        return ResilientLockWatchEventCache.newProxyInstance(\n+                new LockWatchEventCacheImpl(ClientLockWatchEventLogImpl.create()), NoOpLockWatchEventCache.INSTANCE);\n+    }\n+\n+    @VisibleForTesting\n+    LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+        timestampMap = new TimestampToVersionMap();\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(\n+                version -> startTimestamps.forEach(timestamp -> timestampMap.putStartVersion(timestamp, version)));\n+\n+        getEarliestVersion().ifPresent(eventLog::removeOldEntries);\n+    }\n+\n+    @Override\n+    public void processGetCommitTimestampsUpdate(\n+            Collection<TransactionUpdate> transactionUpdates,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(version -> transactionUpdates.forEach(\n+                transactionUpdate -> checkConditionOrThrow(!timestampMap.putCommitUpdate(transactionUpdate, version),\n+                        \"start timestamp missing from map\")));\n+    }\n+\n+    @Override\n+    public CommitUpdate getCommitUpdate(long startTs) {\n+        Optional<IdentifiedVersion> startVersion = timestampMap.getStartVersion(startTs);\n+        Optional<CommitInfo> maybeCommitInfo = timestampMap.getCommitInfo(startTs);\n+\n+        checkConditionOrThrow(!maybeCommitInfo.isPresent() || !startVersion.isPresent(),\n+                \"start or commit info not processed for start timestamp\");\n+\n+        CommitInfo commitInfo = maybeCommitInfo.get();\n+\n+        ClientLogEvents update = eventLog.getEventsBetweenVersions(startVersion, commitInfo.commitVersion());\n+\n+        if (update.clearCache()) {\n+            return ImmutableInvalidateAll.builder().build();\n+        }\n+\n+        return constructCommitUpdate(commitInfo, update.events());\n+    }\n+\n+    @Override\n+    public TransactionsLockWatchEvents getEventsForTransactions(\n+            Set<Long> startTimestamps,\n+            Optional<IdentifiedVersion> startVersion) {\n+        Preconditions.checkArgument(!startTimestamps.isEmpty(), \"Cannot get events for empty set of transactions\");\n+        Map<Long, IdentifiedVersion> timestampToVersion = getTimestampMappings(startTimestamps);\n+        IdentifiedVersion endVersion = Collections.max(timestampToVersion.values(),\n+                Comparator.comparingLong(IdentifiedVersion::version));\n+        return eventLog.getEventsBetweenVersions(startVersion, endVersion).map(timestampToVersion);\n+    }\n+\n+    @Override\n+    public void removeTransactionStateFromCache(long startTimestamp) {\n+        timestampMap.remove(startTimestamp);\n+    }\n+\n+    @VisibleForTesting\n+    Map<Long, IdentifiedVersion> getTimestampMappings(Set<Long> startTimestamps) {\n+        Map<Long, IdentifiedVersion> timestampToVersion = new HashMap<>();\n+        startTimestamps.forEach(timestamp -> {\n+            Optional<IdentifiedVersion> entry = timestampMap.getStartVersion(timestamp);\n+            checkConditionOrThrow(!entry.isPresent(), \"start timestamp missing from map\");\n+            timestampToVersion.put(timestamp, entry.get());\n+        });\n+        return timestampToVersion;\n+    }\n+\n+    @VisibleForTesting\n+    Optional<IdentifiedVersion> getEarliestVersion() {\n+        Optional<IdentifiedVersion> currentVersion = eventLog.getLatestKnownVersion();\n+        return timestampMap.getEarliestVersion().flatMap(sequence ->\n+                currentVersion.map(version -> IdentifiedVersion.of(version.id(), sequence)));\n+    }\n+\n+    private void checkConditionOrThrow(boolean condition, String message) {\n+        if (condition) {\n+            throw new TransactionLockWatchFailedException(message);\n+        }\n+    }\n+\n+    private CommitUpdate constructCommitUpdate(CommitInfo commitInfo, List<LockWatchEvent> events) {", "originalCommit": "0b5c5163688e4a03b23acb148c627c6adacad271", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIxNzc4MQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435217781", "bodyText": "Again, this is where you should clear out your stale events.", "author": "jkozlowski", "createdAt": "2020-06-04T12:34:30Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.atlasdb.keyvalue.api.watch.TimestampToVersionMap.CommitInfo;\n+import com.palantir.atlasdb.transaction.api.TransactionLockWatchFailedException;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.ClientLockWatchEventLog;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableInvalidateAll;\n+import com.palantir.lock.watch.ImmutableInvalidateSome;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.NoOpLockWatchEventCache;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchEvents;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This class should only be used through {@link ResilientLockWatchEventCache} as a proxy; failure to do so will result\n+ * in concurrency issues and inconsistency in the cache state.\n+ */\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final TimestampToVersionMap timestampMap;\n+\n+    public static LockWatchEventCache create() {\n+        return ResilientLockWatchEventCache.newProxyInstance(\n+                new LockWatchEventCacheImpl(ClientLockWatchEventLogImpl.create()), NoOpLockWatchEventCache.INSTANCE);\n+    }\n+\n+    @VisibleForTesting\n+    LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+        timestampMap = new TimestampToVersionMap();\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(\n+                version -> startTimestamps.forEach(timestamp -> timestampMap.putStartVersion(timestamp, version)));\n+\n+        getEarliestVersion().ifPresent(eventLog::removeOldEntries);\n+    }\n+\n+    @Override\n+    public void processGetCommitTimestampsUpdate(\n+            Collection<TransactionUpdate> transactionUpdates,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(version -> transactionUpdates.forEach(\n+                transactionUpdate -> checkConditionOrThrow(!timestampMap.putCommitUpdate(transactionUpdate, version),\n+                        \"start timestamp missing from map\")));\n+    }\n+\n+    @Override\n+    public CommitUpdate getCommitUpdate(long startTs) {\n+        Optional<IdentifiedVersion> startVersion = timestampMap.getStartVersion(startTs);\n+        Optional<CommitInfo> maybeCommitInfo = timestampMap.getCommitInfo(startTs);\n+\n+        checkConditionOrThrow(!maybeCommitInfo.isPresent() || !startVersion.isPresent(),\n+                \"start or commit info not processed for start timestamp\");\n+\n+        CommitInfo commitInfo = maybeCommitInfo.get();\n+\n+        ClientLogEvents update = eventLog.getEventsBetweenVersions(startVersion, commitInfo.commitVersion());\n+\n+        if (update.clearCache()) {\n+            return ImmutableInvalidateAll.builder().build();\n+        }\n+\n+        return constructCommitUpdate(commitInfo, update.events());\n+    }\n+\n+    @Override\n+    public TransactionsLockWatchEvents getEventsForTransactions(\n+            Set<Long> startTimestamps,\n+            Optional<IdentifiedVersion> startVersion) {\n+        Preconditions.checkArgument(!startTimestamps.isEmpty(), \"Cannot get events for empty set of transactions\");\n+        Map<Long, IdentifiedVersion> timestampToVersion = getTimestampMappings(startTimestamps);\n+        IdentifiedVersion endVersion = Collections.max(timestampToVersion.values(),\n+                Comparator.comparingLong(IdentifiedVersion::version));\n+        return eventLog.getEventsBetweenVersions(startVersion, endVersion).map(timestampToVersion);\n+    }\n+\n+    @Override\n+    public void removeTransactionStateFromCache(long startTimestamp) {\n+        timestampMap.remove(startTimestamp);", "originalCommit": "0b5c5163688e4a03b23acb148c627c6adacad271", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI2OTMyOA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435269328", "bodyText": "Done", "author": "Jolyon-S", "createdAt": "2020-06-04T13:47:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIxNzc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIxODc3MQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435218771", "bodyText": "nit: This name is weird and we should change it. My suggestion would actually be to flip things around:\n\nLockWatchEventCache -> LockWatchStateStore\nClientLockWatchEventLog -> LockWatchEventLog\n\nOr something to that effect, but \"Client\" is just not very good.", "author": "jkozlowski", "createdAt": "2020-06-04T12:36:11Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/ClientLockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.lock.watch.ClientLockWatchEventLog;\n+import com.palantir.lock.watch.ClientLockWatchSnapshotUpdater;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class ClientLockWatchEventLogImpl implements ClientLockWatchEventLog {", "originalCommit": "0b5c5163688e4a03b23acb148c627c6adacad271", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5NzUzMw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435397533", "bodyText": "I'm going to hold off on the rename to the cache, since that is used in a lot of places, and that would bloat the review by quite a lot. Renamed the log, although it is very similar to LockEventLog which is an entirely distinct piece.", "author": "Jolyon-S", "createdAt": "2020-06-04T16:39:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIxODc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIxOTY1OA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435219658", "bodyText": "I would maybe again suggest splitting a small datastructure class that has the API you need here.", "author": "jkozlowski", "createdAt": "2020-06-04T12:37:40Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/ClientLockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.lock.watch.ClientLockWatchEventLog;\n+import com.palantir.lock.watch.ClientLockWatchSnapshotUpdater;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class ClientLockWatchEventLogImpl implements ClientLockWatchEventLog {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final ClientLockWatchSnapshotUpdater snapshotUpdater;\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();", "originalCommit": "0b5c5163688e4a03b23acb148c627c6adacad271", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5NDM4Mg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435394382", "bodyText": "I personally disagree with this one. The other split made sense to me as it was strongly coupled (i.e. two maps), but I don't think we get much from wrapping this map in another class (other than a longer diff!). Unless you feel strongly about this I would rather keep as-is.", "author": "Jolyon-S", "createdAt": "2020-06-04T16:34:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIxOTY1OA=="}], "type": "inlineReview"}, {"oid": "4360b74ead3cad978df7e0467b1266394dbe21d7", "url": "https://github.com/palantir/atlasdb/commit/4360b74ead3cad978df7e0467b1266394dbe21d7", "message": "add metric to cache", "committedDate": "2020-06-04T13:09:40Z", "type": "commit"}, {"oid": "9aa1be25d7e446405cd2fb7eaf3bb5e91ad57df8", "url": "https://github.com/palantir/atlasdb/commit/9aa1be25d7e446405cd2fb7eaf3bb5e91ad57df8", "message": "fix bug", "committedDate": "2020-06-04T13:11:54Z", "type": "commit"}, {"oid": "5b89730d02510e22fd91d31add91b21206de0145", "url": "https://github.com/palantir/atlasdb/commit/5b89730d02510e22fd91d31add91b21206de0145", "message": "rename ttvm", "committedDate": "2020-06-04T13:15:23Z", "type": "commit"}, {"oid": "ef99edaf3ab20ae8e4ab7fefe05d1924c5e07fd4", "url": "https://github.com/palantir/atlasdb/commit/ef99edaf3ab20ae8e4ab7fefe05d1924c5e07fd4", "message": "put throws on multi put", "committedDate": "2020-06-04T13:19:05Z", "type": "commit"}, {"oid": "ed55d088580477bca66717c3cea9b7d18bf1d463", "url": "https://github.com/palantir/atlasdb/commit/ed55d088580477bca66717c3cea9b7d18bf1d463", "message": "more comments", "committedDate": "2020-06-04T13:21:16Z", "type": "commit"}, {"oid": "bc664f41566c14ae991c55da9c3b285548cd1153", "url": "https://github.com/palantir/atlasdb/commit/bc664f41566c14ae991c55da9c3b285548cd1153", "message": "invert check statement", "committedDate": "2020-06-04T13:22:15Z", "type": "commit"}, {"oid": "372047923a23661196f6ea250eaac6ad317e2795", "url": "https://github.com/palantir/atlasdb/commit/372047923a23661196f6ea250eaac6ad317e2795", "message": "fix tests and improve flow", "committedDate": "2020-06-04T13:42:45Z", "type": "commit"}, {"oid": "e7b56694b571956a51edd9d51f602f5e651ec751", "url": "https://github.com/palantir/atlasdb/commit/e7b56694b571956a51edd9d51f602f5e651ec751", "message": "move remove", "committedDate": "2020-06-04T13:46:10Z", "type": "commit"}, {"oid": "0cdaf846364db0ae9c81e02e1bca8b736f6d6302", "url": "https://github.com/palantir/atlasdb/commit/0cdaf846364db0ae9c81e02e1bca8b736f6d6302", "message": "use collections instead", "committedDate": "2020-06-04T14:13:11Z", "type": "commit"}, {"oid": "7d4ac9b3e8318dc9c0e2b89e2d1f1039dd4ef5ec", "url": "https://github.com/palantir/atlasdb/commit/7d4ac9b3e8318dc9c0e2b89e2d1f1039dd4ef5ec", "message": "fix test", "committedDate": "2020-06-04T14:58:09Z", "type": "commit"}, {"oid": "6484e61ffcf595f6fd2ae4fe71b8ca5eacaffcd1", "url": "https://github.com/palantir/atlasdb/commit/6484e61ffcf595f6fd2ae4fe71b8ca5eacaffcd1", "message": "rename method", "committedDate": "2020-06-04T15:00:17Z", "type": "commit"}, {"oid": "beedc8ed0be415e93ce86ec14ab0f1aa769f53c1", "url": "https://github.com/palantir/atlasdb/commit/beedc8ed0be415e93ce86ec14ab0f1aa769f53c1", "message": "rename some things", "committedDate": "2020-06-04T16:39:15Z", "type": "commit"}, {"oid": "aed50741f06984b1f7c68b8cf3dd4726dd2d1572", "url": "https://github.com/palantir/atlasdb/commit/aed50741f06984b1f7c68b8cf3dd4726dd2d1572", "message": "fix last comments", "committedDate": "2020-06-04T16:45:02Z", "type": "commit"}, {"oid": "b263bde7fc41bafe57d174bff24d2ce4432a55e7", "url": "https://github.com/palantir/atlasdb/commit/b263bde7fc41bafe57d174bff24d2ce4432a55e7", "message": "fix some checkstyle things", "committedDate": "2020-06-09T08:38:26Z", "type": "commit"}, {"oid": "5e65abf7fda4e6435c36ed024f1883ae19ceec65", "url": "https://github.com/palantir/atlasdb/commit/5e65abf7fda4e6435c36ed024f1883ae19ceec65", "message": "hopefully checkstyle is happy now", "committedDate": "2020-06-09T09:14:49Z", "type": "commit"}, {"oid": "250bf38d6cffb35f8d86bf52c16ceca136d5cbe8", "url": "https://github.com/palantir/atlasdb/commit/250bf38d6cffb35f8d86bf52c16ceca136d5cbe8", "message": "rename updater", "committedDate": "2020-06-09T12:15:08Z", "type": "commit"}, {"oid": "5dcd0b2160f8f0280f3c637e9b79ef5f1df5eb01", "url": "https://github.com/palantir/atlasdb/commit/5dcd0b2160f8f0280f3c637e9b79ef5f1df5eb01", "message": "Merge branch 'develop' into lw-client-cache-ete", "committedDate": "2020-06-09T13:27:50Z", "type": "commit"}, {"oid": "8393341804c51af20f5c632da9355c4efef045d4", "url": "https://github.com/palantir/atlasdb/commit/8393341804c51af20f5c632da9355c4efef045d4", "message": "Merge branch 'develop' into lw-client-cache-ete\n\n# Conflicts:\n#\tlock-api-objects/src/main/java/com/palantir/lock/watch/TransactionsLockWatchEvents.java\n#\tlock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchSnapshot.java\n#\tlock-api/src/main/java/com/palantir/lock/watch/NoOpLockWatchEventCache.java", "committedDate": "2020-06-09T14:50:08Z", "type": "commit"}, {"oid": "eff25d3afa288590c3da71553e1f94d94e7384f9", "url": "https://github.com/palantir/atlasdb/commit/eff25d3afa288590c3da71553e1f94d94e7384f9", "message": "fix merge conflict", "committedDate": "2020-06-09T14:52:53Z", "type": "commit"}, {"oid": "fcfeabe6d60eef57129a0a4da5c48c1f05878137", "url": "https://github.com/palantir/atlasdb/commit/fcfeabe6d60eef57129a0a4da5c48c1f05878137", "message": "fix checkstyle", "committedDate": "2020-06-09T14:55:17Z", "type": "commit"}, {"oid": "711e9bf5dca4a299e62330f05c3b88d0ceee0962", "url": "https://github.com/palantir/atlasdb/commit/711e9bf5dca4a299e62330f05c3b88d0ceee0962", "message": "remove empty file", "committedDate": "2020-06-09T15:21:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1MTU4NA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r437351584", "bodyText": "nit: Maybe \"ClientLockWatchSnapshot\", not sure Updater adds much.", "author": "jkozlowski", "createdAt": "2020-06-09T11:57:37Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/ClientLockWatchSnapshotUpdaterImpl.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.watch.ClientLockWatchSnapshotUpdater;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class ClientLockWatchSnapshotUpdaterImpl implements ClientLockWatchSnapshotUpdater {", "originalCommit": "5e65abf7fda4e6435c36ed024f1883ae19ceec65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODEyMjczMQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438122731", "bodyText": "Done", "author": "Jolyon-S", "createdAt": "2020-06-10T13:30:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1MTU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1MTc3OQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r437351779", "bodyText": "I don't think you need synchronized here anymore?", "author": "jkozlowski", "createdAt": "2020-06-09T11:58:00Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/ClientLockWatchSnapshotUpdaterImpl.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.watch.ClientLockWatchSnapshotUpdater;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class ClientLockWatchSnapshotUpdaterImpl implements ClientLockWatchSnapshotUpdater {\n+    private final Set<LockWatchReferences.LockWatchReference> watches;\n+    private final Set<LockDescriptor> locked;\n+    private final EventVisitor visitor;\n+    private Optional<IdentifiedVersion> snapshotVersion;\n+\n+    static ClientLockWatchSnapshotUpdater create() {\n+        return new ClientLockWatchSnapshotUpdaterImpl();\n+    }\n+\n+    private ClientLockWatchSnapshotUpdaterImpl() {\n+        this.watches = new HashSet<>();\n+        this.locked = new HashSet<>();\n+        this.visitor = new EventVisitor();\n+        this.snapshotVersion = Optional.empty();\n+    }\n+\n+    @Override\n+    public synchronized LockWatchStateUpdate.Snapshot getSnapshot() {", "originalCommit": "5e65abf7fda4e6435c36ed024f1883ae19ceec65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE0MDcyNA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438140724", "bodyText": "Removed", "author": "Jolyon-S", "createdAt": "2020-06-10T13:54:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1MTc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1MzMwNA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r437353304", "bodyText": "Does this interface need to be public here? Can you not keep it next to the implementation? I feel like this is implementation detail", "author": "jkozlowski", "createdAt": "2020-06-09T12:00:48Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchSnapshotUpdater.java", "diffHunk": "@@ -16,17 +16,11 @@\n \n package com.palantir.lock.watch;\n \n-import java.util.Collection;\n-import java.util.Optional;\n-import java.util.Set;\n+import java.util.List;\n \n-public interface LockWatchEventCache {\n-    Optional<IdentifiedVersion> lastKnownVersion();\n-    void processStartTransactionsUpdate(Set<Long> startTimestamps, LockWatchStateUpdate update);\n-    void processGetCommitTimestampsUpdate(Collection<TransactionUpdate> transactionUpdates,\n-            LockWatchStateUpdate update);\n-    CommitUpdate getCommitUpdate(long startTs);\n-    TransactionsLockWatchEvents getEventsForTransactions(Set<Long> startTimestamps,\n-            Optional<IdentifiedVersion> version);\n-    void removeTransactionStateFromCache(long startTimestamp);\n+public interface ClientLockWatchSnapshotUpdater {", "originalCommit": "5e65abf7fda4e6435c36ed024f1883ae19ceec65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE0Mjg5Mw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438142893", "bodyText": "Moved to be in same area as impl, and therefore removed public tag.", "author": "Jolyon-S", "createdAt": "2020-06-10T13:57:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1MzMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1MzU2NA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r437353564", "bodyText": "Does this interface need to be public here? Can you not keep it next to the implementation? I feel like this is implementation detail", "author": "jkozlowski", "createdAt": "2020-06-09T12:01:20Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLogEvents.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.immutables.value.Value;\n+\n+@Value.Immutable\n+public interface ClientLogEvents {", "originalCommit": "5e65abf7fda4e6435c36ed024f1883ae19ceec65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE0Mjk4MQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438142981", "bodyText": "Done.", "author": "Jolyon-S", "createdAt": "2020-06-10T13:57:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1MzU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1MzY4OQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r437353689", "bodyText": "I think this is the only API we need possibly?", "author": "jkozlowski", "createdAt": "2020-06-09T12:01:36Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCache.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public interface LockWatchEventCache {", "originalCommit": "5e65abf7fda4e6435c36ed024f1883ae19ceec65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE0MzEzNw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438143137", "bodyText": "Agreed", "author": "Jolyon-S", "createdAt": "2020-06-10T13:58:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1MzY4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1Mzc1Mg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r437353752", "bodyText": "Does this interface need to be public here? Can you not keep it next to the implementation? I feel like this is implementation detail", "author": "jkozlowski", "createdAt": "2020-06-09T12:01:44Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventLog.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Optional;\n+\n+public interface LockWatchEventLog {", "originalCommit": "5e65abf7fda4e6435c36ed024f1883ae19ceec65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE0MzI4Mw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438143283", "bodyText": "Done", "author": "Jolyon-S", "createdAt": "2020-06-10T13:58:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1Mzc1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1NDA1Nw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r437354057", "bodyText": "Where are the mocks?", "author": "jkozlowski", "createdAt": "2020-06-09T12:02:20Z", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/ClientLockWatchSnapshotUpdaterImplTest.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.ClientLockWatchSnapshotUpdater;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+\n+@RunWith(MockitoJUnitRunner.class)", "originalCommit": "5e65abf7fda4e6435c36ed024f1883ae19ceec65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE0MzYzNA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438143634", "bodyText": "Good catch!", "author": "Jolyon-S", "createdAt": "2020-06-10T13:58:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1NDA1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1NDM5OA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r437354398", "bodyText": "Test for what happens after a reset?", "author": "jkozlowski", "createdAt": "2020-06-09T12:02:55Z", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/ClientLockWatchSnapshotUpdaterImplTest.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.ClientLockWatchSnapshotUpdater;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public final class ClientLockWatchSnapshotUpdaterImplTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_2))\n+                    .build(0L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(1L);\n+    private static final LockWatchEvent LOCK_EVENT = LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3),\n+            LockToken.of(UUID.randomUUID())).build(2L);\n+    private static final IdentifiedVersion VERSION = IdentifiedVersion.of(UUID.randomUUID(), 999L);\n+\n+    private ClientLockWatchSnapshotUpdater snapshotUpdater;\n+\n+    @Before\n+    public void before() {\n+        snapshotUpdater = ClientLockWatchSnapshotUpdaterImpl.create();\n+    }\n+\n+    @Test\n+    public void eventsProcessedAsExpected() {\n+        snapshotUpdater.processEvents(ImmutableList.of(WATCH_EVENT), VERSION);\n+        LockWatchStateUpdate.Snapshot snapshot = snapshotUpdater.getSnapshot();\n+        assertThat(snapshot.locked()).containsExactlyInAnyOrder(DESCRIPTOR, DESCRIPTOR_2);\n+        assertThat(snapshot.lockWatches()).containsExactlyInAnyOrder(REFERENCE);\n+\n+        snapshotUpdater.processEvents(ImmutableList.of(UNLOCK_EVENT, LOCK_EVENT), VERSION);\n+        LockWatchStateUpdate.Snapshot snapshot2 = snapshotUpdater.getSnapshot();\n+        assertThat(snapshot2.locked()).containsExactlyInAnyOrder(DESCRIPTOR, DESCRIPTOR_3);\n+        assertThat(snapshot2.lockWatches()).containsExactlyInAnyOrder(REFERENCE);\n+    }", "originalCommit": "5e65abf7fda4e6435c36ed024f1883ae19ceec65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE1NTQ2MA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438155460", "bodyText": "Done for both snapshot and failure case; can always remove failure case when we need to.", "author": "Jolyon-S", "createdAt": "2020-06-10T14:14:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1NDM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1NDkyMQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r437354921", "bodyText": "You probably want to extract this into a variable that is shared with the WATCH_EVENT", "author": "jkozlowski", "createdAt": "2020-06-09T12:03:50Z", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/ClientLockWatchSnapshotUpdaterImplTest.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.ClientLockWatchSnapshotUpdater;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public final class ClientLockWatchSnapshotUpdaterImplTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_2))\n+                    .build(0L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(1L);\n+    private static final LockWatchEvent LOCK_EVENT = LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3),\n+            LockToken.of(UUID.randomUUID())).build(2L);\n+    private static final IdentifiedVersion VERSION = IdentifiedVersion.of(UUID.randomUUID(), 999L);\n+\n+    private ClientLockWatchSnapshotUpdater snapshotUpdater;\n+\n+    @Before\n+    public void before() {\n+        snapshotUpdater = ClientLockWatchSnapshotUpdaterImpl.create();\n+    }\n+\n+    @Test\n+    public void eventsProcessedAsExpected() {\n+        snapshotUpdater.processEvents(ImmutableList.of(WATCH_EVENT), VERSION);\n+        LockWatchStateUpdate.Snapshot snapshot = snapshotUpdater.getSnapshot();\n+        assertThat(snapshot.locked()).containsExactlyInAnyOrder(DESCRIPTOR, DESCRIPTOR_2);", "originalCommit": "5e65abf7fda4e6435c36ed024f1883ae19ceec65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE0ODQxMg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438148412", "bodyText": "Done", "author": "Jolyon-S", "createdAt": "2020-06-10T14:05:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1NDkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA5NTEyOA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438095128", "bodyText": "This extends here is really trippy. I'd rather you copy paste some code than use inheritance, for clarity what happens in what state.", "author": "jkozlowski", "createdAt": "2020-06-10T12:49:47Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.lock.watch.ClientLockWatchSnapshot;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventLog;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class LockWatchEventLogImpl implements LockWatchEventLog {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final ClientLockWatchSnapshot snapshot;\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    static LockWatchEventLog create() {\n+        return create(ClientLockWatchSnapshotImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventLog create(ClientLockWatchSnapshot snapshot) {\n+        return new LockWatchEventLogImpl(snapshot);\n+    }\n+\n+    private LockWatchEventLogImpl(ClientLockWatchSnapshot snapshot) {\n+        this.snapshot = snapshot;\n+    }\n+\n+    @Override\n+    public boolean processUpdate(LockWatchStateUpdate update) {\n+        final ProcessingVisitor visitor;\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            visitor = new NewLeaderVisitor();\n+        } else {\n+            visitor = new ProcessingVisitor();\n+        }\n+        return update.accept(visitor);\n+    }\n+\n+    @Override\n+    public ClientLogEvents getEventsBetweenVersions(\n+            Optional<IdentifiedVersion> startVersion,\n+            IdentifiedVersion endVersion) {\n+        Optional<IdentifiedVersion> versionInclusive = startVersion.map(this::createInclusiveVersion);\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(endVersion);\n+        ClientLogEvents.Builder eventBuilder = new ClientLogEvents.Builder();\n+        final long fromSequence;\n+\n+        if (!versionInclusive.isPresent() || differentLeaderOrTooFarBehind(currentVersion, versionInclusive.get())) {\n+            eventBuilder.addEvents(LockWatchCreatedEvent.fromSnapshot(snapshot.getSnapshot()));\n+            eventBuilder.clearCache(true);\n+            if (eventMap.isEmpty()) {\n+                return eventBuilder.build();\n+            }\n+            fromSequence = eventMap.firstKey();\n+        } else {\n+            eventBuilder.clearCache(false);\n+            fromSequence = versionInclusive.get().version();\n+        }\n+\n+        eventBuilder.addAllEvents(eventMap.subMap(fromSequence, INCLUSIVE, endVersion.version(), INCLUSIVE).values());\n+        return eventBuilder.build();\n+    }\n+\n+    @Override\n+    public void removeOldEntries(long earliestSequence) {\n+        Set<Map.Entry<Long, LockWatchEvent>> eventsToBeRemoved = eventMap.headMap(earliestSequence).entrySet();\n+        Optional<Long> latestDeletedVersion = Streams.findLast(eventsToBeRemoved.stream()).map(Map.Entry::getKey);\n+        Optional<IdentifiedVersion> currentVersion = getLatestKnownVersion();\n+\n+        if (eventsToBeRemoved.isEmpty() || !latestDeletedVersion.isPresent() || !currentVersion.isPresent()) {\n+            return;\n+        }\n+\n+        snapshot.processEvents(\n+                eventsToBeRemoved.stream().map(Map.Entry::getValue).collect(Collectors.toList()),\n+                IdentifiedVersion.of(currentVersion.get().id(), latestDeletedVersion.get()));\n+        eventsToBeRemoved.clear();\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> getLatestKnownVersion() {\n+        return latestVersion;\n+    }\n+\n+    private boolean differentLeaderOrTooFarBehind(IdentifiedVersion currentVersion,\n+            IdentifiedVersion startVersion) {\n+        return !startVersion.id().equals(currentVersion.id()) || eventMap.floorKey(startVersion.version()) == null;\n+    }\n+\n+    private IdentifiedVersion createInclusiveVersion(IdentifiedVersion startVersion) {\n+        return IdentifiedVersion.of(startVersion.id(), startVersion.version() + 1);\n+    }\n+\n+    private IdentifiedVersion getLatestVersionAndVerify(IdentifiedVersion endVersion) {\n+        Preconditions.checkState(latestVersion.isPresent(), \"Cannot get events when log does not know its version\");\n+        IdentifiedVersion currentVersion = latestVersion.get();\n+        Preconditions.checkArgument(endVersion.version() <= currentVersion.version(),\n+                \"Transactions' view of the world is more up-to-date than the log\");\n+        return currentVersion;\n+    }\n+\n+    private void processSuccess(LockWatchStateUpdate.Success success) {\n+        Preconditions.checkState(latestVersion.isPresent(), \"Must have a known version to process successful updates\");\n+\n+        if (success.lastKnownVersion() > latestVersion.get().version()) {\n+            success.events().forEach(event -> eventMap.put(event.sequence(), event));\n+            latestVersion = Optional.of(IdentifiedVersion.of(success.logId(), eventMap.lastKey()));\n+        }\n+    }\n+\n+    private void processSnapshot(LockWatchStateUpdate.Snapshot snapshotUpdate) {\n+        eventMap.clear();\n+        this.snapshot.resetWithSnapshot(snapshotUpdate);\n+        latestVersion = Optional.of(IdentifiedVersion.of(snapshotUpdate.logId(), snapshotUpdate.lastKnownVersion()));\n+    }\n+\n+    private void processFailed() {\n+        eventMap.clear();\n+        snapshot.reset();\n+        latestVersion = Optional.empty();\n+    }\n+\n+    private class ProcessingVisitor implements LockWatchStateUpdate.Visitor<Boolean> {\n+        @Override\n+        public Boolean visit(LockWatchStateUpdate.Failed failed) {\n+            processFailed();\n+            return false;\n+        }\n+\n+        @Override\n+        public Boolean visit(LockWatchStateUpdate.Success success) {\n+            processSuccess(success);\n+            return true;\n+        }\n+\n+        @Override\n+        public Boolean visit(LockWatchStateUpdate.Snapshot snapshotUpdate) {\n+            processSnapshot(snapshotUpdate);\n+            return false;\n+        }\n+    }\n+\n+    private final class NewLeaderVisitor extends ProcessingVisitor {", "originalCommit": "711e9bf5dca4a299e62330f05c3b88d0ceee0962", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE0ODQ4NQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438148485", "bodyText": "Done", "author": "Jolyon-S", "createdAt": "2020-06-10T14:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA5NTEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA5NTYyNw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438095627", "bodyText": "using a boolean to indicate something here is really hard to reason about, and probably easy to screw up. Have an enum ShouldClearCache or something", "author": "jkozlowski", "createdAt": "2020-06-10T12:50:30Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.lock.watch.ClientLockWatchSnapshot;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventLog;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class LockWatchEventLogImpl implements LockWatchEventLog {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final ClientLockWatchSnapshot snapshot;\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    static LockWatchEventLog create() {\n+        return create(ClientLockWatchSnapshotImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventLog create(ClientLockWatchSnapshot snapshot) {\n+        return new LockWatchEventLogImpl(snapshot);\n+    }\n+\n+    private LockWatchEventLogImpl(ClientLockWatchSnapshot snapshot) {\n+        this.snapshot = snapshot;\n+    }\n+\n+    @Override\n+    public boolean processUpdate(LockWatchStateUpdate update) {", "originalCommit": "711e9bf5dca4a299e62330f05c3b88d0ceee0962", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE0ODU3Mw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438148573", "bodyText": "Done", "author": "Jolyon-S", "createdAt": "2020-06-10T14:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA5NTYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODEwNTQ1NA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438105454", "bodyText": "So I think this is good, because you should not assume that startTransaction requests are processed in a single-threaded way. BUT startTransaction and getCommitTimestamp can run concurrently. And I wonder if we should assume that there can't be more concurrent executions in general.\nI wonder if the below if statement is enough to catch reordered execution between these and therefore I'm wondering if the callers should pass their lastKnown version. So imagine you have:\nThread 1: calls startTransactions on timelock with latestVersion 1\nThread 2: calls getCommitTimestamp with latestVersion 1 (because Thread 1 hasn't returned yet)\nThread 2: returns events [2,3]\nThread 1: returns events [2,3,4]\nIs there some reordering where you would loose events somehow and end up with holes?  Should we have the eventMap also know what the last eventId it has is and know what to expect afterwards, and double check they're coming back in the right order?", "author": "jkozlowski", "createdAt": "2020-06-10T13:05:16Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.lock.watch.ClientLockWatchSnapshot;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventLog;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class LockWatchEventLogImpl implements LockWatchEventLog {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final ClientLockWatchSnapshot snapshot;\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    static LockWatchEventLog create() {\n+        return create(ClientLockWatchSnapshotImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventLog create(ClientLockWatchSnapshot snapshot) {\n+        return new LockWatchEventLogImpl(snapshot);\n+    }\n+\n+    private LockWatchEventLogImpl(ClientLockWatchSnapshot snapshot) {\n+        this.snapshot = snapshot;\n+    }\n+\n+    @Override\n+    public boolean processUpdate(LockWatchStateUpdate update) {\n+        final ProcessingVisitor visitor;\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            visitor = new NewLeaderVisitor();\n+        } else {\n+            visitor = new ProcessingVisitor();\n+        }\n+        return update.accept(visitor);\n+    }\n+\n+    @Override\n+    public ClientLogEvents getEventsBetweenVersions(\n+            Optional<IdentifiedVersion> startVersion,\n+            IdentifiedVersion endVersion) {\n+        Optional<IdentifiedVersion> versionInclusive = startVersion.map(this::createInclusiveVersion);\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(endVersion);\n+        ClientLogEvents.Builder eventBuilder = new ClientLogEvents.Builder();\n+        final long fromSequence;\n+\n+        if (!versionInclusive.isPresent() || differentLeaderOrTooFarBehind(currentVersion, versionInclusive.get())) {\n+            eventBuilder.addEvents(LockWatchCreatedEvent.fromSnapshot(snapshot.getSnapshot()));\n+            eventBuilder.clearCache(true);\n+            if (eventMap.isEmpty()) {\n+                return eventBuilder.build();\n+            }\n+            fromSequence = eventMap.firstKey();\n+        } else {\n+            eventBuilder.clearCache(false);\n+            fromSequence = versionInclusive.get().version();\n+        }\n+\n+        eventBuilder.addAllEvents(eventMap.subMap(fromSequence, INCLUSIVE, endVersion.version(), INCLUSIVE).values());\n+        return eventBuilder.build();\n+    }\n+\n+    @Override\n+    public void removeOldEntries(long earliestSequence) {\n+        Set<Map.Entry<Long, LockWatchEvent>> eventsToBeRemoved = eventMap.headMap(earliestSequence).entrySet();\n+        Optional<Long> latestDeletedVersion = Streams.findLast(eventsToBeRemoved.stream()).map(Map.Entry::getKey);\n+        Optional<IdentifiedVersion> currentVersion = getLatestKnownVersion();\n+\n+        if (eventsToBeRemoved.isEmpty() || !latestDeletedVersion.isPresent() || !currentVersion.isPresent()) {\n+            return;\n+        }\n+\n+        snapshot.processEvents(\n+                eventsToBeRemoved.stream().map(Map.Entry::getValue).collect(Collectors.toList()),\n+                IdentifiedVersion.of(currentVersion.get().id(), latestDeletedVersion.get()));\n+        eventsToBeRemoved.clear();\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> getLatestKnownVersion() {\n+        return latestVersion;\n+    }\n+\n+    private boolean differentLeaderOrTooFarBehind(IdentifiedVersion currentVersion,\n+            IdentifiedVersion startVersion) {\n+        return !startVersion.id().equals(currentVersion.id()) || eventMap.floorKey(startVersion.version()) == null;\n+    }\n+\n+    private IdentifiedVersion createInclusiveVersion(IdentifiedVersion startVersion) {\n+        return IdentifiedVersion.of(startVersion.id(), startVersion.version() + 1);\n+    }\n+\n+    private IdentifiedVersion getLatestVersionAndVerify(IdentifiedVersion endVersion) {\n+        Preconditions.checkState(latestVersion.isPresent(), \"Cannot get events when log does not know its version\");\n+        IdentifiedVersion currentVersion = latestVersion.get();\n+        Preconditions.checkArgument(endVersion.version() <= currentVersion.version(),\n+                \"Transactions' view of the world is more up-to-date than the log\");\n+        return currentVersion;\n+    }\n+\n+    private void processSuccess(LockWatchStateUpdate.Success success) {\n+        Preconditions.checkState(latestVersion.isPresent(), \"Must have a known version to process successful updates\");", "originalCommit": "711e9bf5dca4a299e62330f05c3b88d0ceee0962", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODEyODE4NQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438128185", "bodyText": "I have thought about this a lot, and I do not think that the above causes problems. Thread 2 would return events [2, 3] and they are put into the cache; the cache's latest version is now 3. Now, thread 1 returns [2, 3, 4] and the latest version of that update, 4, is greater than 3. Therefore it would process those events again. Now, you are possibly thinking: 2, 3 are double-processed; can we get into a state where:\nCache contains values [3 ... X]\nupdate which started ages ago comes back with values [2 ... X + 1]\nWe've already retentioned 2, but now it's been re-processed. However, this is still fine.\na) Events are only retentioned when the earliest version in the cache above are gone. If an old event (2 in the above example) re-appears, it would never be used, as all timestamps have versions after it anyway.\nb) We assume that there are no holes, and I believe this to be a fair assumption: I believe the ordering:\nThread A returns [2,3]\nThread B returns [5, 6]\nThread C returns [4] (which we miss since 4 < 5)\nis impossible; there is no way that thread B can return [5, 6] without also containing [4], as it must have started with the latest version in the cache, 3.\nThe bottom line is that I do not believe that there is a way that we leave a hole. Let me know if this makes sense; I don't think anything else is needed for correctness, but if there is anything to make this less potentially scary then maybe it is worth doing.", "author": "Jolyon-S", "createdAt": "2020-06-10T13:37:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODEwNTQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExNDEwOA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438114108", "bodyText": "This is quite gnarly to read, but I think correct.", "author": "jkozlowski", "createdAt": "2020-06-10T13:18:16Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.lock.watch.ClientLockWatchSnapshot;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventLog;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class LockWatchEventLogImpl implements LockWatchEventLog {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final ClientLockWatchSnapshot snapshot;\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    static LockWatchEventLog create() {\n+        return create(ClientLockWatchSnapshotImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventLog create(ClientLockWatchSnapshot snapshot) {\n+        return new LockWatchEventLogImpl(snapshot);\n+    }\n+\n+    private LockWatchEventLogImpl(ClientLockWatchSnapshot snapshot) {\n+        this.snapshot = snapshot;\n+    }\n+\n+    @Override\n+    public boolean processUpdate(LockWatchStateUpdate update) {\n+        final ProcessingVisitor visitor;\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            visitor = new NewLeaderVisitor();\n+        } else {\n+            visitor = new ProcessingVisitor();\n+        }\n+        return update.accept(visitor);\n+    }\n+\n+    @Override\n+    public ClientLogEvents getEventsBetweenVersions(\n+            Optional<IdentifiedVersion> startVersion,\n+            IdentifiedVersion endVersion) {\n+        Optional<IdentifiedVersion> versionInclusive = startVersion.map(this::createInclusiveVersion);", "originalCommit": "711e9bf5dca4a299e62330f05c3b88d0ceee0962", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExNTYyNw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438115627", "bodyText": "I think you should review your code to make sure this naming is the same everywhere. The name in the API is \"lastKnownVersion\" meaning the client knows of events up to and including this version.", "author": "jkozlowski", "createdAt": "2020-06-10T13:20:32Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.lock.watch.ClientLockWatchSnapshot;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventLog;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class LockWatchEventLogImpl implements LockWatchEventLog {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final ClientLockWatchSnapshot snapshot;\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    static LockWatchEventLog create() {\n+        return create(ClientLockWatchSnapshotImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventLog create(ClientLockWatchSnapshot snapshot) {\n+        return new LockWatchEventLogImpl(snapshot);\n+    }\n+\n+    private LockWatchEventLogImpl(ClientLockWatchSnapshot snapshot) {\n+        this.snapshot = snapshot;\n+    }\n+\n+    @Override\n+    public boolean processUpdate(LockWatchStateUpdate update) {\n+        final ProcessingVisitor visitor;\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            visitor = new NewLeaderVisitor();\n+        } else {\n+            visitor = new ProcessingVisitor();\n+        }\n+        return update.accept(visitor);\n+    }\n+\n+    @Override\n+    public ClientLogEvents getEventsBetweenVersions(\n+            Optional<IdentifiedVersion> startVersion,", "originalCommit": "711e9bf5dca4a299e62330f05c3b88d0ceee0962", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE1MTI0Ng==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438151246", "bodyText": "Done", "author": "Jolyon-S", "createdAt": "2020-06-10T14:09:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExNTYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExNjA1Ng==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438116056", "bodyText": "This is why the \"inclusiveVersion\" is kinda misleading here: the version is already inclusive, you are trying to compute the next eventId after that.", "author": "jkozlowski", "createdAt": "2020-06-10T13:21:11Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.lock.watch.ClientLockWatchSnapshot;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventLog;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class LockWatchEventLogImpl implements LockWatchEventLog {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final ClientLockWatchSnapshot snapshot;\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    static LockWatchEventLog create() {\n+        return create(ClientLockWatchSnapshotImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventLog create(ClientLockWatchSnapshot snapshot) {\n+        return new LockWatchEventLogImpl(snapshot);\n+    }\n+\n+    private LockWatchEventLogImpl(ClientLockWatchSnapshot snapshot) {\n+        this.snapshot = snapshot;\n+    }\n+\n+    @Override\n+    public boolean processUpdate(LockWatchStateUpdate update) {\n+        final ProcessingVisitor visitor;\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            visitor = new NewLeaderVisitor();\n+        } else {\n+            visitor = new ProcessingVisitor();\n+        }\n+        return update.accept(visitor);\n+    }\n+\n+    @Override\n+    public ClientLogEvents getEventsBetweenVersions(\n+            Optional<IdentifiedVersion> startVersion,\n+            IdentifiedVersion endVersion) {\n+        Optional<IdentifiedVersion> versionInclusive = startVersion.map(this::createInclusiveVersion);", "originalCommit": "711e9bf5dca4a299e62330f05c3b88d0ceee0962", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODEzMDQwNg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438130406", "bodyText": "Well, the client passes down the last version that they know about - i.e. \"I have all events up to and including this version\". Therefore the earliest event possible that is still useful is one immediately after that version, right? i.e. X+1?", "author": "Jolyon-S", "createdAt": "2020-06-10T13:41:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExNjA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODEzMDYyNg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438130626", "bodyText": "Although I agree that the naming is perhaps a bit hard to parse", "author": "Jolyon-S", "createdAt": "2020-06-10T13:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExNjA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE1MDg5OA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438150898", "bodyText": "ah, so the client's version is \"inclusive\" of the events they know, whereas this is the version that is \"inclusive\" of what I want to know.", "author": "Jolyon-S", "createdAt": "2020-06-10T14:08:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExNjA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE1MTM5NQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438151395", "bodyText": "I think I've made it clearer", "author": "Jolyon-S", "createdAt": "2020-06-10T14:09:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExNjA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExNzg0MQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438117841", "bodyText": "This is more like \"eventIdToKeep\"", "author": "jkozlowski", "createdAt": "2020-06-10T13:23:36Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.lock.watch.ClientLockWatchSnapshot;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventLog;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class LockWatchEventLogImpl implements LockWatchEventLog {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final ClientLockWatchSnapshot snapshot;\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    static LockWatchEventLog create() {\n+        return create(ClientLockWatchSnapshotImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventLog create(ClientLockWatchSnapshot snapshot) {\n+        return new LockWatchEventLogImpl(snapshot);\n+    }\n+\n+    private LockWatchEventLogImpl(ClientLockWatchSnapshot snapshot) {\n+        this.snapshot = snapshot;\n+    }\n+\n+    @Override\n+    public boolean processUpdate(LockWatchStateUpdate update) {\n+        final ProcessingVisitor visitor;\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            visitor = new NewLeaderVisitor();\n+        } else {\n+            visitor = new ProcessingVisitor();\n+        }\n+        return update.accept(visitor);\n+    }\n+\n+    @Override\n+    public ClientLogEvents getEventsBetweenVersions(\n+            Optional<IdentifiedVersion> startVersion,\n+            IdentifiedVersion endVersion) {\n+        Optional<IdentifiedVersion> versionInclusive = startVersion.map(this::createInclusiveVersion);\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(endVersion);\n+        ClientLogEvents.Builder eventBuilder = new ClientLogEvents.Builder();\n+        final long fromSequence;\n+\n+        if (!versionInclusive.isPresent() || differentLeaderOrTooFarBehind(currentVersion, versionInclusive.get())) {\n+            eventBuilder.addEvents(LockWatchCreatedEvent.fromSnapshot(snapshot.getSnapshot()));\n+            eventBuilder.clearCache(true);\n+            if (eventMap.isEmpty()) {\n+                return eventBuilder.build();\n+            }\n+            fromSequence = eventMap.firstKey();\n+        } else {\n+            eventBuilder.clearCache(false);\n+            fromSequence = versionInclusive.get().version();\n+        }\n+\n+        eventBuilder.addAllEvents(eventMap.subMap(fromSequence, INCLUSIVE, endVersion.version(), INCLUSIVE).values());\n+        return eventBuilder.build();\n+    }\n+\n+    @Override\n+    public void removeOldEntries(long earliestSequence) {", "originalCommit": "711e9bf5dca4a299e62330f05c3b88d0ceee0962", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE1NjI2MA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438156260", "bodyText": "I think I would prefer removeEventsBefore - will change it to that (as that still implies that there is some removing occurring).", "author": "Jolyon-S", "createdAt": "2020-06-10T14:15:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExNzg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExOTcwNQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438119705", "bodyText": "I don't think it would hurt to be defensive here and check that the events are contiguous and the first event in \"events\" has id that is the next if after your snapshot version.", "author": "jkozlowski", "createdAt": "2020-06-10T13:26:13Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/ClientLockWatchSnapshotImpl.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.watch.ClientLockWatchSnapshot;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class ClientLockWatchSnapshotImpl implements ClientLockWatchSnapshot {\n+    private final Set<LockWatchReferences.LockWatchReference> watches;\n+    private final Set<LockDescriptor> locked;\n+    private final EventVisitor visitor;\n+    private Optional<IdentifiedVersion> snapshotVersion;\n+\n+    static ClientLockWatchSnapshot create() {\n+        return new ClientLockWatchSnapshotImpl();\n+    }\n+\n+    private ClientLockWatchSnapshotImpl() {\n+        this.watches = new HashSet<>();\n+        this.locked = new HashSet<>();\n+        this.visitor = new EventVisitor();\n+        this.snapshotVersion = Optional.empty();\n+    }\n+\n+    @Override\n+    public synchronized LockWatchStateUpdate.Snapshot getSnapshot() {\n+        Preconditions.checkState(snapshotVersion.isPresent(),\n+                \"Snapshot was reset on fail and has not been seeded since\");\n+        return LockWatchStateUpdate.snapshot(\n+                snapshotVersion.get().id(),\n+                snapshotVersion.get().version(),\n+                ImmutableSet.copyOf(locked),\n+                ImmutableSet.copyOf(watches));\n+    }\n+\n+    @Override\n+    public void processEvents(List<LockWatchEvent> events, IdentifiedVersion lastVersion) {\n+        events.forEach(event -> event.accept(visitor));", "originalCommit": "711e9bf5dca4a299e62330f05c3b88d0ceee0962", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE2Mzc3MQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438163771", "bodyText": "Done", "author": "Jolyon-S", "createdAt": "2020-06-10T14:25:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExOTcwNQ=="}], "type": "inlineReview"}, {"oid": "14db375a512ddb5f9c1bb3bea9020d9ab9d0c626", "url": "https://github.com/palantir/atlasdb/commit/14db375a512ddb5f9c1bb3bea9020d9ab9d0c626", "message": "split more things out", "committedDate": "2020-06-10T13:54:35Z", "type": "commit"}, {"oid": "c6c1f78898dfedeec445e0690402c56dcd58a719", "url": "https://github.com/palantir/atlasdb/commit/c6c1f78898dfedeec445e0690402c56dcd58a719", "message": "moved a load of things", "committedDate": "2020-06-10T13:58:19Z", "type": "commit"}, {"oid": "fd6b3abe1cca4ded6939fdb0e64137afa8d14e61", "url": "https://github.com/palantir/atlasdb/commit/fd6b3abe1cca4ded6939fdb0e64137afa8d14e61", "message": "more changes per review", "committedDate": "2020-06-10T14:16:13Z", "type": "commit"}, {"oid": "8e54d0809d038b9f5b0c4f3601f49ba080092d92", "url": "https://github.com/palantir/atlasdb/commit/8e54d0809d038b9f5b0c4f3601f49ba080092d92", "message": "fixup last tests", "committedDate": "2020-06-10T14:28:50Z", "type": "commit"}, {"oid": "ade7bca29ba0d396627a3c754950e4033536dade", "url": "https://github.com/palantir/atlasdb/commit/ade7bca29ba0d396627a3c754950e4033536dade", "message": "add store test", "committedDate": "2020-06-10T15:39:21Z", "type": "commit"}, {"oid": "a311fcd0f3b3833f664d435b534eb38ad556deae", "url": "https://github.com/palantir/atlasdb/commit/a311fcd0f3b3833f664d435b534eb38ad556deae", "message": "checkstyle hurrah", "committedDate": "2020-06-10T15:41:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIyOTkyNQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438229925", "bodyText": "Dodgy diff, because I moved a load of things", "author": "Jolyon-S", "createdAt": "2020-06-10T15:51:42Z", "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/CacheStatus.java", "diffHunk": "@@ -16,17 +16,17 @@\n \n package com.palantir.lock.watch;\n \n-import java.util.Collection;\n-import java.util.Optional;\n-import java.util.Set;\n+public enum CacheStatus {", "originalCommit": "a311fcd0f3b3833f664d435b534eb38ad556deae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUwOTQ4MQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441509481", "bodyText": "This should be long putAll(Iterable events), then your code that uses it becomes:\nlatestVersion = Optional.of(IdentifiedVersion.of(success.logId(), eventStore.putAll(success.events())));\n\nAnd you can make #getFirstKey private.", "author": "jkozlowski", "createdAt": "2020-06-17T12:34:08Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/VersionedEventStore.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class VersionedEventStore {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    boolean isEmpty() {\n+        return eventMap.isEmpty();\n+    }\n+\n+    long getFirstKey() {\n+        Preconditions.checkState(!eventMap.isEmpty(), \"Cannot get first key from empty map\");\n+        return eventMap.firstKey();\n+    }\n+\n+    long getLastKey() {\n+        Preconditions.checkState(!eventMap.isEmpty(), \"Cannot get last key from empty map\");\n+        return eventMap.lastKey();\n+    }\n+\n+    Collection<LockWatchEvent> getEventsBetweenVersionsInclusive(long startVersion, long endVersion) {\n+        return eventMap.subMap(startVersion, INCLUSIVE, endVersion, INCLUSIVE).values();\n+    }\n+\n+    Set<Map.Entry<Long, LockWatchEvent>> getElementsUpToExclusive(long endVersion) {\n+        return ImmutableSet.copyOf(eventMap.headMap(endVersion).entrySet());\n+    }\n+\n+    void clearElementsUpToExclusive(long endVersion) {\n+        eventMap.headMap(endVersion).entrySet().clear();\n+    }\n+\n+    boolean hasFloorKey(long key) {\n+        return eventMap.floorKey(key) != null;\n+    }\n+\n+    void clear() {\n+        eventMap.clear();\n+    }\n+\n+    void put(long version, LockWatchEvent event) {", "originalCommit": "a311fcd0f3b3833f664d435b534eb38ad556deae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYxODMwNg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441618306", "bodyText": "Done", "author": "Jolyon-S", "createdAt": "2020-06-17T15:06:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUwOTQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxMDEzMw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441510133", "bodyText": "This should be #contains.", "author": "jkozlowski", "createdAt": "2020-06-17T12:35:14Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/VersionedEventStore.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class VersionedEventStore {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    boolean isEmpty() {\n+        return eventMap.isEmpty();\n+    }\n+\n+    long getFirstKey() {\n+        Preconditions.checkState(!eventMap.isEmpty(), \"Cannot get first key from empty map\");\n+        return eventMap.firstKey();\n+    }\n+\n+    long getLastKey() {\n+        Preconditions.checkState(!eventMap.isEmpty(), \"Cannot get last key from empty map\");\n+        return eventMap.lastKey();\n+    }\n+\n+    Collection<LockWatchEvent> getEventsBetweenVersionsInclusive(long startVersion, long endVersion) {\n+        return eventMap.subMap(startVersion, INCLUSIVE, endVersion, INCLUSIVE).values();\n+    }\n+\n+    Set<Map.Entry<Long, LockWatchEvent>> getElementsUpToExclusive(long endVersion) {\n+        return ImmutableSet.copyOf(eventMap.headMap(endVersion).entrySet());\n+    }\n+\n+    void clearElementsUpToExclusive(long endVersion) {\n+        eventMap.headMap(endVersion).entrySet().clear();\n+    }\n+\n+    boolean hasFloorKey(long key) {", "originalCommit": "a311fcd0f3b3833f664d435b534eb38ad556deae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYxODU3Nw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441618577", "bodyText": "done", "author": "Jolyon-S", "createdAt": "2020-06-17T15:06:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxMDEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxMjk2Mw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441512963", "bodyText": "I think this should be something like:\ngetLatestKnownVersion().ifPresent(currentVersion -> {\nSet<Map.Entry<Long, LockWatchEvent>> eventsToBeRemoved = eventStore.removeEventsUpToExlusive(earliestSequence);\n  snapshot.processEvents(\n                removedEvents.stream().map(Map.Entry::getValue).collect(Collectors.toList()),\n                IdentifiedVersion.of(currentVersion.get().id(), latestDeletedVersion.get()))\n}) ;\n\nThis should allow you to get rid of VersionedEventStore#getElementsUpToExclusive and generally clean this up.", "author": "jkozlowski", "createdAt": "2020-06-17T12:40:01Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.lock.watch.CacheStatus;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class LockWatchEventLogImpl implements LockWatchEventLog {\n+    private final ClientLockWatchSnapshot snapshot;\n+    private final VersionedEventStore eventStore = new VersionedEventStore();\n+\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    static LockWatchEventLog create() {\n+        return create(ClientLockWatchSnapshotImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventLog create(ClientLockWatchSnapshot snapshot) {\n+        return new LockWatchEventLogImpl(snapshot);\n+    }\n+\n+    private LockWatchEventLogImpl(ClientLockWatchSnapshot snapshot) {\n+        this.snapshot = snapshot;\n+    }\n+\n+    @Override\n+    public CacheStatus processUpdate(LockWatchStateUpdate update) {\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            return update.accept(new NewLeaderVisitor());\n+        } else {\n+            return update.accept(new ProcessingVisitor());\n+        }\n+    }\n+\n+    @Override\n+    public ClientLogEvents getEventsBetweenVersions(\n+            Optional<IdentifiedVersion> lastKnownVersion,\n+            IdentifiedVersion endVersion) {\n+        Optional<IdentifiedVersion> startVersion = lastKnownVersion.map(this::createStartVersion);\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(endVersion);\n+        ClientLogEvents.Builder eventBuilder = new ClientLogEvents.Builder();\n+        final long fromSequence;\n+\n+        if (!startVersion.isPresent() || differentLeaderOrTooFarBehind(currentVersion, startVersion.get())) {\n+            eventBuilder.addEvents(LockWatchCreatedEvent.fromSnapshot(snapshot.getSnapshot()));\n+            eventBuilder.clearCache(true);\n+            if (eventStore.isEmpty()) {\n+                return eventBuilder.build();\n+            }\n+            fromSequence = eventStore.getFirstKey();\n+        } else {\n+            eventBuilder.clearCache(false);\n+            fromSequence = startVersion.get().version();\n+        }\n+\n+        eventBuilder.addAllEvents(eventStore.getEventsBetweenVersionsInclusive(fromSequence, endVersion.version()));\n+        return eventBuilder.build();\n+    }\n+\n+    @Override\n+    public void removeEventsBefore(long earliestSequence) {\n+        Set<Map.Entry<Long, LockWatchEvent>> eventsToBeRemoved = eventStore.getElementsUpToExclusive(earliestSequence);", "originalCommit": "a311fcd0f3b3833f664d435b534eb38ad556deae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY0Nzg4MQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441647881", "bodyText": "Impl is a bit cleaner now, although the need to still compute latestDeletedVersion is a little meh.", "author": "Jolyon-S", "createdAt": "2020-06-17T15:47:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxMjk2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2MDczMA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441660730", "bodyText": "also just saw later comment.", "author": "Jolyon-S", "createdAt": "2020-06-17T16:07:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxMjk2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxMzg5MQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441513891", "bodyText": "I feel like you could clean this up if this was Optional and then VersionedEventStore#getEventsBetweenVersionsInclusive takes an Optional. And you would get rid of VersionedStore#getFirstKey", "author": "jkozlowski", "createdAt": "2020-06-17T12:41:36Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.lock.watch.CacheStatus;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class LockWatchEventLogImpl implements LockWatchEventLog {\n+    private final ClientLockWatchSnapshot snapshot;\n+    private final VersionedEventStore eventStore = new VersionedEventStore();\n+\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    static LockWatchEventLog create() {\n+        return create(ClientLockWatchSnapshotImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventLog create(ClientLockWatchSnapshot snapshot) {\n+        return new LockWatchEventLogImpl(snapshot);\n+    }\n+\n+    private LockWatchEventLogImpl(ClientLockWatchSnapshot snapshot) {\n+        this.snapshot = snapshot;\n+    }\n+\n+    @Override\n+    public CacheStatus processUpdate(LockWatchStateUpdate update) {\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            return update.accept(new NewLeaderVisitor());\n+        } else {\n+            return update.accept(new ProcessingVisitor());\n+        }\n+    }\n+\n+    @Override\n+    public ClientLogEvents getEventsBetweenVersions(\n+            Optional<IdentifiedVersion> lastKnownVersion,\n+            IdentifiedVersion endVersion) {\n+        Optional<IdentifiedVersion> startVersion = lastKnownVersion.map(this::createStartVersion);\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(endVersion);\n+        ClientLogEvents.Builder eventBuilder = new ClientLogEvents.Builder();\n+        final long fromSequence;", "originalCommit": "a311fcd0f3b3833f664d435b534eb38ad556deae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzNDA1Mg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441634052", "bodyText": "Even better: I would just have an if statement that run the whole codepath, it is clearly a different codepath depending on whether you have a snapshot or not. The way you have it you're saving 1 line of duplication (to do the getEventsBetweenVersionsInclusive in one place), but in order to do that you are making the code non-linear and creating a builder half way through. My opinion is that this would be easier to read if you just had:\nif (rebuildFromSnapshot()) {\n  return new ClientLogEvents.Builder()\n    .clearCache(true)\n    .addEvents(LockWatchCreatedEvent.fromSnapshot(snapshot.getSnapshot()))\n    .addAllEvents(eventStore.getEventsBetweenVersionsInclusive(Optional.empty(), endVersion.version()))\n}\n\nreturn new ClientLogEvents.Builder()\n    .clearCache(false)\n    .addAllEvents(eventStore.getEventsBetweenVersionsInclusive(Optional.of(theVersion), endVersion.version()));", "author": "jkozlowski", "createdAt": "2020-06-17T15:26:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxMzg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1NjQzOQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441656439", "bodyText": "Done, although I feel like there is maybe a nicer optional functional method to use in my impl to make it nicer.", "author": "Jolyon-S", "createdAt": "2020-06-17T16:00:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxMzg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2MDU5NA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441660594", "bodyText": "ah, didn't see later comment.", "author": "Jolyon-S", "createdAt": "2020-06-17T16:07:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxMzg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2MjE0Nw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441662147", "bodyText": "Actually that does work out pretty nicely.", "author": "Jolyon-S", "createdAt": "2020-06-17T16:09:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxMzg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNDU2MA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441514560", "bodyText": "Why do you sometimes copy and sometimes not? I feel like you should stick to one, and maybe consider Collections.unmodifiable* wrappers.", "author": "jkozlowski", "createdAt": "2020-06-17T12:42:45Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/VersionedEventStore.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class VersionedEventStore {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    boolean isEmpty() {\n+        return eventMap.isEmpty();\n+    }\n+\n+    long getFirstKey() {\n+        Preconditions.checkState(!eventMap.isEmpty(), \"Cannot get first key from empty map\");\n+        return eventMap.firstKey();\n+    }\n+\n+    long getLastKey() {\n+        Preconditions.checkState(!eventMap.isEmpty(), \"Cannot get last key from empty map\");\n+        return eventMap.lastKey();\n+    }\n+\n+    Collection<LockWatchEvent> getEventsBetweenVersionsInclusive(long startVersion, long endVersion) {\n+        return eventMap.subMap(startVersion, INCLUSIVE, endVersion, INCLUSIVE).values();\n+    }\n+\n+    Set<Map.Entry<Long, LockWatchEvent>> getElementsUpToExclusive(long endVersion) {\n+        return ImmutableSet.copyOf(eventMap.headMap(endVersion).entrySet());", "originalCommit": "a311fcd0f3b3833f664d435b534eb38ad556deae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1OTE1NQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441659155", "bodyText": "As I understand it, that wrapper returns a view, so if I modify the underlying structure, that will possibly be reflected in the returned one. So this is not a problem in some of the internal cases as it is synchronised, but we want to be careful when returning to the user that it is decoupled from the underlying implementation.\nIn this particular case (after latest refactor), we need to do a copy as we immediately delete the elements in the underlying structure before processing them in the snapshot updater.", "author": "Jolyon-S", "createdAt": "2020-06-17T16:04:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNDU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNTQxMQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441515411", "bodyText": "In general I like this more, because reading floorKey etc. is not great in the other class. But you should just make sure you have API on this class that is not just a wrapping of NavigableMap without any renames that make sense. I suggested a few strategies above.", "author": "jkozlowski", "createdAt": "2020-06-17T12:44:08Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/VersionedEventStore.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class VersionedEventStore {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    boolean isEmpty() {", "originalCommit": "a311fcd0f3b3833f664d435b534eb38ad556deae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNjc2OA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441516768", "bodyText": "nit: contiguous", "author": "jkozlowski", "createdAt": "2020-06-17T12:46:20Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/ClientLockWatchSnapshotImpl.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class ClientLockWatchSnapshotImpl implements ClientLockWatchSnapshot {\n+    private final Set<LockWatchReferences.LockWatchReference> watches;\n+    private final Set<LockDescriptor> locked;\n+    private final EventVisitor visitor;\n+    private Optional<IdentifiedVersion> snapshotVersion;\n+\n+    static ClientLockWatchSnapshot create() {\n+        return new ClientLockWatchSnapshotImpl();\n+    }\n+\n+    private ClientLockWatchSnapshotImpl() {\n+        this.watches = new HashSet<>();\n+        this.locked = new HashSet<>();\n+        this.visitor = new EventVisitor();\n+        this.snapshotVersion = Optional.empty();\n+    }\n+\n+    @Override\n+    public LockWatchStateUpdate.Snapshot getSnapshot() {\n+        Preconditions.checkState(snapshotVersion.isPresent(),\n+                \"Snapshot was reset on fail and has not been seeded since\");\n+        return LockWatchStateUpdate.snapshot(\n+                snapshotVersion.get().id(),\n+                snapshotVersion.get().version(),\n+                ImmutableSet.copyOf(locked),\n+                ImmutableSet.copyOf(watches));\n+    }\n+\n+    @Override\n+    public void processEvents(List<LockWatchEvent> events, IdentifiedVersion lastVersion) {\n+        assertEventsAreContinguous(events);\n+        events.forEach(event -> event.accept(visitor));\n+        snapshotVersion = Optional.of(lastVersion);\n+    }\n+\n+    @Override\n+    public void resetWithSnapshot(LockWatchStateUpdate.Snapshot snapshot) {\n+        reset();\n+        watches.addAll(snapshot.lockWatches());\n+        locked.addAll(snapshot.locked());\n+        snapshotVersion = Optional.of(IdentifiedVersion.of(snapshot.logId(), snapshot.lastKnownVersion()));\n+    }\n+\n+    @Override\n+    public void reset() {\n+        snapshotVersion = Optional.empty();\n+        watches.clear();\n+        locked.clear();\n+    }\n+\n+    private void assertEventsAreContinguous(List<LockWatchEvent> events) {", "originalCommit": "a311fcd0f3b3833f664d435b534eb38ad556deae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1OTMyOA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441659328", "bodyText": "Good catch.", "author": "Jolyon-S", "createdAt": "2020-06-17T16:05:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNjc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUyMDI2NQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441520265", "bodyText": "I have a feeling that this would be much nicer if:\n\nOnce you have my other suggestions about the code in LockWatchEventLogImpl#removeEvents\nclearElementsUpToExclusive actually returns a LockWatchEvents little type.\nprocessEvents in this class accepts that, and only that. It then computes the latest version by getting the last event itself. Basically it feels weird to pass it something that it then needs to trust was computed correctly.\n\nAnd then LockWatchEvents is a small wrapper around a list of events that validates continuity. And then", "author": "jkozlowski", "createdAt": "2020-06-17T12:52:09Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/ClientLockWatchSnapshotImpl.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class ClientLockWatchSnapshotImpl implements ClientLockWatchSnapshot {\n+    private final Set<LockWatchReferences.LockWatchReference> watches;\n+    private final Set<LockDescriptor> locked;\n+    private final EventVisitor visitor;\n+    private Optional<IdentifiedVersion> snapshotVersion;\n+\n+    static ClientLockWatchSnapshot create() {\n+        return new ClientLockWatchSnapshotImpl();\n+    }\n+\n+    private ClientLockWatchSnapshotImpl() {\n+        this.watches = new HashSet<>();\n+        this.locked = new HashSet<>();\n+        this.visitor = new EventVisitor();\n+        this.snapshotVersion = Optional.empty();\n+    }\n+\n+    @Override\n+    public LockWatchStateUpdate.Snapshot getSnapshot() {\n+        Preconditions.checkState(snapshotVersion.isPresent(),\n+                \"Snapshot was reset on fail and has not been seeded since\");\n+        return LockWatchStateUpdate.snapshot(\n+                snapshotVersion.get().id(),\n+                snapshotVersion.get().version(),\n+                ImmutableSet.copyOf(locked),\n+                ImmutableSet.copyOf(watches));\n+    }\n+\n+    @Override\n+    public void processEvents(List<LockWatchEvent> events, IdentifiedVersion lastVersion) {\n+        assertEventsAreContinguous(events);\n+        events.forEach(event -> event.accept(visitor));\n+        snapshotVersion = Optional.of(lastVersion);\n+    }\n+\n+    @Override\n+    public void resetWithSnapshot(LockWatchStateUpdate.Snapshot snapshot) {\n+        reset();\n+        watches.addAll(snapshot.lockWatches());\n+        locked.addAll(snapshot.locked());\n+        snapshotVersion = Optional.of(IdentifiedVersion.of(snapshot.logId(), snapshot.lastKnownVersion()));\n+    }\n+\n+    @Override\n+    public void reset() {\n+        snapshotVersion = Optional.empty();\n+        watches.clear();\n+        locked.clear();\n+    }\n+\n+    private void assertEventsAreContinguous(List<LockWatchEvent> events) {", "originalCommit": "a311fcd0f3b3833f664d435b534eb38ad556deae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3MDc4Ng==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441670786", "bodyText": "Done", "author": "Jolyon-S", "createdAt": "2020-06-17T16:23:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUyMDI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUzMjY1NQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441532655", "bodyText": "I will put one comment for LockWatchEventCacheImplTest and LockWatchEventLogImplTest (and kinda LockWattchEventCacheIntegrationTest):\nI feel that the tests in LockWatchEventCacheImplTest and LockWatchEventLogImplTest, where you mock all the datastructures underneath them, are quite fragile in general. What I kinda had in mind is:\n\nLockWatchEventCacheImpl has a package private method called #getSnapshot which returns a Snapshot of all the internal datastructures (so it contains log of events, all the open transactions and their state, and current snapshot). That thing is Json serializable\nYou only have 1 big integration test, that tests a bunch of scenarios where you poke the LockWatchEventCacheImpl, but after each step take a snapshot and compare it to a golden file (and do as many steps as you want).\nThe review is just a matter of: read a test case in LockWAtchEventCacheImplIntegrationTest, understand what it should do to the internal datastructures, and go diff each step and see that the right thing happened.\n\nThis is a bit of extra code that will only be used for tests, however I would argue that the implementation of this cache is the critical piece to all of lock watches (this and the timelock code).", "author": "jkozlowski", "createdAt": "2020-06-17T13:11:26Z", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheImplTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.atlasdb.transaction.api.TransactionLockWatchFailedException;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CacheStatus;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public final class LockWatchEventCacheImplTest {", "originalCommit": "a311fcd0f3b3833f664d435b534eb38ad556deae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU3MzkwNg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441573906", "bodyText": "I think this does describe a useful test, although it does depend on the creation of the \"golden file\" being correct: given that this is the first implementation, I feel like it is hard to convince oneself that \"this golden file is actually 100% super correct\", other than by manual review. Still, I absolutely agree about the tests being pretty fragile, and I think this could be pretty good. I'll experiment and see what it looks like.", "author": "Jolyon-S", "createdAt": "2020-06-17T14:08:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUzMjY1NQ=="}], "type": "inlineReview"}, {"oid": "00949554e8a2361341bce9ca7d304c9c8b13c789", "url": "https://github.com/palantir/atlasdb/commit/00949554e8a2361341bce9ca7d304c9c8b13c789", "message": "clean up a load of things; tests are probably broken", "committedDate": "2020-06-17T16:24:07Z", "type": "commit"}, {"oid": "0a07e577be9585f14adc62f8e85b5b12c6c22640", "url": "https://github.com/palantir/atlasdb/commit/0a07e577be9585f14adc62f8e85b5b12c6c22640", "message": "bleh", "committedDate": "2020-06-19T13:56:56Z", "type": "commit"}, {"oid": "923b285787e12b3035bf529b86154cc3c8f047ff", "url": "https://github.com/palantir/atlasdb/commit/923b285787e12b3035bf529b86154cc3c8f047ff", "message": "json test approach", "committedDate": "2020-06-22T09:44:26Z", "type": "commit"}, {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557", "url": "https://github.com/palantir/atlasdb/commit/752379c0f334106ef69ab5dc8ae04ff2af0e2557", "message": "remove old tests", "committedDate": "2020-06-22T09:47:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ3MzY2Nw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443473667", "bodyText": "I think we discussed that ideally we won't have these directly on this class. Either have a small Snapshot class defined or remove these and it will likely still work (cause Jackson is magic).", "author": "jkozlowski", "createdAt": "2020-06-22T10:48:14Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.atlasdb.keyvalue.api.watch.TimestampStateStore.CommitInfo;\n+import com.palantir.atlasdb.transaction.api.TransactionLockWatchFailedException;\n+import com.palantir.atlasdb.util.MetricsManager;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CacheStatus;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableInvalidateAll;\n+import com.palantir.lock.watch.ImmutableInvalidateSome;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.NoOpLockWatchEventCache;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This class should only be used through {@link ResilientLockWatchEventCache} as a proxy; failure to do so will result\n+ * in concurrency issues and inconsistency in the cache state.\n+ */\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    @JsonProperty", "originalCommit": "752379c0f334106ef69ab5dc8ae04ff2af0e2557", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxNzMwNw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443517307", "bodyText": "I don't think removing worked, but gone for a few state classes instead.", "author": "Jolyon-S", "createdAt": "2020-06-22T12:19:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ3MzY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4MTMyNQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443481325", "bodyText": "All the tests start in exactly the same way, can you refactor this somehow?", "author": "jkozlowski", "createdAt": "2020-06-22T11:03:40Z", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);", "originalCommit": "752379c0f334106ef69ab5dc8ae04ff2af0e2557", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5NDAzNw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443494037", "bodyText": "So in JSON I believe these will be serialized as base64 or base32; can you make this visible in these constant for ease of reference? So like create the byte[] from base64/32 string.", "author": "jkozlowski", "createdAt": "2020-06-22T11:31:07Z", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});", "originalCommit": "752379c0f334106ef69ab5dc8ae04ff2af0e2557", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxOTk5Mw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443519993", "bodyText": "cannot instantiate lock descriptors directly here as the constructor that takes bytes is package-private; I can add a comment for each descriptor though - I think that is probably the closest thing we can get here.", "author": "Jolyon-S", "createdAt": "2020-06-22T12:24:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5NDAzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5OTczMQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443499731", "bodyText": "Reviewed, diff make sense.", "author": "jkozlowski", "createdAt": "2020-06-22T11:43:48Z", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        verifyStage();\n+\n+        Set<Long> secondTimestamps = ImmutableSet.of(5L, 123L);", "originalCommit": "752379c0f334106ef69ab5dc8ae04ff2af0e2557", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUwMDkzOA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443500938", "bodyText": "Reviewed, diff makes sense.", "author": "jkozlowski", "createdAt": "2020-06-22T11:46:11Z", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        verifyStage();\n+\n+        Set<Long> secondTimestamps = ImmutableSet.of(5L, 123L);\n+        eventCache.processStartTransactionsUpdate(secondTimestamps, SUCCESS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getCommitUpdateDoesNotContainCommitLocks() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        verifyStage();\n+\n+        CommitUpdate commitUpdate = eventCache.getCommitUpdate(1L);", "originalCommit": "752379c0f334106ef69ab5dc8ae04ff2af0e2557", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxMTM4Nw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443511387", "bodyText": "Reviewed makes sense.", "author": "jkozlowski", "createdAt": "2020-06-22T12:07:39Z", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        verifyStage();\n+\n+        Set<Long> secondTimestamps = ImmutableSet.of(5L, 123L);\n+        eventCache.processStartTransactionsUpdate(secondTimestamps, SUCCESS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getCommitUpdateDoesNotContainCommitLocks() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        verifyStage();\n+\n+        CommitUpdate commitUpdate = eventCache.getCommitUpdate(1L);\n+        assertThat(commitUpdate.accept(new CommitUpdateVisitor()))\n+                .containsExactlyInAnyOrder(DESCRIPTOR);\n+    }\n+\n+    @Test\n+    public void cacheClearedOnSnapshotUpdate() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);", "originalCommit": "752379c0f334106ef69ab5dc8ae04ff2af0e2557", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxNzA5NA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443517094", "bodyText": "Actually shouldn't this throw? You have received a success update from timelock by you don't know what the snapshot is.", "author": "jkozlowski", "createdAt": "2020-06-22T12:18:58Z", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        verifyStage();\n+\n+        Set<Long> secondTimestamps = ImmutableSet.of(5L, 123L);\n+        eventCache.processStartTransactionsUpdate(secondTimestamps, SUCCESS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getCommitUpdateDoesNotContainCommitLocks() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        verifyStage();\n+\n+        CommitUpdate commitUpdate = eventCache.getCommitUpdate(1L);\n+        assertThat(commitUpdate.accept(new CommitUpdateVisitor()))\n+                .containsExactlyInAnyOrder(DESCRIPTOR);\n+    }\n+\n+    @Test\n+    public void cacheClearedOnSnapshotUpdate() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, SUCCESS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate snapshot2 = LockWatchStateUpdate.snapshot(LEADER, 7L, ImmutableSet.of(DESCRIPTOR),\n+                ImmutableSet.of());\n+        Set<Long> timestamps3 = ImmutableSet.of(123L, 1255L);\n+        eventCache.processStartTransactionsUpdate(timestamps3, snapshot2);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getEventsForTransactionsReturnsSnapshotWithOldEvents() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate success2 = LockWatchStateUpdate.success(LEADER, 10L, ImmutableList.of(LOCK_EVENT_2));\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, success2);\n+        verifyStage();\n+\n+        TransactionsLockWatchUpdate results = eventCache.getUpdateForTransactions(TIMESTAMPS_2, Optional.empty());\n+        assertThat(results.clearCache()).isTrue();\n+        assertThat(results.startTsToSequence()).containsExactlyInAnyOrderEntriesOf(\n+                ImmutableMap.of(16L, IdentifiedVersion.of(LEADER, 10L)));\n+        assertThat(results.events()).containsExactly(\n+                LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE),\n+                        ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_3)).build(6L),\n+                LOCK_EVENT_2);\n+    }\n+\n+    @Test\n+    public void failedUpdateClearsAllCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, LockWatchStateUpdate.failed(LEADER));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void leaderChangeClearsCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,", "originalCommit": "752379c0f334106ef69ab5dc8ae04ff2af0e2557", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxNzk3OA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443517978", "bodyText": "Ah, I see you handle this. I would just say that this is probably an unexpected state to be in, but maybe possible if leaders switch quickly somehow, and given concurrency between startTransaction and commitTimestamp calls.", "author": "jkozlowski", "createdAt": "2020-06-22T12:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxNzA5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUyNjMwNg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443526306", "bodyText": "yeah - you can imagine a case where the success update comes before the snapshot somehow, so in that case we just clear the cache outright, and wait for the snapshot update.", "author": "Jolyon-S", "createdAt": "2020-06-22T12:36:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxNzA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxOTQ1NA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443519454", "bodyText": "Reviewed", "author": "jkozlowski", "createdAt": "2020-06-22T12:23:11Z", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        verifyStage();\n+\n+        Set<Long> secondTimestamps = ImmutableSet.of(5L, 123L);\n+        eventCache.processStartTransactionsUpdate(secondTimestamps, SUCCESS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getCommitUpdateDoesNotContainCommitLocks() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        verifyStage();\n+\n+        CommitUpdate commitUpdate = eventCache.getCommitUpdate(1L);\n+        assertThat(commitUpdate.accept(new CommitUpdateVisitor()))\n+                .containsExactlyInAnyOrder(DESCRIPTOR);\n+    }\n+\n+    @Test\n+    public void cacheClearedOnSnapshotUpdate() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, SUCCESS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate snapshot2 = LockWatchStateUpdate.snapshot(LEADER, 7L, ImmutableSet.of(DESCRIPTOR),\n+                ImmutableSet.of());\n+        Set<Long> timestamps3 = ImmutableSet.of(123L, 1255L);\n+        eventCache.processStartTransactionsUpdate(timestamps3, snapshot2);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getEventsForTransactionsReturnsSnapshotWithOldEvents() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate success2 = LockWatchStateUpdate.success(LEADER, 10L, ImmutableList.of(LOCK_EVENT_2));\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, success2);\n+        verifyStage();\n+\n+        TransactionsLockWatchUpdate results = eventCache.getUpdateForTransactions(TIMESTAMPS_2, Optional.empty());\n+        assertThat(results.clearCache()).isTrue();\n+        assertThat(results.startTsToSequence()).containsExactlyInAnyOrderEntriesOf(\n+                ImmutableMap.of(16L, IdentifiedVersion.of(LEADER, 10L)));\n+        assertThat(results.events()).containsExactly(\n+                LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE),\n+                        ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_3)).build(6L),\n+                LOCK_EVENT_2);\n+    }\n+\n+    @Test\n+    public void failedUpdateClearsAllCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, LockWatchStateUpdate.failed(LEADER));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void leaderChangeClearsCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,\n+                LockWatchStateUpdate.success(EVENT2_UUID, 4L, ImmutableList.of()));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void removingEntriesRetentionsEventsInLog() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);", "originalCommit": "752379c0f334106ef69ab5dc8ae04ff2af0e2557", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxOTc4NA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443519784", "bodyText": "Yeah, I think this is what I mean: you should throw immediately when you discover a discontinuity, so probably that validation should be pushed up from snapshot to event cache.", "author": "jkozlowski", "createdAt": "2020-06-22T12:23:52Z", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        verifyStage();\n+\n+        Set<Long> secondTimestamps = ImmutableSet.of(5L, 123L);\n+        eventCache.processStartTransactionsUpdate(secondTimestamps, SUCCESS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getCommitUpdateDoesNotContainCommitLocks() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        verifyStage();\n+\n+        CommitUpdate commitUpdate = eventCache.getCommitUpdate(1L);\n+        assertThat(commitUpdate.accept(new CommitUpdateVisitor()))\n+                .containsExactlyInAnyOrder(DESCRIPTOR);\n+    }\n+\n+    @Test\n+    public void cacheClearedOnSnapshotUpdate() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, SUCCESS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate snapshot2 = LockWatchStateUpdate.snapshot(LEADER, 7L, ImmutableSet.of(DESCRIPTOR),\n+                ImmutableSet.of());\n+        Set<Long> timestamps3 = ImmutableSet.of(123L, 1255L);\n+        eventCache.processStartTransactionsUpdate(timestamps3, snapshot2);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getEventsForTransactionsReturnsSnapshotWithOldEvents() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate success2 = LockWatchStateUpdate.success(LEADER, 10L, ImmutableList.of(LOCK_EVENT_2));\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, success2);\n+        verifyStage();\n+\n+        TransactionsLockWatchUpdate results = eventCache.getUpdateForTransactions(TIMESTAMPS_2, Optional.empty());\n+        assertThat(results.clearCache()).isTrue();\n+        assertThat(results.startTsToSequence()).containsExactlyInAnyOrderEntriesOf(\n+                ImmutableMap.of(16L, IdentifiedVersion.of(LEADER, 10L)));\n+        assertThat(results.events()).containsExactly(\n+                LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE),\n+                        ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_3)).build(6L),\n+                LOCK_EVENT_2);\n+    }\n+\n+    @Test\n+    public void failedUpdateClearsAllCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, LockWatchStateUpdate.failed(LEADER));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void leaderChangeClearsCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,\n+                LockWatchStateUpdate.success(EVENT2_UUID, 4L, ImmutableList.of()));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void removingEntriesRetentionsEventsInLog() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, SUCCESS);\n+        verifyStage();\n+\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void nonContiguousEventsThrows() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,\n+                LockWatchStateUpdate.success(LEADER, 10L, ImmutableList.of(WATCH_EVENT, LOCK_EVENT, LOCK_EVENT_2)));\n+        eventCache.processStartTransactionsUpdate(ImmutableSet.of(23L, 55L),\n+                LockWatchStateUpdate.success(LEADER, 20L,\n+                        ImmutableList.of(UnlockEvent.builder(ImmutableSet.of()).build(20L))));\n+        verifyStage();\n+        assertThatThrownBy(() -> eventCache.removeTransactionStateFromCache(START_TS))\n+                .isExactlyInstanceOf(SafeIllegalArgumentException.class)\n+                .hasMessage(\"Events form a non-contiguous sequence\");", "originalCommit": "752379c0f334106ef69ab5dc8ae04ff2af0e2557", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUyNjYzNA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443526634", "bodyText": "Reasonable - I'll see what that looks like now.", "author": "Jolyon-S", "createdAt": "2020-06-22T12:36:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxOTc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxOTkyNw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443519927", "bodyText": "Same here.", "author": "jkozlowski", "createdAt": "2020-06-22T12:24:09Z", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        verifyStage();\n+\n+        Set<Long> secondTimestamps = ImmutableSet.of(5L, 123L);\n+        eventCache.processStartTransactionsUpdate(secondTimestamps, SUCCESS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getCommitUpdateDoesNotContainCommitLocks() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        verifyStage();\n+\n+        CommitUpdate commitUpdate = eventCache.getCommitUpdate(1L);\n+        assertThat(commitUpdate.accept(new CommitUpdateVisitor()))\n+                .containsExactlyInAnyOrder(DESCRIPTOR);\n+    }\n+\n+    @Test\n+    public void cacheClearedOnSnapshotUpdate() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, SUCCESS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate snapshot2 = LockWatchStateUpdate.snapshot(LEADER, 7L, ImmutableSet.of(DESCRIPTOR),\n+                ImmutableSet.of());\n+        Set<Long> timestamps3 = ImmutableSet.of(123L, 1255L);\n+        eventCache.processStartTransactionsUpdate(timestamps3, snapshot2);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getEventsForTransactionsReturnsSnapshotWithOldEvents() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate success2 = LockWatchStateUpdate.success(LEADER, 10L, ImmutableList.of(LOCK_EVENT_2));\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, success2);\n+        verifyStage();\n+\n+        TransactionsLockWatchUpdate results = eventCache.getUpdateForTransactions(TIMESTAMPS_2, Optional.empty());\n+        assertThat(results.clearCache()).isTrue();\n+        assertThat(results.startTsToSequence()).containsExactlyInAnyOrderEntriesOf(\n+                ImmutableMap.of(16L, IdentifiedVersion.of(LEADER, 10L)));\n+        assertThat(results.events()).containsExactly(\n+                LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE),\n+                        ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_3)).build(6L),\n+                LOCK_EVENT_2);\n+    }\n+\n+    @Test\n+    public void failedUpdateClearsAllCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, LockWatchStateUpdate.failed(LEADER));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void leaderChangeClearsCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,\n+                LockWatchStateUpdate.success(EVENT2_UUID, 4L, ImmutableList.of()));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void removingEntriesRetentionsEventsInLog() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, SUCCESS);\n+        verifyStage();\n+\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void nonContiguousEventsThrows() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,\n+                LockWatchStateUpdate.success(LEADER, 10L, ImmutableList.of(WATCH_EVENT, LOCK_EVENT, LOCK_EVENT_2)));\n+        eventCache.processStartTransactionsUpdate(ImmutableSet.of(23L, 55L),\n+                LockWatchStateUpdate.success(LEADER, 20L,\n+                        ImmutableList.of(UnlockEvent.builder(ImmutableSet.of()).build(20L))));\n+        verifyStage();\n+        assertThatThrownBy(() -> eventCache.removeTransactionStateFromCache(START_TS))\n+                .isExactlyInstanceOf(SafeIllegalArgumentException.class)\n+                .hasMessage(\"Events form a non-contiguous sequence\");\n+    }\n+\n+    @Test\n+    public void snapshotMissedEventThrows() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,\n+                LockWatchStateUpdate.success(LEADER, 5L, ImmutableList.of(UNLOCK_EVENT)));\n+        eventCache.processStartTransactionsUpdate(ImmutableSet.of(23L, 55L),\n+                LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(LOCK_EVENT)));\n+        verifyStage();\n+\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+        assertThatThrownBy(() -> eventCache.removeTransactionStateFromCache(16L))\n+                .isExactlyInstanceOf(SafeIllegalArgumentException.class)\n+                .hasMessage(\"Events missing between last snapshot and this batch of events\");", "originalCommit": "752379c0f334106ef69ab5dc8ae04ff2af0e2557", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUyMTYzOQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443521639", "bodyText": "I think I am missing a test where you have at least 2 successful updates.", "author": "jkozlowski", "createdAt": "2020-06-22T12:27:17Z", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {", "originalCommit": "752379c0f334106ef69ab5dc8ae04ff2af0e2557", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUyMzAzMg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443523032", "bodyText": "Let's add a test where you race some updates, to simulate 2 concurrent calls (startTransactions and commitTimestamps): they will both start with the same version being sent to timelock, and let's say return same events, so second update should be no-op.\nSo basically something like:\neventCache.processStartTranscationUpdate(TIMESTAMPS, UPDATE);\neventCache.processStartTransactionUpdate(TIMESTAMPS2, UPDATE);\n\nEvents are the same, so you should remember the new timestamps, but event store should not change.", "author": "jkozlowski", "createdAt": "2020-06-22T12:29:52Z", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        verifyStage();\n+\n+        Set<Long> secondTimestamps = ImmutableSet.of(5L, 123L);\n+        eventCache.processStartTransactionsUpdate(secondTimestamps, SUCCESS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getCommitUpdateDoesNotContainCommitLocks() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        verifyStage();\n+\n+        CommitUpdate commitUpdate = eventCache.getCommitUpdate(1L);\n+        assertThat(commitUpdate.accept(new CommitUpdateVisitor()))\n+                .containsExactlyInAnyOrder(DESCRIPTOR);\n+    }\n+\n+    @Test\n+    public void cacheClearedOnSnapshotUpdate() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, SUCCESS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate snapshot2 = LockWatchStateUpdate.snapshot(LEADER, 7L, ImmutableSet.of(DESCRIPTOR),\n+                ImmutableSet.of());\n+        Set<Long> timestamps3 = ImmutableSet.of(123L, 1255L);\n+        eventCache.processStartTransactionsUpdate(timestamps3, snapshot2);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getEventsForTransactionsReturnsSnapshotWithOldEvents() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate success2 = LockWatchStateUpdate.success(LEADER, 10L, ImmutableList.of(LOCK_EVENT_2));\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, success2);\n+        verifyStage();\n+\n+        TransactionsLockWatchUpdate results = eventCache.getUpdateForTransactions(TIMESTAMPS_2, Optional.empty());\n+        assertThat(results.clearCache()).isTrue();\n+        assertThat(results.startTsToSequence()).containsExactlyInAnyOrderEntriesOf(\n+                ImmutableMap.of(16L, IdentifiedVersion.of(LEADER, 10L)));\n+        assertThat(results.events()).containsExactly(\n+                LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE),\n+                        ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_3)).build(6L),\n+                LOCK_EVENT_2);\n+    }\n+\n+    @Test\n+    public void failedUpdateClearsAllCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, LockWatchStateUpdate.failed(LEADER));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void leaderChangeClearsCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,\n+                LockWatchStateUpdate.success(EVENT2_UUID, 4L, ImmutableList.of()));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void removingEntriesRetentionsEventsInLog() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, SUCCESS);\n+        verifyStage();\n+\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void nonContiguousEventsThrows() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,\n+                LockWatchStateUpdate.success(LEADER, 10L, ImmutableList.of(WATCH_EVENT, LOCK_EVENT, LOCK_EVENT_2)));\n+        eventCache.processStartTransactionsUpdate(ImmutableSet.of(23L, 55L),\n+                LockWatchStateUpdate.success(LEADER, 20L,\n+                        ImmutableList.of(UnlockEvent.builder(ImmutableSet.of()).build(20L))));\n+        verifyStage();\n+        assertThatThrownBy(() -> eventCache.removeTransactionStateFromCache(START_TS))\n+                .isExactlyInstanceOf(SafeIllegalArgumentException.class)\n+                .hasMessage(\"Events form a non-contiguous sequence\");\n+    }\n+\n+    @Test\n+    public void snapshotMissedEventThrows() {", "originalCommit": "752379c0f334106ef69ab5dc8ae04ff2af0e2557", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUzMjg5OA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443532898", "bodyText": "Done", "author": "Jolyon-S", "createdAt": "2020-06-22T12:47:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUyMzAzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUyNTIxNQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443525215", "bodyText": "Another test to simulate concurrent calls: 2 calls come back but one of them has more events then the other. So again, second call with less events is no-op. So something like:\neventCache.processStartTranscationUpdate(TIMESTAMPS, BIG_UPDATE);\neventCache.processStartTranscationUpdate(TIMESTAMPS2, SMALL_UPDATE)\n\nWhere BIG_UPDATE, say, has events [1,2,3,4,5] and SMALL_UPDATE has [1,2,3]. Again, transactions should be remembered, by nothing in the event log should change.", "author": "jkozlowski", "createdAt": "2020-06-22T12:34:05Z", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        verifyStage();\n+\n+        Set<Long> secondTimestamps = ImmutableSet.of(5L, 123L);\n+        eventCache.processStartTransactionsUpdate(secondTimestamps, SUCCESS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getCommitUpdateDoesNotContainCommitLocks() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        verifyStage();\n+\n+        CommitUpdate commitUpdate = eventCache.getCommitUpdate(1L);\n+        assertThat(commitUpdate.accept(new CommitUpdateVisitor()))\n+                .containsExactlyInAnyOrder(DESCRIPTOR);\n+    }\n+\n+    @Test\n+    public void cacheClearedOnSnapshotUpdate() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, SUCCESS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate snapshot2 = LockWatchStateUpdate.snapshot(LEADER, 7L, ImmutableSet.of(DESCRIPTOR),\n+                ImmutableSet.of());\n+        Set<Long> timestamps3 = ImmutableSet.of(123L, 1255L);\n+        eventCache.processStartTransactionsUpdate(timestamps3, snapshot2);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getEventsForTransactionsReturnsSnapshotWithOldEvents() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate success2 = LockWatchStateUpdate.success(LEADER, 10L, ImmutableList.of(LOCK_EVENT_2));\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, success2);\n+        verifyStage();\n+\n+        TransactionsLockWatchUpdate results = eventCache.getUpdateForTransactions(TIMESTAMPS_2, Optional.empty());\n+        assertThat(results.clearCache()).isTrue();\n+        assertThat(results.startTsToSequence()).containsExactlyInAnyOrderEntriesOf(\n+                ImmutableMap.of(16L, IdentifiedVersion.of(LEADER, 10L)));\n+        assertThat(results.events()).containsExactly(\n+                LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE),\n+                        ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_3)).build(6L),\n+                LOCK_EVENT_2);\n+    }\n+\n+    @Test\n+    public void failedUpdateClearsAllCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, LockWatchStateUpdate.failed(LEADER));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void leaderChangeClearsCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,\n+                LockWatchStateUpdate.success(EVENT2_UUID, 4L, ImmutableList.of()));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void removingEntriesRetentionsEventsInLog() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, SUCCESS);\n+        verifyStage();\n+\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void nonContiguousEventsThrows() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,\n+                LockWatchStateUpdate.success(LEADER, 10L, ImmutableList.of(WATCH_EVENT, LOCK_EVENT, LOCK_EVENT_2)));\n+        eventCache.processStartTransactionsUpdate(ImmutableSet.of(23L, 55L),\n+                LockWatchStateUpdate.success(LEADER, 20L,\n+                        ImmutableList.of(UnlockEvent.builder(ImmutableSet.of()).build(20L))));\n+        verifyStage();\n+        assertThatThrownBy(() -> eventCache.removeTransactionStateFromCache(START_TS))\n+                .isExactlyInstanceOf(SafeIllegalArgumentException.class)\n+                .hasMessage(\"Events form a non-contiguous sequence\");\n+    }\n+\n+    @Test\n+    public void snapshotMissedEventThrows() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);", "originalCommit": "752379c0f334106ef69ab5dc8ae04ff2af0e2557", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "884a89a9e787d13d43e71c84d66cabf519f695ed", "url": "https://github.com/palantir/atlasdb/commit/884a89a9e787d13d43e71c84d66cabf519f695ed", "message": "rewrite json testing stuff", "committedDate": "2020-06-22T12:54:07Z", "type": "commit"}, {"oid": "4421c87b1a56ea74fb8c77b57ba581d134a41f3f", "url": "https://github.com/palantir/atlasdb/commit/4421c87b1a56ea74fb8c77b57ba581d134a41f3f", "message": "remove unused block", "committedDate": "2020-06-22T12:57:32Z", "type": "commit"}, {"oid": "6fa9cefff070a08af4a69b65dc57dadd4df1351f", "url": "https://github.com/palantir/atlasdb/commit/6fa9cefff070a08af4a69b65dc57dadd4df1351f", "message": "remove unused property flag", "committedDate": "2020-06-22T12:59:31Z", "type": "commit"}, {"oid": "a16aeaab4638238cc0d4415235c11db3d57005a2", "url": "https://github.com/palantir/atlasdb/commit/a16aeaab4638238cc0d4415235c11db3d57005a2", "message": "remove unused json", "committedDate": "2020-06-22T13:12:16Z", "type": "commit"}, {"oid": "f18748986c0709df9422558798214a38502733c2", "url": "https://github.com/palantir/atlasdb/commit/f18748986c0709df9422558798214a38502733c2", "message": "fix bug", "committedDate": "2020-06-22T13:25:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzU1NjEzOQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443556139", "bodyText": "Wonky diff!", "author": "Jolyon-S", "createdAt": "2020-06-22T13:26:34Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/CacheUpdate.java", "diffHunk": "@@ -14,19 +14,28 @@\n  * limitations under the License.\n  */\n \n-package com.palantir.lock.watch;\n+package com.palantir.atlasdb.keyvalue.api.watch;\n \n-import java.util.Collection;\n import java.util.Optional;\n-import java.util.Set;\n-\n-public interface LockWatchEventCache {\n-    Optional<IdentifiedVersion> lastKnownVersion();\n-    void processStartTransactionsUpdate(Set<Long> startTimestamps, LockWatchStateUpdate update);\n-    void processGetCommitTimestampsUpdate(Collection<TransactionUpdate> transactionUpdates,\n-            LockWatchStateUpdate update);\n-    CommitUpdate getCommitUpdate(long startTs);\n-    TransactionsLockWatchUpdate getUpdateForTransactions(Set<Long> startTimestamps,\n-            Optional<IdentifiedVersion> version);\n-    void removeTransactionStateFromCache(long startTimestamp);\n+\n+import com.palantir.lock.watch.IdentifiedVersion;\n+\n+final class CacheUpdate {", "originalCommit": "f18748986c0709df9422558798214a38502733c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "24845fb6e22ae2aa554ef931646475dc93887750", "url": "https://github.com/palantir/atlasdb/commit/24845fb6e22ae2aa554ef931646475dc93887750", "message": "fix tests", "committedDate": "2020-06-22T13:57:03Z", "type": "commit"}, {"oid": "1a26d91744ba520707f614fc955c0fd3aef3690a", "url": "https://github.com/palantir/atlasdb/commit/1a26d91744ba520707f614fc955c0fd3aef3690a", "message": "remove unused import", "committedDate": "2020-06-22T14:09:09Z", "type": "commit"}, {"oid": "3792064e3489c5099deb8905bb44426c3ec6ee56", "url": "https://github.com/palantir/atlasdb/commit/3792064e3489c5099deb8905bb44426c3ec6ee56", "message": "some move over", "committedDate": "2020-05-19T14:46:33Z", "type": "commit"}, {"oid": "66faf28be1904c08caa9299f48128a585bdf58c5", "url": "https://github.com/palantir/atlasdb/commit/66faf28be1904c08caa9299f48128a585bdf58c5", "message": "more progress", "committedDate": "2020-05-22T12:53:04Z", "type": "commit"}, {"oid": "51bec1cc362f2f668841f824e712ac08306820d3", "url": "https://github.com/palantir/atlasdb/commit/51bec1cc362f2f668841f824e712ac08306820d3", "message": "tidy up", "committedDate": "2020-05-26T09:01:34Z", "type": "commit"}, {"oid": "03e002c5cb07c956f89c74731e1c3862b3db89fa", "url": "https://github.com/palantir/atlasdb/commit/03e002c5cb07c956f89c74731e1c3862b3db89fa", "message": "Merge branch 'develop' into lw-client-lwec\n\n# Conflicts:\n#\tlock-api-objects/src/main/java/com/palantir/lock/watch/IdentifiedVersion.java\n#\tlock-api-objects/src/main/java/com/palantir/lock/watch/LockWatchEventCache.java\n#\tlock-api-objects/src/main/java/com/palantir/lock/watch/NoOpLockWatchEventCache.java", "committedDate": "2020-05-26T09:03:45Z", "type": "commit"}, {"oid": "567f68b7f0d9b8bf14ab2a859e99625269eeebec", "url": "https://github.com/palantir/atlasdb/commit/567f68b7f0d9b8bf14ab2a859e99625269eeebec", "message": "merge in develop", "committedDate": "2020-05-26T09:22:33Z", "type": "commit"}, {"oid": "8d7484a38c3e5d22856712240a3aa947deb4c305", "url": "https://github.com/palantir/atlasdb/commit/8d7484a38c3e5d22856712240a3aa947deb4c305", "message": "fix javadoc", "committedDate": "2020-05-26T09:28:06Z", "type": "commit"}, {"oid": "47925adc5f220db94b38a18145c13d50b6dccbb6", "url": "https://github.com/palantir/atlasdb/commit/47925adc5f220db94b38a18145c13d50b6dccbb6", "message": "fix invalidate call", "committedDate": "2020-05-26T09:58:01Z", "type": "commit"}, {"oid": "f6f27bf544a44492863e3a7b38e4fa7e0c933547", "url": "https://github.com/palantir/atlasdb/commit/f6f27bf544a44492863e3a7b38e4fa7e0c933547", "message": "remove extraneous also", "committedDate": "2020-05-26T09:58:23Z", "type": "commit"}, {"oid": "c55c561569c3075c2536b1f59cc53118181bcb45", "url": "https://github.com/palantir/atlasdb/commit/c55c561569c3075c2536b1f59cc53118181bcb45", "message": "Split line", "committedDate": "2020-05-26T10:27:33Z", "type": "commit"}, {"oid": "5937a2ad7c14e565b5885d14331b8ebab52621fe", "url": "https://github.com/palantir/atlasdb/commit/5937a2ad7c14e565b5885d14331b8ebab52621fe", "message": "tidy javadoc", "committedDate": "2020-05-26T10:29:22Z", "type": "commit"}, {"oid": "9d5fe6f4d202a4a5f805b2691eb3d806d0891956", "url": "https://github.com/palantir/atlasdb/commit/9d5fe6f4d202a4a5f805b2691eb3d806d0891956", "message": "reworked to be smoother", "committedDate": "2020-05-26T12:51:04Z", "type": "commit"}, {"oid": "7f891fab695f028440d5553506cba4d0cbd89b66", "url": "https://github.com/palantir/atlasdb/commit/7f891fab695f028440d5553506cba4d0cbd89b66", "message": "process events", "committedDate": "2020-05-26T12:59:59Z", "type": "commit"}, {"oid": "2632cfbd358e8340b73471cf3eb0702cdc94abdc", "url": "https://github.com/palantir/atlasdb/commit/2632cfbd358e8340b73471cf3eb0702cdc94abdc", "message": "implement snapshot thing", "committedDate": "2020-05-26T13:17:22Z", "type": "commit"}, {"oid": "2db213804283140b24b243b40a0074bbc2c36c42", "url": "https://github.com/palantir/atlasdb/commit/2db213804283140b24b243b40a0074bbc2c36c42", "message": "Merge branch 'lw-client-lwel-6' into lw-client-updater", "committedDate": "2020-05-26T13:17:27Z", "type": "commit"}, {"oid": "1491da9efe764685acf51d9f9a349ff0ce282ace", "url": "https://github.com/palantir/atlasdb/commit/1491da9efe764685acf51d9f9a349ff0ce282ace", "message": "clean some things", "committedDate": "2020-05-26T13:23:37Z", "type": "commit"}, {"oid": "087ef9a0c3434e7c884a0f70032a4aff49200a38", "url": "https://github.com/palantir/atlasdb/commit/087ef9a0c3434e7c884a0f70032a4aff49200a38", "message": "take updates from lw-client-updater", "committedDate": "2020-05-26T13:24:27Z", "type": "commit"}, {"oid": "783993e7963e1ae7a541824ba146c54ff259305a", "url": "https://github.com/palantir/atlasdb/commit/783993e7963e1ae7a541824ba146c54ff259305a", "message": "merge in interface change", "committedDate": "2020-05-26T13:25:22Z", "type": "commit"}, {"oid": "d4e012c815b186c4244cf5dc2b1591eb3145011c", "url": "https://github.com/palantir/atlasdb/commit/d4e012c815b186c4244cf5dc2b1591eb3145011c", "message": "move to different place and begin writing tests", "committedDate": "2020-05-26T13:52:53Z", "type": "commit"}, {"oid": "88375c23784dd9339c25a110994939db62aaf18c", "url": "https://github.com/palantir/atlasdb/commit/88375c23784dd9339c25a110994939db62aaf18c", "message": "rework a little", "committedDate": "2020-05-26T14:55:25Z", "type": "commit"}, {"oid": "03f23a5e1cb63023c73f04e7006b194cbf945b99", "url": "https://github.com/palantir/atlasdb/commit/03f23a5e1cb63023c73f04e7006b194cbf945b99", "message": "remove extraneous if statement", "committedDate": "2020-05-26T14:56:46Z", "type": "commit"}, {"oid": "b2d6ba262e5fea00c5639eff58f926e9030d60db", "url": "https://github.com/palantir/atlasdb/commit/b2d6ba262e5fea00c5639eff58f926e9030d60db", "message": "begin cleaning up tests", "committedDate": "2020-05-26T15:04:41Z", "type": "commit"}, {"oid": "8a10d3c6de85b8dcf6932ca943cada8a4b18e927", "url": "https://github.com/palantir/atlasdb/commit/8a10d3c6de85b8dcf6932ca943cada8a4b18e927", "message": "fix failing test", "committedDate": "2020-05-26T15:19:48Z", "type": "commit"}, {"oid": "7c47e620e892790bc7f2a8f5a46fbd3ffdafd5d2", "url": "https://github.com/palantir/atlasdb/commit/7c47e620e892790bc7f2a8f5a46fbd3ffdafd5d2", "message": "change to use queue for better concurrency", "committedDate": "2020-05-27T08:28:10Z", "type": "commit"}, {"oid": "a346359dc71cc7d54649dd2024afbe717e3d7d4b", "url": "https://github.com/palantir/atlasdb/commit/a346359dc71cc7d54649dd2024afbe717e3d7d4b", "message": "fix up tests further", "committedDate": "2020-05-27T08:52:58Z", "type": "commit"}, {"oid": "aa21cfa20248b2b92d0dcbf573fb317d456b7ccf", "url": "https://github.com/palantir/atlasdb/commit/aa21cfa20248b2b92d0dcbf573fb317d456b7ccf", "message": "further tidy", "committedDate": "2020-05-27T09:03:08Z", "type": "commit"}, {"oid": "18e55d4e6bb0a139ee5880bf8f3600e6ca5fc5e8", "url": "https://github.com/palantir/atlasdb/commit/18e55d4e6bb0a139ee5880bf8f3600e6ca5fc5e8", "message": "merge in lwec changes", "committedDate": "2020-05-27T09:04:03Z", "type": "commit"}, {"oid": "bbdc66cc44624081d9e7cafa9c89fa083ef0ff49", "url": "https://github.com/palantir/atlasdb/commit/bbdc66cc44624081d9e7cafa9c89fa083ef0ff49", "message": "move events change to lwec", "committedDate": "2020-05-27T09:05:34Z", "type": "commit"}, {"oid": "fb814703df2a9eff0ddceb132f5bb80cd6264358", "url": "https://github.com/palantir/atlasdb/commit/fb814703df2a9eff0ddceb132f5bb80cd6264358", "message": "Merge branch 'lw-client-lwec' into lw-client-lwel-6", "committedDate": "2020-05-27T09:05:48Z", "type": "commit"}, {"oid": "b0aafe4832366277001208f765d808f73be1b499", "url": "https://github.com/palantir/atlasdb/commit/b0aafe4832366277001208f765d808f73be1b499", "message": "further tidy up and move to proper place", "committedDate": "2020-05-27T09:30:39Z", "type": "commit"}, {"oid": "9799c448b2bce358e7b013337bba832bb4c61934", "url": "https://github.com/palantir/atlasdb/commit/9799c448b2bce358e7b013337bba832bb4c61934", "message": "merge in earlier in chain entries", "committedDate": "2020-05-27T09:31:35Z", "type": "commit"}, {"oid": "9f590f46ca3fc3354b8beff5e15d9d72c860855b", "url": "https://github.com/palantir/atlasdb/commit/9f590f46ca3fc3354b8beff5e15d9d72c860855b", "message": "update snapshotter", "committedDate": "2020-05-27T09:36:33Z", "type": "commit"}, {"oid": "439db7c896759e96e5158068a9ac731257976662", "url": "https://github.com/palantir/atlasdb/commit/439db7c896759e96e5158068a9ac731257976662", "message": "merge from above", "committedDate": "2020-05-27T09:37:17Z", "type": "commit"}, {"oid": "e87b893d6855c81056f2f3c65953248bbeb63917", "url": "https://github.com/palantir/atlasdb/commit/e87b893d6855c81056f2f3c65953248bbeb63917", "message": "begin writing tests", "committedDate": "2020-05-27T10:19:54Z", "type": "commit"}, {"oid": "d7994e4deff7fb0608edfd242e9dfacd1c3fc52d", "url": "https://github.com/palantir/atlasdb/commit/d7994e4deff7fb0608edfd242e9dfacd1c3fc52d", "message": "further improvement", "committedDate": "2020-05-27T10:24:24Z", "type": "commit"}, {"oid": "0f0dda9b9f6d9059a1a8a857b4a31488d5bb20c2", "url": "https://github.com/palantir/atlasdb/commit/0f0dda9b9f6d9059a1a8a857b4a31488d5bb20c2", "message": "fix out-by-ones", "committedDate": "2020-05-27T10:42:52Z", "type": "commit"}, {"oid": "be1e98cfe593047cccd121344e79431149cb02d5", "url": "https://github.com/palantir/atlasdb/commit/be1e98cfe593047cccd121344e79431149cb02d5", "message": "merge in previous branch", "committedDate": "2020-05-27T12:04:14Z", "type": "commit"}, {"oid": "c396b07a71402745a7973268065627d0979fcc5f", "url": "https://github.com/palantir/atlasdb/commit/c396b07a71402745a7973268065627d0979fcc5f", "message": "change to return immutable sets", "committedDate": "2020-05-27T12:10:46Z", "type": "commit"}, {"oid": "ebfc2a36e6a17b858c9bc5a8fb2add1b0c58542a", "url": "https://github.com/palantir/atlasdb/commit/ebfc2a36e6a17b858c9bc5a8fb2add1b0c58542a", "message": "rework tests and tidy", "committedDate": "2020-05-27T14:39:15Z", "type": "commit"}, {"oid": "ba284b1ae7e88d796761ec1ae4cb2d5a9439bf44", "url": "https://github.com/palantir/atlasdb/commit/ba284b1ae7e88d796761ec1ae4cb2d5a9439bf44", "message": "remove no op implementations", "committedDate": "2020-05-27T14:44:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIzNDgzNw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431234837", "bodyText": "What happens when timestampToVersion is empty?", "author": "jkozlowski", "createdAt": "2020-05-27T15:31:59Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class ClientLockWatchEventLogImpl implements ClientLockWatchEventLog {\n+    private final ClientLockWatchSnapshotUpdater snapshotUpdater;\n+    private final ConcurrentSkipListMap<Long, LockWatchEvent> eventLog;\n+    private volatile Optional<IdentifiedVersion> latestVersion;\n+\n+    public static ClientLockWatchEventLogImpl create() {\n+        return new ClientLockWatchEventLogImpl(ClientLockWatchSnapshotUpdaterImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static ClientLockWatchEventLogImpl create(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        return new ClientLockWatchEventLogImpl(snapshotUpdater);\n+    }\n+\n+    private ClientLockWatchEventLogImpl(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        this.snapshotUpdater = snapshotUpdater;\n+        this.eventLog = new ConcurrentSkipListMap<>();\n+        this.latestVersion = Optional.empty();\n+    }\n+\n+    @Override\n+    public synchronized Optional<IdentifiedVersion> processUpdate(\n+            LockWatchStateUpdate update,\n+            Optional<IdentifiedVersion> earliestVersion) {\n+        ProcessingVisitor visitor;\n+        if (newLeader(update)) {\n+            visitor = new NewLeaderVisitor(earliestVersion);\n+        } else {\n+            visitor = new ProcessingVisitor(earliestVersion);\n+        }\n+        update.accept(visitor);\n+        return latestVersion;\n+    }\n+\n+    /**\n+     * @param timestampToVersion mapping from timestamp to identified version from client-side event cache;\n+     * @param version            latest version that the client knows about; should be before timestamps in the\n+     *                           mapping;\n+     * @return lock watch events that occurred from (exclusive) the provided version, up to (inclusive) the latest\n+     * version in the timestamp to version map.\n+     */\n+    @Override\n+    public synchronized TransactionsLockWatchEvents getEventsForTransactions(\n+            Map<Long, IdentifiedVersion> timestampToVersion,\n+            Optional<IdentifiedVersion> version) {\n+        Preconditions.checkState(latestVersion.isPresent(), \"Cannot get events when log does not know its version\");\n+        Optional<IdentifiedVersion> versionInclusive =\n+                version.map(oldVersion -> IdentifiedVersion.of(oldVersion.id(), oldVersion.version() + 1));\n+        IdentifiedVersion currentVersion = latestVersion.get();\n+        /*\n+        There are three cases to consider where we would return a snapshot:\n+            1: they provide an empty version;\n+            2. their version has a different UUID (i.e. refers to the wrong leader);\n+            3. their version is behind our log.\n+        Note that if their version is ahead of our log, or we do not have a version, an exception is thrown instead.\n+         */\n+        if (!versionInclusive.isPresent()\n+                || !versionInclusive.get().id().equals(currentVersion.id())\n+                || eventLog.floorKey(versionInclusive.get().version()) == null) {\n+            return TransactionsLockWatchEvents.failure(snapshotUpdater.getSnapshot(currentVersion));\n+        }\n+\n+        IdentifiedVersion toVersion = Collections.max(timestampToVersion.values());", "originalCommit": "ba284b1ae7e88d796761ec1ae4cb2d5a9439bf44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI2MTg0OA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431261848", "bodyText": "According to Collections.max: @throws NoSuchElementException if the collection is empty.\nI think throwing is the right behaviour (if there are no elements, then there will be no updates anyway, so that does not make sense), but I'll change this to use a Preconditions instead.", "author": "Jolyon-S", "createdAt": "2020-05-27T16:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIzNDgzNw=="}], "type": "inlineReview"}, {"oid": "1eaaa9291c9b2eb3e605f86ae4490d5f2df733a4", "url": "https://github.com/palantir/atlasdb/commit/1eaaa9291c9b2eb3e605f86ae4490d5f2df733a4", "message": "add preconditions check", "committedDate": "2020-05-27T16:05:35Z", "type": "commit"}, {"oid": "df8be797623ce419b38ed47df893db4e8cb1da49", "url": "https://github.com/palantir/atlasdb/commit/df8be797623ce419b38ed47df893db4e8cb1da49", "message": "tidy lwec", "committedDate": "2020-05-28T09:29:05Z", "type": "commit"}, {"oid": "979a218f7c9365f528ef128429fc9060bc13d621", "url": "https://github.com/palantir/atlasdb/commit/979a218f7c9365f528ef128429fc9060bc13d621", "message": "rework test for LWEC", "committedDate": "2020-05-28T09:52:28Z", "type": "commit"}, {"oid": "367d7bf92d7119bf06b0920eabc3e9f2bc2f0562", "url": "https://github.com/palantir/atlasdb/commit/367d7bf92d7119bf06b0920eabc3e9f2bc2f0562", "message": "clean up impls some more", "committedDate": "2020-05-28T10:09:56Z", "type": "commit"}, {"oid": "a5911c0293b940aa72c155d142c516cdb68c7f62", "url": "https://github.com/palantir/atlasdb/commit/a5911c0293b940aa72c155d142c516cdb68c7f62", "message": "tidy up lwel tests", "committedDate": "2020-05-28T10:19:27Z", "type": "commit"}, {"oid": "587796014b685eec6ee3d289fe8d627a2946e6ae", "url": "https://github.com/palantir/atlasdb/commit/587796014b685eec6ee3d289fe8d627a2946e6ae", "message": "write snapshotter tests", "committedDate": "2020-05-28T10:29:19Z", "type": "commit"}, {"oid": "def4fa47f8b4e3968c7b67575ae4020260ff25d9", "url": "https://github.com/palantir/atlasdb/commit/def4fa47f8b4e3968c7b67575ae4020260ff25d9", "message": "remove concurrent skip list map from lwec", "committedDate": "2020-05-28T10:39:23Z", "type": "commit"}, {"oid": "2aaf8fdb6b6bafcc6accfbd9c61c59ef0a4d7f92", "url": "https://github.com/palantir/atlasdb/commit/2aaf8fdb6b6bafcc6accfbd9c61c59ef0a4d7f92", "message": "Merge branch 'develop' into lw-client-cache-ete", "committedDate": "2020-05-28T12:26:33Z", "type": "commit"}, {"oid": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6", "url": "https://github.com/palantir/atlasdb/commit/38e8dd49dca47ec5460a8c2fa40d079bf463d7c6", "message": "merge in and add commit update - DOES NOT USE LOCK TOKEN YET", "committedDate": "2020-05-28T13:16:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1MjQwNQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431852405", "bodyText": "should this be aware of table references + cells?", "author": "j-baker", "createdAt": "2020-05-28T13:53:35Z", "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/CommitUpdate.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Set;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+\n+public interface CommitUpdate {\n+    long commitTs();\n+\n+    <T> T accept(Visitor<T> visitor);\n+\n+    @Value.Immutable\n+    interface InvalidateAll extends CommitUpdate {\n+        @Override\n+        default <T> T accept(Visitor<T> visitor) {\n+            return visitor.visit(this);\n+        }\n+    }\n+\n+    @Value.Immutable\n+    interface InvalidateSome extends CommitUpdate {\n+        Set<LockDescriptor> invalidatedLocks();", "originalCommit": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1MzEzOA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431853138", "bodyText": "I don't actually know the answer here - could see it being easier or harder to implement in various places as a consequence", "author": "j-baker", "createdAt": "2020-05-28T13:54:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1MjQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1MzQ5Ng==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431853496", "bodyText": "you should probably throw if they're incomparable?", "author": "j-baker", "createdAt": "2020-05-28T13:55:02Z", "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/IdentifiedVersion.java", "diffHunk": "@@ -21,9 +21,19 @@\n import org.immutables.value.Value;\n \n @Value.Immutable\n-public interface IdentifiedVersion {\n+public interface IdentifiedVersion extends Comparable<IdentifiedVersion> {\n     @Value.Parameter\n     UUID id();\n     @Value.Parameter\n     long version();\n+\n+    static IdentifiedVersion of(UUID id, long version) {\n+        return ImmutableIdentifiedVersion.of(id, version);\n+    }\n+\n+    @Override\n+    default int compareTo(IdentifiedVersion otherVersion) {\n+        // Compare on version only; if used for equality, will not consider leader id\n+        return Long.compare(version(), otherVersion.version());", "originalCommit": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1MzY3NA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431853674", "bodyText": "and then probably have a comparator and not make them be comparable?", "author": "j-baker", "createdAt": "2020-05-28T13:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1MzQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1Mzk5MQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431853991", "bodyText": "IdentifiedVersion needs to change name", "author": "j-baker", "createdAt": "2020-05-28T13:55:40Z", "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/TransactionsLockWatchEvents.java", "diffHunk": "@@ -50,7 +50,7 @@ static ForcedSnapshot failure(LockWatchStateUpdate.Snapshot snapshot) {\n         @Value.Parameter\n         List<LockWatchEvent> events();\n         @Value.Parameter\n-        Map<Long, Long> startTsToSequence();\n+        Map<Long, IdentifiedVersion> startTsToSequence();", "originalCommit": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1NTE1MQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431855151", "bodyText": "split process update and aging out older entries", "author": "j-baker", "createdAt": "2020-05-28T13:57:05Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLog.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.palantir.lock.LockDescriptor;\n+\n+public interface ClientLockWatchEventLog {\n+    TransactionsLockWatchEvents getEventsForTransactions(\n+            Map<Long, IdentifiedVersion> timestampToVersion,\n+            Optional<IdentifiedVersion> version);\n+    Optional<Set<LockDescriptor>> getEventsBetweenVersions(\n+            IdentifiedVersion startVersion,\n+            IdentifiedVersion endVersion);\n+    Optional<IdentifiedVersion> getLatestKnownVersion();\n+    Optional<IdentifiedVersion> processUpdate(LockWatchStateUpdate update, Optional<IdentifiedVersion> earliestVersion);", "originalCommit": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1NTU2Ng==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431855566", "bodyText": "remove Concurrent + volatile", "author": "j-baker", "createdAt": "2020-05-28T13:57:39Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class ClientLockWatchEventLogImpl implements ClientLockWatchEventLog {\n+    private final ClientLockWatchSnapshotUpdater snapshotUpdater;\n+    private final ConcurrentSkipListMap<Long, LockWatchEvent> eventMap = new ConcurrentSkipListMap<>();\n+    private volatile Optional<IdentifiedVersion> latestVersion = Optional.empty();", "originalCommit": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1NTg3Mg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431855872", "bodyText": "@GuardedBy(\"this\")", "author": "j-baker", "createdAt": "2020-05-28T13:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1NTU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1NjQ4Mw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431856483", "bodyText": "either mark final or just factor into separate method createVisitor", "author": "j-baker", "createdAt": "2020-05-28T13:58:56Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class ClientLockWatchEventLogImpl implements ClientLockWatchEventLog {\n+    private final ClientLockWatchSnapshotUpdater snapshotUpdater;\n+    private final ConcurrentSkipListMap<Long, LockWatchEvent> eventMap = new ConcurrentSkipListMap<>();\n+    private volatile Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    public static ClientLockWatchEventLogImpl create() {\n+        return create(ClientLockWatchSnapshotUpdaterImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static ClientLockWatchEventLogImpl create(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        return new ClientLockWatchEventLogImpl(snapshotUpdater);\n+    }\n+\n+    private ClientLockWatchEventLogImpl(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        this.snapshotUpdater = snapshotUpdater;\n+    }\n+\n+    @Override\n+    public synchronized Optional<IdentifiedVersion> processUpdate(\n+            LockWatchStateUpdate update,\n+            Optional<IdentifiedVersion> earliestVersion) {\n+        ProcessingVisitor visitor;", "originalCommit": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1NzY1Nw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431857657", "bodyText": "boolean providedEmptyVersion = ...\nboolean versionHasDifferentUuid = ...\nboolean tooFarBehindLog =...\nif (providedEmptyVersion || versionHasDifferentUuid || tooFarBehindLog) {\n    return snapshot\n}", "author": "j-baker", "createdAt": "2020-05-28T14:00:25Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class ClientLockWatchEventLogImpl implements ClientLockWatchEventLog {\n+    private final ClientLockWatchSnapshotUpdater snapshotUpdater;\n+    private final ConcurrentSkipListMap<Long, LockWatchEvent> eventMap = new ConcurrentSkipListMap<>();\n+    private volatile Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    public static ClientLockWatchEventLogImpl create() {\n+        return create(ClientLockWatchSnapshotUpdaterImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static ClientLockWatchEventLogImpl create(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        return new ClientLockWatchEventLogImpl(snapshotUpdater);\n+    }\n+\n+    private ClientLockWatchEventLogImpl(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        this.snapshotUpdater = snapshotUpdater;\n+    }\n+\n+    @Override\n+    public synchronized Optional<IdentifiedVersion> processUpdate(\n+            LockWatchStateUpdate update,\n+            Optional<IdentifiedVersion> earliestVersion) {\n+        ProcessingVisitor visitor;\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            visitor = new NewLeaderVisitor(earliestVersion);\n+        } else {\n+            visitor = new ProcessingVisitor(earliestVersion);\n+        }\n+        update.accept(visitor);\n+        return latestVersion;\n+    }\n+\n+    /**\n+     * @param timestampToVersion mapping from timestamp to identified version from client-side event cache;\n+     * @param version            latest version that the client knows about; should be before timestamps in the\n+     *                           mapping;\n+     * @return lock watch events that occurred from (exclusive) the provided version, up to (inclusive) the latest\n+     * version in the timestamp to version map.\n+     */\n+    @Override\n+    public synchronized TransactionsLockWatchEvents getEventsForTransactions(\n+            Map<Long, IdentifiedVersion> timestampToVersion,\n+            Optional<IdentifiedVersion> version) {\n+        Optional<IdentifiedVersion> versionInclusive = version.map(this::getInclusiveVersion);\n+        IdentifiedVersion toVersion = Collections.max(timestampToVersion.values());\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(toVersion);\n+\n+        /*\n+        There are three cases to consider where we would return a snapshot:\n+            1: they provide an empty version;\n+            2. their version has a different UUID (i.e. refers to the wrong leader);\n+            3. their version is behind our log.\n+        Note that if their version is ahead of our log, or we do not have a version, an exception is thrown instead.\n+         */\n+        if (!versionInclusive.isPresent()", "originalCommit": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "94446d78465b0a42c646c0a747d20a45a5d7d561", "url": "https://github.com/palantir/atlasdb/commit/94446d78465b0a42c646c0a747d20a45a5d7d561", "message": "action some comments", "committedDate": "2020-05-28T14:42:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5NTk4NA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431895984", "bodyText": "Maybe I'm missing something here, but I don't see how it is possible to have sufficient information to exclude a set of locks based solely on the LockToken. At the time that this is taken out in the commit flow, we do have access to Set<LockDescriptor> which we register; I wonder if it is worth changing this interface to use that instead - it would certainly be easier and potentially just the right thing to do, but open to suggestions.", "author": "Jolyon-S", "createdAt": "2020-05-28T14:47:37Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCache.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.palantir.lock.v2.LockToken;\n+\n+public interface LockWatchEventCache {\n+    /**\n+     * Returns the last known lock watch version for the cache.\n+     */\n+    Optional<IdentifiedVersion> lastKnownVersion();\n+\n+    /**\n+     * Updates the cache with the update, and identifies the given timestamps with that lock watch state.\n+     */\n+    void processTransactionUpdate(Collection<Long> startTimestamps, LockWatchStateUpdate update);\n+\n+    /**\n+     * Updates the cache with the update, and calculates the {@link CommitUpdate} taking into account all changes to\n+     * lock watch state since the start of the transaction, excluding the transaction's own commit locks.\n+     *\n+     * @param startTs          start timestamp of the transaction\n+     * @param commitTs         commit timestamp of the transaction\n+     * @param commitLocksToken lock token for the transactions's commit locks\n+     * @return the commit update for this transaction's precommit condition\n+     */\n+    CommitUpdate getCommitUpdate(long startTs, long commitTs, LockToken commitLocksToken);", "originalCommit": "94446d78465b0a42c646c0a747d20a45a5d7d561", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyMTU4NA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431921584", "bodyText": "Should be possible: each LockEvent/UnlockEvent has the LockToken; just need to figure out what the right id for filtering is?", "author": "jkozlowski", "createdAt": "2020-05-28T15:22:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5NTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyMzM4Mg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431923382", "bodyText": "aaah\nLockWatchEvent obscures things by a layer, I missed that. Good catch!", "author": "Jolyon-S", "createdAt": "2020-05-28T15:24:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5NTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4NzAzMA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r432387030", "bodyText": "Unlock events don't have a lock token, but then we don't strictly care about unlock events in this update at all; we only want the set of lock descriptors (excluding commit locks) that have been taken out at some point in this transaction; if lock X was locked then unlocked, we clearly still want to return X (i.e. the unlock events are irrelevant for the commit update / conflict checking of cached reads).", "author": "Jolyon-S", "createdAt": "2020-05-29T10:08:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5NTk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5NjY3OQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431896679", "bodyText": "Todo - consider how to handle the commitLocksToken - there is a comment above discussing my concern here.", "author": "Jolyon-S", "createdAt": "2020-05-28T14:48:25Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * Notes on concurrency: all public methods in this class are synchronised: this removes any concern that the timestamp\n+ * mapping will be modified while also being cleared or read. For processing updates and getting events, this should not\n+ * have a performance impact as these methods will be called in a single-threaded manner anyway (via an autobatcher),\n+ * but the method to remove entries is not necessarily called as such, and may cause some impact on performance.\n+ */\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final HashMap<Long, IdentifiedVersion> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions = TreeMultimap.create();\n+\n+    private LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+    }\n+\n+    public static LockWatchEventCacheImpl create() {\n+        return create(ClientLockWatchEventLogImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventCacheImpl create(ClientLockWatchEventLog eventLog) {\n+        return new LockWatchEventCacheImpl(eventLog);\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public synchronized void processTransactionUpdate(\n+            Collection<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> currentVersion = eventLog.getLatestKnownVersion();\n+        Optional<IdentifiedVersion> latestVersion = eventLog.processUpdate(update);\n+        getEarliestVersion().ifPresent(eventLog::removeOldEntries);\n+\n+        if (!(latestVersion.isPresent()\n+                && currentVersion.isPresent()\n+                && latestVersion.get().id().equals(currentVersion.get().id())\n+                && update.accept(SuccessVisitor.INSTANCE))) {\n+            timestampMap.clear();\n+            aliveVersions.clear();\n+        }\n+\n+        latestVersion.ifPresent(\n+                version -> startTimestamps.forEach(timestamp -> {\n+                    timestampMap.put(timestamp, version);\n+                    aliveVersions.put(version, timestamp);\n+                }));\n+    }\n+\n+    @Override\n+    public synchronized CommitUpdate getCommitUpdate(long startTs, long commitTs, LockToken commitLocksToken) {", "originalCommit": "94446d78465b0a42c646c0a747d20a45a5d7d561", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6b77ad44a8337b1b6b663681a532e4270f36f4c2", "url": "https://github.com/palantir/atlasdb/commit/6b77ad44a8337b1b6b663681a532e4270f36f4c2", "message": "change comparable to comparator", "committedDate": "2020-05-28T14:57:06Z", "type": "commit"}, {"oid": "356c7496ccd0727309e0a17b14881d888af70bb8", "url": "https://github.com/palantir/atlasdb/commit/356c7496ccd0727309e0a17b14881d888af70bb8", "message": "fix test", "committedDate": "2020-05-28T15:21:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyMzg1Nw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431923857", "bodyText": "worth having an error message", "author": "j-baker", "createdAt": "2020-05-28T15:25:21Z", "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/IdentifiedVersion.java", "diffHunk": "@@ -16,14 +16,28 @@\n \n package com.palantir.lock.watch;\n \n+import java.util.Comparator;\n import java.util.UUID;\n \n import org.immutables.value.Value;\n \n+import com.palantir.logsafe.Preconditions;\n+\n @Value.Immutable\n public interface IdentifiedVersion {\n     @Value.Parameter\n     UUID id();\n     @Value.Parameter\n     long version();\n+\n+    static IdentifiedVersion of(UUID id, long version) {\n+        return ImmutableIdentifiedVersion.of(id, version);\n+    }\n+\n+    static Comparator<IdentifiedVersion> comparator() {\n+        return (version1, version2) -> {\n+            Preconditions.checkArgument(version1.id().equals(version2.id()));", "originalCommit": "356c7496ccd0727309e0a17b14881d888af70bb8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyNDAzNQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431924035", "bodyText": "why is this Optional?", "author": "j-baker", "createdAt": "2020-05-28T15:25:37Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLog.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.palantir.lock.LockDescriptor;\n+\n+public interface ClientLockWatchEventLog {\n+    TransactionsLockWatchEvents getEventsForTransactions(\n+            Map<Long, IdentifiedVersion> timestampToVersion,\n+            Optional<IdentifiedVersion> version);\n+    Optional<Set<LockDescriptor>> getEventsBetweenVersions(\n+            IdentifiedVersion startVersion,\n+            IdentifiedVersion endVersion);", "originalCommit": "356c7496ccd0727309e0a17b14881d888af70bb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyNDI2MA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431924260", "bodyText": "also, why does this not return a TransactionsLockWatchEvents?", "author": "j-baker", "createdAt": "2020-05-28T15:25:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyNDAzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyNTc1Mw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431925753", "bodyText": "I could equally return that and have the above (i.e. the cache) turn that into a commit update; this approach just makes the cache not worry about events themselves.", "author": "Jolyon-S", "createdAt": "2020-05-28T15:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyNDAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyNDQ4Mg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431924482", "bodyText": "probably add this annotation to all the fields", "author": "j-baker", "createdAt": "2020-05-28T15:26:13Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class ClientLockWatchEventLogImpl implements ClientLockWatchEventLog {\n+    private final ClientLockWatchSnapshotUpdater snapshotUpdater;\n+    private final TreeMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    @GuardedBy(\"this\")", "originalCommit": "356c7496ccd0727309e0a17b14881d888af70bb8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyNjY3MQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431926671", "bodyText": "factor out constants 'INCLUSIVE', so the reader doesn't have to understand what 'true' means. Also, for stuff like this, do ImmutableList.copyOf(", "author": "j-baker", "createdAt": "2020-05-28T15:29:02Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class ClientLockWatchEventLogImpl implements ClientLockWatchEventLog {\n+    private final ClientLockWatchSnapshotUpdater snapshotUpdater;\n+    private final TreeMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    @GuardedBy(\"this\")\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    public static ClientLockWatchEventLogImpl create() {\n+        return create(ClientLockWatchSnapshotUpdaterImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static ClientLockWatchEventLogImpl create(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        return new ClientLockWatchEventLogImpl(snapshotUpdater);\n+    }\n+\n+    private ClientLockWatchEventLogImpl(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        this.snapshotUpdater = snapshotUpdater;\n+    }\n+\n+    @Override\n+    public synchronized Optional<IdentifiedVersion> processUpdate(LockWatchStateUpdate update) {\n+        final ProcessingVisitor visitor;\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            visitor = new NewLeaderVisitor();\n+        } else {\n+            visitor = new ProcessingVisitor();\n+        }\n+        update.accept(visitor);\n+        return latestVersion;\n+    }\n+\n+    @Override\n+    public synchronized void removeOldEntries(IdentifiedVersion earliestVersion) {\n+        Set<Map.Entry<Long, LockWatchEvent>> eventsToBeRemoved =\n+                eventMap.headMap(earliestVersion.version()).entrySet();\n+        snapshotUpdater.processEvents(\n+                eventsToBeRemoved.stream().map(Map.Entry::getValue).collect(Collectors.toList()));\n+        eventsToBeRemoved.clear();\n+    }\n+\n+    /**\n+     * @param timestampToVersion mapping from timestamp to identified version from client-side event cache;\n+     * @param version            latest version that the client knows about; should be before timestamps in the\n+     *                           mapping;\n+     * @return lock watch events that occurred from (exclusive) the provided version, up to (inclusive) the latest\n+     * version in the timestamp to version map.\n+     */\n+    @Override\n+    public synchronized TransactionsLockWatchEvents getEventsForTransactions(\n+            Map<Long, IdentifiedVersion> timestampToVersion,\n+            Optional<IdentifiedVersion> version) {\n+        Optional<IdentifiedVersion> versionInclusive = version.map(this::createInclusiveVersion);\n+        IdentifiedVersion toVersion = Collections.max(timestampToVersion.values(), IdentifiedVersion.comparator());\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(toVersion);\n+\n+        if (!versionInclusive.isPresent() || differentLeaderOrTooFarBehind(currentVersion, versionInclusive.get())) {\n+            return TransactionsLockWatchEvents.failure(snapshotUpdater.getSnapshot(currentVersion));\n+        }\n+\n+        if (eventMap.isEmpty()) {\n+            return TransactionsLockWatchEvents.success(ImmutableList.of(), timestampToVersion);\n+        }\n+\n+        IdentifiedVersion fromVersion = versionInclusive.get();\n+\n+        return TransactionsLockWatchEvents.success(\n+                new ArrayList<>(eventMap.subMap(fromVersion.version(), true, toVersion.version(), true).values()),", "originalCommit": "356c7496ccd0727309e0a17b14881d888af70bb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyNzY0Ng==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431927646", "bodyText": "(because when it can be immutable for free, it should be :))\nadvantages: frequently immutables style classes will copy to ensure immutability, and ImmutableList.copyOf() is a no-op if you're copying an immutable list.\nAlso, immutablelist is marginally faster than arraylist because you don't have to do bounds checking. But really immutability is what you want.", "author": "j-baker", "createdAt": "2020-05-28T15:30:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyNjY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyODM2Nw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431928367", "bodyText": "you should define this method (in as far as it has to be a different method) in terms of the other one. The logic is basically the same. But I don't think should have its own return type, so should basically be the same method.", "author": "j-baker", "createdAt": "2020-05-28T15:31:10Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class ClientLockWatchEventLogImpl implements ClientLockWatchEventLog {\n+    private final ClientLockWatchSnapshotUpdater snapshotUpdater;\n+    private final TreeMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    @GuardedBy(\"this\")\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    public static ClientLockWatchEventLogImpl create() {\n+        return create(ClientLockWatchSnapshotUpdaterImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static ClientLockWatchEventLogImpl create(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        return new ClientLockWatchEventLogImpl(snapshotUpdater);\n+    }\n+\n+    private ClientLockWatchEventLogImpl(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        this.snapshotUpdater = snapshotUpdater;\n+    }\n+\n+    @Override\n+    public synchronized Optional<IdentifiedVersion> processUpdate(LockWatchStateUpdate update) {\n+        final ProcessingVisitor visitor;\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            visitor = new NewLeaderVisitor();\n+        } else {\n+            visitor = new ProcessingVisitor();\n+        }\n+        update.accept(visitor);\n+        return latestVersion;\n+    }\n+\n+    @Override\n+    public synchronized void removeOldEntries(IdentifiedVersion earliestVersion) {\n+        Set<Map.Entry<Long, LockWatchEvent>> eventsToBeRemoved =\n+                eventMap.headMap(earliestVersion.version()).entrySet();\n+        snapshotUpdater.processEvents(\n+                eventsToBeRemoved.stream().map(Map.Entry::getValue).collect(Collectors.toList()));\n+        eventsToBeRemoved.clear();\n+    }\n+\n+    /**\n+     * @param timestampToVersion mapping from timestamp to identified version from client-side event cache;\n+     * @param version            latest version that the client knows about; should be before timestamps in the\n+     *                           mapping;\n+     * @return lock watch events that occurred from (exclusive) the provided version, up to (inclusive) the latest\n+     * version in the timestamp to version map.\n+     */\n+    @Override\n+    public synchronized TransactionsLockWatchEvents getEventsForTransactions(\n+            Map<Long, IdentifiedVersion> timestampToVersion,\n+            Optional<IdentifiedVersion> version) {\n+        Optional<IdentifiedVersion> versionInclusive = version.map(this::createInclusiveVersion);\n+        IdentifiedVersion toVersion = Collections.max(timestampToVersion.values(), IdentifiedVersion.comparator());\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(toVersion);\n+\n+        if (!versionInclusive.isPresent() || differentLeaderOrTooFarBehind(currentVersion, versionInclusive.get())) {\n+            return TransactionsLockWatchEvents.failure(snapshotUpdater.getSnapshot(currentVersion));\n+        }\n+\n+        if (eventMap.isEmpty()) {\n+            return TransactionsLockWatchEvents.success(ImmutableList.of(), timestampToVersion);\n+        }\n+\n+        IdentifiedVersion fromVersion = versionInclusive.get();\n+\n+        return TransactionsLockWatchEvents.success(\n+                new ArrayList<>(eventMap.subMap(fromVersion.version(), true, toVersion.version(), true).values()),\n+                timestampToVersion);\n+    }\n+\n+    @Override\n+    public synchronized Optional<Set<LockDescriptor>> getEventsBetweenVersions(\n+            IdentifiedVersion startVersion,\n+            IdentifiedVersion endVersion) {\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(endVersion);\n+        IdentifiedVersion fromVersion = createInclusiveVersion(startVersion);\n+\n+        if (differentLeaderOrTooFarBehind(currentVersion, fromVersion)) {", "originalCommit": "356c7496ccd0727309e0a17b14881d888af70bb8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzMzM0OA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431933348", "bodyText": "so there's an interesting class of bug with this sort of thing. Basically, you can partially succeed - accept some but not all of the writes, and then fail (e.g. what if resetWithSnapshot fails below for some reason). Then you're in a corrupt state.\nIt's relatively straightforward to cover this. Basically, you have a boolean field 'failed' and before you mutate any state, you set it to true, and then false before you're done. Before your reading methods, you checkState(!failed) and if it fails for any reason you know you have a bug.\nA different thing is to have immutable state which you replace on success (e.g. make transactional), but that changes your code style a fair bit.", "author": "j-baker", "createdAt": "2020-05-28T15:37:57Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class ClientLockWatchEventLogImpl implements ClientLockWatchEventLog {\n+    private final ClientLockWatchSnapshotUpdater snapshotUpdater;\n+    private final TreeMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    @GuardedBy(\"this\")\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    public static ClientLockWatchEventLogImpl create() {\n+        return create(ClientLockWatchSnapshotUpdaterImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static ClientLockWatchEventLogImpl create(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        return new ClientLockWatchEventLogImpl(snapshotUpdater);\n+    }\n+\n+    private ClientLockWatchEventLogImpl(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        this.snapshotUpdater = snapshotUpdater;\n+    }\n+\n+    @Override\n+    public synchronized Optional<IdentifiedVersion> processUpdate(LockWatchStateUpdate update) {\n+        final ProcessingVisitor visitor;\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            visitor = new NewLeaderVisitor();\n+        } else {\n+            visitor = new ProcessingVisitor();\n+        }\n+        update.accept(visitor);\n+        return latestVersion;\n+    }\n+\n+    @Override\n+    public synchronized void removeOldEntries(IdentifiedVersion earliestVersion) {\n+        Set<Map.Entry<Long, LockWatchEvent>> eventsToBeRemoved =\n+                eventMap.headMap(earliestVersion.version()).entrySet();\n+        snapshotUpdater.processEvents(\n+                eventsToBeRemoved.stream().map(Map.Entry::getValue).collect(Collectors.toList()));\n+        eventsToBeRemoved.clear();\n+    }\n+\n+    /**\n+     * @param timestampToVersion mapping from timestamp to identified version from client-side event cache;\n+     * @param version            latest version that the client knows about; should be before timestamps in the\n+     *                           mapping;\n+     * @return lock watch events that occurred from (exclusive) the provided version, up to (inclusive) the latest\n+     * version in the timestamp to version map.\n+     */\n+    @Override\n+    public synchronized TransactionsLockWatchEvents getEventsForTransactions(\n+            Map<Long, IdentifiedVersion> timestampToVersion,\n+            Optional<IdentifiedVersion> version) {\n+        Optional<IdentifiedVersion> versionInclusive = version.map(this::createInclusiveVersion);\n+        IdentifiedVersion toVersion = Collections.max(timestampToVersion.values(), IdentifiedVersion.comparator());\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(toVersion);\n+\n+        if (!versionInclusive.isPresent() || differentLeaderOrTooFarBehind(currentVersion, versionInclusive.get())) {\n+            return TransactionsLockWatchEvents.failure(snapshotUpdater.getSnapshot(currentVersion));\n+        }\n+\n+        if (eventMap.isEmpty()) {\n+            return TransactionsLockWatchEvents.success(ImmutableList.of(), timestampToVersion);\n+        }\n+\n+        IdentifiedVersion fromVersion = versionInclusive.get();\n+\n+        return TransactionsLockWatchEvents.success(\n+                new ArrayList<>(eventMap.subMap(fromVersion.version(), true, toVersion.version(), true).values()),\n+                timestampToVersion);\n+    }\n+\n+    @Override\n+    public synchronized Optional<Set<LockDescriptor>> getEventsBetweenVersions(\n+            IdentifiedVersion startVersion,\n+            IdentifiedVersion endVersion) {\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(endVersion);\n+        IdentifiedVersion fromVersion = createInclusiveVersion(startVersion);\n+\n+        if (differentLeaderOrTooFarBehind(currentVersion, fromVersion)) {\n+            return Optional.empty();\n+        }\n+\n+        if (eventMap.isEmpty()) {\n+            return Optional.of(ImmutableSet.of());\n+        }\n+\n+        List<LockWatchEvent> events =\n+                new ArrayList<>(eventMap.subMap(fromVersion.version(), true, endVersion.version(), true).values());\n+        Set<LockDescriptor> locksTakenOut = new HashSet<>();\n+        events.forEach(event -> locksTakenOut.addAll(event.accept(LockEventVisitor.INSTANCE)));\n+\n+        return Optional.of(locksTakenOut);\n+    }\n+\n+    @Override\n+    public synchronized Optional<IdentifiedVersion> getLatestKnownVersion() {\n+        return latestVersion;\n+    }\n+\n+    private boolean differentLeaderOrTooFarBehind(IdentifiedVersion currentVersion, IdentifiedVersion startVersion) {\n+        return !startVersion.id().equals(currentVersion.id()) || eventMap.floorKey(startVersion.version()) == null;\n+    }\n+\n+    private IdentifiedVersion createInclusiveVersion(IdentifiedVersion startVersion) {\n+        return IdentifiedVersion.of(startVersion.id(), startVersion.version() + 1);\n+    }\n+\n+    private IdentifiedVersion getLatestVersionAndVerify(IdentifiedVersion endVersion) {\n+        Preconditions.checkState(latestVersion.isPresent(), \"Cannot get events when log does not know its version\");\n+        IdentifiedVersion currentVersion = latestVersion.get();\n+        Preconditions.checkArgument(IdentifiedVersion.comparator().compare(endVersion, currentVersion) > -1,\n+                \"Transactions' view of the world is more up-to-date than the log\");\n+        return currentVersion;\n+    }\n+\n+    private void processSuccess(LockWatchStateUpdate.Success success) {\n+        Preconditions.checkState(latestVersion.isPresent(), \"Must have a known version to process successful updates\");", "originalCommit": "356c7496ccd0727309e0a17b14881d888af70bb8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNDU4NA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431934584", "bodyText": "lower case long. Never use Long where you can avoid it - prefer long which is guaranteed to not be null, or something like OptionalLong most of the time. With generics, you can't avoid it a lot of the time.", "author": "j-baker", "createdAt": "2020-05-28T15:39:51Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCache.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.palantir.lock.v2.LockToken;\n+\n+public interface LockWatchEventCache {\n+    /**\n+     * Returns the last known lock watch version for the cache.\n+     */\n+    Optional<IdentifiedVersion> lastKnownVersion();\n+\n+    /**\n+     * Updates the cache with the update, and identifies the given timestamps with that lock watch state.\n+     */\n+    void processTransactionUpdate(Collection<Long> startTimestamps, LockWatchStateUpdate update);\n+\n+    /**\n+     * Updates the cache with the update, and calculates the {@link CommitUpdate} taking into account all changes to\n+     * lock watch state since the start of the transaction, excluding the transaction's own commit locks.\n+     *\n+     * @param startTs          start timestamp of the transaction\n+     * @param commitTs         commit timestamp of the transaction\n+     * @param commitLocksToken lock token for the transactions's commit locks\n+     * @return the commit update for this transaction's precommit condition\n+     */\n+    CommitUpdate getCommitUpdate(long startTs, long commitTs, LockToken commitLocksToken);\n+\n+    /**\n+     * Given a set of start timestamps, and a lock watch state version, returns a list of all events that occurred since\n+     * that version, and a map associating each start timestamp with its respective lock watch state version.\n+     */\n+    TransactionsLockWatchEvents getEventsForTransactions(Set<Long> startTimestamps,\n+            Optional<IdentifiedVersion> version);\n+\n+    /**\n+     * Removes the given timestamp from the cache. If no timestamps exist for a given version, events before that\n+     * version in the underlying {@link ClientLockWatchEventLog} will be deleted on next update.\n+     */\n+    void removeTimestampFromCache(Long timestamp);", "originalCommit": "356c7496ccd0727309e0a17b14881d888af70bb8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ba530f4e41af46b0894438dbb7016573aad01619", "url": "https://github.com/palantir/atlasdb/commit/ba530f4e41af46b0894438dbb7016573aad01619", "message": "on the path to greatness", "committedDate": "2020-05-29T09:07:41Z", "type": "commit"}, {"oid": "e923ad3393151273089da13078bc02a465634f69", "url": "https://github.com/palantir/atlasdb/commit/e923ad3393151273089da13078bc02a465634f69", "message": "rework to remove dedupe (somewhat)", "committedDate": "2020-05-29T09:26:49Z", "type": "commit"}, {"oid": "344b178e580d208afac2d63b832aacdce7ca671b", "url": "https://github.com/palantir/atlasdb/commit/344b178e580d208afac2d63b832aacdce7ca671b", "message": "add exception message to comparator", "committedDate": "2020-05-29T09:28:03Z", "type": "commit"}, {"oid": "0556722d983ea5c866863ac93dc91381301226d0", "url": "https://github.com/palantir/atlasdb/commit/0556722d983ea5c866863ac93dc91381301226d0", "message": "even more failed checks", "committedDate": "2020-05-29T09:36:09Z", "type": "commit"}, {"oid": "1261e59e5b6b4c9c62618285b6276cd7c036781c", "url": "https://github.com/palantir/atlasdb/commit/1261e59e5b6b4c9c62618285b6276cd7c036781c", "message": "fix commit lock token thing", "committedDate": "2020-05-29T10:11:04Z", "type": "commit"}, {"oid": "88836daa2356491bff2fac2096203e69d5385de8", "url": "https://github.com/palantir/atlasdb/commit/88836daa2356491bff2fac2096203e69d5385de8", "message": "beefy changes", "committedDate": "2020-05-29T13:19:18Z", "type": "commit"}, {"oid": "835101227becd445d249c49c2c014c99e65a8bd1", "url": "https://github.com/palantir/atlasdb/commit/835101227becd445d249c49c2c014c99e65a8bd1", "message": "remove incorrect json serialisation", "committedDate": "2020-05-29T13:20:29Z", "type": "commit"}, {"oid": "340ba337e8509e174e22a0c4e60692d419ca5de4", "url": "https://github.com/palantir/atlasdb/commit/340ba337e8509e174e22a0c4e60692d419ca5de4", "message": "more cleanup throughout", "committedDate": "2020-05-29T13:26:01Z", "type": "commit"}, {"oid": "284148ab7122d3c7363d3ad9373882cd59d6c1f1", "url": "https://github.com/palantir/atlasdb/commit/284148ab7122d3c7363d3ad9373882cd59d6c1f1", "message": "resolve build errors", "committedDate": "2020-05-29T13:47:53Z", "type": "commit"}, {"oid": "7c44d324231b65e9def980db96cd2740f86e8f13", "url": "https://github.com/palantir/atlasdb/commit/7c44d324231b65e9def980db96cd2740f86e8f13", "message": "add more tests", "committedDate": "2020-05-29T14:10:06Z", "type": "commit"}, {"oid": "c1d4b59b0627bc567dae341d6672d02013bab272", "url": "https://github.com/palantir/atlasdb/commit/c1d4b59b0627bc567dae341d6672d02013bab272", "message": "remove unused line", "committedDate": "2020-05-29T14:10:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUwODYwMw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r432508603", "bodyText": "This is a dodgy diff, as I moved the location of some of these files (lock-api-objects doesn't have tests, whereas lock-api does).", "author": "Jolyon-S", "createdAt": "2020-05-29T14:11:29Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLog.java", "diffHunk": "@@ -19,10 +19,12 @@\n import java.util.Optional;\n import java.util.Set;\n \n-public interface LockWatchEventCache {\n-    Optional<IdentifiedVersion> lastKnownVersion();\n-    IdentifiedVersion processStartTransactionsUpdate(Set<Long> startTimestamps, LockWatchStateUpdate update);\n-    void processUpdate(LockWatchStateUpdate update);\n-    TransactionsLockWatchEvents getEventsForTransactions(Set<Long> startTimestamps,\n-            Optional<IdentifiedVersion> version);\n+import com.palantir.lock.LockDescriptor;\n+\n+public interface ClientLockWatchEventLog {", "originalCommit": "c1d4b59b0627bc567dae341d6672d02013bab272", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a73341d3312e837debe4147c49b0b954e43de9a7", "url": "https://github.com/palantir/atlasdb/commit/a73341d3312e837debe4147c49b0b954e43de9a7", "message": "slight refactor", "committedDate": "2020-05-29T14:13:02Z", "type": "commit"}, {"oid": "6e9c87fce5fc64267d88def40a2eb95409554be0", "url": "https://github.com/palantir/atlasdb/commit/6e9c87fce5fc64267d88def40a2eb95409554be0", "message": "change to google error prone", "committedDate": "2020-05-29T14:42:32Z", "type": "commit"}, {"oid": "4dc51f725e1b0c63252579b16432b8e6c0f6874f", "url": "https://github.com/palantir/atlasdb/commit/4dc51f725e1b0c63252579b16432b8e6c0f6874f", "message": "slap synchronised on everything", "committedDate": "2020-05-29T15:28:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExODI2Mg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433118262", "bodyText": "I'm just wondering if this map should actually be on both results of this class, or if we even need a union here, and here is why:\nThe client of Atlas may receive a snapshot because their version is too old, but the version that each transaction holds is definitely not too old (by the definition of our cache system). Therefore, it surely makes sense that we can return a snapshot that resets the cache state, along with all the events that have happened between that snapshot and the latest version in the timestamp map. This would mean that the only difference between success and failure is that failure contains a snapshot also. Since a snapshot is essentially just a LockWatchCreatedEvent, this would mean that we could condense this interface to have a single return type, but with a boolean flag of whether the cache needs to be reset or not.\n@jkozlowski @j-baker thoughts? This would make more sense with the Atlasdb-proxy implementation too (simplifying the types and so forth).", "author": "Jolyon-S", "createdAt": "2020-06-01T08:55:33Z", "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/TransactionsLockWatchEvents.java", "diffHunk": "@@ -50,7 +50,7 @@ static ForcedSnapshot failure(LockWatchStateUpdate.Snapshot snapshot) {\n         @Value.Parameter\n         List<LockWatchEvent> events();\n         @Value.Parameter\n-        Map<Long, Long> startTsToSequence();\n+        Map<Long, IdentifiedVersion> startTsToSequence();", "originalCommit": "4dc51f725e1b0c63252579b16432b8e6c0f6874f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzNTI5Nw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433135297", "bodyText": "Chatted with @jkozlowski offline, and we think it's the right thing to do. Will change that now.", "author": "Jolyon-S", "createdAt": "2020-06-01T09:34:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExODI2Mg=="}], "type": "inlineReview"}, {"oid": "efe1d31a1a9c216c0356abee6c0aa7625d11cbd2", "url": "https://github.com/palantir/atlasdb/commit/efe1d31a1a9c216c0356abee6c0aa7625d11cbd2", "message": "rework to use non-union type", "committedDate": "2020-06-01T09:53:10Z", "type": "commit"}, {"oid": "6849606524d53a774c1f5eba200f2b19432f059d", "url": "https://github.com/palantir/atlasdb/commit/6849606524d53a774c1f5eba200f2b19432f059d", "message": "fix tests and remove unused type", "committedDate": "2020-06-01T09:57:10Z", "type": "commit"}, {"oid": "d1ff70c3cf945302f53751102fc57788d4ac0d87", "url": "https://github.com/palantir/atlasdb/commit/d1ff70c3cf945302f53751102fc57788d4ac0d87", "message": "initial merge with dev", "committedDate": "2020-06-02T09:36:49Z", "type": "commit"}, {"oid": "1a5bb751dc1cd22f3de3e54d4d4f7b957c3e2ed7", "url": "https://github.com/palantir/atlasdb/commit/1a5bb751dc1cd22f3de3e54d4d4f7b957c3e2ed7", "message": "more cleanup of diff", "committedDate": "2020-06-02T09:44:19Z", "type": "commit"}, {"oid": "56f1b254872e82c4bb06fb57be30046727261d8e", "url": "https://github.com/palantir/atlasdb/commit/56f1b254872e82c4bb06fb57be30046727261d8e", "message": "fix test", "committedDate": "2020-06-02T09:46:03Z", "type": "commit"}, {"oid": "b48150debb67cfd5d28a2d740ee5ec8edf928913", "url": "https://github.com/palantir/atlasdb/commit/b48150debb67cfd5d28a2d740ee5ec8edf928913", "message": "Add generated changelog entries", "committedDate": "2020-06-02T09:46:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1NTY4OQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433755689", "bodyText": "As per James' comment, would like to rename this (in this PR or another).\nAny thoughts to a good name?", "author": "Jolyon-S", "createdAt": "2020-06-02T09:49:26Z", "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/IdentifiedVersion.java", "diffHunk": "@@ -16,14 +16,28 @@\n \n package com.palantir.lock.watch;\n \n+import java.util.Comparator;\n import java.util.UUID;\n \n import org.immutables.value.Value;\n \n+import com.palantir.logsafe.Preconditions;\n+\n @Value.Immutable\n public interface IdentifiedVersion {", "originalCommit": "b48150debb67cfd5d28a2d740ee5ec8edf928913", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgyNjc3OA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433826778", "bodyText": "Let's worry about it for another PR.", "author": "jkozlowski", "createdAt": "2020-06-02T12:09:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1NTY4OQ=="}], "type": "inlineReview"}, {"oid": "0361d428227311875d543d2e51269de0868faf83", "url": "https://github.com/palantir/atlasdb/commit/0361d428227311875d543d2e51269de0868faf83", "message": "remove extraneous guarded by annotations", "committedDate": "2020-06-02T09:50:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1ODMwNQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433758305", "bodyText": "Diff is strange - should be same as previous LockWatchEventCache (with added javadoc)", "author": "Jolyon-S", "createdAt": "2020-06-02T09:54:05Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCache.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public interface LockWatchEventCache {", "originalCommit": "b48150debb67cfd5d28a2d740ee5ec8edf928913", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgyNjk3Mg==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433826972", "bodyText": "Strange indeed.", "author": "jkozlowski", "createdAt": "2020-06-02T12:10:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1ODMwNQ=="}], "type": "inlineReview"}, {"oid": "cf1a4862768ee204515b8992c7b727f4c66695cc", "url": "https://github.com/palantir/atlasdb/commit/cf1a4862768ee204515b8992c7b727f4c66695cc", "message": "remove notes on concurrency", "committedDate": "2020-06-02T09:54:32Z", "type": "commit"}, {"oid": "dad59559662a1f18b8ad05e3c8bb21d059d6f8cf", "url": "https://github.com/palantir/atlasdb/commit/dad59559662a1f18b8ad05e3c8bb21d059d6f8cf", "message": "Merge branch 'lw-client-cache-ete' of github.com:palantir/atlasdb into lw-client-cache-ete", "committedDate": "2020-06-02T09:54:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc2MDI0NA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433760244", "bodyText": "Will only be empty on case of failure as an update.", "author": "Jolyon-S", "createdAt": "2020-06-02T09:57:32Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final HashMap<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    @GuardedBy(\"this\")\n+    private boolean failed = false;\n+\n+\n+    private LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+    }\n+\n+    public static LockWatchEventCacheImpl create() {\n+        return create(ClientLockWatchEventLogImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventCacheImpl create(ClientLockWatchEventLog eventLog) {\n+        return new LockWatchEventCacheImpl(eventLog);\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public synchronized void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        ensureNotFailed(() -> {\n+            Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+            latestVersion.ifPresent(", "originalCommit": "dad59559662a1f18b8ad05e3c8bb21d059d6f8cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc2MzQ5OA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433763498", "bodyText": "This, getCommitUpdate, and getEventsForTransactions can all fail (and indeed, throw) if a leader election occurs between the start and end of the transaction. Presumably, this is the correct behaviour, but that does require the callers to catch these cases.\nOpen to ideas for alternatives. getCommitUpdate should probably invalidateAll, this method should maybe not fail (it's only used for getCommitUpdate), but not sure about what we should do for getEventsForTransactions, given that it is intended to be called outside Atlas.", "author": "Jolyon-S", "createdAt": "2020-06-02T10:03:23Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final HashMap<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    @GuardedBy(\"this\")\n+    private boolean failed = false;\n+\n+\n+    private LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+    }\n+\n+    public static LockWatchEventCacheImpl create() {\n+        return create(ClientLockWatchEventLogImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventCacheImpl create(ClientLockWatchEventLog eventLog) {\n+        return new LockWatchEventCacheImpl(eventLog);\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public synchronized void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        ensureNotFailed(() -> {\n+            Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+            latestVersion.ifPresent(\n+                    version -> startTimestamps.forEach(timestamp -> {\n+                        timestampMap.put(timestamp, MapEntry.of(version));\n+                        aliveVersions.put(version, timestamp);\n+                    }));\n+        });\n+    }\n+\n+    @Override\n+    public synchronized void processGetCommitTimestampsUpdate(\n+            Collection<TransactionUpdate> transactionUpdates,\n+            LockWatchStateUpdate update) {\n+        ensureNotFailed(() -> {\n+            Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+            latestVersion.ifPresent(version ->\n+                    transactionUpdates.forEach(transactionUpdate -> {\n+                        MapEntry previousEntry = timestampMap.get(transactionUpdate.startTs());\n+                        Preconditions.checkNotNull(previousEntry, \"Start timestamp missing from cache\");", "originalCommit": "dad59559662a1f18b8ad05e3c8bb21d059d6f8cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1OTAzOQ==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433859039", "bodyText": "As per my other comment, let's review this carefully because a lot of cases you need to recover from by retrying the transactions, so we can't throw Illegal(State|Argument) exceptions.", "author": "jkozlowski", "createdAt": "2020-06-02T13:05:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc2MzQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg2Mzg0Mw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433863843", "bodyText": "Yeah, I agree.", "author": "Jolyon-S", "createdAt": "2020-06-02T13:13:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc2MzQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5NzAzMA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433897030", "bodyText": "ARGH\ncyclic dependency if I want to use TransactionFailedRetriableException as atlasdb-api depends on lock-api, and we would need to depend on atlasdb-api to get access to TransactionFailedRetriableException...", "author": "Jolyon-S", "createdAt": "2020-06-02T13:59:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc2MzQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyMzc3OA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433923778", "bodyText": "I have a work around but it's not super nice.", "author": "Jolyon-S", "createdAt": "2020-06-02T14:32:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc2MzQ5OA=="}], "type": "inlineReview"}, {"oid": "b13d3a412d3216057ab2f180bc4ce1806dc117e5", "url": "https://github.com/palantir/atlasdb/commit/b13d3a412d3216057ab2f180bc4ce1806dc117e5", "message": "rename method", "committedDate": "2020-06-02T10:04:28Z", "type": "commit"}, {"oid": "b37f0b3357c7717268efec75c15489a0f74be40a", "url": "https://github.com/palantir/atlasdb/commit/b37f0b3357c7717268efec75c15489a0f74be40a", "message": "wire in cache", "committedDate": "2020-06-02T10:09:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc2NzM2NA==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433767364", "bodyText": "Sanity check: This should be the only place where we need to wire in the real cache over the NoOp one (I checked this by looking at where LockWatchManagerImpl is created, and it appears the only real one is here).", "author": "Jolyon-S", "createdAt": "2020-06-02T10:10:25Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/TransactionManagers.java", "diffHunk": "@@ -1077,7 +1078,7 @@ private static LockAndTimestampServices getLockAndTimestampServices(\n         NamespacedConjureTimelockService namespacedConjureTimelockService\n                 = new NamespacedConjureTimelockService(withDiagnosticsConjureTimelockService, timelockNamespace);\n \n-        LockWatchEventCache lockWatchEventCache = NoOpLockWatchEventCache.INSTANCE;\n+        LockWatchEventCache lockWatchEventCache = LockWatchEventCacheImpl.create();", "originalCommit": "b37f0b3357c7717268efec75c15489a0f74be40a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgyMjE0Mw==", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433822143", "bodyText": "Yep.", "author": "jkozlowski", "createdAt": "2020-06-02T12:00:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc2NzM2NA=="}], "type": "inlineReview"}]}