{"pr_number": 4723, "pr_title": "Use refreshable for runtime config", "pr_createdAt": "2020-04-21T11:54:04Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4723", "timeline": [{"oid": "ed5dcc416d407bf21a1698af446c936889af202e", "url": "https://github.com/palantir/atlasdb/commit/ed5dcc416d407bf21a1698af446c936889af202e", "message": "Mostly there.", "committedDate": "2020-04-21T11:52:52Z", "type": "commit"}, {"oid": "0ca655051704ae32280bcc3c5493f05509c8de27", "url": "https://github.com/palantir/atlasdb/commit/0ca655051704ae32280bcc3c5493f05509c8de27", "message": "Fix", "committedDate": "2020-04-21T11:57:08Z", "type": "commit"}, {"oid": "ec50f30351e1fa17835d70dabd6bde561e01beb6", "url": "https://github.com/palantir/atlasdb/commit/ec50f30351e1fa17835d70dabd6bde561e01beb6", "message": "Fixup", "committedDate": "2020-04-21T11:59:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjEyMTgxNg==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412121816", "bodyText": "This isn't ideal, but if this occurs the application is doing something really rather bad.", "author": "jkozlowski", "createdAt": "2020-04-21T12:00:00Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/ConfigRefreshable.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.factory;\n+\n+\n+import java.time.Duration;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.palantir.atlasdb.config.AtlasDbRuntimeConfig;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+import com.palantir.refreshable.DefaultRefreshable;\n+import com.palantir.refreshable.Refreshable;\n+\n+final class ConfigRefreshable implements AutoCloseable {\n+\n+    private static final Logger log = LoggerFactory.getLogger(ConfigRefreshable.class);\n+    private static final Duration REFRESH_INTERVAL = Duration.ofSeconds(1);\n+\n+    private final Refreshable<Optional<AtlasDbRuntimeConfig>> delegate;\n+    private final Runnable closer;\n+\n+    private ConfigRefreshable(\n+            Refreshable<Optional<AtlasDbRuntimeConfig>> delegate,\n+            Runnable closer) {\n+        this.delegate = delegate;\n+        this.closer = closer;\n+    }\n+\n+    public Refreshable<Optional<AtlasDbRuntimeConfig>> refreshable() {\n+        return delegate;\n+    }\n+\n+    @Override\n+    public void close() {\n+        closer.run();\n+    }\n+\n+    static ConfigRefreshable wrap(Refreshable<Optional<AtlasDbRuntimeConfig>> delegate) {\n+        return new ConfigRefreshable(delegate, () -> {});\n+    }\n+\n+    @SuppressWarnings(\"FutureReturnValueIgnored\")\n+    static ConfigRefreshable createPolling(Supplier<Optional<AtlasDbRuntimeConfig>> config) {\n+        DefaultRefreshable<Optional<AtlasDbRuntimeConfig>> refreshable = new DefaultRefreshable<>(call(config));\n+\n+        ScheduledExecutorService executor = PTExecutors.newSingleThreadScheduledExecutor();\n+        executor.scheduleWithFixedDelay(\n+                () -> {\n+                    try {\n+                        refreshable.update(config.get());\n+                    } catch (Throwable e) {\n+                        // This should not occur in practice", "originalCommit": "ec50f30351e1fa17835d70dabd6bde561e01beb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxMjE3Nw==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412512177", "bodyText": "Or we are really.", "author": "jkozlowski", "createdAt": "2020-04-21T21:43:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjEyMTgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjEyMjQ5Nw==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412122497", "bodyText": "This change should be fine, the autogenerated immutables class should still have the same #runtimeConfigSupplier(Supplier) method, so should not be a break for users.", "author": "jkozlowski", "createdAt": "2020-04-21T12:01:06Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/TransactionManagers.java", "diffHunk": "@@ -202,10 +202,13 @@\n \n     abstract AtlasDbConfig config();\n \n-    @Value.Default\n-    Supplier<Optional<AtlasDbRuntimeConfig>> runtimeConfigSupplier() {\n-        return Optional::empty;\n-    }\n+    abstract Optional<Refreshable<Optional<AtlasDbRuntimeConfig>>> runtimeConfig();\n+\n+    /**\n+     * @deprecated use {@link #runtimeConfig} instead.\n+     */\n+    @Deprecated\n+    abstract Optional<Supplier<Optional<AtlasDbRuntimeConfig>>> runtimeConfigSupplier();", "originalCommit": "ec50f30351e1fa17835d70dabd6bde561e01beb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjEzMTQwMQ==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412131401", "bodyText": "See test in TransactionManagers I added, it's using this method.", "author": "jkozlowski", "createdAt": "2020-04-21T12:15:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjEyMjQ5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ2MTk2MQ==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412461961", "bodyText": "I guess my bigger concern is if someone calls txMgr.runtimeConfigSupplier() though a code search suggests that no one does so.\nIf someone did (especially if that someone is one of our friendly supporting libs) that would be a spicy break \ud83d\udd25but thankfully looks like that's not the case.", "author": "jeremyk-91", "createdAt": "2020-04-21T20:16:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjEyMjQ5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwNjg2MA==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412506860", "bodyText": "Hmmm, I don't think runtimeConfigSupplier() would've compiled before? immutables shouldn't generate it, it only generates them when the type is Optional of something.", "author": "jkozlowski", "createdAt": "2020-04-21T21:33:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjEyMjQ5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjEyMjg0Mg==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412122842", "bodyText": "This maintains the current setup, where it's possible to not provide the runtime config (used for InMemory configuration).", "author": "jkozlowski", "createdAt": "2020-04-21T12:01:34Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/TransactionManagers.java", "diffHunk": "@@ -279,6 +282,12 @@ LockWatchingCache lockWatchingCache() {\n         thread.start();\n     };\n \n+    @Value.Check\n+    protected void check() {\n+        Preconditions.checkState(!(runtimeConfigSupplier().isPresent() && runtimeConfig().isPresent()),\n+                \"Either Refreshable or Supplier of runtime config must be provided or none, but not both\");", "originalCommit": "ec50f30351e1fa17835d70dabd6bde561e01beb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ2MjMyOA==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412462328", "bodyText": "nit: probably enough to just say Cannot provide both Refreshable and Supplier of runtime config?", "author": "jeremyk-91", "createdAt": "2020-04-21T20:17:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjEyMjg0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxMTkzNA==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412511934", "bodyText": "Done", "author": "jkozlowski", "createdAt": "2020-04-21T21:42:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjEyMjg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjEyMzQyOA==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412123428", "bodyText": "I removed all uses of Suppliers.compose in this class.", "author": "jkozlowski", "createdAt": "2020-04-21T12:02:34Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/TransactionManagers.java", "diffHunk": "@@ -375,11 +388,11 @@ private TransactionManager serializableInternal(@Output List<AutoCloseable> clos\n \n             // Even if sweep queue writes are enabled, unless targeted sweep is enabled we generally still want to\n             // at least retain the option to perform background sweep, which requires updating the priority table.\n-            if (!targetedSweepIsFullyEnabled()) {\n+            if (!targetedSweepIsFullyEnabled(config(), runtime)) {\n                 kvs = SweepStatsKeyValueService.create(kvs,\n                         new TimelockTimestampServiceAdapter(lockAndTimestampServices.timelock()),\n-                        Suppliers.compose(SweepConfig::writeThreshold, sweepConfig::get),\n-                        Suppliers.compose(SweepConfig::writeSizeThreshold, sweepConfig::get)\n+                        sweepConfig.map(SweepConfig::writeThreshold),", "originalCommit": "ec50f30351e1fa17835d70dabd6bde561e01beb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a2047fbd0aee4fcbbe92eb834713dd2308f1edb6", "url": "https://github.com/palantir/atlasdb/commit/a2047fbd0aee4fcbbe92eb834713dd2308f1edb6", "message": "Fixup", "committedDate": "2020-04-21T12:11:56Z", "type": "commit"}, {"oid": "f505a26164f3c3cba32420b1986f34e3345ef53e", "url": "https://github.com/palantir/atlasdb/commit/f505a26164f3c3cba32420b1986f34e3345ef53e", "message": "Fixup", "committedDate": "2020-04-21T12:12:11Z", "type": "commit"}, {"oid": "bc02955babc7055a937b95ea95bc9c5dd1821b50", "url": "https://github.com/palantir/atlasdb/commit/bc02955babc7055a937b95ea95bc9c5dd1821b50", "message": "Fixup", "committedDate": "2020-04-21T12:30:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI2NTE3MQ==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412265171", "bodyText": "Seems kinda odd to wrap the refreshable in this way. I think it was expose a way to convert a supplier to an optional using some executor, and handle the lifecycle of the executor seperately", "author": "ferozco", "createdAt": "2020-04-21T15:03:10Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/ConfigRefreshable.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.factory;\n+\n+\n+import java.time.Duration;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.palantir.atlasdb.config.AtlasDbRuntimeConfig;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+import com.palantir.refreshable.DefaultRefreshable;\n+import com.palantir.refreshable.Refreshable;\n+\n+final class ConfigRefreshable implements AutoCloseable {\n+\n+    private static final Logger log = LoggerFactory.getLogger(ConfigRefreshable.class);\n+    private static final Duration REFRESH_INTERVAL = Duration.ofSeconds(1);\n+\n+    private final Refreshable<Optional<AtlasDbRuntimeConfig>> delegate;\n+    private final Runnable closer;\n+\n+    private ConfigRefreshable(\n+            Refreshable<Optional<AtlasDbRuntimeConfig>> delegate,\n+            Runnable closer) {\n+        this.delegate = delegate;\n+        this.closer = closer;\n+    }\n+\n+    public Refreshable<Optional<AtlasDbRuntimeConfig>> refreshable() {\n+        return delegate;\n+    }\n+\n+    @Override\n+    public void close() {\n+        closer.run();\n+    }\n+\n+    static ConfigRefreshable wrap(Refreshable<Optional<AtlasDbRuntimeConfig>> delegate) {", "originalCommit": "bc02955babc7055a937b95ea95bc9c5dd1821b50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMzMDYxMA==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412330610", "bodyText": "Can you explain a bit more? I don\u2019t quite understand the suggested solution", "author": "jkozlowski", "createdAt": "2020-04-21T17:00:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI2NTE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM2NTM2OQ==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412365369", "bodyText": "The suggestion is to just get rid of the extra level of abstraction and manage the lifecycle of the executor used to update the refreshables separately. This is especially beneficial since it allows you to reuse the executor across refreshables and allows you to avoid unnecessarily wrapping existing refreshables.\nHence:\nConfigRefreshable<T> config1 = ConfigRefreshable.createPolling(mySupplier1);\nConfigRefreshable<T> config2 = ConfigRefreshable.createPolling(mySupplier2);\n...\n\nconfig1.close();\nconfig2.close();\n\nbecomes:\nScheduledExecutorService refreshableExecutor = PTExecutors.newSingleThreadScheduledExecutor();\n\nRefreshable<T> config1 = Refreshables.create(mySupplier1, refreshableExecutor);\nRefreshable<T> config2 = Refreshables.create(mySupplier2, refreshableExecutor);\n...\n\nrefreshableExecutor.shutdown()", "author": "ferozco", "createdAt": "2020-04-21T17:49:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI2NTE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQwMzg4NQ==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412403885", "bodyText": "I don\u2019t expect to be using refreshables anywhere else. Handling this separately in TransactionManagers will be messy, because you don\u2019t create the executor if someone provides the Refreshable. I can see what it would look like though", "author": "jkozlowski", "createdAt": "2020-04-21T18:45:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI2NTE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzNzUxNA==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412437514", "bodyText": "So I tried to come up with something that's not messy and I can't: the fact that you only sometimes create the executor, and then you need to add it to the closeables list AND THEN, but only after TransactionManager is created, call #shutdownCallbacks with it makes me not want to do it.\nThis is actually a nice small abstraction of a closeable refreshable, and everything falls through nicely.", "author": "jkozlowski", "createdAt": "2020-04-21T19:37:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI2NTE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzODIyNg==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412438226", "bodyText": "Instead, I don't expose any special wrap methods, but instead the only way to create this special refreshable is from the TransactionManagers builder.", "author": "jkozlowski", "createdAt": "2020-04-21T19:38:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI2NTE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzOTgxOQ==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412439819", "bodyText": "And if we excavate this so we can remove the deprecated method, we'll just remove all this code.", "author": "jkozlowski", "createdAt": "2020-04-21T19:41:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI2NTE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0MDgzMA==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412440830", "bodyText": "sure, whatever you're happy with", "author": "ferozco", "createdAt": "2020-04-21T19:42:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI2NTE3MQ=="}], "type": "inlineReview"}, {"oid": "080237ad7c5663ced2d176b4bb6c03aab5475e69", "url": "https://github.com/palantir/atlasdb/commit/080237ad7c5663ced2d176b4bb6c03aab5475e69", "message": "Better shutdown.", "committedDate": "2020-04-21T19:19:30Z", "type": "commit"}, {"oid": "495c0afa18d5726b053e0886a7425cec7fccaa32", "url": "https://github.com/palantir/atlasdb/commit/495c0afa18d5726b053e0886a7425cec7fccaa32", "message": "Tighten the impl, don't expose unnecessary things.", "committedDate": "2020-04-21T19:35:02Z", "type": "commit"}, {"oid": "f481f13e73c7768a26df544668a386734364d801", "url": "https://github.com/palantir/atlasdb/commit/f481f13e73c7768a26df544668a386734364d801", "message": "Add generated changelog entries", "committedDate": "2020-04-21T19:35:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0Mzc0Mg==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412443742", "bodyText": "Famous last words: the danger here is that we write some sort of weird update code (since DefaultRefreshable.update propagates to all the children) and this throws, and we won't find out about it. This is a bit of a change in behavior, but I don't feel strongly that this is such high risk.", "author": "jkozlowski", "createdAt": "2020-04-21T19:47:16Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/AtlasDbRuntimeConfigRefreshable.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.factory;\n+\n+\n+import java.time.Duration;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.palantir.atlasdb.config.AtlasDbRuntimeConfig;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+import com.palantir.refreshable.DefaultRefreshable;\n+import com.palantir.refreshable.Refreshable;\n+\n+final class AtlasDbRuntimeConfigRefreshable implements AutoCloseable {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AtlasDbRuntimeConfigRefreshable.class);\n+    private static final Duration REFRESH_INTERVAL = Duration.ofSeconds(1);\n+    private static final Duration GRACEFUL_SHUTDOWN = Duration.ofSeconds(5);\n+    private static final AtlasDbRuntimeConfig DEFAULT_RUNTIME = AtlasDbRuntimeConfig.defaultRuntimeConfig();\n+\n+    private final Refreshable<AtlasDbRuntimeConfig> delegate;\n+    private final Runnable closer;\n+\n+    private AtlasDbRuntimeConfigRefreshable(\n+            Refreshable<Optional<AtlasDbRuntimeConfig>> delegate,\n+            Runnable closer) {\n+        this.delegate = delegate.map(config -> config.orElse(DEFAULT_RUNTIME));\n+        this.closer = closer;\n+    }\n+\n+    public Refreshable<AtlasDbRuntimeConfig> config() {\n+        return delegate;\n+    }\n+\n+    @Override\n+    public void close() {\n+        closer.run();\n+    }\n+\n+    static AtlasDbRuntimeConfigRefreshable create(TransactionManagers builder) {\n+        return builder.runtimeConfig()\n+                .map(AtlasDbRuntimeConfigRefreshable::wrap)\n+                .orElseGet(() -> {\n+                    Supplier<Optional<AtlasDbRuntimeConfig>> runtimeConfig = builder.runtimeConfigSupplier()\n+                            .orElse(Optional::empty);\n+                    return AtlasDbRuntimeConfigRefreshable.createPolling(runtimeConfig);\n+                });\n+    }\n+\n+    private static AtlasDbRuntimeConfigRefreshable wrap(Refreshable<Optional<AtlasDbRuntimeConfig>> delegate) {\n+        return new AtlasDbRuntimeConfigRefreshable(delegate, () -> {\n+        });\n+    }\n+\n+    @SuppressWarnings(\"FutureReturnValueIgnored\")\n+    private static AtlasDbRuntimeConfigRefreshable createPolling(Supplier<Optional<AtlasDbRuntimeConfig>> config) {\n+        DefaultRefreshable<Optional<AtlasDbRuntimeConfig>> refreshable = new DefaultRefreshable<>(call(config));\n+\n+        ScheduledExecutorService executor = PTExecutors.newSingleThreadScheduledExecutor();\n+        executor.scheduleWithFixedDelay(\n+                () -> {\n+                    try {\n+                        refreshable.update(config.get());\n+                    } catch (Throwable e) {\n+                        // This should not occur in practice", "originalCommit": "f481f13e73c7768a26df544668a386734364d801", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3MjA4Ng==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412472086", "bodyText": "Not sure I follow: do we mean a subscriber? If a subscriber throws it does look like the world could be in an inconsistent state, but right now I think we're fine", "author": "jeremyk-91", "createdAt": "2020-04-21T20:33:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0Mzc0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwNzYzOA==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412507638", "bodyText": "Yes, I mean that Refreshables remember everyone who called #map on them and propagate the updates. Yes you could be in an inconsistent state, but I think this is by design of refreshables.", "author": "jkozlowski", "createdAt": "2020-04-21T21:34:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0Mzc0Mg=="}], "type": "inlineReview"}, {"oid": "41eedd86888e2e76d5566bdc9e0987770500b77c", "url": "https://github.com/palantir/atlasdb/commit/41eedd86888e2e76d5566bdc9e0987770500b77c", "message": "Message.", "committedDate": "2020-04-21T19:49:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0Mzc4Ng==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412443786", "bodyText": "Is this intentional? Seems strange that we'd deliberately make this not live reload", "author": "jeremyk-91", "createdAt": "2020-04-21T19:47:21Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/debug/TransactionPostMortemRunner.java", "diffHunk": "@@ -69,7 +70,7 @@ public TransactionPostMortemRunner(\n             TransactionManager transactionManager,\n             TableReference tableReference,\n             AtlasDbConfig install,\n-            Supplier<AtlasDbRuntimeConfig> runtime,", "originalCommit": "f481f13e73c7768a26df544668a386734364d801", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxMDA0Nw==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412510047", "bodyText": "This is only instantiated in test code from what I can see? So it didn't make sense to keep it this way, and it was calling ServerListConfigs.parseInstallAndRuntimeConfigs, which now takes a Refreshable.", "author": "jkozlowski", "createdAt": "2020-04-21T21:39:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0Mzc4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxMDIwNw==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412510207", "bodyText": "Ah, nevermind, this is called in an internal product at runtime. Ok, lemme rejig this", "author": "jkozlowski", "createdAt": "2020-04-21T21:39:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0Mzc4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxMTM5Ng==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412511396", "bodyText": "I'll change into Refreshable and we'll need to fixup internal product to do this properly.", "author": "jkozlowski", "createdAt": "2020-04-21T21:41:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0Mzc4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUyNTczMg==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412525732", "bodyText": "Donezo", "author": "jkozlowski", "createdAt": "2020-04-21T22:09:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0Mzc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ2NzcyMg==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412467722", "bodyText": "I think you drive-by fixed a bug here! Previously if you don't specify a runtime config, targeted sweep is enabled in practice, but the check here thinks it is disabled. Now it correctly recognises that targeted sweep is enabled by default.", "author": "jeremyk-91", "createdAt": "2020-04-21T20:26:34Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/TransactionManagers.java", "diffHunk": "@@ -538,9 +550,11 @@ TransactionConfig withConsolidatedGrabImmutableTsLockFlag(TransactionConfig tran\n \n     }\n \n-    private boolean targetedSweepIsFullyEnabled() {\n-        return config().targetedSweep().enableSweepQueueWrites()\n-                && runtimeConfigSupplier().get().map(config -> config.targetedSweep().enabled()).orElse(false);\n+    private static boolean targetedSweepIsFullyEnabled(\n+            AtlasDbConfig installConfig,\n+            Supplier<AtlasDbRuntimeConfig> runtime) {\n+        return installConfig.targetedSweep().enableSweepQueueWrites()\n+                && runtime.get().targetedSweep().enabled();", "originalCommit": "41eedd86888e2e76d5566bdc9e0987770500b77c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwODMyMg==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412508322", "bodyText": "Yep", "author": "jkozlowski", "createdAt": "2020-04-21T21:35:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ2NzcyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ2ODU4Nw==", "url": "https://github.com/palantir/atlasdb/pull/4723#discussion_r412468587", "bodyText": "nit: I'd prefer warn, this is probably not super actionable for us?", "author": "jeremyk-91", "createdAt": "2020-04-21T20:28:03Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/AtlasDbRuntimeConfigRefreshable.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.factory;\n+\n+\n+import java.time.Duration;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.palantir.atlasdb.config.AtlasDbRuntimeConfig;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+import com.palantir.refreshable.DefaultRefreshable;\n+import com.palantir.refreshable.Refreshable;\n+\n+final class AtlasDbRuntimeConfigRefreshable implements AutoCloseable {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AtlasDbRuntimeConfigRefreshable.class);\n+    private static final Duration REFRESH_INTERVAL = Duration.ofSeconds(1);\n+    private static final Duration GRACEFUL_SHUTDOWN = Duration.ofSeconds(5);\n+    private static final AtlasDbRuntimeConfig DEFAULT_RUNTIME = AtlasDbRuntimeConfig.defaultRuntimeConfig();\n+\n+    private final Refreshable<AtlasDbRuntimeConfig> delegate;\n+    private final Runnable closer;\n+\n+    private AtlasDbRuntimeConfigRefreshable(\n+            Refreshable<Optional<AtlasDbRuntimeConfig>> delegate,\n+            Runnable closer) {\n+        this.delegate = delegate.map(config -> config.orElse(DEFAULT_RUNTIME));\n+        this.closer = closer;\n+    }\n+\n+    public Refreshable<AtlasDbRuntimeConfig> config() {\n+        return delegate;\n+    }\n+\n+    @Override\n+    public void close() {\n+        closer.run();\n+    }\n+\n+    static AtlasDbRuntimeConfigRefreshable create(TransactionManagers builder) {\n+        return builder.runtimeConfig()\n+                .map(AtlasDbRuntimeConfigRefreshable::wrap)\n+                .orElseGet(() -> {\n+                    Supplier<Optional<AtlasDbRuntimeConfig>> runtimeConfig = builder.runtimeConfigSupplier()\n+                            .orElse(Optional::empty);\n+                    return AtlasDbRuntimeConfigRefreshable.createPolling(runtimeConfig);\n+                });\n+    }\n+\n+    private static AtlasDbRuntimeConfigRefreshable wrap(Refreshable<Optional<AtlasDbRuntimeConfig>> delegate) {\n+        return new AtlasDbRuntimeConfigRefreshable(delegate, () -> {\n+        });\n+    }\n+\n+    @SuppressWarnings(\"FutureReturnValueIgnored\")\n+    private static AtlasDbRuntimeConfigRefreshable createPolling(Supplier<Optional<AtlasDbRuntimeConfig>> config) {\n+        DefaultRefreshable<Optional<AtlasDbRuntimeConfig>> refreshable = new DefaultRefreshable<>(call(config));\n+\n+        ScheduledExecutorService executor = PTExecutors.newSingleThreadScheduledExecutor();\n+        executor.scheduleWithFixedDelay(\n+                () -> {\n+                    try {\n+                        refreshable.update(config.get());\n+                    } catch (Throwable e) {\n+                        // This should not occur in practice\n+                        log.error(\"Failed to reload runtime config\", e);\n+                    }\n+                },\n+                REFRESH_INTERVAL.toNanos(),\n+                REFRESH_INTERVAL.toNanos(),\n+                TimeUnit.NANOSECONDS);\n+\n+        return new AtlasDbRuntimeConfigRefreshable(refreshable, () -> {\n+            if (!MoreExecutors.shutdownAndAwaitTermination(\n+                    executor, GRACEFUL_SHUTDOWN.toMillis(), TimeUnit.MILLISECONDS)) {\n+                log.error(\"Executor did not terminate within graceful shutdown duration\");", "originalCommit": "41eedd86888e2e76d5566bdc9e0987770500b77c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "12d68ca9b23f0f7eea1c8248adea40476c4b9673", "url": "https://github.com/palantir/atlasdb/commit/12d68ca9b23f0f7eea1c8248adea40476c4b9673", "message": "Nit.", "committedDate": "2020-04-21T21:33:30Z", "type": "commit"}, {"oid": "3841182d3c89561588f82efee84533e28fa7660d", "url": "https://github.com/palantir/atlasdb/commit/3841182d3c89561588f82efee84533e28fa7660d", "message": "Fix", "committedDate": "2020-04-21T21:36:19Z", "type": "commit"}, {"oid": "c42d12635a3cd081732def8ad876f29af1f81a4d", "url": "https://github.com/palantir/atlasdb/commit/c42d12635a3cd081732def8ad876f29af1f81a4d", "message": "Fixup", "committedDate": "2020-04-21T21:42:18Z", "type": "commit"}, {"oid": "1a251a1d90edfa9da9aaa7dde7d685844fc06f25", "url": "https://github.com/palantir/atlasdb/commit/1a251a1d90edfa9da9aaa7dde7d685844fc06f25", "message": "Fixup", "committedDate": "2020-04-21T21:47:18Z", "type": "commit"}]}