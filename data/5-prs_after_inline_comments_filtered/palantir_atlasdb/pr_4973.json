{"pr_number": 4973, "pr_title": "[TS] Auto Tune TS Pause Between Iterations", "pr_createdAt": "2020-09-03T12:21:38Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4973", "timeline": [{"oid": "b1b95daa3b38d82ef3cdaef54144aa3f8c5fd06e", "url": "https://github.com/palantir/atlasdb/commit/b1b95daa3b38d82ef3cdaef54144aa3f8c5fd06e", "message": "Enable autotuning TS pause between iterations", "committedDate": "2020-09-03T11:49:28Z", "type": "commit"}, {"oid": "0ec4ae18f13a34e4ceed81cf4021f0cb12261171", "url": "https://github.com/palantir/atlasdb/commit/0ec4ae18f13a34e4ceed81cf4021f0cb12261171", "message": "A few small fixes", "committedDate": "2020-09-03T12:21:24Z", "type": "commit"}, {"oid": "37e26dce61a143581b5853ea6bd5f3b79707a64d", "url": "https://github.com/palantir/atlasdb/commit/37e26dce61a143581b5853ea6bd5f3b79707a64d", "message": "Add generated changelog entries", "committedDate": "2020-09-03T12:21:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEzODA5NA==", "url": "https://github.com/palantir/atlasdb/pull/4973#discussion_r483138094", "bodyText": "This is pretty nice.", "author": "jeremyk-91", "createdAt": "2020-09-03T17:21:25Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/sweep/queue/SweepDelay.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.sweep.queue;\n+\n+import java.time.Duration;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class SweepDelay {\n+    public static final int BATCH_CELLS_LOW_THRESHOLD = 100;\n+    public static final long MIN_PAUSE_MILLIS = 1;\n+    public static final long MAX_PAUSE_MILLIS = 5000;\n+    public static final long BACKOFF = Duration.ofMinutes(2).toMillis();\n+\n+    private final long initialPause;\n+    private final AtomicLong currentPause;\n+\n+    public SweepDelay(long configPause) {\n+        this.initialPause = Math.min(Math.max(MIN_PAUSE_MILLIS, configPause), MAX_PAUSE_MILLIS);\n+        this.currentPause = new AtomicLong(initialPause);\n+    }\n+\n+    public long getNextPause(SweepIterationResult result) {\n+        return SweepIterationResults.caseOf(result)", "originalCommit": "37e26dce61a143581b5853ea6bd5f3b79707a64d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUwMDMwNw==", "url": "https://github.com/palantir/atlasdb/pull/4973#discussion_r483500307", "bodyText": "\ud83e\udd73", "author": "gmaretic", "createdAt": "2020-09-04T09:25:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEzODA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0MjQxMg==", "url": "https://github.com/palantir/atlasdb/pull/4973#discussion_r483142412", "bodyText": "Something to be aware of (I guess it's fine for now but will affect the next stage of changes): this will spin up numThreads many core threads and core thread timeout is not allowed by the executor returned here, so some changes will be needed when we extend this to cover that.", "author": "jeremyk-91", "createdAt": "2020-09-03T17:29:02Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/sweep/queue/TargetedSweeper.java", "diffHunk": "@@ -229,44 +217,62 @@ private void assertInitialized() {\n         }\n     }\n \n+    private int getPartitionBatchLimit() {\n+        return runtime.get().enableAutoTuning()\n+                ? Integer.MAX_VALUE\n+                : runtime.get().maximumPartitionsToBatchInSingleRead();\n+    }\n+\n     private class BackgroundSweepScheduler implements AutoCloseable {\n         private final int numThreads;\n         private final SweeperStrategy sweepStrategy;\n         private final AtomicLong counter = new AtomicLong(0);\n+        private final SweepDelay delay;\n \n         private ScheduledExecutorService executorService;\n \n         private BackgroundSweepScheduler(int numThreads, SweeperStrategy sweepStrategy) {\n             this.numThreads = numThreads;\n             this.sweepStrategy = sweepStrategy;\n+            this.delay = new SweepDelay(runtime.get().pauseMillis());\n         }\n \n         private void scheduleBackgroundThreads() {\n             if (numThreads > 0 && executorService == null) {\n                 executorService = PTExecutors\n                         .newScheduledThreadPoolExecutor(numThreads, new NamedThreadFactory(\"Targeted Sweep\", true));", "originalCommit": "37e26dce61a143581b5853ea6bd5f3b79707a64d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUwMDY0NQ==", "url": "https://github.com/palantir/atlasdb/pull/4973#discussion_r483500645", "bodyText": "Yeah, once we do task scaling, this is set to 1 instead", "author": "gmaretic", "createdAt": "2020-09-04T09:25:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0MjQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0MzYwNg==", "url": "https://github.com/palantir/atlasdb/pull/4973#discussion_r483143606", "bodyText": "I think you can delete it and put in a JsonIgnoreProperties annotation at the top.", "author": "jeremyk-91", "createdAt": "2020-09-03T17:31:07Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/sweep/queue/config/TargetedSweepRuntimeConfig.java", "diffHunk": "@@ -46,9 +46,10 @@ public int shards() {\n     }\n \n     /**\n-     * If true, we batch many iterations on each shard and strategy upon obtaining the lock. This should lead to\n-     * higher throughput in targeted sweep at the expense of more uneven sweeping across different shards.\n+     * @deprecated This configuration is ignored, use {@link #enableAutoTuning()} or\n+     * {@link #maximumPartitionsToBatchInSingleRead()} instead.\n      */\n+    @Deprecated\n     @Value.Default\n     public boolean batchShardIterations() {", "originalCommit": "37e26dce61a143581b5853ea6bd5f3b79707a64d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0NTExNQ==", "url": "https://github.com/palantir/atlasdb/pull/4973#discussion_r483145115", "bodyText": "would be good to add some documentation on how the self-tuning mechanism works", "author": "jeremyk-91", "createdAt": "2020-09-03T17:34:10Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/sweep/queue/SweepDelay.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.sweep.queue;\n+\n+import java.time.Duration;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class SweepDelay {", "originalCommit": "37e26dce61a143581b5853ea6bd5f3b79707a64d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUwOTA2Ng==", "url": "https://github.com/palantir/atlasdb/pull/4973#discussion_r483509066", "bodyText": "\ud83c\udf96\ufe0f", "author": "gmaretic", "createdAt": "2020-09-04T09:42:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0NTExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0NzMzMg==", "url": "https://github.com/palantir/atlasdb/pull/4973#discussion_r483147332", "bodyText": "I'd question whether we want to place a cap on MAX_PAUSE_MILLIS: it seems a bit unexpected that if the user configures the gap to be 10 seconds for whatever reason we just throw it away. Even if we think that's ok I think it makes sense to fail more aggressively.\nIn other words I'd go for\ninitial = max(min, config)\nmin = 1\nmax = max(5000, config)\n\nNote that if you go this route you may need some special integer mathematics in line 47...", "author": "jeremyk-91", "createdAt": "2020-09-03T17:38:24Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/sweep/queue/SweepDelay.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.sweep.queue;\n+\n+import java.time.Duration;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class SweepDelay {\n+    public static final int BATCH_CELLS_LOW_THRESHOLD = 100;\n+    public static final long MIN_PAUSE_MILLIS = 1;\n+    public static final long MAX_PAUSE_MILLIS = 5000;\n+    public static final long BACKOFF = Duration.ofMinutes(2).toMillis();\n+\n+    private final long initialPause;\n+    private final AtomicLong currentPause;\n+\n+    public SweepDelay(long configPause) {\n+        this.initialPause = Math.min(Math.max(MIN_PAUSE_MILLIS, configPause), MAX_PAUSE_MILLIS);", "originalCommit": "37e26dce61a143581b5853ea6bd5f3b79707a64d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUwODk5NQ==", "url": "https://github.com/palantir/atlasdb/pull/4973#discussion_r483508995", "bodyText": "Makes sense, I now just use it as both initial and max. Do we want to do something like max should always be at least 2 * initial instead?", "author": "gmaretic", "createdAt": "2020-09-04T09:42:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0NzMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0ODMyOQ==", "url": "https://github.com/palantir/atlasdb/pull/4973#discussion_r483148329", "bodyText": "If I'm understanding this correctly this one should read\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertThat(delay.getNextPause(SUCCESS_TOO_FAST)).isGreaterThanOrEqualTo((long) (MIN_PAUSE_MILLIS * 1.05));\n          \n          \n            \n                    assertThat(delay.getNextPause(SUCCESS_TOO_SLOW)).isLessThanOrEqualTo((long) (MIN_PAUSE_MILLIS * 1.05));", "author": "jeremyk-91", "createdAt": "2020-09-03T17:40:15Z", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/sweep/queue/SweepDelayTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.sweep.queue;\n+\n+\n+import static com.palantir.atlasdb.sweep.queue.SweepDelay.BACKOFF;\n+import static com.palantir.atlasdb.sweep.queue.SweepDelay.BATCH_CELLS_LOW_THRESHOLD;\n+import static com.palantir.atlasdb.sweep.queue.SweepDelay.MAX_PAUSE_MILLIS;\n+import static com.palantir.atlasdb.sweep.queue.SweepDelay.MIN_PAUSE_MILLIS;\n+import static com.palantir.atlasdb.sweep.queue.SweepQueueUtils.SWEEP_BATCH_SIZE;\n+import static com.palantir.logsafe.testing.Assertions.assertThat;\n+\n+import org.junit.Test;\n+\n+public class SweepDelayTest {\n+    private static final SweepIterationResult SUCCESS_TOO_FAST = SweepIterationResults.success(1L);\n+    private static final SweepIterationResult SUCCESS_TOO_SLOW = SweepIterationResults.success(SWEEP_BATCH_SIZE);\n+    private static final SweepIterationResult SUCCESS = SweepIterationResults\n+            .success((BATCH_CELLS_LOW_THRESHOLD + SWEEP_BATCH_SIZE) / 2);\n+    private static final long INITIAL_DELAY = 250L;\n+\n+    private SweepDelay delay = new SweepDelay(INITIAL_DELAY);\n+\n+    @Test\n+    public void iterationWithNormalBatchReturnsInitialPause() {\n+        assertThat(delay.getNextPause(SUCCESS)).isEqualTo(INITIAL_DELAY);\n+    }\n+\n+    @Test\n+    public void configurationsOutOfBoundsAreSetAtBounds() {\n+        SweepDelay negativeDelay = new SweepDelay(-5L);\n+        SweepDelay largeDelay = new SweepDelay(10_000_000L);\n+\n+        assertThat(negativeDelay.getNextPause(SUCCESS)).isEqualTo(MIN_PAUSE_MILLIS);\n+        assertThat(largeDelay.getNextPause(SUCCESS)).isEqualTo(MAX_PAUSE_MILLIS);\n+    }\n+\n+    @Test\n+    public void unableToAcquireShardReturnsMaxPause() {\n+        assertThat(delay.getNextPause(SweepIterationResults.unableToAcquireShard())).isEqualTo(MAX_PAUSE_MILLIS);\n+    }\n+\n+    @Test\n+    public void insufficientConsistencyReturnsBackoff() {\n+        assertThat(delay.getNextPause(SweepIterationResults.insufficientConsistency())).isEqualTo(BACKOFF);\n+    }\n+\n+    @Test\n+    public void otherErrorReturnsMaxPause() {\n+        assertThat(delay.getNextPause(SweepIterationResults.otherError())).isEqualTo(MAX_PAUSE_MILLIS);\n+    }\n+\n+    @Test\n+    public void disabledReturnsBackoff() {\n+        assertThat(delay.getNextPause(SweepIterationResults.disabled())).isEqualTo(BACKOFF);\n+    }\n+\n+    @Test\n+    public void iterationWithSmallBatchIncreasesPause() {\n+        assertThat(delay.getNextPause(SUCCESS_TOO_FAST)).isGreaterThan(INITIAL_DELAY);\n+    }\n+\n+    @Test\n+    public void iterationWithFullBatchReducesPause() {\n+        assertThat(delay.getNextPause(SUCCESS_TOO_SLOW)).isLessThan(INITIAL_DELAY);\n+    }\n+\n+    @Test\n+    public void consistentSmallBatchesGravitatesTowardsMaximumPause() {\n+        for (int i = 0; i < 20; i++) {\n+            delay.getNextPause(SUCCESS_TOO_FAST);\n+        }\n+        assertThat(delay.getNextPause(SUCCESS_TOO_FAST)).isGreaterThanOrEqualTo((long) (MAX_PAUSE_MILLIS * 0.95));\n+    }\n+\n+    @Test\n+    public void consistentFullBatchesGravitatesTowardsMinimumPause() {\n+        for (int i = 0; i < 20; i++) {\n+            delay.getNextPause(SUCCESS_TOO_SLOW);\n+        }\n+        assertThat(delay.getNextPause(SUCCESS_TOO_FAST)).isGreaterThanOrEqualTo((long) (MIN_PAUSE_MILLIS * 1.05));", "originalCommit": "37e26dce61a143581b5853ea6bd5f3b79707a64d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUwOTEyOA==", "url": "https://github.com/palantir/atlasdb/pull/4973#discussion_r483509128", "bodyText": "Nice catch!", "author": "gmaretic", "createdAt": "2020-09-04T09:42:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0ODMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0ODYxOQ==", "url": "https://github.com/palantir/atlasdb/pull/4973#discussion_r483148619", "bodyText": "at this point it's probably worth having a sweepTwentyBatchesWithOutcome(long)?", "author": "jeremyk-91", "createdAt": "2020-09-03T17:40:46Z", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/sweep/queue/SweepDelayTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.sweep.queue;\n+\n+\n+import static com.palantir.atlasdb.sweep.queue.SweepDelay.BACKOFF;\n+import static com.palantir.atlasdb.sweep.queue.SweepDelay.BATCH_CELLS_LOW_THRESHOLD;\n+import static com.palantir.atlasdb.sweep.queue.SweepDelay.MAX_PAUSE_MILLIS;\n+import static com.palantir.atlasdb.sweep.queue.SweepDelay.MIN_PAUSE_MILLIS;\n+import static com.palantir.atlasdb.sweep.queue.SweepQueueUtils.SWEEP_BATCH_SIZE;\n+import static com.palantir.logsafe.testing.Assertions.assertThat;\n+\n+import org.junit.Test;\n+\n+public class SweepDelayTest {\n+    private static final SweepIterationResult SUCCESS_TOO_FAST = SweepIterationResults.success(1L);\n+    private static final SweepIterationResult SUCCESS_TOO_SLOW = SweepIterationResults.success(SWEEP_BATCH_SIZE);\n+    private static final SweepIterationResult SUCCESS = SweepIterationResults\n+            .success((BATCH_CELLS_LOW_THRESHOLD + SWEEP_BATCH_SIZE) / 2);\n+    private static final long INITIAL_DELAY = 250L;\n+\n+    private SweepDelay delay = new SweepDelay(INITIAL_DELAY);\n+\n+    @Test\n+    public void iterationWithNormalBatchReturnsInitialPause() {\n+        assertThat(delay.getNextPause(SUCCESS)).isEqualTo(INITIAL_DELAY);\n+    }\n+\n+    @Test\n+    public void configurationsOutOfBoundsAreSetAtBounds() {\n+        SweepDelay negativeDelay = new SweepDelay(-5L);\n+        SweepDelay largeDelay = new SweepDelay(10_000_000L);\n+\n+        assertThat(negativeDelay.getNextPause(SUCCESS)).isEqualTo(MIN_PAUSE_MILLIS);\n+        assertThat(largeDelay.getNextPause(SUCCESS)).isEqualTo(MAX_PAUSE_MILLIS);\n+    }\n+\n+    @Test\n+    public void unableToAcquireShardReturnsMaxPause() {\n+        assertThat(delay.getNextPause(SweepIterationResults.unableToAcquireShard())).isEqualTo(MAX_PAUSE_MILLIS);\n+    }\n+\n+    @Test\n+    public void insufficientConsistencyReturnsBackoff() {\n+        assertThat(delay.getNextPause(SweepIterationResults.insufficientConsistency())).isEqualTo(BACKOFF);\n+    }\n+\n+    @Test\n+    public void otherErrorReturnsMaxPause() {\n+        assertThat(delay.getNextPause(SweepIterationResults.otherError())).isEqualTo(MAX_PAUSE_MILLIS);\n+    }\n+\n+    @Test\n+    public void disabledReturnsBackoff() {\n+        assertThat(delay.getNextPause(SweepIterationResults.disabled())).isEqualTo(BACKOFF);\n+    }\n+\n+    @Test\n+    public void iterationWithSmallBatchIncreasesPause() {\n+        assertThat(delay.getNextPause(SUCCESS_TOO_FAST)).isGreaterThan(INITIAL_DELAY);\n+    }\n+\n+    @Test\n+    public void iterationWithFullBatchReducesPause() {\n+        assertThat(delay.getNextPause(SUCCESS_TOO_SLOW)).isLessThan(INITIAL_DELAY);\n+    }\n+\n+    @Test\n+    public void consistentSmallBatchesGravitatesTowardsMaximumPause() {\n+        for (int i = 0; i < 20; i++) {\n+            delay.getNextPause(SUCCESS_TOO_FAST);\n+        }\n+        assertThat(delay.getNextPause(SUCCESS_TOO_FAST)).isGreaterThanOrEqualTo((long) (MAX_PAUSE_MILLIS * 0.95));\n+    }\n+\n+    @Test\n+    public void consistentFullBatchesGravitatesTowardsMinimumPause() {\n+        for (int i = 0; i < 20; i++) {\n+            delay.getNextPause(SUCCESS_TOO_SLOW);\n+        }\n+        assertThat(delay.getNextPause(SUCCESS_TOO_FAST)).isGreaterThanOrEqualTo((long) (MIN_PAUSE_MILLIS * 1.05));\n+    }\n+\n+    @Test\n+    public void consistentNormalBatchesAfterFullBatchesGravitatesTowardsInitialPause() {\n+        for (int i = 0; i < 20; i++) {\n+            delay.getNextPause(SUCCESS_TOO_SLOW);\n+        }\n+        for (int i = 0; i < 20; i++) {\n+            delay.getNextPause(SUCCESS);\n+        }", "originalCommit": "37e26dce61a143581b5853ea6bd5f3b79707a64d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0ODk1MA==", "url": "https://github.com/palantir/atlasdb/pull/4973#discussion_r483148950", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertThat(nextPause).isGreaterThanOrEqualTo((long) (INITIAL_DELAY * 0.95));\n          \n          \n            \n                    assertThat(nextPause).isLessThanOrEqualTo((long) (INITIAL_DELAY * 1.05));\n          \n          \n            \n                    assertThat(nextPause).isBetween((long) (INITIAL_DELAY * 0.95), (long) (INITIAL_DELAY * 1.05));", "author": "jeremyk-91", "createdAt": "2020-09-03T17:41:32Z", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/sweep/queue/SweepDelayTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.sweep.queue;\n+\n+\n+import static com.palantir.atlasdb.sweep.queue.SweepDelay.BACKOFF;\n+import static com.palantir.atlasdb.sweep.queue.SweepDelay.BATCH_CELLS_LOW_THRESHOLD;\n+import static com.palantir.atlasdb.sweep.queue.SweepDelay.MAX_PAUSE_MILLIS;\n+import static com.palantir.atlasdb.sweep.queue.SweepDelay.MIN_PAUSE_MILLIS;\n+import static com.palantir.atlasdb.sweep.queue.SweepQueueUtils.SWEEP_BATCH_SIZE;\n+import static com.palantir.logsafe.testing.Assertions.assertThat;\n+\n+import org.junit.Test;\n+\n+public class SweepDelayTest {\n+    private static final SweepIterationResult SUCCESS_TOO_FAST = SweepIterationResults.success(1L);\n+    private static final SweepIterationResult SUCCESS_TOO_SLOW = SweepIterationResults.success(SWEEP_BATCH_SIZE);\n+    private static final SweepIterationResult SUCCESS = SweepIterationResults\n+            .success((BATCH_CELLS_LOW_THRESHOLD + SWEEP_BATCH_SIZE) / 2);\n+    private static final long INITIAL_DELAY = 250L;\n+\n+    private SweepDelay delay = new SweepDelay(INITIAL_DELAY);\n+\n+    @Test\n+    public void iterationWithNormalBatchReturnsInitialPause() {\n+        assertThat(delay.getNextPause(SUCCESS)).isEqualTo(INITIAL_DELAY);\n+    }\n+\n+    @Test\n+    public void configurationsOutOfBoundsAreSetAtBounds() {\n+        SweepDelay negativeDelay = new SweepDelay(-5L);\n+        SweepDelay largeDelay = new SweepDelay(10_000_000L);\n+\n+        assertThat(negativeDelay.getNextPause(SUCCESS)).isEqualTo(MIN_PAUSE_MILLIS);\n+        assertThat(largeDelay.getNextPause(SUCCESS)).isEqualTo(MAX_PAUSE_MILLIS);\n+    }\n+\n+    @Test\n+    public void unableToAcquireShardReturnsMaxPause() {\n+        assertThat(delay.getNextPause(SweepIterationResults.unableToAcquireShard())).isEqualTo(MAX_PAUSE_MILLIS);\n+    }\n+\n+    @Test\n+    public void insufficientConsistencyReturnsBackoff() {\n+        assertThat(delay.getNextPause(SweepIterationResults.insufficientConsistency())).isEqualTo(BACKOFF);\n+    }\n+\n+    @Test\n+    public void otherErrorReturnsMaxPause() {\n+        assertThat(delay.getNextPause(SweepIterationResults.otherError())).isEqualTo(MAX_PAUSE_MILLIS);\n+    }\n+\n+    @Test\n+    public void disabledReturnsBackoff() {\n+        assertThat(delay.getNextPause(SweepIterationResults.disabled())).isEqualTo(BACKOFF);\n+    }\n+\n+    @Test\n+    public void iterationWithSmallBatchIncreasesPause() {\n+        assertThat(delay.getNextPause(SUCCESS_TOO_FAST)).isGreaterThan(INITIAL_DELAY);\n+    }\n+\n+    @Test\n+    public void iterationWithFullBatchReducesPause() {\n+        assertThat(delay.getNextPause(SUCCESS_TOO_SLOW)).isLessThan(INITIAL_DELAY);\n+    }\n+\n+    @Test\n+    public void consistentSmallBatchesGravitatesTowardsMaximumPause() {\n+        for (int i = 0; i < 20; i++) {\n+            delay.getNextPause(SUCCESS_TOO_FAST);\n+        }\n+        assertThat(delay.getNextPause(SUCCESS_TOO_FAST)).isGreaterThanOrEqualTo((long) (MAX_PAUSE_MILLIS * 0.95));\n+    }\n+\n+    @Test\n+    public void consistentFullBatchesGravitatesTowardsMinimumPause() {\n+        for (int i = 0; i < 20; i++) {\n+            delay.getNextPause(SUCCESS_TOO_SLOW);\n+        }\n+        assertThat(delay.getNextPause(SUCCESS_TOO_FAST)).isGreaterThanOrEqualTo((long) (MIN_PAUSE_MILLIS * 1.05));\n+    }\n+\n+    @Test\n+    public void consistentNormalBatchesAfterFullBatchesGravitatesTowardsInitialPause() {\n+        for (int i = 0; i < 20; i++) {\n+            delay.getNextPause(SUCCESS_TOO_SLOW);\n+        }\n+        for (int i = 0; i < 20; i++) {\n+            delay.getNextPause(SUCCESS);\n+        }\n+        long nextPause = delay.getNextPause(SUCCESS);\n+        assertThat(nextPause).isGreaterThanOrEqualTo((long) (INITIAL_DELAY * 0.95));\n+        assertThat(nextPause).isLessThanOrEqualTo((long) (INITIAL_DELAY * 1.05));", "originalCommit": "37e26dce61a143581b5853ea6bd5f3b79707a64d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ec85e65689b9d4d3599520776f135f0566af9c7e", "url": "https://github.com/palantir/atlasdb/commit/ec85e65689b9d4d3599520776f135f0566af9c7e", "message": "Addressed CR", "committedDate": "2020-09-04T09:43:56Z", "type": "commit"}, {"oid": "e634135c79533213568dc380cb3e41752c4de520", "url": "https://github.com/palantir/atlasdb/commit/e634135c79533213568dc380cb3e41752c4de520", "message": "Merge branch 'ts/dynamic-pause' of github.com:palantir/atlasdb into ts/dynamic-pause", "committedDate": "2020-09-04T09:44:02Z", "type": "commit"}, {"oid": "5063be63ab076ef9912731c1a7c6b136974def59", "url": "https://github.com/palantir/atlasdb/commit/5063be63ab076ef9912731c1a7c6b136974def59", "message": "Update changelog", "committedDate": "2020-09-04T09:46:24Z", "type": "commit"}, {"oid": "59afe2e0b54ae816321f33c452be739812f5f149", "url": "https://github.com/palantir/atlasdb/commit/59afe2e0b54ae816321f33c452be739812f5f149", "message": "Some more fixes", "committedDate": "2020-09-04T13:14:56Z", "type": "commit"}, {"oid": "d157bf2dcd2f4c6171cb026e603479f8e19d15fd", "url": "https://github.com/palantir/atlasdb/commit/d157bf2dcd2f4c6171cb026e603479f8e19d15fd", "message": "Newlines", "committedDate": "2020-09-04T13:16:32Z", "type": "commit"}]}