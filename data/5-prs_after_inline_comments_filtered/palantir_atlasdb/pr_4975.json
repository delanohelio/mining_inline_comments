{"pr_number": 4975, "pr_title": "[TS] Auto tune number of parallel background tasks", "pr_createdAt": "2020-09-07T09:45:35Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4975", "timeline": [{"oid": "b1b95daa3b38d82ef3cdaef54144aa3f8c5fd06e", "url": "https://github.com/palantir/atlasdb/commit/b1b95daa3b38d82ef3cdaef54144aa3f8c5fd06e", "message": "Enable autotuning TS pause between iterations", "committedDate": "2020-09-03T11:49:28Z", "type": "commit"}, {"oid": "0ec4ae18f13a34e4ceed81cf4021f0cb12261171", "url": "https://github.com/palantir/atlasdb/commit/0ec4ae18f13a34e4ceed81cf4021f0cb12261171", "message": "A few small fixes", "committedDate": "2020-09-03T12:21:24Z", "type": "commit"}, {"oid": "d1ed128df8c24ce372804fde2c70502092c4d4ca", "url": "https://github.com/palantir/atlasdb/commit/d1ed128df8c24ce372804fde2c70502092c4d4ca", "message": "Have to fix failing tests", "committedDate": "2020-09-04T09:23:58Z", "type": "commit"}, {"oid": "4b357b8e87ee317827a2269ec67759559de8d6a1", "url": "https://github.com/palantir/atlasdb/commit/4b357b8e87ee317827a2269ec67759559de8d6a1", "message": "Maintain backwards consistency to fix sensitive tests", "committedDate": "2020-09-04T11:18:52Z", "type": "commit"}, {"oid": "3c3747979436a6a8567cb3060274c85a05ac9581", "url": "https://github.com/palantir/atlasdb/commit/3c3747979436a6a8567cb3060274c85a05ac9581", "message": "Add stress test and some docs", "committedDate": "2020-09-04T11:51:48Z", "type": "commit"}, {"oid": "2586a938325eeda4095597cececc21e16a2c9299", "url": "https://github.com/palantir/atlasdb/commit/2586a938325eeda4095597cececc21e16a2c9299", "message": "Merge with develop", "committedDate": "2020-09-07T08:45:41Z", "type": "commit"}, {"oid": "ebe1a844c100a7a218e889750a5761e190581bdd", "url": "https://github.com/palantir/atlasdb/commit/ebe1a844c100a7a218e889750a5761e190581bdd", "message": "Update javadoc", "committedDate": "2020-09-07T08:48:17Z", "type": "commit"}, {"oid": "0554e448e59dd3f0747218502e46e02590110c16", "url": "https://github.com/palantir/atlasdb/commit/0554e448e59dd3f0747218502e46e02590110c16", "message": "Semantic merge", "committedDate": "2020-09-07T08:53:21Z", "type": "commit"}, {"oid": "2aa7ff0b3e01a54aa1110a3a1311a159104a49c1", "url": "https://github.com/palantir/atlasdb/commit/2aa7ff0b3e01a54aa1110a3a1311a159104a49c1", "message": "Fix semantic merge conflicts", "committedDate": "2020-09-07T08:58:25Z", "type": "commit"}, {"oid": "a7fc39ca3e58a9cfa3fec6d64e3b4fdd5749b6ed", "url": "https://github.com/palantir/atlasdb/commit/a7fc39ca3e58a9cfa3fec6d64e3b4fdd5749b6ed", "message": "Add generated changelog entries", "committedDate": "2020-09-07T08:58:25Z", "type": "commit"}, {"oid": "2a50c017fe38d50a9b51d35c510530c012932436", "url": "https://github.com/palantir/atlasdb/commit/2a50c017fe38d50a9b51d35c510530c012932436", "message": "Fix test and behaviour", "committedDate": "2020-09-07T14:55:59Z", "type": "commit"}, {"oid": "c5b89eb92261f4c0c5ab9b6758eb80ee7b190071", "url": "https://github.com/palantir/atlasdb/commit/c5b89eb92261f4c0c5ab9b6758eb80ee7b190071", "message": "Replace flaky test with nonflaky test", "committedDate": "2020-09-07T21:47:39Z", "type": "commit"}, {"oid": "d16ab2fa420b283a42c3b1a1758cca9c94fbb996", "url": "https://github.com/palantir/atlasdb/commit/d16ab2fa420b283a42c3b1a1758cca9c94fbb996", "message": "Unflake test:", "committedDate": "2020-09-08T08:22:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2OTczOA==", "url": "https://github.com/palantir/atlasdb/pull/4975#discussion_r485169738", "bodyText": "nit: probably just factor out runSweepIterations(iterations) for ticking INITIAL_DELAY + (iterations - 1) * DELAY", "author": "jeremyk-91", "createdAt": "2020-09-08T20:12:22Z", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/sweep/queue/ScalingSweepTaskSchedulerTest.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.sweep.queue;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.atLeast;\n+import static org.mockito.Mockito.atMost;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import static com.palantir.atlasdb.sweep.queue.ScalingSweepTaskScheduler.INITIAL_DELAY;\n+import static com.palantir.logsafe.testing.Assertions.assertThat;\n+\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.common.concurrent.PTExecutors;\n+\n+public class ScalingSweepTaskSchedulerTest {\n+    private static final SweepIterationResult SUCCESS_HUGE = SweepIterationResults\n+            .success(SweepQueueUtils.SWEEP_BATCH_SIZE);\n+    private static final SweepIterationResult SUCCESS_LARGE = SweepIterationResults\n+            .success(ScalingSweepTaskScheduler.BATCH_CELLS_HIGH_THRESHOLD);\n+    private static final SweepIterationResult SUCCESS_MEDIUM = SweepIterationResults\n+            .success(ScalingSweepTaskScheduler.BATCH_CELLS_LOW_THRESHOLD + 1);\n+    private static final SweepIterationResult SUCCESS_SMALL = SweepIterationResults\n+            .success(ScalingSweepTaskScheduler.BATCH_CELLS_LOW_THRESHOLD);\n+    private static final SweepIterationResult SUCCESS_TINY = SweepIterationResults\n+            .success(SweepDelay.BATCH_CELLS_LOW_THRESHOLD);\n+    private static final long DELAY = 1L;\n+    private static final long INITIAL_PAUSE = 5L;\n+\n+    private final DeterministicScheduler deterministicScheduler = new DeterministicScheduler();\n+    private final SweepDelay delay = mock(SweepDelay.class);\n+    private final Callable<SweepIterationResult> sweepIteration = mock(Callable.class);\n+    private final AtomicBoolean schedulerEnabled = new AtomicBoolean(true);\n+    private final ScalingSweepTaskScheduler scheduler = createScheduler(Duration.ZERO);\n+\n+    @Before\n+    public void setup() {\n+        when(delay.getInitialPause()).thenReturn(INITIAL_PAUSE);\n+        when(delay.getNextPause(any(SweepIterationResult.class))).thenReturn(DELAY);\n+    }\n+\n+    @Test\n+    public void whenExpectedNumberOfEntriesIsSweptKeepReschedulingAfterDelay() throws Exception {\n+        when(sweepIteration.call()).thenReturn(SUCCESS_MEDIUM);\n+        scheduler.start(2);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 8 * DELAY, TimeUnit.MILLISECONDS);", "originalCommit": "d16ab2fa420b283a42c3b1a1758cca9c94fbb996", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MDk1Mw==", "url": "https://github.com/palantir/atlasdb/pull/4975#discussion_r485170953", "bodyText": "In general for tests like this one, you might want to tick the ticker a bit less, check that it hadn't retriggered yet, and then tick it to the required value", "author": "jeremyk-91", "createdAt": "2020-09-08T20:14:53Z", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/sweep/queue/ScalingSweepTaskSchedulerTest.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.sweep.queue;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.atLeast;\n+import static org.mockito.Mockito.atMost;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import static com.palantir.atlasdb.sweep.queue.ScalingSweepTaskScheduler.INITIAL_DELAY;\n+import static com.palantir.logsafe.testing.Assertions.assertThat;\n+\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.common.concurrent.PTExecutors;\n+\n+public class ScalingSweepTaskSchedulerTest {\n+    private static final SweepIterationResult SUCCESS_HUGE = SweepIterationResults\n+            .success(SweepQueueUtils.SWEEP_BATCH_SIZE);\n+    private static final SweepIterationResult SUCCESS_LARGE = SweepIterationResults\n+            .success(ScalingSweepTaskScheduler.BATCH_CELLS_HIGH_THRESHOLD);\n+    private static final SweepIterationResult SUCCESS_MEDIUM = SweepIterationResults\n+            .success(ScalingSweepTaskScheduler.BATCH_CELLS_LOW_THRESHOLD + 1);\n+    private static final SweepIterationResult SUCCESS_SMALL = SweepIterationResults\n+            .success(ScalingSweepTaskScheduler.BATCH_CELLS_LOW_THRESHOLD);\n+    private static final SweepIterationResult SUCCESS_TINY = SweepIterationResults\n+            .success(SweepDelay.BATCH_CELLS_LOW_THRESHOLD);\n+    private static final long DELAY = 1L;\n+    private static final long INITIAL_PAUSE = 5L;\n+\n+    private final DeterministicScheduler deterministicScheduler = new DeterministicScheduler();\n+    private final SweepDelay delay = mock(SweepDelay.class);\n+    private final Callable<SweepIterationResult> sweepIteration = mock(Callable.class);\n+    private final AtomicBoolean schedulerEnabled = new AtomicBoolean(true);\n+    private final ScalingSweepTaskScheduler scheduler = createScheduler(Duration.ZERO);\n+\n+    @Before\n+    public void setup() {\n+        when(delay.getInitialPause()).thenReturn(INITIAL_PAUSE);\n+        when(delay.getNextPause(any(SweepIterationResult.class))).thenReturn(DELAY);\n+    }\n+\n+    @Test\n+    public void whenExpectedNumberOfEntriesIsSweptKeepReschedulingAfterDelay() throws Exception {\n+        when(sweepIteration.call()).thenReturn(SUCCESS_MEDIUM);\n+        scheduler.start(2);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 8 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times((1 + 8) * 2)).call();\n+    }\n+\n+    @Test\n+    public void whenScalingDisabledUsesInitialPause() throws Exception {\n+        when(sweepIteration.call()).thenReturn(SUCCESS_MEDIUM);\n+        schedulerEnabled.set(false);\n+        scheduler.start(10);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 7 * INITIAL_PAUSE, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(8 * 10)).call();\n+    }\n+\n+    @Test\n+    public void whenManyEntriesAreSweptNewTaskSpawns() throws Exception {\n+        when(sweepIteration.call()).thenReturn(\n+                SUCCESS_LARGE,\n+                SUCCESS_MEDIUM, SUCCESS_MEDIUM,\n+                SUCCESS_LARGE, SUCCESS_MEDIUM);\n+        scheduler.start(1);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 5 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(1 + 2 + 2 + 3 + 3 + 3)).call();\n+    }\n+\n+    @Test\n+    public void coolDownProtectsAgainstSpawningNewTasks() throws Exception {\n+        ScalingSweepTaskScheduler schedulerWithCoolDown = createScheduler(Duration.ofDays(1));\n+        when(sweepIteration.call()).thenReturn(SUCCESS_LARGE);\n+        schedulerWithCoolDown.start(1);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 5 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(1 + 5)).call();\n+    }\n+\n+    @Test\n+    public void whenFewEntriesAreSweptTasksAreReduced() throws Exception {\n+        when(sweepIteration.call()).thenReturn(SUCCESS_SMALL, SUCCESS_MEDIUM);\n+        scheduler.start(10);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 5 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(10 + 5 * 9)).call();\n+    }\n+\n+    @Test\n+    public void whenFewEntriesDoNotReduceToZeroTasks() throws Exception {\n+        when(sweepIteration.call()).thenReturn(SUCCESS_SMALL);\n+        scheduler.start(1);\n+        deterministicScheduler.tick(INITIAL_DELAY + 5 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(1 + 5)).call();\n+    }\n+\n+    @Test\n+    public void coolDownProtectsAgainstReducingTasks() throws Exception {\n+        ScalingSweepTaskScheduler schedulerWithCoolDown = createScheduler(Duration.ofDays(1));\n+        when(sweepIteration.call()).thenReturn(SUCCESS_SMALL);\n+\n+        schedulerWithCoolDown.start(2);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 5 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(2 + 5 * 2)).call();\n+    }\n+\n+    @Test\n+    public void attemptToIncreaseNumberOfThreadsPreventsReduction() throws Exception {\n+        Duration coolDown = Duration.ofSeconds(1);\n+        ScalingSweepTaskScheduler schedulerWithCoolDown = createScheduler(coolDown);\n+        when(sweepIteration.call()).thenReturn(\n+                SUCCESS_LARGE,\n+                SUCCESS_LARGE,\n+                SUCCESS_SMALL);\n+        schedulerWithCoolDown.start(2);\n+\n+        Uninterruptibles.sleepUninterruptibly(coolDown.toMillis() / 2 + 1, TimeUnit.MILLISECONDS);\n+        deterministicScheduler.tick(INITIAL_DELAY, TimeUnit.MILLISECONDS);\n+\n+        Uninterruptibles.sleepUninterruptibly(coolDown.toMillis() / 2 + 1, TimeUnit.MILLISECONDS);\n+        // these will not reduce the number of threads due to the attempt to increase in previous iterations\n+        deterministicScheduler.tick(2 * DELAY, TimeUnit.MILLISECONDS);\n+\n+        Uninterruptibles.sleepUninterruptibly(coolDown.toMillis() / 2 + 1, TimeUnit.MILLISECONDS);\n+        // the first iteration that gets executed will not reschedule\n+        deterministicScheduler.tick(2 * DELAY, TimeUnit.MILLISECONDS);\n+\n+        verify(sweepIteration, times(2 + 2 * 2 + 2 + 1)).call();\n+    }\n+\n+    @Test\n+    public void whenUnableToAcquireShardOnLastTaskRescheduleAfterMaxPause() throws Exception {\n+        ScalingSweepTaskScheduler schedulerWithRealDelay = createScheduler(new SweepDelay(1L), Duration.ZERO);\n+        when(sweepIteration.call()).thenReturn(SweepIterationResults.unableToAcquireShard(), SUCCESS_MEDIUM);\n+\n+        schedulerWithRealDelay.start(1);\n+        deterministicScheduler.tick(INITIAL_DELAY + SweepDelay.DEFAULT_MAX_PAUSE_MILLIS + 2, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(1 + 3)).call();", "originalCommit": "d16ab2fa420b283a42c3b1a1758cca9c94fbb996", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NDIzMg==", "url": "https://github.com/palantir/atlasdb/pull/4975#discussion_r485174232", "bodyText": "We should be able to avoid this: you can pass in a clock or rather Supplier<Instant> to the scheduler", "author": "jeremyk-91", "createdAt": "2020-09-08T20:21:17Z", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/sweep/queue/ScalingSweepTaskSchedulerTest.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.sweep.queue;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.atLeast;\n+import static org.mockito.Mockito.atMost;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import static com.palantir.atlasdb.sweep.queue.ScalingSweepTaskScheduler.INITIAL_DELAY;\n+import static com.palantir.logsafe.testing.Assertions.assertThat;\n+\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.common.concurrent.PTExecutors;\n+\n+public class ScalingSweepTaskSchedulerTest {\n+    private static final SweepIterationResult SUCCESS_HUGE = SweepIterationResults\n+            .success(SweepQueueUtils.SWEEP_BATCH_SIZE);\n+    private static final SweepIterationResult SUCCESS_LARGE = SweepIterationResults\n+            .success(ScalingSweepTaskScheduler.BATCH_CELLS_HIGH_THRESHOLD);\n+    private static final SweepIterationResult SUCCESS_MEDIUM = SweepIterationResults\n+            .success(ScalingSweepTaskScheduler.BATCH_CELLS_LOW_THRESHOLD + 1);\n+    private static final SweepIterationResult SUCCESS_SMALL = SweepIterationResults\n+            .success(ScalingSweepTaskScheduler.BATCH_CELLS_LOW_THRESHOLD);\n+    private static final SweepIterationResult SUCCESS_TINY = SweepIterationResults\n+            .success(SweepDelay.BATCH_CELLS_LOW_THRESHOLD);\n+    private static final long DELAY = 1L;\n+    private static final long INITIAL_PAUSE = 5L;\n+\n+    private final DeterministicScheduler deterministicScheduler = new DeterministicScheduler();\n+    private final SweepDelay delay = mock(SweepDelay.class);\n+    private final Callable<SweepIterationResult> sweepIteration = mock(Callable.class);\n+    private final AtomicBoolean schedulerEnabled = new AtomicBoolean(true);\n+    private final ScalingSweepTaskScheduler scheduler = createScheduler(Duration.ZERO);\n+\n+    @Before\n+    public void setup() {\n+        when(delay.getInitialPause()).thenReturn(INITIAL_PAUSE);\n+        when(delay.getNextPause(any(SweepIterationResult.class))).thenReturn(DELAY);\n+    }\n+\n+    @Test\n+    public void whenExpectedNumberOfEntriesIsSweptKeepReschedulingAfterDelay() throws Exception {\n+        when(sweepIteration.call()).thenReturn(SUCCESS_MEDIUM);\n+        scheduler.start(2);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 8 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times((1 + 8) * 2)).call();\n+    }\n+\n+    @Test\n+    public void whenScalingDisabledUsesInitialPause() throws Exception {\n+        when(sweepIteration.call()).thenReturn(SUCCESS_MEDIUM);\n+        schedulerEnabled.set(false);\n+        scheduler.start(10);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 7 * INITIAL_PAUSE, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(8 * 10)).call();\n+    }\n+\n+    @Test\n+    public void whenManyEntriesAreSweptNewTaskSpawns() throws Exception {\n+        when(sweepIteration.call()).thenReturn(\n+                SUCCESS_LARGE,\n+                SUCCESS_MEDIUM, SUCCESS_MEDIUM,\n+                SUCCESS_LARGE, SUCCESS_MEDIUM);\n+        scheduler.start(1);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 5 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(1 + 2 + 2 + 3 + 3 + 3)).call();\n+    }\n+\n+    @Test\n+    public void coolDownProtectsAgainstSpawningNewTasks() throws Exception {\n+        ScalingSweepTaskScheduler schedulerWithCoolDown = createScheduler(Duration.ofDays(1));\n+        when(sweepIteration.call()).thenReturn(SUCCESS_LARGE);\n+        schedulerWithCoolDown.start(1);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 5 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(1 + 5)).call();\n+    }\n+\n+    @Test\n+    public void whenFewEntriesAreSweptTasksAreReduced() throws Exception {\n+        when(sweepIteration.call()).thenReturn(SUCCESS_SMALL, SUCCESS_MEDIUM);\n+        scheduler.start(10);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 5 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(10 + 5 * 9)).call();\n+    }\n+\n+    @Test\n+    public void whenFewEntriesDoNotReduceToZeroTasks() throws Exception {\n+        when(sweepIteration.call()).thenReturn(SUCCESS_SMALL);\n+        scheduler.start(1);\n+        deterministicScheduler.tick(INITIAL_DELAY + 5 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(1 + 5)).call();\n+    }\n+\n+    @Test\n+    public void coolDownProtectsAgainstReducingTasks() throws Exception {\n+        ScalingSweepTaskScheduler schedulerWithCoolDown = createScheduler(Duration.ofDays(1));\n+        when(sweepIteration.call()).thenReturn(SUCCESS_SMALL);\n+\n+        schedulerWithCoolDown.start(2);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 5 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(2 + 5 * 2)).call();\n+    }\n+\n+    @Test\n+    public void attemptToIncreaseNumberOfThreadsPreventsReduction() throws Exception {\n+        Duration coolDown = Duration.ofSeconds(1);\n+        ScalingSweepTaskScheduler schedulerWithCoolDown = createScheduler(coolDown);\n+        when(sweepIteration.call()).thenReturn(\n+                SUCCESS_LARGE,\n+                SUCCESS_LARGE,\n+                SUCCESS_SMALL);\n+        schedulerWithCoolDown.start(2);\n+\n+        Uninterruptibles.sleepUninterruptibly(coolDown.toMillis() / 2 + 1, TimeUnit.MILLISECONDS);\n+        deterministicScheduler.tick(INITIAL_DELAY, TimeUnit.MILLISECONDS);\n+\n+        Uninterruptibles.sleepUninterruptibly(coolDown.toMillis() / 2 + 1, TimeUnit.MILLISECONDS);", "originalCommit": "d16ab2fa420b283a42c3b1a1758cca9c94fbb996", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NDc1OQ==", "url": "https://github.com/palantir/atlasdb/pull/4975#discussion_r485174759", "bodyText": "I would throw a SafeIllegalStateException in this case (unless there's some vagary of the type system I'm missing).", "author": "jeremyk-91", "createdAt": "2020-09-08T20:22:19Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/sweep/queue/ScalingSweepTaskScheduler.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.sweep.queue;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Supplier;\n+\n+import com.palantir.common.concurrent.NamedThreadFactory;\n+import com.palantir.common.concurrent.PTExecutors;\n+\n+public class ScalingSweepTaskScheduler implements Closeable {\n+    private static final Duration COOL_DOWN = Duration.ofMinutes(5L);\n+    static final int BATCH_CELLS_LOW_THRESHOLD = 1_000;\n+    static final int BATCH_CELLS_HIGH_THRESHOLD = SweepQueueUtils.SWEEP_BATCH_SIZE * 2 / 3;\n+    static final long INITIAL_DELAY = 1_000L;\n+\n+    private final ScheduledExecutorService executorService;\n+    private final SweepDelay delay;\n+    private final Duration coolDown;\n+    private final Callable<SweepIterationResult> singleIteration;\n+    private final BooleanSupplier scalingEnabled;\n+\n+    private int runningTasks = 0;\n+    private Instant lastModification = Instant.now();\n+    private Instant lastIncreaseAttempted = Instant.now();\n+\n+    ScalingSweepTaskScheduler(\n+            ScheduledExecutorService executorService,\n+            SweepDelay delay,\n+            Duration coolDown,\n+            Callable<SweepIterationResult> singleIteration,\n+            BooleanSupplier scalingEnabled) {\n+        this.executorService = executorService;\n+        this.delay = delay;\n+        this.coolDown = coolDown;\n+        this.singleIteration = singleIteration;\n+        this.scalingEnabled = scalingEnabled;\n+    }\n+\n+    /**\n+     * Creates a scheduler for targeted sweep background tasks that dynamically modifies the number of parallel tasks\n+     * based on results. The number of tasks is guaranteed to always be between 1 nad 128, and will only change by one\n+     * in any {@link #COOL_DOWN} period. Furthermore, if conflicting results are observed, increasing the number of\n+     * tasks is prioritised to make sure targeted sweep does not fall behind.\n+     *\n+     * If an iteration of the task is unable to acquire a shard to sweep or sweep is disabled, and there are multiple\n+     * running tasks, the number of tasks will be decreased regardless of {@link #COOL_DOWN} as this indicates the level\n+     * of parallelism is too high to achieve any benefit.\n+     */\n+    public static ScalingSweepTaskScheduler createStarted(\n+            SweepDelay delay,\n+            int initialThreads,\n+            Callable<SweepIterationResult> task,\n+            BooleanSupplier scalingEnabled) {\n+        ScheduledExecutorService  executorService = PTExecutors.newScheduledThreadPoolExecutor(1,\n+                new NamedThreadFactory(\"Targeted Sweep\", true));\n+\n+        ScalingSweepTaskScheduler scheduler = new ScalingSweepTaskScheduler(\n+                executorService, delay, COOL_DOWN, task, scalingEnabled);\n+        scheduler.start(initialThreads);\n+        return scheduler;\n+    }\n+\n+    void start(int initialThreads) {\n+        for (int i = 0; i < initialThreads; i++) {\n+            increaseNumberOfTasks(INITIAL_DELAY);\n+        }\n+    }\n+\n+    private synchronized void maybeIncreaseNumberOfTasks(long pause) {\n+        lastIncreaseAttempted = Instant.now();\n+        if (cooldownPassed(lastModification)) {\n+            increaseNumberOfTasks(pause);\n+        }\n+        scheduleAfterDelay(pause);\n+    }\n+\n+    private synchronized void maybeDecreaseNumberOfTasks(long pause) {\n+        if (cooldownPassed(lastModification) && cooldownPassed(lastIncreaseAttempted)) {\n+            decreaseNumberOfTasksOrRescheduleIfLast(pause);\n+        } else {\n+            scheduleAfterDelay(pause);\n+        }\n+    }\n+\n+    private synchronized void increaseNumberOfTasks(long pause) {\n+        if (runningTasks < 128) {\n+            runningTasks++;\n+            lastModification = Instant.now();\n+            scheduleAfterDelay(pause);\n+        }\n+    }\n+\n+    private synchronized void decreaseNumberOfTasksOrRescheduleIfLast(long pause) {\n+        if (runningTasks == 1) {\n+            scheduleAfterDelay(pause);\n+        } else {\n+            decreaseNumberOfTasks();\n+        }\n+    }\n+\n+    private synchronized void decreaseNumberOfTasks() {\n+        runningTasks--;\n+        lastModification = Instant.now();\n+    }\n+\n+    private void scheduleAfterDelay(long pause) {\n+        executorService.schedule(() -> retryingTask(singleIteration), pause, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void retryingTask(Callable<SweepIterationResult> task) {\n+        try {\n+            SweepIterationResult sweepResult = task.call();\n+            if (!scalingEnabled.getAsBoolean()) {\n+                scheduleAfterDelay(delay.getInitialPause());\n+            } else {\n+                long pause = delay.getNextPause(sweepResult);\n+                SweepIterationResults.caseOf(sweepResult)\n+                        .success(numThreads -> determineAction(numThreads, pause))\n+                        .unableToAcquireShard(wrap(() -> decreaseNumberOfTasksOrRescheduleIfLast(pause)))\n+                        .insufficientConsistency(wrap(() -> scheduleAfterDelay(pause)))\n+                        .otherError(wrap(() -> scheduleAfterDelay(pause)))\n+                        .disabled(wrap(() -> decreaseNumberOfTasksOrRescheduleIfLast(pause)));\n+            }\n+        } catch (Exception e) {\n+            scheduleAfterDelay(delay.getMaxPause());\n+        }\n+    }\n+\n+    private Void determineAction(long numThreads, long pause) {\n+        if (numThreads <= BATCH_CELLS_LOW_THRESHOLD) {\n+            maybeDecreaseNumberOfTasks(pause);\n+        } else if (numThreads >= BATCH_CELLS_HIGH_THRESHOLD) {\n+            maybeIncreaseNumberOfTasks(pause);\n+        } else {\n+            scheduleAfterDelay(pause);\n+        }\n+        return null;", "originalCommit": "d16ab2fa420b283a42c3b1a1758cca9c94fbb996", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYyNTM1Mg==", "url": "https://github.com/palantir/atlasdb/pull/4975#discussion_r485625352", "bodyText": "I definitely don't want to throw here, the function has to return Void for the fluent expression above to be happy with typing", "author": "gmaretic", "createdAt": "2020-09-09T13:47:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NDc1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NjM0OQ==", "url": "https://github.com/palantir/atlasdb/pull/4975#discussion_r485176349", "bodyText": "nit: runningTasks, for consistency with elsewhere in the class.", "author": "jeremyk-91", "createdAt": "2020-09-08T20:25:41Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/sweep/queue/ScalingSweepTaskScheduler.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.sweep.queue;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Supplier;\n+\n+import com.palantir.common.concurrent.NamedThreadFactory;\n+import com.palantir.common.concurrent.PTExecutors;\n+\n+public class ScalingSweepTaskScheduler implements Closeable {\n+    private static final Duration COOL_DOWN = Duration.ofMinutes(5L);\n+    static final int BATCH_CELLS_LOW_THRESHOLD = 1_000;\n+    static final int BATCH_CELLS_HIGH_THRESHOLD = SweepQueueUtils.SWEEP_BATCH_SIZE * 2 / 3;\n+    static final long INITIAL_DELAY = 1_000L;\n+\n+    private final ScheduledExecutorService executorService;\n+    private final SweepDelay delay;\n+    private final Duration coolDown;\n+    private final Callable<SweepIterationResult> singleIteration;\n+    private final BooleanSupplier scalingEnabled;\n+\n+    private int runningTasks = 0;\n+    private Instant lastModification = Instant.now();\n+    private Instant lastIncreaseAttempted = Instant.now();\n+\n+    ScalingSweepTaskScheduler(\n+            ScheduledExecutorService executorService,\n+            SweepDelay delay,\n+            Duration coolDown,\n+            Callable<SweepIterationResult> singleIteration,\n+            BooleanSupplier scalingEnabled) {\n+        this.executorService = executorService;\n+        this.delay = delay;\n+        this.coolDown = coolDown;\n+        this.singleIteration = singleIteration;\n+        this.scalingEnabled = scalingEnabled;\n+    }\n+\n+    /**\n+     * Creates a scheduler for targeted sweep background tasks that dynamically modifies the number of parallel tasks\n+     * based on results. The number of tasks is guaranteed to always be between 1 nad 128, and will only change by one\n+     * in any {@link #COOL_DOWN} period. Furthermore, if conflicting results are observed, increasing the number of\n+     * tasks is prioritised to make sure targeted sweep does not fall behind.\n+     *\n+     * If an iteration of the task is unable to acquire a shard to sweep or sweep is disabled, and there are multiple\n+     * running tasks, the number of tasks will be decreased regardless of {@link #COOL_DOWN} as this indicates the level\n+     * of parallelism is too high to achieve any benefit.\n+     */\n+    public static ScalingSweepTaskScheduler createStarted(\n+            SweepDelay delay,\n+            int initialThreads,\n+            Callable<SweepIterationResult> task,\n+            BooleanSupplier scalingEnabled) {\n+        ScheduledExecutorService  executorService = PTExecutors.newScheduledThreadPoolExecutor(1,\n+                new NamedThreadFactory(\"Targeted Sweep\", true));\n+\n+        ScalingSweepTaskScheduler scheduler = new ScalingSweepTaskScheduler(\n+                executorService, delay, COOL_DOWN, task, scalingEnabled);\n+        scheduler.start(initialThreads);\n+        return scheduler;\n+    }\n+\n+    void start(int initialThreads) {\n+        for (int i = 0; i < initialThreads; i++) {\n+            increaseNumberOfTasks(INITIAL_DELAY);\n+        }\n+    }\n+\n+    private synchronized void maybeIncreaseNumberOfTasks(long pause) {\n+        lastIncreaseAttempted = Instant.now();\n+        if (cooldownPassed(lastModification)) {\n+            increaseNumberOfTasks(pause);\n+        }\n+        scheduleAfterDelay(pause);\n+    }\n+\n+    private synchronized void maybeDecreaseNumberOfTasks(long pause) {\n+        if (cooldownPassed(lastModification) && cooldownPassed(lastIncreaseAttempted)) {\n+            decreaseNumberOfTasksOrRescheduleIfLast(pause);\n+        } else {\n+            scheduleAfterDelay(pause);\n+        }\n+    }\n+\n+    private synchronized void increaseNumberOfTasks(long pause) {\n+        if (runningTasks < 128) {\n+            runningTasks++;\n+            lastModification = Instant.now();\n+            scheduleAfterDelay(pause);\n+        }\n+    }\n+\n+    private synchronized void decreaseNumberOfTasksOrRescheduleIfLast(long pause) {\n+        if (runningTasks == 1) {\n+            scheduleAfterDelay(pause);\n+        } else {\n+            decreaseNumberOfTasks();\n+        }\n+    }\n+\n+    private synchronized void decreaseNumberOfTasks() {\n+        runningTasks--;\n+        lastModification = Instant.now();\n+    }\n+\n+    private void scheduleAfterDelay(long pause) {\n+        executorService.schedule(() -> retryingTask(singleIteration), pause, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void retryingTask(Callable<SweepIterationResult> task) {\n+        try {\n+            SweepIterationResult sweepResult = task.call();\n+            if (!scalingEnabled.getAsBoolean()) {\n+                scheduleAfterDelay(delay.getInitialPause());\n+            } else {\n+                long pause = delay.getNextPause(sweepResult);\n+                SweepIterationResults.caseOf(sweepResult)\n+                        .success(numThreads -> determineAction(numThreads, pause))", "originalCommit": "d16ab2fa420b283a42c3b1a1758cca9c94fbb996", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODEwMw==", "url": "https://github.com/palantir/atlasdb/pull/4975#discussion_r485178103", "bodyText": "Let's talk about this tomorrow. I don't see how this change would affect behaviour here, but because of large internal product's lock service implementation, we do need to know if the huge requests were broken.", "author": "jeremyk-91", "createdAt": "2020-09-08T20:29:25Z", "path": "atlasdb-ete-tests/src/test/java/com/palantir/atlasdb/ete/LockWithoutTimelockEteTest.java", "diffHunk": "@@ -1,37 +0,0 @@\n-/*\n- * (c) Copyright 2019 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.atlasdb.ete;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import org.junit.Test;\n-\n-import com.palantir.atlasdb.lock.LockResource;\n-\n-public class LockWithoutTimelockEteTest {\n-    private LockResource lockResource = EteSetup.createClientToSingleNode(LockResource.class);\n-\n-    @Test\n-    public void hugeV1LockSucceeds() throws InterruptedException {\n-        assertThat(lockResource.lockUsingLegacyLockApi(100, 500_000)).isTrue();", "originalCommit": "d16ab2fa420b283a42c3b1a1758cca9c94fbb996", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY5NzAzMg==", "url": "https://github.com/palantir/atlasdb/pull/4975#discussion_r485697032", "bodyText": "Reverted the change as discussed", "author": "gmaretic", "createdAt": "2020-09-09T15:20:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODEwMw=="}], "type": "inlineReview"}, {"oid": "824029af9e83fe8685fee93275e2235d209c2a7f", "url": "https://github.com/palantir/atlasdb/commit/824029af9e83fe8685fee93275e2235d209c2a7f", "message": "Address comments and revamp tests a bit", "committedDate": "2020-09-09T14:03:28Z", "type": "commit"}, {"oid": "502ed6af41ff8751b80e616a57073e281ecc0e21", "url": "https://github.com/palantir/atlasdb/commit/502ed6af41ff8751b80e616a57073e281ecc0e21", "message": "Add method to create client with extended timeout", "committedDate": "2020-09-09T15:06:25Z", "type": "commit"}, {"oid": "82dbab37d14cece3b4a120a45a4f3e097d083214", "url": "https://github.com/palantir/atlasdb/commit/82dbab37d14cece3b4a120a45a4f3e097d083214", "message": "Revert test change", "committedDate": "2020-09-09T15:07:45Z", "type": "commit"}, {"oid": "caea00fa9c299042b2e1b0f59204ecd5a3b9964e", "url": "https://github.com/palantir/atlasdb/commit/caea00fa9c299042b2e1b0f59204ecd5a3b9964e", "message": "Unflake tests properly", "committedDate": "2020-09-09T15:13:49Z", "type": "commit"}]}