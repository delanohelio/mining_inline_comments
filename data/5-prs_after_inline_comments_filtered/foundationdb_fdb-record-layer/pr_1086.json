{"pr_number": 1086, "pr_title": "Resolves #1085: Permuted grouped aggregate", "pr_createdAt": "2020-12-17T01:43:48Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/1086", "timeline": [{"oid": "85e25dd4c537998d9bb831f5fd6d5b3b1480ec7c", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/85e25dd4c537998d9bb831f5fd6d5b3b1480ec7c", "message": "Resolves #1085: Permuted grouped aggregate", "committedDate": "2020-12-18T18:48:25Z", "type": "forcePushed"}, {"oid": "05cc1836d90e0ebb24700e69a8aba88c891e8209", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/05cc1836d90e0ebb24700e69a8aba88c891e8209", "message": "Resolves #1085: Permuted grouped aggregate", "committedDate": "2021-01-29T18:58:09Z", "type": "forcePushed"}, {"oid": "1238bf67b93ad16f67f06ea5e7fce801130c482b", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/1238bf67b93ad16f67f06ea5e7fce801130c482b", "message": "Resolves #1085: Permuted grouped aggregate", "committedDate": "2021-02-02T15:58:37Z", "type": "commit"}, {"oid": "1238bf67b93ad16f67f06ea5e7fce801130c482b", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/1238bf67b93ad16f67f06ea5e7fce801130c482b", "message": "Resolves #1085: Permuted grouped aggregate", "committedDate": "2021-02-02T15:58:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODcxOTgxMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1086#discussion_r568719813", "bodyText": "Since there is some duplication, it would also be possible to have a MIN_AND_MAX type.", "author": "MMcM", "createdAt": "2021-02-02T15:59:44Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/metadata/IndexTypes.java", "diffHunk": "@@ -147,6 +147,16 @@\n      */\n     public static final String BITMAP_VALUE = \"bitmap_value\";\n \n+    /**\n+     * An index remmebering minimum values in a way that can enumerate minima ordered by value and not (part of the) group.\n+     */\n+    public static final String PERMUTED_MIN = \"permuted_\" + FunctionNames.MIN;\n+\n+    /**\n+     * An index remmebering maximum values in a way that can enumerate maxima ordered by value and not (part of the) group.\n+     */\n+    public static final String PERMUTED_MAX = \"permuted_\" + FunctionNames.MAX;", "originalCommit": "1238bf67b93ad16f67f06ea5e7fce801130c482b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTgyODM5OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1086#discussion_r569828399", "bodyText": "I guess you would need to split the secondary subspace in two for that type of index, but you could do it, I suppose.", "author": "alecgrieser", "createdAt": "2021-02-03T23:38:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODcxOTgxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDUwNjMyMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1086#discussion_r570506323", "bodyText": "Yes, you would.", "author": "MMcM", "createdAt": "2021-02-04T19:59:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODcxOTgxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTY2MTAzOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1086#discussion_r569661039", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * An index that maintains an extremum value in a way that can be enumated by that value rather than by group.\n          \n          \n            \n             * An index that maintains an extremum value in a way that can be enumerated by that value rather than by group.", "author": "alecgrieser", "createdAt": "2021-02-03T18:50:25Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/PermutedMinMaxIndexMaintainer.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * PermutedMinMaxIndexMaintainer.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb.indexes;\n+\n+import com.apple.foundationdb.KeyValue;\n+import com.apple.foundationdb.Transaction;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.record.IndexEntry;\n+import com.apple.foundationdb.record.IndexScanType;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.ScanProperties;\n+import com.apple.foundationdb.record.TupleRange;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexOptions;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.MetaDataException;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBIndexableRecord;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBStoreTimer;\n+import com.apple.foundationdb.record.provider.foundationdb.IndexMaintainerState;\n+import com.apple.foundationdb.record.provider.foundationdb.KeyValueCursor;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.apple.foundationdb.tuple.TupleHelpers;\n+import com.google.protobuf.Message;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * An index that maintains an extremum value in a way that can be enumated by that value rather than by group.", "originalCommit": "1238bf67b93ad16f67f06ea5e7fce801130c482b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTY2MjA2MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1086#discussion_r569662061", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * An index remmebering minimum values in a way that can enumerate minima ordered by value and not (part of the) group.\n          \n          \n            \n                 * An index remembering minimum values in a way that can enumerate minima ordered by value and not (part of the) group.", "author": "alecgrieser", "createdAt": "2021-02-03T18:52:11Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/metadata/IndexTypes.java", "diffHunk": "@@ -147,6 +147,16 @@\n      */\n     public static final String BITMAP_VALUE = \"bitmap_value\";\n \n+    /**\n+     * An index remmebering minimum values in a way that can enumerate minima ordered by value and not (part of the) group.", "originalCommit": "1238bf67b93ad16f67f06ea5e7fce801130c482b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTY2MjE1NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1086#discussion_r569662154", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * An index remmebering maximum values in a way that can enumerate maxima ordered by value and not (part of the) group.\n          \n          \n            \n                 * An index remembering maximum values in a way that can enumerate maxima ordered by value and not (part of the) group.", "author": "alecgrieser", "createdAt": "2021-02-03T18:52:20Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/metadata/IndexTypes.java", "diffHunk": "@@ -147,6 +147,16 @@\n      */\n     public static final String BITMAP_VALUE = \"bitmap_value\";\n \n+    /**\n+     * An index remmebering minimum values in a way that can enumerate minima ordered by value and not (part of the) group.\n+     */\n+    public static final String PERMUTED_MIN = \"permuted_\" + FunctionNames.MIN;\n+\n+    /**\n+     * An index remmebering maximum values in a way that can enumerate maxima ordered by value and not (part of the) group.", "originalCommit": "1238bf67b93ad16f67f06ea5e7fce801130c482b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTgwMjQxMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1086#discussion_r569802410", "bodyText": "Should this default to zero instead of throwing an error? IIUC, a permuted size of zero would mean that the secondary subspace on this index would be (group, value), i.e., it would have the same semantics as a MIN_EVER or MAX_EVER index except without the \"ever\" ness, which seems like a sensible default.", "author": "alecgrieser", "createdAt": "2021-02-03T22:39:31Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/PermutedMinMaxIndexMaintainer.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * PermutedMinMaxIndexMaintainer.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb.indexes;\n+\n+import com.apple.foundationdb.KeyValue;\n+import com.apple.foundationdb.Transaction;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.record.IndexEntry;\n+import com.apple.foundationdb.record.IndexScanType;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.ScanProperties;\n+import com.apple.foundationdb.record.TupleRange;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexOptions;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.MetaDataException;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBIndexableRecord;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBStoreTimer;\n+import com.apple.foundationdb.record.provider.foundationdb.IndexMaintainerState;\n+import com.apple.foundationdb.record.provider.foundationdb.KeyValueCursor;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.apple.foundationdb.tuple.TupleHelpers;\n+import com.google.protobuf.Message;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * An index that maintains an extremum value in a way that can be enumated by that value rather than by group.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public class PermutedMinMaxIndexMaintainer extends StandardIndexMaintainer {\n+    protected enum Type {\n+        MIN, MAX\n+    }\n+\n+    private final Type type;\n+    private final int permutedSize;\n+\n+    public PermutedMinMaxIndexMaintainer(@Nonnull IndexMaintainerState state) {\n+        super(state);\n+        type = getType(state.index);\n+        permutedSize = getPermutedSize(state.index);\n+    }\n+\n+    protected static int getPermutedSize(@Nonnull Index index) {\n+        String permutedSizeOption = index.getOption(IndexOptions.PERMUTED_SIZE_OPTION);\n+        if (permutedSizeOption == null) {\n+            throw new MetaDataException(\"permuted size not specified\", LogMessageKeys.INDEX_NAME, index.getName());", "originalCommit": "1238bf67b93ad16f67f06ea5e7fce801130c482b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDUyMDk3OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1086#discussion_r570520978", "bodyText": "Yes, but a VALUE index can do that and more.", "author": "MMcM", "createdAt": "2021-02-04T20:25:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTgwMjQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDY2NTg1Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1086#discussion_r570665853", "bodyText": "I think that this index would be better than a VALUE index if you wanted to list all of the extrema (by group), not just calculate the extremum for a single group. I suppose you could do that with a skip-scan on a VALUE index, though it wouldn't be as performant.", "author": "alecgrieser", "createdAt": "2021-02-05T01:47:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTgwMjQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTgwNDEzNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1086#discussion_r569804136", "bodyText": "This could probably use an example, something like \"if you had an index on field(c).groupBy(concatenateFields(a, b)) with a permute size of 1, then this would allow you to find the minimum of maximum value of c for each (a, b) pair, ordered by (a, c, b)\". And it should probably say that you specify the number of columns to add to the end of the grouping index by using the PERMUTED_SIZE_OPTION.", "author": "alecgrieser", "createdAt": "2021-02-03T22:43:02Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/PermutedMinMaxIndexMaintainer.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * PermutedMinMaxIndexMaintainer.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb.indexes;\n+\n+import com.apple.foundationdb.KeyValue;\n+import com.apple.foundationdb.Transaction;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.record.IndexEntry;\n+import com.apple.foundationdb.record.IndexScanType;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.ScanProperties;\n+import com.apple.foundationdb.record.TupleRange;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexOptions;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.MetaDataException;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBIndexableRecord;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBStoreTimer;\n+import com.apple.foundationdb.record.provider.foundationdb.IndexMaintainerState;\n+import com.apple.foundationdb.record.provider.foundationdb.KeyValueCursor;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.apple.foundationdb.tuple.TupleHelpers;\n+import com.google.protobuf.Message;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * An index that maintains an extremum value in a way that can be enumated by that value rather than by group.\n+ */", "originalCommit": "1238bf67b93ad16f67f06ea5e7fce801130c482b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5MzgwNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1086#discussion_r570593807", "bodyText": "Added", "author": "MMcM", "createdAt": "2021-02-04T22:40:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTgwNDEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTgzMDk4Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1086#discussion_r569830987", "bodyText": "I think this is fine, but I wanted to walk through one edge case, just to be sure. Suppose there are two index entries with the same extremum value, and then there are two concurrent transactions, one which removes one record and one which removes the other. Then I think both updates will see that the extremum hasn't changed and choose not to update the extremum value in the permuted space. But whichever commits second will be failed with a conflict anyway because the range scanned to calculate the extremum will have been changed (by the other write), and so one of the two updates will fail with a conflict (and not corrupt the index).\nI think that's right, anyway.", "author": "alecgrieser", "createdAt": "2021-02-03T23:45:29Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/PermutedMinMaxIndexMaintainer.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * PermutedMinMaxIndexMaintainer.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb.indexes;\n+\n+import com.apple.foundationdb.KeyValue;\n+import com.apple.foundationdb.Transaction;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.record.IndexEntry;\n+import com.apple.foundationdb.record.IndexScanType;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.ScanProperties;\n+import com.apple.foundationdb.record.TupleRange;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexOptions;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.MetaDataException;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBIndexableRecord;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBStoreTimer;\n+import com.apple.foundationdb.record.provider.foundationdb.IndexMaintainerState;\n+import com.apple.foundationdb.record.provider.foundationdb.KeyValueCursor;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.apple.foundationdb.tuple.TupleHelpers;\n+import com.google.protobuf.Message;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * An index that maintains an extremum value in a way that can be enumated by that value rather than by group.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public class PermutedMinMaxIndexMaintainer extends StandardIndexMaintainer {\n+    protected enum Type {\n+        MIN, MAX\n+    }\n+\n+    private final Type type;\n+    private final int permutedSize;\n+\n+    public PermutedMinMaxIndexMaintainer(@Nonnull IndexMaintainerState state) {\n+        super(state);\n+        type = getType(state.index);\n+        permutedSize = getPermutedSize(state.index);\n+    }\n+\n+    protected static int getPermutedSize(@Nonnull Index index) {\n+        String permutedSizeOption = index.getOption(IndexOptions.PERMUTED_SIZE_OPTION);\n+        if (permutedSizeOption == null) {\n+            throw new MetaDataException(\"permuted size not specified\", LogMessageKeys.INDEX_NAME, index.getName());\n+        }\n+        return Integer.parseInt(permutedSizeOption);\n+    }\n+\n+    protected static Type getType(@Nonnull Index index) {\n+        if (IndexTypes.PERMUTED_MIN.equals(index.getType())) {\n+            return Type.MIN;\n+        }\n+        if (IndexTypes.PERMUTED_MAX.equals(index.getType())) {\n+            return Type.MAX;\n+        }\n+        throw new MetaDataException(\"Unknown index type for \" + index);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public RecordCursor<IndexEntry> scan(@Nonnull IndexScanType scanType,\n+                                         @Nonnull TupleRange range,\n+                                         @Nullable byte[] continuation,\n+                                         @Nonnull ScanProperties scanProperties) {\n+        if (scanType == IndexScanType.BY_VALUE) {\n+            return scan(range, continuation, scanProperties);\n+        }\n+        if (scanType == IndexScanType.BY_GROUP) {\n+            final Subspace permutedSubspace = getSecondarySubspace();\n+            final RecordCursor<KeyValue> keyValues = KeyValueCursor.Builder.withSubspace(permutedSubspace)\n+                    .setContext(state.context)\n+                    .setRange(range)\n+                    .setContinuation(continuation)\n+                    .setScanProperties(scanProperties)\n+                    .build();\n+            return keyValues.map(kv -> {\n+                state.store.countKeyValue(FDBStoreTimer.Counts.LOAD_INDEX_KEY, FDBStoreTimer.Counts.LOAD_INDEX_KEY_BYTES, FDBStoreTimer.Counts.LOAD_INDEX_VALUE_BYTES,\n+                        kv);\n+                return unpackKeyValue(permutedSubspace, kv);\n+            });\n+        }\n+        throw new RecordCoreException(\"Can only scan permuted index by value or group.\");\n+    }\n+\n+    @Override\n+    protected <M extends Message> CompletableFuture<Void> updateIndexKeys(@Nonnull final FDBIndexableRecord<M> savedRecord,\n+                                                                          final boolean remove,\n+                                                                          @Nonnull final List<IndexEntry> indexEntries) {\n+        final int groupPrefixSize = getGroupingCount();\n+        final int totalSize = state.index.getColumnSize();\n+        final Subspace permutedSubspace = getSecondarySubspace();\n+        for (IndexEntry indexEntry : indexEntries) {\n+            final Tuple groupKey = TupleHelpers.subTuple(indexEntry.getKey(), 0, groupPrefixSize);\n+            final Tuple value = TupleHelpers.subTuple(indexEntry.getKey(), groupPrefixSize, totalSize);\n+            final int permutePosition = groupPrefixSize - permutedSize;\n+            final Tuple groupPrefix = TupleHelpers.subTuple(groupKey, 0, permutePosition);\n+            final Tuple groupSuffix = TupleHelpers.subTuple(groupKey, permutePosition, groupPrefixSize);\n+            if (remove) {\n+                // First remove from ordinary tree.\n+                return updateOneKeyAsync(savedRecord, remove, indexEntry).thenCompose(vignore -> {\n+                    final byte[] permutedKeyToRemove = permutedSubspace.pack(groupPrefix.addAll(value).addAll(groupSuffix));\n+                    // See if value is the current minimum/maximum.\n+                    return state.store.ensureContextActive().get(permutedKeyToRemove).thenCompose(permutedValueExists -> {\n+                        if (permutedValueExists == null) {\n+                            return AsyncUtil.DONE;  // No, nothing more to do.\n+                        }\n+                        return getExtremum(groupKey).thenApply(extremum -> {\n+                            if (extremum == null) {", "originalCommit": "1238bf67b93ad16f67f06ea5e7fce801130c482b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTgzMTc2OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1086#discussion_r569831768", "bodyText": "Should these two index types be added to PlannableIndexTypes.valueTypes? Maybe the fact that they have GroupingKeyExpressions as their root key expression makes it a little awkward, but it seems like the primary space on this index could be used to answer the same sets of queries as a VALUE index (on the wholeKey)", "author": "alecgrieser", "createdAt": "2021-02-03T23:47:37Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/metadata/IndexTypes.java", "diffHunk": "@@ -147,6 +147,16 @@\n      */\n     public static final String BITMAP_VALUE = \"bitmap_value\";\n \n+    /**\n+     * An index remmebering minimum values in a way that can enumerate minima ordered by value and not (part of the) group.\n+     */\n+    public static final String PERMUTED_MIN = \"permuted_\" + FunctionNames.MIN;", "originalCommit": "1238bf67b93ad16f67f06ea5e7fce801130c482b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDUyMDU4Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1086#discussion_r570520586", "bodyText": "That is also true of RANK indexes, but we didn't do that for just the reason you give. So maybe something to revisit with the new planner.\nAnother way to do all the would be to have indexes that require that another index (in these cases, a particular VALUE) also exist in the schema and then use it.", "author": "MMcM", "createdAt": "2021-02-04T20:24:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTgzMTc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTg5OTU0OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1086#discussion_r569899548", "bodyText": "Does this need to override canDeleteWhere and/or deleteWhere to delete items from the secondary subspace?", "author": "alecgrieser", "createdAt": "2021-02-04T02:32:51Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/PermutedMinMaxIndexMaintainer.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * PermutedMinMaxIndexMaintainer.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb.indexes;\n+\n+import com.apple.foundationdb.KeyValue;\n+import com.apple.foundationdb.Transaction;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.record.IndexEntry;\n+import com.apple.foundationdb.record.IndexScanType;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.ScanProperties;\n+import com.apple.foundationdb.record.TupleRange;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexOptions;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.MetaDataException;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBIndexableRecord;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBStoreTimer;\n+import com.apple.foundationdb.record.provider.foundationdb.IndexMaintainerState;\n+import com.apple.foundationdb.record.provider.foundationdb.KeyValueCursor;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.apple.foundationdb.tuple.TupleHelpers;\n+import com.google.protobuf.Message;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * An index that maintains an extremum value in a way that can be enumated by that value rather than by group.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public class PermutedMinMaxIndexMaintainer extends StandardIndexMaintainer {", "originalCommit": "1238bf67b93ad16f67f06ea5e7fce801130c482b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5Mzk5OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1086#discussion_r570593999", "bodyText": "Yes, it does. Added.", "author": "MMcM", "createdAt": "2021-02-04T22:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTg5OTU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTkwMTE2Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1086#discussion_r569901167", "bodyText": "I suppose in theory, I could see this also having:\n\nA test where the grouping expression is zero columns\nA test where the permuted size is zero\nA test of delete where\n\nI'm also fine with merging this without the first two tests. A test of delete where would probably be good to have", "author": "alecgrieser", "createdAt": "2021-02-04T02:34:50Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/indexes/PermutedMinMaxIndexTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * PermutedMinMaxIndexTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb.indexes;\n+\n+import com.apple.foundationdb.record.IndexScanType;\n+import com.apple.foundationdb.record.ScanProperties;\n+import com.apple.foundationdb.record.TestRecords1Proto;\n+import com.apple.foundationdb.record.TupleRange;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexOptions;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordContext;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreTestBase;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.apple.foundationdb.tuple.TupleHelpers;\n+import com.apple.test.Tags;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\n+/**\n+ * Tests for permuted min / max type indexes.\n+ */\n+@Tag(Tags.RequiresFDB)\n+public class PermutedMinMaxIndexTest extends FDBRecordStoreTestBase {", "originalCommit": "1238bf67b93ad16f67f06ea5e7fce801130c482b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5NDQyMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1086#discussion_r570594422", "bodyText": "1 & 2 fail index validation, again on the principle that an index that doesn't do anything useful should be rejected.\nTest for delete where included with that addition.", "author": "MMcM", "createdAt": "2021-02-04T22:42:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTkwMTE2Nw=="}], "type": "inlineReview"}, {"oid": "8af4927f906940dc38f7c0b2e2c971ce34a50982", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/8af4927f906940dc38f7c0b2e2c971ce34a50982", "message": "Apply suggestions from code review\n\nCo-authored-by: Alec Grieser <alloc@apple.com>", "committedDate": "2021-02-04T20:01:29Z", "type": "commit"}, {"oid": "9040e6aa5259814d0942e538271c3d7eb2741ea0", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/9040e6aa5259814d0942e538271c3d7eb2741ea0", "message": "Address review comments", "committedDate": "2021-02-04T22:39:36Z", "type": "commit"}]}