{"pr_number": 988, "pr_title": "Resolves #987: introduce concept of correlations (using quantifiers)", "pr_createdAt": "2020-07-02T03:04:10Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/988", "timeline": [{"oid": "97c2bfd007e4846c38e76d98ab043cfa23a6f061", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/97c2bfd007e4846c38e76d98ab043cfa23a6f061", "message": "Resolves #987: introduce concept of correlations (using quantifiers)", "committedDate": "2020-07-06T22:31:35Z", "type": "forcePushed"}, {"oid": "06154b19e5ff0afd1d7c3cc2f1c43441fb95be55", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/06154b19e5ff0afd1d7c3cc2f1c43441fb95be55", "message": "Resolves #987: introduce concept of correlations (using quantifiers)", "committedDate": "2020-07-07T21:17:41Z", "type": "forcePushed"}, {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/6eb7142ab316ffbec53e375804118f722f1d2bcc", "message": "Resolves #987: introduce concept of correlations (using quantifiers)", "committedDate": "2020-07-09T15:00:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3ODUzMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452378531", "bodyText": "Technically, I think changing this interface is breaking enough that we need to increment the minor version. Hmmm...", "author": "nschiefer", "createdAt": "2020-07-09T17:29:58Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "diffHunk": "@@ -33,27 +33,31 @@\n import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreBase;\n import com.apple.foundationdb.record.provider.foundationdb.FDBStoreTimer;\n import com.apple.foundationdb.record.query.plan.IndexKeyValueToPartialRecord;\n-import com.apple.foundationdb.record.query.plan.ScanComparisons;\n+import com.apple.foundationdb.record.query.plan.temp.CorrelationIdentifier;\n import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n import com.apple.foundationdb.record.query.plan.temp.explain.NodeInfo;\n import com.apple.foundationdb.record.query.plan.temp.explain.PlannerGraph;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.ImmutableBiMap;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.ImmutableMap;\n import com.google.protobuf.Descriptors;\n import com.google.protobuf.Message;\n \n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n \n /**\n  * A query plan that reconstructs records from the entries in a covering index.\n  */\n @API(API.Status.MAINTAINED)\n-public class RecordQueryCoveringIndexPlan implements RecordQueryPlanWithChild {\n+public class RecordQueryCoveringIndexPlan implements RecordQueryPlanWithNoChildren {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxNTYyMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457515623", "bodyText": "Will keep that in mind!", "author": "normen662", "createdAt": "2020-07-20T15:53:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3ODUzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3ODc4Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452378787", "bodyText": "Similarly, eliminating this method is technically a breaking change.", "author": "nschiefer", "createdAt": "2020-07-09T17:30:22Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "diffHunk": "@@ -177,17 +197,12 @@ public void logPlanStructure(StoreTimer timer) {\n \n     @Override\n     public int getComplexity() {\n-        return getChild().getComplexity();\n-    }\n-\n-    @Override\n-    public RecordQueryPlan getChild() {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3OTQ1Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452379453", "bodyText": "Likewise, this is also technically a breaking change.", "author": "nschiefer", "createdAt": "2020-07-09T17:31:34Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryFilterPlanBase.java", "diffHunk": "@@ -98,56 +97,56 @@ protected RecordQueryFilterPlanBase(@Nonnull ExpressionRef<RecordQueryPlan> inne\n     }\n \n     @Nonnull\n-    public RecordQueryPlan getInner() {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3OTY3Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452379672", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected RecordQueryInJoinPlan(final Quantifier.Physical inner,\n          \n          \n            \n                                                final String bindingName,\n          \n          \n            \n                protected RecordQueryInJoinPlan(@Nonnull final Quantifier.Physical inner,\n          \n          \n            \n                                                @Nonnull final String bindingName,", "author": "nschiefer", "createdAt": "2020-07-09T17:31:56Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInJoinPlan.java", "diffHunk": "@@ -52,13 +53,16 @@\n     @SuppressWarnings(\"unchecked\")\n     protected static final Comparator<Object> VALUE_COMPARATOR = (o1, o2) -> ((Comparable)o1).compareTo((Comparable)o2);\n \n-    protected final ExpressionRef<RecordQueryPlan> plan;\n+    protected final Quantifier.Physical inner;\n     protected final String bindingName;\n     protected final boolean sortValuesNeeded;\n     protected final boolean sortReverse;\n \n-    public RecordQueryInJoinPlan(RecordQueryPlan plan, String bindingName, boolean sortValuesNeeded, boolean sortReverse) {\n-        this.plan = GroupExpressionRef.of(plan);\n+    protected RecordQueryInJoinPlan(final Quantifier.Physical inner,\n+                                    final String bindingName,", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3OTg1Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452379856", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected final Quantifier.Physical inner;\n          \n          \n            \n                @Nonnull\n          \n          \n            \n                protected final Quantifier.Physical inner;", "author": "nschiefer", "createdAt": "2020-07-09T17:32:18Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInJoinPlan.java", "diffHunk": "@@ -52,13 +53,16 @@\n     @SuppressWarnings(\"unchecked\")\n     protected static final Comparator<Object> VALUE_COMPARATOR = (o1, o2) -> ((Comparable)o1).compareTo((Comparable)o2);\n \n-    protected final ExpressionRef<RecordQueryPlan> plan;\n+    protected final Quantifier.Physical inner;", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MDE3NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452380175", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryCoveringIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public RecordQueryCoveringIndexPlan rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:32:52Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "diffHunk": "@@ -135,39 +139,55 @@ public boolean hasLoadBykeys() {\n     @Nonnull\n     @Override\n     public String toString() {\n-        return \"Covering(\" + getChild() + \" -> \" + toRecord + \")\";\n+        return \"Covering(\" + indexPlan + \" -> \" + toRecord + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        if (!(otherExpression instanceof RecordQueryCoveringIndexPlan)) {\n-            return false;\n-        }\n-        final RecordQueryCoveringIndexPlan other = (RecordQueryCoveringIndexPlan) otherExpression;\n-        return recordTypeName.equals(other.recordTypeName) && toRecord.equals(other.toRecord);\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryCoveringIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUyNTkwMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457525901", "bodyText": "Done.", "author": "normen662", "createdAt": "2020-07-20T16:06:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MDE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MDI2Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452380266", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:33:01Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "diffHunk": "@@ -135,39 +139,55 @@ public boolean hasLoadBykeys() {\n     @Nonnull\n     @Override\n     public String toString() {\n-        return \"Covering(\" + getChild() + \" -> \" + toRecord + \")\";\n+        return \"Covering(\" + indexPlan + \" -> \" + toRecord + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        if (!(otherExpression instanceof RecordQueryCoveringIndexPlan)) {\n-            return false;\n-        }\n-        final RecordQueryCoveringIndexPlan other = (RecordQueryCoveringIndexPlan) otherExpression;\n-        return recordTypeName.equals(other.recordTypeName) && toRecord.equals(other.toRecord);\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryCoveringIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return new RecordQueryCoveringIndexPlan(indexPlan, recordTypeName, toRecord);\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzMDMyMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457530323", "bodyText": "Done.", "author": "normen662", "createdAt": "2020-07-20T16:13:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MDI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MDQxNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452380417", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n          \n          \n            \n                public boolean resultEquals(@Nullable final Object other, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:33:21Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "diffHunk": "@@ -135,39 +139,55 @@ public boolean hasLoadBykeys() {\n     @Nonnull\n     @Override\n     public String toString() {\n-        return \"Covering(\" + getChild() + \" -> \" + toRecord + \")\";\n+        return \"Covering(\" + indexPlan + \" -> \" + toRecord + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        if (!(otherExpression instanceof RecordQueryCoveringIndexPlan)) {\n-            return false;\n-        }\n-        final RecordQueryCoveringIndexPlan other = (RecordQueryCoveringIndexPlan) otherExpression;\n-        return recordTypeName.equals(other.recordTypeName) && toRecord.equals(other.toRecord);\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryCoveringIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return new RecordQueryCoveringIndexPlan(indexPlan, recordTypeName, toRecord);\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n+        if (otherExpression == this) {\n             return true;\n         }\n-        if (o == null || getClass() != o.getClass()) {\n+        if (otherExpression.getClass() != getClass()) {\n             return false;\n         }\n-        if (!super.equals(o)) {\n+        final RecordQueryCoveringIndexPlan other = (RecordQueryCoveringIndexPlan) otherExpression;\n+        return indexPlan.resultEquals(other.indexPlan, equivalencesMap) &&\n+               recordTypeName.equals(other.recordTypeName) &&\n+               toRecord.equals(other.toRecord);\n+    }\n+\n+    @Override\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MTAyMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452381022", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryFilterPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public RecordQueryFilterPlan rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {", "author": "nschiefer", "createdAt": "2020-07-09T17:34:27Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryFilterPlan.java", "diffHunk": "@@ -91,42 +98,54 @@ protected boolean hasAsyncFilter() {\n \n     @Override\n     public boolean isReverse() {\n-        return getInner().isReverse();\n+        return getInnerPlan().isReverse();\n     }\n \n     @Nonnull\n     @Override\n     public String toString() {\n-        return getInner() + \" | \" + getFilter();\n+        return getInnerPlan() + \" | \" + getFilter();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryFilterPlan &&\n-               filter.equals(((RecordQueryFilterPlan)otherExpression).getFilter());\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryFilterPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MTEzNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452381135", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:34:42Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryFilterPlan.java", "diffHunk": "@@ -91,42 +98,54 @@ protected boolean hasAsyncFilter() {\n \n     @Override\n     public boolean isReverse() {\n-        return getInner().isReverse();\n+        return getInnerPlan().isReverse();\n     }\n \n     @Nonnull\n     @Override\n     public String toString() {\n-        return getInner() + \" | \" + getFilter();\n+        return getInnerPlan() + \" | \" + getFilter();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryFilterPlan &&\n-               filter.equals(((RecordQueryFilterPlan)otherExpression).getFilter());\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryFilterPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryFilterPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers),\n+                getFilter());\n+    }\n+\n+    @Override\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MTg1Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452381857", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:35:59Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInJoinPlan.java", "diffHunk": "@@ -120,8 +124,8 @@ public boolean isReverse() {\n \n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        if (!(otherExpression instanceof RecordQueryInJoinPlan)) {\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MjM0Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452382347", "bodyText": "This one is interesting because it's logically correlated, but that correlation doesn't show up in the data structure. I think you have this right, but we probably have to iterate on it.", "author": "nschiefer", "createdAt": "2020-07-09T17:36:50Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInJoinPlan.java", "diffHunk": "@@ -106,7 +110,7 @@ public boolean isSorted() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return ImmutableList.of(Quantifier.physical(plan));\n+        return ImmutableList.of(inner);", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzNDExMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457534112", "bodyText": "+1", "author": "normen662", "createdAt": "2020-07-20T16:19:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MjM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MjYzMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452382631", "bodyText": "I agree wholeheartedly with this TODO.", "author": "nschiefer", "createdAt": "2020-07-09T17:37:23Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInParameterJoinPlan.java", "diffHunk": "@@ -75,26 +100,29 @@ public String toString() {\n         return str.toString();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryInParameterJoinPlan &&\n-               super.equalsWithoutChildren(otherExpression) &&\n-               externalBinding.equals(((RecordQueryInParameterJoinPlan)otherExpression).externalBinding);\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of(); // TODO this should be reconsidered when we have selects", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MjkwNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452382906", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryInParameterJoinPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public RecordQueryInParameterJoinPlan rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {", "author": "nschiefer", "createdAt": "2020-07-09T17:37:54Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInParameterJoinPlan.java", "diffHunk": "@@ -75,26 +100,29 @@ public String toString() {\n         return str.toString();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryInParameterJoinPlan &&\n-               super.equalsWithoutChildren(otherExpression) &&\n-               externalBinding.equals(((RecordQueryInParameterJoinPlan)otherExpression).externalBinding);\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of(); // TODO this should be reconsidered when we have selects\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryInParameterJoinPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NDIwNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452384206", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryInValuesJoinPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public RecordQueryInValuesJoinPlan rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {", "author": "nschiefer", "createdAt": "2020-07-09T17:40:23Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInValuesJoinPlan.java", "diffHunk": "@@ -73,27 +97,29 @@ public String toString() {\n         return str.toString();\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryInValuesJoinPlan &&\n-               super.equalsWithoutChildren(otherExpression) &&\n-               Objects.equals(values, ((RecordQueryInValuesJoinPlan)otherExpression).values);\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of(); // TODO this should be reconsidered when we have selects\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-        RecordQueryInValuesJoinPlan that = (RecordQueryInValuesJoinPlan)o;\n-        return Objects.equals(values, that.values);\n+    public RecordQueryInValuesJoinPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NDI4OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452384288", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:40:34Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInValuesJoinPlan.java", "diffHunk": "@@ -73,27 +97,29 @@ public String toString() {\n         return str.toString();\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryInValuesJoinPlan &&\n-               super.equalsWithoutChildren(otherExpression) &&\n-               Objects.equals(values, ((RecordQueryInValuesJoinPlan)otherExpression).values);\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of(); // TODO this should be reconsidered when we have selects\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-        RecordQueryInValuesJoinPlan that = (RecordQueryInValuesJoinPlan)o;\n-        return Objects.equals(values, that.values);\n+    public RecordQueryInValuesJoinPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryInValuesJoinPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers),\n+                bindingName,\n+                values,\n+                sortValuesNeeded,\n+                sortReverse);\n+    }\n+\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NDQ3OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452384479", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public RecordQueryIndexPlan rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:40:56Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIndexPlan.java", "diffHunk": "@@ -127,25 +131,51 @@ public boolean hasLoadBykeys() {\n         return false;\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return equals(otherExpression);\n+    public RecordQueryIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NDU2Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452384567", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:41:06Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIndexPlan.java", "diffHunk": "@@ -127,25 +131,51 @@ public boolean hasLoadBykeys() {\n         return false;\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return equals(otherExpression);\n+    public RecordQueryIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return new RecordQueryIndexPlan(getIndexName(),\n+                getScanType(),\n+                getComparisons(),\n+                isReverse());\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NDcxOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452384719", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n          \n          \n            \n                public boolean resultEquals(@Nullable final Object other, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:41:24Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIndexPlan.java", "diffHunk": "@@ -127,25 +131,51 @@ public boolean hasLoadBykeys() {\n         return false;\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return equals(otherExpression);\n+    public RecordQueryIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return new RecordQueryIndexPlan(getIndexName(),\n+                getScanType(),\n+                getComparisons(),\n+                isReverse());\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n+        if (this == otherExpression) {\n             return true;\n         }\n-        if (!(o instanceof RecordQueryIndexPlan)) {\n+        if (getClass() != otherExpression.getClass()) {\n             return false;\n         }\n-        RecordQueryIndexPlan that = (RecordQueryIndexPlan) o;\n+        RecordQueryIndexPlan that = (RecordQueryIndexPlan) otherExpression;\n         return reverse == that.reverse &&\n-                Objects.equals(indexName, that.indexName) &&\n-                Objects.equals(scanType, that.scanType) &&\n-                Objects.equals(comparisons, that.comparisons);\n+               Objects.equals(indexName, that.indexName) &&\n+               Objects.equals(scanType, that.scanType) &&\n+               Objects.equals(comparisons, that.comparisons);\n+    }\n+\n+    @Override\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NTc2Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452385763", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryIntersectionPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n          \n          \n            \n                                                                                final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public RecordQueryIntersectionPlan rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n          \n          \n            \n                                                                                @Nonnull final List<Quantifier> rebasedQuantifiers) {", "author": "nschiefer", "createdAt": "2020-07-09T17:43:12Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIntersectionPlan.java", "diffHunk": "@@ -166,9 +178,31 @@ public String toString() {\n         return getChildStream().map(RecordQueryPlan::toString).collect(Collectors.joining(\" \" + INTERSECT + \" \"));\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryIntersectionPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n+                                                                    final List<Quantifier> rebasedQuantifiers) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NTg4NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452385884", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:43:27Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIntersectionPlan.java", "diffHunk": "@@ -166,9 +178,31 @@ public String toString() {\n         return getChildStream().map(RecordQueryPlan::toString).collect(Collectors.joining(\" \" + INTERSECT + \" \"));\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryIntersectionPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n+                                                                    final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryIntersectionPlan(\n+                rebasedQuantifiers\n+                        .stream()\n+                        .map(quantifier -> (Quantifier.Physical)quantifier)\n+                        .collect(Collectors.toList()),\n+                getComparisonKey(),\n+                isReverse(),\n+                false);\n+    }\n+\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NjAxMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452386011", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n          \n          \n            \n                public boolean resultEquals(@Nullable final Object other, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:43:42Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIntersectionPlan.java", "diffHunk": "@@ -178,17 +212,30 @@ public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpressi\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NjQ4OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452386489", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryLoadByKeysPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public RecordQueryLoadByKeysPlan rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:44:35Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryLoadByKeysPlan.java", "diffHunk": "@@ -130,22 +135,47 @@ public String toString() {\n         return \"ByKeys(\" + getKeysSource() + \")\";\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of(); // TODO this should be reconsidered when we have selects\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryLoadByKeysPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NjYzMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452386631", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:44:49Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryLoadByKeysPlan.java", "diffHunk": "@@ -130,22 +135,47 @@ public String toString() {\n         return \"ByKeys(\" + getKeysSource() + \")\";\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of(); // TODO this should be reconsidered when we have selects\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryLoadByKeysPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return this;\n+    }\n+\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryLoadByKeysPlan;\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4Njg3Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452386873", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n          \n          \n            \n                public boolean resultEquals(@Nullable final Object other, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:45:16Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryLoadByKeysPlan.java", "diffHunk": "@@ -130,22 +135,47 @@ public String toString() {\n         return \"ByKeys(\" + getKeysSource() + \")\";\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of(); // TODO this should be reconsidered when we have selects\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryLoadByKeysPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return this;\n+    }\n+\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryLoadByKeysPlan;\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n+        if (!(otherExpression instanceof RecordQueryLoadByKeysPlan)) {\n+            return false;\n+        }\n+\n+        return Objects.equals(getKeysSource(), ((RecordQueryLoadByKeysPlan)otherExpression).getKeysSource());\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NzE4MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452387181", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryPredicateFilterPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public RecordQueryPredicateFilterPlan rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {", "author": "nschiefer", "createdAt": "2020-07-09T17:45:50Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryPredicateFilterPlan.java", "diffHunk": "@@ -110,39 +109,50 @@ public QueryPredicate getPredicate() {\n         return filter;\n     }\n \n-\n+    @Nonnull\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryPredicateFilterPlan;\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return filter.getCorrelatedTo();\n     }\n \n+    @Nonnull\n     @Override\n-    public String toString() {\n-        return getInner() + \" | \" + getPredicate();\n+    public RecordQueryPredicateFilterPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NzQzNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452387436", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:46:18Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryPredicateFilterPlan.java", "diffHunk": "@@ -110,39 +109,50 @@ public QueryPredicate getPredicate() {\n         return filter;\n     }\n \n-\n+    @Nonnull\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryPredicateFilterPlan;\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return filter.getCorrelatedTo();\n     }\n \n+    @Nonnull\n     @Override\n-    public String toString() {\n-        return getInner() + \" | \" + getPredicate();\n+    public RecordQueryPredicateFilterPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryPredicateFilterPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers),\n+                getBaseSource(),\n+                getPredicate().rebase(translationMap));\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4Nzk4MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452387981", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryScanPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public RecordQueryScanPlan rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:47:18Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScanPlan.java", "diffHunk": "@@ -147,26 +151,52 @@ public String toString() {\n         return \"Scan(\" + range + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return equals(otherExpression);\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryScanPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4ODE0NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452388144", "bodyText": "Couldn't this just return this, since it's uncorrelated?", "author": "nschiefer", "createdAt": "2020-07-09T17:47:36Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScanPlan.java", "diffHunk": "@@ -147,26 +151,52 @@ public String toString() {\n         return \"Scan(\" + range + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return equals(otherExpression);\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryScanPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return new RecordQueryScanPlan(getComparisons(), isReverse());", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzODE0Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464638147", "bodyText": "^", "author": "nschiefer", "createdAt": "2020-08-03T20:14:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4ODE0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5Mzc1NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465993755", "bodyText": "^", "author": "nschiefer", "createdAt": "2020-08-05T20:46:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4ODE0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4ODI0NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452388244", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:47:48Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScanPlan.java", "diffHunk": "@@ -147,26 +151,52 @@ public String toString() {\n         return \"Scan(\" + range + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return equals(otherExpression);\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryScanPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return new RecordQueryScanPlan(getComparisons(), isReverse());\n+    }\n+\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4ODY4Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452388682", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryScoreForRankPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public RecordQueryScoreForRankPlan rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {", "author": "nschiefer", "createdAt": "2020-07-09T17:48:43Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScoreForRankPlan.java", "diffHunk": "@@ -139,24 +150,32 @@ public String toString() {\n         return getChild() + \" WHERE \" + ranks.stream().map(Object::toString).collect(Collectors.joining(\", \"));\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n+    public RecordQueryScoreForRankPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4ODc5Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452388796", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:48:56Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScoreForRankPlan.java", "diffHunk": "@@ -139,24 +150,32 @@ public String toString() {\n         return getChild() + \" WHERE \" + ranks.stream().map(Object::toString).collect(Collectors.joining(\", \"));\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n+    public RecordQueryScoreForRankPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryScoreForRankPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers),\n+                getRanks());\n+    }\n+\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4OTM1NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452389354", "bodyText": "Where is resultEquals() for this class?", "author": "nschiefer", "createdAt": "2020-07-09T17:49:58Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScoreForRankPlan.java", "diffHunk": "@@ -139,24 +150,32 @@ public String toString() {\n         return getChild() + \" WHERE \" + ranks.stream().map(Object::toString).collect(Collectors.joining(\", \"));\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n+    public RecordQueryScoreForRankPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryScoreForRankPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers),\n+                getRanks());\n+    }\n+\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n         return otherExpression instanceof RecordQueryScoreForRankPlan &&\n                ranks.equals(((RecordQueryScoreForRankPlan) otherExpression).ranks);\n     }\n \n+    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        RecordQueryScoreForRankPlan that = (RecordQueryScoreForRankPlan) o;\n-        return Objects.equals(getChild(), that.getChild()) &&\n-                Objects.equals(ranks, that.ranks);\n+    public boolean equals(final Object other) {\n+        return resultEquals(other, ImmutableBiMap.of());", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzNjQ0MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457536440", "bodyText": "This has changed in general since you reviewed this. resultEquals() is only implemented in RelationalExpression which is much nicer. That generic implementation then does the necessary things and defers to equalsWithoutChildren() after establishing result equality of the children.", "author": "normen662", "createdAt": "2020-07-20T16:23:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4OTM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4OTg2MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452389861", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryTextIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public RecordQueryTextIndexPlan rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:50:52Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTextIndexPlan.java", "diffHunk": "@@ -132,27 +136,52 @@ public int getComplexity() {\n         return 1;\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryTextIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MDAwMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452390002", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new RecordQueryTextIndexPlan(getIndexName(),\n          \n          \n            \n                            getTextScan(),\n          \n          \n            \n                            isReverse());\n          \n          \n            \n                    return new RecordQueryTextIndexPlan(getIndexName(), getTextScan(), isReverse());", "author": "nschiefer", "createdAt": "2020-07-09T17:51:07Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTextIndexPlan.java", "diffHunk": "@@ -132,27 +136,52 @@ public int getComplexity() {\n         return 1;\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryTextIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return new RecordQueryTextIndexPlan(getIndexName(),\n+                getTextScan(),\n+                isReverse());", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MDEwNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452390104", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:51:20Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTextIndexPlan.java", "diffHunk": "@@ -132,27 +136,52 @@ public int getComplexity() {\n         return 1;\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryTextIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return new RecordQueryTextIndexPlan(getIndexName(),\n+                getTextScan(),\n+                isReverse());\n+    }\n+\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MDQxMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452390411", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n          \n          \n            \n                public boolean resultEquals(@Nullable final Object other, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:51:55Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTextIndexPlan.java", "diffHunk": "@@ -132,27 +136,52 @@ public int getComplexity() {\n         return 1;\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryTextIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return new RecordQueryTextIndexPlan(getIndexName(),\n+                getTextScan(),\n+                isReverse());\n+    }\n+\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n         if (!(otherExpression instanceof RecordQueryTextIndexPlan)) {\n             return false;\n         }\n-        final RecordQueryTextIndexPlan other = (RecordQueryTextIndexPlan) otherExpression;\n-        return reverse == other.reverse && indexName.equals(other.indexName) && textScan.equals(other.textScan);\n+\n+        final RecordQueryTextIndexPlan that = (RecordQueryTextIndexPlan)otherExpression;\n+        return this.reverse == that.reverse &&\n+               this.indexName.equals(that.indexName) &&\n+               this.textScan.equals(that.textScan);\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MDY0Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452390642", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryTypeFilterPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public RecordQueryTypeFilterPlan rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {", "author": "nschiefer", "createdAt": "2020-07-09T17:52:20Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTypeFilterPlan.java", "diffHunk": "@@ -113,24 +115,17 @@ public String toString() {\n         return getInner() + \" | \" + recordTypes;\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryTypeFilterPlan &&\n-               recordTypes.equals(((RecordQueryTypeFilterPlan)otherExpression).recordTypes);\n+    public RecordQueryTypeFilterPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MTE0Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452391147", "bodyText": "This patterns shows up so often (and looks sufficiently confusing if you don't know what specifically is going on) that I think we should make it into a utility method on RecordQueryPlan or something along those lines.", "author": "nschiefer", "createdAt": "2020-07-09T17:53:16Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTypeFilterPlan.java", "diffHunk": "@@ -113,24 +115,17 @@ public String toString() {\n         return getInner() + \" | \" + recordTypes;\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryTypeFilterPlan &&\n-               recordTypes.equals(((RecordQueryTypeFilterPlan)otherExpression).recordTypes);\n+    public RecordQueryTypeFilterPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryTypeFilterPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers), getRecordTypes());", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzczMzQ0MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457733440", "bodyText": "Added a helper to narrow the type.", "author": "normen662", "createdAt": "2020-07-20T22:45:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MTE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MTc3OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452391779", "bodyText": "This code style (here and elsewhere) feels pretty unidiomatic in the Record Layer when all of the parameters are \"short\". Can you collapse them down into a single second line here and elsewhere among the RecordQueryPlan classes?", "author": "nschiefer", "createdAt": "2020-07-09T17:54:31Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlan.java", "diffHunk": "@@ -92,18 +103,24 @@ public RecordQueryUnionPlan(@Nonnull RecordQueryPlan left, @Nonnull RecordQueryP\n      */\n     @API(API.Status.DEPRECATED)\n     @Deprecated\n-    public RecordQueryUnionPlan(@Nonnull List<RecordQueryPlan> children,\n-                                @Nonnull KeyExpression comparisonKey, boolean reverse, boolean showComparisonKey) {\n-        this(children.stream().map(GroupExpressionRef::of).collect(Collectors.toList()), comparisonKey,\n-                reverse, showComparisonKey, false);\n+    public RecordQueryUnionPlan(@Nonnull final List<RecordQueryPlan> children,\n+                                @Nonnull final KeyExpression comparisonKey,\n+                                final boolean reverse,\n+                                final boolean showComparisonKey) {\n+        this(Quantifiers.fromPlans(children.stream().map(GroupExpressionRef::of).collect(Collectors.toList())),\n+                comparisonKey,\n+                reverse,\n+                showComparisonKey,\n+                false);", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzODU3Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457538573", "bodyText": "I actually have significant trouble quick-parsing that in my head if it is collapsed. Are you okay with leaving this and other places?", "author": "normen662", "createdAt": "2020-07-20T16:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MTc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzODU1Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464638552", "bodyText": "Yeah, that's fine.", "author": "nschiefer", "createdAt": "2020-08-03T20:15:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MTc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MTk1OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452391959", "bodyText": "Same here, for that matter.", "author": "nschiefer", "createdAt": "2020-07-09T17:54:50Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlan.java", "diffHunk": "@@ -121,27 +138,31 @@ public KeyExpression getComparisonKey() {\n         return comparisonKey;\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        if (!(otherExpression instanceof RecordQueryUnionPlan)) {\n-            return false;\n-        }\n-        final RecordQueryUnionPlan other = (RecordQueryUnionPlan) otherExpression;\n-        return comparisonKey.equals(other.comparisonKey) &&\n-               isReverse() == other.isReverse();\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    public RecordQueryUnionPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryUnionPlan(rebasedQuantifiers.stream().map(quantifier -> (Quantifier.Physical)quantifier).collect(Collectors.toList()),\n+                getComparisonKey(),\n+                isReverse(),\n+                showComparisonKey,\n+                false);", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MjA0MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452392041", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryUnionPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public RecordQueryUnionPlan rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {", "author": "nschiefer", "createdAt": "2020-07-09T17:55:03Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlan.java", "diffHunk": "@@ -121,27 +138,31 @@ public KeyExpression getComparisonKey() {\n         return comparisonKey;\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        if (!(otherExpression instanceof RecordQueryUnionPlan)) {\n-            return false;\n-        }\n-        final RecordQueryUnionPlan other = (RecordQueryUnionPlan) otherExpression;\n-        return comparisonKey.equals(other.comparisonKey) &&\n-               isReverse() == other.isReverse();\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    public RecordQueryUnionPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MjMzOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452392339", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:55:36Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlan.java", "diffHunk": "@@ -121,27 +138,31 @@ public KeyExpression getComparisonKey() {\n         return comparisonKey;\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        if (!(otherExpression instanceof RecordQueryUnionPlan)) {\n-            return false;\n-        }\n-        final RecordQueryUnionPlan other = (RecordQueryUnionPlan) otherExpression;\n-        return comparisonKey.equals(other.comparisonKey) &&\n-               isReverse() == other.isReverse();\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    public RecordQueryUnionPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryUnionPlan(rebasedQuantifiers.stream().map(quantifier -> (Quantifier.Physical)quantifier).collect(Collectors.toList()),\n+                getComparisonKey(),\n+                isReverse(),\n+                showComparisonKey,\n+                false);\n+    }\n+\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MzAyNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452393027", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                     final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalences) {\n          \n          \n            \n                                                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalences) {", "author": "nschiefer", "createdAt": "2020-07-09T17:56:58Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlanBase.java", "diffHunk": "@@ -115,20 +121,42 @@ public boolean isReverse() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return Quantifiers.fromPlans(children);\n+        return quantifiers;\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n+    public boolean equalsWithoutChildren(@Nonnull final RelationalExpression other,\n+                                         final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalences) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MzE1OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452393158", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n          \n          \n            \n                public boolean resultEquals(@Nullable final Object other, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "author": "nschiefer", "createdAt": "2020-07-09T17:57:12Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlanBase.java", "diffHunk": "@@ -115,20 +121,42 @@ public boolean isReverse() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return Quantifiers.fromPlans(children);\n+        return quantifiers;\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n+    public boolean equalsWithoutChildren(@Nonnull final RelationalExpression other,\n+                                         final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalences) {\n+        if (!RecordQueryPlanWithChildren.super.equalsWithoutChildren(other, equivalences)) {\n+            return false;\n         }\n-        if (o == null || getClass() != o.getClass()) {\n+        return reverse == ((RecordQueryUnionPlanBase)other).reverse;\n+    }\n+\n+    @Override\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NTE0Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452395143", "bodyText": "I don't love this as a default method on RelationalExpression since, as far as I can tell, it's only ever used in the implementation of the RelationalExpression interface and never by a consumer of that interface. It also doesn't seem to actually use anything internal to the class.\nCan we pull this out into a utility method instead?", "author": "nschiefer", "createdAt": "2020-07-09T18:00:49Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +148,160 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    default boolean canCorrelate() {\n+        return false;\n+    }\n+\n+    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+\n+    default Optional<BiMap<Quantifier, Quantifier>> resultEqualsQuantifiers(@Nonnull final Set<? extends Quantifier> otherQuantifiers,", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzOTAxOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457539018", "bodyText": "Done.", "author": "normen662", "createdAt": "2020-07-20T16:27:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NTE0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NTY2Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452395666", "bodyText": "I also think that matchQuantifiers is confusing as a default method on the RelationalExpression interface and should also be pulled out into a utility class.", "author": "nschiefer", "createdAt": "2020-07-09T18:01:43Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +148,160 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    default boolean canCorrelate() {\n+        return false;\n+    }\n+\n+    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+\n+    default Optional<BiMap<Quantifier, Quantifier>> resultEqualsQuantifiers(@Nonnull final Set<? extends Quantifier> otherQuantifiers,\n+                                                                            @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        return matchQuantifiers(otherQuantifiers,\n+                equivalenceMap,\n+                (quantifier, otherQuantifier, nestedEquivalenceMap) -> {\n+                    if (quantifier.hashCode() != otherQuantifier.hashCode()) {\n+                        return false;\n+                    }\n+                    return quantifier.resultEquals(otherQuantifier, nestedEquivalenceMap);\n+                });\n+    }\n+\n+    /**\n+     * An predicate that tests for a match between quantifiers also taking into account an equivalence maps between\n+     * {@link CorrelationIdentifier}s.\n+     */\n+    @FunctionalInterface\n+    interface MatchingPredicate {\n+        boolean test(@Nonnull Quantifier quantifier,\n+                     @Nonnull Quantifier otherQuantifier,\n+                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+    }\n+\n+\n+    /**\n+     * Method to match up the quantifiers this expression owns with the given set of other quantifiers and an\n+     * equivalence map.\n+     *\n+     * Two quantifiers can be considered equal if their extended equality method {@link Quantifier#resultEquals} returns\n+     * {@code true} for the given the correct equality map. This method attempts to match up each quantifier from the\n+     * set of quantifiers this expression owns to the given other set of quantifiers.\n+     *\n+     * Now this method returns an empty mapping if e.g. the number quantifiers in the respetive sets doesn't match.\n+     *\n+     * For expressions that cannot introduce correlations, this method is simply {@code O(n!)} where is the\n+     * number of quantifiers (which is equal for both sets). This path is taken by UNIONs and other set operations.\n+     *\n+     * For expressions that introduce correlations, the matching process is more complicated. First, we determine one\n+     * topologically correct ordering. Then we iterate through all topologically correct orderings of the set of\n+     * quantifiers this expression owns. For each element in the permutation of quantifiers that is returned by\n+     * the {@link com.apple.foundationdb.record.query.plan.temp.TopologicalSort.TopologicalOrderPermutationIterator}\n+     * we try to math the quantifiers between the sets topologically from left to right (using {@code predicate}).\n+     * For each match we find we add an equivalence between the alias of this and the other quantifier that matched\n+     * in an equivalence map that extends the given equivalence map.\n+     * @param otherQuantifiers other quantifiers\n+     * @param equivalencesMap equivalence map\n+     * @param predicate that tests if two quantifiers and their graph they range over can be considered equivalent\n+     * @return A bi-map containing a mapping from the quantifiers this expression owns to the quantifiers in\n+     *         {@code otherQuantifiers}. Note that the mapping is bijective and can therefore be inverted.\n+     */\n+    @SuppressWarnings({\"UnstableApiUsage\", \"squid:S135\"})\n+    default Optional<BiMap<Quantifier, Quantifier>> matchQuantifiers(@Nonnull Set<? extends Quantifier> otherQuantifiers,", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY1NTUwNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457655506", "bodyText": "It is now in Quantifiers.", "author": "normen662", "createdAt": "2020-07-20T19:55:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NTY2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NjIxOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452396219", "bodyText": "When we pick a new name for resultEqualsQuantifiers, I think it should be clearer that there's a non-trivial matching process going on here, rather than just some simple comparison. At the very least, we should add a comment similar to the one that was removed explicitly calling out that the order of the quantifiers is (mostly) not significant.", "author": "nschiefer", "createdAt": "2020-07-09T18:02:44Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlanBase.java", "diffHunk": "@@ -115,20 +121,42 @@ public boolean isReverse() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return Quantifiers.fromPlans(children);\n+        return quantifiers;\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n+    public boolean equalsWithoutChildren(@Nonnull final RelationalExpression other,\n+                                         final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalences) {\n+        if (!RecordQueryPlanWithChildren.super.equalsWithoutChildren(other, equivalences)) {\n+            return false;\n         }\n-        if (o == null || getClass() != o.getClass()) {\n+        return reverse == ((RecordQueryUnionPlanBase)other).reverse;\n+    }\n+\n+    @Override\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        if (other == null || getClass() != other.getClass()) {\n             return false;\n         }\n-        RecordQueryUnionPlanBase that = (RecordQueryUnionPlanBase) o;\n-        return reverse == that.reverse &&\n-               Objects.equals(Sets.newHashSet(getQueryPlanChildren()), Sets.newHashSet(that.getQueryPlanChildren()));  // isomorphic under re-ordering of children\n+        final RecordQueryUnionPlanBase otherPlan = (RecordQueryUnionPlanBase) other;\n+        \n+        final Optional<BiMap<Quantifier, Quantifier>> quantifierMapOptional =\n+                resultEqualsQuantifiers(ImmutableSet.copyOf(otherPlan.getQuantifiers()),", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzOTQzNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457539434", "bodyText": "This method is now called match() and it lives in Quantifiers.", "author": "normen662", "createdAt": "2020-07-20T16:28:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NjIxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NjgyOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452396829", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryUnorderedDistinctPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public RecordQueryUnorderedDistinctPlan rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {", "author": "nschiefer", "createdAt": "2020-07-09T18:03:49Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedDistinctPlan.java", "diffHunk": "@@ -115,32 +124,43 @@ private KeyExpression getComparisonKey() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return ImmutableList.of(Quantifier.physical(inner));\n+        return ImmutableList.of(inner);\n     }\n \n     @Override\n     public String toString() {\n         return getInner() + \" | UnorderedDistinct(\" + getComparisonKey() + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryUnorderedDistinctPlan &&\n-               comparisonKey.equals(((RecordQueryUnorderedDistinctPlan)otherExpression).comparisonKey);\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    public RecordQueryUnorderedDistinctPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5Njk4NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452396984", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "author": "nschiefer", "createdAt": "2020-07-09T18:04:04Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedDistinctPlan.java", "diffHunk": "@@ -115,32 +124,43 @@ private KeyExpression getComparisonKey() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return ImmutableList.of(Quantifier.physical(inner));\n+        return ImmutableList.of(inner);\n     }\n \n     @Override\n     public String toString() {\n         return getInner() + \" | UnorderedDistinct(\" + getComparisonKey() + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryUnorderedDistinctPlan &&\n-               comparisonKey.equals(((RecordQueryUnorderedDistinctPlan)otherExpression).comparisonKey);\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    public RecordQueryUnorderedDistinctPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryUnorderedDistinctPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers),\n+                getComparisonKey());\n+    }\n+\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NzYzMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452397631", "bodyText": "Where is resultEquals() for RecordQueryUnorderedDistinctPlan?", "author": "nschiefer", "createdAt": "2020-07-09T18:05:15Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedDistinctPlan.java", "diffHunk": "@@ -115,32 +124,43 @@ private KeyExpression getComparisonKey() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return ImmutableList.of(Quantifier.physical(inner));\n+        return ImmutableList.of(inner);\n     }\n \n     @Override\n     public String toString() {\n         return getInner() + \" | UnorderedDistinct(\" + getComparisonKey() + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryUnorderedDistinctPlan &&\n-               comparisonKey.equals(((RecordQueryUnorderedDistinctPlan)otherExpression).comparisonKey);\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    public RecordQueryUnorderedDistinctPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryUnorderedDistinctPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers),\n+                getComparisonKey());\n+    }\n+\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n+        if (!RecordQueryPlanWithChild.super.equalsWithoutChildren(otherExpression, equivalencesMap)) {\n             return false;\n         }\n-        RecordQueryUnorderedDistinctPlan that = (RecordQueryUnorderedDistinctPlan) o;\n-        return Objects.equals(getInner(), that.getInner()) &&\n-                Objects.equals(getComparisonKey(), that.getComparisonKey());\n+\n+        return otherExpression instanceof RecordQueryUnorderedDistinctPlan &&\n+               comparisonKey.equals(((RecordQueryUnorderedDistinctPlan)otherExpression).comparisonKey);\n+    }\n+\n+    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n+    @Override\n+    public boolean equals(final Object other) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzOTc3MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457539770", "bodyText": "Refactored. Generic implementation in RelationalExpression.", "author": "normen662", "createdAt": "2020-07-20T16:28:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NzYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NzgxNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452397815", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryUnorderedPrimaryKeyDistinctPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public RecordQueryUnorderedPrimaryKeyDistinctPlan rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {", "author": "nschiefer", "createdAt": "2020-07-09T18:05:36Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedPrimaryKeyDistinctPlan.java", "diffHunk": "@@ -107,30 +111,42 @@ public RecordQueryPlan getChild() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return ImmutableList.of(Quantifier.physical(inner));\n+        return ImmutableList.of(inner);\n     }\n \n     @Override\n     public String toString() {\n         return getInner() + \" | UnorderedPrimaryKeyDistinct()\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryUnorderedPrimaryKeyDistinctPlan;\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryUnorderedPrimaryKeyDistinctPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NzkzMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452397932", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "author": "nschiefer", "createdAt": "2020-07-09T18:05:47Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedPrimaryKeyDistinctPlan.java", "diffHunk": "@@ -107,30 +111,42 @@ public RecordQueryPlan getChild() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return ImmutableList.of(Quantifier.physical(inner));\n+        return ImmutableList.of(inner);\n     }\n \n     @Override\n     public String toString() {\n         return getInner() + \" | UnorderedPrimaryKeyDistinct()\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryUnorderedPrimaryKeyDistinctPlan;\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryUnorderedPrimaryKeyDistinctPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryUnorderedPrimaryKeyDistinctPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers));\n+    }\n+\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5ODA3NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452398075", "bodyText": "Similarly, where is resultEquals() for this class?", "author": "nschiefer", "createdAt": "2020-07-09T18:06:05Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedPrimaryKeyDistinctPlan.java", "diffHunk": "@@ -107,30 +111,42 @@ public RecordQueryPlan getChild() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return ImmutableList.of(Quantifier.physical(inner));\n+        return ImmutableList.of(inner);\n     }\n \n     @Override\n     public String toString() {\n         return getInner() + \" | UnorderedPrimaryKeyDistinct()\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryUnorderedPrimaryKeyDistinctPlan;\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryUnorderedPrimaryKeyDistinctPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryUnorderedPrimaryKeyDistinctPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers));\n+    }\n+\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n+        if (!RecordQueryPlanWithChild.super.equalsWithoutChildren(otherExpression, equivalencesMap)) {\n             return false;\n         }\n-        RecordQueryUnorderedPrimaryKeyDistinctPlan that = (RecordQueryUnorderedPrimaryKeyDistinctPlan) o;\n-        return Objects.equals(getInner(), that.getInner());\n+\n+        return otherExpression instanceof RecordQueryUnorderedPrimaryKeyDistinctPlan;\n+    }\n+\n+    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n+    @Override\n+    public boolean equals(final Object other) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5ODI4NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452398284", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryUnorderedUnionPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public RecordQueryUnorderedUnionPlan rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {", "author": "nschiefer", "createdAt": "2020-07-09T18:06:27Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedUnionPlan.java", "diffHunk": "@@ -86,29 +95,30 @@ public static RecordQueryUnorderedUnionPlan from(@Nonnull List<RecordQueryPlan>\n         for (RecordQueryPlan child : children) {\n             builder.add(GroupExpressionRef.of(child));\n         }\n-        return new RecordQueryUnorderedUnionPlan(builder.build(), reverse);\n+        return new RecordQueryUnorderedUnionPlan(Quantifiers.fromPlans(builder.build()), reverse);\n     }\n \n     @Nonnull\n     public static RecordQueryUnorderedUnionPlan from(@Nonnull RecordQueryPlan left, @Nonnull RecordQueryPlan right) {\n-        return new RecordQueryUnorderedUnionPlan(ImmutableList.of(GroupExpressionRef.of(left), GroupExpressionRef.of(right)), left.isReverse());\n+        return new RecordQueryUnorderedUnionPlan(Quantifiers.fromPlans(ImmutableList.of(GroupExpressionRef.of(left), GroupExpressionRef.of(right))),\n+                left.isReverse());\n     }\n \n-    @API(API.Status.EXPERIMENTAL)\n     @Nonnull\n-    public static RecordQueryUnorderedUnionPlan fromRefs(@Nonnull List<ExpressionRef<RecordQueryPlan>> children) {\n-        return new RecordQueryUnorderedUnionPlan(children, false);\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n-    @API(API.Status.EXPERIMENTAL)\n     @Nonnull\n-    public static RecordQueryUnorderedUnionPlan fromRefs(@Nonnull ExpressionRef<RecordQueryPlan> left, @Nonnull ExpressionRef<RecordQueryPlan> right) {\n-        return new RecordQueryUnorderedUnionPlan(ImmutableList.of(left, right), false);\n+    @Override\n+    public RecordQueryUnorderedUnionPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5ODM4NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452398384", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "author": "nschiefer", "createdAt": "2020-07-09T18:06:39Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedUnionPlan.java", "diffHunk": "@@ -86,29 +95,30 @@ public static RecordQueryUnorderedUnionPlan from(@Nonnull List<RecordQueryPlan>\n         for (RecordQueryPlan child : children) {\n             builder.add(GroupExpressionRef.of(child));\n         }\n-        return new RecordQueryUnorderedUnionPlan(builder.build(), reverse);\n+        return new RecordQueryUnorderedUnionPlan(Quantifiers.fromPlans(builder.build()), reverse);\n     }\n \n     @Nonnull\n     public static RecordQueryUnorderedUnionPlan from(@Nonnull RecordQueryPlan left, @Nonnull RecordQueryPlan right) {\n-        return new RecordQueryUnorderedUnionPlan(ImmutableList.of(GroupExpressionRef.of(left), GroupExpressionRef.of(right)), left.isReverse());\n+        return new RecordQueryUnorderedUnionPlan(Quantifiers.fromPlans(ImmutableList.of(GroupExpressionRef.of(left), GroupExpressionRef.of(right))),\n+                left.isReverse());\n     }\n \n-    @API(API.Status.EXPERIMENTAL)\n     @Nonnull\n-    public static RecordQueryUnorderedUnionPlan fromRefs(@Nonnull List<ExpressionRef<RecordQueryPlan>> children) {\n-        return new RecordQueryUnorderedUnionPlan(children, false);\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n-    @API(API.Status.EXPERIMENTAL)\n     @Nonnull\n-    public static RecordQueryUnorderedUnionPlan fromRefs(@Nonnull ExpressionRef<RecordQueryPlan> left, @Nonnull ExpressionRef<RecordQueryPlan> right) {\n-        return new RecordQueryUnorderedUnionPlan(ImmutableList.of(left, right), false);\n+    @Override\n+    public RecordQueryUnorderedUnionPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryUnorderedUnionPlan(rebasedQuantifiers.stream().map(quantifier -> (Quantifier.Physical)quantifier).collect(Collectors.toList()),\n+                isReverse());\n     }\n \n     @Override\n-    @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwMzQ3NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452403474", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n          \n          \n            \n             * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n          \n          \n            \n             * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n          \n          \n            \n             * the alias identifier that {@code q} uses.\n          \n          \n            \n             * A <em>correlated</em> entity is one which can only be evaluated as a function of some input (usually a {@link Quantifier}) from its relational parent.\n          \n          \n            \n             * Since a correlated entity can have multiple correlations to similar quantifiers, a correlation is disambiguated by a {@link CorrelationIdentifier}. Correlated entities are said\n          \n          \n            \n             * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n          \n          \n            \n             * the correlation identifier that {@code q} uses.", "author": "nschiefer", "createdAt": "2020-07-09T18:16:03Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwMzkzOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452403938", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n          \n          \n            \n             * during the planning stage of a query.\n          \n          \n            \n            * Distinguishing the correlation identifier from the identity of of the quantifier object simplifies modifications of the graph, for example while applying transformations during query planning.", "author": "nschiefer", "createdAt": "2020-07-09T18:16:57Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwNTQ4Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452405486", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n          \n          \n            \n             * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n          \n          \n            \n             * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n          \n          \n            \n             * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n          \n          \n            \n             * new {@link CorrelationIdentifier} {@code id'}.\n          \n          \n            \n             * An correlated object can be <em>rebased</em> using {@link #rebase} and\n          \n          \n            \n             * a map of translations from one correlation identifier to another, resulting in a new object of type {@code S} that is\n          \n          \n            \n             * identical to {@code this} except that all correlated references in the subtree rooted at this entity  (i.e., this object's relational children, predicates, etc.) are replaced with their corresponding identifiers per the map.", "author": "nschiefer", "createdAt": "2020-07-09T18:19:42Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwNTc2Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452405767", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n          \n          \n            \n             * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n          \n          \n            \n             * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n          \n          \n            \n             * any identifier participating in the translation.\n          \n          \n            \n             * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n          \n          \n            \n             * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n          \n          \n            \n             * It is perfectly acceptable to return {@code this} if {@code this} is not correlated to any identifier participating in the translation.", "author": "nschiefer", "createdAt": "2020-07-09T18:20:14Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwNjg4MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452406881", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n          \n          \n            \n             * may be considered equal even though their used correlation identifiers are different:\n          \n          \n            \n             * This interface defines a {@link #resultEquals()} method that also takes an equivalence map, and determines equality up to the equivalences defined therein. Two correlated entities are equivalent even if they use different names, as long as un-bound correlations can be aligned. For example, in:", "author": "nschiefer", "createdAt": "2020-07-09T18:22:04Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwNzIwNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452407205", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * SELECT *\n          \n          \n            \n             * FROM T1 a, T2 b\n          \n          \n            \n             * WHERE a.x = b.y\n          \n          \n            \n             * UNION (SELECT *\n          \n          \n            \n             *        FROM T1 c, T2 d\n          \n          \n            \n             *        WHERE c.x = d.y)\n          \n          \n            \n            * <pre>\n          \n          \n            \n             * SELECT *\n          \n          \n            \n             * FROM T1 a, T2 b\n          \n          \n            \n             * WHERE a.x = b.y\n          \n          \n            \n             * UNION (SELECT *\n          \n          \n            \n             *        FROM T1 c, T2 d\n          \n          \n            \n             *        WHERE c.x = d.y)\n          \n          \n            \n             * </pre>", "author": "nschiefer", "createdAt": "2020-07-09T18:22:40Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwNzY3MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452407671", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n          \n          \n            \n                 * Return the set of {@link CorrelationIdentifier}s this entity is correlated to.", "author": "nschiefer", "createdAt": "2020-07-09T18:23:35Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwODEyNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452408126", "bodyText": "Does RecordQuery implement Correlated? I think you might mean RecordQueryPlan, which is probably redundant because aRecordQueryPlan is a RelationalExpression.", "author": "nschiefer", "createdAt": "2020-07-09T18:24:28Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwODUxMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452408512", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n          \n          \n            \n                 * implement this interface) cannot even in principle produce a meaningful result. As often times entities that", "author": "nschiefer", "createdAt": "2020-07-09T18:25:07Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwODc4MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452408781", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Rebases this and all other objects this objects is composed of against a given translation map.\n          \n          \n            \n                 * Rebases this and all other objects this objects is composed of using the given translation map.", "author": "nschiefer", "createdAt": "2020-07-09T18:25:31Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwODkzNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452408934", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n          \n          \n            \n                 *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. IDs not", "author": "nschiefer", "createdAt": "2020-07-09T18:25:47Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwOTAzNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452409036", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);\n          \n          \n            \n                S rebase(@Nonnull Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);", "author": "nschiefer", "createdAt": "2020-07-09T18:26:00Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk3Nzk4OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453977989", "bodyText": "See comment below about giving the translation maps a nicer interface.", "author": "nschiefer", "createdAt": "2020-07-13T22:24:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwOTAzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyNzg1OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452427859", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Determine equality under the additional consideration of an equivalence map between {@link CorrelationIdentifier}s.\n          \n          \n            \n                 * Determine equality with respect to an equivalence map between {@link CorrelationIdentifier}s.", "author": "nschiefer", "createdAt": "2020-07-09T19:01:18Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);\n+\n+    /**\n+     * Determine equality under the additional consideration of an equivalence map between {@link CorrelationIdentifier}s.", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyODI0OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452428248", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * and {@code q2} refer to a table {@code T} which presumably is the same table. Therefore, these two query blocks\n          \n          \n            \n                 * and {@code q2} refer to a record type {@code T} which presumably is the same type. Therefore, these two query blocks", "author": "nschiefer", "createdAt": "2020-07-09T19:02:01Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);\n+\n+    /**\n+     * Determine equality under the additional consideration of an equivalence map between {@link CorrelationIdentifier}s.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a table {@code T} which presumably is the same table. Therefore, these two query blocks", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyODMzOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452428338", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * ARE the same.\n          \n          \n            \n                 * <em>are</em> the same.", "author": "nschiefer", "createdAt": "2020-07-09T19:02:14Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);\n+\n+    /**\n+     * Determine equality under the additional consideration of an equivalence map between {@link CorrelationIdentifier}s.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a table {@code T} which presumably is the same table. Therefore, these two query blocks\n+     * ARE the same.", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyODQ2OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452428469", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *       method. As we can only ever establish tru equality using equivalence maps, {@code hashCode()}\n          \n          \n            \n                 *       method. As we can only ever establish true equality using equivalence maps, {@code hashCode()}", "author": "nschiefer", "createdAt": "2020-07-09T19:02:31Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);\n+\n+    /**\n+     * Determine equality under the additional consideration of an equivalence map between {@link CorrelationIdentifier}s.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a table {@code T} which presumably is the same table. Therefore, these two query blocks\n+     * ARE the same.\n+     * In the context of this method, we can establish equality between {@code q1.x = 5} and {@code q2.x = 5} if\n+     * we know that {@code q1} and {@code q2} refer to the same underlying entity. The equivalence map passed in\n+     * encodes that equality between {@link CorrelationIdentifier}s.\n+     *\n+     * Note: This method has the same interaction with {@link Object#hashCode()} as the regular {@code equals()}\n+     *       method. As we can only ever establish tru equality using equivalence maps, {@code hashCode()}", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyODU3NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452428575", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *       implementations in implementors of this interface MUST NOT be dependent on any correlation identifiers\n          \n          \n            \n                 *       implementations in implementors of this interface <em>must not</em> be dependent on any correlation identifiers", "author": "nschiefer", "createdAt": "2020-07-09T19:02:43Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);\n+\n+    /**\n+     * Determine equality under the additional consideration of an equivalence map between {@link CorrelationIdentifier}s.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a table {@code T} which presumably is the same table. Therefore, these two query blocks\n+     * ARE the same.\n+     * In the context of this method, we can establish equality between {@code q1.x = 5} and {@code q2.x = 5} if\n+     * we know that {@code q1} and {@code q2} refer to the same underlying entity. The equivalence map passed in\n+     * encodes that equality between {@link CorrelationIdentifier}s.\n+     *\n+     * Note: This method has the same interaction with {@link Object#hashCode()} as the regular {@code equals()}\n+     *       method. As we can only ever establish tru equality using equivalence maps, {@code hashCode()}\n+     *       implementations in implementors of this interface MUST NOT be dependent on any correlation identifiers", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyODgwMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452428800", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *       used in the structure of the entity. Doing so might violate the fundamental assumption:\n          \n          \n            \n                 *       used in the structure of the entity. Doing so might violate the fundamental property of hash codes:", "author": "nschiefer", "createdAt": "2020-07-09T19:03:14Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);\n+\n+    /**\n+     * Determine equality under the additional consideration of an equivalence map between {@link CorrelationIdentifier}s.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a table {@code T} which presumably is the same table. Therefore, these two query blocks\n+     * ARE the same.\n+     * In the context of this method, we can establish equality between {@code q1.x = 5} and {@code q2.x = 5} if\n+     * we know that {@code q1} and {@code q2} refer to the same underlying entity. The equivalence map passed in\n+     * encodes that equality between {@link CorrelationIdentifier}s.\n+     *\n+     * Note: This method has the same interaction with {@link Object#hashCode()} as the regular {@code equals()}\n+     *       method. As we can only ever establish tru equality using equivalence maps, {@code hashCode()}\n+     *       implementations in implementors of this interface MUST NOT be dependent on any correlation identifiers\n+     *       used in the structure of the entity. Doing so might violate the fundamental assumption:", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyODk4NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452428984", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *        {@code id'} used in {@code other} if either they are the same by regular java {@link Object#equals}\n          \n          \n            \n                 *        {@code id'} used in {@code other} if either they are the same by {@link Object#equals}", "author": "nschiefer", "createdAt": "2020-07-09T19:03:39Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);\n+\n+    /**\n+     * Determine equality under the additional consideration of an equivalence map between {@link CorrelationIdentifier}s.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a table {@code T} which presumably is the same table. Therefore, these two query blocks\n+     * ARE the same.\n+     * In the context of this method, we can establish equality between {@code q1.x = 5} and {@code q2.x = 5} if\n+     * we know that {@code q1} and {@code q2} refer to the same underlying entity. The equivalence map passed in\n+     * encodes that equality between {@link CorrelationIdentifier}s.\n+     *\n+     * Note: This method has the same interaction with {@link Object#hashCode()} as the regular {@code equals()}\n+     *       method. As we can only ever establish tru equality using equivalence maps, {@code hashCode()}\n+     *       implementations in implementors of this interface MUST NOT be dependent on any correlation identifiers\n+     *       used in the structure of the entity. Doing so might violate the fundamental assumption:\n+     *       {@code e1.equals(e2, ...) => e1.hashCode() == e2.hashCode()}\n+     *\n+     * @param other the other object to establish equality with\n+     * @param equivalenceMap a map of {@link CorrelationIdentifier}s {@code ids} to {@code ids'}. A correlation\n+     *        identifier {@code id} used in {@code this} should be considered equal to another correlation identifier\n+     *        {@code id'} used in {@code other} if either they are the same by regular java {@link Object#equals}", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyOTEyMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452429123", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                boolean resultEquals(Object other, BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap);\n          \n          \n            \n                boolean resultEquals(@Nullable Object other, @Nonnull BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap);", "author": "nschiefer", "createdAt": "2020-07-09T19:03:55Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);\n+\n+    /**\n+     * Determine equality under the additional consideration of an equivalence map between {@link CorrelationIdentifier}s.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a table {@code T} which presumably is the same table. Therefore, these two query blocks\n+     * ARE the same.\n+     * In the context of this method, we can establish equality between {@code q1.x = 5} and {@code q2.x = 5} if\n+     * we know that {@code q1} and {@code q2} refer to the same underlying entity. The equivalence map passed in\n+     * encodes that equality between {@link CorrelationIdentifier}s.\n+     *\n+     * Note: This method has the same interaction with {@link Object#hashCode()} as the regular {@code equals()}\n+     *       method. As we can only ever establish tru equality using equivalence maps, {@code hashCode()}\n+     *       implementations in implementors of this interface MUST NOT be dependent on any correlation identifiers\n+     *       used in the structure of the entity. Doing so might violate the fundamental assumption:\n+     *       {@code e1.equals(e2, ...) => e1.hashCode() == e2.hashCode()}\n+     *\n+     * @param other the other object to establish equality with\n+     * @param equivalenceMap a map of {@link CorrelationIdentifier}s {@code ids} to {@code ids'}. A correlation\n+     *        identifier {@code id} used in {@code this} should be considered equal to another correlation identifier\n+     *        {@code id'} used in {@code other} if either they are the same by regular java {@link Object#equals}\n+     *        of if there is a mapping from {@code id} to {@code id'}.\n+     * @return {@code true} if both entities are considered equal using the equivalences passed in, {@code false}\n+     *         otherwise\n+     */\n+    boolean resultEquals(Object other, BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap);", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk3NzczOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453977739", "bodyText": "I think it would be nice to wrap up these maps/bimaps into some kind of custom helper object (which can of course be backed by a Guava bimap). It should make a lot of these signatures a lot clearer, at least if it was given a good name (CorrelationTranslationMap?).", "author": "nschiefer", "createdAt": "2020-07-13T22:23:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyOTEyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU1MDczNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457550734", "bodyText": "Done.", "author": "normen662", "createdAt": "2020-07-20T16:46:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyOTEyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyOTI2NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452429265", "bodyText": "I think this should be filled in: :-)", "author": "nschiefer", "createdAt": "2020-07-09T19:04:13Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/CorrelationIdentifier.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * CorrelationIdentifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Objects;\n+import java.util.UUID;\n+\n+/**\n+ * TBD.", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyOTUzMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452429530", "bodyText": "I think, but am not sure, that randomID() is more idiomatic in our code base.", "author": "nschiefer", "createdAt": "2020-07-09T19:04:42Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/CorrelationIdentifier.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * CorrelationIdentifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Objects;\n+import java.util.UUID;\n+\n+/**\n+ * TBD.\n+ */\n+public class CorrelationIdentifier {\n+    @Nonnull final String id;\n+\n+    @Nonnull\n+    public static CorrelationIdentifier of(final String id) {\n+        return new CorrelationIdentifier(id);\n+    }\n+\n+    @Nonnull\n+    public static CorrelationIdentifier randomId() {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQzMDAwNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452430007", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Insert a new expression into this expression ref.\n          \n          \n            \n                 * Insert a new expression into this reference.", "author": "nschiefer", "createdAt": "2020-07-09T19:05:35Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRef.java", "diffHunk": "@@ -36,8 +37,14 @@\n  * @param <T> the type of planner expression that is contained in this reference\n  */\n @API(API.Status.EXPERIMENTAL)\n-public interface ExpressionRef<T extends RelationalExpression> extends Bindable {\n-    void insert(@Nonnull T newValue);\n+public interface ExpressionRef<T extends RelationalExpression> extends Bindable, Correlated<ExpressionRef<T>> {\n+    /**\n+     * Insert a new expression into this expression ref.", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQzMDEzNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452430136", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return {@code true} if the value was not already part of the ref and was inserted, {@code false} if\n          \n          \n            \n                 * @return {@code true} if the value was not already part of the reference and was inserted, {@code false} if", "author": "nschiefer", "createdAt": "2020-07-09T19:05:50Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRef.java", "diffHunk": "@@ -36,8 +37,14 @@\n  * @param <T> the type of planner expression that is contained in this reference\n  */\n @API(API.Status.EXPERIMENTAL)\n-public interface ExpressionRef<T extends RelationalExpression> extends Bindable {\n-    void insert(@Nonnull T newValue);\n+public interface ExpressionRef<T extends RelationalExpression> extends Bindable, Correlated<ExpressionRef<T>> {\n+    /**\n+     * Insert a new expression into this expression ref.\n+     * @param newValue the value to be inserted\n+     * @return {@code true} if the value was not already part of the ref and was inserted, {@code false} if", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQzMDIwNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452430206", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *         the given value was already contained in the ref and was therefore not inserted.\n          \n          \n            \n                 *         the given value was already contained in the reference and was therefore not inserted.", "author": "nschiefer", "createdAt": "2020-07-09T19:05:59Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRef.java", "diffHunk": "@@ -36,8 +37,14 @@\n  * @param <T> the type of planner expression that is contained in this reference\n  */\n @API(API.Status.EXPERIMENTAL)\n-public interface ExpressionRef<T extends RelationalExpression> extends Bindable {\n-    void insert(@Nonnull T newValue);\n+public interface ExpressionRef<T extends RelationalExpression> extends Bindable, Correlated<ExpressionRef<T>> {\n+    /**\n+     * Insert a new expression into this expression ref.\n+     * @param newValue the value to be inserted\n+     * @return {@code true} if the value was not already part of the ref and was inserted, {@code false} if\n+     *         the given value was already contained in the ref and was therefore not inserted.", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQzOTI0Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452439243", "bodyText": "Do we need the extra set of parentheses here?", "author": "nschiefer", "createdAt": "2020-07-09T19:23:35Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/GroupExpressionRef.java", "diffHunk": "@@ -84,73 +92,92 @@ public T get() {\n     }\n \n     @Override\n-    public void insert(@Nonnull T newValue) {\n+    public boolean insert(@Nonnull T newValue) {\n         if (!containsInMemo(newValue)) {\n             members.add(newValue);\n+            return true;\n         }\n+        return false;\n     }\n-\n-    public void insertAll(@Nonnull GroupExpressionRef<T> newValues) {\n-        for (T member : newValues.members) {\n-            insert(member);\n-        }\n-    }\n-\n-    public void removeMemberIfPresent(@Nonnull T member) {\n-        members.remove(member);\n-    }\n-\n-    public void removeMember(@Nonnull T member) {\n-        if (!members.remove(member)) {\n-            throw new RecordCoreArgumentException(\"tried to remove member that isn't present\")\n-                    .addLogInfo(\"member\", member);\n-        }\n-    }\n-\n+    \n+    @SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n     public boolean containsExactly(@Nonnull T expression) {\n         return members.contains(expression);\n     }\n \n     @Override\n-    public boolean containsAllInMemo(@Nonnull ExpressionRef<? extends RelationalExpression> otherRef) {\n-        for (RelationalExpression otherMember : otherRef.getMembers()) {\n-            if (!containsInMemo(otherMember)) {\n+    public boolean containsAllInMemo(@Nonnull final ExpressionRef<? extends RelationalExpression> otherRef,\n+                                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        for (final RelationalExpression otherMember : otherRef.getMembers()) {\n+            if (!containsInMemo(otherMember, equivalenceMap)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n-    public boolean containsInMemo(@Nonnull RelationalExpression expression) {\n-        for (RelationalExpression member : members) {\n-            if (containsInMember(member, expression)) {\n+    public boolean containsInMemo(@Nonnull final RelationalExpression expression) {\n+        return containsInMemo(expression, ImmutableBiMap.of());\n+    }\n+\n+    public boolean containsInMemo(@Nonnull final RelationalExpression expression,\n+                                  @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        for (final RelationalExpression member : members) {\n+            if (containsInMember(member, expression, equivalenceMap)) {\n                 return true;\n             }\n         }\n         return false;\n     }\n \n-    private boolean containsInMember(@Nonnull RelationalExpression member, @Nonnull RelationalExpression otherMember) {\n-        if (!member.equalsWithoutChildren(otherMember)) {\n+    private static boolean containsInMember(@Nonnull RelationalExpression member,\n+                                            @Nonnull RelationalExpression otherMember,\n+                                            @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        if (member.getClass() != otherMember.getClass()) {\n             return false;\n         }\n \n-        final List<? extends Quantifier> memberQuantifiers = member.getQuantifiers();\n-        final List<? extends Quantifier> otherMemberQuantifiers = otherMember.getQuantifiers();\n-        if (memberQuantifiers.size() != otherMemberQuantifiers.size()) {\n+        final Optional<BiMap<Quantifier, Quantifier>> quantifierMapOptional =\n+                member.matchQuantifiers(ImmutableSet.copyOf(otherMember.getQuantifiers()),\n+                        equivalenceMap,\n+                        ((quantifier, otherQuantifier, nestedEquivalencesMap) -> {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0NDEyNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452444127", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public GroupExpressionRef<T> rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public GroupExpressionRef<T> rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "author": "nschiefer", "createdAt": "2020-07-09T19:33:28Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/GroupExpressionRef.java", "diffHunk": "@@ -84,73 +92,92 @@ public T get() {\n     }\n \n     @Override\n-    public void insert(@Nonnull T newValue) {\n+    public boolean insert(@Nonnull T newValue) {\n         if (!containsInMemo(newValue)) {\n             members.add(newValue);\n+            return true;\n         }\n+        return false;\n     }\n-\n-    public void insertAll(@Nonnull GroupExpressionRef<T> newValues) {\n-        for (T member : newValues.members) {\n-            insert(member);\n-        }\n-    }\n-\n-    public void removeMemberIfPresent(@Nonnull T member) {\n-        members.remove(member);\n-    }\n-\n-    public void removeMember(@Nonnull T member) {\n-        if (!members.remove(member)) {\n-            throw new RecordCoreArgumentException(\"tried to remove member that isn't present\")\n-                    .addLogInfo(\"member\", member);\n-        }\n-    }\n-\n+    \n+    @SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n     public boolean containsExactly(@Nonnull T expression) {\n         return members.contains(expression);\n     }\n \n     @Override\n-    public boolean containsAllInMemo(@Nonnull ExpressionRef<? extends RelationalExpression> otherRef) {\n-        for (RelationalExpression otherMember : otherRef.getMembers()) {\n-            if (!containsInMemo(otherMember)) {\n+    public boolean containsAllInMemo(@Nonnull final ExpressionRef<? extends RelationalExpression> otherRef,\n+                                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        for (final RelationalExpression otherMember : otherRef.getMembers()) {\n+            if (!containsInMemo(otherMember, equivalenceMap)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n-    public boolean containsInMemo(@Nonnull RelationalExpression expression) {\n-        for (RelationalExpression member : members) {\n-            if (containsInMember(member, expression)) {\n+    public boolean containsInMemo(@Nonnull final RelationalExpression expression) {\n+        return containsInMemo(expression, ImmutableBiMap.of());\n+    }\n+\n+    public boolean containsInMemo(@Nonnull final RelationalExpression expression,\n+                                  @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        for (final RelationalExpression member : members) {\n+            if (containsInMember(member, expression, equivalenceMap)) {\n                 return true;\n             }\n         }\n         return false;\n     }\n \n-    private boolean containsInMember(@Nonnull RelationalExpression member, @Nonnull RelationalExpression otherMember) {\n-        if (!member.equalsWithoutChildren(otherMember)) {\n+    private static boolean containsInMember(@Nonnull RelationalExpression member,\n+                                            @Nonnull RelationalExpression otherMember,\n+                                            @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        if (member.getClass() != otherMember.getClass()) {\n             return false;\n         }\n \n-        final List<? extends Quantifier> memberQuantifiers = member.getQuantifiers();\n-        final List<? extends Quantifier> otherMemberQuantifiers = otherMember.getQuantifiers();\n-        if (memberQuantifiers.size() != otherMemberQuantifiers.size()) {\n+        final Optional<BiMap<Quantifier, Quantifier>> quantifierMapOptional =\n+                member.matchQuantifiers(ImmutableSet.copyOf(otherMember.getQuantifiers()),\n+                        equivalenceMap,\n+                        ((quantifier, otherQuantifier, nestedEquivalencesMap) -> {\n+                            final ExpressionRef<? extends RelationalExpression> rangesOver = quantifier.getRangesOver();\n+                            final ExpressionRef<? extends RelationalExpression> otherRangesOver = otherQuantifier.getRangesOver();\n+                            return rangesOver.containsAllInMemo(otherRangesOver, nestedEquivalencesMap);\n+                        }));\n+\n+        if (!quantifierMapOptional.isPresent()) {\n             return false;\n         }\n+        final BiMap<Quantifier, Quantifier> quantifierMap = quantifierMapOptional.get();\n \n-        for (int i = 0; i < memberQuantifiers.size(); i++) {\n-            final ExpressionRef<? extends RelationalExpression> memberRangesOver = memberQuantifiers.get(i).getRangesOver();\n-            final ExpressionRef<? extends RelationalExpression> otherMemberRangesOver = otherMemberQuantifiers.get(i).getRangesOver();\n+        return member.equalsWithoutChildren(otherMember,\n+                Quantifiers.compose(equivalenceMap, Quantifiers.toIdMap(quantifierMap)));\n+    }\n \n-            if (!memberRangesOver.containsAllInMemo(otherMemberRangesOver)) {\n-                return false;\n-            }\n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        final ImmutableSet.Builder<CorrelationIdentifier> builder = ImmutableSet.builder();\n+        for (final T member : getMembers()) {\n+            builder.addAll(member.getCorrelatedTo());\n         }\n+        return builder.build();\n+    }\n \n-        return true;\n+    @SuppressWarnings(\"unchecked\")\n+    @Nonnull\n+    @Override\n+    public GroupExpressionRef<T> rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0NDMyMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452444323", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n          \n          \n            \n                public boolean resultEquals(@Nullable final Object other, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "author": "nschiefer", "createdAt": "2020-07-09T19:33:53Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/GroupExpressionRef.java", "diffHunk": "@@ -244,4 +271,36 @@ public String toString() {\n         members.addAll(expressions);\n         return new GroupExpressionRef<>(members);\n     }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0Nzk1MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452447950", "bodyText": "I think this should be filled out.", "author": "nschiefer", "createdAt": "2020-07-09T19:41:14Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -54,16 +59,65 @@\n  * at the owning (join) expression.\n  * </p>\n  */\n-public abstract class Quantifier implements Bindable {\n+@SuppressWarnings(\"unused\")\n+public abstract class Quantifier implements Bindable, Correlated<Quantifier> {\n+    /**\n+     * The alias (some identification) for this quantifier.\n+     */\n+    @Nonnull\n+    private final CorrelationIdentifier alias;\n+\n+    /**\n+     * As a quantifier is immutable the correlated set can be computed lazily and then cached. This supplier\n+     * represents that cached set.\n+     */\n+    @Nonnull\n+    private final Supplier<Set<CorrelationIdentifier>> correlatedToSupplier;\n+\n+    /**\n+     * Builder class for quantifiers.\n+     * @param <Q> quantifier type\n+     * @param <B> builder type\n+     */\n+    public abstract static class Builder<Q extends Quantifier, B extends Builder<Q, B>> {\n+        @Nullable\n+        protected CorrelationIdentifier alias;\n+\n+        @Nonnull\n+        public B from(final Q quantifier) {\n+            return withAlias(quantifier.getAlias());\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Nonnull\n+        public B withAlias(final CorrelationIdentifier alias) {\n+            this.alias = alias;\n+            return (B)this;\n+        }\n+    }\n+\n     /**\n      * A quantifier that conceptually flows one item at a time from the expression it ranges over to\n      * the owning expression.\n      */\n     @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and hashCode() should be overwritten which is not necessary\n     public static final class ForEach extends Quantifier {\n-        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+        @Nonnull private final ExpressionRef<? extends RelationalExpression> rangesOver;\n \n-        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        /**\n+         * TBD.", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0ODIyOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452448228", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public ForEach rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                    public ForEach rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "author": "nschiefer", "createdAt": "2020-07-09T19:41:43Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -78,31 +132,76 @@ private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n         public String getShorthand() {\n             return \"\u0192\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public ForEach rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0ODQ2MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452448460", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Create a builder for a for-each quantifier containing relational\n          \n          \n            \n                 * expressions.\n          \n          \n            \n                 * Create a builder for a for-each quantifier containing relational expressions.", "author": "nschiefer", "createdAt": "2020-07-09T19:42:12Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -78,31 +132,76 @@ private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n         public String getShorthand() {\n             return \"\u0192\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public ForEach rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.forEachBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * Create a builder for a for-each quantifier containing relational\n      * expressions.", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0OTA0OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452449049", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Shorthand to create a for-each quantifier ranging over an expression ref.\n          \n          \n            \n                 * Shorthand to create a for-each quantifier ranging over a reference.", "author": "nschiefer", "createdAt": "2020-07-09T19:43:26Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -78,31 +132,76 @@ private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n         public String getShorthand() {\n             return \"\u0192\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public ForEach rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.forEachBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * Create a builder for a for-each quantifier containing relational\n      * expressions.\n-     * @param rangesOver expression reference to {@link RelationalExpression}s\n-     * @return a for-each quantifier ranging over the given expression reference\n+     * @return a for-each quantifier builder\n      */\n     @Nonnull\n-    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n-        return new ForEach(rangesOver);\n+    public static ForEach.ForEachBuilder forEachBuilder() {\n+        return new ForEach.ForEachBuilder();\n+    }\n+\n+    /**\n+     * Shorthand to create a for-each quantifier ranging over an expression ref.", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0OTA5Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452449096", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param ref the ref\n          \n          \n            \n                 * @param ref the reference", "author": "nschiefer", "createdAt": "2020-07-09T19:43:33Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -78,31 +132,76 @@ private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n         public String getShorthand() {\n             return \"\u0192\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public ForEach rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.forEachBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * Create a builder for a for-each quantifier containing relational\n      * expressions.\n-     * @param rangesOver expression reference to {@link RelationalExpression}s\n-     * @return a for-each quantifier ranging over the given expression reference\n+     * @return a for-each quantifier builder\n      */\n     @Nonnull\n-    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n-        return new ForEach(rangesOver);\n+    public static ForEach.ForEachBuilder forEachBuilder() {\n+        return new ForEach.ForEachBuilder();\n+    }\n+\n+    /**\n+     * Shorthand to create a for-each quantifier ranging over an expression ref.\n+     * @param ref the ref", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ1NzAwOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452457008", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                RelationalExpression rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers);\n          \n          \n            \n                RelationalExpression rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers);", "author": "nschiefer", "createdAt": "2020-07-09T19:59:16Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpressionWithPredicate.java", "diffHunk": "@@ -23,11 +23,16 @@\n import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n \n import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Map;\n \n /**\n  * A (relational) expression that has a predicate on it.\n  */\n public interface RelationalExpressionWithPredicate extends RelationalExpression {\n     @Nonnull\n     QueryPredicate getPredicate();\n+\n+    @Nonnull\n+    RelationalExpression rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers);", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ1NzcwOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452457709", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * to allow skipping at a provided prefix.\n          \n          \n            \n             * to allow skipping to a given prefix.", "author": "nschiefer", "createdAt": "2020-07-09T20:00:41Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e. no infinite loops)\n+ * 4. it iterates all orderings on the fly, i.e. it only stores state (i.e. does not (pre)create the orderings in memory).\n+ *\n+ * {@link TopologicalOrderPermutationIterable} subclasses {@link Iterable} in order to provide an additional feature\n+ * that allows for skipping. Assume we have a set\n+ * <pre>\n+ * {@code\n+ * { a, b, c, d } with constraints { b -> c, b -> d } (c depends on b, d depends on b)\n+ * }\n+ * </pre>\n+ *\n+ * Possible orderings are\n+ * <pre>\n+ * {@code\n+ * (a, b, c, d)\n+ * (a, b, d, c)\n+ * (b, a, c, d)\n+ * (b, a, d, c)\n+ * (b, c, a, d)\n+ * (b, c, d, a)\n+ * (b, d, a, c)\n+ * (b, d, c, a)\n+ * }\n+ * </pre>\n+ *\n+ * Frequently we test for a certain property or perform a particular operation given one possible ordering but it is clear\n+ * that it is not necessary to consider more such orderings that share a common prefix. In the example, it may be\n+ * beneficial to skip the rest of the {@code (b, a, ...)} orderings after the first one was returned\n+ * ({@code (b, a, c, d}). In this case we would like to instruct the iterator to skip all such orderings and continue\n+ * iteration at {@code (b, c, a, d)}. Similarly, we want to skip all orderings starting with {@code (b, ...)} once we\n+ * encountered the first such ordering. This the iterators created by the provided {@link TopologicalOrderPermutationIterable}\n+ * of type {@link TopologicalOrderPermutationIterator} provide a method {@link TopologicalOrderPermutationIterator#skip}\n+ * to allow skipping at a provided prefix.", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2NTc5NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453965794", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param ref the ref\n          \n          \n            \n                 * @param ref the reference", "author": "nschiefer", "createdAt": "2020-07-13T22:05:48Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -78,31 +132,76 @@ private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n         public String getShorthand() {\n             return \"\u0192\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public ForEach rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.forEachBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * Create a builder for a for-each quantifier containing relational\n      * expressions.\n-     * @param rangesOver expression reference to {@link RelationalExpression}s\n-     * @return a for-each quantifier ranging over the given expression reference\n+     * @return a for-each quantifier builder\n      */\n     @Nonnull\n-    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n-        return new ForEach(rangesOver);\n+    public static ForEach.ForEachBuilder forEachBuilder() {\n+        return new ForEach.ForEachBuilder();\n+    }\n+\n+    /**\n+     * Shorthand to create a for-each quantifier ranging over an expression ref.\n+     * @param ref the ref\n+     * @return a new for-each quantifier ranging over {@code ref}\n+     */\n+    @Nonnull\n+    public static ForEach forEach(@Nonnull final ExpressionRef<? extends RelationalExpression> ref) {\n+        return forEachBuilder()\n+                .build(ref);\n+    }\n+\n+    /**\n+     * Shorthand to create a for-each quantifier ranging over an expression ref using a given alias.\n+     * @param ref the ref", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2NTkxMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453965913", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Shorthand to create a for-each quantifier ranging over an expression ref using a given alias.\n          \n          \n            \n                 * Shorthand to create a for-each quantifier ranging over a reference using a given alias.", "author": "nschiefer", "createdAt": "2020-07-13T22:05:58Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -78,31 +132,76 @@ private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n         public String getShorthand() {\n             return \"\u0192\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public ForEach rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.forEachBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * Create a builder for a for-each quantifier containing relational\n      * expressions.\n-     * @param rangesOver expression reference to {@link RelationalExpression}s\n-     * @return a for-each quantifier ranging over the given expression reference\n+     * @return a for-each quantifier builder\n      */\n     @Nonnull\n-    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n-        return new ForEach(rangesOver);\n+    public static ForEach.ForEachBuilder forEachBuilder() {\n+        return new ForEach.ForEachBuilder();\n+    }\n+\n+    /**\n+     * Shorthand to create a for-each quantifier ranging over an expression ref.\n+     * @param ref the ref\n+     * @return a new for-each quantifier ranging over {@code ref}\n+     */\n+    @Nonnull\n+    public static ForEach forEach(@Nonnull final ExpressionRef<? extends RelationalExpression> ref) {\n+        return forEachBuilder()\n+                .build(ref);\n+    }\n+\n+    /**\n+     * Shorthand to create a for-each quantifier ranging over an expression ref using a given alias.", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2NjUxNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453966516", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public Existential rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                    public Existential rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "author": "nschiefer", "createdAt": "2020-07-13T22:06:50Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -117,17 +216,49 @@ private Existential(final ExpressionRef<? extends RelationalExpression> rangesOv\n         public String getShorthand() {\n             return \"\u2203\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public Existential rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2Njg0NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453966844", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Shorthand to create an existential quantifier ranging over an expression ref.\n          \n          \n            \n                 * Shorthand to create an existential quantifier ranging over a reference.", "author": "nschiefer", "createdAt": "2020-07-13T22:07:17Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -117,17 +216,49 @@ private Existential(final ExpressionRef<? extends RelationalExpression> rangesOv\n         public String getShorthand() {\n             return \"\u2203\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public Existential rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.existentialBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * Create a builder for an existential quantifier containing relational\n      * expressions.\n-     * @param rangesOver expression reference to {@link RelationalExpression}s\n-     * @return a for-each quantifier ranging over the given expression reference\n+     * @return an existential quantifier builder\n+     */\n+    @Nonnull\n+    public static Existential.ExistentialBuilder existentialBuilder() {\n+        return new Existential.ExistentialBuilder();\n+    }\n+\n+    /**\n+     * Shorthand to create an existential quantifier ranging over an expression ref.", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2NjkzNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453966934", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param ref the ref\n          \n          \n            \n                 * @param ref the reference", "author": "nschiefer", "createdAt": "2020-07-13T22:07:25Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -117,17 +216,49 @@ private Existential(final ExpressionRef<? extends RelationalExpression> rangesOv\n         public String getShorthand() {\n             return \"\u2203\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public Existential rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.existentialBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * Create a builder for an existential quantifier containing relational\n      * expressions.\n-     * @param rangesOver expression reference to {@link RelationalExpression}s\n-     * @return a for-each quantifier ranging over the given expression reference\n+     * @return an existential quantifier builder\n+     */\n+    @Nonnull\n+    public static Existential.ExistentialBuilder existentialBuilder() {\n+        return new Existential.ExistentialBuilder();\n+    }\n+\n+    /**\n+     * Shorthand to create an existential quantifier ranging over an expression ref.\n+     * @param ref the ref", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2NzA1MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453967050", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static Existential existential(final ExpressionRef<? extends RelationalExpression> ref) {\n          \n          \n            \n                public static Existential existential(@Nonnull final ExpressionRef<? extends RelationalExpression> ref) {", "author": "nschiefer", "createdAt": "2020-07-13T22:07:37Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -117,17 +216,49 @@ private Existential(final ExpressionRef<? extends RelationalExpression> rangesOv\n         public String getShorthand() {\n             return \"\u2203\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public Existential rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.existentialBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * Create a builder for an existential quantifier containing relational\n      * expressions.\n-     * @param rangesOver expression reference to {@link RelationalExpression}s\n-     * @return a for-each quantifier ranging over the given expression reference\n+     * @return an existential quantifier builder\n+     */\n+    @Nonnull\n+    public static Existential.ExistentialBuilder existentialBuilder() {\n+        return new Existential.ExistentialBuilder();\n+    }\n+\n+    /**\n+     * Shorthand to create an existential quantifier ranging over an expression ref.\n+     * @param ref the ref\n+     * @return a new existential quantifier ranging over {@code ref}\n      */\n     @Nonnull\n-    public static Existential existential(@Nonnull final ExpressionRef<? extends RelationalExpression> rangesOver) {\n-        return new Existential(rangesOver);\n+    public static Existential existential(final ExpressionRef<? extends RelationalExpression> ref) {", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2NzMzMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453967333", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Shorthand to create an existential quantifier ranging over an expression ref using a given alias.\n          \n          \n            \n                 * Shorthand to create an existential quantifier ranging over a reference using a given alias.", "author": "nschiefer", "createdAt": "2020-07-13T22:08:02Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -117,17 +216,49 @@ private Existential(final ExpressionRef<? extends RelationalExpression> rangesOv\n         public String getShorthand() {\n             return \"\u2203\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public Existential rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.existentialBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * Create a builder for an existential quantifier containing relational\n      * expressions.\n-     * @param rangesOver expression reference to {@link RelationalExpression}s\n-     * @return a for-each quantifier ranging over the given expression reference\n+     * @return an existential quantifier builder\n+     */\n+    @Nonnull\n+    public static Existential.ExistentialBuilder existentialBuilder() {\n+        return new Existential.ExistentialBuilder();\n+    }\n+\n+    /**\n+     * Shorthand to create an existential quantifier ranging over an expression ref.\n+     * @param ref the ref\n+     * @return a new existential quantifier ranging over {@code ref}\n      */\n     @Nonnull\n-    public static Existential existential(@Nonnull final ExpressionRef<? extends RelationalExpression> rangesOver) {\n-        return new Existential(rangesOver);\n+    public static Existential existential(final ExpressionRef<? extends RelationalExpression> ref) {\n+        return existentialBuilder()\n+                .build(ref);\n+    }\n+\n+    /**\n+     * Shorthand to create an existential quantifier ranging over an expression ref using a given alias.", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2NzQzOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453967438", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param ref the ref\n          \n          \n            \n                 * @param ref the reference", "author": "nschiefer", "createdAt": "2020-07-13T22:08:10Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -117,17 +216,49 @@ private Existential(final ExpressionRef<? extends RelationalExpression> rangesOv\n         public String getShorthand() {\n             return \"\u2203\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public Existential rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.existentialBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * Create a builder for an existential quantifier containing relational\n      * expressions.\n-     * @param rangesOver expression reference to {@link RelationalExpression}s\n-     * @return a for-each quantifier ranging over the given expression reference\n+     * @return an existential quantifier builder\n+     */\n+    @Nonnull\n+    public static Existential.ExistentialBuilder existentialBuilder() {\n+        return new Existential.ExistentialBuilder();\n+    }\n+\n+    /**\n+     * Shorthand to create an existential quantifier ranging over an expression ref.\n+     * @param ref the ref\n+     * @return a new existential quantifier ranging over {@code ref}\n      */\n     @Nonnull\n-    public static Existential existential(@Nonnull final ExpressionRef<? extends RelationalExpression> rangesOver) {\n-        return new Existential(rangesOver);\n+    public static Existential existential(final ExpressionRef<? extends RelationalExpression> ref) {\n+        return existentialBuilder()\n+                .build(ref);\n+    }\n+\n+    /**\n+     * Shorthand to create an existential quantifier ranging over an expression ref using a given alias.\n+     * @param ref the ref", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2ODE3OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453968179", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                         * Often times a for-each quantifier needs to \"turn\" into a physical quantifier e.g. when a logical\n          \n          \n            \n                         * operator is implemented by a physical one.\n          \n          \n            \n                         * Build a new physical quantifier from a for-each quantifier with the same alias.\n          \n          \n            \n                         * Often times a for-each quantifier needs to \"turn\" into a physical quantifier e.g. when a logical\n          \n          \n            \n                         * operator is implemented by a physical one.", "author": "nschiefer", "createdAt": "2020-07-13T22:09:14Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -137,9 +268,32 @@ public static Existential existential(@Nonnull final ExpressionRef<? extends Rel\n      */\n     @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and hashCode() should be overwritten which is not necessary\n     public static final class Physical extends Quantifier {\n-        private final ExpressionRef<? extends RecordQueryPlan> rangesOver;\n+        @Nonnull private final ExpressionRef<? extends RecordQueryPlan> rangesOver;\n+\n+        /**\n+         * Builder subclass for physical quantifiers.\n+         */\n+        public static class PhysicalBuilder extends Builder<Physical, PhysicalBuilder> {\n+            @Nonnull\n+            public Physical build(@Nonnull final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n+                return new Physical(alias == null ? CorrelationIdentifier.randomId() : alias, rangesOver);\n+            }\n+\n+            /**\n+             * Often times a for-each quantifier needs to \"turn\" into a physical quantifier e.g. when a logical\n+             * operator is implemented by a physical one.", "originalCommit": "6eb7142ab316ffbec53e375804118f722f1d2bcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "message": "Resolves #987: introduce concept of correlations (using quantifiers)", "committedDate": "2020-07-21T04:31:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzOTQxOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464639419", "bodyText": "I think you accidentally a word here.\nPerhaps:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n          \n          \n            \n             * what alias (of a quantifier) should be considered equivalent to what other alias (of another quantifier). A quantifier", "author": "nschiefer", "createdAt": "2020-08-03T20:17:16Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzOTU3Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464639577", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * to objects which is desirable while the graph is mutated through transformations. At various points during\n          \n          \n            \n             * to objects, which is desirable as the graph is mutated through transformations. At various points during", "author": "nschiefer", "createdAt": "2020-08-03T20:17:39Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzOTc5Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464639796", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n          \n          \n            \n             * the planning of a query we may want to perform various structural equality comparisons. For example, we might determine if a sub-graph would produce the same result as some other", "author": "nschiefer", "createdAt": "2020-08-03T20:18:11Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzOTkxNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464639914", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n          \n          \n            \n             * we need to determine how two sub-graphs are related to each other (usually equality but also subsumption, etc.).", "author": "nschiefer", "createdAt": "2020-08-03T20:18:28Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MDA1NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464640054", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n          \n          \n            \n             * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent of", "author": "nschiefer", "createdAt": "2020-08-03T20:18:46Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MDI0NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464640245", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n          \n          \n            \n             * each other, or if they are correlated to a mutually external parameter. In these", "author": "nschiefer", "createdAt": "2020-08-03T20:19:12Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MDQwMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464640400", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n          \n          \n            \n             * conceptually empty.\n          \n          \n            \n             * cases the {@code AliasMap} implemented here would be trivial (conceptually empty).", "author": "nschiefer", "createdAt": "2020-08-03T20:19:32Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MDgyOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464640828", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * There are cases, however, that need some care to establish the relationships mentioned before.\n          \n          \n            \n             * There are cases, however, that need some care to establish more complex relationships such as those mentioned above.", "author": "nschiefer", "createdAt": "2020-08-03T20:20:25Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MTA2NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464641065", "bodyText": "This (and other parts like it) need some kind of Javadoc HTML markup. At the very least, we should throw some <pre> tags in there.", "author": "nschiefer", "createdAt": "2020-08-03T20:20:58Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MTUwMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464641500", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n          \n          \n            \n             *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n          \n          \n            \n             *    We wold like to establish, if these graphs are equal or not. Both of them are not complete; that is, we wouldn't\n          \n          \n            \n             *    be able to execute them as-is. The graphs can only be equal with respect to a particular relationship between {@code c1} and {@code c2}.", "author": "nschiefer", "createdAt": "2020-08-03T20:21:55Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MTc4MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464641780", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n          \n          \n            \n             *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.", "author": "nschiefer", "createdAt": "2020-08-03T20:22:31Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MjYxMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464642612", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n          \n          \n            \n             *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n          \n          \n            \n             *    the entire domain of x and y.\n          \n          \n            \n             *    correlated references. If we view a correlated expression as a function of its correlations, then two sub-graph are equivalent if and only if they are identically equal (i.e., equal on their entire domain) when viewed as functions.", "author": "nschiefer", "createdAt": "2020-08-03T20:24:18Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.\n+ *\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    whereas\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is definitely not the same as\n+ *\n+ *            SELECT * FROM S AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    In short, a sub-graph can only be considered equal to another sub-graph if we assume an equality over their\n+ *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n+ *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n+ *    the entire domain of x and y.", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0Mjg5Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464642893", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * When we descend into correlated sub-graphs during an algorithm while we e.g. determine {@link Correlated#resultEquals}\n          \n          \n            \n             * When we descend into correlated sub-graphs during an algorithm while we compute a function like {@link Correlated#resultEquals}", "author": "nschiefer", "createdAt": "2020-08-03T20:24:54Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.\n+ *\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    whereas\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is definitely not the same as\n+ *\n+ *            SELECT * FROM S AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    In short, a sub-graph can only be considered equal to another sub-graph if we assume an equality over their\n+ *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n+ *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n+ *    the entire domain of x and y.\n+ *\n+ * Example 2:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1\n+ *\n+ *    This scenario is somewhat more complicated as it offers more degrees of freedom.\n+ *\n+ *            SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, S AS c1, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ *    This observation is identical to the one in example 1. Due to the commutative nature we also would like to\n+ *    be able to realize that even this is the same:\n+ *\n+ *    SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ * In any case we need to keep track of what's currently considered bound and equal while we traverse the query graph.\n+ * When we descend into correlated sub-graphs during an algorithm while we e.g. determine {@link Correlated#resultEquals}", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MzAzMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464643033", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * we need to have all outside references bound and mapped in some way: Should we treat c1 on the left as c2 on the right\n          \n          \n            \n             * we need to have all outside references bound and mapped in some way: should we treat {@code c1} on the left as {@code c2} on the right", "author": "nschiefer", "createdAt": "2020-08-03T20:25:10Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.\n+ *\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    whereas\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is definitely not the same as\n+ *\n+ *            SELECT * FROM S AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    In short, a sub-graph can only be considered equal to another sub-graph if we assume an equality over their\n+ *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n+ *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n+ *    the entire domain of x and y.\n+ *\n+ * Example 2:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1\n+ *\n+ *    This scenario is somewhat more complicated as it offers more degrees of freedom.\n+ *\n+ *            SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, S AS c1, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ *    This observation is identical to the one in example 1. Due to the commutative nature we also would like to\n+ *    be able to realize that even this is the same:\n+ *\n+ *    SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ * In any case we need to keep track of what's currently considered bound and equal while we traverse the query graph.\n+ * When we descend into correlated sub-graphs during an algorithm while we e.g. determine {@link Correlated#resultEquals}\n+ * we need to have all outside references bound and mapped in some way: Should we treat c1 on the left as c2 on the right", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MzM0NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464643344", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * traversing e.g. permutations of possible mappings.\n          \n          \n            \n             * traversing variation (such as permutations) of possible mappings.", "author": "nschiefer", "createdAt": "2020-08-03T20:25:49Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.\n+ *\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    whereas\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is definitely not the same as\n+ *\n+ *            SELECT * FROM S AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    In short, a sub-graph can only be considered equal to another sub-graph if we assume an equality over their\n+ *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n+ *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n+ *    the entire domain of x and y.\n+ *\n+ * Example 2:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1\n+ *\n+ *    This scenario is somewhat more complicated as it offers more degrees of freedom.\n+ *\n+ *            SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, S AS c1, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ *    This observation is identical to the one in example 1. Due to the commutative nature we also would like to\n+ *    be able to realize that even this is the same:\n+ *\n+ *    SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ * In any case we need to keep track of what's currently considered bound and equal while we traverse the query graph.\n+ * When we descend into correlated sub-graphs during an algorithm while we e.g. determine {@link Correlated#resultEquals}\n+ * we need to have all outside references bound and mapped in some way: Should we treat c1 on the left as c2 on the right\n+ * or the other way around? It is the job of an object of this class to facilitate the construction and the lookup of\n+ * these mappings. Algorithms walking the graph make use of this map, construct and reconstruct assumed equality while\n+ * traversing e.g. permutations of possible mappings.", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MzQyNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464643424", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Another \n          \n          \n            \n             *", "author": "nschiefer", "createdAt": "2020-08-03T20:26:01Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.\n+ *\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    whereas\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is definitely not the same as\n+ *\n+ *            SELECT * FROM S AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    In short, a sub-graph can only be considered equal to another sub-graph if we assume an equality over their\n+ *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n+ *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n+ *    the entire domain of x and y.\n+ *\n+ * Example 2:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1\n+ *\n+ *    This scenario is somewhat more complicated as it offers more degrees of freedom.\n+ *\n+ *            SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, S AS c1, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ *    This observation is identical to the one in example 1. Due to the commutative nature we also would like to\n+ *    be able to realize that even this is the same:\n+ *\n+ *    SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ * In any case we need to keep track of what's currently considered bound and equal while we traverse the query graph.\n+ * When we descend into correlated sub-graphs during an algorithm while we e.g. determine {@link Correlated#resultEquals}\n+ * we need to have all outside references bound and mapped in some way: Should we treat c1 on the left as c2 on the right\n+ * or the other way around? It is the job of an object of this class to facilitate the construction and the lookup of\n+ * these mappings. Algorithms walking the graph make use of this map, construct and reconstruct assumed equality while\n+ * traversing e.g. permutations of possible mappings.\n+ *\n+ * Another \n+ *", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MzQ4MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464643480", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Note: This class is immutable, all perceived \"mutations\" cause a new object to be created.\n          \n          \n            \n             * This class is immutable, all perceived \"mutations\" cause a new object to be created.", "author": "nschiefer", "createdAt": "2020-08-03T20:26:11Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.\n+ *\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    whereas\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is definitely not the same as\n+ *\n+ *            SELECT * FROM S AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    In short, a sub-graph can only be considered equal to another sub-graph if we assume an equality over their\n+ *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n+ *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n+ *    the entire domain of x and y.\n+ *\n+ * Example 2:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1\n+ *\n+ *    This scenario is somewhat more complicated as it offers more degrees of freedom.\n+ *\n+ *            SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, S AS c1, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ *    This observation is identical to the one in example 1. Due to the commutative nature we also would like to\n+ *    be able to realize that even this is the same:\n+ *\n+ *    SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ * In any case we need to keep track of what's currently considered bound and equal while we traverse the query graph.\n+ * When we descend into correlated sub-graphs during an algorithm while we e.g. determine {@link Correlated#resultEquals}\n+ * we need to have all outside references bound and mapped in some way: Should we treat c1 on the left as c2 on the right\n+ * or the other way around? It is the job of an object of this class to facilitate the construction and the lookup of\n+ * these mappings. Algorithms walking the graph make use of this map, construct and reconstruct assumed equality while\n+ * traversing e.g. permutations of possible mappings.\n+ *\n+ * Another \n+ *\n+ * Note: This class is immutable, all perceived \"mutations\" cause a new object to be created.", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0Mzg5MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464643891", "bodyText": "Here and elsewhere, it's not conventional to put any formatting (and especially Markdown formatting) in parameter descriptions. In my experience, it leads to funky Javadocs.", "author": "nschiefer", "createdAt": "2020-08-03T20:27:08Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.\n+ *\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    whereas\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is definitely not the same as\n+ *\n+ *            SELECT * FROM S AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    In short, a sub-graph can only be considered equal to another sub-graph if we assume an equality over their\n+ *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n+ *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n+ *    the entire domain of x and y.\n+ *\n+ * Example 2:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1\n+ *\n+ *    This scenario is somewhat more complicated as it offers more degrees of freedom.\n+ *\n+ *            SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, S AS c1, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ *    This observation is identical to the one in example 1. Due to the commutative nature we also would like to\n+ *    be able to realize that even this is the same:\n+ *\n+ *    SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ * In any case we need to keep track of what's currently considered bound and equal while we traverse the query graph.\n+ * When we descend into correlated sub-graphs during an algorithm while we e.g. determine {@link Correlated#resultEquals}\n+ * we need to have all outside references bound and mapped in some way: Should we treat c1 on the left as c2 on the right\n+ * or the other way around? It is the job of an object of this class to facilitate the construction and the lookup of\n+ * these mappings. Algorithms walking the graph make use of this map, construct and reconstruct assumed equality while\n+ * traversing e.g. permutations of possible mappings.\n+ *\n+ * Another \n+ *\n+ * Note: This class is immutable, all perceived \"mutations\" cause a new object to be created.\n+ *\n+ */\n+public class AliasMap {\n+    private final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> map;\n+\n+    private AliasMap(final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> map) {\n+        this.map = map;\n+    }\n+\n+    public boolean containsSource(@Nonnull final CorrelationIdentifier alias) {\n+        return map.containsKey(alias);\n+    }\n+\n+    public boolean containsTarget(@Nonnull final CorrelationIdentifier alias) {\n+        return map.containsValue(alias);\n+    }\n+\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s that are mapped by this {@code AliasMap}.\n+     * @return a set of {@link CorrelationIdentifier}s that this map contains mappings for.\n+     */\n+    @Nonnull\n+    public Set<CorrelationIdentifier> sources() {\n+        return map.keySet();\n+    }\n+\n+    /**\n+     * Returns the set of all {@link CorrelationIdentifier}s that this map maps to using the set of {@link CorrelationIdentifier}s\n+     * returned by {@link #sources()}.\n+     * @return a set of {@link CorrelationIdentifier}s that this map maps to.\n+     */\n+    @Nonnull\n+    public Set<CorrelationIdentifier> targets() {\n+        return map.values();\n+    }\n+\n+    public int size() {\n+        return map.size();\n+    }\n+\n+    @Nonnull\n+    public Builder derived() {\n+        return new Builder(map);\n+    }\n+\n+    @Nonnull\n+    public Builder derived(int expectedAdditionalElements) {\n+        return new Builder(size() + expectedAdditionalElements).putAll(this);\n+    }\n+\n+    /**\n+     * Compute the composition of two {@link AliasMap}s.\n+     * @param other second alias map\n+     * @return a translation map that maps {@code a -> c} for {@code a, b, c} if {@code a -> b} is contained in {@code first} and {@code b -> c} is contained in {@code second},\n+     *         {@code a -> b} for {@code a, b} if {@code a -> b} in {@code first} and no {@code b -> x} for any {@code x} is contained in {@code second}, and\n+     *         {@code b -> c} for {@code b, c} if {@code a -> x} for any {@code x} is not contained in {@code first} and {@code b -> c} is contained in {@code second}\n+     */\n+    @Nonnull\n+    public AliasMap compose(@Nonnull final AliasMap other) {\n+        final Builder builder =\n+                AliasMap.builder(size() + other.size());\n+\n+        final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> otherMap = other.map;\n+        this.map.forEach((key, value) -> builder.put(key, otherMap.getOrDefault(value, value)));\n+\n+        otherMap.forEach((key, value) -> {\n+            if (!containsSource(key)) {\n+                builder.put(key, value);\n+            }\n+        });\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Method to match up the given sets of correlation identifiers (using an already given equivalence map).\n+     *\n+     * @param aliases aliases of _this_ set", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NDcwMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464644703", "bodyText": "Can we pull this into a named (inner) class? I think it'll ease debugging if this someday shows up in a stack trace or something like that.", "author": "nschiefer", "createdAt": "2020-08-03T20:28:54Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.\n+ *\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    whereas\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is definitely not the same as\n+ *\n+ *            SELECT * FROM S AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    In short, a sub-graph can only be considered equal to another sub-graph if we assume an equality over their\n+ *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n+ *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n+ *    the entire domain of x and y.\n+ *\n+ * Example 2:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1\n+ *\n+ *    This scenario is somewhat more complicated as it offers more degrees of freedom.\n+ *\n+ *            SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, S AS c1, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ *    This observation is identical to the one in example 1. Due to the commutative nature we also would like to\n+ *    be able to realize that even this is the same:\n+ *\n+ *    SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ * In any case we need to keep track of what's currently considered bound and equal while we traverse the query graph.\n+ * When we descend into correlated sub-graphs during an algorithm while we e.g. determine {@link Correlated#resultEquals}\n+ * we need to have all outside references bound and mapped in some way: Should we treat c1 on the left as c2 on the right\n+ * or the other way around? It is the job of an object of this class to facilitate the construction and the lookup of\n+ * these mappings. Algorithms walking the graph make use of this map, construct and reconstruct assumed equality while\n+ * traversing e.g. permutations of possible mappings.\n+ *\n+ * Another \n+ *\n+ * Note: This class is immutable, all perceived \"mutations\" cause a new object to be created.\n+ *\n+ */\n+public class AliasMap {\n+    private final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> map;\n+\n+    private AliasMap(final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> map) {\n+        this.map = map;\n+    }\n+\n+    public boolean containsSource(@Nonnull final CorrelationIdentifier alias) {\n+        return map.containsKey(alias);\n+    }\n+\n+    public boolean containsTarget(@Nonnull final CorrelationIdentifier alias) {\n+        return map.containsValue(alias);\n+    }\n+\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s that are mapped by this {@code AliasMap}.\n+     * @return a set of {@link CorrelationIdentifier}s that this map contains mappings for.\n+     */\n+    @Nonnull\n+    public Set<CorrelationIdentifier> sources() {\n+        return map.keySet();\n+    }\n+\n+    /**\n+     * Returns the set of all {@link CorrelationIdentifier}s that this map maps to using the set of {@link CorrelationIdentifier}s\n+     * returned by {@link #sources()}.\n+     * @return a set of {@link CorrelationIdentifier}s that this map maps to.\n+     */\n+    @Nonnull\n+    public Set<CorrelationIdentifier> targets() {\n+        return map.values();\n+    }\n+\n+    public int size() {\n+        return map.size();\n+    }\n+\n+    @Nonnull\n+    public Builder derived() {\n+        return new Builder(map);\n+    }\n+\n+    @Nonnull\n+    public Builder derived(int expectedAdditionalElements) {\n+        return new Builder(size() + expectedAdditionalElements).putAll(this);\n+    }\n+\n+    /**\n+     * Compute the composition of two {@link AliasMap}s.\n+     * @param other second alias map\n+     * @return a translation map that maps {@code a -> c} for {@code a, b, c} if {@code a -> b} is contained in {@code first} and {@code b -> c} is contained in {@code second},\n+     *         {@code a -> b} for {@code a, b} if {@code a -> b} in {@code first} and no {@code b -> x} for any {@code x} is contained in {@code second}, and\n+     *         {@code b -> c} for {@code b, c} if {@code a -> x} for any {@code x} is not contained in {@code first} and {@code b -> c} is contained in {@code second}\n+     */\n+    @Nonnull\n+    public AliasMap compose(@Nonnull final AliasMap other) {\n+        final Builder builder =\n+                AliasMap.builder(size() + other.size());\n+\n+        final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> otherMap = other.map;\n+        this.map.forEach((key, value) -> builder.put(key, otherMap.getOrDefault(value, value)));\n+\n+        otherMap.forEach((key, value) -> {\n+            if (!containsSource(key)) {\n+                builder.put(key, value);\n+            }\n+        });\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Method to match up the given sets of correlation identifiers (using an already given equivalence map).\n+     *\n+     * @param aliases aliases of _this_ set\n+     * @param dependsOnFn function yielding the dependsOn set for an alias of _this_ set\n+     * @param otherAliases aliases of _the other_ set\n+     * @param otherDependsOnFn function yielding the dependsOn set for an alias of _the other_ set\n+     * @param canCorrelate {@code true} if _this_ set (and the _other_ set) can be the source of correlations themselves.\n+     * @param predicate that tests if two aliases match\n+     * @return An iterable iterating alias maps containing mappings from the correlation identifiers ({@code aliases}) to\n+     *         correlations identifiers {@code otherAliases} according to the given predicate. Note that these mappings\n+     *         are bijective and can therefore be inverted.\n+     */\n+    @SuppressWarnings({\"squid:S135\"})\n+    @Nonnull\n+    public Iterable<AliasMap> match(@Nonnull final Set<CorrelationIdentifier> aliases,\n+                                    @Nonnull final Function<CorrelationIdentifier, Set<CorrelationIdentifier>> dependsOnFn,\n+                                    @Nonnull final Set<CorrelationIdentifier> otherAliases,\n+                                    @Nonnull final Function<CorrelationIdentifier, Set<CorrelationIdentifier>> otherDependsOnFn,\n+                                    final boolean canCorrelate,\n+                                    @Nonnull final MatchingIdPredicate predicate) {\n+        if (aliases.size() != otherAliases.size()) {\n+            return ImmutableList.of();\n+        }\n+\n+        if (aliases.isEmpty()) {\n+            return ImmutableList.of(empty());\n+        }\n+\n+        //\n+        // We do not know which id in \"this\" maps to which in \"other\". In fact, we cannot know as it is\n+        // intentionally modeled this way. We need to find _a_ feasible ordering that matches. In reality, the\n+        // quantifiers owned by an expression imposes a more or less a complete order leaving no room for many\n+        // permutations among unrelated quantifiers. In the worst case, we must enumerate them all. Luckily, most\n+        // algorithms for children have short-circuit semantics, so the uninteresting case where sub-graphs underneath\n+        // quantifiers do not match should be skipped quickly.\n+        //\n+        // get _a_ topologically-sound permutation from other\n+        final Optional<List<CorrelationIdentifier>> otherOrderedOptional =\n+                TopologicalSort.anyTopologicalOrderPermutation(\n+                        otherAliases,\n+                        alias -> Objects.requireNonNull(otherDependsOnFn.apply(alias)));\n+\n+        // There should always be a topologically sound ordering that we can use.\n+        Verify.verify(otherOrderedOptional.isPresent());\n+\n+        final List<CorrelationIdentifier> otherOrdered = otherOrderedOptional.get();\n+\n+        final TopologicalSort.TopologicalOrderPermutationIterable<CorrelationIdentifier> iterable =\n+                TopologicalSort.topologicalOrderPermutations(\n+                        aliases,\n+                        alias -> Objects.requireNonNull(dependsOnFn.apply(alias)));\n+\n+        return () -> {\n+            final TopologicalSort.TopologicalOrderPermutationIterator<CorrelationIdentifier> iterator = iterable.iterator();\n+\n+            return new AbstractIterator<AliasMap>() {", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczMDY1OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464730659", "bodyText": "The follow up to this PR uses this approach much more heavily. I would prefer to go with it for now and then rethink this if necessary.", "author": "normen662", "createdAt": "2020-08-04T00:26:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NDcwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NDk5MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464644990", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static AliasMap identitiesFor(final Set<CorrelationIdentifier> correlationIdentifiers) {\n          \n          \n            \n                public static AliasMap identitiesFor(@Nonnull final Set<CorrelationIdentifier> correlationIdentifiers) {", "author": "nschiefer", "createdAt": "2020-08-03T20:29:30Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.\n+ *\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    whereas\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is definitely not the same as\n+ *\n+ *            SELECT * FROM S AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    In short, a sub-graph can only be considered equal to another sub-graph if we assume an equality over their\n+ *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n+ *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n+ *    the entire domain of x and y.\n+ *\n+ * Example 2:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1\n+ *\n+ *    This scenario is somewhat more complicated as it offers more degrees of freedom.\n+ *\n+ *            SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, S AS c1, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ *    This observation is identical to the one in example 1. Due to the commutative nature we also would like to\n+ *    be able to realize that even this is the same:\n+ *\n+ *    SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ * In any case we need to keep track of what's currently considered bound and equal while we traverse the query graph.\n+ * When we descend into correlated sub-graphs during an algorithm while we e.g. determine {@link Correlated#resultEquals}\n+ * we need to have all outside references bound and mapped in some way: Should we treat c1 on the left as c2 on the right\n+ * or the other way around? It is the job of an object of this class to facilitate the construction and the lookup of\n+ * these mappings. Algorithms walking the graph make use of this map, construct and reconstruct assumed equality while\n+ * traversing e.g. permutations of possible mappings.\n+ *\n+ * Another \n+ *\n+ * Note: This class is immutable, all perceived \"mutations\" cause a new object to be created.\n+ *\n+ */\n+public class AliasMap {\n+    private final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> map;\n+\n+    private AliasMap(final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> map) {\n+        this.map = map;\n+    }\n+\n+    public boolean containsSource(@Nonnull final CorrelationIdentifier alias) {\n+        return map.containsKey(alias);\n+    }\n+\n+    public boolean containsTarget(@Nonnull final CorrelationIdentifier alias) {\n+        return map.containsValue(alias);\n+    }\n+\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s that are mapped by this {@code AliasMap}.\n+     * @return a set of {@link CorrelationIdentifier}s that this map contains mappings for.\n+     */\n+    @Nonnull\n+    public Set<CorrelationIdentifier> sources() {\n+        return map.keySet();\n+    }\n+\n+    /**\n+     * Returns the set of all {@link CorrelationIdentifier}s that this map maps to using the set of {@link CorrelationIdentifier}s\n+     * returned by {@link #sources()}.\n+     * @return a set of {@link CorrelationIdentifier}s that this map maps to.\n+     */\n+    @Nonnull\n+    public Set<CorrelationIdentifier> targets() {\n+        return map.values();\n+    }\n+\n+    public int size() {\n+        return map.size();\n+    }\n+\n+    @Nonnull\n+    public Builder derived() {\n+        return new Builder(map);\n+    }\n+\n+    @Nonnull\n+    public Builder derived(int expectedAdditionalElements) {\n+        return new Builder(size() + expectedAdditionalElements).putAll(this);\n+    }\n+\n+    /**\n+     * Compute the composition of two {@link AliasMap}s.\n+     * @param other second alias map\n+     * @return a translation map that maps {@code a -> c} for {@code a, b, c} if {@code a -> b} is contained in {@code first} and {@code b -> c} is contained in {@code second},\n+     *         {@code a -> b} for {@code a, b} if {@code a -> b} in {@code first} and no {@code b -> x} for any {@code x} is contained in {@code second}, and\n+     *         {@code b -> c} for {@code b, c} if {@code a -> x} for any {@code x} is not contained in {@code first} and {@code b -> c} is contained in {@code second}\n+     */\n+    @Nonnull\n+    public AliasMap compose(@Nonnull final AliasMap other) {\n+        final Builder builder =\n+                AliasMap.builder(size() + other.size());\n+\n+        final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> otherMap = other.map;\n+        this.map.forEach((key, value) -> builder.put(key, otherMap.getOrDefault(value, value)));\n+\n+        otherMap.forEach((key, value) -> {\n+            if (!containsSource(key)) {\n+                builder.put(key, value);\n+            }\n+        });\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Method to match up the given sets of correlation identifiers (using an already given equivalence map).\n+     *\n+     * @param aliases aliases of _this_ set\n+     * @param dependsOnFn function yielding the dependsOn set for an alias of _this_ set\n+     * @param otherAliases aliases of _the other_ set\n+     * @param otherDependsOnFn function yielding the dependsOn set for an alias of _the other_ set\n+     * @param canCorrelate {@code true} if _this_ set (and the _other_ set) can be the source of correlations themselves.\n+     * @param predicate that tests if two aliases match\n+     * @return An iterable iterating alias maps containing mappings from the correlation identifiers ({@code aliases}) to\n+     *         correlations identifiers {@code otherAliases} according to the given predicate. Note that these mappings\n+     *         are bijective and can therefore be inverted.\n+     */\n+    @SuppressWarnings({\"squid:S135\"})\n+    @Nonnull\n+    public Iterable<AliasMap> match(@Nonnull final Set<CorrelationIdentifier> aliases,\n+                                    @Nonnull final Function<CorrelationIdentifier, Set<CorrelationIdentifier>> dependsOnFn,\n+                                    @Nonnull final Set<CorrelationIdentifier> otherAliases,\n+                                    @Nonnull final Function<CorrelationIdentifier, Set<CorrelationIdentifier>> otherDependsOnFn,\n+                                    final boolean canCorrelate,\n+                                    @Nonnull final MatchingIdPredicate predicate) {\n+        if (aliases.size() != otherAliases.size()) {\n+            return ImmutableList.of();\n+        }\n+\n+        if (aliases.isEmpty()) {\n+            return ImmutableList.of(empty());\n+        }\n+\n+        //\n+        // We do not know which id in \"this\" maps to which in \"other\". In fact, we cannot know as it is\n+        // intentionally modeled this way. We need to find _a_ feasible ordering that matches. In reality, the\n+        // quantifiers owned by an expression imposes a more or less a complete order leaving no room for many\n+        // permutations among unrelated quantifiers. In the worst case, we must enumerate them all. Luckily, most\n+        // algorithms for children have short-circuit semantics, so the uninteresting case where sub-graphs underneath\n+        // quantifiers do not match should be skipped quickly.\n+        //\n+        // get _a_ topologically-sound permutation from other\n+        final Optional<List<CorrelationIdentifier>> otherOrderedOptional =\n+                TopologicalSort.anyTopologicalOrderPermutation(\n+                        otherAliases,\n+                        alias -> Objects.requireNonNull(otherDependsOnFn.apply(alias)));\n+\n+        // There should always be a topologically sound ordering that we can use.\n+        Verify.verify(otherOrderedOptional.isPresent());\n+\n+        final List<CorrelationIdentifier> otherOrdered = otherOrderedOptional.get();\n+\n+        final TopologicalSort.TopologicalOrderPermutationIterable<CorrelationIdentifier> iterable =\n+                TopologicalSort.topologicalOrderPermutations(\n+                        aliases,\n+                        alias -> Objects.requireNonNull(dependsOnFn.apply(alias)));\n+\n+        return () -> {\n+            final TopologicalSort.TopologicalOrderPermutationIterator<CorrelationIdentifier> iterator = iterable.iterator();\n+\n+            return new AbstractIterator<AliasMap>() {\n+                @Override\n+                protected AliasMap computeNext() {\n+                    while (iterator.hasNext()) {\n+                        final Builder equivalenceMapBuilder = derived(aliases.size());\n+\n+                        final List<CorrelationIdentifier> ordered = iterator.next();\n+                        int i;\n+                        for (i = 0; i < aliases.size(); i++) {\n+                            final CorrelationIdentifier alias = ordered.get(i);\n+                            final CorrelationIdentifier otherAlias = otherOrdered.get(i);\n+\n+                            if (canCorrelate) {\n+                                // We now amend the equivalences passed in by adding the already known bound aliases left\n+                                // of i and make them equivalent as well\n+                                equivalenceMapBuilder.put(alias, otherAlias);\n+                            }\n+\n+                            if (!predicate.test(alias, otherAlias, equivalenceMapBuilder.build())) {\n+                                break;\n+                            }\n+                        }\n+\n+                        if (i == aliases.size()) {\n+                            // zip ordered and otherOrdered as they now match\n+                            return zip(ordered, otherOrdered);\n+                        } else {\n+                            // we can skip all permutations where the i-th value is bound the way it currently is\n+                            iterator.skip(i);\n+                        }\n+                    }\n+\n+                    return endOfData();\n+                }\n+            };\n+        };\n+    }\n+\n+    @Nonnull\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Nonnull\n+    public static Builder builder(final int expectedSize) {\n+        return new Builder(expectedSize);\n+    }\n+\n+    @Nonnull\n+    public static AliasMap empty() {\n+        return new AliasMap(ImmutableBiMap.of());\n+    }\n+\n+    @Nonnull\n+    public static AliasMap of(@Nonnull final CorrelationIdentifier source, @Nonnull final CorrelationIdentifier target) {\n+        return new AliasMap(ImmutableBiMap.of(source, target));\n+    }\n+\n+    @Nonnull\n+    public static AliasMap of(@Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> map) {\n+        return new AliasMap(ImmutableBiMap.copyOf(map));\n+    }\n+\n+    @Nonnull\n+    public static AliasMap identitiesFor(final Set<CorrelationIdentifier> correlationIdentifiers) {", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NTE0Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464645143", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public AliasMap build() {\n          \n          \n            \n                    @Nonnull\n          \n          \n            \n                    public AliasMap build() {", "author": "nschiefer", "createdAt": "2020-08-03T20:29:49Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.\n+ *\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    whereas\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is definitely not the same as\n+ *\n+ *            SELECT * FROM S AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    In short, a sub-graph can only be considered equal to another sub-graph if we assume an equality over their\n+ *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n+ *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n+ *    the entire domain of x and y.\n+ *\n+ * Example 2:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1\n+ *\n+ *    This scenario is somewhat more complicated as it offers more degrees of freedom.\n+ *\n+ *            SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, S AS c1, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ *    This observation is identical to the one in example 1. Due to the commutative nature we also would like to\n+ *    be able to realize that even this is the same:\n+ *\n+ *    SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ * In any case we need to keep track of what's currently considered bound and equal while we traverse the query graph.\n+ * When we descend into correlated sub-graphs during an algorithm while we e.g. determine {@link Correlated#resultEquals}\n+ * we need to have all outside references bound and mapped in some way: Should we treat c1 on the left as c2 on the right\n+ * or the other way around? It is the job of an object of this class to facilitate the construction and the lookup of\n+ * these mappings. Algorithms walking the graph make use of this map, construct and reconstruct assumed equality while\n+ * traversing e.g. permutations of possible mappings.\n+ *\n+ * Another \n+ *\n+ * Note: This class is immutable, all perceived \"mutations\" cause a new object to be created.\n+ *\n+ */\n+public class AliasMap {\n+    private final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> map;\n+\n+    private AliasMap(final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> map) {\n+        this.map = map;\n+    }\n+\n+    public boolean containsSource(@Nonnull final CorrelationIdentifier alias) {\n+        return map.containsKey(alias);\n+    }\n+\n+    public boolean containsTarget(@Nonnull final CorrelationIdentifier alias) {\n+        return map.containsValue(alias);\n+    }\n+\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s that are mapped by this {@code AliasMap}.\n+     * @return a set of {@link CorrelationIdentifier}s that this map contains mappings for.\n+     */\n+    @Nonnull\n+    public Set<CorrelationIdentifier> sources() {\n+        return map.keySet();\n+    }\n+\n+    /**\n+     * Returns the set of all {@link CorrelationIdentifier}s that this map maps to using the set of {@link CorrelationIdentifier}s\n+     * returned by {@link #sources()}.\n+     * @return a set of {@link CorrelationIdentifier}s that this map maps to.\n+     */\n+    @Nonnull\n+    public Set<CorrelationIdentifier> targets() {\n+        return map.values();\n+    }\n+\n+    public int size() {\n+        return map.size();\n+    }\n+\n+    @Nonnull\n+    public Builder derived() {\n+        return new Builder(map);\n+    }\n+\n+    @Nonnull\n+    public Builder derived(int expectedAdditionalElements) {\n+        return new Builder(size() + expectedAdditionalElements).putAll(this);\n+    }\n+\n+    /**\n+     * Compute the composition of two {@link AliasMap}s.\n+     * @param other second alias map\n+     * @return a translation map that maps {@code a -> c} for {@code a, b, c} if {@code a -> b} is contained in {@code first} and {@code b -> c} is contained in {@code second},\n+     *         {@code a -> b} for {@code a, b} if {@code a -> b} in {@code first} and no {@code b -> x} for any {@code x} is contained in {@code second}, and\n+     *         {@code b -> c} for {@code b, c} if {@code a -> x} for any {@code x} is not contained in {@code first} and {@code b -> c} is contained in {@code second}\n+     */\n+    @Nonnull\n+    public AliasMap compose(@Nonnull final AliasMap other) {\n+        final Builder builder =\n+                AliasMap.builder(size() + other.size());\n+\n+        final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> otherMap = other.map;\n+        this.map.forEach((key, value) -> builder.put(key, otherMap.getOrDefault(value, value)));\n+\n+        otherMap.forEach((key, value) -> {\n+            if (!containsSource(key)) {\n+                builder.put(key, value);\n+            }\n+        });\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Method to match up the given sets of correlation identifiers (using an already given equivalence map).\n+     *\n+     * @param aliases aliases of _this_ set\n+     * @param dependsOnFn function yielding the dependsOn set for an alias of _this_ set\n+     * @param otherAliases aliases of _the other_ set\n+     * @param otherDependsOnFn function yielding the dependsOn set for an alias of _the other_ set\n+     * @param canCorrelate {@code true} if _this_ set (and the _other_ set) can be the source of correlations themselves.\n+     * @param predicate that tests if two aliases match\n+     * @return An iterable iterating alias maps containing mappings from the correlation identifiers ({@code aliases}) to\n+     *         correlations identifiers {@code otherAliases} according to the given predicate. Note that these mappings\n+     *         are bijective and can therefore be inverted.\n+     */\n+    @SuppressWarnings({\"squid:S135\"})\n+    @Nonnull\n+    public Iterable<AliasMap> match(@Nonnull final Set<CorrelationIdentifier> aliases,\n+                                    @Nonnull final Function<CorrelationIdentifier, Set<CorrelationIdentifier>> dependsOnFn,\n+                                    @Nonnull final Set<CorrelationIdentifier> otherAliases,\n+                                    @Nonnull final Function<CorrelationIdentifier, Set<CorrelationIdentifier>> otherDependsOnFn,\n+                                    final boolean canCorrelate,\n+                                    @Nonnull final MatchingIdPredicate predicate) {\n+        if (aliases.size() != otherAliases.size()) {\n+            return ImmutableList.of();\n+        }\n+\n+        if (aliases.isEmpty()) {\n+            return ImmutableList.of(empty());\n+        }\n+\n+        //\n+        // We do not know which id in \"this\" maps to which in \"other\". In fact, we cannot know as it is\n+        // intentionally modeled this way. We need to find _a_ feasible ordering that matches. In reality, the\n+        // quantifiers owned by an expression imposes a more or less a complete order leaving no room for many\n+        // permutations among unrelated quantifiers. In the worst case, we must enumerate them all. Luckily, most\n+        // algorithms for children have short-circuit semantics, so the uninteresting case where sub-graphs underneath\n+        // quantifiers do not match should be skipped quickly.\n+        //\n+        // get _a_ topologically-sound permutation from other\n+        final Optional<List<CorrelationIdentifier>> otherOrderedOptional =\n+                TopologicalSort.anyTopologicalOrderPermutation(\n+                        otherAliases,\n+                        alias -> Objects.requireNonNull(otherDependsOnFn.apply(alias)));\n+\n+        // There should always be a topologically sound ordering that we can use.\n+        Verify.verify(otherOrderedOptional.isPresent());\n+\n+        final List<CorrelationIdentifier> otherOrdered = otherOrderedOptional.get();\n+\n+        final TopologicalSort.TopologicalOrderPermutationIterable<CorrelationIdentifier> iterable =\n+                TopologicalSort.topologicalOrderPermutations(\n+                        aliases,\n+                        alias -> Objects.requireNonNull(dependsOnFn.apply(alias)));\n+\n+        return () -> {\n+            final TopologicalSort.TopologicalOrderPermutationIterator<CorrelationIdentifier> iterator = iterable.iterator();\n+\n+            return new AbstractIterator<AliasMap>() {\n+                @Override\n+                protected AliasMap computeNext() {\n+                    while (iterator.hasNext()) {\n+                        final Builder equivalenceMapBuilder = derived(aliases.size());\n+\n+                        final List<CorrelationIdentifier> ordered = iterator.next();\n+                        int i;\n+                        for (i = 0; i < aliases.size(); i++) {\n+                            final CorrelationIdentifier alias = ordered.get(i);\n+                            final CorrelationIdentifier otherAlias = otherOrdered.get(i);\n+\n+                            if (canCorrelate) {\n+                                // We now amend the equivalences passed in by adding the already known bound aliases left\n+                                // of i and make them equivalent as well\n+                                equivalenceMapBuilder.put(alias, otherAlias);\n+                            }\n+\n+                            if (!predicate.test(alias, otherAlias, equivalenceMapBuilder.build())) {\n+                                break;\n+                            }\n+                        }\n+\n+                        if (i == aliases.size()) {\n+                            // zip ordered and otherOrdered as they now match\n+                            return zip(ordered, otherOrdered);\n+                        } else {\n+                            // we can skip all permutations where the i-th value is bound the way it currently is\n+                            iterator.skip(i);\n+                        }\n+                    }\n+\n+                    return endOfData();\n+                }\n+            };\n+        };\n+    }\n+\n+    @Nonnull\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Nonnull\n+    public static Builder builder(final int expectedSize) {\n+        return new Builder(expectedSize);\n+    }\n+\n+    @Nonnull\n+    public static AliasMap empty() {\n+        return new AliasMap(ImmutableBiMap.of());\n+    }\n+\n+    @Nonnull\n+    public static AliasMap of(@Nonnull final CorrelationIdentifier source, @Nonnull final CorrelationIdentifier target) {\n+        return new AliasMap(ImmutableBiMap.of(source, target));\n+    }\n+\n+    @Nonnull\n+    public static AliasMap of(@Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> map) {\n+        return new AliasMap(ImmutableBiMap.copyOf(map));\n+    }\n+\n+    @Nonnull\n+    public static AliasMap identitiesFor(final Set<CorrelationIdentifier> correlationIdentifiers) {\n+        return new AliasMap(correlationIdentifiers.stream()\n+                .collect(ImmutableBiMap.toImmutableBiMap(Function.identity(), Function.identity())));\n+    }\n+\n+    @SuppressWarnings(\"UnstableApiUsage\")\n+    @Nonnull\n+    public static AliasMap zip(@Nonnull final List<CorrelationIdentifier> left, @Nonnull final List<CorrelationIdentifier> right) {\n+        return new AliasMap(Streams.zip(left.stream(), right.stream(),\n+                (l, r) -> Pair.of(Objects.requireNonNull(l), Objects.requireNonNull(r)))\n+                .collect(ImmutableBiMap.toImmutableBiMap(Pair::getLeft, Pair::getRight)));\n+    }\n+\n+    /**\n+     * Builder class for the {@link AliasMap}.\n+     */\n+    public static class Builder {\n+        private final HashBiMap<CorrelationIdentifier, CorrelationIdentifier> map;\n+\n+        private Builder() {\n+            this.map = HashBiMap.create();\n+        }\n+\n+        private Builder(final int expectedSize) {\n+            this.map = HashBiMap.create(expectedSize);\n+        }\n+\n+        private Builder(final BiMap<CorrelationIdentifier, CorrelationIdentifier> map) {\n+            this.map = HashBiMap.create(map);\n+        }\n+\n+        @Nonnull\n+        public Builder put(@Nonnull final CorrelationIdentifier source, @Nonnull final CorrelationIdentifier target) {\n+            map.put(source, target);\n+            return this;\n+        }\n+\n+        @Nonnull\n+        public Builder putAll(@Nonnull final AliasMap other) {\n+            map.putAll(other.map);\n+            return this;\n+        }\n+\n+        public AliasMap build() {", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MDQ3MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464650471", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                RelationalExpression rebaseWithRebasedQuantifiers(final AliasMap translationMap, final List<Quantifier> rebasedQuantifiers);\n          \n          \n            \n                RelationalExpression rebaseWithRebasedQuantifiers(@Nonnull final AliasMap translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers);\n          \n      \n    \n    \n  \n\nSame for all implementations", "author": "nschiefer", "createdAt": "2020-08-03T20:40:53Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpressionWithPredicate.java", "diffHunk": "@@ -23,11 +23,15 @@\n import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n \n import javax.annotation.Nonnull;\n+import java.util.List;\n \n /**\n  * A (relational) expression that has a predicate on it.\n  */\n public interface RelationalExpressionWithPredicate extends RelationalExpression {\n     @Nonnull\n     QueryPredicate getPredicate();\n+\n+    @Nonnull\n+    RelationalExpression rebaseWithRebasedQuantifiers(final AliasMap translationMap, final List<Quantifier> rebasedQuantifiers);", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MDkzMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464650931", "bodyText": "Let's format this as an <ol> so that it looks nice in the Javadocs.", "author": "nschiefer", "createdAt": "2020-08-03T20:41:50Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,716 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e., no infinite loops)\n+ * 4. it iterates all orderings on the fly. That is, it stores only the position of the iteration and does not (pre)create\n+ *    the orderings in memory.", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MTU4OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464651589", "bodyText": "I assume this is leftover from various performance experiments?", "author": "nschiefer", "createdAt": "2020-08-03T20:43:16Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,716 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e., no infinite loops)\n+ * 4. it iterates all orderings on the fly. That is, it stores only the position of the iteration and does not (pre)create\n+ *    the orderings in memory.\n+ *\n+ * {@link TopologicalOrderPermutationIterable} subclasses {@link Iterable} in order to provide an additional feature\n+ * that allows for skipping. Assume we have a set\n+ * <pre>\n+ * {@code\n+ * { a, b, c, d } with constraints { b -> c, b -> d } (c depends on b, d depends on b)\n+ * }\n+ * </pre>\n+ *\n+ * Possible orderings are\n+ * <pre>\n+ * {@code\n+ * (a, b, c, d)\n+ * (a, b, d, c)\n+ * (b, a, c, d)\n+ * (b, a, d, c)\n+ * (b, c, a, d)\n+ * (b, c, d, a)\n+ * (b, d, a, c)\n+ * (b, d, c, a)\n+ * }\n+ * </pre>\n+ *\n+ * Frequently we test for a certain property or perform a particular operation given one possible ordering but it is clear\n+ * that it is not necessary to consider more such orderings that share a common prefix. In the example, it may be\n+ * beneficial to skip the rest of the {@code (b, a, ...)} orderings after the first one was returned\n+ * ({@code (b, a, c, d}). In this case we would like to instruct the iterator to skip all such orderings and continue\n+ * iteration at {@code (b, c, a, d)}. Similarly, we want to skip all orderings starting with {@code (b, ...)} once we\n+ * encountered the first such ordering. This the iterators created by the provided {@link TopologicalOrderPermutationIterable}\n+ * of type {@link TopologicalOrderPermutationIterator} provide a method {@link TopologicalOrderPermutationIterator#skip}\n+ * to allow skipping to a given prefix.\n+ *\n+ */\n+public class TopologicalSort {\n+    /**\n+     * Iterable that provides special iterators of type {@link TopologicalOrderPermutationIterator}.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterable<T> extends Iterable<List<T>> {\n+        @Nonnull\n+        @Override\n+        TopologicalOrderPermutationIterator<T> iterator();\n+    }\n+\n+    /**\n+     * An iterator extending {@link Iterator} providing the ability to skip a certain prefix.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterator<T> extends Iterator<List<T>> {\n+        /**\n+         * Instructs the iterator to advance to the next possible ordering using the given zero-indexed level.\n+         *\n+         * Example 1: If the last returned ordering of the iterator {@code it} is {@code (e0, e1, e2, e3)} and\n+         *            {@code it.skip(2)} is called, the state of the iterator is advanced in a way that either\n+         *            reaches the end of iteration or the next item that is returned is {@code (e0', e1', e3', e4')}\n+         *            where the prefix {@code (e1', e2', e3')} is not equal to {code (e1, e2, e3)}.\n+         * Example 2: If the last returned ordering of the iterator {@code it} is {@code (e1, e2, e3, e4)} and\n+         *            {@code it.skip(1)} is called, the state of the iterator is advanced in a way that either reaches\n+         *            the end of iteration or the next item that is returned is {@code (e1', e2', e3', e4')} where\n+         *            the prefix {@code (e1', e2')} is not equal to {code (e1, e2)}.\n+         *\n+         * @param level skip level\n+         */\n+        void skip(int level);\n+    }\n+\n+    /**\n+     * A complex iterable implementing {@link TopologicalOrderPermutationIterable} that is used for sets of cardinality greater\n+     * than 1 (i.e., the regular case).\n+     * @param <T> type\n+     */\n+    private static class BacktrackIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        @Nonnull\n+        private final ImmutableSet<T> set;\n+        @Nonnull\n+        private final SetMultimap<T, T> dependsOnMap;\n+\n+        private class BacktrackIterator extends AbstractIterator<List<T>> implements TopologicalSort.TopologicalOrderPermutationIterator<T> {\n+            // state\n+            private final Set<T> bound;\n+            private final List<PeekingIterator<T>> state;\n+\n+            private BacktrackIterator() {\n+                this.bound = Sets.newHashSetWithExpectedSize(set.size());\n+                this.state = Lists.newArrayListWithCapacity(set.size());\n+                for (int i = 0; i < set.size(); i ++ ) {\n+                    this.state.add(null);\n+                }\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                //\n+                // Iterating through all possible correct orderings of set is inherently easier to encode recursively,\n+                // however, this being an iterator together with the requirement to skip subtrees of iterations warrants\n+                // an iterative solution. All hail the Church-Turing thesis!\n+                //\n+                if (set.isEmpty()) {\n+                    return endOfData();\n+                }\n+\n+                //\n+                // If nothing is bound yet, we are at the beginning and should start at level 0, otherwise\n+                // we conceptually start at the level of the finest granularity bound. Note that that finest\n+                // granularity is usually the granularity of the last element in the set, but it is possible\n+                // for fewer elements to be bound if this is the first call after a skip.\n+                //\n+                int currentLevel = bound.isEmpty() ? 0 : bound.size() - 1;\n+\n+                //\n+                // For each permutation of elements we return, we need to bind n elements (n == set.size()).\n+                // We maintain an iterator through the set (that is stable) for each level up to currentLevel.\n+                // That's the state! The iterator for levels greater than currentLevel must be null. The iterators\n+                // for levels below current level must be on a valid element. The iterator for the currentLevel\n+                // maybe null or a valid element.\n+                //\n+\n+                //\n+                // We also use a set \"bound\" that keeps elements that are currently bound by iterators.\n+                // \"bound\" is solely kept for convenience and is entirely computable from the current\n+                // state of all iterators. We must keep it in sync with the state of the iterators at all times.\n+                //\n+                do {\n+                    //\n+                    // Set the currentIterator. That is the iterator at level currentLevel. If it is null,\n+                    // we create a new iterator over the set.\n+                    //\n+                    final PeekingIterator<T> currentIterator;\n+                    if (state.get(currentLevel) == null) {\n+                        currentIterator = Iterators.peekingIterator(set.iterator());\n+                        state.set(currentLevel, currentIterator);\n+                    } else {\n+                        currentIterator = state.get(currentLevel);\n+                        unbind(currentLevel);\n+                        currentIterator.next();\n+                    }\n+\n+                    //\n+                    // Search currentLevel for a next item that does not violate any constraints. Doing so\n+                    // may exhaust currentIterator in which case we couldn't find another element on the current level.\n+                    // In that case we need to abandon the current level and search on the level above (making that\n+                    // level the current level). If we reach level -1 (i.e., we reach the end of the iterator at level 0\n+                    // we are done.\n+                    // If we do find an element not violating any constraints on the current level we conceptually\n+                    // bind it the element we found and continue on downward.\n+                    //\n+                    final boolean isDown = searchLevel(currentIterator);\n+                    if (!isDown) {\n+                        // back tracking -- need to clear out the current iterator\n+                        state.set(currentLevel, null);\n+                    }\n+                    currentLevel = isDown\n+                                   ? currentLevel + 1\n+                                   : currentLevel - 1;\n+                    \n+                    if (currentLevel == -1) {\n+                        return endOfData();\n+                    }\n+                } while (bound.size() < set.size()); // as long as we still have to find a binding\n+\n+                return state.stream()\n+                        .map(PeekingIterator::peek)\n+                        .collect(ImmutableList.toImmutableList());\n+            }\n+\n+            @SuppressWarnings({\"squid:S135\", \"PMD.AvoidBranchingStatementAsLastInLoop\"})\n+            private boolean searchLevel(final PeekingIterator<T> currentIterator) {\n+                while (currentIterator.hasNext()) {\n+                    final T next = currentIterator.peek();\n+\n+                    // check if it is bound already; t is invisible to this loop if it is bound\n+                    if (bound.contains(next)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    //\n+                    // Check if t is only dependent on elements in the current bound set, if it is not it must come later.\n+                    // Note that the intersection removes elements the current element depends on that are not in set.\n+                    // That behavior is for convenience reasons and and specifically not an error.\n+                    //\n+                    final Set<T> dependsOn = Sets.intersection(set, dependsOnMap.get(next));\n+                    if (!bound.containsAll(dependsOn)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    // this level can be bound now\n+                    bound.add(next);\n+                    return true; // go down\n+                }\n+                return false; // go up\n+            }\n+\n+            private void unbind(final int level) {\n+                // reset all the following ones\n+                for (int i = level; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            /**\n+             * Method that skips advances to the next element on the given zero-indexed level.\n+             * @param level level to advance\n+             */\n+            @Override\n+            public void skip(final int level) {\n+                if (level >= set.size()) {\n+                    throw new IndexOutOfBoundsException();\n+                }\n+\n+                if (state.get(level) == null) {\n+                    throw new UnsupportedOperationException(\"cannot skip/unbind as level is not bound at all\");\n+                }\n+\n+                // reset all the following ones\n+                for (int i = level + 1; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                        state.set(i, null);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private BacktrackIterable(@Nonnull final Set<T> set, @Nonnull final SetMultimap<T, T> dependsOnMap) {\n+            Verify.verify(set.size() > 1);\n+            this.set = ImmutableSet.copyOf(set);\n+            this.dependsOnMap = dependsOnMap;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new BacktrackIterator();\n+        }\n+    }\n+\n+    /**\n+     * A complex iterable implementing a {@link TopologicalOrderPermutationIterable} that is used for sets of cardinality greater\n+     * than 1 (i.e., the regular case).\n+     * @param <T> type\n+     */\n+    private static class KahnIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        @Nonnull\n+        private final ImmutableSet<T> set;\n+        @Nonnull\n+        private final SetMultimap<T, T> usedByMap;\n+\n+        private class KahnIterator extends AbstractIterator<List<T>> implements TopologicalOrderPermutationIterator<T> {\n+            // state\n+            private final Set<T> bound;\n+            private final Map<T, Integer> inDegreeMap;\n+            private final List<Set<T>> eligibleElementSets;\n+            private final List<PeekingIterator<T>> iterators;\n+\n+            private KahnIterator() {\n+                this.bound = Sets.newHashSetWithExpectedSize(set.size());\n+                this.inDegreeMap = computeInDegreeMap();\n+                this.eligibleElementSets = Lists.newArrayListWithCapacity(set.size());\n+                // add the set of immediately satisfiable sets\n+                this.eligibleElementSets\n+                        .add(this.inDegreeMap\n+                                .entrySet()\n+                                .stream()\n+                                .filter(entry -> entry.getValue() == 0)\n+                                .map(Map.Entry::getKey)\n+                                .collect(ImmutableSet.toImmutableSet()));\n+                for (int i = 1; i < set.size(); i ++ ) {\n+                    this.eligibleElementSets.add(null);\n+                }\n+                this.iterators = Lists.newArrayListWithCapacity(set.size());\n+                for (int i = 0; i < set.size(); i ++ ) {\n+                    this.iterators.add(null);\n+                }\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                //\n+                // Iterating through all possible correct orderings of set is inherently easier to encode recursively,\n+                // however, this being an iterator together with the requirement to skip subtrees of iterations warrants\n+                // an iterative solution. All hail the Church-Turing thesis!\n+                //\n+                if (set.isEmpty()) {\n+                    return endOfData();\n+                }\n+\n+                //\n+                // If nothing is bound yet, we are at the beginning and should start at level 0, otherwise\n+                // we conceptually start at the level of the finest granularity bound. Note that that finest\n+                // granularity is usually the granularity of the last element in the set, but it is possible\n+                // for fewer elements to be bound if this is the first call after a skip.\n+                //\n+                int currentLevel = bound.isEmpty() ? 0 : bound.size() - 1;\n+\n+                //\n+                // For each permutation of elements we return, we need to bind n elements (n == set.size()).\n+                // We maintain an iterator through the set (that is stable) for each level up to currentLevel.\n+                // That's the state! The iterator for levels greater than currentLevel must be null. The iterators\n+                // for levels below current level must be on a valid element. The iterator for the currentLevel\n+                // maybe null or a valid element.\n+                //\n+\n+                //\n+                // We also use a set \"bound\" that keeps elements that are currently bound by iterators.\n+                // \"bound\" is solely kept for convenience and is entirely computable from the current\n+                // state of all iterators. We must keep it in sync with the state of the iterators at all times.\n+                //\n+                do {\n+                    //\n+                    // Set the currentIterator. That is the iterator at level currentLevel. If it is null,\n+                    // we create a new iterator over the set.\n+                    //\n+                    final PeekingIterator<T> currentIterator;\n+                    if (iterators.get(currentLevel) == null) {\n+                        currentIterator = Iterators.peekingIterator(eligibleElementSets.get(currentLevel).iterator());\n+                        iterators.set(currentLevel, currentIterator);\n+                    } else {\n+                        currentIterator = iterators.get(currentLevel);\n+                        unbindTail(currentLevel);\n+                        currentIterator.next();\n+                    }\n+\n+                    //\n+                    // Search currentLevel for a next item that does not violate any constraints. Doing so\n+                    // may exhaust currentIterator in which case we couldn't find another element on the current level.\n+                    // In that case we need to abandon the current level and search on the level above (making that\n+                    // level the current level). If we reach level -1 (i.e., we reach the end of the iterator at level 0\n+                    // we are done.\n+                    // If we do find an element not violating any constraints on the current level we conceptually\n+                    // bind it the element we found and continue on downward.\n+                    //\n+                    final boolean foundOnLevel = nextOnLevel(currentIterator);\n+                    if (!foundOnLevel) {\n+                        // back tracking -- need to clear out the current iterator\n+                        iterators.set(currentLevel, null);\n+                    }\n+                    currentLevel = foundOnLevel\n+                                   ? currentLevel + 1\n+                                   : currentLevel - 1;\n+\n+                    if (currentLevel == -1) {\n+                        return endOfData();\n+                    }\n+                } while (bound.size() < set.size()); // as long as we still have to find a binding\n+\n+                return iterators.stream()\n+                        .map(PeekingIterator::peek)\n+                        .collect(ImmutableList.toImmutableList());\n+            }\n+\n+            @SuppressWarnings({\"squid:S135\", \"UnstableApiUsage\", \"PMD.AvoidBranchingStatementAsLastInLoop\"})\n+            private boolean nextOnLevel(final PeekingIterator<T> currentIterator) {\n+                while (currentIterator.hasNext()) {\n+                    final T next = currentIterator.peek();\n+\n+                    // check if it is bound already; t is invisible to this loop if it is bound\n+                    if (bound.contains(next)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    // this level can be bound now\n+                    bound.add(next);\n+\n+                    final Set<T> targets = usedByMap.get(next);\n+                    final ImmutableSet.Builder<T> newlyEligibleElementsBuilder = ImmutableSet.builderWithExpectedSize(targets.size());\n+                    for (final T target : targets) {\n+                        final int newInDegree = inDegreeMap.compute(target, (k, v) -> Objects.requireNonNull(v) - 1);\n+                        Verify.verify(newInDegree >= 0);\n+                        if (newInDegree == 0) {\n+                            newlyEligibleElementsBuilder.add(target);\n+                        }\n+                    }\n+\n+                    if (bound.size() < set.size()) {\n+                        newlyEligibleElementsBuilder\n+                                .addAll(eligibleElementSets.get(bound.size() - 1))\n+                                .build();\n+\n+                        //eligibleElementSets.set(bound.size(), Sets.union(eligibleElementSets.get(bound.size() - 1), newlyEligibleElements));", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczMDM0MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464730340", "bodyText": "Yes, as it turns out, creating sets that are views (unions) of other sets are a bad idea if they are the equivalent nesting dolls as your set then turns into a linked list and look ups are effectively linear instead of effectively constant.", "author": "normen662", "createdAt": "2020-08-04T00:25:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MTU4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MzY2Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464653662", "bodyText": "Let's convert this to an <ul>.", "author": "nschiefer", "createdAt": "2020-08-03T20:47:33Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +144,106 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    /**\n+     * Returns if this expression can be the anchor of a correlation.\n+     *\n+     * A correlation is always formed between three entities:\n+     * 1. the {@link Quantifier} that flows data\n+     * 2. the anchor (which is a {@link RelationalExpression} that ranges directly over the source\n+     * 3. the consumers (or dependents) of the correlation which must be a descendant of the anchor.", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1Mzk2MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464653961", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * cannot correlate (this method returns {@code false}) because it is not meaningful e.g. to bind a record\n          \n          \n            \n                 * from the left child of the union and provide bound values to the evaluation of the right child.\n          \n          \n            \n                 * cannot correlate (this method returns {@code false}) because it is not meaningful to bind a record from one child of the union while providing bound values to another.", "author": "nschiefer", "createdAt": "2020-08-03T20:48:16Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +144,106 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    /**\n+     * Returns if this expression can be the anchor of a correlation.\n+     *\n+     * A correlation is always formed between three entities:\n+     * 1. the {@link Quantifier} that flows data\n+     * 2. the anchor (which is a {@link RelationalExpression} that ranges directly over the source\n+     * 3. the consumers (or dependents) of the correlation which must be a descendant of the anchor.\n+     *\n+     * In order for a correlation to be meaningful, the anchor must define how data is bound and used by all\n+     * dependents. For most expressions it is not meaningful or even possible to define correlation in such a way.\n+     *\n+     * For instance, a {@link com.apple.foundationdb.record.query.plan.temp.expressions.LogicalUnorderedUnionExpression}\n+     * cannot correlate (this method returns {@code false}) because it is not meaningful e.g. to bind a record\n+     * from the left child of the union and provide bound values to the evaluation of the right child.", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NDI4OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464654289", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * can be evaluated and the resulting records can bound individually one after another. For each bound flowing\n          \n          \n            \n                 * record along that quantifier the other children of the SELECT expression can be evaluated, potentially causing\n          \n          \n            \n                 * can be evaluated and the resulting records can bound individually one after another. For each bound record\n          \n          \n            \n                 * flowing along that quantifier the other children of the SELECT expression can be evaluated, potentially causing", "author": "nschiefer", "createdAt": "2020-08-03T20:48:53Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +144,106 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    /**\n+     * Returns if this expression can be the anchor of a correlation.\n+     *\n+     * A correlation is always formed between three entities:\n+     * 1. the {@link Quantifier} that flows data\n+     * 2. the anchor (which is a {@link RelationalExpression} that ranges directly over the source\n+     * 3. the consumers (or dependents) of the correlation which must be a descendant of the anchor.\n+     *\n+     * In order for a correlation to be meaningful, the anchor must define how data is bound and used by all\n+     * dependents. For most expressions it is not meaningful or even possible to define correlation in such a way.\n+     *\n+     * For instance, a {@link com.apple.foundationdb.record.query.plan.temp.expressions.LogicalUnorderedUnionExpression}\n+     * cannot correlate (this method returns {@code false}) because it is not meaningful e.g. to bind a record\n+     * from the left child of the union and provide bound values to the evaluation of the right child.\n+     *\n+     * In another example, a logical select expression can correlate which means that one child of the SELECT expression\n+     * can be evaluated and the resulting records can bound individually one after another. For each bound flowing\n+     * record along that quantifier the other children of the SELECT expression can be evaluated, potentially causing", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NDQ4OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464654488", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * The existence of a correlation between source, anchor, and dependents may adversely affect planning in a way that\n          \n          \n            \n                 * a correlation always imposes order between the evaluated of children of e.g. a select expression. This may or may\n          \n          \n            \n                 * The existence of a correlation between source, anchor, and dependents may adversely affect planning because\n          \n          \n            \n                  * a correlation always imposes order between the evaluated of children of an expression. This may or may", "author": "nschiefer", "createdAt": "2020-08-03T20:49:17Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +144,106 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    /**\n+     * Returns if this expression can be the anchor of a correlation.\n+     *\n+     * A correlation is always formed between three entities:\n+     * 1. the {@link Quantifier} that flows data\n+     * 2. the anchor (which is a {@link RelationalExpression} that ranges directly over the source\n+     * 3. the consumers (or dependents) of the correlation which must be a descendant of the anchor.\n+     *\n+     * In order for a correlation to be meaningful, the anchor must define how data is bound and used by all\n+     * dependents. For most expressions it is not meaningful or even possible to define correlation in such a way.\n+     *\n+     * For instance, a {@link com.apple.foundationdb.record.query.plan.temp.expressions.LogicalUnorderedUnionExpression}\n+     * cannot correlate (this method returns {@code false}) because it is not meaningful e.g. to bind a record\n+     * from the left child of the union and provide bound values to the evaluation of the right child.\n+     *\n+     * In another example, a logical select expression can correlate which means that one child of the SELECT expression\n+     * can be evaluated and the resulting records can bound individually one after another. For each bound flowing\n+     * record along that quantifier the other children of the SELECT expression can be evaluated, potentially causing\n+     * more correlation values to be bound, etc. These concepts follow closely to the mechanics of what SQL calls a query\n+     * block.\n+     *\n+     * The existence of a correlation between source, anchor, and dependents may adversely affect planning in a way that\n+     * a correlation always imposes order between the evaluated of children of e.g. a select expression. This may or may", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NTE4Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464655187", "bodyText": "We should fill in this Javadoc before merging.", "author": "nschiefer", "createdAt": "2020-08-03T20:50:50Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRefTraversal.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * ExpressionRefTraversal.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.graph.EndpointPair;\n+import com.google.common.graph.ImmutableNetwork;\n+import com.google.common.graph.MutableNetwork;\n+import com.google.common.graph.Network;\n+import com.google.common.graph.NetworkBuilder;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * TDB.", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NTU5Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464655596", "bodyText": "?", "author": "nschiefer", "createdAt": "2020-08-03T20:51:41Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRefTraversal.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * ExpressionRefTraversal.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.graph.EndpointPair;\n+import com.google.common.graph.ImmutableNetwork;\n+import com.google.common.graph.MutableNetwork;\n+import com.google.common.graph.Network;\n+import com.google.common.graph.NetworkBuilder;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * TDB.\n+\n+ */\n+@SuppressWarnings(\"UnstableApiUsage\")\n+public class ExpressionRefTraversal {\n+\n+    @Nonnull\n+    private final ExpressionRef<? extends RelationalExpression> rootRef;\n+    @Nonnull\n+    private final Network<ExpressionRef<? extends RelationalExpression>, RefPath> network;\n+\n+    private ExpressionRefTraversal(@Nonnull final ExpressionRef<? extends RelationalExpression> rootRef,\n+                                   @Nonnull final Network<ExpressionRef<? extends RelationalExpression>, RefPath> network) {\n+        this.rootRef = rootRef;\n+        this.network = network;\n+    }\n+\n+    @Nonnull\n+    public FullyTraversableExpressionRef<? extends RelationalExpression> getRoot() {\n+        return new FullyTraversableExpressionRef<>(rootRef);\n+    }\n+\n+    @Nonnull\n+    public <T extends RelationalExpression> ExpressionRefDelegate<T> from(@Nonnull final ExpressionRef<T> regularRef) {\n+        return new ExpressionRefDelegate<>(regularRef);\n+    }\n+\n+    public List<FullyTraversableExpressionRef<? extends RelationalExpression>> getLeaves() {\n+        return ImmutableList.of();\n+    }\n+\n+    public static ExpressionRefTraversal withRoot(final ExpressionRef<? extends RelationalExpression> rootRef) {\n+        final MutableNetwork<ExpressionRef<? extends RelationalExpression>, RefPath> network =\n+                NetworkBuilder.directed()\n+                        .allowsParallelEdges(true)\n+                        .allowsSelfLoops(true)\n+                        .build();\n+\n+        return new ExpressionRefTraversal(rootRef, ImmutableNetwork.copyOf(collectNetwork(network, rootRef)));\n+    }\n+\n+    private static MutableNetwork<ExpressionRef<? extends RelationalExpression>, RefPath> collectNetwork(@Nonnull final MutableNetwork<ExpressionRef<? extends RelationalExpression>, RefPath> network,\n+                                                                                                         @Nonnull final ExpressionRef<? extends RelationalExpression> currentRef) {\n+        if (network.addNode(currentRef)) {\n+            for (final RelationalExpression expression : currentRef.getMembers()) {\n+                for (final Quantifier quantifier : expression.getQuantifiers()) {\n+                    final ExpressionRef<? extends RelationalExpression> rangesOverRef = quantifier.getRangesOver();\n+                    collectNetwork(network, rangesOverRef);\n+                    network.addEdge(rangesOverRef, currentRef, new RefPath(expression, quantifier));\n+                }\n+            }\n+        }\n+        return network;\n+    }\n+\n+    /**\n+     * BLA.", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NTY2NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464655665", "bodyText": "?", "author": "nschiefer", "createdAt": "2020-08-03T20:51:52Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRefTraversal.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * ExpressionRefTraversal.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.graph.EndpointPair;\n+import com.google.common.graph.ImmutableNetwork;\n+import com.google.common.graph.MutableNetwork;\n+import com.google.common.graph.Network;\n+import com.google.common.graph.NetworkBuilder;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * TDB.\n+\n+ */\n+@SuppressWarnings(\"UnstableApiUsage\")\n+public class ExpressionRefTraversal {\n+\n+    @Nonnull\n+    private final ExpressionRef<? extends RelationalExpression> rootRef;\n+    @Nonnull\n+    private final Network<ExpressionRef<? extends RelationalExpression>, RefPath> network;\n+\n+    private ExpressionRefTraversal(@Nonnull final ExpressionRef<? extends RelationalExpression> rootRef,\n+                                   @Nonnull final Network<ExpressionRef<? extends RelationalExpression>, RefPath> network) {\n+        this.rootRef = rootRef;\n+        this.network = network;\n+    }\n+\n+    @Nonnull\n+    public FullyTraversableExpressionRef<? extends RelationalExpression> getRoot() {\n+        return new FullyTraversableExpressionRef<>(rootRef);\n+    }\n+\n+    @Nonnull\n+    public <T extends RelationalExpression> ExpressionRefDelegate<T> from(@Nonnull final ExpressionRef<T> regularRef) {\n+        return new ExpressionRefDelegate<>(regularRef);\n+    }\n+\n+    public List<FullyTraversableExpressionRef<? extends RelationalExpression>> getLeaves() {\n+        return ImmutableList.of();\n+    }\n+\n+    public static ExpressionRefTraversal withRoot(final ExpressionRef<? extends RelationalExpression> rootRef) {\n+        final MutableNetwork<ExpressionRef<? extends RelationalExpression>, RefPath> network =\n+                NetworkBuilder.directed()\n+                        .allowsParallelEdges(true)\n+                        .allowsSelfLoops(true)\n+                        .build();\n+\n+        return new ExpressionRefTraversal(rootRef, ImmutableNetwork.copyOf(collectNetwork(network, rootRef)));\n+    }\n+\n+    private static MutableNetwork<ExpressionRef<? extends RelationalExpression>, RefPath> collectNetwork(@Nonnull final MutableNetwork<ExpressionRef<? extends RelationalExpression>, RefPath> network,\n+                                                                                                         @Nonnull final ExpressionRef<? extends RelationalExpression> currentRef) {\n+        if (network.addNode(currentRef)) {\n+            for (final RelationalExpression expression : currentRef.getMembers()) {\n+                for (final Quantifier quantifier : expression.getQuantifiers()) {\n+                    final ExpressionRef<? extends RelationalExpression> rangesOverRef = quantifier.getRangesOver();\n+                    collectNetwork(network, rangesOverRef);\n+                    network.addEdge(rangesOverRef, currentRef, new RefPath(expression, quantifier));\n+                }\n+            }\n+        }\n+        return network;\n+    }\n+\n+    /**\n+     * BLA.\n+     */\n+    public static class RefPath {\n+        @Nonnull\n+        private final RelationalExpression expression;\n+        @Nonnull\n+        private final Quantifier quantifier;\n+\n+        public RefPath(@Nonnull final RelationalExpression expression, @Nonnull final Quantifier quantifier) {\n+            this.expression = expression;\n+            this.quantifier = quantifier;\n+        }\n+\n+        @Nonnull\n+        public RelationalExpression getExpression() {\n+            return expression;\n+        }\n+\n+        @Nonnull\n+        public Quantifier getQuantifier() {\n+            return quantifier;\n+        }\n+    }\n+\n+    /**\n+     * BLA.", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyOTIzMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464729232", "bodyText": "the alter ego of TBD and YADDA. Fixed. Sorry!", "author": "normen662", "createdAt": "2020-08-04T00:22:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NTY2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NTkwMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464655903", "bodyText": "Let's fill this in.", "author": "nschiefer", "createdAt": "2020-08-03T20:52:24Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRefDelegate.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * ExpressionRefDelegate.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+/**\n+ * TBD.", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NzEyOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464657128", "bodyText": "This needs an EXPERIMENTAL API annotation.", "author": "nschiefer", "createdAt": "2020-08-03T20:55:18Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRefDelegate.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * ExpressionRefDelegate.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+/**\n+ * TBD.\n+ * @param <T> the type\n+ */\n+public class ExpressionRefDelegate<T extends RelationalExpression> implements ExpressionRef<T> {", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NzMwMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464657303", "bodyText": "This also needs and EXPERIMENTAL annotation.", "author": "nschiefer", "createdAt": "2020-08-03T20:55:35Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRefTraversal.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * ExpressionRefTraversal.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.graph.EndpointPair;\n+import com.google.common.graph.ImmutableNetwork;\n+import com.google.common.graph.MutableNetwork;\n+import com.google.common.graph.Network;\n+import com.google.common.graph.NetworkBuilder;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * TDB.\n+\n+ */", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1OTUwNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464659505", "bodyText": "Needs an EXPERIMENTAL API annotation.", "author": "nschiefer", "createdAt": "2020-08-03T21:00:16Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -54,16 +57,69 @@\n  * at the owning (join) expression.\n  * </p>\n  */\n-public abstract class Quantifier implements Bindable {\n+@SuppressWarnings(\"unused\")\n+public abstract class Quantifier implements Bindable, Correlated<Quantifier> {", "originalCommit": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fd534541ce6788860cd18d3a49273eb3291aedc5", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/fd534541ce6788860cd18d3a49273eb3291aedc5", "message": "Resolves #987: introduce concept of correlations (using quantifiers)", "committedDate": "2020-08-03T21:54:59Z", "type": "commit"}, {"oid": "f1c138f168363a1427cd3551de57ae02be8f923e", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/f1c138f168363a1427cd3551de57ae02be8f923e", "message": "Resolves #987: introduce concept of correlations (using quantifiers); addressed review comments", "committedDate": "2020-08-04T00:42:49Z", "type": "forcePushed"}, {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/1c6f5d91e302d610963a6f9a05e530cff79457f9", "message": "Resolves #987: introduce concept of correlations (using quantifiers); addressed review comments", "committedDate": "2020-08-05T00:25:26Z", "type": "commit"}, {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/1c6f5d91e302d610963a6f9a05e530cff79457f9", "message": "Resolves #987: introduce concept of correlations (using quantifiers); addressed review comments", "committedDate": "2020-08-05T00:25:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg2MDExNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465860114", "bodyText": "should be structuralEquals()", "author": "normen662", "createdAt": "2020-08-05T16:41:13Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "diffHunk": "@@ -135,56 +137,66 @@ public boolean hasLoadBykeys() {\n     @Nonnull\n     @Override\n     public String toString() {\n-        return \"Covering(\" + getChild() + \" -> \" + toRecord + \")\";\n+        return \"Covering(\" + indexPlan + \" -> \" + toRecord + \")\";\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryCoveringIndexPlan rebase(@Nonnull final AliasMap translationMap) {\n+        return new RecordQueryCoveringIndexPlan(indexPlan, recordTypeName, toRecord);\n     }\n \n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        if (!(otherExpression instanceof RecordQueryCoveringIndexPlan)) {\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression,\n+                                         @Nonnull final AliasMap equivalencesMap) {\n+        if (!RecordQueryPlanWithNoChildren.super.equalsWithoutChildren(otherExpression, equivalencesMap)) {\n             return false;\n         }\n+\n         final RecordQueryCoveringIndexPlan other = (RecordQueryCoveringIndexPlan) otherExpression;\n-        return recordTypeName.equals(other.recordTypeName) && toRecord.equals(other.toRecord);\n+        return indexPlan.semanticEquals(other.indexPlan, equivalencesMap) &&", "originalCommit": "1c6f5d91e302d610963a6f9a05e530cff79457f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg3MDE5MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465870190", "bodyText": "Where did equalsWithoutChildren go?", "author": "normen662", "createdAt": "2020-08-05T16:57:27Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTypeFilterPlan.java", "diffHunk": "@@ -113,29 +113,30 @@ public String toString() {\n         return getInner() + \" | \" + recordTypes;\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryTypeFilterPlan &&\n-               recordTypes.equals(((RecordQueryTypeFilterPlan)otherExpression).recordTypes);\n+    public RecordQueryTypeFilterPlan rebaseWithRebasedQuantifiers(@Nonnull final AliasMap translationMap,", "originalCommit": "1c6f5d91e302d610963a6f9a05e530cff79457f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzMjUzMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465932532", "bodyText": "Alright this is done in the super class now as the record types are exposed through an abstract getter.", "author": "normen662", "createdAt": "2020-08-05T18:49:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg3MDE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5NDI3NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465994275", "bodyText": "This might illustrate my concern about having equalsWithoutChildren() as a default method rather than something that you just have to add as boilerplate in every implementation.", "author": "nschiefer", "createdAt": "2020-08-05T20:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg3MDE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4MDcyNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465980727", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * semantic equality which is usually defined as equality of the result of evaluating the plan fragment\n          \n          \n            \n                 * implementing this interface under the given bound correlations.\n          \n          \n            \n                 * semantic equality: equality of the plan fragments implementing under the given correlation bindings.", "author": "nschiefer", "createdAt": "2020-08-05T20:20:49Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.annotation.API;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Set;\n+\n+/**\n+ * A <em>correlated</em> entity is one which can only be evaluated as a function of some input (usually a {@link Quantifier}\n+ * from its relational parent).\n+ * Since a correlated entity can have multiple correlations to similar quantifiers, a correlation is disambiguated by a\n+ * {@link CorrelationIdentifier}. Correlated entities are said to be correlated to a quantifier {@code q} if the identifiers\n+ * returned by {@link #getCorrelatedTo()} set contain\n+ * the correlation identifier that {@code q} uses.\n+ *\n+ * Distinguishing the correlation identifier from the identity of the quantifier object simplifies modifications of the\n+ * graph, for example while applying transformations during query planning.\n+\n+ * An correlated object can be <em>rebased</em> using {@link #rebase} and a map of translations from one\n+ * correlation identifier to another, resulting in a new object of type {@code S} that is\n+ * identical to {@code this} except that all correlated references in the subtree rooted at this entity\n+ * (i.e., this object's relational children, predicates, etc.) are replaced with their corresponding identifiers\n+ * per the map.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} if {@code this} is not correlated to any identifier participating\n+ * in the translation.\n+ *\n+ * This interface defines a {@link #semanticEquals} method that also takes an equivalence map, and determines equality up\n+ * to the equivalences defined therein. Two correlated entities are equivalent even if they use different names, as long\n+ * as un-bound correlations can be aligned. For example, in:\n+ *\n+ * <pre>\n+ * {@code\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ * }\n+ * </pre>\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #semanticEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s this entity is correlated to.\n+     * This means that without a process that binds these correlations to values, the {@link RelationalExpression}\n+     * (or others that implement this interface) cannot even in principle produce a meaningful result. As often times\n+     * entities that implement this interface use composition and effectively describe trees or DAGs, this method should\n+     * be the set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of using a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. IDs not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(@Nonnull AliasMap translationMap);\n+\n+    /**\n+     * Determine equality with respect to an equivalence map between {@link CorrelationIdentifier}s based on\n+     * semantic equality which is usually defined as equality of the result of evaluating the plan fragment\n+     * implementing this interface under the given bound correlations.", "originalCommit": "1c6f5d91e302d610963a6f9a05e530cff79457f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4MDg3NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465980875", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n          \n          \n            \n                 * (correlated) structure such as a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.", "author": "nschiefer", "createdAt": "2020-08-05T20:21:07Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.annotation.API;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Set;\n+\n+/**\n+ * A <em>correlated</em> entity is one which can only be evaluated as a function of some input (usually a {@link Quantifier}\n+ * from its relational parent).\n+ * Since a correlated entity can have multiple correlations to similar quantifiers, a correlation is disambiguated by a\n+ * {@link CorrelationIdentifier}. Correlated entities are said to be correlated to a quantifier {@code q} if the identifiers\n+ * returned by {@link #getCorrelatedTo()} set contain\n+ * the correlation identifier that {@code q} uses.\n+ *\n+ * Distinguishing the correlation identifier from the identity of the quantifier object simplifies modifications of the\n+ * graph, for example while applying transformations during query planning.\n+\n+ * An correlated object can be <em>rebased</em> using {@link #rebase} and a map of translations from one\n+ * correlation identifier to another, resulting in a new object of type {@code S} that is\n+ * identical to {@code this} except that all correlated references in the subtree rooted at this entity\n+ * (i.e., this object's relational children, predicates, etc.) are replaced with their corresponding identifiers\n+ * per the map.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} if {@code this} is not correlated to any identifier participating\n+ * in the translation.\n+ *\n+ * This interface defines a {@link #semanticEquals} method that also takes an equivalence map, and determines equality up\n+ * to the equivalences defined therein. Two correlated entities are equivalent even if they use different names, as long\n+ * as un-bound correlations can be aligned. For example, in:\n+ *\n+ * <pre>\n+ * {@code\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ * }\n+ * </pre>\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #semanticEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s this entity is correlated to.\n+     * This means that without a process that binds these correlations to values, the {@link RelationalExpression}\n+     * (or others that implement this interface) cannot even in principle produce a meaningful result. As often times\n+     * entities that implement this interface use composition and effectively describe trees or DAGs, this method should\n+     * be the set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of using a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. IDs not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(@Nonnull AliasMap translationMap);\n+\n+    /**\n+     * Determine equality with respect to an equivalence map between {@link CorrelationIdentifier}s based on\n+     * semantic equality which is usually defined as equality of the result of evaluating the plan fragment\n+     * implementing this interface under the given bound correlations.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.", "originalCommit": "1c6f5d91e302d610963a6f9a05e530cff79457f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4MTA4Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465981083", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n          \n          \n            \n                 * That entity representing the filter is said to be correlated to {@code q1}. Similarly,", "author": "nschiefer", "createdAt": "2020-08-05T20:21:34Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.annotation.API;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Set;\n+\n+/**\n+ * A <em>correlated</em> entity is one which can only be evaluated as a function of some input (usually a {@link Quantifier}\n+ * from its relational parent).\n+ * Since a correlated entity can have multiple correlations to similar quantifiers, a correlation is disambiguated by a\n+ * {@link CorrelationIdentifier}. Correlated entities are said to be correlated to a quantifier {@code q} if the identifiers\n+ * returned by {@link #getCorrelatedTo()} set contain\n+ * the correlation identifier that {@code q} uses.\n+ *\n+ * Distinguishing the correlation identifier from the identity of the quantifier object simplifies modifications of the\n+ * graph, for example while applying transformations during query planning.\n+\n+ * An correlated object can be <em>rebased</em> using {@link #rebase} and a map of translations from one\n+ * correlation identifier to another, resulting in a new object of type {@code S} that is\n+ * identical to {@code this} except that all correlated references in the subtree rooted at this entity\n+ * (i.e., this object's relational children, predicates, etc.) are replaced with their corresponding identifiers\n+ * per the map.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} if {@code this} is not correlated to any identifier participating\n+ * in the translation.\n+ *\n+ * This interface defines a {@link #semanticEquals} method that also takes an equivalence map, and determines equality up\n+ * to the equivalences defined therein. Two correlated entities are equivalent even if they use different names, as long\n+ * as un-bound correlations can be aligned. For example, in:\n+ *\n+ * <pre>\n+ * {@code\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ * }\n+ * </pre>\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #semanticEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s this entity is correlated to.\n+     * This means that without a process that binds these correlations to values, the {@link RelationalExpression}\n+     * (or others that implement this interface) cannot even in principle produce a meaningful result. As often times\n+     * entities that implement this interface use composition and effectively describe trees or DAGs, this method should\n+     * be the set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of using a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. IDs not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(@Nonnull AliasMap translationMap);\n+\n+    /**\n+     * Determine equality with respect to an equivalence map between {@link CorrelationIdentifier}s based on\n+     * semantic equality which is usually defined as equality of the result of evaluating the plan fragment\n+     * implementing this interface under the given bound correlations.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that", "originalCommit": "1c6f5d91e302d610963a6f9a05e530cff79457f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4MTMwOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465981308", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n          \n          \n            \n                 * {@code q1.x = 6} is a different filter and is not equal under any correlation mapping.", "author": "nschiefer", "createdAt": "2020-08-05T20:21:57Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.annotation.API;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Set;\n+\n+/**\n+ * A <em>correlated</em> entity is one which can only be evaluated as a function of some input (usually a {@link Quantifier}\n+ * from its relational parent).\n+ * Since a correlated entity can have multiple correlations to similar quantifiers, a correlation is disambiguated by a\n+ * {@link CorrelationIdentifier}. Correlated entities are said to be correlated to a quantifier {@code q} if the identifiers\n+ * returned by {@link #getCorrelatedTo()} set contain\n+ * the correlation identifier that {@code q} uses.\n+ *\n+ * Distinguishing the correlation identifier from the identity of the quantifier object simplifies modifications of the\n+ * graph, for example while applying transformations during query planning.\n+\n+ * An correlated object can be <em>rebased</em> using {@link #rebase} and a map of translations from one\n+ * correlation identifier to another, resulting in a new object of type {@code S} that is\n+ * identical to {@code this} except that all correlated references in the subtree rooted at this entity\n+ * (i.e., this object's relational children, predicates, etc.) are replaced with their corresponding identifiers\n+ * per the map.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} if {@code this} is not correlated to any identifier participating\n+ * in the translation.\n+ *\n+ * This interface defines a {@link #semanticEquals} method that also takes an equivalence map, and determines equality up\n+ * to the equivalences defined therein. Two correlated entities are equivalent even if they use different names, as long\n+ * as un-bound correlations can be aligned. For example, in:\n+ *\n+ * <pre>\n+ * {@code\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ * }\n+ * </pre>\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #semanticEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s this entity is correlated to.\n+     * This means that without a process that binds these correlations to values, the {@link RelationalExpression}\n+     * (or others that implement this interface) cannot even in principle produce a meaningful result. As often times\n+     * entities that implement this interface use composition and effectively describe trees or DAGs, this method should\n+     * be the set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of using a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. IDs not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(@Nonnull AliasMap translationMap);\n+\n+    /**\n+     * Determine equality with respect to an equivalence map between {@link CorrelationIdentifier}s based on\n+     * semantic equality which is usually defined as equality of the result of evaluating the plan fragment\n+     * implementing this interface under the given bound correlations.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we", "originalCommit": "1c6f5d91e302d610963a6f9a05e530cff79457f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4MjAyNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465982026", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n          \n          \n            \n                 * these two filters are not the same. However, the filters may be a part of some other entity that can express\n          \n          \n            \n                 * correlations:\n          \n          \n            \n                 * In contrast, consider a predicate where everything except the correlation is the same, such as {@code q2.x = 5}.\n          \n          \n            \n                 * Without a binding, these two filters are not the same. However, the filters may be a part of some other entity that can express\n          \n          \n            \n                 * correlations:", "author": "nschiefer", "createdAt": "2020-08-05T20:23:20Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.annotation.API;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Set;\n+\n+/**\n+ * A <em>correlated</em> entity is one which can only be evaluated as a function of some input (usually a {@link Quantifier}\n+ * from its relational parent).\n+ * Since a correlated entity can have multiple correlations to similar quantifiers, a correlation is disambiguated by a\n+ * {@link CorrelationIdentifier}. Correlated entities are said to be correlated to a quantifier {@code q} if the identifiers\n+ * returned by {@link #getCorrelatedTo()} set contain\n+ * the correlation identifier that {@code q} uses.\n+ *\n+ * Distinguishing the correlation identifier from the identity of the quantifier object simplifies modifications of the\n+ * graph, for example while applying transformations during query planning.\n+\n+ * An correlated object can be <em>rebased</em> using {@link #rebase} and a map of translations from one\n+ * correlation identifier to another, resulting in a new object of type {@code S} that is\n+ * identical to {@code this} except that all correlated references in the subtree rooted at this entity\n+ * (i.e., this object's relational children, predicates, etc.) are replaced with their corresponding identifiers\n+ * per the map.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} if {@code this} is not correlated to any identifier participating\n+ * in the translation.\n+ *\n+ * This interface defines a {@link #semanticEquals} method that also takes an equivalence map, and determines equality up\n+ * to the equivalences defined therein. Two correlated entities are equivalent even if they use different names, as long\n+ * as un-bound correlations can be aligned. For example, in:\n+ *\n+ * <pre>\n+ * {@code\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ * }\n+ * </pre>\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #semanticEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s this entity is correlated to.\n+     * This means that without a process that binds these correlations to values, the {@link RelationalExpression}\n+     * (or others that implement this interface) cannot even in principle produce a meaningful result. As often times\n+     * entities that implement this interface use composition and effectively describe trees or DAGs, this method should\n+     * be the set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of using a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. IDs not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(@Nonnull AliasMap translationMap);\n+\n+    /**\n+     * Determine equality with respect to an equivalence map between {@link CorrelationIdentifier}s based on\n+     * semantic equality which is usually defined as equality of the result of evaluating the plan fragment\n+     * implementing this interface under the given bound correlations.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:", "originalCommit": "1c6f5d91e302d610963a6f9a05e530cff79457f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4MjI2MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465982260", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * query blocks <em>are</em> the same.\n          \n          \n            \n                 * query blocks <em>are</em> the same, even though they are labelled differently.", "author": "nschiefer", "createdAt": "2020-08-05T20:23:51Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.annotation.API;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Set;\n+\n+/**\n+ * A <em>correlated</em> entity is one which can only be evaluated as a function of some input (usually a {@link Quantifier}\n+ * from its relational parent).\n+ * Since a correlated entity can have multiple correlations to similar quantifiers, a correlation is disambiguated by a\n+ * {@link CorrelationIdentifier}. Correlated entities are said to be correlated to a quantifier {@code q} if the identifiers\n+ * returned by {@link #getCorrelatedTo()} set contain\n+ * the correlation identifier that {@code q} uses.\n+ *\n+ * Distinguishing the correlation identifier from the identity of the quantifier object simplifies modifications of the\n+ * graph, for example while applying transformations during query planning.\n+\n+ * An correlated object can be <em>rebased</em> using {@link #rebase} and a map of translations from one\n+ * correlation identifier to another, resulting in a new object of type {@code S} that is\n+ * identical to {@code this} except that all correlated references in the subtree rooted at this entity\n+ * (i.e., this object's relational children, predicates, etc.) are replaced with their corresponding identifiers\n+ * per the map.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} if {@code this} is not correlated to any identifier participating\n+ * in the translation.\n+ *\n+ * This interface defines a {@link #semanticEquals} method that also takes an equivalence map, and determines equality up\n+ * to the equivalences defined therein. Two correlated entities are equivalent even if they use different names, as long\n+ * as un-bound correlations can be aligned. For example, in:\n+ *\n+ * <pre>\n+ * {@code\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ * }\n+ * </pre>\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #semanticEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s this entity is correlated to.\n+     * This means that without a process that binds these correlations to values, the {@link RelationalExpression}\n+     * (or others that implement this interface) cannot even in principle produce a meaningful result. As often times\n+     * entities that implement this interface use composition and effectively describe trees or DAGs, this method should\n+     * be the set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of using a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. IDs not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(@Nonnull AliasMap translationMap);\n+\n+    /**\n+     * Determine equality with respect to an equivalence map between {@link CorrelationIdentifier}s based on\n+     * semantic equality which is usually defined as equality of the result of evaluating the plan fragment\n+     * implementing this interface under the given bound correlations.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a record type {@code T} which presumably is the same record type. Therefore, these two\n+     * query blocks <em>are</em> the same.", "originalCommit": "1c6f5d91e302d610963a6f9a05e530cff79457f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4Mjc3OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465982779", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * for these two objects the plan fragments are considered to produce the same result under the given bound\n          \n          \n            \n                 * correlations.\n          \n          \n            \n                 * for these two objects the plan fragments are considered to produce the same result under the given correlation\n          \n          \n            \n                 * bindings.", "author": "nschiefer", "createdAt": "2020-08-05T20:24:48Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.annotation.API;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Set;\n+\n+/**\n+ * A <em>correlated</em> entity is one which can only be evaluated as a function of some input (usually a {@link Quantifier}\n+ * from its relational parent).\n+ * Since a correlated entity can have multiple correlations to similar quantifiers, a correlation is disambiguated by a\n+ * {@link CorrelationIdentifier}. Correlated entities are said to be correlated to a quantifier {@code q} if the identifiers\n+ * returned by {@link #getCorrelatedTo()} set contain\n+ * the correlation identifier that {@code q} uses.\n+ *\n+ * Distinguishing the correlation identifier from the identity of the quantifier object simplifies modifications of the\n+ * graph, for example while applying transformations during query planning.\n+\n+ * An correlated object can be <em>rebased</em> using {@link #rebase} and a map of translations from one\n+ * correlation identifier to another, resulting in a new object of type {@code S} that is\n+ * identical to {@code this} except that all correlated references in the subtree rooted at this entity\n+ * (i.e., this object's relational children, predicates, etc.) are replaced with their corresponding identifiers\n+ * per the map.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} if {@code this} is not correlated to any identifier participating\n+ * in the translation.\n+ *\n+ * This interface defines a {@link #semanticEquals} method that also takes an equivalence map, and determines equality up\n+ * to the equivalences defined therein. Two correlated entities are equivalent even if they use different names, as long\n+ * as un-bound correlations can be aligned. For example, in:\n+ *\n+ * <pre>\n+ * {@code\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ * }\n+ * </pre>\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #semanticEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s this entity is correlated to.\n+     * This means that without a process that binds these correlations to values, the {@link RelationalExpression}\n+     * (or others that implement this interface) cannot even in principle produce a meaningful result. As often times\n+     * entities that implement this interface use composition and effectively describe trees or DAGs, this method should\n+     * be the set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of using a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. IDs not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(@Nonnull AliasMap translationMap);\n+\n+    /**\n+     * Determine equality with respect to an equivalence map between {@link CorrelationIdentifier}s based on\n+     * semantic equality which is usually defined as equality of the result of evaluating the plan fragment\n+     * implementing this interface under the given bound correlations.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a record type {@code T} which presumably is the same record type. Therefore, these two\n+     * query blocks <em>are</em> the same.\n+     * In the context of this method, we can establish equality between {@code q1.x = 5} and {@code q2.x = 5} if\n+     * we know that {@code q1} and {@code q2} refer to the same underlying entity. The equivalence map passed in\n+     * encodes that equality between {@link CorrelationIdentifier}s.\n+     *\n+     * Note: This method has the same interaction with {@link Object#hashCode()} as the regular {@code equals()}\n+     *       method. As we can only ever establish true equality using equivalence maps, {@code hashCode()}\n+     *       implementations in implementors of this interface <em>must not</em> be dependent on any correlation identifiers\n+     *       used in the structure of the entity. Doing so might violate the fundamental property of hash codes:\n+     *       {@code e1.equals(e2, ...) => e1.hashCode() == e2.hashCode()}\n+     *\n+     * @param other the other object to establish equality with\n+     * @param equivalenceMap a map of {@link CorrelationIdentifier}s {@code ids} to {@code ids'}. A correlation\n+     *        identifier {@code id} used in {@code this} should be considered equal to another correlation identifier\n+     *        {@code id'} used in {@code other} if either they are the same by {@link Object#equals}\n+     *        of if there is a mapping from {@code id} to {@code id'}.\n+     * @return {@code true} if both entities are considered equal using the equivalences passed in, {@code false}\n+     *         otherwise\n+     */\n+    boolean semanticEquals(@Nullable Object other, @Nonnull AliasMap equivalenceMap);\n+\n+    /**\n+     * Return a semantic hash code for this object. The hash code must obey the convention that for any two objects\n+     * {@code o1} and {@code o2} and for every {@link AliasMap} {@code aliasMap}:\n+     *\n+     * <pre>\n+     * {@code o1.semanticEquals(o1, aliasMap)} follows {@code o1.semanticHash() == o2.semanticHash()}\n+     * </pre>\n+     *\n+     * If the semantic hash code of two implementing objects is equal and {@link #semanticEquals} returns {@code true}\n+     * for these two objects the plan fragments are considered to produce the same result under the given bound\n+     * correlations.", "originalCommit": "1c6f5d91e302d610963a6f9a05e530cff79457f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4MzEyMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465983120", "bodyText": "I don't get what this is trying to say.", "author": "nschiefer", "createdAt": "2020-08-05T20:25:22Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.annotation.API;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Set;\n+\n+/**\n+ * A <em>correlated</em> entity is one which can only be evaluated as a function of some input (usually a {@link Quantifier}\n+ * from its relational parent).\n+ * Since a correlated entity can have multiple correlations to similar quantifiers, a correlation is disambiguated by a\n+ * {@link CorrelationIdentifier}. Correlated entities are said to be correlated to a quantifier {@code q} if the identifiers\n+ * returned by {@link #getCorrelatedTo()} set contain\n+ * the correlation identifier that {@code q} uses.\n+ *\n+ * Distinguishing the correlation identifier from the identity of the quantifier object simplifies modifications of the\n+ * graph, for example while applying transformations during query planning.\n+\n+ * An correlated object can be <em>rebased</em> using {@link #rebase} and a map of translations from one\n+ * correlation identifier to another, resulting in a new object of type {@code S} that is\n+ * identical to {@code this} except that all correlated references in the subtree rooted at this entity\n+ * (i.e., this object's relational children, predicates, etc.) are replaced with their corresponding identifiers\n+ * per the map.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} if {@code this} is not correlated to any identifier participating\n+ * in the translation.\n+ *\n+ * This interface defines a {@link #semanticEquals} method that also takes an equivalence map, and determines equality up\n+ * to the equivalences defined therein. Two correlated entities are equivalent even if they use different names, as long\n+ * as un-bound correlations can be aligned. For example, in:\n+ *\n+ * <pre>\n+ * {@code\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ * }\n+ * </pre>\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #semanticEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s this entity is correlated to.\n+     * This means that without a process that binds these correlations to values, the {@link RelationalExpression}\n+     * (or others that implement this interface) cannot even in principle produce a meaningful result. As often times\n+     * entities that implement this interface use composition and effectively describe trees or DAGs, this method should\n+     * be the set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of using a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. IDs not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(@Nonnull AliasMap translationMap);\n+\n+    /**\n+     * Determine equality with respect to an equivalence map between {@link CorrelationIdentifier}s based on\n+     * semantic equality which is usually defined as equality of the result of evaluating the plan fragment\n+     * implementing this interface under the given bound correlations.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a record type {@code T} which presumably is the same record type. Therefore, these two\n+     * query blocks <em>are</em> the same.\n+     * In the context of this method, we can establish equality between {@code q1.x = 5} and {@code q2.x = 5} if\n+     * we know that {@code q1} and {@code q2} refer to the same underlying entity. The equivalence map passed in\n+     * encodes that equality between {@link CorrelationIdentifier}s.\n+     *\n+     * Note: This method has the same interaction with {@link Object#hashCode()} as the regular {@code equals()}\n+     *       method. As we can only ever establish true equality using equivalence maps, {@code hashCode()}\n+     *       implementations in implementors of this interface <em>must not</em> be dependent on any correlation identifiers\n+     *       used in the structure of the entity. Doing so might violate the fundamental property of hash codes:\n+     *       {@code e1.equals(e2, ...) => e1.hashCode() == e2.hashCode()}\n+     *\n+     * @param other the other object to establish equality with\n+     * @param equivalenceMap a map of {@link CorrelationIdentifier}s {@code ids} to {@code ids'}. A correlation\n+     *        identifier {@code id} used in {@code this} should be considered equal to another correlation identifier\n+     *        {@code id'} used in {@code other} if either they are the same by {@link Object#equals}\n+     *        of if there is a mapping from {@code id} to {@code id'}.\n+     * @return {@code true} if both entities are considered equal using the equivalences passed in, {@code false}\n+     *         otherwise\n+     */\n+    boolean semanticEquals(@Nullable Object other, @Nonnull AliasMap equivalenceMap);\n+\n+    /**\n+     * Return a semantic hash code for this object. The hash code must obey the convention that for any two objects\n+     * {@code o1} and {@code o2} and for every {@link AliasMap} {@code aliasMap}:\n+     *\n+     * <pre>\n+     * {@code o1.semanticEquals(o1, aliasMap)} follows {@code o1.semanticHash() == o2.semanticHash()}\n+     * </pre>\n+     *\n+     * If the semantic hash code of two implementing objects is equal and {@link #semanticEquals} returns {@code true}\n+     * for these two objects the plan fragments are considered to produce the same result under the given bound\n+     * correlations.\n+     *\n+     * As the right side of the follows does not include the alias map passed into {@link #semanticEquals} it is implied\n+     * that this method cannot depend on a correlation mapping.", "originalCommit": "1c6f5d91e302d610963a6f9a05e530cff79457f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAyODQ2Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466028466", "bodyText": "The left side semanticEquals() depends on an AliasMap while semanticHash() does not. Hence, the hash is computed is identical regardless of possible bindings. Will make this more expressive.", "author": "normen662", "createdAt": "2020-08-05T21:59:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4MzEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NjkzNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465986936", "bodyText": "Is this right? It would seem to me that if canCorrelate() doesn't match then we should just return false rather than throwing an exception?", "author": "nschiefer", "createdAt": "2020-08-05T20:32:50Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/GroupExpressionRef.java", "diffHunk": "@@ -84,73 +92,99 @@ public T get() {\n     }\n \n     @Override\n-    public void insert(@Nonnull T newValue) {\n+    public boolean insert(@Nonnull T newValue) {\n         if (!containsInMemo(newValue)) {\n             members.add(newValue);\n+            return true;\n         }\n+        return false;\n     }\n-\n-    public void insertAll(@Nonnull GroupExpressionRef<T> newValues) {\n-        for (T member : newValues.members) {\n-            insert(member);\n-        }\n-    }\n-\n-    public void removeMemberIfPresent(@Nonnull T member) {\n-        members.remove(member);\n-    }\n-\n-    public void removeMember(@Nonnull T member) {\n-        if (!members.remove(member)) {\n-            throw new RecordCoreArgumentException(\"tried to remove member that isn't present\")\n-                    .addLogInfo(\"member\", member);\n-        }\n-    }\n-\n+    \n+    @SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n     public boolean containsExactly(@Nonnull T expression) {\n         return members.contains(expression);\n     }\n \n     @Override\n-    public boolean containsAllInMemo(@Nonnull ExpressionRef<? extends RelationalExpression> otherRef) {\n-        for (RelationalExpression otherMember : otherRef.getMembers()) {\n-            if (!containsInMemo(otherMember)) {\n+    public boolean containsAllInMemo(@Nonnull final ExpressionRef<? extends RelationalExpression> otherRef,\n+                                     @Nonnull final AliasMap equivalenceMap) {\n+        for (final RelationalExpression otherMember : otherRef.getMembers()) {\n+            if (!containsInMemo(otherMember, equivalenceMap)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n-    public boolean containsInMemo(@Nonnull RelationalExpression expression) {\n-        for (RelationalExpression member : members) {\n-            if (containsInMember(member, expression)) {\n+    public boolean containsInMemo(@Nonnull final RelationalExpression expression) {\n+        final Set<CorrelationIdentifier> correlatedTo = getCorrelatedTo();\n+        final Set<CorrelationIdentifier> otherCorrelatedTo = expression.getCorrelatedTo();\n+\n+        final Sets.SetView<CorrelationIdentifier> commonUnbound = Sets.intersection(correlatedTo, otherCorrelatedTo);\n+        final AliasMap identityMap = AliasMap.identitiesFor(commonUnbound);\n+\n+        return containsInMemo(expression, identityMap);\n+    }\n+\n+    private boolean containsInMemo(@Nonnull final RelationalExpression expression,\n+                                   @Nonnull final AliasMap equivalenceMap) {\n+        for (final RelationalExpression member : members) {\n+            if (containsInMember(member, expression, equivalenceMap)) {\n                 return true;\n             }\n         }\n         return false;\n     }\n \n-    private boolean containsInMember(@Nonnull RelationalExpression member, @Nonnull RelationalExpression otherMember) {\n-        if (!member.equalsWithoutChildren(otherMember)) {\n-            return false;\n-        }\n-\n-        final List<? extends Quantifier> memberQuantifiers = member.getQuantifiers();\n-        final List<? extends Quantifier> otherMemberQuantifiers = otherMember.getQuantifiers();\n-        if (memberQuantifiers.size() != otherMemberQuantifiers.size()) {\n+    private static boolean containsInMember(@Nonnull RelationalExpression member,\n+                                            @Nonnull RelationalExpression otherMember,\n+                                            @Nonnull final AliasMap equivalenceMap) {\n+        if (member.getClass() != otherMember.getClass()) {\n             return false;\n         }\n \n-        for (int i = 0; i < memberQuantifiers.size(); i++) {\n-            final ExpressionRef<? extends RelationalExpression> memberRangesOver = memberQuantifiers.get(i).getRangesOver();\n-            final ExpressionRef<? extends RelationalExpression> otherMemberRangesOver = otherMemberQuantifiers.get(i).getRangesOver();\n+        Verify.verify(member.canCorrelate() == otherMember.canCorrelate());", "originalCommit": "1c6f5d91e302d610963a6f9a05e530cff79457f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA0MjcxMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466042713", "bodyText": "When this verify happens we have already established that member and otherMember are of the same class. It is not allowed to have different objects of the class return different values.", "author": "normen662", "createdAt": "2020-08-05T22:38:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NjkzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA0Mjc2Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466042766", "bodyText": "Will add a comment.", "author": "normen662", "createdAt": "2020-08-05T22:38:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NjkzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NzkyMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465987920", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <li>2. the anchor (which is a {@link RelationalExpression} that ranges directly over the source</li>\n          \n          \n            \n                 * <li>2. the anchor (which is a {@link RelationalExpression}) that ranges directly over the source</li>", "author": "nschiefer", "createdAt": "2020-08-05T20:34:57Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +145,130 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    /**\n+     * Returns if this expression can be the anchor of a correlation.\n+     *\n+     * A correlation is always formed between three entities:\n+     * <ol>\n+     * <li>the {@link Quantifier} that flows data</li>\n+     * <li>2. the anchor (which is a {@link RelationalExpression} that ranges directly over the source</li>", "originalCommit": "1c6f5d91e302d610963a6f9a05e530cff79457f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4ODcwNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465988705", "bodyText": "Hmmm, I'm not sure if I like having this as a default method. It seems like a potent foot-gun for someone who might add a new type of relational expression without understanding the details of the planner. How bad is it to have every implementation include one of these?", "author": "nschiefer", "createdAt": "2020-08-05T20:36:36Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +145,130 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    /**\n+     * Returns if this expression can be the anchor of a correlation.\n+     *\n+     * A correlation is always formed between three entities:\n+     * <ol>\n+     * <li>the {@link Quantifier} that flows data</li>\n+     * <li>2. the anchor (which is a {@link RelationalExpression} that ranges directly over the source</li>\n+     * <li>3. the consumers (or dependents) of the correlation which must be a descendant of the anchor.</li>\n+     * </ol>\n+     *\n+     * In order for a correlation to be meaningful, the anchor must define how data is bound and used by all\n+     * dependents. For most expressions it is not meaningful or even possible to define correlation in such a way.\n+     *\n+     * For instance, a {@link com.apple.foundationdb.record.query.plan.temp.expressions.LogicalUnorderedUnionExpression}\n+     * cannot correlate (this method returns {@code false}) because it is not meaningful to bind a record from one child\n+     * of the union while providing bound values to another.\n+     *\n+     * In another example, a logical select expression can correlate which means that one child of the SELECT expression\n+     * can be evaluated and the resulting records can bound individually one after another. For each bound record\n+     * flowing along that quantifier the other children of the SELECT expression can be evaluated, potentially causing\n+     * more correlation values to be bound, etc. These concepts follow closely to the mechanics of what SQL calls a query\n+     * block.\n+     *\n+     * The existence of a correlation between source, anchor, and dependents may adversely affect planning because\n+     * a correlation always imposes order between the evaluated of children of an expression. This may or may\n+     * not tie the hands of the planner to produce an optimal plan. In certain cases, queries written in a correlated\n+     * way can be <em>de-correlated</em> to allow for better optimization techniques.\n+     *\n+     * @return {@code true} if this expression can be the anchor of a correlation, {@code false} otherwise.\n+     */\n+    default boolean canCorrelate() {\n+        return false;\n+    }\n+\n+    default boolean equalsWithoutChildren(@Nonnull final RelationalExpression other,\n+                                          @Nonnull final AliasMap equivalences) {\n+        if (this == other) {\n+            return true;\n+        }\n+        return other.getClass() == getClass();\n+    }", "originalCommit": "1c6f5d91e302d610963a6f9a05e530cff79457f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4ODk4OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465988989", "bodyText": "Like in other places, I'm not sure why this is a verified fast rather than something that just short-circuits to false.", "author": "nschiefer", "createdAt": "2020-08-05T20:37:09Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +145,130 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    /**\n+     * Returns if this expression can be the anchor of a correlation.\n+     *\n+     * A correlation is always formed between three entities:\n+     * <ol>\n+     * <li>the {@link Quantifier} that flows data</li>\n+     * <li>2. the anchor (which is a {@link RelationalExpression} that ranges directly over the source</li>\n+     * <li>3. the consumers (or dependents) of the correlation which must be a descendant of the anchor.</li>\n+     * </ol>\n+     *\n+     * In order for a correlation to be meaningful, the anchor must define how data is bound and used by all\n+     * dependents. For most expressions it is not meaningful or even possible to define correlation in such a way.\n+     *\n+     * For instance, a {@link com.apple.foundationdb.record.query.plan.temp.expressions.LogicalUnorderedUnionExpression}\n+     * cannot correlate (this method returns {@code false}) because it is not meaningful to bind a record from one child\n+     * of the union while providing bound values to another.\n+     *\n+     * In another example, a logical select expression can correlate which means that one child of the SELECT expression\n+     * can be evaluated and the resulting records can bound individually one after another. For each bound record\n+     * flowing along that quantifier the other children of the SELECT expression can be evaluated, potentially causing\n+     * more correlation values to be bound, etc. These concepts follow closely to the mechanics of what SQL calls a query\n+     * block.\n+     *\n+     * The existence of a correlation between source, anchor, and dependents may adversely affect planning because\n+     * a correlation always imposes order between the evaluated of children of an expression. This may or may\n+     * not tie the hands of the planner to produce an optimal plan. In certain cases, queries written in a correlated\n+     * way can be <em>de-correlated</em> to allow for better optimization techniques.\n+     *\n+     * @return {@code true} if this expression can be the anchor of a correlation, {@code false} otherwise.\n+     */\n+    default boolean canCorrelate() {\n+        return false;\n+    }\n+\n+    default boolean equalsWithoutChildren(@Nonnull final RelationalExpression other,\n+                                          @Nonnull final AliasMap equivalences) {\n+        if (this == other) {\n+            return true;\n+        }\n+        return other.getClass() == getClass();\n+    }\n+\n+    int hashCodeWithoutChildren();\n+\n+    /**\n+     * Overloaded method to call {@link #semanticEquals} with an empty alias map.\n+     * @param other object to compare to this expression\n+     * @return {@code true} if this object is semantically equal to {@code other} that is {@code this} and {@code other}\n+     *         produce the same result when invoked with no bindings, {@code false} otherwise.\n+     */\n+    default boolean semanticEquals(@Nullable final Object other) {\n+        return semanticEquals(other, AliasMap.empty());\n+    }\n+\n+    @Override\n+    default boolean semanticEquals(@Nullable final Object other,\n+                                   @Nonnull final AliasMap equivalenceMap) {\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        if (other == null || getClass() != other.getClass()) {\n+            return false;\n+        }\n+\n+        final RelationalExpression otherExpression = (RelationalExpression)other;\n+\n+        Verify.verify(canCorrelate() == otherExpression.canCorrelate());", "originalCommit": "1c6f5d91e302d610963a6f9a05e530cff79457f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA0MzczMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466043730", "bodyText": "It is not correct to return different values for objects of the same class which at that point has been established already.", "author": "normen662", "createdAt": "2020-08-05T22:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4ODk4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4OTkyMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465989920", "bodyText": "If this is the common use case, perhaps we can pull out RelationExpression.equalsWithoutChildren() into a static utility method somewhere rather than a default instance method?", "author": "nschiefer", "createdAt": "2020-08-05T20:39:05Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/FullUnorderedScanExpression.java", "diffHunk": "@@ -68,27 +71,48 @@ public FullUnorderedScanExpression(final Set<String> recordTypes) {\n         return ImmutableList.of();\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public FullUnorderedScanExpression rebase(@Nonnull final AliasMap translationMap) {\n+        return this;\n+    }\n+\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return equals(otherExpression);\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final AliasMap equivalencesMap) {\n+        if (!RelationalExpression.super.equalsWithoutChildren(otherExpression, equivalencesMap)) {", "originalCommit": "1c6f5d91e302d610963a6f9a05e530cff79457f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA0NDQ4OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466044488", "bodyText": "Unfortunately, that's not useful as there is actually a short circuit in that method. I have replaced the convoluted super call with what it's actually doing in the super which now also allows us to short circuit.", "author": "normen662", "createdAt": "2020-08-05T22:44:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4OTkyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5MzMwOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465993308", "bodyText": "There seems to be a lot of code in here that's shared with RelationalExpression.semanticEquals(). Can you pull out some shared abstractions, or at least add some comments illustrating where the difference is? This seems especially prudent since QueryPlan implements RelationalExpression.", "author": "nschiefer", "createdAt": "2020-08-05T20:45:36Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryPlan.java", "diffHunk": "@@ -157,4 +165,119 @@ default RecordQueryPlan accept(@Nonnull RecordQueryPlannerSubstitutionVisitor vi\n         }\n         return visitor.postVisit(this, requiredFields);\n     }\n+\n+    /**\n+     * Return a hash code for this plan which is defined based on the structural layout of a plan. This differs from\n+     * the semantic hash code defined in {@link RelationalExpression}. For instance this method would not necessarily return\n+     * the same hash code for a union {@code UNION(p1, p2)} of two sub-plans {@code p1} and {@code p2} and it's reversed\n+     * {@code UNION(p2, p1)}. In contrast to that the semantic hash of these two plans is the same.\n+     * @return a hash code for this objects that is defined on the structural layout of the plan\n+     */\n+    default int structuralHashCode() {\n+        return Objects.hash(getQuantifiers(), hashCodeWithoutChildren());\n+    }\n+\n+\n+    /**\n+     * Overloaded method to determine structural equality between two different plans using an empty {@link AliasMap}.\n+     * @param other object to compare this object with\n+     * @return {@code true} if {@code this} is structurally equal to {@code other}, {@code false} otherwise\n+     */\n+    @API(API.Status.EXPERIMENTAL)\n+    default boolean structuralEquals(@Nullable final Object other) {\n+        return structuralEquals(other, AliasMap.empty());\n+    }\n+\n+    /**\n+     * Determine if two plans are structurally equal. This differs from the semantic equality defined in\n+     * {@link RelationalExpression}. For instance this method would return false\n+     * for two given plans {@code UNION(p1, p2)} and {@code UNION(p2, p1)} of two different sub-plans {@code p1} and\n+     * {@code p2}. In contrast to that these plans are considered semantically equal.\n+     * @param other object to compare this object with\n+     * @param equivalenceMap alias map to indicate aliases that should be considered as equal when {@code other} is\n+     *        compared to {@code this}. For instance {@code q1.x = 1} is only structurally equal with {@code q2.x = 1}\n+     *        if there is a mapping {@code q1 -> q2} in the alias map passed in\n+     * @return {@code true} if {@code this} is structurally equal to {@code other}, {@code false} otherwise\n+     */\n+    @API(API.Status.EXPERIMENTAL)\n+    default boolean structuralEquals(@Nullable final Object other,", "originalCommit": "1c6f5d91e302d610963a6f9a05e530cff79457f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA0NDkzNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466044936", "bodyText": "That's done in the follow up matching code. In fact I have already rebased and the code duplication between these two methods is now much less. Don't want to do it in this PR as there are other changes in that follow up work that I don't want to pull in.", "author": "normen662", "createdAt": "2020-08-05T22:45:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5MzMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5NjAzNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465996036", "bodyText": "Can you add a similar block here for unordered unions?", "author": "nschiefer", "createdAt": "2020-08-05T20:51:02Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/query/plan/planning/RecordQueryPlanEqualityTest.java", "diffHunk": "@@ -132,12 +133,17 @@ public void differentPlanClassesNotEqual() {\n     public void childOrderDoesNotMatter() {\n         final RecordQueryPlan unionPlan1 = unionPlan(2, 4);\n         final RecordQueryPlan unionPlan2 = unionPlan(4, 2);\n-        assertEquals(unionPlan1, unionPlan2);\n-        assertEquals(unionPlan1.hashCode(), unionPlan2.hashCode());\n+        assertNotEquals(unionPlan1, unionPlan2);\n+        assertNotEquals(unionPlan1.hashCode(), unionPlan2.hashCode());\n+        assertTrue(unionPlan1.semanticEquals(unionPlan2));\n+        assertEquals(unionPlan1.semanticHashCode(), unionPlan2.semanticHashCode());\n+\n \n         final RecordQueryPlan intersectionPlan1 = intersectionPlan(2, 4);\n         final RecordQueryPlan intersectionPlan2 = intersectionPlan(4, 2);\n-        assertEquals(intersectionPlan1, intersectionPlan2);\n-        assertEquals(intersectionPlan1.hashCode(), intersectionPlan2.hashCode());\n+        assertNotEquals(intersectionPlan1, intersectionPlan2);\n+        assertNotEquals(intersectionPlan1.hashCode(), intersectionPlan2.hashCode());\n+        assertTrue(intersectionPlan1.semanticEquals(intersectionPlan2));\n+        assertEquals(intersectionPlan1.semanticHashCode(), intersectionPlan2.semanticHashCode());", "originalCommit": "1c6f5d91e302d610963a6f9a05e530cff79457f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA0NTc3OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466045778", "bodyText": "Hmm -- see line 136-139", "author": "normen662", "createdAt": "2020-08-05T22:47:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5NjAzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUyNjg2MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466526860", "bodyText": "Right, those are ordered unions. I was hoping we could do a similar one for RecordQueryUnorderedUnionPlans.", "author": "nschiefer", "createdAt": "2020-08-06T16:13:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5NjAzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5NjcwMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465996703", "bodyText": "I think we still need this equalsWithoutChildren(). I think these are easy enough to drop and important enough to have that we should remove the default implementation.", "author": "nschiefer", "createdAt": "2020-08-05T20:52:21Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalTypeFilterExpression.java", "diffHunk": "@@ -80,31 +81,37 @@ private Quantifier getInner() {\n         return inner;\n     }\n \n+    @Nonnull\n+    @Override\n+    public LogicalTypeFilterExpression rebase(@Nonnull final AliasMap translationMap) {\n+        // we know the following is correct, just Java doesn't\n+        return (LogicalTypeFilterExpression)TypeFilterExpression.super.rebase(translationMap);\n+    }\n+\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {", "originalCommit": "1c6f5d91e302d610963a6f9a05e530cff79457f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA0MDUyOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466040528", "bodyText": "Removed the default implementation. Also verified that this expression is correctly doing equalsWithoutChildren through its superclass.", "author": "normen662", "createdAt": "2020-08-05T22:32:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5NjcwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5OTA0MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465999040", "bodyText": "This method should be EXPERIMENTAL so that we don't have to maintain it. :-)", "author": "nschiefer", "createdAt": "2020-08-05T20:57:04Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryPlan.java", "diffHunk": "@@ -157,4 +165,119 @@ default RecordQueryPlan accept(@Nonnull RecordQueryPlannerSubstitutionVisitor vi\n         }\n         return visitor.postVisit(this, requiredFields);\n     }\n+\n+    /**\n+     * Return a hash code for this plan which is defined based on the structural layout of a plan. This differs from\n+     * the semantic hash code defined in {@link RelationalExpression}. For instance this method would not necessarily return\n+     * the same hash code for a union {@code UNION(p1, p2)} of two sub-plans {@code p1} and {@code p2} and it's reversed\n+     * {@code UNION(p2, p1)}. In contrast to that the semantic hash of these two plans is the same.\n+     * @return a hash code for this objects that is defined on the structural layout of the plan\n+     */\n+    default int structuralHashCode() {", "originalCommit": "1c6f5d91e302d610963a6f9a05e530cff79457f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "05f568735ecda54915227c69b68d0d433921d6e5", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/05f568735ecda54915227c69b68d0d433921d6e5", "message": "Resolves #987: introduce concept of correlations (using quantifiers); addressed review comments (2); made RecordQueryPlans INTERANL", "committedDate": "2020-08-06T17:25:30Z", "type": "forcePushed"}, {"oid": "782a47fc2b2aeb86411364c95f414c6058094d17", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/782a47fc2b2aeb86411364c95f414c6058094d17", "message": "Resolves #987: introduce concept of correlations (using quantifiers); addressed review comments (2); made RecordQueryPlans INTERANL", "committedDate": "2020-08-06T18:19:34Z", "type": "commit"}, {"oid": "782a47fc2b2aeb86411364c95f414c6058094d17", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/782a47fc2b2aeb86411364c95f414c6058094d17", "message": "Resolves #987: introduce concept of correlations (using quantifiers); addressed review comments (2); made RecordQueryPlans INTERANL", "committedDate": "2020-08-06T18:19:34Z", "type": "forcePushed"}]}