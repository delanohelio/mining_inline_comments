{"pr_number": 1084, "pr_title": "Resolves #1083: integrated index matching and planning in the Cascades planner", "pr_createdAt": "2020-12-07T21:18:12Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084", "timeline": [{"oid": "851efc1482f161b630d18cbee25ed6a725a7899d", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/851efc1482f161b630d18cbee25ed6a725a7899d", "message": "cascades planner and index matching milestone 0", "committedDate": "2020-12-19T23:51:33Z", "type": "forcePushed"}, {"oid": "98d8cb27bc99a018a04e9b8b492d9a2f3f366efb", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/98d8cb27bc99a018a04e9b8b492d9a2f3f366efb", "message": "cascades planner and index matching milestone 0", "committedDate": "2020-12-20T19:33:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODEyOTU1Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r548129557", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * in order to determines if the query expression is in fact subsumed by the candidate. The property of subsumption\n          \n          \n            \n             * in order to determine if the query expression is in fact subsumed by the candidate. The property of subsumption", "author": "MMcM", "createdAt": "2020-12-23T18:42:52Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/MatchIntermediateRule.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * FlattenNestedAndPredicateRule.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.rules;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+import com.apple.foundationdb.record.query.plan.temp.EnumeratingIterable;\n+import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.IdentityBiMap;\n+import com.apple.foundationdb.record.query.plan.temp.IterableHelpers;\n+import com.apple.foundationdb.record.query.plan.temp.MatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.MatchInfo;\n+import com.apple.foundationdb.record.query.plan.temp.PartialMatch;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRule;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRuleCall;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.SelectExpression;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.QuantifierMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.TypeMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matching.BoundMatch;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import static com.apple.foundationdb.record.query.plan.temp.matchers.MultiChildrenMatcher.allMatching;\n+\n+/**\n+ * Expression-based transformation rule that matches any non-leaf expression (called an intermediate expression)\n+ * to a candidate expression in a {@link MatchCandidate}.\n+ * It yields matches of type {@link PartialMatch}. This rule further seeds the memoization\n+ * structure for partial matches that is kept as part of {@link ExpressionRef}. It prepares further rules such as\n+ * other applications of {@link MatchIntermediateRule} and {@link AdjustMatchRule}.\n+ *\n+ * As an intermediate expression has children (and the candidate expression also has at least one child) we\n+ * need to match up the quantifiers of the query expression to the quantifiers of the possible candidate expression\n+ * in order to determines if the query expression is in fact subsumed by the candidate. The property of subsumption", "originalCommit": "98d8cb27bc99a018a04e9b8b492d9a2f3f366efb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODEzODE5NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r548138195", "bodyText": "This method has a somewhat strange contract, though it may be appropriate for how it will be used.\n\nprimaryKey is actually RecordMetaData.commonPrimaryKey, which may be null, in which case no additional fields are included. An equally valid interpretation would be to include as much of a common key as there is.\nin order to trim, the primary key fields need to be normalized, but the remaining fields are not.\nmore fundamentally, since rootExpression can be interpreted by the index maintainer in any way it chooses, it is only by knowing the index type that a caller can be assured that index entries will follow the returned pattern.", "author": "MMcM", "createdAt": "2020-12-23T18:53:33Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/metadata/Index.java", "diffHunk": "@@ -431,6 +432,19 @@ public void trimPrimaryKey(List<?> primaryKeys) {\n         }\n     }\n \n+    @Nonnull\n+    public KeyExpression fullKey(@Nullable final KeyExpression primaryKey) {", "originalCommit": "98d8cb27bc99a018a04e9b8b492d9a2f3f366efb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ3OTE3NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r558479174", "bodyText": "I added a TODO and made sure the function can only be invoked if the index type is VALUE.", "author": "normen662", "createdAt": "2021-01-15T18:03:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODEzODE5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODE0OTE5Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r548149193", "bodyText": "I have some conceptual difficulty with this. I think of the normalized form of a KeyExpression mostly as one that unnests while adding correlation names, so that an ordered sequence of values can be matched with the proper unification semantics. So it is surprising that the normal forms of keys and queries are of the same stuff.\nPerhaps what is strange is that a QueryPredicate can have a placeholder. A ValueComparisonRangePredicate is not so much a predicate as a thing to which predicates can be added as part of that matching.\nIt may be that the problem stems primarily from naming.", "author": "MMcM", "createdAt": "2020-12-23T19:06:30Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/metadata/expressions/KeyExpression.java", "diffHunk": "@@ -192,44 +194,28 @@ public static FanType valueOf(RecordMetaDataProto.Field.FanType fanType) throws\n         return Collections.singletonList(this);\n     }\n \n-    /**\n-     * Flatten this key expression into a list of {@link Element}s, much like {@link #normalizeKeyForPositions()}.\n-     * By default, this method throws an exception because most key expressions cannot be flattened to a list of\n-     * elements without prior adjustment. This method is only overriden by key expressions that can be flattened.\n-     * @return a list of elements representing this key expression in unnested form\n-     * @see ElementKeyExpression#flattenForPlanner()\n-     * @see ThenKeyExpression#flattenForPlanner()\n-     */\n     @API(API.Status.EXPERIMENTAL)\n     @Nonnull\n-    default List<Element> flattenForPlanner() {\n-        throw new RecordCoreException(\"illegal non-element expression\");\n+    default ExpandedPredicates normalizeForPlanner(@Nonnull CorrelationIdentifier baseAlias, @Nonnull final Supplier<CorrelationIdentifier> parameterAliasSupplier) {\n+        return normalizeForPlanner(baseAlias, parameterAliasSupplier, Collections.emptyList());\n     }\n \n+    @API(API.Status.EXPERIMENTAL)\n+    @Nonnull\n+    ExpandedPredicates normalizeForPlanner(@Nonnull CorrelationIdentifier baseAlias, @Nonnull final Supplier<CorrelationIdentifier> parameterAliasSupplier, @Nonnull List<String> fieldNamePrefix);", "originalCommit": "98d8cb27bc99a018a04e9b8b492d9a2f3f366efb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ4MzI5Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r558483297", "bodyText": "Your observations are correct, a placeholder is a predicate in a sense that it only is meaningful in conjunction with an actual match. Maybe another way of thinking about it is to say a place holder is x in [-inf, inf] where the matching yields a compensation that is the actual range. It is possible to do it like so but I feel like it may be a bit to convoluted as such a predicate needs to be understood as something the materialized view can handle, it needs special logic to map the range back to an ordinal position in the index, etc. So rather than using Compensations to capture this mapping I opted to bypass and to just have a mapping from query to placeholder which directly gives me the parameter alias, etc. Hope this makes sense.", "author": "normen662", "createdAt": "2021-01-15T18:10:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODE0OTE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODE1MjA3NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r548152075", "bodyText": "Is there an issue tracking the need for a mutable list here?", "author": "MMcM", "createdAt": "2020-12-23T19:10:24Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -117,9 +117,9 @@ public static AvailableFields fromIndex(@Nonnull RecordType recordType,\n         }\n \n         // Like FDBRecordStoreBase.indexEntryKey(), but with key expressions instead of actual values.\n-        final List<KeyExpression> primaryKeys = commonPrimaryKey == null\n-                                                ? Collections.emptyList()\n-                                                : commonPrimaryKey.normalizeKeyForPositions();\n+        final List<KeyExpression> primaryKeys = new ArrayList<>(commonPrimaryKey == null", "originalCommit": "98d8cb27bc99a018a04e9b8b492d9a2f3f366efb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ3OTY0Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r558479643", "bodyText": "There is none.", "author": "normen662", "createdAt": "2021-01-15T18:04:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODE1MjA3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ4Mzg2OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r558483869", "bodyText": "Let me know if I should create one as you only run into this problem if your commonPrimaryKey is null and that may be not super straightforward to get yourself into.", "author": "normen662", "createdAt": "2021-01-15T18:12:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODE1MjA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODE1ODgxNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r548158817", "bodyText": "I see how this works practically, but it seems odd to set the scan's reverse from the query's sort order. As opposed to trying various directions until one matches. Furthermore, if we ever had mixed order, the matching would need to be piecemeal.", "author": "MMcM", "createdAt": "2020-12-23T19:19:57Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/MetaDataPlanContext.java", "diffHunk": "@@ -108,33 +107,18 @@ public MetaDataPlanContext(@Nonnull RecordMetaData metaData, @Nonnull RecordStor\n                 index -> !query.getAllowedIndexes().contains(index.getName()) :\n                 index -> !query.getIndexQueryabilityFilter().isQueryable(index));\n \n-        ImmutableSet.Builder<IndexEntrySource> builder = ImmutableSet.builder();\n-        if (commonPrimaryKey != null) {\n-            builder.add(IndexEntrySource.fromCommonPrimaryKey(recordTypes, commonPrimaryKey));\n-        }\n+        final ImmutableSet.Builder<MatchCandidate> matchCandidatesBuilder = ImmutableSet.builder();\n         for (Index index : indexList) {\n             indexes.put(index, index.getName());\n-            builder.add(IndexEntrySource.fromIndex(metaData.recordTypesForIndex(index), index));\n+            final Optional<MatchCandidate> candidateForIndexOptional =\n+                    RelationalExpression.fromIndexDefinition(metaData, index, query.isSortReverse());", "originalCommit": "98d8cb27bc99a018a04e9b8b492d9a2f3f366efb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ4NDkxMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r558484912", "bodyText": "Discussed. We leave this as is right now. The proper way of doing this would be to create forward and reverse plans for every scan which doubles the search space effectively for no good reason as isSortReversed is a somewhat global parameter.", "author": "normen662", "createdAt": "2021-01-15T18:14:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODE1ODgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODE2MTQ2NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r548161465", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * thing conceptually but is still technically a quite different. {@link LogicalSortExpression} serves as the logical\n          \n          \n            \n             * thing conceptually but is still technically quite different. {@link LogicalSortExpression} serves as the logical", "author": "MMcM", "createdAt": "2020-12-23T19:24:03Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/MatchableSortExpression.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * LogicalSortExpressionOld.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2018 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.expressions;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.BoundKeyPart;\n+import com.apple.foundationdb.record.query.plan.temp.ComparisonRange;\n+import com.apple.foundationdb.record.query.plan.temp.CorrelationIdentifier;\n+import com.apple.foundationdb.record.query.plan.temp.GroupExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.IdentityBiMap;\n+import com.apple.foundationdb.record.query.plan.temp.MatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.MatchInfo;\n+import com.apple.foundationdb.record.query.plan.temp.PartialMatch;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.explain.Attribute;\n+import com.apple.foundationdb.record.query.plan.temp.explain.InternalPlannerGraphRewritable;\n+import com.apple.foundationdb.record.query.plan.temp.explain.NodeInfo;\n+import com.apple.foundationdb.record.query.plan.temp.explain.PlannerGraph;\n+import com.apple.foundationdb.record.query.plan.temp.rules.AdjustMatchRule;\n+import com.apple.foundationdb.record.query.plan.temp.rules.ImplementSortRule;\n+import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n+import com.apple.foundationdb.record.query.predicates.ValueComparisonRangePredicate.Placeholder;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * A relational planner expression that represents an unimplemented sort on the records produced by its inner\n+ * relational planner expression.\n+ *\n+ * TODO BEGIN\n+ * This class is somewhat flawed. There is a cousin of this class {@link LogicalSortExpression} which does a similar\n+ * thing conceptually but is still technically a quite different. {@link LogicalSortExpression} serves as the logical", "originalCommit": "98d8cb27bc99a018a04e9b8b492d9a2f3f366efb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODE2MjIwOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r548162208", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * only allowed to appear in a match candidate, ever on the expression side. The reason why that is comes down to the\n          \n          \n            \n             * only ever allowed to appear in a match candidate on the expression side. The reason why that is comes down to the", "author": "MMcM", "createdAt": "2020-12-23T19:25:03Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/MatchableSortExpression.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * LogicalSortExpressionOld.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2018 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.expressions;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.BoundKeyPart;\n+import com.apple.foundationdb.record.query.plan.temp.ComparisonRange;\n+import com.apple.foundationdb.record.query.plan.temp.CorrelationIdentifier;\n+import com.apple.foundationdb.record.query.plan.temp.GroupExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.IdentityBiMap;\n+import com.apple.foundationdb.record.query.plan.temp.MatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.MatchInfo;\n+import com.apple.foundationdb.record.query.plan.temp.PartialMatch;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.explain.Attribute;\n+import com.apple.foundationdb.record.query.plan.temp.explain.InternalPlannerGraphRewritable;\n+import com.apple.foundationdb.record.query.plan.temp.explain.NodeInfo;\n+import com.apple.foundationdb.record.query.plan.temp.explain.PlannerGraph;\n+import com.apple.foundationdb.record.query.plan.temp.rules.AdjustMatchRule;\n+import com.apple.foundationdb.record.query.plan.temp.rules.ImplementSortRule;\n+import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n+import com.apple.foundationdb.record.query.predicates.ValueComparisonRangePredicate.Placeholder;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * A relational planner expression that represents an unimplemented sort on the records produced by its inner\n+ * relational planner expression.\n+ *\n+ * TODO BEGIN\n+ * This class is somewhat flawed. There is a cousin of this class {@link LogicalSortExpression} which does a similar\n+ * thing conceptually but is still technically a quite different. {@link LogicalSortExpression} serves as the logical\n+ * precursor to a physical implementation of a sort (which we do not (yet) have). So in order for the planner to produce\n+ * an executable plan, that sort expression has to be optimized away by e.g. {@link ImplementSortRule}. This class\n+ * is different in a way that it an only be used as an expression to be matched against. In other words this class is\n+ * only allowed to appear in a match candidate, ever on the expression side. The reason why that is comes down to the", "originalCommit": "98d8cb27bc99a018a04e9b8b492d9a2f3f366efb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODE2MzIwOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r548163208", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * how it flows and what operations have been applied to it since it was fethed. There are other places where exactly\n          \n          \n            \n             * how it flows and what operations have been applied to it since it was fetched. There are other places where exactly", "author": "MMcM", "createdAt": "2020-12-23T19:26:17Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/MatchableSortExpression.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * LogicalSortExpressionOld.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2018 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.expressions;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.BoundKeyPart;\n+import com.apple.foundationdb.record.query.plan.temp.ComparisonRange;\n+import com.apple.foundationdb.record.query.plan.temp.CorrelationIdentifier;\n+import com.apple.foundationdb.record.query.plan.temp.GroupExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.IdentityBiMap;\n+import com.apple.foundationdb.record.query.plan.temp.MatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.MatchInfo;\n+import com.apple.foundationdb.record.query.plan.temp.PartialMatch;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.explain.Attribute;\n+import com.apple.foundationdb.record.query.plan.temp.explain.InternalPlannerGraphRewritable;\n+import com.apple.foundationdb.record.query.plan.temp.explain.NodeInfo;\n+import com.apple.foundationdb.record.query.plan.temp.explain.PlannerGraph;\n+import com.apple.foundationdb.record.query.plan.temp.rules.AdjustMatchRule;\n+import com.apple.foundationdb.record.query.plan.temp.rules.ImplementSortRule;\n+import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n+import com.apple.foundationdb.record.query.predicates.ValueComparisonRangePredicate.Placeholder;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * A relational planner expression that represents an unimplemented sort on the records produced by its inner\n+ * relational planner expression.\n+ *\n+ * TODO BEGIN\n+ * This class is somewhat flawed. There is a cousin of this class {@link LogicalSortExpression} which does a similar\n+ * thing conceptually but is still technically a quite different. {@link LogicalSortExpression} serves as the logical\n+ * precursor to a physical implementation of a sort (which we do not (yet) have). So in order for the planner to produce\n+ * an executable plan, that sort expression has to be optimized away by e.g. {@link ImplementSortRule}. This class\n+ * is different in a way that it an only be used as an expression to be matched against. In other words this class is\n+ * only allowed to appear in a match candidate, ever on the expression side. The reason why that is comes down to the\n+ * simple question of how to express the thing(s) to sort on in general and what to do with nested repeated value in\n+ * particular.\n+ *\n+ * What should we be able to express when we express order? One thing we definitely want to sort by is a scalar\n+ * value that can be computed from the record or an index key that flows into the operator. On the contrary we should\n+ * not be able to sort by something like {@code field(\"a\", FanOut)} as it really does not make sense\n+ * in this context. What does make sense is to say that you want the stream to be ordered by {@code field(\"a\", FanOut)},\n+ * but you actually are expressing a requirement on data computed on a record before it even flows into the sort, i.e.\n+ * it cannot be computed (conceptually) in this operator. The nested repeated field {@code a} needs to come from either\n+ * a physical version of an {@link ExplodeExpression} (which we don't have (yet)) or from an index access as index keys\n+ * can be constructed in this way. The expressiveness that is fundamentally lacking here is to model what data flows,\n+ * how it flows and what operations have been applied to it since it was fethed. There are other places where exactly", "originalCommit": "98d8cb27bc99a018a04e9b8b492d9a2f3f366efb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODE2NDY4OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r548164689", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * In the future, we should strive ti unify these two classes to one logical sort expression. For now, we have\n          \n          \n            \n             * In the future, we should strive to unify these two classes into one logical sort expression. For now, we have", "author": "MMcM", "createdAt": "2020-12-23T19:28:08Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/MatchableSortExpression.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * LogicalSortExpressionOld.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2018 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.expressions;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.BoundKeyPart;\n+import com.apple.foundationdb.record.query.plan.temp.ComparisonRange;\n+import com.apple.foundationdb.record.query.plan.temp.CorrelationIdentifier;\n+import com.apple.foundationdb.record.query.plan.temp.GroupExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.IdentityBiMap;\n+import com.apple.foundationdb.record.query.plan.temp.MatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.MatchInfo;\n+import com.apple.foundationdb.record.query.plan.temp.PartialMatch;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.explain.Attribute;\n+import com.apple.foundationdb.record.query.plan.temp.explain.InternalPlannerGraphRewritable;\n+import com.apple.foundationdb.record.query.plan.temp.explain.NodeInfo;\n+import com.apple.foundationdb.record.query.plan.temp.explain.PlannerGraph;\n+import com.apple.foundationdb.record.query.plan.temp.rules.AdjustMatchRule;\n+import com.apple.foundationdb.record.query.plan.temp.rules.ImplementSortRule;\n+import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n+import com.apple.foundationdb.record.query.predicates.ValueComparisonRangePredicate.Placeholder;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * A relational planner expression that represents an unimplemented sort on the records produced by its inner\n+ * relational planner expression.\n+ *\n+ * TODO BEGIN\n+ * This class is somewhat flawed. There is a cousin of this class {@link LogicalSortExpression} which does a similar\n+ * thing conceptually but is still technically a quite different. {@link LogicalSortExpression} serves as the logical\n+ * precursor to a physical implementation of a sort (which we do not (yet) have). So in order for the planner to produce\n+ * an executable plan, that sort expression has to be optimized away by e.g. {@link ImplementSortRule}. This class\n+ * is different in a way that it an only be used as an expression to be matched against. In other words this class is\n+ * only allowed to appear in a match candidate, ever on the expression side. The reason why that is comes down to the\n+ * simple question of how to express the thing(s) to sort on in general and what to do with nested repeated value in\n+ * particular.\n+ *\n+ * What should we be able to express when we express order? One thing we definitely want to sort by is a scalar\n+ * value that can be computed from the record or an index key that flows into the operator. On the contrary we should\n+ * not be able to sort by something like {@code field(\"a\", FanOut)} as it really does not make sense\n+ * in this context. What does make sense is to say that you want the stream to be ordered by {@code field(\"a\", FanOut)},\n+ * but you actually are expressing a requirement on data computed on a record before it even flows into the sort, i.e.\n+ * it cannot be computed (conceptually) in this operator. The nested repeated field {@code a} needs to come from either\n+ * a physical version of an {@link ExplodeExpression} (which we don't have (yet)) or from an index access as index keys\n+ * can be constructed in this way. The expressiveness that is fundamentally lacking here is to model what data flows,\n+ * how it flows and what operations have been applied to it since it was fethed. There are other places where exactly\n+ * this is a problem as well. Specifically, for the sort expression, however, this problem manifests itself as:\n+ *\n+ * (1) Either the sort is expressed by using {@link KeyExpression}s. In that case, expressing a nested repeated value\n+ *     in the sort expression itself does not make sense. Again, we should model such a case as a sort over an value\n+ *     that has been pre-produced by a cardinality-changing operator such as a physical variant of explode or by\n+ *     explicitly referring to and modelling the index keys that can flow along with the fetched record. Note that this\n+ *     of course has far-reaching implications for optimizations that attempt to defer the fetch of a record.\n+ *     Essentially, we would like to say\n+ *\n+ *     <pre>\n+ *     index: {@code field(a, FanOut)}\n+ *     plan: {@code Sort(IndexScan(index), a [5, 10]), indexkey.a)}\n+ *     </pre>\n+ *\n+ *     i.e. we want to sort by the index key. We do not want to model that plan like\n+ *     <pre>\n+ *     plan: {@code Sort(IndexScan(index), a [5, 10]), record.field(\"a\", FanOut))}\n+ *     </pre>\n+ *\n+ *     where the sort expression (even only if conceptually) extracts the {@code a}s from the base records as the base\n+ *     record at that moment already may contain duplicates of the base record due to using that index in the underlying\n+ *     scan.\n+ * (2) Alternatively, we can express the sort by using explicit index scan-provided values. You simply cannot sort by\n+ *     anything that does not come from an index or a primary scan (the latter cannot really sort by anything that's\n+ *     repeated due to the key being a primary key). That works for the current landscape as there is no physical sort\n+ *     (yet) and it overcomes the problem explained above in a way that we can express to sort by anything the\n+ *     index scan (or primary scan) produces as opposed to something that can be computed on-the-fly based upon the\n+ *     base record. This also removes the requirement of the base record to be fetched and present at the the time the\n+ *     sort happens (conceptually) and allows for deferred-fetch optimizations.\n+ *\n+ * As a direct result of this we now have two different logical sort expressions. One, {@link LogicalSortExpression}\n+ * which expresses order by using {@link KeyExpression}s and which has the problems layed out in (1), and a this one\n+ * {@link MatchableSortExpression} which expresses order by explicitly naming the constituent parts of an index.\n+ * In the future, we should strive ti unify these two classes to one logical sort expression. For now, we have", "originalCommit": "98d8cb27bc99a018a04e9b8b492d9a2f3f366efb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "412ae8edc695ccdb82f9af41aa36736f7a734888", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/412ae8edc695ccdb82f9af41aa36736f7a734888", "message": "adressing commments", "committedDate": "2021-01-14T17:19:15Z", "type": "forcePushed"}, {"oid": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/2881dc61d82619e0a0cc704c6e38c389436e8c3e", "message": "adressing commments", "committedDate": "2021-01-15T19:03:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDA1NzI2MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r564057260", "bodyText": "The OrThrow cannot really throw because we already checked that the source is present, but looks a little odd in a predicate. Wouldn't target.equals(getTarget(source)) do everything we need?", "author": "MMcM", "createdAt": "2021-01-25T21:31:52Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -211,6 +211,11 @@ public boolean containsTarget(@Nonnull final CorrelationIdentifier alias) {\n         return map.containsValue(alias);\n     }\n \n+    public boolean containsMapping(@Nonnull final CorrelationIdentifier source,\n+                                   @Nonnull final CorrelationIdentifier target) {\n+        return containsSource(source) && containsTarget(target) && getTargetOrThrow(source).equals(target);", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzA4MDgzMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r567080832", "bodyText": "It does except the return of that is Nullable which causes a warning. I could wrap that with a Objects.requreNotNull() but this is doing the same. So it's an artifact of shutting up the compiler.", "author": "normen662", "createdAt": "2021-01-29T20:38:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDA1NzI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDA2NTYwNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r564065606", "bodyText": "I believe that this is very close to Iterables.transform in Guava. We already have that as a dependency, but perhaps it isn't used much in this part of the system.", "author": "MMcM", "createdAt": "2021-01-25T21:47:05Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/IterableHelpers.java", "diffHunk": "@@ -56,6 +56,23 @@ private IterableHelpers() {\n                 }).iterator();\n     }\n \n+    /**\n+     * Maps given function to the given iterable and returns a new iterable. This is akin\n+     * to compositions based on {@link java.util.stream.Stream}, however, allows for restarting the iteration as per\n+     * general contract in {@link Iterable}.\n+     * @param source source iterable\n+     * @param mapper mapper function to map from {@code T} to {@code Iterable} of {@code R}\n+     * @param <T> type of source iterable\n+     * @param <R> type the given mapper function returns\n+     * @return an iterable of type {@code R} that is the conceptual map of {@code source} using {@code mapper}\n+     */\n+    public static <T, R> Iterable<R> map(@Nonnull Iterable<T> source, @Nonnull final Function<? super T, R> mapper) {", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzQ5MjkwMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r567492901", "bodyText": "Using that Guava method causes a code check warning StaticPseudoFunctionalStyleMethod as people need to be told to use streams. Since I need something like restartable streams I went with iterators. As a lot of callers already use flatMap() from this class, I think I want to keep using map() from here as well. I looked into the transform() implementation in guava which does not use streams under the cover but iterators directly. I think map() as it is written here is actually nicer. I don't have strong opinions here but I will leave this as is.", "author": "normen662", "createdAt": "2021-01-31T22:17:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDA2NTYwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzk5MjY2MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r567992661", "bodyText": "If StaticPseudoFunctionalStyleMethod were smarter, wouldn't it complain about this method? The claim seems to be that one should use streams in the caller and not in yet another static monad-like method.", "author": "MMcM", "createdAt": "2021-02-01T17:08:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDA2NTYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDA3MTQ2Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r564071467", "bodyText": "Maybe these call for another comment on the general nature of the difference with the new planner.", "author": "MMcM", "createdAt": "2021-01-25T21:57:45Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/query/FDBRecordStoreQueryTest.java", "diffHunk": "@@ -295,10 +294,14 @@ public void queryWithContinuation() throws Exception {\n                     .setFilter(Query.field(\"num_value_2\").equalsValue(0))\n                     .build();\n             plan = planner.plan(query);\n-            assertThat(plan, filter(query.getFilter(), typeFilter(anything(), scan(unbounded()))));\n-            assertEquals(913370522, plan.planHash(PlanHashable.PlanHashKind.LEGACY));\n+            assertThat(plan, filter(Objects.requireNonNull(query.getFilter()), typeFilter(anything(), scan(unbounded()))));\n+            if (planner instanceof RecordQueryPlanner) {\n+                assertEquals(913370522, plan.planHash(PlanHashable.PlanHashKind.LEGACY));\n             // TODO: https://github.com/FoundationDB/fdb-record-layer/issues/1074\n             // assertEquals(389700036, plan.planHash(PlanHashable.PlanHashKind.STRUCTURAL_WITHOUT_LITERALS));\n+            } else {\n+                assertEquals(-1244637277, plan.planHash(PlanHashable.PlanHashKind.LEGACY));", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjQyMzg4NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572423885", "bodyText": "The plan can be different as it may use QueryComponent in filters rather than QueryPredicates, also sometimes predicates are reordered or the plan is different but verifiably better.", "author": "normen662", "createdAt": "2021-02-08T22:31:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDA3MTQ2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQwMzA1Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r560403057", "bodyText": "Should this be something like getCorrelation? To distinguish it from the other getBinding?", "author": "alecgrieser", "createdAt": "2021-01-19T18:45:11Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/EvaluationContext.java", "diffHunk": "@@ -99,6 +100,16 @@ public Object getBinding(@Nonnull String name) {\n         return bindings.get(name);\n     }\n \n+    /**\n+     * Get the value bound to a single parameter.\n+     *\n+     * @param alias the correlation identifier\n+     * @return the value bound to the given parameter\n+     */\n+    public Object getBinding(@Nonnull CorrelationIdentifier alias) {", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzEwNjk3Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r567106973", "bodyText": "It's meant to be an overload which also just acesses the bindings underlying map. In my mind I equate the terms correlation and alias but then the correlation is fed by a binding using the identifying means of a correlation to bind said alias to some data.", "author": "normen662", "createdAt": "2021-01-29T21:36:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQwMzA1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQwMzI1OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r560403259", "bodyText": "Similarly, should this be .withCorrelation?", "author": "alecgrieser", "createdAt": "2021-01-19T18:45:32Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/EvaluationContext.java", "diffHunk": "@@ -137,4 +148,17 @@ public EvaluationContext withBinding(@Nonnull String bindingName, @Nullable Obje\n         return childBuilder().setBinding(bindingName, value).build();\n     }\n \n+    /**\n+     * Create a new <code>EvaluationContext</code> with an additional binding.\n+     * The returned context will have all of the same state as the current\n+     * context included all bindings except that it will bind an additional\n+     * parameter to an additional value.\n+     *\n+     * @param alias the alias determining the binding name to add\n+     * @param value the value to bind the name to\n+     * @return a new <code>EvaluationContext</code> with the new binding\n+     */\n+    public EvaluationContext withBinding(@Nonnull CorrelationIdentifier alias, @Nullable Object value) {", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzEwNzM5Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r567107392", "bodyText": "see above.", "author": "normen662", "createdAt": "2021-01-29T21:37:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQwMzI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU2NTE0Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r560565142", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * more additional {@code PlannerExpression}s and/or zero or mode additional {@link PartialMatch}es. A rule is defined by:\n          \n          \n            \n             * more additional {@code PlannerExpression}s and/or zero or more additional {@link PartialMatch}es. A rule is defined by:", "author": "alecgrieser", "createdAt": "2021-01-19T23:19:21Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/CascadesPlanner.java", "diffHunk": "@@ -68,20 +63,21 @@\n  * </p>\n  *\n  * <p>\n- * Like many optimization frameworks, Cascades is driven by a set of {@link PlannerRule}s, each of which describes a\n+ * Like many optimization frameworks, Cascades is driven by sets of {@link PlannerRule}s that can be defined for\n+ * {@link RelationalExpression}s, {@link PartialMatch}es and {@link MatchPartition}s, each of which describes a\n  * particular transformation and encapsulates the logic for determining its applicability and applying it. The planner\n  * searches through its {@link PlannerRuleSet} to find a matching rule and then executes that rule, creating zero or\n- * more additional {@code PlannerExpression}s. A rule is defined by:\n+ * more additional {@code PlannerExpression}s and/or zero or mode additional {@link PartialMatch}es. A rule is defined by:", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU2NTU1Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r560565557", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Simplified enqueue/execute overview:\n          \n          \n            \n             * <p>\n          \n          \n            \n             * Simplified enqueue/execute overview:\n          \n          \n            \n             * </p>", "author": "alecgrieser", "createdAt": "2021-01-19T23:20:18Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/CascadesPlanner.java", "diffHunk": "@@ -111,6 +107,66 @@\n  * {@link CascadesCostModel} which is a heuristic model implemented as a {@link java.util.Comparator}.\n  * </p>\n  *\n+ * Simplified enqueue/execute overview:", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU2NjgxMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r560566813", "bodyText": "This won't render into anything useful when this becomes HTML through the doc generation process. There are probably fiddly ways of making this work, or by making it a verbatim expression, though making the whole thing verbatim loses the links (though I guess the links are only for IDEs anyway, because the classes are private?)", "author": "alecgrieser", "createdAt": "2021-01-19T23:23:23Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/CascadesPlanner.java", "diffHunk": "@@ -111,6 +107,66 @@\n  * {@link CascadesCostModel} which is a heuristic model implemented as a {@link java.util.Comparator}.\n  * </p>\n  *\n+ * Simplified enqueue/execute overview:\n+ *\n+ * {@link OptimizeGroup}\n+ *     if (not explored)\n+ *         enqueues\n+ *             this (again)\n+ *             {@link ExploreExpression} for each group member\n+ *         sets explored to {@code true}\n+ *     else\n+ *         prune to find best plan; done\n+ *\n+ * {@link ExploreGroup}\n+ *     enqueues\n+ *         {@link ExploreExpression} for each group member\n+ *     sets explored to {@code true}\n+ *\n+ * {@link ExploreExpression}\n+ *     enqueues\n+ *         all transformations ({@link TransformMatchPartition}) for match partitions of current (group, expression)\n+ *         all transformations ({@link TransformExpression} for current (group, expression)\n+ *         {@link ExploreGroup} for all ranged over groups\n+ *\n+ * after execution of any TransformXXX\n+ *     enqueues\n+ *         {@link AdjustMatch} for each yielded {@link PartialMatch}\n+ *         {@link OptimizeInputs} followed by {@link ExploreExpression} for each yielded {@link RecordQueryPlan}\n+ *         {@link ExploreExpression} for each yielded {@link RelationalExpression} that is not a {@link RecordQueryPlan}\n+ *\n+ * {@link AdjustMatch}\n+ *     enqueues\n+ *         all transformations ({@link TransformPartialMatch}) for current (group, expression, partial match)\n+ *\n+ * {@link OptimizeInputs}\n+ *     enqueues\n+ *         {@link OptimizeGroup} for all ranged over groups", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcyMTQ2Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571721462", "bodyText": "slapped a <pre> ... </pre> around it", "author": "normen662", "createdAt": "2021-02-07T23:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU2NjgxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU2Nzg1NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r560567855", "bodyText": "Is there a reason these two lines aren't ExploreGroup?", "author": "alecgrieser", "createdAt": "2021-01-19T23:24:47Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/CascadesPlanner.java", "diffHunk": "@@ -111,6 +107,66 @@\n  * {@link CascadesCostModel} which is a heuristic model implemented as a {@link java.util.Comparator}.\n  * </p>\n  *\n+ * Simplified enqueue/execute overview:\n+ *\n+ * {@link OptimizeGroup}\n+ *     if (not explored)\n+ *         enqueues\n+ *             this (again)\n+ *             {@link ExploreExpression} for each group member\n+ *         sets explored to {@code true}", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcyMTI2MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571721261", "bodyText": "I suppose that would be possible. This is however unchanged code so I will leave it as is.", "author": "normen662", "createdAt": "2021-02-07T23:52:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU2Nzg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU2ODYyOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r560568629", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *         all transformations ({@link TransformExpression} for current (group, expression)\n          \n          \n            \n             *         all transformations ({@link TransformExpression}) for current (group, expression)", "author": "alecgrieser", "createdAt": "2021-01-19T23:25:26Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/CascadesPlanner.java", "diffHunk": "@@ -111,6 +107,66 @@\n  * {@link CascadesCostModel} which is a heuristic model implemented as a {@link java.util.Comparator}.\n  * </p>\n  *\n+ * Simplified enqueue/execute overview:\n+ *\n+ * {@link OptimizeGroup}\n+ *     if (not explored)\n+ *         enqueues\n+ *             this (again)\n+ *             {@link ExploreExpression} for each group member\n+ *         sets explored to {@code true}\n+ *     else\n+ *         prune to find best plan; done\n+ *\n+ * {@link ExploreGroup}\n+ *     enqueues\n+ *         {@link ExploreExpression} for each group member\n+ *     sets explored to {@code true}\n+ *\n+ * {@link ExploreExpression}\n+ *     enqueues\n+ *         all transformations ({@link TransformMatchPartition}) for match partitions of current (group, expression)\n+ *         all transformations ({@link TransformExpression} for current (group, expression)", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU2OTI2NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r560569265", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Note: Enqueued tasks are executes in typical stack machine order, that is LIFO.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * Note: Enqueued tasks are executed in typical stack machine order, that is LIFO.\n          \n          \n            \n             * </p>\n          \n      \n    \n    \n  \n\nThat is, <p> tags and also executes to executed", "author": "alecgrieser", "createdAt": "2021-01-19T23:26:16Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/CascadesPlanner.java", "diffHunk": "@@ -111,6 +107,66 @@\n  * {@link CascadesCostModel} which is a heuristic model implemented as a {@link java.util.Comparator}.\n  * </p>\n  *\n+ * Simplified enqueue/execute overview:\n+ *\n+ * {@link OptimizeGroup}\n+ *     if (not explored)\n+ *         enqueues\n+ *             this (again)\n+ *             {@link ExploreExpression} for each group member\n+ *         sets explored to {@code true}\n+ *     else\n+ *         prune to find best plan; done\n+ *\n+ * {@link ExploreGroup}\n+ *     enqueues\n+ *         {@link ExploreExpression} for each group member\n+ *     sets explored to {@code true}\n+ *\n+ * {@link ExploreExpression}\n+ *     enqueues\n+ *         all transformations ({@link TransformMatchPartition}) for match partitions of current (group, expression)\n+ *         all transformations ({@link TransformExpression} for current (group, expression)\n+ *         {@link ExploreGroup} for all ranged over groups\n+ *\n+ * after execution of any TransformXXX\n+ *     enqueues\n+ *         {@link AdjustMatch} for each yielded {@link PartialMatch}\n+ *         {@link OptimizeInputs} followed by {@link ExploreExpression} for each yielded {@link RecordQueryPlan}\n+ *         {@link ExploreExpression} for each yielded {@link RelationalExpression} that is not a {@link RecordQueryPlan}\n+ *\n+ * {@link AdjustMatch}\n+ *     enqueues\n+ *         all transformations ({@link TransformPartialMatch}) for current (group, expression, partial match)\n+ *\n+ * {@link OptimizeInputs}\n+ *     enqueues\n+ *         {@link OptimizeGroup} for all ranged over groups\n+ *\n+ * Note: Enqueued tasks are executes in typical stack machine order, that is LIFO.", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU2OTQ5Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r560569492", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * There are three different kinds of transformations:\n          \n          \n            \n             * <p>\n          \n          \n            \n             * There are three different kinds of transformations:\n          \n          \n            \n             * </p>", "author": "alecgrieser", "createdAt": "2021-01-19T23:26:48Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/CascadesPlanner.java", "diffHunk": "@@ -111,6 +107,66 @@\n  * {@link CascadesCostModel} which is a heuristic model implemented as a {@link java.util.Comparator}.\n  * </p>\n  *\n+ * Simplified enqueue/execute overview:\n+ *\n+ * {@link OptimizeGroup}\n+ *     if (not explored)\n+ *         enqueues\n+ *             this (again)\n+ *             {@link ExploreExpression} for each group member\n+ *         sets explored to {@code true}\n+ *     else\n+ *         prune to find best plan; done\n+ *\n+ * {@link ExploreGroup}\n+ *     enqueues\n+ *         {@link ExploreExpression} for each group member\n+ *     sets explored to {@code true}\n+ *\n+ * {@link ExploreExpression}\n+ *     enqueues\n+ *         all transformations ({@link TransformMatchPartition}) for match partitions of current (group, expression)\n+ *         all transformations ({@link TransformExpression} for current (group, expression)\n+ *         {@link ExploreGroup} for all ranged over groups\n+ *\n+ * after execution of any TransformXXX\n+ *     enqueues\n+ *         {@link AdjustMatch} for each yielded {@link PartialMatch}\n+ *         {@link OptimizeInputs} followed by {@link ExploreExpression} for each yielded {@link RecordQueryPlan}\n+ *         {@link ExploreExpression} for each yielded {@link RelationalExpression} that is not a {@link RecordQueryPlan}\n+ *\n+ * {@link AdjustMatch}\n+ *     enqueues\n+ *         all transformations ({@link TransformPartialMatch}) for current (group, expression, partial match)\n+ *\n+ * {@link OptimizeInputs}\n+ *     enqueues\n+ *         {@link OptimizeGroup} for all ranged over groups\n+ *\n+ * Note: Enqueued tasks are executes in typical stack machine order, that is LIFO.\n+ *\n+ * There are three different kinds of transformations:", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU3MTM4MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r560571380", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *         Transforms on expressions {@link TransformExpression}. These are the classical transforms creating new\n          \n          \n            \n             *         Transforms on expressions: {@link TransformExpression}. These are the classical transforms creating new\n          \n      \n    \n    \n  \n\nI'm actually sure if that's quite the right punctuation mark here, but I think the colon helps emphasize that the class is being described (and helps separate it from its description a bit). In any case, whatever punctuation is used, it should be applied to the other two items in this list", "author": "alecgrieser", "createdAt": "2021-01-19T23:31:42Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/CascadesPlanner.java", "diffHunk": "@@ -111,6 +107,66 @@\n  * {@link CascadesCostModel} which is a heuristic model implemented as a {@link java.util.Comparator}.\n  * </p>\n  *\n+ * Simplified enqueue/execute overview:\n+ *\n+ * {@link OptimizeGroup}\n+ *     if (not explored)\n+ *         enqueues\n+ *             this (again)\n+ *             {@link ExploreExpression} for each group member\n+ *         sets explored to {@code true}\n+ *     else\n+ *         prune to find best plan; done\n+ *\n+ * {@link ExploreGroup}\n+ *     enqueues\n+ *         {@link ExploreExpression} for each group member\n+ *     sets explored to {@code true}\n+ *\n+ * {@link ExploreExpression}\n+ *     enqueues\n+ *         all transformations ({@link TransformMatchPartition}) for match partitions of current (group, expression)\n+ *         all transformations ({@link TransformExpression} for current (group, expression)\n+ *         {@link ExploreGroup} for all ranged over groups\n+ *\n+ * after execution of any TransformXXX\n+ *     enqueues\n+ *         {@link AdjustMatch} for each yielded {@link PartialMatch}\n+ *         {@link OptimizeInputs} followed by {@link ExploreExpression} for each yielded {@link RecordQueryPlan}\n+ *         {@link ExploreExpression} for each yielded {@link RelationalExpression} that is not a {@link RecordQueryPlan}\n+ *\n+ * {@link AdjustMatch}\n+ *     enqueues\n+ *         all transformations ({@link TransformPartialMatch}) for current (group, expression, partial match)\n+ *\n+ * {@link OptimizeInputs}\n+ *     enqueues\n+ *         {@link OptimizeGroup} for all ranged over groups\n+ *\n+ * Note: Enqueued tasks are executes in typical stack machine order, that is LIFO.\n+ *\n+ * There are three different kinds of transformations:\n+ * <ul>\n+ *     <li>\n+ *         Transforms on expressions {@link TransformExpression}. These are the classical transforms creating new", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU3MjExMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r560572113", "bodyText": "I assume at some point this class will take a RecordQueryPlannerConfiguration as an argument to one of its constructors?", "author": "alecgrieser", "createdAt": "2021-01-19T23:33:51Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/CascadesPlanner.java", "diffHunk": "@@ -129,25 +187,29 @@\n     @Nonnull\n     private GroupExpressionRef<RelationalExpression> currentRoot;\n     @Nonnull\n+    private AliasResolver aliasResolver;\n+    @Nonnull\n     private Deque<Task> taskStack; // Use a Dequeue instead of a Stack because we don't need synchronization.\n \n     public CascadesPlanner(@Nonnull RecordMetaData metaData, @Nonnull RecordStoreState recordStoreState) {\n         this(metaData, recordStoreState, PlannerRuleSet.ALL);\n     }\n \n     public CascadesPlanner(@Nonnull RecordMetaData metaData, @Nonnull RecordStoreState recordStoreState, @Nonnull PlannerRuleSet ruleSet) {\n+        this.configuration = RecordQueryPlannerConfiguration.builder().build();", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcyMjE3MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571722171", "bodyText": "It's set as mutation, the old planner does it the same way. Blech!", "author": "normen662", "createdAt": "2021-02-07T23:59:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU3MjExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU3Njg0MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r560576841", "bodyText": "This should probably be a KeyValueLogMessage, if for no other reason than that it will fit in better with our other logs (if one ever turns on trace level logs in a real environment)", "author": "alecgrieser", "createdAt": "2021-01-19T23:46:08Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/CascadesPlanner.java", "diffHunk": "@@ -372,225 +409,357 @@ public String toString() {\n         }\n     }\n \n-    private class Transform implements Task {\n+    /**\n+     * Abstract base class for all tasks that have a <em>current</em> (group, expression).\n+     */\n+    private abstract class ExploreTask implements Task {\n         @Nonnull\n         private final PlanContext context;\n         @Nonnull\n         private final GroupExpressionRef<RelationalExpression> group;\n         @Nonnull\n         private final RelationalExpression expression;\n-        @Nonnull\n-        private final PlannerRule<? extends RelationalExpression> rule;\n \n-        public Transform(@Nonnull PlanContext context,\n-                         @Nonnull GroupExpressionRef<RelationalExpression> group,\n-                         @Nonnull RelationalExpression expression,\n-                         @Nonnull PlannerRule<? extends RelationalExpression> rule) {\n+        public ExploreTask(@Nonnull PlanContext context,\n+                           @Nonnull GroupExpressionRef<RelationalExpression> group,\n+                           @Nonnull RelationalExpression expression) {\n             this.context = context;\n             this.group = group;\n             this.expression = expression;\n-            this.rule = rule;\n+        }\n+\n+        @Nonnull\n+        public PlanContext getContext() {\n+            return context;\n+        }\n+\n+        @Nonnull\n+        public GroupExpressionRef<RelationalExpression> getGroup() {\n+            return group;\n+        }\n+\n+        @Nonnull\n+        public RelationalExpression getExpression() {\n+            return expression;\n+        }\n+\n+        @Nonnull\n+        protected PlannerRuleSet getRules() {\n+            return ruleSet;\n+        }\n+    }\n+\n+    /**\n+     * Explore Expression Task.\n+     *\n+     * Simplified enqueue/execute overview:\n+     *\n+     * {@link ExploreExpression}\n+     *     enqueues\n+     *         all transformations ({@link TransformMatchPartition}) for match partitions of current (group, expression)\n+     *         all transformations ({@link TransformExpression} for current (group, expression)\n+     *         {@link ExploreGroup} for all ranged over groups\n+     */\n+    private class ExploreExpression extends ExploreTask {\n+        public ExploreExpression(@Nonnull PlanContext context,\n+                                 @Nonnull GroupExpressionRef<RelationalExpression> group,\n+                                 @Nonnull RelationalExpression expression) {\n+            super(context, group, expression);\n         }\n \n         @Override\n         public void execute() {\n-            if (!group.containsExactly(expression)) { // expression is gone\n-                return;\n-            }\n-            if (logger.isTraceEnabled()) {\n-                logger.trace(\"Bindings: \" +  expression.bindTo(rule.getMatcher()).count());\n-            }\n-            expression.bindTo(rule.getMatcher()).map(bindings -> new CascadesRuleCall(context, rule, group, bindings))\n-                    .forEach(ruleCall -> {\n-                        Debugger.withDebugger(debugger -> debugger.onEvent(new Debugger.TransformRuleCallEvent(currentRoot, taskStack, Location.BEGIN, group, expression, rule, ruleCall)));\n-                        executeRuleCall(ruleCall);\n-                        Debugger.withDebugger(debugger -> debugger.onEvent(new Debugger.TransformRuleCallEvent(currentRoot, taskStack, Location.END, group, expression, rule, ruleCall)));\n-                    });\n+            // Enqueue all rules that need to run after all exploration for a (group, expression) pair is done.\n+            ruleSet.getMatchPartitionRules().forEach(this::enqueueTransformPartialMatch);\n+\n+            // This is closely tied to the way that rule finding works _now_. Specifically, rules are indexed only\n+            // by the type of their _root_, not any of the stuff lower down. As a result, we have enough information\n+            // right here to determine the set of all possible rules that could ever be applied here, regardless of\n+            // what happens towards the leaves of the tree.\n+            ruleSet.getExpressionRules(getExpression()).forEach(this::enqueueTransformTask);\n+\n+            // Enqueue explore group for all groups this expression ranges over\n+            getExpression()\n+                    .getQuantifiers()\n+                    .stream()\n+                    .map(Quantifier::getRangesOver)\n+                    .forEach(this::enqueueExploreGroup);\n         }\n \n-        private void executeRuleCall(@Nonnull CascadesRuleCall ruleCall) {\n-            ruleCall.run();\n-            for (RelationalExpression newExpression : ruleCall.getNewExpressions()) {\n-                if (newExpression instanceof QueryPlan) {\n-                    taskStack.push(new OptimizeInputs(context, group, newExpression));\n-                    taskStack.push(new ExploreExpression(context, group, newExpression));\n-                } else {\n-                    taskStack.push(new ExploreExpression(context, group, newExpression));\n-                }\n-            }\n+        private void enqueueTransformTask(@Nonnull PlannerRule<? extends RelationalExpression> rule) {\n+            taskStack.push(new TransformExpression(getContext(), getGroup(), getExpression(), rule));\n+        }\n+\n+        private void enqueueTransformPartialMatch(PlannerRule<? extends MatchPartition> rule) {\n+            taskStack.push(new TransformMatchPartition(getContext(), getGroup(), getExpression(), rule));\n+        }\n+\n+        private void enqueueExploreGroup(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            taskStack.push(new ExploreGroup(getContext(), rangesOver));\n         }\n \n         @Override\n         public Debugger.Event toTaskEvent(final Location location) {\n-            return new Debugger.TransformEvent(currentRoot, taskStack, location, group, expression, rule);\n+            return new Debugger.ExploreExpressionEvent(currentRoot, taskStack, location, getGroup(), getExpression());\n         }\n \n         @Override\n         public String toString() {\n-            return \"Transform(\" + rule.getClass().getSimpleName() + \")\";\n+            return \"ExploreExpression(\" + getGroup() + \")\";\n         }\n     }\n \n-    private class MatchExpression implements Task {\n+    /**\n+     * Abstract base class for all transformations. All transformations are defined on a sub class of {@link Bindable}.\n+     * This base class uses just {@link Bindable} itself as it never has to reason or pass on the actual defined type\n+     * of the transform rule.\n+     */\n+    private abstract class AbstractTransform implements Task {\n         @Nonnull\n         private final PlanContext context;\n         @Nonnull\n         private final GroupExpressionRef<RelationalExpression> group;\n         @Nonnull\n         private final RelationalExpression expression;\n+        @Nonnull\n+        private final PlannerRule<? extends Bindable> rule;\n \n-        public MatchExpression(@Nonnull final PlanContext context, @Nonnull final GroupExpressionRef<RelationalExpression> group, @Nonnull final RelationalExpression expression) {\n+        protected AbstractTransform(@Nonnull PlanContext context,\n+                                    @Nonnull GroupExpressionRef<RelationalExpression> group,\n+                                    @Nonnull RelationalExpression expression,\n+                                    @Nonnull PlannerRule<? extends Bindable> rule) {\n             this.context = context;\n             this.group = group;\n             this.expression = expression;\n+            this.rule = rule;\n+        }\n+\n+        @Nonnull\n+        public PlanContext getContext() {\n+            return context;\n+        }\n+\n+        @Nonnull\n+        public GroupExpressionRef<RelationalExpression> getGroup() {\n+            return group;\n+        }\n+\n+        @Nonnull\n+        public RelationalExpression getExpression() {\n+            return expression;\n+        }\n+\n+        @Nonnull\n+        public PlannerRule<? extends Bindable> getRule() {\n+            return rule;\n         }\n \n+        @Nonnull\n+        protected abstract Bindable getBindable();\n+\n+        @Nonnull\n+        protected PlannerBindings getInitialBindings() {\n+            return PlannerBindings.empty();\n+        }\n+\n+        protected boolean shouldExecute() {\n+            return true;\n+        }\n+\n+        /**\n+         * Method that calls the actual rule and reacts to new constructs the rule yielded.\n+         *\n+         * Simplified enqueue/execute overview:\n+         *\n+         * executes rule\n+         * enqueues\n+         *     {@link AdjustMatch} for each yielded {@link PartialMatch}\n+         *     {@link OptimizeInputs} followed by {@link ExploreExpression} for each yielded {@link RecordQueryPlan}\n+         *     {@link ExploreExpression} for each yielded {@link RelationalExpression} that is not a {@link RecordQueryPlan}\n+         */\n         @Override\n         public void execute() {\n-            final ImmutableList<? extends ExpressionRef<? extends RelationalExpression>> rangesOverRefs =\n-                    expression.getQuantifiers()\n-                            .stream()\n-                            .map(Quantifier::getRangesOver)\n-                            .collect(ImmutableList.toImmutableList());\n-\n-            if (rangesOverRefs.isEmpty()) {\n-                for (final MatchCandidate matchCandidate : context.getMatchCandidates()) {\n-                    final ExpressionRefTraversal traversal = matchCandidate.getTraversal();\n-                    final Set<ExpressionRef<? extends RelationalExpression>> leafRefs = traversal.getLeafRefs();\n-                    for (final ExpressionRef<? extends RelationalExpression> leafRef : leafRefs) {\n-                        for (final RelationalExpression leafMember : leafRef.getMembers()) {\n-                            if (leafMember.getQuantifiers().isEmpty()) {\n-                                taskStack.push(new MatchExpressionWithCandidate(context,\n-                                        group,\n-                                        expression,\n-                                        matchCandidate,\n-                                        leafRef,\n-                                        leafMember));\n-                            }\n-                        }\n-                    }\n-                }\n-            } else {\n-                // form intersection of all possible match candidates\n-                final ExpressionRef<? extends RelationalExpression> firstRangesOverRef = rangesOverRefs.get(0);\n-                final Set<MatchCandidate> commonMatchCandidates = Sets.newHashSet(firstRangesOverRef.getMatchCandidates());\n-                for (int i = 0; i < rangesOverRefs.size(); i++) {\n-                    final ExpressionRef<? extends RelationalExpression> rangesOverGroup = rangesOverRefs.get(i);\n-                    commonMatchCandidates.retainAll(rangesOverGroup.getMatchCandidates());\n-                }\n+            final GroupExpressionRef<RelationalExpression> group = getGroup();\n+            final PlannerRule<? extends Bindable> rule = getRule();\n+            if (!shouldExecute()) {\n+                return;\n+            }\n \n-                for (final MatchCandidate matchCandidate : commonMatchCandidates) {\n-                    final ExpressionRefTraversal traversal = matchCandidate.getTraversal();\n-                    for (final ExpressionRef<? extends RelationalExpression> rangesOverRef : rangesOverRefs) {\n-                        final Set<PartialMatch> partialMatchesForCandidate = rangesOverRef.getPartialMatchesForCandidate(matchCandidate);\n-                        for (final PartialMatch partialMatch : partialMatchesForCandidate) {\n-                            for (final ExpressionRefTraversal.RefPath parentRefPath : traversal.getParentRefPaths(partialMatch.getCandidateRef())) {\n-                                taskStack.push(new MatchExpressionWithCandidate(context,\n-                                        group,\n-                                        expression,\n-                                        matchCandidate,\n-                                        parentRefPath.getRef(),\n-                                        parentRefPath.getExpression()));\n-                            }\n-                        }\n-                    }\n+            final PlannerBindings initialBindings = getInitialBindings();\n+\n+            if (logger.isTraceEnabled()) {\n+                logger.trace(\"Bindings: \" +  getBindable().bindTo(initialBindings, rule.getMatcher()).count());", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcyMzEzMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571723131", "bodyText": "Point taken in general. Will remove this one as it is pretty pointless now that we have an actual debugger.", "author": "normen662", "createdAt": "2021-02-08T00:06:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU3Njg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU3Nzc3OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r560577779", "bodyText": "Does this class need to be public?", "author": "alecgrieser", "createdAt": "2021-01-19T23:48:29Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ChooseK.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/*\n+ * CrossProduct.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.PeekingIterator;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+\n+/**\n+ * Utility class to provide helpers related to enumeration of cross products.\n+ *\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public class ChooseK {", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzQ5MDI5Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r567490296", "bodyText": "Yes, I am actually thinking of moving this into a utility package eventually (at which point it should be public).", "author": "normen662", "createdAt": "2021-01-31T21:57:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU3Nzc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU4MjA4Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r560582083", "bodyText": "This feels like it's losing the split point information, so I'm not sure how the planner will distinguish between what parts of the expression are ordered (i.e., the key parts of innerKey) and which parts are not ordered (i.e., the value parts of innerKey)", "author": "alecgrieser", "createdAt": "2021-01-20T00:00:20Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/metadata/expressions/KeyWithValueExpression.java", "diffHunk": "@@ -142,8 +144,10 @@ public int getChildColumnSize() {\n \n     @Nonnull\n     @Override\n-    public KeyExpression normalizeForPlanner(@Nonnull Source source, @Nonnull List<String> fieldNamePrefix) {\n-        return new KeyWithValueExpression(innerKey.normalizeForPlanner(source, fieldNamePrefix), splitPoint);\n+    public ExpandedPredicates expandForPlanner(@Nonnull final CorrelationIdentifier baseAlias,\n+                                               @Nonnull final Supplier<CorrelationIdentifier> parameterAliasSupplier,\n+                                               @Nonnull final List<String> fieldNamePrefix) {\n+        return innerKey.expandForPlanner(baseAlias, parameterAliasSupplier, fieldNamePrefix);", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcxNTIwNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571715204", "bodyText": "In the reimplementation of this expansion this is taken care of by a state object during expansion.", "author": "normen662", "createdAt": "2021-02-07T23:06:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU4MjA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU4MzIxMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r560583210", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * {@code A_s} and {@code B_s} may be completely equivalent to each other and {@code Q_s} can be substituted with\n          \n          \n            \n             * {@code Q_s} and {@code M_s} may be completely equivalent to each other and {@code Q_s} can be substituted with\n          \n      \n    \n    \n  \n\nI think?", "author": "alecgrieser", "createdAt": "2021-01-20T00:04:06Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Compensation.java", "diffHunk": "@@ -0,0 +1,333 @@\n+/*\n+ * Compensation.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.LogicalFilterExpression;\n+import com.apple.foundationdb.record.query.plan.temp.rules.DataAccessRule;\n+import com.apple.foundationdb.record.query.predicates.AndPredicate;\n+import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Maps;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Collection;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Interface for all kinds of compensation. A compensation is the byproduct of expression DAG matching.\n+ * Matching two graphs {@code Q} and {@code M} may yield two sub graphs {@code Q_s} and {@code M_s} that match.\n+ * {@code A_s} and {@code B_s} may be completely equivalent to each other and {@code Q_s} can be substituted with", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcyNTgzMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571725832", "bodyText": "You are correct. That's what happens when you change the naming midway :-)", "author": "normen662", "createdAt": "2021-02-08T00:26:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU4MzIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU4MzM4Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r560583386", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * result from the raw base data set. For those purposes it makes more sense to relax the matching requirement to just\n          \n          \n            \n             * result from the raw base data set. For those purposes, it makes more sense to relax the matching requirement to just", "author": "alecgrieser", "createdAt": "2021-01-20T00:04:41Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Compensation.java", "diffHunk": "@@ -0,0 +1,333 @@\n+/*\n+ * Compensation.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.LogicalFilterExpression;\n+import com.apple.foundationdb.record.query.plan.temp.rules.DataAccessRule;\n+import com.apple.foundationdb.record.query.predicates.AndPredicate;\n+import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Maps;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Collection;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Interface for all kinds of compensation. A compensation is the byproduct of expression DAG matching.\n+ * Matching two graphs {@code Q} and {@code M} may yield two sub graphs {@code Q_s} and {@code M_s} that match.\n+ * {@code A_s} and {@code B_s} may be completely equivalent to each other and {@code Q_s} can be substituted with\n+ * {@code M_s} freely and vice versa. The requirement that {@code Q_s} and {@code M_s} have to be semantically\n+ * equivalent for such a substitution, however, is not very useful. Normally, we try to find a materialized data set\n+ * such as an index that can be utilized by the planner directly using a scan\n+ * (requiring a complete match on the {@code M}-side, that is {@code M_s} equals {@code M}) instead of computing the\n+ * result from the raw base data set. For those purposes it makes more sense to relax the matching requirement to just", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU4NDE3OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r560584179", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * require that the materialized view side of matching {@code M} can subsume the query side {@code M} which means that\n          \n          \n            \n             * require that the materialized view side of matching {@code M} can subsume the query side {@code Q}, which means that\n          \n      \n    \n    \n  \n\nI think", "author": "alecgrieser", "createdAt": "2021-01-20T00:06:58Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Compensation.java", "diffHunk": "@@ -0,0 +1,333 @@\n+/*\n+ * Compensation.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.LogicalFilterExpression;\n+import com.apple.foundationdb.record.query.plan.temp.rules.DataAccessRule;\n+import com.apple.foundationdb.record.query.predicates.AndPredicate;\n+import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Maps;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Collection;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Interface for all kinds of compensation. A compensation is the byproduct of expression DAG matching.\n+ * Matching two graphs {@code Q} and {@code M} may yield two sub graphs {@code Q_s} and {@code M_s} that match.\n+ * {@code A_s} and {@code B_s} may be completely equivalent to each other and {@code Q_s} can be substituted with\n+ * {@code M_s} freely and vice versa. The requirement that {@code Q_s} and {@code M_s} have to be semantically\n+ * equivalent for such a substitution, however, is not very useful. Normally, we try to find a materialized data set\n+ * such as an index that can be utilized by the planner directly using a scan\n+ * (requiring a complete match on the {@code M}-side, that is {@code M_s} equals {@code M}) instead of computing the\n+ * result from the raw base data set. For those purposes it makes more sense to relax the matching requirement to just\n+ * require that the materialized view side of matching {@code M} can subsume the query side {@code M} which means that", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcyNjA5Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571726097", "bodyText": "You are paying attention! :-)", "author": "normen662", "createdAt": "2021-02-08T00:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU4NDE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU4NDU0MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r560584541", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * executing {@code M} at least contains the result result executing {@code Q} would result in. But it may produce\n          \n          \n            \n             * executing {@code M} at least contains the results that executing {@code Q} would result in, but it may produce", "author": "alecgrieser", "createdAt": "2021-01-20T00:07:53Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Compensation.java", "diffHunk": "@@ -0,0 +1,333 @@\n+/*\n+ * Compensation.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.LogicalFilterExpression;\n+import com.apple.foundationdb.record.query.plan.temp.rules.DataAccessRule;\n+import com.apple.foundationdb.record.query.predicates.AndPredicate;\n+import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Maps;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Collection;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Interface for all kinds of compensation. A compensation is the byproduct of expression DAG matching.\n+ * Matching two graphs {@code Q} and {@code M} may yield two sub graphs {@code Q_s} and {@code M_s} that match.\n+ * {@code A_s} and {@code B_s} may be completely equivalent to each other and {@code Q_s} can be substituted with\n+ * {@code M_s} freely and vice versa. The requirement that {@code Q_s} and {@code M_s} have to be semantically\n+ * equivalent for such a substitution, however, is not very useful. Normally, we try to find a materialized data set\n+ * such as an index that can be utilized by the planner directly using a scan\n+ * (requiring a complete match on the {@code M}-side, that is {@code M_s} equals {@code M}) instead of computing the\n+ * result from the raw base data set. For those purposes it makes more sense to relax the matching requirement to just\n+ * require that the materialized view side of matching {@code M} can subsume the query side {@code M} which means that\n+ * executing {@code M} at least contains the result result executing {@code Q} would result in. But it may produce", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU4ODQ2NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r560588465", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Example in SQL terms:\n          \n          \n            \n             *\n          \n          \n            \n             * Query:\n          \n          \n            \n             * <pre>\n          \n          \n            \n             * {@code\n          \n          \n            \n             *   SELECT *\n          \n          \n            \n             *   FROM recordType\n          \n          \n            \n             *   WHERE a = 3 AND b = 5\n          \n          \n            \n             * }\n          \n          \n            \n             * </pre>\n          \n          \n            \n             *\n          \n          \n            \n             * Index:\n          \n          \n            \n             * <pre>\n          \n          \n            \n             * {@code\n          \n          \n            \n             *   SELECT *\n          \n          \n            \n             *   FROM recordType\n          \n          \n            \n             *   WHERE a <comparison parameter p0>\n          \n          \n            \n             *   ORDER BY a\n          \n          \n            \n             * }\n          \n          \n            \n             * </pre>\n          \n          \n            \n             *\n          \n          \n            \n             * A match for the two graphs created for both query and index side is:\n          \n          \n            \n             * <pre>\n          \n          \n            \n             * {@code\n          \n          \n            \n             *   SELECT *\n          \n          \n            \n             *   FROM recordType\n          \n          \n            \n             *   WHERE a <p0 -> \"= 3\">\n          \n          \n            \n             *   ORDER BY a\n          \n          \n            \n             * }\n          \n          \n            \n             * </pre>\n          \n          \n            \n             * Using this graph we can now substitute the scan over the index but we will have to account for the unmatched\n          \n          \n            \n             * second predicate in {@code Q}:\n          \n          \n            \n             * <pre>\n          \n          \n            \n             * {@code\n          \n          \n            \n             *   SELECT *\n          \n          \n            \n             *   FROM index\n          \n          \n            \n             *   WHERE b = 5\n          \n          \n            \n             * }\n          \n          \n            \n             * </pre>\n          \n          \n            \n             * The query fragment that needs to be inserted to correct for extra records the index scan produces, that is\n          \n          \n            \n             * the {@code WHERE x = 5} is compensation.\n          \n          \n            \n             *\n          \n          \n            \n             * Compensation is computed either during the matching process or is computed after a complete match has been found\n          \n          \n            \n             * utilizing helper structures such as {@link PartialMatch} and {@link MatchInfo}, which are themselves\n          \n          \n            \n             * built during matching. Logic in\n          \n          \n            \n             * {@link DataAccessRule} computes and applies compensation\n          \n          \n            \n             * as needed when a complete index match has been found.\n          \n          \n            \n             *\n          \n          \n            \n             * A query sub graph can have multiple matches that could be utilized. In the example above, another index on {@code b}\n          \n          \n            \n             * would also match but use {@code b} for the index scan and a predicate {@code WHERE a = 3}. Both match the query,\n          \n          \n            \n             * and in fact both indexes can be utilized together by intersecting the index scans. For those cases, it becomes\n          \n          \n            \n             * important to be able to intersect compensations as well such that only the minimally required combined\n          \n          \n            \n             * compensation is required. In this example, no compensation is required as the individual indexes being intersected\n          \n          \n            \n             * complement each other nicely.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * Example in SQL terms:\n          \n          \n            \n             * </p>\n          \n          \n            \n             *\n          \n          \n            \n             * <p>\n          \n          \n            \n             * Query: <br>\n          \n          \n            \n             * <pre>\n          \n          \n            \n             * {@code\n          \n          \n            \n             *   SELECT *\n          \n          \n            \n             *   FROM recordType\n          \n          \n            \n             *   WHERE a = 3 AND b = 5\n          \n          \n            \n             * }\n          \n          \n            \n             * </pre></p>\n          \n          \n            \n             *\n          \n          \n            \n             * <p>\n          \n          \n            \n             * Index: <br>\n          \n          \n            \n             * <pre>\n          \n          \n            \n             * {@code\n          \n          \n            \n             *   SELECT *\n          \n          \n            \n             *   FROM recordType\n          \n          \n            \n             *   WHERE a <comparison parameter p0>\n          \n          \n            \n             *   ORDER BY a\n          \n          \n            \n             * }\n          \n          \n            \n             * </pre></p>\n          \n          \n            \n             *\n          \n          \n            \n             * <p>\n          \n          \n            \n             * A match for the two graphs created for both query and index side is:<br>\n          \n          \n            \n             * <pre>\n          \n          \n            \n             * {@code\n          \n          \n            \n             *   SELECT *\n          \n          \n            \n             *   FROM recordType\n          \n          \n            \n             *   WHERE a <p0 -> \"= 3\">\n          \n          \n            \n             *   ORDER BY a\n          \n          \n            \n             * }\n          \n          \n            \n             * </pre></p>\n          \n          \n            \n             *\n          \n          \n            \n             * <p>\n          \n          \n            \n             * Using this graph we can now substitute the scan over the index but we will have to account for the unmatched\n          \n          \n            \n             * second predicate in {@code Q}:<br/>\n          \n          \n            \n             * <pre>\n          \n          \n            \n             * {@code\n          \n          \n            \n             *   SELECT *\n          \n          \n            \n             *   FROM index\n          \n          \n            \n             *   WHERE b = 5\n          \n          \n            \n             * }\n          \n          \n            \n             * </pre></p>\n          \n          \n            \n             *\n          \n          \n            \n             * <p>\n          \n          \n            \n             * The query fragment that needs to be inserted to correct for extra records the index scan produces, that is\n          \n          \n            \n             * the {@code WHERE x = 5} is compensation.\n          \n          \n            \n             * </p>\n          \n          \n            \n             *\n          \n          \n            \n             * <p>\n          \n          \n            \n             * Compensation is computed either during the matching process or is computed after a complete match has been found\n          \n          \n            \n             * utilizing helper structures such as {@link PartialMatch} and {@link MatchInfo}, which are themselves\n          \n          \n            \n             * built during matching. Logic in\n          \n          \n            \n             * {@link DataAccessRule} computes and applies compensation\n          \n          \n            \n             * as needed when a complete index match has been found.\n          \n          \n            \n             * </p>\n          \n          \n            \n             *\n          \n          \n            \n             * <p>\n          \n          \n            \n             * A query sub-graph can have multiple matches that could be utilized. In the example above, another index on {@code b}\n          \n          \n            \n             * would also match but use {@code b} for the index scan and a predicate {@code WHERE a = 3}. Both match the query,\n          \n          \n            \n             * and in fact both indexes can be utilized together by intersecting the index scans. For those cases, it becomes\n          \n          \n            \n             * important to be able to intersect compensations as well such that only the minimally required combined\n          \n          \n            \n             * compensation is required. In this example, no compensation is required as the individual indexes being intersected\n          \n          \n            \n             * complement each other nicely.\n          \n          \n            \n             * </p>\n          \n      \n    \n    \n  \n\nHmm, GitHub's diff algorithm isn't very good apparently, but this is just adding HTML tags and one other change (\"sub graph\" -> \"graph\"). I appreciated this explanation of compensation, though!", "author": "alecgrieser", "createdAt": "2021-01-20T00:19:45Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Compensation.java", "diffHunk": "@@ -0,0 +1,333 @@\n+/*\n+ * Compensation.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.LogicalFilterExpression;\n+import com.apple.foundationdb.record.query.plan.temp.rules.DataAccessRule;\n+import com.apple.foundationdb.record.query.predicates.AndPredicate;\n+import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Maps;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Collection;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Interface for all kinds of compensation. A compensation is the byproduct of expression DAG matching.\n+ * Matching two graphs {@code Q} and {@code M} may yield two sub graphs {@code Q_s} and {@code M_s} that match.\n+ * {@code A_s} and {@code B_s} may be completely equivalent to each other and {@code Q_s} can be substituted with\n+ * {@code M_s} freely and vice versa. The requirement that {@code Q_s} and {@code M_s} have to be semantically\n+ * equivalent for such a substitution, however, is not very useful. Normally, we try to find a materialized data set\n+ * such as an index that can be utilized by the planner directly using a scan\n+ * (requiring a complete match on the {@code M}-side, that is {@code M_s} equals {@code M}) instead of computing the\n+ * result from the raw base data set. For those purposes it makes more sense to relax the matching requirement to just\n+ * require that the materialized view side of matching {@code M} can subsume the query side {@code M} which means that\n+ * executing {@code M} at least contains the result result executing {@code Q} would result in. But it may produce\n+ * extraneous records. Compensation corrects for that problem by applying certain post-operations such as\n+ * filtering, distincting or resorting.\n+ *\n+ * Example in SQL terms:\n+ *\n+ * Query:\n+ * <pre>\n+ * {@code\n+ *   SELECT *\n+ *   FROM recordType\n+ *   WHERE a = 3 AND b = 5\n+ * }\n+ * </pre>\n+ *\n+ * Index:\n+ * <pre>\n+ * {@code\n+ *   SELECT *\n+ *   FROM recordType\n+ *   WHERE a <comparison parameter p0>\n+ *   ORDER BY a\n+ * }\n+ * </pre>\n+ *\n+ * A match for the two graphs created for both query and index side is:\n+ * <pre>\n+ * {@code\n+ *   SELECT *\n+ *   FROM recordType\n+ *   WHERE a <p0 -> \"= 3\">\n+ *   ORDER BY a\n+ * }\n+ * </pre>\n+ * Using this graph we can now substitute the scan over the index but we will have to account for the unmatched\n+ * second predicate in {@code Q}:\n+ * <pre>\n+ * {@code\n+ *   SELECT *\n+ *   FROM index\n+ *   WHERE b = 5\n+ * }\n+ * </pre>\n+ * The query fragment that needs to be inserted to correct for extra records the index scan produces, that is\n+ * the {@code WHERE x = 5} is compensation.\n+ *\n+ * Compensation is computed either during the matching process or is computed after a complete match has been found\n+ * utilizing helper structures such as {@link PartialMatch} and {@link MatchInfo}, which are themselves\n+ * built during matching. Logic in\n+ * {@link DataAccessRule} computes and applies compensation\n+ * as needed when a complete index match has been found.\n+ *\n+ * A query sub graph can have multiple matches that could be utilized. In the example above, another index on {@code b}\n+ * would also match but use {@code b} for the index scan and a predicate {@code WHERE a = 3}. Both match the query,\n+ * and in fact both indexes can be utilized together by intersecting the index scans. For those cases, it becomes\n+ * important to be able to intersect compensations as well such that only the minimally required combined\n+ * compensation is required. In this example, no compensation is required as the individual indexes being intersected\n+ * complement each other nicely.", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU4OTg0NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r560589845", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Returns a compensation which represents the <em>impossible</em> compensation, i.e. it returns an object where\n          \n          \n            \n                 * {@link #isNeeded()} returns {@code true} however, that cannot be applied. This object is only needed to define\n          \n          \n            \n                 * Returns a compensation which represents the <em>impossible</em> compensation, i.e., it returns an object where\n          \n          \n            \n                 * {@link #isNeeded()} returns {@code true} but that cannot be applied. This object is only needed to define", "author": "alecgrieser", "createdAt": "2021-01-20T00:23:55Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Compensation.java", "diffHunk": "@@ -0,0 +1,333 @@\n+/*\n+ * Compensation.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.LogicalFilterExpression;\n+import com.apple.foundationdb.record.query.plan.temp.rules.DataAccessRule;\n+import com.apple.foundationdb.record.query.predicates.AndPredicate;\n+import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Maps;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Collection;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Interface for all kinds of compensation. A compensation is the byproduct of expression DAG matching.\n+ * Matching two graphs {@code Q} and {@code M} may yield two sub graphs {@code Q_s} and {@code M_s} that match.\n+ * {@code A_s} and {@code B_s} may be completely equivalent to each other and {@code Q_s} can be substituted with\n+ * {@code M_s} freely and vice versa. The requirement that {@code Q_s} and {@code M_s} have to be semantically\n+ * equivalent for such a substitution, however, is not very useful. Normally, we try to find a materialized data set\n+ * such as an index that can be utilized by the planner directly using a scan\n+ * (requiring a complete match on the {@code M}-side, that is {@code M_s} equals {@code M}) instead of computing the\n+ * result from the raw base data set. For those purposes it makes more sense to relax the matching requirement to just\n+ * require that the materialized view side of matching {@code M} can subsume the query side {@code M} which means that\n+ * executing {@code M} at least contains the result result executing {@code Q} would result in. But it may produce\n+ * extraneous records. Compensation corrects for that problem by applying certain post-operations such as\n+ * filtering, distincting or resorting.\n+ *\n+ * Example in SQL terms:\n+ *\n+ * Query:\n+ * <pre>\n+ * {@code\n+ *   SELECT *\n+ *   FROM recordType\n+ *   WHERE a = 3 AND b = 5\n+ * }\n+ * </pre>\n+ *\n+ * Index:\n+ * <pre>\n+ * {@code\n+ *   SELECT *\n+ *   FROM recordType\n+ *   WHERE a <comparison parameter p0>\n+ *   ORDER BY a\n+ * }\n+ * </pre>\n+ *\n+ * A match for the two graphs created for both query and index side is:\n+ * <pre>\n+ * {@code\n+ *   SELECT *\n+ *   FROM recordType\n+ *   WHERE a <p0 -> \"= 3\">\n+ *   ORDER BY a\n+ * }\n+ * </pre>\n+ * Using this graph we can now substitute the scan over the index but we will have to account for the unmatched\n+ * second predicate in {@code Q}:\n+ * <pre>\n+ * {@code\n+ *   SELECT *\n+ *   FROM index\n+ *   WHERE b = 5\n+ * }\n+ * </pre>\n+ * The query fragment that needs to be inserted to correct for extra records the index scan produces, that is\n+ * the {@code WHERE x = 5} is compensation.\n+ *\n+ * Compensation is computed either during the matching process or is computed after a complete match has been found\n+ * utilizing helper structures such as {@link PartialMatch} and {@link MatchInfo}, which are themselves\n+ * built during matching. Logic in\n+ * {@link DataAccessRule} computes and applies compensation\n+ * as needed when a complete index match has been found.\n+ *\n+ * A query sub graph can have multiple matches that could be utilized. In the example above, another index on {@code b}\n+ * would also match but use {@code b} for the index scan and a predicate {@code WHERE a = 3}. Both match the query,\n+ * and in fact both indexes can be utilized together by intersecting the index scans. For those cases, it becomes\n+ * important to be able to intersect compensations as well such that only the minimally required combined\n+ * compensation is required. In this example, no compensation is required as the individual indexes being intersected\n+ * complement each other nicely.\n+ */\n+public interface Compensation extends Function<ExpressionRef<RelationalExpression>, RelationalExpression> {\n+    /**\n+     * Named object to indicate that this compensation is in fact no compensation, that is no additional operators\n+     * need to be injected to compensate for a match.\n+     */\n+    Compensation NO_COMPENSATION = new Compensation() {\n+        @Override\n+        public boolean isNeeded() {\n+            return false;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public Compensation intersect(@Nonnull final Compensation otherCompensation) {\n+            return this;\n+        }\n+\n+        @Override\n+        public RelationalExpression apply(final ExpressionRef<RelationalExpression> reference) {\n+            throw new RecordCoreException(\"this method should not be called\");\n+        }\n+    };\n+\n+    /**\n+     * Identity element for the intersection monoid defined by {@link #intersect(Compensation)}.\n+     * Example for the usage pattern for that monoid:\n+     *\n+     * Let {@code compensations} be a {@link Collection} of {@link Compensation}.\n+     * You can use {@link java.util.stream.Stream#reduce} to create an intersection of\n+     * all compensations in that collection.\n+     * <pre>\n+     * {code\n+     * final Compensations intersectedCompensations =\n+     *   compensations\n+     *     .stream()\n+     *     .reduce(Compensation.impossibleCompensation(), Compensation::intersect);\n+     * }\n+     * </pre>\n+     * Note that if {@code compensations} is empty, the result of the intersection is the impossible compensation.\n+     */\n+    Compensation IMPOSSIBLE_COMPENSATION = new Compensation() {\n+        @Override\n+        public boolean isNeeded() {\n+            return true;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public Compensation intersect(@Nonnull final Compensation otherCompensation) {\n+            return otherCompensation;\n+        }\n+\n+        @Override\n+        public RelationalExpression apply(final ExpressionRef<RelationalExpression> reference) {\n+            throw new RecordCoreException(\"this method should not be called\");\n+        }\n+    };\n+\n+    /**\n+     * Returns if this compensation object needs to be applied in order to correct the result of a match.\n+     * @return {@code true} if this compensation must be applied, {@code false} if this compensation is not needed.\n+     *         Note, by contract it is illegal to call {@link #apply} on this compensation if this method returns\n+     *         {@code false}.\n+     */\n+    default boolean isNeeded() {\n+        return true;\n+    }\n+\n+    /**\n+     * Intersect this compensation with another one passed in.\n+     * @param otherCompensation other compensation to intersect this compensation with\n+     * @return the new compensation representing the intersection of both compensations\n+     */\n+    @Nonnull\n+    default Compensation intersect(@Nonnull Compensation otherCompensation) {\n+        if (!isNeeded() || !otherCompensation.isNeeded()) {\n+            return noCompensation();\n+        }\n+\n+        return new Compensation() {\n+            @Nonnull\n+            @Override\n+            public RelationalExpression apply(@Nonnull final ExpressionRef<RelationalExpression> reference) {\n+                return Compensation.this.apply(\n+                        GroupExpressionRef.of(otherCompensation\n+                                .apply(reference)));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Returns a compensation which represents no compensation at all, i.e. it returns an object where\n+     * {@link #isNeeded()} returns {@code false}. That object cannot be applied.\n+     * @return a compensation object that represents the absence of the need for compensation\n+     */\n+    @Nonnull\n+    static Compensation noCompensation() {\n+        return NO_COMPENSATION;\n+    }\n+\n+    /**\n+     * Returns a compensation which represents the <em>impossible</em> compensation, i.e. it returns an object where\n+     * {@link #isNeeded()} returns {@code true} however, that cannot be applied. This object is only needed to define", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYwMzYyOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r560603628", "bodyText": "Why doesn't it matter which side it's taken from?", "author": "alecgrieser", "createdAt": "2021-01-20T01:03:24Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Compensation.java", "diffHunk": "@@ -0,0 +1,333 @@\n+/*\n+ * Compensation.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.LogicalFilterExpression;\n+import com.apple.foundationdb.record.query.plan.temp.rules.DataAccessRule;\n+import com.apple.foundationdb.record.query.predicates.AndPredicate;\n+import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Maps;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Collection;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Interface for all kinds of compensation. A compensation is the byproduct of expression DAG matching.\n+ * Matching two graphs {@code Q} and {@code M} may yield two sub graphs {@code Q_s} and {@code M_s} that match.\n+ * {@code A_s} and {@code B_s} may be completely equivalent to each other and {@code Q_s} can be substituted with\n+ * {@code M_s} freely and vice versa. The requirement that {@code Q_s} and {@code M_s} have to be semantically\n+ * equivalent for such a substitution, however, is not very useful. Normally, we try to find a materialized data set\n+ * such as an index that can be utilized by the planner directly using a scan\n+ * (requiring a complete match on the {@code M}-side, that is {@code M_s} equals {@code M}) instead of computing the\n+ * result from the raw base data set. For those purposes it makes more sense to relax the matching requirement to just\n+ * require that the materialized view side of matching {@code M} can subsume the query side {@code M} which means that\n+ * executing {@code M} at least contains the result result executing {@code Q} would result in. But it may produce\n+ * extraneous records. Compensation corrects for that problem by applying certain post-operations such as\n+ * filtering, distincting or resorting.\n+ *\n+ * Example in SQL terms:\n+ *\n+ * Query:\n+ * <pre>\n+ * {@code\n+ *   SELECT *\n+ *   FROM recordType\n+ *   WHERE a = 3 AND b = 5\n+ * }\n+ * </pre>\n+ *\n+ * Index:\n+ * <pre>\n+ * {@code\n+ *   SELECT *\n+ *   FROM recordType\n+ *   WHERE a <comparison parameter p0>\n+ *   ORDER BY a\n+ * }\n+ * </pre>\n+ *\n+ * A match for the two graphs created for both query and index side is:\n+ * <pre>\n+ * {@code\n+ *   SELECT *\n+ *   FROM recordType\n+ *   WHERE a <p0 -> \"= 3\">\n+ *   ORDER BY a\n+ * }\n+ * </pre>\n+ * Using this graph we can now substitute the scan over the index but we will have to account for the unmatched\n+ * second predicate in {@code Q}:\n+ * <pre>\n+ * {@code\n+ *   SELECT *\n+ *   FROM index\n+ *   WHERE b = 5\n+ * }\n+ * </pre>\n+ * The query fragment that needs to be inserted to correct for extra records the index scan produces, that is\n+ * the {@code WHERE x = 5} is compensation.\n+ *\n+ * Compensation is computed either during the matching process or is computed after a complete match has been found\n+ * utilizing helper structures such as {@link PartialMatch} and {@link MatchInfo}, which are themselves\n+ * built during matching. Logic in\n+ * {@link DataAccessRule} computes and applies compensation\n+ * as needed when a complete index match has been found.\n+ *\n+ * A query sub graph can have multiple matches that could be utilized. In the example above, another index on {@code b}\n+ * would also match but use {@code b} for the index scan and a predicate {@code WHERE a = 3}. Both match the query,\n+ * and in fact both indexes can be utilized together by intersecting the index scans. For those cases, it becomes\n+ * important to be able to intersect compensations as well such that only the minimally required combined\n+ * compensation is required. In this example, no compensation is required as the individual indexes being intersected\n+ * complement each other nicely.\n+ */\n+public interface Compensation extends Function<ExpressionRef<RelationalExpression>, RelationalExpression> {\n+    /**\n+     * Named object to indicate that this compensation is in fact no compensation, that is no additional operators\n+     * need to be injected to compensate for a match.\n+     */\n+    Compensation NO_COMPENSATION = new Compensation() {\n+        @Override\n+        public boolean isNeeded() {\n+            return false;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public Compensation intersect(@Nonnull final Compensation otherCompensation) {\n+            return this;\n+        }\n+\n+        @Override\n+        public RelationalExpression apply(final ExpressionRef<RelationalExpression> reference) {\n+            throw new RecordCoreException(\"this method should not be called\");\n+        }\n+    };\n+\n+    /**\n+     * Identity element for the intersection monoid defined by {@link #intersect(Compensation)}.\n+     * Example for the usage pattern for that monoid:\n+     *\n+     * Let {@code compensations} be a {@link Collection} of {@link Compensation}.\n+     * You can use {@link java.util.stream.Stream#reduce} to create an intersection of\n+     * all compensations in that collection.\n+     * <pre>\n+     * {code\n+     * final Compensations intersectedCompensations =\n+     *   compensations\n+     *     .stream()\n+     *     .reduce(Compensation.impossibleCompensation(), Compensation::intersect);\n+     * }\n+     * </pre>\n+     * Note that if {@code compensations} is empty, the result of the intersection is the impossible compensation.\n+     */\n+    Compensation IMPOSSIBLE_COMPENSATION = new Compensation() {\n+        @Override\n+        public boolean isNeeded() {\n+            return true;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public Compensation intersect(@Nonnull final Compensation otherCompensation) {\n+            return otherCompensation;\n+        }\n+\n+        @Override\n+        public RelationalExpression apply(final ExpressionRef<RelationalExpression> reference) {\n+            throw new RecordCoreException(\"this method should not be called\");\n+        }\n+    };\n+\n+    /**\n+     * Returns if this compensation object needs to be applied in order to correct the result of a match.\n+     * @return {@code true} if this compensation must be applied, {@code false} if this compensation is not needed.\n+     *         Note, by contract it is illegal to call {@link #apply} on this compensation if this method returns\n+     *         {@code false}.\n+     */\n+    default boolean isNeeded() {\n+        return true;\n+    }\n+\n+    /**\n+     * Intersect this compensation with another one passed in.\n+     * @param otherCompensation other compensation to intersect this compensation with\n+     * @return the new compensation representing the intersection of both compensations\n+     */\n+    @Nonnull\n+    default Compensation intersect(@Nonnull Compensation otherCompensation) {\n+        if (!isNeeded() || !otherCompensation.isNeeded()) {\n+            return noCompensation();\n+        }\n+\n+        return new Compensation() {\n+            @Nonnull\n+            @Override\n+            public RelationalExpression apply(@Nonnull final ExpressionRef<RelationalExpression> reference) {\n+                return Compensation.this.apply(\n+                        GroupExpressionRef.of(otherCompensation\n+                                .apply(reference)));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Returns a compensation which represents no compensation at all, i.e. it returns an object where\n+     * {@link #isNeeded()} returns {@code false}. That object cannot be applied.\n+     * @return a compensation object that represents the absence of the need for compensation\n+     */\n+    @Nonnull\n+    static Compensation noCompensation() {\n+        return NO_COMPENSATION;\n+    }\n+\n+    /**\n+     * Returns a compensation which represents the <em>impossible</em> compensation, i.e. it returns an object where\n+     * {@link #isNeeded()} returns {@code true} however, that cannot be applied. This object is only needed to define\n+     * the identity of the intersection monoid on compensations. One can imagine the impossible compensation to stand\n+     * for the fact that compensation is needed (that is the match subsumes the query) but that the compensation itself\n+     * cannot be computed.\n+     * @return a compensation object that represents an impossible for compensation\n+     */\n+    @Nonnull\n+    static Compensation impossibleCompensation() {\n+        return IMPOSSIBLE_COMPENSATION;\n+    }\n+\n+    /**\n+     * Returns a specific compensation object that uses a mapping between predicates from a query to predicates that\n+     * are used for the application of the compensation.\n+     * @param predicateCompensationMap map that maps {@link QueryPredicate}s of the query to {@link QueryPredicate}s\n+     *        used for compensation\n+     * @return a new compensation\n+     */\n+    @Nonnull\n+    static Compensation ofPredicateMap(final Map<QueryPredicate, QueryPredicate> predicateCompensationMap) {\n+        return predicateCompensationMap.isEmpty() ? noCompensation() : new ForMatch(predicateCompensationMap);\n+    }\n+\n+    /**\n+     * Interface for {@link Compensation}s that map original {@link QueryPredicate}s to compensating\n+     * {@link QueryPredicate}s.\n+     */\n+    interface WithPredicateCompensation extends Compensation {\n+        @Nonnull\n+        Map<QueryPredicate, QueryPredicate> getPredicateCompensationMap();\n+\n+        /**\n+         * Method to return a new compensation of at least type {@link WithPredicateCompensation} based on the current\n+         * compensation object. This method should be implemented by implementing classes and/or their sub classes.\n+         * TODO make this method protected in Java 11.\n+         * @param predicateCompensationMap  map that maps {@link QueryPredicate}s of the query to {@link QueryPredicate}s\n+         *        used for compensation\n+         * @return a new compensation\n+         */\n+        @Nonnull\n+        WithPredicateCompensation derivedWithPredicateCompensationMap(@Nonnull IdentityHashMap<QueryPredicate, QueryPredicate> predicateCompensationMap);\n+\n+        /**\n+         * Specific implementation of intersecting two compensations both of type {@link WithPredicateCompensation}.\n+         * This implementation delegates to its super method if {@code otherCompensation} is not of type\n+         * {@link WithPredicateCompensation}. If it is, it creates a new compensation of type\n+         * {@link WithPredicateCompensation} that contains only the mappings that are contained in both this compensation\n+         * and {@code otherCompensation}.\n+         * @param otherCompensation other compensation to intersect this compensation with\n+         * @return a new compensation object representing the logical intersection between {@code this} and\n+         *         {@code otherCompensation}\n+         */\n+        @Nonnull\n+        @Override\n+        default Compensation intersect(@Nonnull Compensation otherCompensation) {\n+            if (!(otherCompensation instanceof WithPredicateCompensation)) {\n+                return Compensation.super.intersect(otherCompensation);\n+            }\n+            final WithPredicateCompensation otherWithPredicateCompensation = (WithPredicateCompensation)otherCompensation;\n+            final Map<QueryPredicate, QueryPredicate> otherCompensationMap = otherWithPredicateCompensation.getPredicateCompensationMap();\n+\n+            final IdentityHashMap<QueryPredicate, QueryPredicate> combinedMap = Maps.newIdentityHashMap();\n+            for (final Map.Entry<QueryPredicate, QueryPredicate> entry : getPredicateCompensationMap().entrySet()) {\n+                // if the other side does not have compensation for this key, we don't need compensation\n+                if (otherCompensationMap.containsKey(entry.getKey())) {\n+                    // we just pick one side\n+                    combinedMap.put(entry.getKey(), entry.getValue());", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzQ5MTA1NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r567491054", "bodyText": "Both compensations have a compensation for this particular predicate which is essentially reapplying the predicate. At this point it doesn't matter which side we take as both create the same compensating filter. If at any point in the future one data access has a better niftier trick to reapply the predicate we need to generate plans with either compensation and let the planner figure out which one wins. I will add a comment for now saying essentially the same thing.", "author": "normen662", "createdAt": "2021-01-31T22:03:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYwMzYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY2NTE4NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565665184", "bodyText": "Is this nullable now, or was this a mistake?", "author": "alecgrieser", "createdAt": "2021-01-27T21:57:26Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/metadata/expressions/FieldKeyExpression.java", "diffHunk": "@@ -207,40 +213,49 @@ public int getColumnSize() {\n \n     @Nonnull\n     @Override\n-    public KeyExpression normalizeForPlanner(@Nonnull Source source, @Nonnull List<String> fieldNamePrefix) {\n+    public ExpandedPredicates expandForPlanner(@Nonnull final CorrelationIdentifier baseAlias,\n+                                               @Nonnull final Supplier<CorrelationIdentifier> parameterAliasSupplier,\n+                                               @Nonnull final List<String> fieldNamePrefix) {\n         final List<String> fieldNames = ImmutableList.<String>builder()\n                 .addAll(fieldNamePrefix)\n                 .add(fieldName)\n                 .build();\n+        final Placeholder predicate;\n         switch (fanType) {\n             case FanOut:\n-                return new ElementKeyExpression(new ValueElement(new RepeatedFieldSource(source, fieldNames)));\n+                final Quantifier childBase = getBase(baseAlias, fieldNamePrefix);\n+                final CorrelationIdentifier parameterAlias = parameterAliasSupplier.get();\n+                predicate = new ObjectValue(childBase.getAlias()).withParameterAlias(parameterAlias);\n+                final ExpandedPredicates.Sealed childExpandedPredicates = ExpandedPredicates.ofPlaceholderPredicate(predicate).seal();\n+                final SelectExpression selectExpression =\n+                        childExpandedPredicates\n+                                .buildSelectWithBase(childBase);\n+                final Quantifier childQuantifier = Quantifier.forEach(GroupExpressionRef.of(selectExpression));\n+                return childExpandedPredicates.derivedWithQuantifier(childQuantifier);\n             case None:\n-                return new ElementKeyExpression(new FieldElement(source, fieldNames));\n-            case Concatenate:\n+                predicate = new FieldValue(baseAlias, fieldNames).withParameterAlias(parameterAliasSupplier.get());\n+                return ExpandedPredicates.ofPlaceholderPredicate(predicate);\n+            case Concatenate: // TODO collect/concatenate function\n             default:\n         }\n         throw new UnsupportedOperationException();\n     }\n \n     @Nonnull\n-    Source getFieldSource(@Nonnull Source rootSource, @Nonnull List<String> fieldNamePrefix) {\n+    Quantifier getBase(@Nonnull CorrelationIdentifier baseAlias, @Nonnull List<String> fieldNamePrefix) {\n         final List<String> fieldNames = ImmutableList.<String>builder()\n                 .addAll(fieldNamePrefix)\n                 .add(fieldName)\n                 .build();\n         switch (fanType) {\n             case FanOut:\n-                return new RepeatedFieldSource(rootSource, fieldNames);\n-            case Concatenate:\n-            case None:\n-                return rootSource;\n+                return Quantifier.forEach(GroupExpressionRef.of(\n+                        new ExplodeExpression(baseAlias, fieldNames)));\n             default:\n                 throw new RecordCoreException(\"unrecognized fan type\");\n         }\n     }\n \n-    @Nonnull", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzA3NzgwNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r567077807", "bodyText": "good catch -- restored", "author": "normen662", "createdAt": "2021-01-29T20:31:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY2NTE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY2NjQ1Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565666452", "bodyText": "Is it okay that this loses the grouping information?", "author": "alecgrieser", "createdAt": "2021-01-27T21:59:30Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/metadata/expressions/GroupingKeyExpression.java", "diffHunk": "@@ -115,8 +117,10 @@ public int getColumnSize() {\n \n     @Nonnull\n     @Override\n-    public KeyExpression normalizeForPlanner(@Nonnull Source source, @Nonnull List<String> fieldNamePrefix) {\n-        return new GroupingKeyExpression(wholeKey.normalizeForPlanner(source, fieldNamePrefix), groupedCount);\n+    public ExpandedPredicates expandForPlanner(@Nonnull final CorrelationIdentifier baseAlias,\n+                                               @Nonnull final Supplier<CorrelationIdentifier> parameterAliasSupplier,\n+                                               @Nonnull final List<String> fieldNamePrefix) {\n+        return wholeKey.expandForPlanner(baseAlias, parameterAliasSupplier, fieldNamePrefix);", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcwMjQzOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571702438", "bodyText": "Changed the implementation -- an UnsupportedOperationException is thrown now.", "author": "normen662", "createdAt": "2021-02-07T21:25:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY2NjQ1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY2NjgxNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565666814", "bodyText": "Would probably be good to have a brief java doc explaining what this is.", "author": "alecgrieser", "createdAt": "2021-01-27T22:00:13Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/metadata/expressions/KeyExpression.java", "diffHunk": "@@ -192,44 +194,28 @@ public static FanType valueOf(RecordMetaDataProto.Field.FanType fanType) throws\n         return Collections.singletonList(this);\n     }\n \n-    /**\n-     * Flatten this key expression into a list of {@link Element}s, much like {@link #normalizeKeyForPositions()}.\n-     * By default, this method throws an exception because most key expressions cannot be flattened to a list of\n-     * elements without prior adjustment. This method is only overriden by key expressions that can be flattened.\n-     * @return a list of elements representing this key expression in unnested form\n-     * @see ElementKeyExpression#flattenForPlanner()\n-     * @see ThenKeyExpression#flattenForPlanner()\n-     */\n     @API(API.Status.EXPERIMENTAL)\n     @Nonnull\n-    default List<Element> flattenForPlanner() {\n-        throw new RecordCoreException(\"illegal non-element expression\");\n+    default ExpandedPredicates expandForPlanner(@Nonnull CorrelationIdentifier baseAlias, @Nonnull final Supplier<CorrelationIdentifier> parameterAliasSupplier) {\n+        return expandForPlanner(baseAlias, parameterAliasSupplier, Collections.emptyList());\n     }\n \n+    @API(API.Status.EXPERIMENTAL)\n+    @Nonnull\n+    ExpandedPredicates expandForPlanner(@Nonnull CorrelationIdentifier baseAlias, @Nonnull final Supplier<CorrelationIdentifier> parameterAliasSupplier, @Nonnull List<String> fieldNamePrefix);", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcxNTA1Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571715057", "bodyText": "Done.", "author": "normen662", "createdAt": "2021-02-07T23:05:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY2NjgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY2NzY4NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565667685", "bodyText": "Extra whitespace got added. (I'd just use the change suggestion feature, except it seems to be confused and it looks like my suggestion is to remove the whole line, which isn't quite right.)", "author": "alecgrieser", "createdAt": "2021-01-27T22:01:53Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/metadata/expressions/RecordTypeKeyExpression.java", "diffHunk": "@@ -111,23 +109,11 @@ public GroupingKeyExpression ungrouped() {\n     public RecordMetaDataProto.KeyExpression toKeyExpression() {\n         return RECORD_TYPE_KEY_PROTO;\n     }\n-\n+    ", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY2OTc0OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565669749", "bodyText": "This could also probably do with a brief javadoc explanation", "author": "alecgrieser", "createdAt": "2021-01-27T22:05:49Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/expressions/QueryComponent.java", "diffHunk": "@@ -144,34 +143,11 @@ default boolean isAsync() {\n      */\n     void validate(@Nonnull Descriptors.Descriptor descriptor);\n \n-    /**\n-     * Convert this query component into an equivalent {@link QueryPredicate} by pushing all information about nested\n-     * and repeated fields to {@link Element}s inside of {@link com.apple.foundationdb.record.query.predicates.ElementPredicate}s.\n-     *\n-     * @param rootSource the source representing the input stream of the query component\n-     * @return an equivalent query predicate\n-     */\n     @API(API.Status.EXPERIMENTAL)\n-    @Nonnull\n-    default QueryPredicate normalizeForPlanner(@Nonnull Source rootSource) {\n-        return normalizeForPlanner(rootSource, Collections.emptyList());\n+    default ExpandedPredicates expandForPlanner(@Nonnull CorrelationIdentifier baseAlias) {\n+        return expandForPlanner(baseAlias, Collections.emptyList());\n     }\n \n-    /**\n-     * Convert this query component into an equivalent {@link QueryPredicate} by pushing all information about nested\n-     * and repeated fields to {@link Element}s inside of {@link com.apple.foundationdb.record.query.predicates.ElementPredicate}s.\n-     *\n-     * <p>\n-     * This normalization process requires tracking some state: the name of a nested field is available\n-     * only at the relevant {@link NestedField}, but that information is necessary to construct the\n-     * {@link com.apple.foundationdb.record.query.predicates.ElementPredicate} at the leaves of the sub-tree rooted at\n-     * that nested field. This extra information is tracked in the given {@code fieldNamePrefix}.\n-     * </p>\n-     * @param source the source representing the input stream of the key expression\n-     * @param fieldNamePrefix the (non-repeated) field names on the path from the most recent source to this part of the query component\n-     * @return an equivalent query predicate\n-     */\n     @API(API.Status.EXPERIMENTAL)\n-    @Nonnull\n-    QueryPredicate normalizeForPlanner(@Nonnull Source source, @Nonnull List<String> fieldNamePrefix);\n+    ExpandedPredicates expandForPlanner(@Nonnull CorrelationIdentifier baseAlias, @Nonnull List<String> fieldNamePrefix);", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcxNzgxMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571717813", "bodyText": "done", "author": "normen662", "createdAt": "2021-02-07T23:26:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY2OTc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY4NjcxMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565686712", "bodyText": "Does this need to be public? It's a bit academic, given that this whole package is temporary, but perhaps something to think about before this is moved out of temp status.", "author": "alecgrieser", "createdAt": "2021-01-27T22:38:35Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/BoundKeyPart.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * BoundKeyPart.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n+import com.apple.foundationdb.record.query.predicates.ValueComparisonRangePredicate;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Optional;\n+\n+/**\n+ * A key expression that can be bound by a comparison.\n+ */\n+public class BoundKeyPart extends KeyPart {", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcxOTU1Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571719553", "bodyText": "It's used by rules which reside in temp.rules. This needs to stay public for those nested packages. You gotta love Java.", "author": "normen662", "createdAt": "2021-02-07T23:39:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY4NjcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY5MDk4MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565690981", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * {@link ComplexIterable}. Iterators created by this class, however, avoid to build complex state objects\n          \n          \n            \n                 * {@link ComplexIterable}. Iterators created by this class, however, avoid building complex state objects", "author": "alecgrieser", "createdAt": "2021-01-27T22:47:16Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ChooseK.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/*\n+ * CrossProduct.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.PeekingIterator;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+\n+/**\n+ * Utility class to provide helpers related to enumeration of cross products.\n+ *\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public class ChooseK {\n+\n+    private ChooseK() {\n+        // prevent instantiation\n+    }\n+\n+    /**\n+     * A complex iterable implementing {@link EnumeratingIterable} that is used for sets of cardinality greater\n+     * than 1 (i.e., the regular case).\n+     * @param <T> type\n+     */\n+    private static class ComplexIterable<T> implements EnumeratingIterable<T> {\n+        @Nonnull\n+        private final List<T> elements;\n+        private final int numberOfElementsToChoose;\n+\n+        private class ComplexIterator extends AbstractIterator<List<T>> implements EnumeratingIterator<T> {\n+            // state\n+            private int bound;\n+            private final List<PeekingIterator<Integer>> state;\n+            int currentOffset;\n+\n+            private ComplexIterator() {\n+                this.bound = 0;\n+                this.state = Lists.newArrayListWithCapacity(numberOfElementsToChoose);\n+                for (int i = 0; i < numberOfElementsToChoose; i ++) {\n+                    this.state.add(null);\n+                }\n+                this.currentOffset = 0;\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                if (elements.isEmpty()) {\n+                    return endOfData();\n+                }\n+\n+                //\n+                // If nothing is bound yet, we are at the beginning and should start at level 0, otherwise\n+                // we conceptually start at the level of the finest granularity bound.\n+                //\n+                int currentLevel = bound == 0 ? 0 : bound - 1;\n+\n+                //\n+                // For permutation of elements we return, we need to bind n elements (n == sources.size()).\n+                // We maintain an iterator through the iterators over sources (that is stable) for each level up to\n+                // currentLevel. That's the state!\n+                // The iterator for levels greater than currentLevel may be null. The iterators\n+                // for levels below current level must be on a valid element. The iterator for the currentLevel\n+                // maybe null or a valid element.\n+                //\n+\n+                //\n+                // We also use an integer value \"bound\" that keep track of the level that is currently bound by iterators.\n+                //\n+                do {\n+                    final int lastOffset;\n+\n+                    //\n+                    // Set the currentIterator. That is the iterator at level currentLevel. If it is null,\n+                    // we create a new iterator over the set.\n+                    //\n+                    final PeekingIterator<Integer> currentIterator;\n+                    if (state.get(currentLevel) == null) {\n+                        currentIterator = Iterators.peekingIterator(IntStream.range(1, elements.size() - currentOffset + 1).iterator());\n+                        state.set(currentLevel, currentIterator);\n+                        lastOffset = 0;\n+                    } else {\n+                        currentIterator = state.get(currentLevel);\n+                        unbind(currentLevel);\n+                        lastOffset = currentIterator.peek();\n+                        currentIterator.next();\n+                    }\n+\n+                    //\n+                    // Search currentLevel for a next item. Doing so may exhaust currentIterator in which case we\n+                    // couldn't find another element on the current level.\n+                    // In that case we need to abandon the current level and search on the level above (making that\n+                    // level the current level). If we reach level -1 (i.e., we reach the end of the iterator at level 0\n+                    // we are done.\n+                    // If we do find an element not violating any constraints on the current level we conceptually\n+                    // bind the element we found and continue on downward.\n+                    //\n+                    final boolean isDown = currentIterator.hasNext();\n+                    if (isDown) {\n+                        bound += 1;\n+                        currentOffset += 1;\n+                        currentLevel += 1;\n+                    } else {\n+                        // back tracking -- need to clear out the current iterator\n+                        state.set(currentLevel, null);\n+                        currentOffset -= lastOffset;\n+                        currentLevel -= 1;\n+                    }\n+\n+                    if (currentLevel == -1) {\n+                        return endOfData();\n+                    }\n+                } while (bound < numberOfElementsToChoose); // as long as we still have to find a binding\n+\n+                final ImmutableList.Builder<T> resultBuilder = ImmutableList.builder();\n+\n+                int resultOffset = 0;\n+                for (final PeekingIterator<Integer> iterator : state) {\n+                    resultOffset += iterator.peek();\n+                    // System.out.print(\"[\" + iterator.peek() + \" \" + resultOffset + \"]\");\n+                    resultBuilder.add(elements.get(resultOffset - 1));\n+                }\n+                // System.out.println();\n+\n+                return resultBuilder.build();\n+            }\n+\n+            private void unbind(final int level) {\n+                // reset all the following ones\n+                for (int i = level; i < numberOfElementsToChoose; i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    final PeekingIterator<Integer> currentIterator = state.get(i);\n+                    if (currentIterator != null) {\n+                        bound -= 1;\n+                        if (i > level) {\n+                            state.set(level, null);\n+                        }\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            /**\n+             * Method that skips advances to the next element on the given zero-indexed level.\n+             * @param level level to advance\n+             */\n+            @Override\n+            public void skip(final int level) {\n+                if (level >= numberOfElementsToChoose) {\n+                    throw new IndexOutOfBoundsException();\n+                }\n+\n+                if (state.get(level) == null) {\n+                    throw new UnsupportedOperationException(\"cannot skip/unbind as level is not bound at all\");\n+                }\n+\n+                // reset all the following ones\n+                for (int i = level + 1; i < numberOfElementsToChoose; i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    final PeekingIterator<Integer> currentIterator = state.get(i);\n+                    if (currentIterator != null) {\n+                        bound -= 1;\n+                        currentOffset -= currentIterator.peek();\n+                        state.set(i, null);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private ComplexIterable(@Nonnull final Iterable<T> elements, final int numberOfElementsToChoose) {\n+            this.elements = ImmutableList.copyOf(elements);\n+            this.numberOfElementsToChoose = numberOfElementsToChoose;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public EnumeratingIterator<T> iterator() {\n+            return new ComplexIterator();\n+        }\n+    }\n+\n+    /**\n+     * An implementation of {@link EnumeratingIterable} that is optimized to work for single item\n+     * input sets. The case where the input set is exactly one item is trivial and also properly handled by\n+     * {@link ComplexIterable}. Iterators created by this class, however, avoid to build complex state objects", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY5NzIwMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565697201", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * If the underlying DAG is mutated gainst assumptions, the semantics of this class is defined in a way that calls to\n          \n          \n            \n             * If the underlying DAG is mutated against assumptions, the semantics of this class is defined in a way that calls to\n          \n      \n    \n    \n  \n\nPresumably a typo?", "author": "alecgrieser", "createdAt": "2021-01-27T23:00:16Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRefTraversal.java", "diffHunk": "@@ -36,43 +37,115 @@\n /**\n  * Utility class to provide a graph view of a expression reference DAG given by a root expression reference\n  * (to a {@link RelationalExpression} that allows to perform traversal operations that are normally not possible\n- * on instances of {@link ExpressionRef} such as {@link #getLeafRefs()} and {@link #getParentRefs}.\n+ * on instances of {@link ExpressionRef} such as {@link #getLeafReferences()} and {@link #getParentRefs}.\n  *\n  * The implementation of this class assumes that the original DAG is not mutated after the traversal is created.\n- * If the underlying DAG is mutated against assumptions, the semantics of this class is defined in a way that calls to\n+ * If the underlying DAG is mutated gainst assumptions, the semantics of this class is defined in a way that calls to", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY5OTE0NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565699145", "bodyText": "It's a little weird to me that this implements BiMap<Wrapper<K>, Wrapper<V>> instead of BiMap<K, V> (and then just uses the wrapped items underneath). I didn't look too closely at all the places this is used, but it is just seemed like something that is maybe not what I would have guessed.", "author": "alecgrieser", "createdAt": "2021-01-27T23:04:46Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/IdentityBiMap.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * IdentityBiMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.annotation.SpotBugsSuppressWarnings;\n+import com.google.common.base.Equivalence;\n+import com.google.common.base.Equivalence.Wrapper;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.errorprone.annotations.CanIgnoreReturnValue;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collector;\n+\n+/**\n+ * BiMap based on identities of types {@code K} and {@code V}.\n+ * @param <K> key type\n+ * @param <V> value type\n+ */\n+public class IdentityBiMap<K, V> implements BiMap<Wrapper<K>, Wrapper<V>> {", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzA4MzM1MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r567083351", "bodyText": "This class is a shim as there is no real Guava or commons class that gives you this. At least Guava has Equivalence which does this job as a last resort type of thing. On the downside the generics make you want to not deal with the fallout. This class encapsulated some of that.", "author": "normen662", "createdAt": "2021-01-29T20:43:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY5OTE0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY5OTYwMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565699600", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Name of the match candidate. If this candidate represents and index, it will be the name of the index.\n          \n          \n            \n                 * Name of the match candidate. If this candidate represents an index, it will be the name of the index.", "author": "alecgrieser", "createdAt": "2021-01-27T23:05:49Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/IndexScanMatchCandidate.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * MatchCandidate.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.IndexScanType;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.IndexScanExpression;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+\n+/**\n+ * Case class to represent a match candidate that is backed by an index.\n+ */\n+public class IndexScanMatchCandidate implements MatchCandidate {\n+    /**\n+     * Name of the match candidate. If this candidate represents and index, it will be the name of the index.", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcwMDU3Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565700576", "bodyText": "Do we need this rule suppression here? That seems to be about not having too many break or continue statements in nested loops, but I don't think we have any nested loops in this function.", "author": "alecgrieser", "createdAt": "2021-01-27T23:07:54Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/IndexScanMatchCandidate.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * MatchCandidate.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.IndexScanType;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.IndexScanExpression;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+\n+/**\n+ * Case class to represent a match candidate that is backed by an index.\n+ */\n+public class IndexScanMatchCandidate implements MatchCandidate {\n+    /**\n+     * Name of the match candidate. If this candidate represents and index, it will be the name of the index.\n+     */\n+    @Nonnull\n+    private final String name;\n+\n+    /**\n+     * Holds the parameter names for all necessary parameters that need to be bound during matching.\n+     */\n+    @Nonnull\n+    private final List<CorrelationIdentifier> parameters;\n+\n+    /**\n+     * Traversal object.\n+     */\n+    @Nonnull\n+    private final ExpressionRefTraversal traversal;\n+\n+    @Nonnull\n+    private final KeyExpression alternativeKeyExpression;\n+\n+    public IndexScanMatchCandidate(@Nonnull String name,\n+                                   @Nonnull final ExpressionRefTraversal traversal,\n+                                   @Nonnull final List<CorrelationIdentifier> parameters,\n+                                   @Nonnull final KeyExpression alternativeKeyExpression) {\n+        this.name = name;\n+        this.traversal = traversal;\n+        this.parameters = ImmutableList.copyOf(parameters);\n+        this.alternativeKeyExpression = alternativeKeyExpression;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public ExpressionRefTraversal getTraversal() {\n+        return traversal;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public List<CorrelationIdentifier> getParameters() {\n+        return parameters;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public KeyExpression getAlternativeKeyExpression() {\n+        return alternativeKeyExpression;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @SuppressWarnings(\"java:S135\")", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzA4NDUwNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r567084507", "bodyText": "you are correct -- removed.", "author": "normen662", "createdAt": "2021-01-29T20:46:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcwMDU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcwMjU1MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565702551", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Match candidates also allow for creation of scans over the materialized data, e.g. the index for an\n          \n          \n            \n             * {@link IndexScanMatchCandidate} or the primary range for a {@link PrimaryScanMatchCandidate} given appropriate\n          \n          \n            \n             * {@link ComparisonRange}s which usually are the direct result of graph matching.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * Match candidates also allow for creation of scans over the materialized data, e.g. the index for an\n          \n          \n            \n             * {@link IndexScanMatchCandidate} or the primary range for a {@link PrimaryScanMatchCandidate} given appropriate\n          \n          \n            \n             * {@link ComparisonRange}s which usually are the direct result of graph matching.\n          \n          \n            \n             * </p>", "author": "alecgrieser", "createdAt": "2021-01-27T23:12:24Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/MatchCandidate.java", "diffHunk": "@@ -20,38 +20,167 @@\n \n package com.apple.foundationdb.record.query.plan.temp;\n \n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.collect.Sets;\n+\n import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n \n /**\n- * Case class to represent a match candidate. A match candidate on code level is just a name and a data flow graph\n+ * Interface to represent a match candidate. A match candidate on code level is just a name and a data flow graph\n  * that can be matched against a query graph. The match candidate does not keep the root to the graph to be matched but\n  * rather an instance of {@link ExpressionRefTraversal} to allow for navigation of references within the candidate.\n+ *\n+ * Match candidates also allow for creation of scans over the materialized data, e.g. the index for an\n+ * {@link IndexScanMatchCandidate} or the primary range for a {@link PrimaryScanMatchCandidate} given appropriate\n+ * {@link ComparisonRange}s which usually are the direct result of graph matching.", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcxODEyOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565718128", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * is not sensitive to whether such a binding could actually be uses in an index scan. In fact, in a different maybe\n          \n          \n            \n                 * is not sensitive to whether such a binding could actually be used in an index scan. In fact, in a different maybe", "author": "alecgrieser", "createdAt": "2021-01-27T23:42:23Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/MatchCandidate.java", "diffHunk": "@@ -20,38 +20,167 @@\n \n package com.apple.foundationdb.record.query.plan.temp;\n \n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.collect.Sets;\n+\n import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n \n /**\n- * Case class to represent a match candidate. A match candidate on code level is just a name and a data flow graph\n+ * Interface to represent a match candidate. A match candidate on code level is just a name and a data flow graph\n  * that can be matched against a query graph. The match candidate does not keep the root to the graph to be matched but\n  * rather an instance of {@link ExpressionRefTraversal} to allow for navigation of references within the candidate.\n+ *\n+ * Match candidates also allow for creation of scans over the materialized data, e.g. the index for an\n+ * {@link IndexScanMatchCandidate} or the primary range for a {@link PrimaryScanMatchCandidate} given appropriate\n+ * {@link ComparisonRange}s which usually are the direct result of graph matching.\n  */\n-public class MatchCandidate {\n+public interface MatchCandidate {\n     /**\n-     * Name of the match candidate. If this candidate represents and index, it will be the name of the index.\n+     * Returns the name of the match candidate. If this candidate represents and index, it will be the name of the index.\n+     * @return the name of this match candidate\n      */\n     @Nonnull\n-    private final String name;\n+    String getName();\n \n     /**\n-     * Traversal object.\n+     * Returns the traversal object for this candidate. The traversal object can either be computed up-front when\n+     * the candidate is created or lazily when this method is invoked. It is, however, necessary that the traversal\n+     * once computed is stable, meaning the object returned by implementors of this method must always return the\n+     * same object.\n+     * @return the traversal associated for this match candidate\n      */\n     @Nonnull\n-    private final ExpressionRefTraversal traversal;\n+    ExpressionRefTraversal getTraversal();\n \n-    public MatchCandidate(@Nonnull String name, @Nonnull final ExpressionRefTraversal traversal) {\n-        this.name = name;\n-        this.traversal = traversal;\n-    }\n+    /**\n+     * Returns the parameter names for all necessary parameters that need to be bound during matching.\n+     * @return a list of {@link CorrelationIdentifier}s for all the used parameters in this match candidate\n+     */\n+    @Nonnull\n+    List<CorrelationIdentifier> getParameters();\n \n+    /**\n+     * This method returns a key expression that can be used to actually compute the the keys of this candidate for a\n+     * given record.\n+     * The current expression hierarchy cannot be evaluated at runtime (in general). This key expression helps\n+     * representing compensation or part of compensation if needed.\n+     * @return a key expression that can be evaluated based on a base record\n+     */\n     @Nonnull\n-    public String getName() {\n-        return name;\n+    KeyExpression getAlternativeKeyExpression();\n+\n+    /**\n+     * Computes a map from {@link CorrelationIdentifier} to {@link ComparisonRange} that is physically compatible with\n+     * a scan over the materialized version of the match candidate, so e.g. for an {@link IndexScanMatchCandidate} that\n+     * would be the scan over the index.\n+     * As matching progresses it finds mappings from parameters to corresponding comparison ranges. Matching, however,\n+     * is not sensitive to whether such a binding could actually be uses in an index scan. In fact, in a different maybe", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcyMjAxMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565722011", "bodyText": "I'm a little confused from this description, but what's an example of an index scan that couldn't actually be performed but that this method will happily compute? Something with an inequality scan on two fields in the index (like a > 5 AND b > 7 on an index on (a, b))?", "author": "alecgrieser", "createdAt": "2021-01-27T23:52:21Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/MatchCandidate.java", "diffHunk": "@@ -20,38 +20,167 @@\n \n package com.apple.foundationdb.record.query.plan.temp;\n \n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.collect.Sets;\n+\n import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n \n /**\n- * Case class to represent a match candidate. A match candidate on code level is just a name and a data flow graph\n+ * Interface to represent a match candidate. A match candidate on code level is just a name and a data flow graph\n  * that can be matched against a query graph. The match candidate does not keep the root to the graph to be matched but\n  * rather an instance of {@link ExpressionRefTraversal} to allow for navigation of references within the candidate.\n+ *\n+ * Match candidates also allow for creation of scans over the materialized data, e.g. the index for an\n+ * {@link IndexScanMatchCandidate} or the primary range for a {@link PrimaryScanMatchCandidate} given appropriate\n+ * {@link ComparisonRange}s which usually are the direct result of graph matching.\n  */\n-public class MatchCandidate {\n+public interface MatchCandidate {\n     /**\n-     * Name of the match candidate. If this candidate represents and index, it will be the name of the index.\n+     * Returns the name of the match candidate. If this candidate represents and index, it will be the name of the index.\n+     * @return the name of this match candidate\n      */\n     @Nonnull\n-    private final String name;\n+    String getName();\n \n     /**\n-     * Traversal object.\n+     * Returns the traversal object for this candidate. The traversal object can either be computed up-front when\n+     * the candidate is created or lazily when this method is invoked. It is, however, necessary that the traversal\n+     * once computed is stable, meaning the object returned by implementors of this method must always return the\n+     * same object.\n+     * @return the traversal associated for this match candidate\n      */\n     @Nonnull\n-    private final ExpressionRefTraversal traversal;\n+    ExpressionRefTraversal getTraversal();\n \n-    public MatchCandidate(@Nonnull String name, @Nonnull final ExpressionRefTraversal traversal) {\n-        this.name = name;\n-        this.traversal = traversal;\n-    }\n+    /**\n+     * Returns the parameter names for all necessary parameters that need to be bound during matching.\n+     * @return a list of {@link CorrelationIdentifier}s for all the used parameters in this match candidate\n+     */\n+    @Nonnull\n+    List<CorrelationIdentifier> getParameters();\n \n+    /**\n+     * This method returns a key expression that can be used to actually compute the the keys of this candidate for a\n+     * given record.\n+     * The current expression hierarchy cannot be evaluated at runtime (in general). This key expression helps\n+     * representing compensation or part of compensation if needed.\n+     * @return a key expression that can be evaluated based on a base record\n+     */\n     @Nonnull\n-    public String getName() {\n-        return name;\n+    KeyExpression getAlternativeKeyExpression();\n+\n+    /**\n+     * Computes a map from {@link CorrelationIdentifier} to {@link ComparisonRange} that is physically compatible with\n+     * a scan over the materialized version of the match candidate, so e.g. for an {@link IndexScanMatchCandidate} that\n+     * would be the scan over the index.\n+     * As matching progresses it finds mappings from parameters to corresponding comparison ranges. Matching, however,\n+     * is not sensitive to whether such a binding could actually be uses in an index scan. In fact, in a different maybe\n+     * future record layer with improved physical operators this method should be revised to account for those improvements.\n+     * For now, we only consider a prefix of said mappings that consist of n equality-bound mappings and stops either\n+     * at an inequality bound parameter or before a unbound parameter.", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzA4NTkzMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r567085932", "bodyText": "Yes, exactly. An index skip scan (see Oracle) can do this by scanning the index for values of a and then probing the index for each such a to get the correct bs. This is also sometimes incorrectly called index-nested-loop join.", "author": "normen662", "createdAt": "2021-01-29T20:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcyMjAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcyNzM3Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565727377", "bodyText": "Do you have a feeling for how well the planner will stand up to cases where we relax this restriction? That is, if commonPrimaryKey == null, will it still be able to figure out that it can scan the primary records subspace and filter things out (or even apply predicates by limiting the scan over certain ranges)? For example, one common pattern we encourage is prefixing each record's primary key with the record type field, which means that commonPrimaryKey is null, but it's still possible to reason about the records by key (e.g., to get all records of a given type, you can plan a scan over a range of primary records).\nTo the extent that the current version of the planner doesn't do this, how difficult do you think it will be to modify the planner to handle that case?", "author": "alecgrieser", "createdAt": "2021-01-28T00:06:26Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -96,47 +105,140 @@\n public interface RelationalExpression extends Bindable, Correlated<RelationalExpression> {\n     @Nonnull\n     static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull PlanContext context) {\n-\n         Quantifier.ForEach quantifier = Quantifier.forEach(GroupExpressionRef.of(new FullUnorderedScanExpression(context.getMetaData().getRecordTypes().keySet())));\n-        final ViewExpression.Builder builder = ViewExpression.builder();\n-        for (String recordType : context.getRecordTypes()) {\n-            builder.addRecordType(recordType);\n-        }\n-        final Source baseSource = builder.buildBaseSource();\n-        if (query.getSort() != null) {\n-            List<Element> normalizedSort = query.getSort()\n-                    .normalizeForPlanner(baseSource, Collections.emptyList())\n-                    .flattenForPlanner();\n-            quantifier = Quantifier.forEach(GroupExpressionRef.of(new LogicalSortExpression(Collections.emptyList(), normalizedSort, query.isSortReverse(), quantifier)));\n+\n+        if (!context.getRecordTypes().isEmpty()) {\n+            quantifier = Quantifier.forEach(GroupExpressionRef.of(new LogicalTypeFilterExpression(new HashSet<>(context.getRecordTypes()), quantifier)));\n         }\n \n+        final SelectExpression selectExpression;\n         if (query.getFilter() != null) {\n-            final QueryPredicate normalized = query.getFilter().normalizeForPlanner(baseSource);\n-            quantifier = Quantifier.forEach(GroupExpressionRef.of(new LogicalFilterExpression(baseSource, normalized, quantifier)));\n+            selectExpression =\n+                    query.getFilter()\n+                            .expandForPlanner(quantifier.getAlias())\n+                            .buildSelectWithBase(quantifier);\n+        } else {\n+            selectExpression =\n+                    ExpandedPredicates.empty()\n+                            .buildSelectWithBase(quantifier);\n         }\n+        quantifier = Quantifier.forEach(GroupExpressionRef.of(selectExpression));\n \n-        if (!query.getRecordTypes().isEmpty()) {\n-            quantifier = Quantifier.forEach(GroupExpressionRef.of(new LogicalTypeFilterExpression(new HashSet<>(query.getRecordTypes()), quantifier)));\n-        }\n         if (query.removesDuplicates()) {\n             quantifier = Quantifier.forEach(GroupExpressionRef.of(new LogicalDistinctExpression(quantifier)));\n         }\n-        return Iterables.getOnlyElement(quantifier.getRangesOver().getMembers());\n+\n+        if (query.getSort() != null) {\n+            quantifier = Quantifier.forEach(GroupExpressionRef.of(new LogicalSortExpression(query.getSort(), query.isSortReverse(), quantifier)));\n+        }\n+\n+        return quantifier.getRangesOver().get();\n+    }\n+\n+    @Nonnull\n+    static Optional<MatchCandidate> fromIndexDefinition(@Nonnull final RecordMetaData metaData,\n+                                                        @Nonnull final Index index,\n+                                                        final boolean isReverse) {\n+        final Collection<RecordType> recordTypesForIndex = metaData.recordTypesForIndex(index);\n+        final KeyExpression commonPrimaryKeyForIndex = RecordMetaData.commonPrimaryKey(recordTypesForIndex);\n+\n+        final ImmutableSet<String> recordTypeNamesForIndex =\n+                recordTypesForIndex\n+                        .stream()\n+                        .map(RecordType::getName)\n+                        .collect(ImmutableSet.toImmutableSet());\n+\n+        final Set<String> availableRecordTypes = metaData.getRecordTypes().keySet();\n+\n+        final String name = index.getName();\n+        final String type = index.getType();\n+\n+        if (type.equals(IndexTypes.VALUE)) {\n+            final KeyExpression fullIndexKeyExpression = index.fullKey(commonPrimaryKeyForIndex);\n+            final Quantifier baseQuantifier = createBaseQuantifier(availableRecordTypes, recordTypeNamesForIndex);\n+            Debugger.updateIndex(Placeholder.class, old -> 0);\n+            final ExpandedPredicates.Sealed expandedPredicates =\n+                    fullIndexKeyExpression.expandForPlanner(baseQuantifier.getAlias(),\n+                            () -> {\n+                                final CorrelationIdentifier parameterAlias =\n+                                        Debugger.getIndexOptional(Placeholder.class)\n+                                                .map(i -> CorrelationIdentifier.of(\"p\" + i))\n+                                                .orElse(CorrelationIdentifier.randomID());\n+                                Debugger.updateIndex(Placeholder.class, i -> i + 1);\n+                                return parameterAlias;\n+                            }).seal();\n+\n+            final List<CorrelationIdentifier> parameters =\n+                    expandedPredicates.getPlaceholders()\n+                            .stream()\n+                            .map(Placeholder::getParameterAlias)\n+                            .collect(ImmutableList.toImmutableList());\n+            \n+            final RelationalExpression expression =\n+                    new MatchableSortExpression(parameters, isReverse, expandedPredicates.buildSelectWithBase(baseQuantifier));\n+\n+            final MatchCandidate matchCandidate =\n+                    new IndexScanMatchCandidate(\n+                            name,\n+                            ExpressionRefTraversal.withRoot(GroupExpressionRef.of(expression)),\n+                            parameters,\n+                            fullIndexKeyExpression);\n+            return Optional.of(matchCandidate);\n+        }\n+\n+        return Optional.empty();\n     }\n \n+    @Nonnull\n+    static Optional<MatchCandidate> fromPrimaryDefinition(@Nonnull final RecordMetaData metaData,\n+                                                          @Nonnull final Set<String> recordTypes,\n+                                                          @Nullable KeyExpression commonPrimaryKey,\n+                                                          final boolean isReverse) {\n+        if (commonPrimaryKey != null) {", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMDA1OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565730059", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Tag-exception tha is specifically thrown by implementations of {@link Debugger} to signal the planner to restart\n          \n          \n            \n             * Tag-exception that is specifically thrown by implementations of {@link Debugger} to signal the planner to restart", "author": "alecgrieser", "createdAt": "2021-01-28T00:13:39Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/debug/RestartException.java", "diffHunk": "@@ -21,7 +21,7 @@\n package com.apple.foundationdb.record.query.plan.temp.debug;\n \n /**\n- * Tag-exception that is specifically thrown by implementations of {@link Debugger} to signal the planner to restart\n+ * Tag-exception tha is specifically thrown by implementations of {@link Debugger} to signal the planner to restart", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMTUzNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565731535", "bodyText": "Looks like maybe you were going to rename this file, but it looks like it's still LogicalSortExpression.java\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * LogicalSortExpressionOld.java\n          \n          \n            \n             * LogicalSortExpression.java", "author": "alecgrieser", "createdAt": "2021-01-28T00:17:39Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalSortExpression.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*\n- * LogicalSortExpression.java\n+ * LogicalSortExpressionOld.java", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMjE2MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565732161", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * LogicalSortExpressionOld.java\n          \n          \n            \n             * MatchableSortExpression.java", "author": "alecgrieser", "createdAt": "2021-01-28T00:19:16Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/MatchableSortExpression.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * LogicalSortExpressionOld.java", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMjI3Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565732273", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * IndexEntrySourceScanExpression.java\n          \n          \n            \n             * IndexScanExpression.java", "author": "alecgrieser", "createdAt": "2021-01-28T00:19:39Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/IndexScanExpression.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * IndexEntrySourceScanExpression.java", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMjQ3Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565732473", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * IndexEntrySourceScanExpression.java\n          \n          \n            \n             * PrimaryScanExpression.java", "author": "alecgrieser", "createdAt": "2021-01-28T00:20:09Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/PrimaryScanExpression.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * IndexEntrySourceScanExpression.java", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMzA0Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565733046", "bodyText": "Is this the right query plan? Or is this a logical version of a RecordQueryScanPlan?", "author": "alecgrieser", "createdAt": "2021-01-28T00:21:42Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/PrimaryScanExpression.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * IndexEntrySourceScanExpression.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.expressions;\n+\n+import com.apple.foundationdb.record.query.plan.ScanComparisons;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.ComparisonRange;\n+import com.apple.foundationdb.record.query.plan.temp.CorrelationIdentifier;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.explain.Attribute;\n+import com.apple.foundationdb.record.query.plan.temp.explain.NodeInfo;\n+import com.apple.foundationdb.record.query.plan.temp.explain.PlannerGraph;\n+import com.apple.foundationdb.record.query.plan.temp.explain.PlannerGraphRewritable;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * A logical version of {@link com.apple.foundationdb.record.query.plan.plans.RecordQueryIndexPlan}.", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc5NjI0MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565796240", "bodyText": "I believe @alecgrieser is right.", "author": "nschiefer", "createdAt": "2021-01-28T03:28:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMzA0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUyMDU5NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572520595", "bodyText": "Still seems to be true.", "author": "MMcM", "createdAt": "2021-02-09T02:24:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMzA0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzExNTU0NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r573115545", "bodyText": "\u2705", "author": "MMcM", "createdAt": "2021-02-09T18:06:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMzA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczNTE1Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565735152", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * ImplementUnorderedUnionRule.java\n          \n          \n            \n             * ImplementDistinctUnionRule.java", "author": "alecgrieser", "createdAt": "2021-01-28T00:24:40Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/ImplementDistinctUnionRule.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * ImplementUnorderedUnionRule.java", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczNTI0MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565735240", "bodyText": "Looks like these are the old docs from that other file", "author": "alecgrieser", "createdAt": "2021-01-28T00:25:00Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/ImplementDistinctUnionRule.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * ImplementUnorderedUnionRule.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.rules;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryUnionPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryUnorderedUnionPlan;\n+import com.apple.foundationdb.record.query.plan.temp.KeyPart;\n+import com.apple.foundationdb.record.query.plan.temp.PlanContext;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRule;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRuleCall;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.LogicalDistinctExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.LogicalUnorderedUnionExpression;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.MultiChildrenMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.QuantifierMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ReferenceMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.TypeMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.properties.OrderingProperty;\n+import com.apple.foundationdb.record.query.plan.temp.properties.OrderingProperty.OrderingInfo;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * A rule that implements an unordered union of its (already implemented) children. This will extract the\n+ * {@link RecordQueryPlan} from each child of a {@link LogicalUnorderedUnionExpression} and create a\n+ * {@link RecordQueryUnorderedUnionPlan} with those plans as children.", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjI1OTg4Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572259883", "bodyText": "arg", "author": "normen662", "createdAt": "2021-02-08T18:08:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczNTI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc0MjE0OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565742148", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * TypeFilterCountProperty.java\n          \n          \n            \n             * ExpressionCountProperty.java", "author": "alecgrieser", "createdAt": "2021-01-28T00:44:51Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/properties/ExpressionCountProperty.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * TypeFilterCountProperty.java", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc0NDQ5OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565744499", "bodyText": "This instanceof ladder is kind of ugly, but I'm not entirely sure what to do about it. I guess this thing comes up from time to time--whether to have each implementation know about the things that are asked of it (which means needing to edit a bunch of files any time we need to know how to ask it about things) or to have one class for each thing to know about (which means any time a new type of thing is added a bunch of files need to go be updated). I guess I'll put this here in case you have any better ideas, but I'm not sure I have a concrete suggestion.", "author": "alecgrieser", "createdAt": "2021-01-28T00:50:25Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/properties/OrderingProperty.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * CreatesDuplicatesProperty.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.properties;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.IndexScanType;\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.query.plan.ScanComparisons;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryIndexPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryIntersectionPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryScanPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryUnionPlan;\n+import com.apple.foundationdb.record.query.plan.temp.ComparisonRange;\n+import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.KeyPart;\n+import com.apple.foundationdb.record.query.plan.temp.PlanContext;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerProperty;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.IndexScanExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.LogicalIntersectionExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.LogicalSortExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.PrimaryScanExpression;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BinaryOperator;\n+\n+/**\n+ * A property that determines whether the expression may produce duplicate entries. If the given expression is a\n+ * {@link RelationalExpression}, this will return whether the expression might produce multiple instances\n+ * of the same record. If the given expression is a {@link KeyExpression}, then this will return whether the\n+ * expression might return multiple results for the same record.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public class OrderingProperty implements PlannerProperty<Optional<OrderingProperty.OrderingInfo>> {\n+    @Nonnull\n+    private final PlanContext context;\n+\n+    private OrderingProperty(@Nonnull PlanContext context) {\n+        this.context = context;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public Optional<OrderingInfo> evaluateAtExpression(@Nonnull RelationalExpression expression, @Nonnull List<Optional<OrderingInfo>> childResults) {\n+\n+        final RecordMetaData metaData = context.getMetaData();\n+\n+        if (expression instanceof RecordQueryScanPlan) {", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc5Nzg5OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565797898", "bodyText": "I believe the way around this in general is double-dispatch, which is pretty awkward in Java. So, we are probably stuck with a giant instanceof ladder, or something equivalent somewhere else.", "author": "nschiefer", "createdAt": "2021-01-28T03:35:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc0NDQ5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc0NDc1Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565744757", "bodyText": "Looks like the old javadoc", "author": "alecgrieser", "createdAt": "2021-01-28T00:51:15Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/properties/OrderingProperty.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * CreatesDuplicatesProperty.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.properties;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.IndexScanType;\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.query.plan.ScanComparisons;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryIndexPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryIntersectionPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryScanPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryUnionPlan;\n+import com.apple.foundationdb.record.query.plan.temp.ComparisonRange;\n+import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.KeyPart;\n+import com.apple.foundationdb.record.query.plan.temp.PlanContext;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerProperty;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.IndexScanExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.LogicalIntersectionExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.LogicalSortExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.PrimaryScanExpression;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BinaryOperator;\n+\n+/**\n+ * A property that determines whether the expression may produce duplicate entries. If the given expression is a\n+ * {@link RelationalExpression}, this will return whether the expression might produce multiple instances\n+ * of the same record. If the given expression is a {@link KeyExpression}, then this will return whether the\n+ * expression might return multiple results for the same record.", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc0NDg2MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565744861", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * CreatesDuplicatesProperty.java\n          \n          \n            \n             * OrderingProperty.java", "author": "alecgrieser", "createdAt": "2021-01-28T00:51:36Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/properties/OrderingProperty.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * CreatesDuplicatesProperty.java", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc0NTU5Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565745593", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * DataAccessRule.java\n          \n          \n            \n             * AdjustMatchRule.java", "author": "alecgrieser", "createdAt": "2021-01-28T00:54:00Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/AdjustMatchRule.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * DataAccessRule.java", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc0NjExOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565746118", "bodyText": "I think this is the javadoc for DataAccessRule", "author": "alecgrieser", "createdAt": "2021-01-28T00:55:27Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/AdjustMatchRule.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * DataAccessRule.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.rules;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.query.plan.temp.CascadesPlanner;\n+import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.IndexScanMatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.MatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.MatchInfo;\n+import com.apple.foundationdb.record.query.plan.temp.PartialMatch;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRule;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRuleCall;\n+import com.apple.foundationdb.record.query.plan.temp.PrimaryScanMatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.IndexScanExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.PrimaryScanExpression;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PartialMatchMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.SetMultimap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * A rule that utilizes index matching information compiled by {@link CascadesPlanner} to create a logical expression\n+ * for data access. While this rule delegates specifics to the {@link MatchCandidate}s, the following are possible\n+ * outcomes of the application of this transformation rule. Based on the match info, we may create for a single match:\n+ *\n+ * <ul>\n+ *     <li>a {@link PrimaryScanExpression} for a single {@link PrimaryScanMatchCandidate},</li>\n+ *     <li>an {@link IndexScanExpression} for a single {@link IndexScanMatchCandidate}</li>\n+ * </ul>\n+ *\n+ * The logic that this rules delegates to to actually create the expressions can be found in\n+ * {@link MatchCandidate#toScanExpression(MatchInfo)}.", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjI1Nzg5Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572257896", "bodyText": "Sorry -- fixed.", "author": "normen662", "createdAt": "2021-02-08T18:05:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc0NjExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc0NjY0OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565746648", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * ImplementUnorderedUnionRule.java\n          \n          \n            \n             * ImplementIntersectionRule.java", "author": "alecgrieser", "createdAt": "2021-01-28T00:56:52Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/ImplementIntersectionRule.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * ImplementUnorderedUnionRule.java", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc0NzA5OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565747099", "bodyText": "Looks like the javadoc for the unordered union implementation rule", "author": "alecgrieser", "createdAt": "2021-01-28T00:57:55Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/ImplementIntersectionRule.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * ImplementUnorderedUnionRule.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.rules;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryIntersectionPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryUnorderedUnionPlan;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRule;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRuleCall;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.LogicalIntersectionExpression;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.MultiChildrenMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.AnyChildrenMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.QuantifierMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.TypeMatcher;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+\n+/**\n+ * A rule that implements an unordered union of its (already implemented) children. This will extract the\n+ * {@link RecordQueryPlan} from each child of a {@link LogicalIntersectionExpression} and create a\n+ * {@link RecordQueryUnorderedUnionPlan} with those plans as children.", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc0Nzg0Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565747847", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * LogicalToPhysicalIndexScanRule.java\n          \n          \n            \n             * LogicalToPhysicalScanRule.java", "author": "alecgrieser", "createdAt": "2021-01-28T00:59:49Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/LogicalToPhysicalScanRule.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*\n- * LogicalToPhysicalScanRule.java\n+ * LogicalToPhysicalIndexScanRule.java", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc0ODAxNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565748016", "bodyText": "Javadoc for the wrong class.", "author": "alecgrieser", "createdAt": "2021-01-28T01:00:13Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/LogicalToPhysicalScanRule.java", "diffHunk": "@@ -23,45 +23,33 @@\n import com.apple.foundationdb.annotation.API;\n import com.apple.foundationdb.record.query.plan.plans.RecordQueryIndexPlan;\n import com.apple.foundationdb.record.query.plan.plans.RecordQueryScanPlan;\n-import com.apple.foundationdb.record.query.plan.temp.IndexEntrySource;\n import com.apple.foundationdb.record.query.plan.temp.PlannerRule;\n import com.apple.foundationdb.record.query.plan.temp.PlannerRuleCall;\n-import com.apple.foundationdb.record.query.plan.temp.expressions.IndexEntrySourceScanExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.PrimaryScanExpression;\n import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n import com.apple.foundationdb.record.query.plan.temp.matchers.TypeMatcher;\n \n import javax.annotation.Nonnull;\n-import java.util.Objects;\n \n /**\n  * A rule that converts a logical index scan expression to a {@link RecordQueryIndexPlan}. This rule simply converts\n- * the logical index scan's {@link com.apple.foundationdb.record.query.plan.temp.view.ViewExpressionComparisons} to a\n+ * the logical index scan's to a\n  * {@link com.apple.foundationdb.record.query.plan.ScanComparisons} to be used during query execution.", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc0OTM5NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565749395", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *\n          \n          \n            \n             *\n          \n          \n            \n             * <p>", "author": "alecgrieser", "createdAt": "2021-01-28T01:04:26Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/MatchIntermediateRule.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * FlattenNestedAndPredicateRule.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.rules;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+import com.apple.foundationdb.record.query.plan.temp.EnumeratingIterable;\n+import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.IdentityBiMap;\n+import com.apple.foundationdb.record.query.plan.temp.IterableHelpers;\n+import com.apple.foundationdb.record.query.plan.temp.MatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.MatchInfo;\n+import com.apple.foundationdb.record.query.plan.temp.PartialMatch;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRule;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRuleCall;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.SelectExpression;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.QuantifierMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.TypeMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matching.BoundMatch;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import static com.apple.foundationdb.record.query.plan.temp.matchers.MultiChildrenMatcher.allMatching;\n+\n+/**\n+ * Expression-based transformation rule that matches any non-leaf expression (called an intermediate expression)\n+ * to a candidate expression in a {@link MatchCandidate}.\n+ * It yields matches of type {@link PartialMatch}. This rule further seeds the memoization\n+ * structure for partial matches that is kept as part of {@link ExpressionRef}. It prepares further rules such as\n+ * other applications of {@link MatchIntermediateRule} and {@link AdjustMatchRule}.\n+ *", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1MDA2MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565750061", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *\n          \n          \n            \n             * Example 1\n          \n          \n            \n             * </p>\n          \n          \n            \n             *\n          \n          \n            \n             * <h2>\n          \n          \n            \n             * Example 1\n          \n          \n            \n             * </h2>", "author": "alecgrieser", "createdAt": "2021-01-28T01:06:12Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/MatchIntermediateRule.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * FlattenNestedAndPredicateRule.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.rules;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+import com.apple.foundationdb.record.query.plan.temp.EnumeratingIterable;\n+import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.IdentityBiMap;\n+import com.apple.foundationdb.record.query.plan.temp.IterableHelpers;\n+import com.apple.foundationdb.record.query.plan.temp.MatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.MatchInfo;\n+import com.apple.foundationdb.record.query.plan.temp.PartialMatch;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRule;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRuleCall;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.SelectExpression;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.QuantifierMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.TypeMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matching.BoundMatch;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import static com.apple.foundationdb.record.query.plan.temp.matchers.MultiChildrenMatcher.allMatching;\n+\n+/**\n+ * Expression-based transformation rule that matches any non-leaf expression (called an intermediate expression)\n+ * to a candidate expression in a {@link MatchCandidate}.\n+ * It yields matches of type {@link PartialMatch}. This rule further seeds the memoization\n+ * structure for partial matches that is kept as part of {@link ExpressionRef}. It prepares further rules such as\n+ * other applications of {@link MatchIntermediateRule} and {@link AdjustMatchRule}.\n+ *\n+ * As an intermediate expression has children (and the candidate expression also has at least one child) we\n+ * need to match up the quantifiers of the query expression to the quantifiers of the possible candidate expression\n+ * in order to determine if the query expression is in fact subsumed by the candidate. The property of subsumption\n+ * is defined as the ability of replacing the query expression with the candidate expression with the additional\n+ * application of compensation. Equivalence between expressions is stronger than subsumption in a way that if two\n+ * expressions are semantically equal, the compensation is considered to be a no op.\n+ *\n+ * Example 1", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1MDIxNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565750216", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *\n          \n          \n            \n             *\n          \n          \n            \n             * <p>", "author": "alecgrieser", "createdAt": "2021-01-28T01:06:44Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/MatchIntermediateRule.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * FlattenNestedAndPredicateRule.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.rules;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+import com.apple.foundationdb.record.query.plan.temp.EnumeratingIterable;\n+import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.IdentityBiMap;\n+import com.apple.foundationdb.record.query.plan.temp.IterableHelpers;\n+import com.apple.foundationdb.record.query.plan.temp.MatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.MatchInfo;\n+import com.apple.foundationdb.record.query.plan.temp.PartialMatch;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRule;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRuleCall;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.SelectExpression;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.QuantifierMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.TypeMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matching.BoundMatch;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import static com.apple.foundationdb.record.query.plan.temp.matchers.MultiChildrenMatcher.allMatching;\n+\n+/**\n+ * Expression-based transformation rule that matches any non-leaf expression (called an intermediate expression)\n+ * to a candidate expression in a {@link MatchCandidate}.\n+ * It yields matches of type {@link PartialMatch}. This rule further seeds the memoization\n+ * structure for partial matches that is kept as part of {@link ExpressionRef}. It prepares further rules such as\n+ * other applications of {@link MatchIntermediateRule} and {@link AdjustMatchRule}.\n+ *\n+ * As an intermediate expression has children (and the candidate expression also has at least one child) we\n+ * need to match up the quantifiers of the query expression to the quantifiers of the possible candidate expression\n+ * in order to determine if the query expression is in fact subsumed by the candidate. The property of subsumption\n+ * is defined as the ability of replacing the query expression with the candidate expression with the additional\n+ * application of compensation. Equivalence between expressions is stronger than subsumption in a way that if two\n+ * expressions are semantically equal, the compensation is considered to be a no op.\n+ *\n+ * Example 1\n+ *\n+ * <pre>\n+ * {@code\n+ * query expression                    candidate expression\n+ *\n+ *      +-----------+                       +-----------+\n+ *      |   Union   |                       |   Union   |\n+ *      +-----------+                       +-----------+\n+ *      /     |     \\                       /     |     \\\n+ *     /      |      \\                     /      |      \\\n+ * +----+  +----+  +----+              +----+  +----+  +----+\n+ * | c1 |  | c2 |  | c3 |              | ca |  | cb |  | cc |\n+ * +----+  +----+  +----+              +----+  +----+  +----+\n+ * }\n+ * </pre>\n+ *", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1MDMzNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565750335", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * expression are equal. It may be that no such mapping exist in which case subsumption cannot be established and this\n          \n          \n            \n             * expression are equal? It may be that no such mapping exist in which case subsumption cannot be established and this", "author": "alecgrieser", "createdAt": "2021-01-28T01:07:04Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/MatchIntermediateRule.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * FlattenNestedAndPredicateRule.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.rules;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+import com.apple.foundationdb.record.query.plan.temp.EnumeratingIterable;\n+import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.IdentityBiMap;\n+import com.apple.foundationdb.record.query.plan.temp.IterableHelpers;\n+import com.apple.foundationdb.record.query.plan.temp.MatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.MatchInfo;\n+import com.apple.foundationdb.record.query.plan.temp.PartialMatch;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRule;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRuleCall;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.SelectExpression;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.QuantifierMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.TypeMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matching.BoundMatch;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import static com.apple.foundationdb.record.query.plan.temp.matchers.MultiChildrenMatcher.allMatching;\n+\n+/**\n+ * Expression-based transformation rule that matches any non-leaf expression (called an intermediate expression)\n+ * to a candidate expression in a {@link MatchCandidate}.\n+ * It yields matches of type {@link PartialMatch}. This rule further seeds the memoization\n+ * structure for partial matches that is kept as part of {@link ExpressionRef}. It prepares further rules such as\n+ * other applications of {@link MatchIntermediateRule} and {@link AdjustMatchRule}.\n+ *\n+ * As an intermediate expression has children (and the candidate expression also has at least one child) we\n+ * need to match up the quantifiers of the query expression to the quantifiers of the possible candidate expression\n+ * in order to determine if the query expression is in fact subsumed by the candidate. The property of subsumption\n+ * is defined as the ability of replacing the query expression with the candidate expression with the additional\n+ * application of compensation. Equivalence between expressions is stronger than subsumption in a way that if two\n+ * expressions are semantically equal, the compensation is considered to be a no op.\n+ *\n+ * Example 1\n+ *\n+ * <pre>\n+ * {@code\n+ * query expression                    candidate expression\n+ *\n+ *      +-----------+                       +-----------+\n+ *      |   Union   |                       |   Union   |\n+ *      +-----------+                       +-----------+\n+ *      /     |     \\                       /     |     \\\n+ *     /      |      \\                     /      |      \\\n+ * +----+  +----+  +----+              +----+  +----+  +----+\n+ * | c1 |  | c2 |  | c3 |              | ca |  | cb |  | cc |\n+ * +----+  +----+  +----+              +----+  +----+  +----+\n+ * }\n+ * </pre>\n+ *\n+ * The matching logic between these two expressions needs to first establish if there is a mapping from\n+ * {@code c1, c2, c3} to {@code c1, cb, cc} such that the query expression can be subsumed by the candidate expression.\n+ * In the example, we use union expressions that only define subsumption through equivalency. In other words,\n+ * is there a mapping between the sets of quantifiers the expressions range over such that query expression and candidate\n+ * expression are equal. It may be that no such mapping exist in which case subsumption cannot be established and this", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1MDU1OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565750559", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *\n          \n          \n            \n             * </p>\n          \n          \n            \n             *\n          \n          \n            \n             * <p>", "author": "alecgrieser", "createdAt": "2021-01-28T01:07:36Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/MatchIntermediateRule.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * FlattenNestedAndPredicateRule.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.rules;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+import com.apple.foundationdb.record.query.plan.temp.EnumeratingIterable;\n+import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.IdentityBiMap;\n+import com.apple.foundationdb.record.query.plan.temp.IterableHelpers;\n+import com.apple.foundationdb.record.query.plan.temp.MatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.MatchInfo;\n+import com.apple.foundationdb.record.query.plan.temp.PartialMatch;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRule;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRuleCall;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.SelectExpression;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.QuantifierMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.TypeMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matching.BoundMatch;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import static com.apple.foundationdb.record.query.plan.temp.matchers.MultiChildrenMatcher.allMatching;\n+\n+/**\n+ * Expression-based transformation rule that matches any non-leaf expression (called an intermediate expression)\n+ * to a candidate expression in a {@link MatchCandidate}.\n+ * It yields matches of type {@link PartialMatch}. This rule further seeds the memoization\n+ * structure for partial matches that is kept as part of {@link ExpressionRef}. It prepares further rules such as\n+ * other applications of {@link MatchIntermediateRule} and {@link AdjustMatchRule}.\n+ *\n+ * As an intermediate expression has children (and the candidate expression also has at least one child) we\n+ * need to match up the quantifiers of the query expression to the quantifiers of the possible candidate expression\n+ * in order to determine if the query expression is in fact subsumed by the candidate. The property of subsumption\n+ * is defined as the ability of replacing the query expression with the candidate expression with the additional\n+ * application of compensation. Equivalence between expressions is stronger than subsumption in a way that if two\n+ * expressions are semantically equal, the compensation is considered to be a no op.\n+ *\n+ * Example 1\n+ *\n+ * <pre>\n+ * {@code\n+ * query expression                    candidate expression\n+ *\n+ *      +-----------+                       +-----------+\n+ *      |   Union   |                       |   Union   |\n+ *      +-----------+                       +-----------+\n+ *      /     |     \\                       /     |     \\\n+ *     /      |      \\                     /      |      \\\n+ * +----+  +----+  +----+              +----+  +----+  +----+\n+ * | c1 |  | c2 |  | c3 |              | ca |  | cb |  | cc |\n+ * +----+  +----+  +----+              +----+  +----+  +----+\n+ * }\n+ * </pre>\n+ *\n+ * The matching logic between these two expressions needs to first establish if there is a mapping from\n+ * {@code c1, c2, c3} to {@code c1, cb, cc} such that the query expression can be subsumed by the candidate expression.\n+ * In the example, we use union expressions that only define subsumption through equivalency. In other words,\n+ * is there a mapping between the sets of quantifiers the expressions range over such that query expression and candidate\n+ * expression are equal. It may be that no such mapping exist in which case subsumption cannot be established and this\n+ * rule does not yield matches. It can also be that there are multiple such matches in which case we yield more than\n+ * one partial match back to the planner. The expected \"successful\" outcome would be for this rule to yield exactly one\n+ * match.\n+ *", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1MDkyMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565750921", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *\n          \n          \n            \n             * Example 2\n          \n          \n            \n             * </p>\n          \n          \n            \n             *\n          \n          \n            \n             * <h2>\n          \n          \n            \n             * Example 2\n          \n          \n            \n             * </h2>", "author": "alecgrieser", "createdAt": "2021-01-28T01:08:32Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/MatchIntermediateRule.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * FlattenNestedAndPredicateRule.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.rules;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+import com.apple.foundationdb.record.query.plan.temp.EnumeratingIterable;\n+import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.IdentityBiMap;\n+import com.apple.foundationdb.record.query.plan.temp.IterableHelpers;\n+import com.apple.foundationdb.record.query.plan.temp.MatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.MatchInfo;\n+import com.apple.foundationdb.record.query.plan.temp.PartialMatch;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRule;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRuleCall;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.SelectExpression;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.QuantifierMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.TypeMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matching.BoundMatch;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import static com.apple.foundationdb.record.query.plan.temp.matchers.MultiChildrenMatcher.allMatching;\n+\n+/**\n+ * Expression-based transformation rule that matches any non-leaf expression (called an intermediate expression)\n+ * to a candidate expression in a {@link MatchCandidate}.\n+ * It yields matches of type {@link PartialMatch}. This rule further seeds the memoization\n+ * structure for partial matches that is kept as part of {@link ExpressionRef}. It prepares further rules such as\n+ * other applications of {@link MatchIntermediateRule} and {@link AdjustMatchRule}.\n+ *\n+ * As an intermediate expression has children (and the candidate expression also has at least one child) we\n+ * need to match up the quantifiers of the query expression to the quantifiers of the possible candidate expression\n+ * in order to determine if the query expression is in fact subsumed by the candidate. The property of subsumption\n+ * is defined as the ability of replacing the query expression with the candidate expression with the additional\n+ * application of compensation. Equivalence between expressions is stronger than subsumption in a way that if two\n+ * expressions are semantically equal, the compensation is considered to be a no op.\n+ *\n+ * Example 1\n+ *\n+ * <pre>\n+ * {@code\n+ * query expression                    candidate expression\n+ *\n+ *      +-----------+                       +-----------+\n+ *      |   Union   |                       |   Union   |\n+ *      +-----------+                       +-----------+\n+ *      /     |     \\                       /     |     \\\n+ *     /      |      \\                     /      |      \\\n+ * +----+  +----+  +----+              +----+  +----+  +----+\n+ * | c1 |  | c2 |  | c3 |              | ca |  | cb |  | cc |\n+ * +----+  +----+  +----+              +----+  +----+  +----+\n+ * }\n+ * </pre>\n+ *\n+ * The matching logic between these two expressions needs to first establish if there is a mapping from\n+ * {@code c1, c2, c3} to {@code c1, cb, cc} such that the query expression can be subsumed by the candidate expression.\n+ * In the example, we use union expressions that only define subsumption through equivalency. In other words,\n+ * is there a mapping between the sets of quantifiers the expressions range over such that query expression and candidate\n+ * expression are equal. It may be that no such mapping exist in which case subsumption cannot be established and this\n+ * rule does not yield matches. It can also be that there are multiple such matches in which case we yield more than\n+ * one partial match back to the planner. The expected \"successful\" outcome would be for this rule to yield exactly one\n+ * match.\n+ *\n+ * The described problem is referred to as exact matching. To make matters more complicated, it can be that the query\n+ * expression can be subsumed by the candidate expression even though the sets of quantifiers do not have the same\n+ * cardinality. This is referred to as non-exact matching.\n+ *\n+ * Example 2", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1MTA0Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565751046", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *\n          \n          \n            \n             *\n          \n          \n            \n             * <p>", "author": "alecgrieser", "createdAt": "2021-01-28T01:08:50Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/MatchIntermediateRule.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * FlattenNestedAndPredicateRule.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.rules;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+import com.apple.foundationdb.record.query.plan.temp.EnumeratingIterable;\n+import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.IdentityBiMap;\n+import com.apple.foundationdb.record.query.plan.temp.IterableHelpers;\n+import com.apple.foundationdb.record.query.plan.temp.MatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.MatchInfo;\n+import com.apple.foundationdb.record.query.plan.temp.PartialMatch;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRule;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRuleCall;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.SelectExpression;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.QuantifierMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.TypeMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matching.BoundMatch;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import static com.apple.foundationdb.record.query.plan.temp.matchers.MultiChildrenMatcher.allMatching;\n+\n+/**\n+ * Expression-based transformation rule that matches any non-leaf expression (called an intermediate expression)\n+ * to a candidate expression in a {@link MatchCandidate}.\n+ * It yields matches of type {@link PartialMatch}. This rule further seeds the memoization\n+ * structure for partial matches that is kept as part of {@link ExpressionRef}. It prepares further rules such as\n+ * other applications of {@link MatchIntermediateRule} and {@link AdjustMatchRule}.\n+ *\n+ * As an intermediate expression has children (and the candidate expression also has at least one child) we\n+ * need to match up the quantifiers of the query expression to the quantifiers of the possible candidate expression\n+ * in order to determine if the query expression is in fact subsumed by the candidate. The property of subsumption\n+ * is defined as the ability of replacing the query expression with the candidate expression with the additional\n+ * application of compensation. Equivalence between expressions is stronger than subsumption in a way that if two\n+ * expressions are semantically equal, the compensation is considered to be a no op.\n+ *\n+ * Example 1\n+ *\n+ * <pre>\n+ * {@code\n+ * query expression                    candidate expression\n+ *\n+ *      +-----------+                       +-----------+\n+ *      |   Union   |                       |   Union   |\n+ *      +-----------+                       +-----------+\n+ *      /     |     \\                       /     |     \\\n+ *     /      |      \\                     /      |      \\\n+ * +----+  +----+  +----+              +----+  +----+  +----+\n+ * | c1 |  | c2 |  | c3 |              | ca |  | cb |  | cc |\n+ * +----+  +----+  +----+              +----+  +----+  +----+\n+ * }\n+ * </pre>\n+ *\n+ * The matching logic between these two expressions needs to first establish if there is a mapping from\n+ * {@code c1, c2, c3} to {@code c1, cb, cc} such that the query expression can be subsumed by the candidate expression.\n+ * In the example, we use union expressions that only define subsumption through equivalency. In other words,\n+ * is there a mapping between the sets of quantifiers the expressions range over such that query expression and candidate\n+ * expression are equal. It may be that no such mapping exist in which case subsumption cannot be established and this\n+ * rule does not yield matches. It can also be that there are multiple such matches in which case we yield more than\n+ * one partial match back to the planner. The expected \"successful\" outcome would be for this rule to yield exactly one\n+ * match.\n+ *\n+ * The described problem is referred to as exact matching. To make matters more complicated, it can be that the query\n+ * expression can be subsumed by the candidate expression even though the sets of quantifiers do not have the same\n+ * cardinality. This is referred to as non-exact matching.\n+ *\n+ * Example 2\n+ *\n+ * <pre>\n+ * {@code\n+ * query expression                    candidate expression\n+ *\n+ *     +-----------+                     +-----------+\n+ *     |   Select  |                     |   Select  |\n+ *     +-----------+                     +-----------+\n+ *      /        \\ exists                /     |     \\\n+ *     /          \\                     /      |      \\\n+ * +----+      +----+              +----+  +----+  +----+\n+ * | c1 |      | c2 |              | ca |  | cb |  | cc |\n+ * +----+      +----+              +----+  +----+  +----+\n+ * }\n+ * </pre>\n+ *", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1MTMzMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565751333", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *\n          \n          \n            \n             * </p>\n          \n          \n            \n             *\n          \n          \n            \n             * <p>", "author": "alecgrieser", "createdAt": "2021-01-28T01:09:30Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/MatchIntermediateRule.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * FlattenNestedAndPredicateRule.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.rules;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+import com.apple.foundationdb.record.query.plan.temp.EnumeratingIterable;\n+import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.IdentityBiMap;\n+import com.apple.foundationdb.record.query.plan.temp.IterableHelpers;\n+import com.apple.foundationdb.record.query.plan.temp.MatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.MatchInfo;\n+import com.apple.foundationdb.record.query.plan.temp.PartialMatch;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRule;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRuleCall;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.SelectExpression;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.QuantifierMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.TypeMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matching.BoundMatch;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import static com.apple.foundationdb.record.query.plan.temp.matchers.MultiChildrenMatcher.allMatching;\n+\n+/**\n+ * Expression-based transformation rule that matches any non-leaf expression (called an intermediate expression)\n+ * to a candidate expression in a {@link MatchCandidate}.\n+ * It yields matches of type {@link PartialMatch}. This rule further seeds the memoization\n+ * structure for partial matches that is kept as part of {@link ExpressionRef}. It prepares further rules such as\n+ * other applications of {@link MatchIntermediateRule} and {@link AdjustMatchRule}.\n+ *\n+ * As an intermediate expression has children (and the candidate expression also has at least one child) we\n+ * need to match up the quantifiers of the query expression to the quantifiers of the possible candidate expression\n+ * in order to determine if the query expression is in fact subsumed by the candidate. The property of subsumption\n+ * is defined as the ability of replacing the query expression with the candidate expression with the additional\n+ * application of compensation. Equivalence between expressions is stronger than subsumption in a way that if two\n+ * expressions are semantically equal, the compensation is considered to be a no op.\n+ *\n+ * Example 1\n+ *\n+ * <pre>\n+ * {@code\n+ * query expression                    candidate expression\n+ *\n+ *      +-----------+                       +-----------+\n+ *      |   Union   |                       |   Union   |\n+ *      +-----------+                       +-----------+\n+ *      /     |     \\                       /     |     \\\n+ *     /      |      \\                     /      |      \\\n+ * +----+  +----+  +----+              +----+  +----+  +----+\n+ * | c1 |  | c2 |  | c3 |              | ca |  | cb |  | cc |\n+ * +----+  +----+  +----+              +----+  +----+  +----+\n+ * }\n+ * </pre>\n+ *\n+ * The matching logic between these two expressions needs to first establish if there is a mapping from\n+ * {@code c1, c2, c3} to {@code c1, cb, cc} such that the query expression can be subsumed by the candidate expression.\n+ * In the example, we use union expressions that only define subsumption through equivalency. In other words,\n+ * is there a mapping between the sets of quantifiers the expressions range over such that query expression and candidate\n+ * expression are equal. It may be that no such mapping exist in which case subsumption cannot be established and this\n+ * rule does not yield matches. It can also be that there are multiple such matches in which case we yield more than\n+ * one partial match back to the planner. The expected \"successful\" outcome would be for this rule to yield exactly one\n+ * match.\n+ *\n+ * The described problem is referred to as exact matching. To make matters more complicated, it can be that the query\n+ * expression can be subsumed by the candidate expression even though the sets of quantifiers do not have the same\n+ * cardinality. This is referred to as non-exact matching.\n+ *\n+ * Example 2\n+ *\n+ * <pre>\n+ * {@code\n+ * query expression                    candidate expression\n+ *\n+ *     +-----------+                     +-----------+\n+ *     |   Select  |                     |   Select  |\n+ *     +-----------+                     +-----------+\n+ *      /        \\ exists                /     |     \\\n+ *     /          \\                     /      |      \\\n+ * +----+      +----+              +----+  +----+  +----+\n+ * | c1 |      | c2 |              | ca |  | cb |  | cc |\n+ * +----+      +----+              +----+  +----+  +----+\n+ * }\n+ * </pre>\n+ *\n+ * For simplicity let us further assume the subtrees underneath {@code c1} and {@code ca} as well as\n+ * the subtrees underneath {@code c2} and {@code cb} are already determined to be semantically equivalent.\n+ * In this example we yield two partial matches, one for {@code c1 -> ca} and one for {@code c1 -> ca, c2 -> cb}.\n+ * That is because the query expression can be replaced by the candidate expression in both cases (albeit with\n+ * different compensations).\n+ *", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1MTg3NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565751875", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Discussion as to why they are matching. For further explanation see {@link SelectExpression#subsumedBy}. First note\n          \n          \n            \n             * Discussion as to why they are matching: for further explanation see {@link SelectExpression#subsumedBy}. First note\n          \n      \n    \n    \n  \n\nI could also see making the \"discussion\" phrase its own header and then the rest of the paragraph is in its own section, more or less as is.", "author": "alecgrieser", "createdAt": "2021-01-28T01:11:02Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/MatchIntermediateRule.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * FlattenNestedAndPredicateRule.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.rules;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+import com.apple.foundationdb.record.query.plan.temp.EnumeratingIterable;\n+import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.IdentityBiMap;\n+import com.apple.foundationdb.record.query.plan.temp.IterableHelpers;\n+import com.apple.foundationdb.record.query.plan.temp.MatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.MatchInfo;\n+import com.apple.foundationdb.record.query.plan.temp.PartialMatch;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRule;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRuleCall;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.SelectExpression;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.QuantifierMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.TypeMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matching.BoundMatch;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import static com.apple.foundationdb.record.query.plan.temp.matchers.MultiChildrenMatcher.allMatching;\n+\n+/**\n+ * Expression-based transformation rule that matches any non-leaf expression (called an intermediate expression)\n+ * to a candidate expression in a {@link MatchCandidate}.\n+ * It yields matches of type {@link PartialMatch}. This rule further seeds the memoization\n+ * structure for partial matches that is kept as part of {@link ExpressionRef}. It prepares further rules such as\n+ * other applications of {@link MatchIntermediateRule} and {@link AdjustMatchRule}.\n+ *\n+ * As an intermediate expression has children (and the candidate expression also has at least one child) we\n+ * need to match up the quantifiers of the query expression to the quantifiers of the possible candidate expression\n+ * in order to determine if the query expression is in fact subsumed by the candidate. The property of subsumption\n+ * is defined as the ability of replacing the query expression with the candidate expression with the additional\n+ * application of compensation. Equivalence between expressions is stronger than subsumption in a way that if two\n+ * expressions are semantically equal, the compensation is considered to be a no op.\n+ *\n+ * Example 1\n+ *\n+ * <pre>\n+ * {@code\n+ * query expression                    candidate expression\n+ *\n+ *      +-----------+                       +-----------+\n+ *      |   Union   |                       |   Union   |\n+ *      +-----------+                       +-----------+\n+ *      /     |     \\                       /     |     \\\n+ *     /      |      \\                     /      |      \\\n+ * +----+  +----+  +----+              +----+  +----+  +----+\n+ * | c1 |  | c2 |  | c3 |              | ca |  | cb |  | cc |\n+ * +----+  +----+  +----+              +----+  +----+  +----+\n+ * }\n+ * </pre>\n+ *\n+ * The matching logic between these two expressions needs to first establish if there is a mapping from\n+ * {@code c1, c2, c3} to {@code c1, cb, cc} such that the query expression can be subsumed by the candidate expression.\n+ * In the example, we use union expressions that only define subsumption through equivalency. In other words,\n+ * is there a mapping between the sets of quantifiers the expressions range over such that query expression and candidate\n+ * expression are equal. It may be that no such mapping exist in which case subsumption cannot be established and this\n+ * rule does not yield matches. It can also be that there are multiple such matches in which case we yield more than\n+ * one partial match back to the planner. The expected \"successful\" outcome would be for this rule to yield exactly one\n+ * match.\n+ *\n+ * The described problem is referred to as exact matching. To make matters more complicated, it can be that the query\n+ * expression can be subsumed by the candidate expression even though the sets of quantifiers do not have the same\n+ * cardinality. This is referred to as non-exact matching.\n+ *\n+ * Example 2\n+ *\n+ * <pre>\n+ * {@code\n+ * query expression                    candidate expression\n+ *\n+ *     +-----------+                     +-----------+\n+ *     |   Select  |                     |   Select  |\n+ *     +-----------+                     +-----------+\n+ *      /        \\ exists                /     |     \\\n+ *     /          \\                     /      |      \\\n+ * +----+      +----+              +----+  +----+  +----+\n+ * | c1 |      | c2 |              | ca |  | cb |  | cc |\n+ * +----+      +----+              +----+  +----+  +----+\n+ * }\n+ * </pre>\n+ *\n+ * For simplicity let us further assume the subtrees underneath {@code c1} and {@code ca} as well as\n+ * the subtrees underneath {@code c2} and {@code cb} are already determined to be semantically equivalent.\n+ * In this example we yield two partial matches, one for {@code c1 -> ca} and one for {@code c1 -> ca, c2 -> cb}.\n+ * That is because the query expression can be replaced by the candidate expression in both cases (albeit with\n+ * different compensations).\n+ *\n+ * Discussion as to why they are matching. For further explanation see {@link SelectExpression#subsumedBy}. First note", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1MzAxOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565753019", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             */\n          \n          \n            \n             * </p>\n          \n          \n            \n             */", "author": "alecgrieser", "createdAt": "2021-01-28T01:12:34Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/MatchIntermediateRule.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * FlattenNestedAndPredicateRule.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.rules;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+import com.apple.foundationdb.record.query.plan.temp.EnumeratingIterable;\n+import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.IdentityBiMap;\n+import com.apple.foundationdb.record.query.plan.temp.IterableHelpers;\n+import com.apple.foundationdb.record.query.plan.temp.MatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.MatchInfo;\n+import com.apple.foundationdb.record.query.plan.temp.PartialMatch;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRule;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRuleCall;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.SelectExpression;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.QuantifierMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.TypeMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matching.BoundMatch;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import static com.apple.foundationdb.record.query.plan.temp.matchers.MultiChildrenMatcher.allMatching;\n+\n+/**\n+ * Expression-based transformation rule that matches any non-leaf expression (called an intermediate expression)\n+ * to a candidate expression in a {@link MatchCandidate}.\n+ * It yields matches of type {@link PartialMatch}. This rule further seeds the memoization\n+ * structure for partial matches that is kept as part of {@link ExpressionRef}. It prepares further rules such as\n+ * other applications of {@link MatchIntermediateRule} and {@link AdjustMatchRule}.\n+ *\n+ * As an intermediate expression has children (and the candidate expression also has at least one child) we\n+ * need to match up the quantifiers of the query expression to the quantifiers of the possible candidate expression\n+ * in order to determine if the query expression is in fact subsumed by the candidate. The property of subsumption\n+ * is defined as the ability of replacing the query expression with the candidate expression with the additional\n+ * application of compensation. Equivalence between expressions is stronger than subsumption in a way that if two\n+ * expressions are semantically equal, the compensation is considered to be a no op.\n+ *\n+ * Example 1\n+ *\n+ * <pre>\n+ * {@code\n+ * query expression                    candidate expression\n+ *\n+ *      +-----------+                       +-----------+\n+ *      |   Union   |                       |   Union   |\n+ *      +-----------+                       +-----------+\n+ *      /     |     \\                       /     |     \\\n+ *     /      |      \\                     /      |      \\\n+ * +----+  +----+  +----+              +----+  +----+  +----+\n+ * | c1 |  | c2 |  | c3 |              | ca |  | cb |  | cc |\n+ * +----+  +----+  +----+              +----+  +----+  +----+\n+ * }\n+ * </pre>\n+ *\n+ * The matching logic between these two expressions needs to first establish if there is a mapping from\n+ * {@code c1, c2, c3} to {@code c1, cb, cc} such that the query expression can be subsumed by the candidate expression.\n+ * In the example, we use union expressions that only define subsumption through equivalency. In other words,\n+ * is there a mapping between the sets of quantifiers the expressions range over such that query expression and candidate\n+ * expression are equal. It may be that no such mapping exist in which case subsumption cannot be established and this\n+ * rule does not yield matches. It can also be that there are multiple such matches in which case we yield more than\n+ * one partial match back to the planner. The expected \"successful\" outcome would be for this rule to yield exactly one\n+ * match.\n+ *\n+ * The described problem is referred to as exact matching. To make matters more complicated, it can be that the query\n+ * expression can be subsumed by the candidate expression even though the sets of quantifiers do not have the same\n+ * cardinality. This is referred to as non-exact matching.\n+ *\n+ * Example 2\n+ *\n+ * <pre>\n+ * {@code\n+ * query expression                    candidate expression\n+ *\n+ *     +-----------+                     +-----------+\n+ *     |   Select  |                     |   Select  |\n+ *     +-----------+                     +-----------+\n+ *      /        \\ exists                /     |     \\\n+ *     /          \\                     /      |      \\\n+ * +----+      +----+              +----+  +----+  +----+\n+ * | c1 |      | c2 |              | ca |  | cb |  | cc |\n+ * +----+      +----+              +----+  +----+  +----+\n+ * }\n+ * </pre>\n+ *\n+ * For simplicity let us further assume the subtrees underneath {@code c1} and {@code ca} as well as\n+ * the subtrees underneath {@code c2} and {@code cb} are already determined to be semantically equivalent.\n+ * In this example we yield two partial matches, one for {@code c1 -> ca} and one for {@code c1 -> ca, c2 -> cb}.\n+ * That is because the query expression can be replaced by the candidate expression in both cases (albeit with\n+ * different compensations).\n+ *\n+ * Discussion as to why they are matching. For further explanation see {@link SelectExpression#subsumedBy}. First note\n+ * that the quantifier over {@code c2} is existential (of type {@link Existential}. That also means that this quantifier\n+ * does not ever positively contribute to the cardinality of the select expression. It only filters out the outer if\n+ * the inner does not produce any records. In some sense it is very similar to a predicate. In fact it is a predicate\n+ * defined on a sub query. Now if {@code ca} is known to subsume {@code c1} we can replace the query expression with\n+ * the candidate expression if we also reapply the existential predicate (first match case). For the match that also\n+ * maps {@code c2} to {@code cb} we also know that the existential predicate over {@code c2} is filtering out a record\n+ * when {@code cb} does not produce any records. On the flip side if there is more than one record being produced by the\n+ * sub query on the query side the quantifier over {@code cb} produces multiple records that now do contribute to the\n+ * cardinality on the candidate side. That will need to be corrected by distinct-ing the output of the select expression\n+ * if the match is utilized later on.\n+ */", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1Njk1OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565756958", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *\n          \n          \n            \n                 *\n          \n          \n            \n                 * <p>", "author": "alecgrieser", "createdAt": "2021-01-28T01:24:25Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/QueryPredicate.java", "diffHunk": "@@ -23,51 +23,156 @@\n import com.apple.foundationdb.annotation.API;\n import com.apple.foundationdb.record.EvaluationContext;\n import com.apple.foundationdb.record.PlanHashable;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecord;\n import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreBase;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n import com.apple.foundationdb.record.query.plan.temp.Bindable;\n import com.apple.foundationdb.record.query.plan.temp.Correlated;\n-import com.apple.foundationdb.record.query.plan.temp.view.SourceEntry;\n+import com.apple.foundationdb.record.query.plan.temp.PredicateMultiMap.PredicateMapping;\n+import com.google.common.collect.ImmutableSet;\n import com.google.protobuf.Message;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n \n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n+import java.util.Optional;\n+import java.util.Set;\n \n /**\n- * An interface describing a predicate that can be evaluated on a {@link SourceEntry} (usually derived from a record).\n- *\n- * <p>\n- * {@code QueryPredicate} is generally quite similar to {@link com.apple.foundationdb.record.query.expressions.QueryComponent}.\n- * However, there is a key difference in how each interface evaluates the predicate against a given record:\n- * </p>\n- * <ul>\n- *     <li>\n- *         A {@link com.apple.foundationdb.record.query.expressions.QueryComponent} is evaluated on a\n- *         {@link com.apple.foundationdb.record.provider.foundationdb.FDBRecord} wrapping a Protobuf message.\n- *         To evaluate predicates on nested records, a {@code QueryComponent} such as\n- *         {@link com.apple.foundationdb.record.query.expressions.NestedField} or\n- *         {@link com.apple.foundationdb.record.query.expressions.OneOfThemWithComponent} will descend into the nested\n- *         record.\n- *     </li>\n- *     <li>\n- *         A {@code QueryPredicate} is evaluated on a {@link SourceEntry}, which maps\n- *         {@link com.apple.foundationdb.record.query.plan.temp.view.Source}s to values. The predicate can be evaluated\n- *         on a nested record by specifying a complex {@code Source}, such as\n- *         {@link com.apple.foundationdb.record.query.plan.temp.view.RepeatedFieldSource}. All sources are evaluated\n- *         to produce a stream of source entries before any predicates are evaluated.\n- *     </li>\n- * </ul>\n- *\n- * <p>\n- * Concretely, the difference between {@code QueryPredicate}s and {@code QueryComponent}s is most easily seen in the\n- * way that multiple predicates on repeated fields can be expressed. Any query predicate anywhere in a tree of\n- * predicates can make use of any source. In contrast, each {@link com.apple.foundationdb.record.query.expressions.OneOfThemWithComponent}\n- * is a single iteration through the field's repeated values so the values obtained by that iteration are usable only\n- * within that {@code OneOfThemWithComponent}.\n- * </p>\n+ * Class to model the concept of a predicate. A predicate is a construct that can be evaluated using\n+ * three-values logic for a set of given inputs. The caller can then use that result to take appropriate action,\n+ * e.g. filter a record out of a set of records, etc.\n  */\n @API(API.Status.EXPERIMENTAL)\n public interface QueryPredicate extends Bindable, PlanHashable, Correlated<QueryPredicate> {\n+\n+    /**\n+     * Determines if this predicate implies some other predicate.\n+     *", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1NzAzNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565757036", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Let's say the the {@code EVAL(p)} denotes the outcome of the evaluation of a predicate. A predicate {@code p1}\n          \n          \n            \n                 * Let's say that {@code EVAL(p)} denotes the outcome of the evaluation of a predicate. A predicate {@code p1}", "author": "alecgrieser", "createdAt": "2021-01-28T01:24:43Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/QueryPredicate.java", "diffHunk": "@@ -23,51 +23,156 @@\n import com.apple.foundationdb.annotation.API;\n import com.apple.foundationdb.record.EvaluationContext;\n import com.apple.foundationdb.record.PlanHashable;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecord;\n import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreBase;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n import com.apple.foundationdb.record.query.plan.temp.Bindable;\n import com.apple.foundationdb.record.query.plan.temp.Correlated;\n-import com.apple.foundationdb.record.query.plan.temp.view.SourceEntry;\n+import com.apple.foundationdb.record.query.plan.temp.PredicateMultiMap.PredicateMapping;\n+import com.google.common.collect.ImmutableSet;\n import com.google.protobuf.Message;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n \n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n+import java.util.Optional;\n+import java.util.Set;\n \n /**\n- * An interface describing a predicate that can be evaluated on a {@link SourceEntry} (usually derived from a record).\n- *\n- * <p>\n- * {@code QueryPredicate} is generally quite similar to {@link com.apple.foundationdb.record.query.expressions.QueryComponent}.\n- * However, there is a key difference in how each interface evaluates the predicate against a given record:\n- * </p>\n- * <ul>\n- *     <li>\n- *         A {@link com.apple.foundationdb.record.query.expressions.QueryComponent} is evaluated on a\n- *         {@link com.apple.foundationdb.record.provider.foundationdb.FDBRecord} wrapping a Protobuf message.\n- *         To evaluate predicates on nested records, a {@code QueryComponent} such as\n- *         {@link com.apple.foundationdb.record.query.expressions.NestedField} or\n- *         {@link com.apple.foundationdb.record.query.expressions.OneOfThemWithComponent} will descend into the nested\n- *         record.\n- *     </li>\n- *     <li>\n- *         A {@code QueryPredicate} is evaluated on a {@link SourceEntry}, which maps\n- *         {@link com.apple.foundationdb.record.query.plan.temp.view.Source}s to values. The predicate can be evaluated\n- *         on a nested record by specifying a complex {@code Source}, such as\n- *         {@link com.apple.foundationdb.record.query.plan.temp.view.RepeatedFieldSource}. All sources are evaluated\n- *         to produce a stream of source entries before any predicates are evaluated.\n- *     </li>\n- * </ul>\n- *\n- * <p>\n- * Concretely, the difference between {@code QueryPredicate}s and {@code QueryComponent}s is most easily seen in the\n- * way that multiple predicates on repeated fields can be expressed. Any query predicate anywhere in a tree of\n- * predicates can make use of any source. In contrast, each {@link com.apple.foundationdb.record.query.expressions.OneOfThemWithComponent}\n- * is a single iteration through the field's repeated values so the values obtained by that iteration are usable only\n- * within that {@code OneOfThemWithComponent}.\n- * </p>\n+ * Class to model the concept of a predicate. A predicate is a construct that can be evaluated using\n+ * three-values logic for a set of given inputs. The caller can then use that result to take appropriate action,\n+ * e.g. filter a record out of a set of records, etc.\n  */\n @API(API.Status.EXPERIMENTAL)\n public interface QueryPredicate extends Bindable, PlanHashable, Correlated<QueryPredicate> {\n+\n+    /**\n+     * Determines if this predicate implies some other predicate.\n+     *\n+     * Let's say the the {@code EVAL(p)} denotes the outcome of the evaluation of a predicate. A predicate {@code p1}", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1NzIyNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565757225", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *\n          \n          \n            \n                 * </p>\n          \n          \n            \n                 *\n          \n          \n            \n                 * <p>", "author": "alecgrieser", "createdAt": "2021-01-28T01:25:22Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/QueryPredicate.java", "diffHunk": "@@ -23,51 +23,156 @@\n import com.apple.foundationdb.annotation.API;\n import com.apple.foundationdb.record.EvaluationContext;\n import com.apple.foundationdb.record.PlanHashable;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecord;\n import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreBase;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n import com.apple.foundationdb.record.query.plan.temp.Bindable;\n import com.apple.foundationdb.record.query.plan.temp.Correlated;\n-import com.apple.foundationdb.record.query.plan.temp.view.SourceEntry;\n+import com.apple.foundationdb.record.query.plan.temp.PredicateMultiMap.PredicateMapping;\n+import com.google.common.collect.ImmutableSet;\n import com.google.protobuf.Message;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n \n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n+import java.util.Optional;\n+import java.util.Set;\n \n /**\n- * An interface describing a predicate that can be evaluated on a {@link SourceEntry} (usually derived from a record).\n- *\n- * <p>\n- * {@code QueryPredicate} is generally quite similar to {@link com.apple.foundationdb.record.query.expressions.QueryComponent}.\n- * However, there is a key difference in how each interface evaluates the predicate against a given record:\n- * </p>\n- * <ul>\n- *     <li>\n- *         A {@link com.apple.foundationdb.record.query.expressions.QueryComponent} is evaluated on a\n- *         {@link com.apple.foundationdb.record.provider.foundationdb.FDBRecord} wrapping a Protobuf message.\n- *         To evaluate predicates on nested records, a {@code QueryComponent} such as\n- *         {@link com.apple.foundationdb.record.query.expressions.NestedField} or\n- *         {@link com.apple.foundationdb.record.query.expressions.OneOfThemWithComponent} will descend into the nested\n- *         record.\n- *     </li>\n- *     <li>\n- *         A {@code QueryPredicate} is evaluated on a {@link SourceEntry}, which maps\n- *         {@link com.apple.foundationdb.record.query.plan.temp.view.Source}s to values. The predicate can be evaluated\n- *         on a nested record by specifying a complex {@code Source}, such as\n- *         {@link com.apple.foundationdb.record.query.plan.temp.view.RepeatedFieldSource}. All sources are evaluated\n- *         to produce a stream of source entries before any predicates are evaluated.\n- *     </li>\n- * </ul>\n- *\n- * <p>\n- * Concretely, the difference between {@code QueryPredicate}s and {@code QueryComponent}s is most easily seen in the\n- * way that multiple predicates on repeated fields can be expressed. Any query predicate anywhere in a tree of\n- * predicates can make use of any source. In contrast, each {@link com.apple.foundationdb.record.query.expressions.OneOfThemWithComponent}\n- * is a single iteration through the field's repeated values so the values obtained by that iteration are usable only\n- * within that {@code OneOfThemWithComponent}.\n- * </p>\n+ * Class to model the concept of a predicate. A predicate is a construct that can be evaluated using\n+ * three-values logic for a set of given inputs. The caller can then use that result to take appropriate action,\n+ * e.g. filter a record out of a set of records, etc.\n  */\n @API(API.Status.EXPERIMENTAL)\n public interface QueryPredicate extends Bindable, PlanHashable, Correlated<QueryPredicate> {\n+\n+    /**\n+     * Determines if this predicate implies some other predicate.\n+     *\n+     * Let's say the the {@code EVAL(p)} denotes the outcome of the evaluation of a predicate. A predicate {@code p1}\n+     * implies some other predicate {@code p2} if\n+     *\n+     * <pre>\n+     *     {@code\n+     *     (EVAL(p1, recordBindings) == true) -> (EVAL(p2, recordBindings) == true)\n+     *     }\n+     * </pre>\n+     *\n+     * for all {@code recordBindings} possibly contained in a stream of records that are potentially being flowed at\n+     * execution time.\n+     *", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1Nzg5Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565757893", "bodyText": "sargable?", "author": "alecgrieser", "createdAt": "2021-01-28T01:27:23Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/QueryPredicate.java", "diffHunk": "@@ -23,51 +23,156 @@\n import com.apple.foundationdb.annotation.API;\n import com.apple.foundationdb.record.EvaluationContext;\n import com.apple.foundationdb.record.PlanHashable;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecord;\n import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreBase;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n import com.apple.foundationdb.record.query.plan.temp.Bindable;\n import com.apple.foundationdb.record.query.plan.temp.Correlated;\n-import com.apple.foundationdb.record.query.plan.temp.view.SourceEntry;\n+import com.apple.foundationdb.record.query.plan.temp.PredicateMultiMap.PredicateMapping;\n+import com.google.common.collect.ImmutableSet;\n import com.google.protobuf.Message;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n \n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n+import java.util.Optional;\n+import java.util.Set;\n \n /**\n- * An interface describing a predicate that can be evaluated on a {@link SourceEntry} (usually derived from a record).\n- *\n- * <p>\n- * {@code QueryPredicate} is generally quite similar to {@link com.apple.foundationdb.record.query.expressions.QueryComponent}.\n- * However, there is a key difference in how each interface evaluates the predicate against a given record:\n- * </p>\n- * <ul>\n- *     <li>\n- *         A {@link com.apple.foundationdb.record.query.expressions.QueryComponent} is evaluated on a\n- *         {@link com.apple.foundationdb.record.provider.foundationdb.FDBRecord} wrapping a Protobuf message.\n- *         To evaluate predicates on nested records, a {@code QueryComponent} such as\n- *         {@link com.apple.foundationdb.record.query.expressions.NestedField} or\n- *         {@link com.apple.foundationdb.record.query.expressions.OneOfThemWithComponent} will descend into the nested\n- *         record.\n- *     </li>\n- *     <li>\n- *         A {@code QueryPredicate} is evaluated on a {@link SourceEntry}, which maps\n- *         {@link com.apple.foundationdb.record.query.plan.temp.view.Source}s to values. The predicate can be evaluated\n- *         on a nested record by specifying a complex {@code Source}, such as\n- *         {@link com.apple.foundationdb.record.query.plan.temp.view.RepeatedFieldSource}. All sources are evaluated\n- *         to produce a stream of source entries before any predicates are evaluated.\n- *     </li>\n- * </ul>\n- *\n- * <p>\n- * Concretely, the difference between {@code QueryPredicate}s and {@code QueryComponent}s is most easily seen in the\n- * way that multiple predicates on repeated fields can be expressed. Any query predicate anywhere in a tree of\n- * predicates can make use of any source. In contrast, each {@link com.apple.foundationdb.record.query.expressions.OneOfThemWithComponent}\n- * is a single iteration through the field's repeated values so the values obtained by that iteration are usable only\n- * within that {@code OneOfThemWithComponent}.\n- * </p>\n+ * Class to model the concept of a predicate. A predicate is a construct that can be evaluated using\n+ * three-values logic for a set of given inputs. The caller can then use that result to take appropriate action,\n+ * e.g. filter a record out of a set of records, etc.\n  */\n @API(API.Status.EXPERIMENTAL)\n public interface QueryPredicate extends Bindable, PlanHashable, Correlated<QueryPredicate> {\n+\n+    /**\n+     * Determines if this predicate implies some other predicate.\n+     *\n+     * Let's say the the {@code EVAL(p)} denotes the outcome of the evaluation of a predicate. A predicate {@code p1}\n+     * implies some other predicate {@code p2} if\n+     *\n+     * <pre>\n+     *     {@code\n+     *     (EVAL(p1, recordBindings) == true) -> (EVAL(p2, recordBindings) == true)\n+     *     }\n+     * </pre>\n+     *\n+     * for all {@code recordBindings} possibly contained in a stream of records that are potentially being flowed at\n+     * execution time.\n+     *\n+     * If {@code p1} implies {@code p2}, this method returns an instance of class {@link PredicateMapping} which should\n+     * give the caller all necessary info to change {@code p2} to {@code COMP(p2)} in a way make the opposite also true:\n+     *\n+     * <pre>\n+     *     {@code\n+     *     (EVAL(p1, recordBindings) == true) <-> (EVAL(COMP(p2), recordBindings) == true)\n+     *     }\n+     * </pre>\n+     *\n+     * Note that this method takes special care when placeholders are involved as this method is called during index\n+     * matching with candidates graphs. A placeholder by itself cannot be executed. In order for the place holder to\n+     * match it has to partake in a relationship with a query predicate that tells the placeholder the specific comparison\n+     * and bounds it operates over. In some sends this expresses a kind of polymorphism of the placeholder that is bound\n+     * to a specific predicate only in the presence of a sargable predicate on the query side.", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjM1MTU5NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572351595", "bodyText": "see class Sargable. Added a link to that class in the Javadoc here. Sargable stands for (s)earch(arg)ument-able. it's like common lingo :-)", "author": "normen662", "createdAt": "2021-02-08T20:33:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1Nzg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1ODM3NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565758374", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *\n          \n          \n            \n                 * Examples:\n          \n          \n            \n                 *\n          \n          \n            \n                 * Example 1\n          \n          \n            \n                 * </p>\n          \n          \n            \n                 *\n          \n          \n            \n                 * <h2>\n          \n          \n            \n                 * Examples:\n          \n          \n            \n                 * </h2>\n          \n          \n            \n                 *\n          \n          \n            \n                 * <h3>\n          \n          \n            \n                 * Example 1\n          \n          \n            \n                 * </h3>", "author": "alecgrieser", "createdAt": "2021-01-28T01:28:38Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/QueryPredicate.java", "diffHunk": "@@ -23,51 +23,156 @@\n import com.apple.foundationdb.annotation.API;\n import com.apple.foundationdb.record.EvaluationContext;\n import com.apple.foundationdb.record.PlanHashable;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecord;\n import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreBase;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n import com.apple.foundationdb.record.query.plan.temp.Bindable;\n import com.apple.foundationdb.record.query.plan.temp.Correlated;\n-import com.apple.foundationdb.record.query.plan.temp.view.SourceEntry;\n+import com.apple.foundationdb.record.query.plan.temp.PredicateMultiMap.PredicateMapping;\n+import com.google.common.collect.ImmutableSet;\n import com.google.protobuf.Message;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n \n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n+import java.util.Optional;\n+import java.util.Set;\n \n /**\n- * An interface describing a predicate that can be evaluated on a {@link SourceEntry} (usually derived from a record).\n- *\n- * <p>\n- * {@code QueryPredicate} is generally quite similar to {@link com.apple.foundationdb.record.query.expressions.QueryComponent}.\n- * However, there is a key difference in how each interface evaluates the predicate against a given record:\n- * </p>\n- * <ul>\n- *     <li>\n- *         A {@link com.apple.foundationdb.record.query.expressions.QueryComponent} is evaluated on a\n- *         {@link com.apple.foundationdb.record.provider.foundationdb.FDBRecord} wrapping a Protobuf message.\n- *         To evaluate predicates on nested records, a {@code QueryComponent} such as\n- *         {@link com.apple.foundationdb.record.query.expressions.NestedField} or\n- *         {@link com.apple.foundationdb.record.query.expressions.OneOfThemWithComponent} will descend into the nested\n- *         record.\n- *     </li>\n- *     <li>\n- *         A {@code QueryPredicate} is evaluated on a {@link SourceEntry}, which maps\n- *         {@link com.apple.foundationdb.record.query.plan.temp.view.Source}s to values. The predicate can be evaluated\n- *         on a nested record by specifying a complex {@code Source}, such as\n- *         {@link com.apple.foundationdb.record.query.plan.temp.view.RepeatedFieldSource}. All sources are evaluated\n- *         to produce a stream of source entries before any predicates are evaluated.\n- *     </li>\n- * </ul>\n- *\n- * <p>\n- * Concretely, the difference between {@code QueryPredicate}s and {@code QueryComponent}s is most easily seen in the\n- * way that multiple predicates on repeated fields can be expressed. Any query predicate anywhere in a tree of\n- * predicates can make use of any source. In contrast, each {@link com.apple.foundationdb.record.query.expressions.OneOfThemWithComponent}\n- * is a single iteration through the field's repeated values so the values obtained by that iteration are usable only\n- * within that {@code OneOfThemWithComponent}.\n- * </p>\n+ * Class to model the concept of a predicate. A predicate is a construct that can be evaluated using\n+ * three-values logic for a set of given inputs. The caller can then use that result to take appropriate action,\n+ * e.g. filter a record out of a set of records, etc.\n  */\n @API(API.Status.EXPERIMENTAL)\n public interface QueryPredicate extends Bindable, PlanHashable, Correlated<QueryPredicate> {\n+\n+    /**\n+     * Determines if this predicate implies some other predicate.\n+     *\n+     * Let's say the the {@code EVAL(p)} denotes the outcome of the evaluation of a predicate. A predicate {@code p1}\n+     * implies some other predicate {@code p2} if\n+     *\n+     * <pre>\n+     *     {@code\n+     *     (EVAL(p1, recordBindings) == true) -> (EVAL(p2, recordBindings) == true)\n+     *     }\n+     * </pre>\n+     *\n+     * for all {@code recordBindings} possibly contained in a stream of records that are potentially being flowed at\n+     * execution time.\n+     *\n+     * If {@code p1} implies {@code p2}, this method returns an instance of class {@link PredicateMapping} which should\n+     * give the caller all necessary info to change {@code p2} to {@code COMP(p2)} in a way make the opposite also true:\n+     *\n+     * <pre>\n+     *     {@code\n+     *     (EVAL(p1, recordBindings) == true) <-> (EVAL(COMP(p2), recordBindings) == true)\n+     *     }\n+     * </pre>\n+     *\n+     * Note that this method takes special care when placeholders are involved as this method is called during index\n+     * matching with candidates graphs. A placeholder by itself cannot be executed. In order for the place holder to\n+     * match it has to partake in a relationship with a query predicate that tells the placeholder the specific comparison\n+     * and bounds it operates over. In some sends this expresses a kind of polymorphism of the placeholder that is bound\n+     * to a specific predicate only in the presence of a sargable predicate on the query side.\n+     *\n+     * Examples:\n+     *\n+     * Example 1", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1ODYzNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565758635", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Example 2\n          \n          \n            \n                 * <h3>\n          \n          \n            \n                 * Example 2\n          \n          \n            \n                 * </h3>", "author": "alecgrieser", "createdAt": "2021-01-28T01:29:24Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/QueryPredicate.java", "diffHunk": "@@ -23,51 +23,156 @@\n import com.apple.foundationdb.annotation.API;\n import com.apple.foundationdb.record.EvaluationContext;\n import com.apple.foundationdb.record.PlanHashable;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecord;\n import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreBase;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n import com.apple.foundationdb.record.query.plan.temp.Bindable;\n import com.apple.foundationdb.record.query.plan.temp.Correlated;\n-import com.apple.foundationdb.record.query.plan.temp.view.SourceEntry;\n+import com.apple.foundationdb.record.query.plan.temp.PredicateMultiMap.PredicateMapping;\n+import com.google.common.collect.ImmutableSet;\n import com.google.protobuf.Message;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n \n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n+import java.util.Optional;\n+import java.util.Set;\n \n /**\n- * An interface describing a predicate that can be evaluated on a {@link SourceEntry} (usually derived from a record).\n- *\n- * <p>\n- * {@code QueryPredicate} is generally quite similar to {@link com.apple.foundationdb.record.query.expressions.QueryComponent}.\n- * However, there is a key difference in how each interface evaluates the predicate against a given record:\n- * </p>\n- * <ul>\n- *     <li>\n- *         A {@link com.apple.foundationdb.record.query.expressions.QueryComponent} is evaluated on a\n- *         {@link com.apple.foundationdb.record.provider.foundationdb.FDBRecord} wrapping a Protobuf message.\n- *         To evaluate predicates on nested records, a {@code QueryComponent} such as\n- *         {@link com.apple.foundationdb.record.query.expressions.NestedField} or\n- *         {@link com.apple.foundationdb.record.query.expressions.OneOfThemWithComponent} will descend into the nested\n- *         record.\n- *     </li>\n- *     <li>\n- *         A {@code QueryPredicate} is evaluated on a {@link SourceEntry}, which maps\n- *         {@link com.apple.foundationdb.record.query.plan.temp.view.Source}s to values. The predicate can be evaluated\n- *         on a nested record by specifying a complex {@code Source}, such as\n- *         {@link com.apple.foundationdb.record.query.plan.temp.view.RepeatedFieldSource}. All sources are evaluated\n- *         to produce a stream of source entries before any predicates are evaluated.\n- *     </li>\n- * </ul>\n- *\n- * <p>\n- * Concretely, the difference between {@code QueryPredicate}s and {@code QueryComponent}s is most easily seen in the\n- * way that multiple predicates on repeated fields can be expressed. Any query predicate anywhere in a tree of\n- * predicates can make use of any source. In contrast, each {@link com.apple.foundationdb.record.query.expressions.OneOfThemWithComponent}\n- * is a single iteration through the field's repeated values so the values obtained by that iteration are usable only\n- * within that {@code OneOfThemWithComponent}.\n- * </p>\n+ * Class to model the concept of a predicate. A predicate is a construct that can be evaluated using\n+ * three-values logic for a set of given inputs. The caller can then use that result to take appropriate action,\n+ * e.g. filter a record out of a set of records, etc.\n  */\n @API(API.Status.EXPERIMENTAL)\n public interface QueryPredicate extends Bindable, PlanHashable, Correlated<QueryPredicate> {\n+\n+    /**\n+     * Determines if this predicate implies some other predicate.\n+     *\n+     * Let's say the the {@code EVAL(p)} denotes the outcome of the evaluation of a predicate. A predicate {@code p1}\n+     * implies some other predicate {@code p2} if\n+     *\n+     * <pre>\n+     *     {@code\n+     *     (EVAL(p1, recordBindings) == true) -> (EVAL(p2, recordBindings) == true)\n+     *     }\n+     * </pre>\n+     *\n+     * for all {@code recordBindings} possibly contained in a stream of records that are potentially being flowed at\n+     * execution time.\n+     *\n+     * If {@code p1} implies {@code p2}, this method returns an instance of class {@link PredicateMapping} which should\n+     * give the caller all necessary info to change {@code p2} to {@code COMP(p2)} in a way make the opposite also true:\n+     *\n+     * <pre>\n+     *     {@code\n+     *     (EVAL(p1, recordBindings) == true) <-> (EVAL(COMP(p2), recordBindings) == true)\n+     *     }\n+     * </pre>\n+     *\n+     * Note that this method takes special care when placeholders are involved as this method is called during index\n+     * matching with candidates graphs. A placeholder by itself cannot be executed. In order for the place holder to\n+     * match it has to partake in a relationship with a query predicate that tells the placeholder the specific comparison\n+     * and bounds it operates over. In some sends this expresses a kind of polymorphism of the placeholder that is bound\n+     * to a specific predicate only in the presence of a sargable predicate on the query side.\n+     *\n+     * Examples:\n+     *\n+     * Example 1\n+     * <pre>\n+     *     {@code\n+     *     p1: x = 5\n+     *     p2: true (tautology predicate)\n+     *\n+     *     result: optional of PredicateMapping(COMP(true) => x = 5)\n+     *     }\n+     *     {@code p1} implies {@code p2} but, i.e., {@code x = 5} implies {@code true} but in order for {@code true} to\n+     *     imply {@code x = 5}, the compensation has to be applied such that {@code COMP(p2)} becomes {@code true ^ x = 5}.\n+     * </pre>\n+     *\n+     * Example 2", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1ODk4NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565758984", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Example 3\n          \n          \n            \n                 * <h3>\n          \n          \n            \n                 * Example 3\n          \n          \n            \n                 * </h3>", "author": "alecgrieser", "createdAt": "2021-01-28T01:30:23Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/QueryPredicate.java", "diffHunk": "@@ -23,51 +23,156 @@\n import com.apple.foundationdb.annotation.API;\n import com.apple.foundationdb.record.EvaluationContext;\n import com.apple.foundationdb.record.PlanHashable;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecord;\n import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreBase;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n import com.apple.foundationdb.record.query.plan.temp.Bindable;\n import com.apple.foundationdb.record.query.plan.temp.Correlated;\n-import com.apple.foundationdb.record.query.plan.temp.view.SourceEntry;\n+import com.apple.foundationdb.record.query.plan.temp.PredicateMultiMap.PredicateMapping;\n+import com.google.common.collect.ImmutableSet;\n import com.google.protobuf.Message;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n \n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n+import java.util.Optional;\n+import java.util.Set;\n \n /**\n- * An interface describing a predicate that can be evaluated on a {@link SourceEntry} (usually derived from a record).\n- *\n- * <p>\n- * {@code QueryPredicate} is generally quite similar to {@link com.apple.foundationdb.record.query.expressions.QueryComponent}.\n- * However, there is a key difference in how each interface evaluates the predicate against a given record:\n- * </p>\n- * <ul>\n- *     <li>\n- *         A {@link com.apple.foundationdb.record.query.expressions.QueryComponent} is evaluated on a\n- *         {@link com.apple.foundationdb.record.provider.foundationdb.FDBRecord} wrapping a Protobuf message.\n- *         To evaluate predicates on nested records, a {@code QueryComponent} such as\n- *         {@link com.apple.foundationdb.record.query.expressions.NestedField} or\n- *         {@link com.apple.foundationdb.record.query.expressions.OneOfThemWithComponent} will descend into the nested\n- *         record.\n- *     </li>\n- *     <li>\n- *         A {@code QueryPredicate} is evaluated on a {@link SourceEntry}, which maps\n- *         {@link com.apple.foundationdb.record.query.plan.temp.view.Source}s to values. The predicate can be evaluated\n- *         on a nested record by specifying a complex {@code Source}, such as\n- *         {@link com.apple.foundationdb.record.query.plan.temp.view.RepeatedFieldSource}. All sources are evaluated\n- *         to produce a stream of source entries before any predicates are evaluated.\n- *     </li>\n- * </ul>\n- *\n- * <p>\n- * Concretely, the difference between {@code QueryPredicate}s and {@code QueryComponent}s is most easily seen in the\n- * way that multiple predicates on repeated fields can be expressed. Any query predicate anywhere in a tree of\n- * predicates can make use of any source. In contrast, each {@link com.apple.foundationdb.record.query.expressions.OneOfThemWithComponent}\n- * is a single iteration through the field's repeated values so the values obtained by that iteration are usable only\n- * within that {@code OneOfThemWithComponent}.\n- * </p>\n+ * Class to model the concept of a predicate. A predicate is a construct that can be evaluated using\n+ * three-values logic for a set of given inputs. The caller can then use that result to take appropriate action,\n+ * e.g. filter a record out of a set of records, etc.\n  */\n @API(API.Status.EXPERIMENTAL)\n public interface QueryPredicate extends Bindable, PlanHashable, Correlated<QueryPredicate> {\n+\n+    /**\n+     * Determines if this predicate implies some other predicate.\n+     *\n+     * Let's say the the {@code EVAL(p)} denotes the outcome of the evaluation of a predicate. A predicate {@code p1}\n+     * implies some other predicate {@code p2} if\n+     *\n+     * <pre>\n+     *     {@code\n+     *     (EVAL(p1, recordBindings) == true) -> (EVAL(p2, recordBindings) == true)\n+     *     }\n+     * </pre>\n+     *\n+     * for all {@code recordBindings} possibly contained in a stream of records that are potentially being flowed at\n+     * execution time.\n+     *\n+     * If {@code p1} implies {@code p2}, this method returns an instance of class {@link PredicateMapping} which should\n+     * give the caller all necessary info to change {@code p2} to {@code COMP(p2)} in a way make the opposite also true:\n+     *\n+     * <pre>\n+     *     {@code\n+     *     (EVAL(p1, recordBindings) == true) <-> (EVAL(COMP(p2), recordBindings) == true)\n+     *     }\n+     * </pre>\n+     *\n+     * Note that this method takes special care when placeholders are involved as this method is called during index\n+     * matching with candidates graphs. A placeholder by itself cannot be executed. In order for the place holder to\n+     * match it has to partake in a relationship with a query predicate that tells the placeholder the specific comparison\n+     * and bounds it operates over. In some sends this expresses a kind of polymorphism of the placeholder that is bound\n+     * to a specific predicate only in the presence of a sargable predicate on the query side.\n+     *\n+     * Examples:\n+     *\n+     * Example 1\n+     * <pre>\n+     *     {@code\n+     *     p1: x = 5\n+     *     p2: true (tautology predicate)\n+     *\n+     *     result: optional of PredicateMapping(COMP(true) => x = 5)\n+     *     }\n+     *     {@code p1} implies {@code p2} but, i.e., {@code x = 5} implies {@code true} but in order for {@code true} to\n+     *     imply {@code x = 5}, the compensation has to be applied such that {@code COMP(p2)} becomes {@code true ^ x = 5}.\n+     * </pre>\n+     *\n+     * Example 2\n+     * <pre>\n+     *     {@code\n+     *     p1: x = 5\n+     *     p2: x COMPARISONRANGE (placeholder)\n+     *\n+     *     result: optional of PredicateMapping(COMP(x COMPARISONRANGE) => x = 5, binding b to indicate\n+     *     COMPARISONRANGE should be [5, 5])\n+     *     }\n+     *     {@code p1} implies {@code p2} but, i.e., {@code x = 5} implies {@code x COMPARISONRANGE} but only if\n+     *     {@code COMPARISONRANGE} is bound to {@code [5, 5]} but in order for {@code x COMPARISONRANGE} to\n+     *     imply {@code x = 5}, the compensation has to be applied such that {@code COMP(p2)} becomes {@code x = 5}.\n+     * </pre>\n+     *\n+     * Example 3", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1OTEyNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565759124", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *\n          \n          \n            \n                 *\n          \n          \n            \n                 * <p>", "author": "alecgrieser", "createdAt": "2021-01-28T01:30:48Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/QueryPredicate.java", "diffHunk": "@@ -23,51 +23,156 @@\n import com.apple.foundationdb.annotation.API;\n import com.apple.foundationdb.record.EvaluationContext;\n import com.apple.foundationdb.record.PlanHashable;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecord;\n import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreBase;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n import com.apple.foundationdb.record.query.plan.temp.Bindable;\n import com.apple.foundationdb.record.query.plan.temp.Correlated;\n-import com.apple.foundationdb.record.query.plan.temp.view.SourceEntry;\n+import com.apple.foundationdb.record.query.plan.temp.PredicateMultiMap.PredicateMapping;\n+import com.google.common.collect.ImmutableSet;\n import com.google.protobuf.Message;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n \n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n+import java.util.Optional;\n+import java.util.Set;\n \n /**\n- * An interface describing a predicate that can be evaluated on a {@link SourceEntry} (usually derived from a record).\n- *\n- * <p>\n- * {@code QueryPredicate} is generally quite similar to {@link com.apple.foundationdb.record.query.expressions.QueryComponent}.\n- * However, there is a key difference in how each interface evaluates the predicate against a given record:\n- * </p>\n- * <ul>\n- *     <li>\n- *         A {@link com.apple.foundationdb.record.query.expressions.QueryComponent} is evaluated on a\n- *         {@link com.apple.foundationdb.record.provider.foundationdb.FDBRecord} wrapping a Protobuf message.\n- *         To evaluate predicates on nested records, a {@code QueryComponent} such as\n- *         {@link com.apple.foundationdb.record.query.expressions.NestedField} or\n- *         {@link com.apple.foundationdb.record.query.expressions.OneOfThemWithComponent} will descend into the nested\n- *         record.\n- *     </li>\n- *     <li>\n- *         A {@code QueryPredicate} is evaluated on a {@link SourceEntry}, which maps\n- *         {@link com.apple.foundationdb.record.query.plan.temp.view.Source}s to values. The predicate can be evaluated\n- *         on a nested record by specifying a complex {@code Source}, such as\n- *         {@link com.apple.foundationdb.record.query.plan.temp.view.RepeatedFieldSource}. All sources are evaluated\n- *         to produce a stream of source entries before any predicates are evaluated.\n- *     </li>\n- * </ul>\n- *\n- * <p>\n- * Concretely, the difference between {@code QueryPredicate}s and {@code QueryComponent}s is most easily seen in the\n- * way that multiple predicates on repeated fields can be expressed. Any query predicate anywhere in a tree of\n- * predicates can make use of any source. In contrast, each {@link com.apple.foundationdb.record.query.expressions.OneOfThemWithComponent}\n- * is a single iteration through the field's repeated values so the values obtained by that iteration are usable only\n- * within that {@code OneOfThemWithComponent}.\n- * </p>\n+ * Class to model the concept of a predicate. A predicate is a construct that can be evaluated using\n+ * three-values logic for a set of given inputs. The caller can then use that result to take appropriate action,\n+ * e.g. filter a record out of a set of records, etc.\n  */\n @API(API.Status.EXPERIMENTAL)\n public interface QueryPredicate extends Bindable, PlanHashable, Correlated<QueryPredicate> {\n+\n+    /**\n+     * Determines if this predicate implies some other predicate.\n+     *\n+     * Let's say the the {@code EVAL(p)} denotes the outcome of the evaluation of a predicate. A predicate {@code p1}\n+     * implies some other predicate {@code p2} if\n+     *\n+     * <pre>\n+     *     {@code\n+     *     (EVAL(p1, recordBindings) == true) -> (EVAL(p2, recordBindings) == true)\n+     *     }\n+     * </pre>\n+     *\n+     * for all {@code recordBindings} possibly contained in a stream of records that are potentially being flowed at\n+     * execution time.\n+     *\n+     * If {@code p1} implies {@code p2}, this method returns an instance of class {@link PredicateMapping} which should\n+     * give the caller all necessary info to change {@code p2} to {@code COMP(p2)} in a way make the opposite also true:\n+     *\n+     * <pre>\n+     *     {@code\n+     *     (EVAL(p1, recordBindings) == true) <-> (EVAL(COMP(p2), recordBindings) == true)\n+     *     }\n+     * </pre>\n+     *\n+     * Note that this method takes special care when placeholders are involved as this method is called during index\n+     * matching with candidates graphs. A placeholder by itself cannot be executed. In order for the place holder to\n+     * match it has to partake in a relationship with a query predicate that tells the placeholder the specific comparison\n+     * and bounds it operates over. In some sends this expresses a kind of polymorphism of the placeholder that is bound\n+     * to a specific predicate only in the presence of a sargable predicate on the query side.\n+     *\n+     * Examples:\n+     *\n+     * Example 1\n+     * <pre>\n+     *     {@code\n+     *     p1: x = 5\n+     *     p2: true (tautology predicate)\n+     *\n+     *     result: optional of PredicateMapping(COMP(true) => x = 5)\n+     *     }\n+     *     {@code p1} implies {@code p2} but, i.e., {@code x = 5} implies {@code true} but in order for {@code true} to\n+     *     imply {@code x = 5}, the compensation has to be applied such that {@code COMP(p2)} becomes {@code true ^ x = 5}.\n+     * </pre>\n+     *\n+     * Example 2\n+     * <pre>\n+     *     {@code\n+     *     p1: x = 5\n+     *     p2: x COMPARISONRANGE (placeholder)\n+     *\n+     *     result: optional of PredicateMapping(COMP(x COMPARISONRANGE) => x = 5, binding b to indicate\n+     *     COMPARISONRANGE should be [5, 5])\n+     *     }\n+     *     {@code p1} implies {@code p2} but, i.e., {@code x = 5} implies {@code x COMPARISONRANGE} but only if\n+     *     {@code COMPARISONRANGE} is bound to {@code [5, 5]} but in order for {@code x COMPARISONRANGE} to\n+     *     imply {@code x = 5}, the compensation has to be applied such that {@code COMP(p2)} becomes {@code x = 5}.\n+     * </pre>\n+     *\n+     * Example 3\n+     * <pre>\n+     *     {@code\n+     *     p1: x = 5\n+     *     p2: y COMPARISONRANGE (placeholder)\n+     *\n+     *     result: Optional.empty()\n+     *     }\n+     *     {@code p1} does not imply {@code p2}, i.e., {@code x = 5} does not imply {@code y COMPARISONRANGE}.\n+     * </pre>\n+     *", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1OTMwNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565759304", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *\n          \n          \n            \n                 * </p>\n          \n          \n            \n                 *", "author": "alecgrieser", "createdAt": "2021-01-28T01:31:22Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/QueryPredicate.java", "diffHunk": "@@ -23,51 +23,156 @@\n import com.apple.foundationdb.annotation.API;\n import com.apple.foundationdb.record.EvaluationContext;\n import com.apple.foundationdb.record.PlanHashable;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecord;\n import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreBase;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n import com.apple.foundationdb.record.query.plan.temp.Bindable;\n import com.apple.foundationdb.record.query.plan.temp.Correlated;\n-import com.apple.foundationdb.record.query.plan.temp.view.SourceEntry;\n+import com.apple.foundationdb.record.query.plan.temp.PredicateMultiMap.PredicateMapping;\n+import com.google.common.collect.ImmutableSet;\n import com.google.protobuf.Message;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n \n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n+import java.util.Optional;\n+import java.util.Set;\n \n /**\n- * An interface describing a predicate that can be evaluated on a {@link SourceEntry} (usually derived from a record).\n- *\n- * <p>\n- * {@code QueryPredicate} is generally quite similar to {@link com.apple.foundationdb.record.query.expressions.QueryComponent}.\n- * However, there is a key difference in how each interface evaluates the predicate against a given record:\n- * </p>\n- * <ul>\n- *     <li>\n- *         A {@link com.apple.foundationdb.record.query.expressions.QueryComponent} is evaluated on a\n- *         {@link com.apple.foundationdb.record.provider.foundationdb.FDBRecord} wrapping a Protobuf message.\n- *         To evaluate predicates on nested records, a {@code QueryComponent} such as\n- *         {@link com.apple.foundationdb.record.query.expressions.NestedField} or\n- *         {@link com.apple.foundationdb.record.query.expressions.OneOfThemWithComponent} will descend into the nested\n- *         record.\n- *     </li>\n- *     <li>\n- *         A {@code QueryPredicate} is evaluated on a {@link SourceEntry}, which maps\n- *         {@link com.apple.foundationdb.record.query.plan.temp.view.Source}s to values. The predicate can be evaluated\n- *         on a nested record by specifying a complex {@code Source}, such as\n- *         {@link com.apple.foundationdb.record.query.plan.temp.view.RepeatedFieldSource}. All sources are evaluated\n- *         to produce a stream of source entries before any predicates are evaluated.\n- *     </li>\n- * </ul>\n- *\n- * <p>\n- * Concretely, the difference between {@code QueryPredicate}s and {@code QueryComponent}s is most easily seen in the\n- * way that multiple predicates on repeated fields can be expressed. Any query predicate anywhere in a tree of\n- * predicates can make use of any source. In contrast, each {@link com.apple.foundationdb.record.query.expressions.OneOfThemWithComponent}\n- * is a single iteration through the field's repeated values so the values obtained by that iteration are usable only\n- * within that {@code OneOfThemWithComponent}.\n- * </p>\n+ * Class to model the concept of a predicate. A predicate is a construct that can be evaluated using\n+ * three-values logic for a set of given inputs. The caller can then use that result to take appropriate action,\n+ * e.g. filter a record out of a set of records, etc.\n  */\n @API(API.Status.EXPERIMENTAL)\n public interface QueryPredicate extends Bindable, PlanHashable, Correlated<QueryPredicate> {\n+\n+    /**\n+     * Determines if this predicate implies some other predicate.\n+     *\n+     * Let's say the the {@code EVAL(p)} denotes the outcome of the evaluation of a predicate. A predicate {@code p1}\n+     * implies some other predicate {@code p2} if\n+     *\n+     * <pre>\n+     *     {@code\n+     *     (EVAL(p1, recordBindings) == true) -> (EVAL(p2, recordBindings) == true)\n+     *     }\n+     * </pre>\n+     *\n+     * for all {@code recordBindings} possibly contained in a stream of records that are potentially being flowed at\n+     * execution time.\n+     *\n+     * If {@code p1} implies {@code p2}, this method returns an instance of class {@link PredicateMapping} which should\n+     * give the caller all necessary info to change {@code p2} to {@code COMP(p2)} in a way make the opposite also true:\n+     *\n+     * <pre>\n+     *     {@code\n+     *     (EVAL(p1, recordBindings) == true) <-> (EVAL(COMP(p2), recordBindings) == true)\n+     *     }\n+     * </pre>\n+     *\n+     * Note that this method takes special care when placeholders are involved as this method is called during index\n+     * matching with candidates graphs. A placeholder by itself cannot be executed. In order for the place holder to\n+     * match it has to partake in a relationship with a query predicate that tells the placeholder the specific comparison\n+     * and bounds it operates over. In some sends this expresses a kind of polymorphism of the placeholder that is bound\n+     * to a specific predicate only in the presence of a sargable predicate on the query side.\n+     *\n+     * Examples:\n+     *\n+     * Example 1\n+     * <pre>\n+     *     {@code\n+     *     p1: x = 5\n+     *     p2: true (tautology predicate)\n+     *\n+     *     result: optional of PredicateMapping(COMP(true) => x = 5)\n+     *     }\n+     *     {@code p1} implies {@code p2} but, i.e., {@code x = 5} implies {@code true} but in order for {@code true} to\n+     *     imply {@code x = 5}, the compensation has to be applied such that {@code COMP(p2)} becomes {@code true ^ x = 5}.\n+     * </pre>\n+     *\n+     * Example 2\n+     * <pre>\n+     *     {@code\n+     *     p1: x = 5\n+     *     p2: x COMPARISONRANGE (placeholder)\n+     *\n+     *     result: optional of PredicateMapping(COMP(x COMPARISONRANGE) => x = 5, binding b to indicate\n+     *     COMPARISONRANGE should be [5, 5])\n+     *     }\n+     *     {@code p1} implies {@code p2} but, i.e., {@code x = 5} implies {@code x COMPARISONRANGE} but only if\n+     *     {@code COMPARISONRANGE} is bound to {@code [5, 5]} but in order for {@code x COMPARISONRANGE} to\n+     *     imply {@code x = 5}, the compensation has to be applied such that {@code COMP(p2)} becomes {@code x = 5}.\n+     * </pre>\n+     *\n+     * Example 3\n+     * <pre>\n+     *     {@code\n+     *     p1: x = 5\n+     *     p2: y COMPARISONRANGE (placeholder)\n+     *\n+     *     result: Optional.empty()\n+     *     }\n+     *     {@code p1} does not imply {@code p2}, i.e., {@code x = 5} does not imply {@code y COMPARISONRANGE}.\n+     * </pre>\n+     *\n+     * Note: This method is expected to return a meaningful non-empty result if called with a candidate predicate that\n+     * also represents a tautology.\n+     *", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2MDI3OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565760278", "bodyText": "Is sargable a more general term used in the Biz\u2122, or is this something we're making up?", "author": "alecgrieser", "createdAt": "2021-01-28T01:34:46Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/ValueComparisonRangePredicate.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * ValueComparisonRangePredicate.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.predicates;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.annotation.SpotBugsSuppressWarnings;\n+import com.apple.foundationdb.record.EvaluationContext;\n+import com.apple.foundationdb.record.ObjectPlanHash;\n+import com.apple.foundationdb.record.PlanHashable;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecord;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreBase;\n+import com.apple.foundationdb.record.query.expressions.Comparisons;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+import com.apple.foundationdb.record.query.plan.temp.ComparisonRange;\n+import com.apple.foundationdb.record.query.plan.temp.CorrelationIdentifier;\n+import com.apple.foundationdb.record.query.plan.temp.PredicateMultiMap.PredicateMapping;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Message;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A special predicate used to represent a parameterized tuple range.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public abstract class ValueComparisonRangePredicate implements PredicateWithValue {\n+    @Nonnull\n+    private final Value value;\n+\n+    public ValueComparisonRangePredicate(@Nonnull final Value value) {\n+        this.value = value;\n+    }\n+\n+    @Override\n+    @Nonnull\n+    public Value getValue() {\n+        return value;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return value.getCorrelatedTo();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public Stream<PlannerBindings> bindTo(@Nonnull final PlannerBindings outerBindings, @Nonnull final ExpressionMatcher<? extends Bindable> matcher) {\n+        return matcher.matchWith(outerBindings, this, ImmutableList.of());\n+    }\n+\n+    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n+    @SpotBugsSuppressWarnings(\"EQ_UNUSUAL\")\n+    @Override\n+    public boolean equals(final Object other) {\n+        return semanticEquals(other, AliasMap.emptyMap());\n+    }\n+\n+    @Override\n+    public boolean semanticEquals(@Nullable final Object other, @Nonnull final AliasMap aliasMap) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (other == null || getClass() != other.getClass()) {\n+            return false;\n+        }\n+        final ValueComparisonRangePredicate that = (ValueComparisonRangePredicate)other;\n+        return value.semanticEquals(that.value, aliasMap);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return semanticHashCode();\n+    }\n+\n+    @Override\n+    public int semanticHashCode() {\n+        return Objects.hash(value.semanticHashCode());\n+    }\n+\n+    @Override\n+    public int planHash(@Nonnull final PlanHashKind hashKind) {\n+        return PlanHashable.planHash(hashKind, value);\n+    }\n+\n+    public static Placeholder placeholder(@Nonnull Value value, @Nonnull CorrelationIdentifier parameterAlias) {\n+        return new Placeholder(value, parameterAlias);\n+    }\n+\n+    public static Sargable sargable(@Nonnull Value value, @Nonnull ComparisonRange comparisonRange) {\n+        return new Sargable(value, comparisonRange);\n+    }\n+\n+    /**\n+     * A place holder predicate solely used for index matching.\n+     */\n+    public static class Placeholder extends ValueComparisonRangePredicate {\n+        private static final ObjectPlanHash BASE_HASH = new ObjectPlanHash(\"Place-Holder\");\n+\n+        private final CorrelationIdentifier parameterAlias;\n+\n+        public Placeholder(@Nonnull final Value value, @Nonnull CorrelationIdentifier parameterAlias) {\n+            super(value);\n+            this.parameterAlias = parameterAlias;\n+        }\n+\n+        public CorrelationIdentifier getParameterAlias() {\n+            return parameterAlias;\n+        }\n+\n+        @Nullable\n+        @Override\n+        public <M extends Message> Boolean eval(@Nonnull final FDBRecordStoreBase<M> store, @Nonnull final EvaluationContext context, @Nullable final FDBRecord<M> record, @Nullable final M message) {\n+            throw new RecordCoreException(\"this method should not ever be reached\");\n+        }\n+\n+        @Override\n+        @SuppressWarnings({\"ConstantConditions\", \"java:S2259\"})\n+        public boolean semanticEquals(@Nullable final Object other, @Nonnull final AliasMap aliasMap) {\n+            if (!semanticEqualsWithoutParameterAlias(other, aliasMap)) {\n+                return false;\n+            }\n+\n+            return Objects.equals(parameterAlias, ((Placeholder)other).parameterAlias);\n+        }\n+\n+        public boolean semanticEqualsWithoutParameterAlias(@Nullable final Object other, @Nonnull final AliasMap aliasMap) {\n+            return super.semanticEquals(other, aliasMap);\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public Placeholder rebase(@Nonnull final AliasMap translationMap) {\n+            return new Placeholder(getValue().rebase(translationMap), parameterAlias);\n+        }\n+\n+        @Override\n+        public int semanticHashCode() {\n+            return Objects.hash(super.semanticHashCode(), parameterAlias);\n+        }\n+\n+        @Override\n+        public int planHash(@Nonnull final PlanHashKind hashKind) {\n+            return PlanHashable.objectsPlanHash(hashKind, super.planHash(), BASE_HASH);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"(\" + getValue() + \" -> \" + parameterAlias.toString() + \")\";\n+        }\n+    }\n+\n+    /**\n+     * A query predicate that can be used as a (s)earch (arg)ument for an index scan.\n+     */\n+    public static class Sargable extends ValueComparisonRangePredicate {", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjQxNjcwNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572416705", "bodyText": "Haha -- yes!", "author": "normen662", "createdAt": "2021-02-08T22:18:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2MDI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2MTkzNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565761935", "bodyText": "The commented out lines and this print statement should probably get cleaned up before merge", "author": "alecgrieser", "createdAt": "2021-01-28T01:39:49Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/query/FDBNestedFieldQueryTest.java", "diffHunk": "@@ -204,13 +210,21 @@ public void nested() throws Exception {\n         // which should have failed validate\n         RecordQuery query = RecordQuery.newBuilder()\n                 .setRecordType(\"RestaurantRecord\")\n-                .setFilter(Query.field(\"reviews\").oneOfThem().matches(Query.field(\"rating\").greaterThan(5)))\n+                .setFilter(Query.and(\n+                        Query.field(\"name\").equalsValue(\"something\"),\n+                        Query.field(\"name\").equalsValue(\"something1\"),\n+                        Query.field(\"rest_no\").equalsValue(1L),\n+                        //Query.field(\"reviews\").oneOfThem().matches(Query.field(\"reviewer\").equalsValue(10L))))\n+                        //Query.field(\"reviews\").oneOfThem().matches(Query.field(\"rating\").equalsValue(20))))\n+                        Query.field(\"reviews\").oneOfThem().matches(Query.and(Query.field(\"reviewer\").equalsValue(10L), Query.field(\"rating\").equalsValue(20)))))\n                 .build();\n         RecordQueryPlan plan = planner.plan(query);\n+\n+        System.out.println(plan.toString());", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2MjcyOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565762729", "bodyText": "Does this differ from the plan produced by the older planner? Is it that the predicates may be reordered?", "author": "alecgrieser", "createdAt": "2021-01-28T01:42:24Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/query/FDBNestedFieldQueryTest.java", "diffHunk": "@@ -274,18 +286,24 @@ public void nestedWithAnd() throws Exception {\n                 ))\n                 .build();\n         plan = planner.plan(query);\n-        assertThat(plan, filter(Query.field(\"stats\").matches(\n-                Query.and(Query.field(\"school_name\").lessThan(\"University of Procrastination\"),\n-                        Query.field(\"hometown\").startsWith(\"H\"))),\n-                indexScan(allOf(indexName(\"stats$school\"), bounds(hasTupleString(\"([null],[1000]]\"))))));\n         if (planner instanceof RecordQueryPlanner) {\n+            assertThat(plan, filter(Query.field(\"stats\").matches(\n+                    Query.and(Query.field(\"school_name\").lessThan(\"University of Procrastination\"),\n+                            Query.field(\"hometown\").startsWith(\"H\"))),\n+                    indexScan(allOf(indexName(\"stats$school\"), bounds(hasTupleString(\"([null],[1000]]\"))))));\n+\n             assertEquals(1700959433, plan.planHash(PlanHashable.PlanHashKind.LEGACY));\n             assertEquals(1026881662, plan.planHash(PlanHashable.PlanHashKind.FOR_CONTINUATION));\n             assertEquals(129783739, plan.planHash(PlanHashable.PlanHashKind.STRUCTURAL_WITHOUT_LITERALS));\n         } else {\n-            assertEquals(-1198378902, plan.planHash(PlanHashable.PlanHashKind.LEGACY));\n-            assertEquals(-699838672, plan.planHash(PlanHashable.PlanHashKind.FOR_CONTINUATION));\n-            assertEquals(-1395185561, plan.planHash(PlanHashable.PlanHashKind.STRUCTURAL_WITHOUT_LITERALS));\n+            assertThat(plan, filter(\n+                    allOf(queryPredicateDescendant(PredicateMatchers.field(\"stats\", \"school_name\").lessThan(\"University of Procrastination\")),\n+                            queryPredicateDescendant(PredicateMatchers.field(\"stats\", \"hometown\").startsWith(\"H\"))),", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjQyMTM4Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572421386", "bodyText": "Three things can happen:\n\npredicates may get reordered\npredicates in the old planner are based on QueryComponents, in the new planner they are not.\nthere is an actual different plan getting produced. if that happens the plan the new planner produces is better as this would be a regression otherwise", "author": "normen662", "createdAt": "2021-02-08T22:26:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2MjcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2MzE2Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565763163", "bodyText": "How does the new planner do on this kind of query?", "author": "alecgrieser", "createdAt": "2021-01-28T01:43:53Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/query/FDBOrQueryToUnionTest.java", "diffHunk": "@@ -541,62 +530,6 @@ public void testOrQuery5(boolean removesDuplicates) throws Exception {\n         }\n     }\n \n-    /**\n-     * Setup a query with a match candidate.\n-     */\n-    @Disabled(\"match infrastructure not ready yet\")\n-    @Test\n-    public void testMatch1() throws Exception {\n-        // Debugger.setDebugger(new PlannerRepl());\n-        // Debugger.setup();\n-\n-        RecordMetaDataHook hook = complexQuerySetupHook();\n-        complexQuerySetup(hook);\n-        final CascadesPlanner cascadesPlanner = new CascadesPlanner(recordStore.getRecordMetaData(), recordStore.getRecordStoreState());\n-        RecordQuery query = RecordQuery.newBuilder()\n-                .setRecordType(\"MySimpleRecord\")\n-                .setFilter(Query.or(\n-                        Query.field(\"str_value_indexed\").lessThan(\"m\"),\n-                        Query.field(\"num_value_3_indexed\").greaterThan(3)))", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjQyMjMxNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572422315", "bodyText": "There is a transformation that transforms this into a union and then the children are matched separately.", "author": "normen662", "createdAt": "2021-02-08T22:28:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2MzE2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2NDA3NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565764074", "bodyText": "Is the query to key matcher not used any more? I thought it was still being used in the old planner for some grouping-related things", "author": "alecgrieser", "createdAt": "2021-01-28T01:46:25Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/query/QueryToKeyMatcherTest.java", "diffHunk": "@@ -1,718 +0,0 @@\n-/*\n- * QueryToKeyMatcherTest.java\n- *\n- * This source file is part of the FoundationDB open source project\n- *\n- * Copyright 2015-2018 Apple Inc. and the FoundationDB project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.apple.foundationdb.record.query;\n-\n-import com.apple.foundationdb.record.ObjectPlanHash;\n-import com.apple.foundationdb.record.PlanHashable;\n-import com.apple.foundationdb.record.metadata.Key;\n-import com.apple.foundationdb.record.metadata.UnknownKeyExpression;\n-import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n-import com.apple.foundationdb.record.metadata.expressions.FunctionKeyExpression;\n-import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n-import com.apple.foundationdb.record.metadata.expressions.KeyExpression.FanType;\n-import com.apple.foundationdb.record.metadata.expressions.QueryableKeyExpression;\n-import com.apple.foundationdb.record.provider.foundationdb.FDBRecord;\n-import com.apple.foundationdb.record.query.expressions.Field;\n-import com.apple.foundationdb.record.query.expressions.Query;\n-import com.apple.foundationdb.record.query.expressions.QueryComponent;\n-import com.apple.foundationdb.record.query.expressions.RecordTypeKeyComparison;\n-import com.apple.foundationdb.record.query.plan.temp.view.Element;\n-import com.apple.foundationdb.record.query.plan.temp.view.Source;\n-import com.google.auto.service.AutoService;\n-import com.google.protobuf.Message;\n-import org.junit.jupiter.api.Test;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static com.apple.foundationdb.record.metadata.Key.Expressions.concat;\n-import static com.apple.foundationdb.record.metadata.Key.Expressions.concatenateFields;\n-import static com.apple.foundationdb.record.metadata.Key.Expressions.function;\n-import static com.apple.foundationdb.record.metadata.Key.Expressions.keyWithValue;\n-import static com.apple.foundationdb.record.metadata.Key.Expressions.recordType;\n-import static com.apple.foundationdb.record.metadata.Key.Expressions.value;\n-import static com.apple.foundationdb.record.query.QueryToKeyMatcher.Match;\n-import static com.apple.foundationdb.record.query.QueryToKeyMatcher.MatchType;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n-\n-/**\n- * Tests for {@link QueryToKeyMatcher}.\n- */\n-public class QueryToKeyMatcherTest {", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzA5MDgwNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r567090807", "bodyText": "Oooopsie, I think I removed this class when I removed the sources code. Looks like the scalpel acted a little bit more like a battle axe. Restored the file and it still passes.", "author": "normen662", "createdAt": "2021-01-29T21:00:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2NDA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2NDg4OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565764889", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // we lazy convert the given component to a predicate and let semantic equals establish equality\n          \n          \n            \n                        // we lazily convert the given component to a predicate and let semantic equals establish equality", "author": "alecgrieser", "createdAt": "2021-01-28T01:48:38Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/query/plan/match/FilterMatcherWithComponent.java", "diffHunk": "@@ -39,30 +47,49 @@\n  * {@link com.apple.foundationdb.record.query.plan.RecordQueryPlanner} (which produces {@link RecordQueryFilterPlan}s)\n  * and the {@link com.apple.foundationdb.record.query.plan.temp.CascadesPlanner} (which produces\n  * {@link RecordQueryPredicateFilterPlan}).\n- *\n- * <p>\n- * Note that this matcher must store a {@link QueryComponent} rather than a {@link QueryPredicate} or\n- * {@code Matcher<QueryComponent>} because it must be able to convert it to an equivalent {@code QueryPredicate} using\n- * the {@link QueryComponent#normalizeForPlanner(Source, java.util.List)} method.\n- * </p>\n  */\n public class FilterMatcherWithComponent extends PlanMatcherWithChild {\n     @Nonnull\n     private final QueryComponent component;\n \n+    @Nonnull\n+    private final CorrelationIdentifier baseAlias;\n+\n+    @Nonnull\n+    private final Supplier<QueryPredicate> componentAsPredicateSupplier;\n+\n     public FilterMatcherWithComponent(@Nonnull QueryComponent component, @Nonnull Matcher<RecordQueryPlan> childMatcher) {\n         super(childMatcher);\n         this.component = component;\n+        this.baseAlias = CorrelationIdentifier.randomID();\n+        this.componentAsPredicateSupplier = Suppliers.memoize(() -> {\n+            final ExpandedPredicates expandedPredicates =\n+                    component.expandForPlanner(baseAlias);\n+            Verify.verify(expandedPredicates.getQuantifiers().isEmpty());\n+            return expandedPredicates.asAndPredicate();\n+        });\n     }\n \n     @Override\n     public boolean matchesSafely(@Nonnull RecordQueryPlan plan) {\n         if (plan instanceof RecordQueryFilterPlan) {\n             return component.equals(((RecordQueryFilterPlan)plan).getFilter()) && super.matchesSafely(plan);\n         } else if (plan instanceof RecordQueryPredicateFilterPlan) {\n-            QueryPredicate predicate = ((RecordQueryPredicateFilterPlan)plan).getPredicate();\n-            return predicate.equals(component.normalizeForPlanner(((RecordQueryPredicateFilterPlan)plan).getBaseSource()))\n-                    && super.matchesSafely(plan);\n+            // todo make more robust as this will currently only work with the simplest of all cases\n+\n+            // we lazy convert the given component to a predicate and let semantic equals establish equality", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2NTg2Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565765867", "bodyText": "I wonder if there's a way to test this without restarting to printing by doing something like taking each combination and putting it into a set, and then validating that the set has the right elements (which is fairly easy to compute for this example).", "author": "alecgrieser", "createdAt": "2021-01-28T01:51:31Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/query/plan/temp/ChooseKTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * AliasMapTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.temp.matching.ComputingMatcher;\n+import com.google.common.collect.ImmutableSet;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Set;\n+\n+/**\n+ * Testcase class for {@link ComputingMatcher}.\n+ */\n+public class ChooseKTest {\n+    @Test\n+    void testChooseK1() {\n+        final Set<String> elements = ImmutableSet.of(\"a\", \"b\", \"c\", \"d\");\n+\n+        final EnumeratingIterable<String> combinations = ChooseK.chooseK(elements, 3);\n+        combinations.forEach(System.out::println);", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzQ5NzAzMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r567497033", "bodyText": "Yeah -- it's just I never got to actually polish this file and it slipped through. Corrected in the next commit.", "author": "normen662", "createdAt": "2021-01-31T22:48:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2NTg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2NjI3NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565766275", "bodyText": "Is the repetition of \"c\" and \"d\" intentional?", "author": "alecgrieser", "createdAt": "2021-01-28T01:52:52Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/query/plan/temp/ChooseKTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * AliasMapTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.temp.matching.ComputingMatcher;\n+import com.google.common.collect.ImmutableSet;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Set;\n+\n+/**\n+ * Testcase class for {@link ComputingMatcher}.\n+ */\n+public class ChooseKTest {\n+    @Test\n+    void testChooseK1() {\n+        final Set<String> elements = ImmutableSet.of(\"a\", \"b\", \"c\", \"d\");\n+\n+        final EnumeratingIterable<String> combinations = ChooseK.chooseK(elements, 3);\n+        combinations.forEach(System.out::println);\n+\n+        //        for (EnumeratingIterator<String> iterator = combinations.iterator(); iterator.hasNext(); ) {\n+        //            final List<String> combination = iterator.next();\n+        //            System.out.println(combination);\n+        //            if (combination.get(0).equals(\"b\")) {\n+        //                iterator.skip(0);\n+        //            }\n+        //        }\n+    }\n+    \n+    @Test\n+    void testChooseK2() {\n+        final Set<String> elements = ImmutableSet.of(\"a\", \"b\", \"c\", \"d\", \"c\", \"d\", \"e\");", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzQ5NzA3MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r567497071", "bodyText": "No -- fixed.", "author": "normen662", "createdAt": "2021-01-31T22:49:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2NjI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2Njc2NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565766765", "bodyText": "For this, I suspect you could do something like collect the combinations from the iterator, and then validate that (1) the combinations produced are unique and (2) that there are 5Ck of them for each k.", "author": "alecgrieser", "createdAt": "2021-01-28T01:54:25Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/query/plan/temp/ChooseKTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * AliasMapTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.temp.matching.ComputingMatcher;\n+import com.google.common.collect.ImmutableSet;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Set;\n+\n+/**\n+ * Testcase class for {@link ComputingMatcher}.\n+ */\n+public class ChooseKTest {\n+    @Test\n+    void testChooseK1() {\n+        final Set<String> elements = ImmutableSet.of(\"a\", \"b\", \"c\", \"d\");\n+\n+        final EnumeratingIterable<String> combinations = ChooseK.chooseK(elements, 3);\n+        combinations.forEach(System.out::println);\n+\n+        //        for (EnumeratingIterator<String> iterator = combinations.iterator(); iterator.hasNext(); ) {\n+        //            final List<String> combination = iterator.next();\n+        //            System.out.println(combination);\n+        //            if (combination.get(0).equals(\"b\")) {\n+        //                iterator.skip(0);\n+        //            }\n+        //        }\n+    }\n+    \n+    @Test\n+    void testChooseK2() {\n+        final Set<String> elements = ImmutableSet.of(\"a\", \"b\", \"c\", \"d\", \"c\", \"d\", \"e\");\n+\n+        for (int k = 0; k < elements.size() + 1; k ++) {\n+            System.out.println(\"=== \" + elements.size() + \" choose \" + k + \" ======================\");\n+            final EnumeratingIterable<String> combinations = ChooseK.chooseK(elements, k);\n+\n+            combinations.forEach(System.out::println);\n+            System.out.println(\"=========================\");", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2NzA3Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565767072", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * AliasMapTest.java\n          \n          \n            \n             * ComputingMatcherTest.java", "author": "alecgrieser", "createdAt": "2021-01-28T01:55:21Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/query/plan/temp/ComputingMatcherTest.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * AliasMapTest.java", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2NzcxMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565767712", "bodyText": "Presumably there's a different assert that could be added instead of the print statements?", "author": "alecgrieser", "createdAt": "2021-01-28T01:57:14Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/query/plan/temp/ComputingMatcherTest.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * AliasMapTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.temp.matching.BoundMatch;\n+import com.apple.foundationdb.record.query.plan.temp.matching.ComputingMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matching.GenericMatcher;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import static com.apple.foundationdb.record.query.plan.temp.CorrelationIdentifier.of;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+/**\n+ * Testcase class for {@link com.apple.foundationdb.record.query.plan.temp.matching.ComputingMatcher}.\n+ */\n+public class ComputingMatcherTest {\n+    @Test\n+    void testMatchNoCorrelations1() {\n+        final Set<CorrelationIdentifier> left = ImmutableSet.of(of(\"l1\"), of(\"l2\"), of(\"l3\"), of(\"ll4\"), of(\"ll5\"), of(\"ll6\"), of(\"ll7\"));\n+        final Set<CorrelationIdentifier> right = ImmutableSet.of(of(\"r1\"), of(\"r2\"), of(\"r3\"), of(\"rr4\"), of(\"rr5\"), of(\"rr6\"), of(\"rr7\"));\n+\n+        final GenericMatcher<BoundMatch<EnumeratingIterable<String>>> matcher =\n+                ComputingMatcher.onAliasDependencies(\n+                        AliasMap.emptyMap(),\n+                        left,\n+                        l -> l,\n+                        l -> ImmutableSet.of(),\n+                        right,\n+                        r -> r,\n+                        r -> ImmutableSet.of(),\n+                        (l, r, aliasMap) -> {\n+                            if (l.toString().substring(1).equals(r.toString().substring(1))) {\n+                                return ImmutableList.of(l + \" + \" + r);\n+                            }\n+                            return ImmutableList.of();\n+                        },\n+                        ComputingMatcher::productAccumulator);\n+\n+        final Iterable<BoundMatch<EnumeratingIterable<String>>> matches = matcher.match();\n+\n+\n+        matches.forEach(boundMatch -> System.out.println(boundMatch.getAliasMap()));\n+\n+        System.out.println(\"================\");", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc3MjA3Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565772072", "bodyText": "Really this wants to somehow check PlannableIndexTypes.getValueTypes, to allow for extended value types.\nThis method ought to do like https://github.com/FoundationDB/fdb-record-layer/blob/master/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java#L440-L442 and take just the key part of key-with-value, which isn't really a key expression, but does appear in the root expression.", "author": "MMcM", "createdAt": "2021-01-28T02:11:05Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/metadata/Index.java", "diffHunk": "@@ -431,6 +433,32 @@ public void trimPrimaryKey(List<?> primaryKeys) {\n         }\n     }\n \n+\n+    /**\n+     * Compute the full key of an index (given that the index is a value index).\n+     *\n+     * @param primaryKey primary key of the records the index ranges over. The primary key is used to determine\n+     *        parts in the index definition that already contain parts of the primary key. All primary key components\n+     *        that are not already part of the index key are appended to the index key.\n+     * @return a {@link KeyExpression} describing the <em>full</em> index key as stored\n+     * TODO the implementation is currently restricted to only work on value indexes. We need to make this generally\n+     * TODO applicable to all index types in appropriate ways.\n+     */\n+    @Nonnull\n+    public KeyExpression fullKey(@Nullable final KeyExpression primaryKey) {\n+        Preconditions.checkArgument(getType().equals(IndexTypes.VALUE));", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcwMTYwNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571701607", "bodyText": "This is now handled in the key expression expansion visitors.", "author": "normen662", "createdAt": "2021-02-07T21:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc3MjA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTU5ODYzMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565598633", "bodyText": "You should be cautious about relying on this too generally, since not all indexes (e.g., aggregate indexes) actually contain part of the primary key. I think that is okay, but it is worth being cautious.", "author": "nschiefer", "createdAt": "2021-01-27T20:05:37Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/metadata/Index.java", "diffHunk": "@@ -431,6 +433,32 @@ public void trimPrimaryKey(List<?> primaryKeys) {\n         }\n     }\n \n+\n+    /**\n+     * Compute the full key of an index (given that the index is a value index).\n+     *\n+     * @param primaryKey primary key of the records the index ranges over. The primary key is used to determine\n+     *        parts in the index definition that already contain parts of the primary key. All primary key components\n+     *        that are not already part of the index key are appended to the index key.\n+     * @return a {@link KeyExpression} describing the <em>full</em> index key as stored\n+     * TODO the implementation is currently restricted to only work on value indexes. We need to make this generally", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcwMTIzMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571701232", "bodyText": "This is only ever going to be called for values indexes. I am moving this method into the expansion visitor that is dependent on the type of index.", "author": "normen662", "createdAt": "2021-02-07T21:16:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTU5ODYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYwMDEzMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565600130", "bodyText": "The other part of this which makes me nervous is the use of KeyExpression.normalizeKeyForPositions(), which collapses the canonical edge cases of nested KeyExpressions:\n\nconcat(field(\"a\").nest(\"b\"), field(\"a\").nest(\"c\")) and\nfield(\"a\").nest(concat(field(\"b\"), field(\"c\")).\n\nThis is like an edge case of an edge case, since I think nested repeated primary keys are exceptionally rare (and possibly banned?).", "author": "nschiefer", "createdAt": "2021-01-27T20:08:09Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/metadata/Index.java", "diffHunk": "@@ -431,6 +433,32 @@ public void trimPrimaryKey(List<?> primaryKeys) {\n         }\n     }\n \n+\n+    /**\n+     * Compute the full key of an index (given that the index is a value index).\n+     *\n+     * @param primaryKey primary key of the records the index ranges over. The primary key is used to determine\n+     *        parts in the index definition that already contain parts of the primary key. All primary key components\n+     *        that are not already part of the index key are appended to the index key.\n+     * @return a {@link KeyExpression} describing the <em>full</em> index key as stored\n+     * TODO the implementation is currently restricted to only work on value indexes. We need to make this generally\n+     * TODO applicable to all index types in appropriate ways.\n+     */\n+    @Nonnull\n+    public KeyExpression fullKey(@Nullable final KeyExpression primaryKey) {\n+        Preconditions.checkArgument(getType().equals(IndexTypes.VALUE));\n+\n+        if (primaryKey == null) {\n+            return getRootExpression();\n+        }\n+        final ArrayList<KeyExpression> trimmedPrimaryKeyComponents = new ArrayList<>(primaryKey.normalizeKeyForPositions());", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjMyNTY4MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r566325681", "bodyText": "Primary keys are required to produce only one result, so repeated (and thus nested) repeated primary keys would be banned unless you use FanType.Concatenate. I'm...not actually sure what would happen if you had a nested repeated with a concatenated parent \ud83d\ude2c", "author": "alecgrieser", "createdAt": "2021-01-28T18:43:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYwMDEzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcwMTc5NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571701794", "bodyText": "Yes -- undefined bad things would happen if the primary key cause key.createsFuplicates() == true", "author": "normen662", "createdAt": "2021-02-07T21:20:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYwMDEzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYwMDU5Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565600596", "bodyText": "I assume this is just a placeholder for now, right? Or is there something fundamental that makes it impossible for this to work with collations?", "author": "nschiefer", "createdAt": "2021-01-27T20:08:59Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/metadata/expressions/CollateFunctionKeyExpression.java", "diffHunk": "@@ -179,8 +179,9 @@ public int getColumnSize() {\n \n     @Nonnull\n     @Override\n-    public Element toElement(@Nonnull Source rootSource) {\n-        return normalizeForPlanner(rootSource, Collections.emptyList()).flattenForPlanner().get(0);\n+    public Value toValue(@Nonnull final CorrelationIdentifier baseAlias,\n+                         @Nonnull final List<String> fieldNamePrefix) {\n+        throw new UnsupportedOperationException();", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcwMTg5Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571701896", "bodyText": "Just for now -- adding a TODO", "author": "normen662", "createdAt": "2021-02-07T21:20:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYwMDU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYwMjMxMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565602310", "bodyText": "I don't believe that this is correct as implemented, but it doesn't matter (yet) because we never handle indexes with GroupingKeyExpressions. Does that sound right?\nAs originally envisioned, the difference between the normalizeForPlanner() and flattenForPlanner() functions was that the former produced a KeyExpression that pushed correlations to the leaves of the KeyExpression tree while preserving the non-correlated structure of the KeyExpression (such as groupings). That way, RelationalExpression.fromIndexDefinition() could interpret the structure of the KeyExpression in context of the index type. Then, flattenForPlanner() could finish removing that information.\nIs there a general plan for do something similar? If that's the case, it might be better to change this to throw an UnsupportedOperationException or similar, so that this thought doesn't get lost in the future.", "author": "nschiefer", "createdAt": "2021-01-27T20:12:12Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/metadata/expressions/GroupingKeyExpression.java", "diffHunk": "@@ -115,8 +117,10 @@ public int getColumnSize() {\n \n     @Nonnull\n     @Override\n-    public KeyExpression normalizeForPlanner(@Nonnull Source source, @Nonnull List<String> fieldNamePrefix) {\n-        return new GroupingKeyExpression(wholeKey.normalizeForPlanner(source, fieldNamePrefix), groupedCount);\n+    public ExpandedPredicates expandForPlanner(@Nonnull final CorrelationIdentifier baseAlias,\n+                                               @Nonnull final Supplier<CorrelationIdentifier> parameterAliasSupplier,\n+                                               @Nonnull final List<String> fieldNamePrefix) {\n+        return wholeKey.expandForPlanner(baseAlias, parameterAliasSupplier, fieldNamePrefix);", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcwMjI5Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571702296", "bodyText": "For now, this expression will cause an exception to be thrown.", "author": "normen662", "createdAt": "2021-02-07T21:24:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYwMjMxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY3NTk3MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565675970", "bodyText": "I figured out why this is object equality (rather than .equals()), but I think it is worth mentioning on a comment so that this doesn't get \"refactored\" to the wrong thing.", "author": "nschiefer", "createdAt": "2021-01-27T22:17:08Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/GroupExpressionRef.java", "diffHunk": "@@ -354,15 +354,25 @@ public int semanticHashCode() {\n         return partialMatchMap.keySet();\n     }\n \n+    @Nonnull\n+    @Override\n+    public Collection<PartialMatch> getPartialMatchesForExpression(@Nonnull final RelationalExpression expression) {\n+        return partialMatchMap.values()\n+                .stream()\n+                .filter(partialMatch ->\n+                        partialMatch.getQueryExpression() == expression)", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY4MDc3OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565680779", "bodyText": "\ud83e\udd14", "author": "nschiefer", "createdAt": "2021-01-27T22:26:42Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/debug/RestartException.java", "diffHunk": "@@ -21,7 +21,7 @@\n package com.apple.foundationdb.record.query.plan.temp.debug;\n \n /**\n- * Tag-exception that is specifically thrown by implementations of {@link Debugger} to signal the planner to restart\n+ * Tag-exception tha is specifically thrown by implementations of {@link Debugger} to signal the planner to restart", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY4Nzg2MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565687860", "bodyText": "Can it ever be the case that a single CascadesRuleCall produces both new expression and new partial matches, or are these disjoint cases?\nI think the latter is true but I am far from confident. In any case, I think this is a sufficiently important point that it should be explained.", "author": "nschiefer", "createdAt": "2021-01-27T22:40:37Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/CascadesPlanner.java", "diffHunk": "@@ -372,225 +409,357 @@ public String toString() {\n         }\n     }\n \n-    private class Transform implements Task {\n+    /**\n+     * Abstract base class for all tasks that have a <em>current</em> (group, expression).\n+     */\n+    private abstract class ExploreTask implements Task {\n         @Nonnull\n         private final PlanContext context;\n         @Nonnull\n         private final GroupExpressionRef<RelationalExpression> group;\n         @Nonnull\n         private final RelationalExpression expression;\n-        @Nonnull\n-        private final PlannerRule<? extends RelationalExpression> rule;\n \n-        public Transform(@Nonnull PlanContext context,\n-                         @Nonnull GroupExpressionRef<RelationalExpression> group,\n-                         @Nonnull RelationalExpression expression,\n-                         @Nonnull PlannerRule<? extends RelationalExpression> rule) {\n+        public ExploreTask(@Nonnull PlanContext context,\n+                           @Nonnull GroupExpressionRef<RelationalExpression> group,\n+                           @Nonnull RelationalExpression expression) {\n             this.context = context;\n             this.group = group;\n             this.expression = expression;\n-            this.rule = rule;\n+        }\n+\n+        @Nonnull\n+        public PlanContext getContext() {\n+            return context;\n+        }\n+\n+        @Nonnull\n+        public GroupExpressionRef<RelationalExpression> getGroup() {\n+            return group;\n+        }\n+\n+        @Nonnull\n+        public RelationalExpression getExpression() {\n+            return expression;\n+        }\n+\n+        @Nonnull\n+        protected PlannerRuleSet getRules() {\n+            return ruleSet;\n+        }\n+    }\n+\n+    /**\n+     * Explore Expression Task.\n+     *\n+     * Simplified enqueue/execute overview:\n+     *\n+     * {@link ExploreExpression}\n+     *     enqueues\n+     *         all transformations ({@link TransformMatchPartition}) for match partitions of current (group, expression)\n+     *         all transformations ({@link TransformExpression} for current (group, expression)\n+     *         {@link ExploreGroup} for all ranged over groups\n+     */\n+    private class ExploreExpression extends ExploreTask {\n+        public ExploreExpression(@Nonnull PlanContext context,\n+                                 @Nonnull GroupExpressionRef<RelationalExpression> group,\n+                                 @Nonnull RelationalExpression expression) {\n+            super(context, group, expression);\n         }\n \n         @Override\n         public void execute() {\n-            if (!group.containsExactly(expression)) { // expression is gone\n-                return;\n-            }\n-            if (logger.isTraceEnabled()) {\n-                logger.trace(\"Bindings: \" +  expression.bindTo(rule.getMatcher()).count());\n-            }\n-            expression.bindTo(rule.getMatcher()).map(bindings -> new CascadesRuleCall(context, rule, group, bindings))\n-                    .forEach(ruleCall -> {\n-                        Debugger.withDebugger(debugger -> debugger.onEvent(new Debugger.TransformRuleCallEvent(currentRoot, taskStack, Location.BEGIN, group, expression, rule, ruleCall)));\n-                        executeRuleCall(ruleCall);\n-                        Debugger.withDebugger(debugger -> debugger.onEvent(new Debugger.TransformRuleCallEvent(currentRoot, taskStack, Location.END, group, expression, rule, ruleCall)));\n-                    });\n+            // Enqueue all rules that need to run after all exploration for a (group, expression) pair is done.\n+            ruleSet.getMatchPartitionRules().forEach(this::enqueueTransformPartialMatch);\n+\n+            // This is closely tied to the way that rule finding works _now_. Specifically, rules are indexed only\n+            // by the type of their _root_, not any of the stuff lower down. As a result, we have enough information\n+            // right here to determine the set of all possible rules that could ever be applied here, regardless of\n+            // what happens towards the leaves of the tree.\n+            ruleSet.getExpressionRules(getExpression()).forEach(this::enqueueTransformTask);\n+\n+            // Enqueue explore group for all groups this expression ranges over\n+            getExpression()\n+                    .getQuantifiers()\n+                    .stream()\n+                    .map(Quantifier::getRangesOver)\n+                    .forEach(this::enqueueExploreGroup);\n         }\n \n-        private void executeRuleCall(@Nonnull CascadesRuleCall ruleCall) {\n-            ruleCall.run();\n-            for (RelationalExpression newExpression : ruleCall.getNewExpressions()) {\n-                if (newExpression instanceof QueryPlan) {\n-                    taskStack.push(new OptimizeInputs(context, group, newExpression));\n-                    taskStack.push(new ExploreExpression(context, group, newExpression));\n-                } else {\n-                    taskStack.push(new ExploreExpression(context, group, newExpression));\n-                }\n-            }\n+        private void enqueueTransformTask(@Nonnull PlannerRule<? extends RelationalExpression> rule) {\n+            taskStack.push(new TransformExpression(getContext(), getGroup(), getExpression(), rule));\n+        }\n+\n+        private void enqueueTransformPartialMatch(PlannerRule<? extends MatchPartition> rule) {\n+            taskStack.push(new TransformMatchPartition(getContext(), getGroup(), getExpression(), rule));\n+        }\n+\n+        private void enqueueExploreGroup(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            taskStack.push(new ExploreGroup(getContext(), rangesOver));\n         }\n \n         @Override\n         public Debugger.Event toTaskEvent(final Location location) {\n-            return new Debugger.TransformEvent(currentRoot, taskStack, location, group, expression, rule);\n+            return new Debugger.ExploreExpressionEvent(currentRoot, taskStack, location, getGroup(), getExpression());\n         }\n \n         @Override\n         public String toString() {\n-            return \"Transform(\" + rule.getClass().getSimpleName() + \")\";\n+            return \"ExploreExpression(\" + getGroup() + \")\";\n         }\n     }\n \n-    private class MatchExpression implements Task {\n+    /**\n+     * Abstract base class for all transformations. All transformations are defined on a sub class of {@link Bindable}.\n+     * This base class uses just {@link Bindable} itself as it never has to reason or pass on the actual defined type\n+     * of the transform rule.\n+     */\n+    private abstract class AbstractTransform implements Task {\n         @Nonnull\n         private final PlanContext context;\n         @Nonnull\n         private final GroupExpressionRef<RelationalExpression> group;\n         @Nonnull\n         private final RelationalExpression expression;\n+        @Nonnull\n+        private final PlannerRule<? extends Bindable> rule;\n \n-        public MatchExpression(@Nonnull final PlanContext context, @Nonnull final GroupExpressionRef<RelationalExpression> group, @Nonnull final RelationalExpression expression) {\n+        protected AbstractTransform(@Nonnull PlanContext context,\n+                                    @Nonnull GroupExpressionRef<RelationalExpression> group,\n+                                    @Nonnull RelationalExpression expression,\n+                                    @Nonnull PlannerRule<? extends Bindable> rule) {\n             this.context = context;\n             this.group = group;\n             this.expression = expression;\n+            this.rule = rule;\n+        }\n+\n+        @Nonnull\n+        public PlanContext getContext() {\n+            return context;\n+        }\n+\n+        @Nonnull\n+        public GroupExpressionRef<RelationalExpression> getGroup() {\n+            return group;\n+        }\n+\n+        @Nonnull\n+        public RelationalExpression getExpression() {\n+            return expression;\n+        }\n+\n+        @Nonnull\n+        public PlannerRule<? extends Bindable> getRule() {\n+            return rule;\n         }\n \n+        @Nonnull\n+        protected abstract Bindable getBindable();\n+\n+        @Nonnull\n+        protected PlannerBindings getInitialBindings() {\n+            return PlannerBindings.empty();\n+        }\n+\n+        protected boolean shouldExecute() {\n+            return true;\n+        }\n+\n+        /**\n+         * Method that calls the actual rule and reacts to new constructs the rule yielded.\n+         *\n+         * Simplified enqueue/execute overview:\n+         *\n+         * executes rule\n+         * enqueues\n+         *     {@link AdjustMatch} for each yielded {@link PartialMatch}\n+         *     {@link OptimizeInputs} followed by {@link ExploreExpression} for each yielded {@link RecordQueryPlan}\n+         *     {@link ExploreExpression} for each yielded {@link RelationalExpression} that is not a {@link RecordQueryPlan}\n+         */\n         @Override\n         public void execute() {\n-            final ImmutableList<? extends ExpressionRef<? extends RelationalExpression>> rangesOverRefs =\n-                    expression.getQuantifiers()\n-                            .stream()\n-                            .map(Quantifier::getRangesOver)\n-                            .collect(ImmutableList.toImmutableList());\n-\n-            if (rangesOverRefs.isEmpty()) {\n-                for (final MatchCandidate matchCandidate : context.getMatchCandidates()) {\n-                    final ExpressionRefTraversal traversal = matchCandidate.getTraversal();\n-                    final Set<ExpressionRef<? extends RelationalExpression>> leafRefs = traversal.getLeafRefs();\n-                    for (final ExpressionRef<? extends RelationalExpression> leafRef : leafRefs) {\n-                        for (final RelationalExpression leafMember : leafRef.getMembers()) {\n-                            if (leafMember.getQuantifiers().isEmpty()) {\n-                                taskStack.push(new MatchExpressionWithCandidate(context,\n-                                        group,\n-                                        expression,\n-                                        matchCandidate,\n-                                        leafRef,\n-                                        leafMember));\n-                            }\n-                        }\n-                    }\n-                }\n-            } else {\n-                // form intersection of all possible match candidates\n-                final ExpressionRef<? extends RelationalExpression> firstRangesOverRef = rangesOverRefs.get(0);\n-                final Set<MatchCandidate> commonMatchCandidates = Sets.newHashSet(firstRangesOverRef.getMatchCandidates());\n-                for (int i = 0; i < rangesOverRefs.size(); i++) {\n-                    final ExpressionRef<? extends RelationalExpression> rangesOverGroup = rangesOverRefs.get(i);\n-                    commonMatchCandidates.retainAll(rangesOverGroup.getMatchCandidates());\n-                }\n+            final GroupExpressionRef<RelationalExpression> group = getGroup();\n+            final PlannerRule<? extends Bindable> rule = getRule();\n+            if (!shouldExecute()) {\n+                return;\n+            }\n \n-                for (final MatchCandidate matchCandidate : commonMatchCandidates) {\n-                    final ExpressionRefTraversal traversal = matchCandidate.getTraversal();\n-                    for (final ExpressionRef<? extends RelationalExpression> rangesOverRef : rangesOverRefs) {\n-                        final Set<PartialMatch> partialMatchesForCandidate = rangesOverRef.getPartialMatchesForCandidate(matchCandidate);\n-                        for (final PartialMatch partialMatch : partialMatchesForCandidate) {\n-                            for (final ExpressionRefTraversal.RefPath parentRefPath : traversal.getParentRefPaths(partialMatch.getCandidateRef())) {\n-                                taskStack.push(new MatchExpressionWithCandidate(context,\n-                                        group,\n-                                        expression,\n-                                        matchCandidate,\n-                                        parentRefPath.getRef(),\n-                                        parentRefPath.getExpression()));\n-                            }\n-                        }\n-                    }\n+            final PlannerBindings initialBindings = getInitialBindings();\n+\n+            if (logger.isTraceEnabled()) {\n+                logger.trace(\"Bindings: \" +  getBindable().bindTo(initialBindings, rule.getMatcher()).count());\n+            }\n+\n+            getBindable().bindTo(initialBindings, rule.getMatcher())\n+                    .map(bindings -> new CascadesRuleCall(getContext(), rule, group, aliasResolver, bindings))\n+                    .forEach(ruleCall -> {\n+                        // we notify the debugger (if installed) that the transform task is succeeding and\n+                        // about begin and end of the rule call event\n+                        Debugger.withDebugger(debugger -> debugger.onEvent(toTaskEvent(Location.SUCCESS)));\n+                        Debugger.withDebugger(debugger -> debugger.onEvent(new Debugger.TransformRuleCallEvent(currentRoot, taskStack, Location.BEGIN, group, getBindable(), rule, ruleCall)));\n+                        executeRuleCall(ruleCall);\n+                        Debugger.withDebugger(debugger -> debugger.onEvent(new Debugger.TransformRuleCallEvent(currentRoot, taskStack, Location.END, group, getBindable(), rule, ruleCall)));\n+                    });\n+        }\n+\n+        protected void executeRuleCall(@Nonnull CascadesRuleCall ruleCall) {\n+            ruleCall.run();\n+            for (final PartialMatch newPartialMatch : ruleCall.getNewPartialMatches()) {\n+                taskStack.push(new AdjustMatch(getContext(), getGroup(), getExpression(), newPartialMatch));\n+            }\n+\n+            for (final RelationalExpression newExpression : ruleCall.getNewExpressions()) {", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcyMzg1MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571723851", "bodyText": "When we talked about I think we agreed on making this approach (while desirable) more type safe as there really currently is no case I can think of for a rule to do both.", "author": "normen662", "createdAt": "2021-02-08T00:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY4Nzg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcyNTA0MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571725041", "bodyText": "Opened #1123 to address this issue.", "author": "normen662", "createdAt": "2021-02-08T00:20:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY4Nzg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcwMzA2Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565703063", "bodyText": "Probably want actual tests here rather than just code that prints out the results?", "author": "nschiefer", "createdAt": "2021-01-27T23:13:40Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/query/plan/temp/ChooseKTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * AliasMapTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.temp.matching.ComputingMatcher;\n+import com.google.common.collect.ImmutableSet;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Set;\n+\n+/**\n+ * Testcase class for {@link ComputingMatcher}.\n+ */\n+public class ChooseKTest {\n+    @Test\n+    void testChooseK1() {", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzQ5NzExNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r567497115", "bodyText": "That code here never got polished. Sorry! :-(", "author": "normen662", "createdAt": "2021-01-31T22:49:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcwMzA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcxODczNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565718736", "bodyText": "This replacement for baseSource is fantastic! It makes so much sense!", "author": "nschiefer", "createdAt": "2021-01-27T23:44:03Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryPredicateFilterPlan.java", "diffHunk": "@@ -82,17 +75,9 @@ protected boolean hasAsyncFilter() {\n         if (record == null) {\n             return null;\n         }\n-        Boolean result = null;\n-        Iterator<SourceEntry> entries = baseSource.evalSourceEntriesFor(record.getRecord()).iterator();\n-        while (entries.hasNext()) {\n-            Boolean entryResult = filter.eval(store, context, entries.next());\n-            if (entryResult != null && entryResult) {\n-                return true;\n-            } else if (result == null) {\n-                result = entryResult;\n-            }\n-        }\n-        return result;\n+\n+        final EvaluationContext nestedContext = context.withBinding(getInner().getAlias(), record.getRecord());", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcxOTQ0Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565719443", "bodyText": "I eventually figured this out (you need more context in the recursion before rolling things up), but I think the need for this class over QueryPredicate is tricky enough that it's worth writing down in some detail here.", "author": "nschiefer", "createdAt": "2021-01-27T23:45:51Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpandedPredicates.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * ExpandedPredicates.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.temp.expressions.SelectExpression;\n+import com.apple.foundationdb.record.query.predicates.AndPredicate;\n+import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n+import com.apple.foundationdb.record.query.predicates.ValueComparisonRangePredicate.Placeholder;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Lists;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+/**\n+ * Class to abstract behavior when query expansion is applied to query components or key expressions.", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTczMDIyMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571730222", "bodyText": "done.", "author": "normen662", "createdAt": "2021-02-08T00:56:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcxOTQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1Nzk0NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565757945", "bodyText": "I think I see how this rule works out, but it would be a lot better if the type of innerMatcher was ExpressionMatcher<ExpressionRef<RecordQueryPlan>> instead of ExpressionMatcher<ExpressionRef<? extends RelationalExpression>>.\nIs there any way to ensure that the child of a physical quantifier if RecordQueryPlan? Or does that create some problem that I'm not seeing?", "author": "nschiefer", "createdAt": "2021-01-28T01:27:33Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/PushDistinctFilterBelowFilterRule.java", "diffHunk": "@@ -83,9 +84,10 @@ public PushDistinctFilterBelowFilterRule() {\n         super(root);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     @Override\n     public void onMatch(@Nonnull PlannerRuleCall call) {\n-        final ExpressionRef<RecordQueryPlan> inner = call.get(innerMatcher);\n+        final ExpressionRef<RecordQueryPlan> inner = (ExpressionRef<RecordQueryPlan>)call.get(innerMatcher);", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjMyMzI4Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572323282", "bodyText": "Please check the new implementation. It uses generics to ensure that if you use a type matcher to filter all the contained expressions you get a reference of the narrowed type rather than the widened type.", "author": "normen662", "createdAt": "2021-02-08T19:47:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1Nzk0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1ODE2MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565758160", "bodyText": "Same comment here as on PushDistinctFilterBelowFilterRule.", "author": "nschiefer", "createdAt": "2021-01-28T01:28:00Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/PushTypeFilterBelowFilterRule.java", "diffHunk": "@@ -91,12 +92,12 @@ public PushTypeFilterBelowFilterRule() {\n         super(root);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     @Override\n     public void onMatch(@Nonnull PlannerRuleCall call) {\n-        final ExpressionRef<RecordQueryPlan> inner = call.get(innerMatcher);\n+        final ExpressionRef<RecordQueryPlan> inner = (ExpressionRef<RecordQueryPlan>)call.get(innerMatcher);", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjMzOTQxOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572339418", "bodyText": "now strongly typed by generics", "author": "normen662", "createdAt": "2021-02-08T20:13:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc1ODE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2MDEzNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565760136", "bodyText": "I'm not sure that withParameterAlias() really gets at the core of what this represents. Would something like withParameterAliasComparison() or something else that suggests parallelism with withComparison() work better?", "author": "nschiefer", "createdAt": "2021-01-28T01:34:11Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/Value.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Value.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.predicates;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.EvaluationContext;\n+import com.apple.foundationdb.record.PlanHashable;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecord;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreBase;\n+import com.apple.foundationdb.record.query.expressions.Comparisons;\n+import com.apple.foundationdb.record.query.plan.temp.Correlated;\n+import com.apple.foundationdb.record.query.plan.temp.CorrelationIdentifier;\n+import com.apple.foundationdb.record.query.predicates.ValueComparisonRangePredicate.Placeholder;\n+import com.google.protobuf.Message;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A scalar value type.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public interface Value extends Correlated<Value>, PlanHashable {\n+\n+    @Nullable\n+    <M extends Message> Object eval(@Nonnull final FDBRecordStoreBase<M> store, @Nonnull final EvaluationContext context, @Nullable FDBRecord<M> record, @Nullable M message);\n+\n+    @Nonnull\n+    default ValuePredicate withComparison(@Nonnull Comparisons.Comparison comparison) {\n+        return new ValuePredicate(this, comparison);\n+    }\n+\n+    @Nonnull\n+    default Placeholder withParameterAlias(@Nonnull final CorrelationIdentifier parameterAlias) {", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjM2ODYxNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572368616", "bodyText": "I don't have a strong opinion about this, but in a ton of other cases withXXX() just indicates that the methods derives a new identical instance where the XXX is replaced by whatever is handed in.\nI am beefing up the java docs for these two though.", "author": "normen662", "createdAt": "2021-02-08T21:01:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2MDEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2MDQ0NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565760445", "bodyText": "Is there a reason to try to evaluate this at all, rather than just throwing an exception?", "author": "nschiefer", "createdAt": "2021-01-28T01:35:22Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/ValueComparisonRangePredicate.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * ValueComparisonRangePredicate.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.predicates;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.annotation.SpotBugsSuppressWarnings;\n+import com.apple.foundationdb.record.EvaluationContext;\n+import com.apple.foundationdb.record.ObjectPlanHash;\n+import com.apple.foundationdb.record.PlanHashable;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecord;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreBase;\n+import com.apple.foundationdb.record.query.expressions.Comparisons;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+import com.apple.foundationdb.record.query.plan.temp.ComparisonRange;\n+import com.apple.foundationdb.record.query.plan.temp.CorrelationIdentifier;\n+import com.apple.foundationdb.record.query.plan.temp.PredicateMultiMap.PredicateMapping;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Message;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A special predicate used to represent a parameterized tuple range.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public abstract class ValueComparisonRangePredicate implements PredicateWithValue {\n+    @Nonnull\n+    private final Value value;\n+\n+    public ValueComparisonRangePredicate(@Nonnull final Value value) {\n+        this.value = value;\n+    }\n+\n+    @Override\n+    @Nonnull\n+    public Value getValue() {\n+        return value;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return value.getCorrelatedTo();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public Stream<PlannerBindings> bindTo(@Nonnull final PlannerBindings outerBindings, @Nonnull final ExpressionMatcher<? extends Bindable> matcher) {\n+        return matcher.matchWith(outerBindings, this, ImmutableList.of());\n+    }\n+\n+    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n+    @SpotBugsSuppressWarnings(\"EQ_UNUSUAL\")\n+    @Override\n+    public boolean equals(final Object other) {\n+        return semanticEquals(other, AliasMap.emptyMap());\n+    }\n+\n+    @Override\n+    public boolean semanticEquals(@Nullable final Object other, @Nonnull final AliasMap aliasMap) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (other == null || getClass() != other.getClass()) {\n+            return false;\n+        }\n+        final ValueComparisonRangePredicate that = (ValueComparisonRangePredicate)other;\n+        return value.semanticEquals(that.value, aliasMap);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return semanticHashCode();\n+    }\n+\n+    @Override\n+    public int semanticHashCode() {\n+        return Objects.hash(value.semanticHashCode());\n+    }\n+\n+    @Override\n+    public int planHash(@Nonnull final PlanHashKind hashKind) {\n+        return PlanHashable.planHash(hashKind, value);\n+    }\n+\n+    public static Placeholder placeholder(@Nonnull Value value, @Nonnull CorrelationIdentifier parameterAlias) {\n+        return new Placeholder(value, parameterAlias);\n+    }\n+\n+    public static Sargable sargable(@Nonnull Value value, @Nonnull ComparisonRange comparisonRange) {\n+        return new Sargable(value, comparisonRange);\n+    }\n+\n+    /**\n+     * A place holder predicate solely used for index matching.\n+     */\n+    public static class Placeholder extends ValueComparisonRangePredicate {\n+        private static final ObjectPlanHash BASE_HASH = new ObjectPlanHash(\"Place-Holder\");\n+\n+        private final CorrelationIdentifier parameterAlias;\n+\n+        public Placeholder(@Nonnull final Value value, @Nonnull CorrelationIdentifier parameterAlias) {\n+            super(value);\n+            this.parameterAlias = parameterAlias;\n+        }\n+\n+        public CorrelationIdentifier getParameterAlias() {\n+            return parameterAlias;\n+        }\n+\n+        @Nullable\n+        @Override\n+        public <M extends Message> Boolean eval(@Nonnull final FDBRecordStoreBase<M> store, @Nonnull final EvaluationContext context, @Nullable final FDBRecord<M> record, @Nullable final M message) {\n+            throw new RecordCoreException(\"this method should not ever be reached\");\n+        }\n+\n+        @Override\n+        @SuppressWarnings({\"ConstantConditions\", \"java:S2259\"})\n+        public boolean semanticEquals(@Nullable final Object other, @Nonnull final AliasMap aliasMap) {\n+            if (!semanticEqualsWithoutParameterAlias(other, aliasMap)) {\n+                return false;\n+            }\n+\n+            return Objects.equals(parameterAlias, ((Placeholder)other).parameterAlias);\n+        }\n+\n+        public boolean semanticEqualsWithoutParameterAlias(@Nullable final Object other, @Nonnull final AliasMap aliasMap) {\n+            return super.semanticEquals(other, aliasMap);\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public Placeholder rebase(@Nonnull final AliasMap translationMap) {\n+            return new Placeholder(getValue().rebase(translationMap), parameterAlias);\n+        }\n+\n+        @Override\n+        public int semanticHashCode() {\n+            return Objects.hash(super.semanticHashCode(), parameterAlias);\n+        }\n+\n+        @Override\n+        public int planHash(@Nonnull final PlanHashKind hashKind) {\n+            return PlanHashable.objectsPlanHash(hashKind, super.planHash(), BASE_HASH);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"(\" + getValue() + \" -> \" + parameterAlias.toString() + \")\";\n+        }\n+    }\n+\n+    /**\n+     * A query predicate that can be used as a (s)earch (arg)ument for an index scan.\n+     */\n+    public static class Sargable extends ValueComparisonRangePredicate {\n+        private static final ObjectPlanHash BASE_HASH = new ObjectPlanHash(\"Sargable-Predicate\");\n+\n+        @Nonnull\n+        private final ComparisonRange comparisonRange;\n+\n+        public Sargable(@Nonnull final Value value, @Nonnull final ComparisonRange comparisonRange) {\n+            super(value);\n+            this.comparisonRange = comparisonRange;\n+        }\n+\n+        @Nonnull\n+        public ComparisonRange getComparisonRange() {\n+            return comparisonRange;\n+        }\n+\n+        @Nullable\n+        @Override\n+        public <M extends Message> Boolean eval(@Nonnull final FDBRecordStoreBase<M> store, @Nonnull final EvaluationContext context, @Nullable final FDBRecord<M> record, @Nullable final M message) {\n+            // this could just throw an exception as we shouldn't support evaluating this kind of predicate\n+            // as it is for index matching purposes only", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjQxNzU2Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572417562", "bodyText": "channged to throwing an exception", "author": "normen662", "createdAt": "2021-02-08T22:19:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2MDQ0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2MDc5Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565760796", "bodyText": "I think that we probably want to clean this up before merging.", "author": "nschiefer", "createdAt": "2021-01-28T01:36:29Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/query/FDBNestedFieldQueryTest.java", "diffHunk": "@@ -204,13 +210,21 @@ public void nested() throws Exception {\n         // which should have failed validate\n         RecordQuery query = RecordQuery.newBuilder()\n                 .setRecordType(\"RestaurantRecord\")\n-                .setFilter(Query.field(\"reviews\").oneOfThem().matches(Query.field(\"rating\").greaterThan(5)))\n+                .setFilter(Query.and(\n+                        Query.field(\"name\").equalsValue(\"something\"),\n+                        Query.field(\"name\").equalsValue(\"something1\"),\n+                        Query.field(\"rest_no\").equalsValue(1L),\n+                        //Query.field(\"reviews\").oneOfThem().matches(Query.field(\"reviewer\").equalsValue(10L))))\n+                        //Query.field(\"reviews\").oneOfThem().matches(Query.field(\"rating\").equalsValue(20))))\n+                        Query.field(\"reviews\").oneOfThem().matches(Query.and(Query.field(\"reviewer\").equalsValue(10L), Query.field(\"rating\").equalsValue(20)))))\n                 .build();\n         RecordQueryPlan plan = planner.plan(query);\n+\n+        System.out.println(plan.toString());", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjQxOTc2NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572419764", "bodyText": "Agreed -- sorry for this mess!", "author": "normen662", "createdAt": "2021-02-08T22:23:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2MDc5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2MDkyMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565760922", "bodyText": "Why is this block of code commented out? At the very least we should indicate what's going on here.", "author": "nschiefer", "createdAt": "2021-01-28T01:36:51Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/query/FDBNestedFieldQueryTest.java", "diffHunk": "@@ -204,13 +210,21 @@ public void nested() throws Exception {\n         // which should have failed validate\n         RecordQuery query = RecordQuery.newBuilder()\n                 .setRecordType(\"RestaurantRecord\")\n-                .setFilter(Query.field(\"reviews\").oneOfThem().matches(Query.field(\"rating\").greaterThan(5)))\n+                .setFilter(Query.and(\n+                        Query.field(\"name\").equalsValue(\"something\"),\n+                        Query.field(\"name\").equalsValue(\"something1\"),\n+                        Query.field(\"rest_no\").equalsValue(1L),\n+                        //Query.field(\"reviews\").oneOfThem().matches(Query.field(\"reviewer\").equalsValue(10L))))\n+                        //Query.field(\"reviews\").oneOfThem().matches(Query.field(\"rating\").equalsValue(20))))\n+                        Query.field(\"reviews\").oneOfThem().matches(Query.and(Query.field(\"reviewer\").equalsValue(10L), Query.field(\"rating\").equalsValue(20)))))\n                 .build();\n         RecordQueryPlan plan = planner.plan(query);\n+\n+        System.out.println(plan.toString());\n+\n+        /*\n         assertThat(plan, primaryKeyDistinct(indexScan(allOf(indexName(\"review_rating\"), bounds(hasTupleString(\"([5],>\"))))));", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2Nzg0NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565767845", "bodyText": "It would be good to specify which traversal object this is.", "author": "nschiefer", "createdAt": "2021-01-28T01:57:39Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/IndexScanMatchCandidate.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * MatchCandidate.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.IndexScanType;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.IndexScanExpression;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+\n+/**\n+ * Case class to represent a match candidate that is backed by an index.\n+ */\n+public class IndexScanMatchCandidate implements MatchCandidate {\n+    /**\n+     * Name of the match candidate. If this candidate represents and index, it will be the name of the index.\n+     */\n+    @Nonnull\n+    private final String name;\n+\n+    /**\n+     * Holds the parameter names for all necessary parameters that need to be bound during matching.\n+     */\n+    @Nonnull\n+    private final List<CorrelationIdentifier> parameters;\n+\n+    /**\n+     * Traversal object.", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzA4Mzg3Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r567083877", "bodyText": "Yup, done.", "author": "normen662", "createdAt": "2021-01-29T20:45:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc2Nzg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc3MDU1Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565770556", "bodyText": "Perhaps fromIndexDefinition() and fromPrimaryDefinition() belong on MatchCandidate rather than RelationalExpression now that they don't produce RelationalExpressions?", "author": "nschiefer", "createdAt": "2021-01-28T02:06:30Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -96,47 +105,140 @@\n public interface RelationalExpression extends Bindable, Correlated<RelationalExpression> {\n     @Nonnull\n     static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull PlanContext context) {\n-\n         Quantifier.ForEach quantifier = Quantifier.forEach(GroupExpressionRef.of(new FullUnorderedScanExpression(context.getMetaData().getRecordTypes().keySet())));\n-        final ViewExpression.Builder builder = ViewExpression.builder();\n-        for (String recordType : context.getRecordTypes()) {\n-            builder.addRecordType(recordType);\n-        }\n-        final Source baseSource = builder.buildBaseSource();\n-        if (query.getSort() != null) {\n-            List<Element> normalizedSort = query.getSort()\n-                    .normalizeForPlanner(baseSource, Collections.emptyList())\n-                    .flattenForPlanner();\n-            quantifier = Quantifier.forEach(GroupExpressionRef.of(new LogicalSortExpression(Collections.emptyList(), normalizedSort, query.isSortReverse(), quantifier)));\n+\n+        if (!context.getRecordTypes().isEmpty()) {\n+            quantifier = Quantifier.forEach(GroupExpressionRef.of(new LogicalTypeFilterExpression(new HashSet<>(context.getRecordTypes()), quantifier)));\n         }\n \n+        final SelectExpression selectExpression;\n         if (query.getFilter() != null) {\n-            final QueryPredicate normalized = query.getFilter().normalizeForPlanner(baseSource);\n-            quantifier = Quantifier.forEach(GroupExpressionRef.of(new LogicalFilterExpression(baseSource, normalized, quantifier)));\n+            selectExpression =\n+                    query.getFilter()\n+                            .expandForPlanner(quantifier.getAlias())\n+                            .buildSelectWithBase(quantifier);\n+        } else {\n+            selectExpression =\n+                    ExpandedPredicates.empty()\n+                            .buildSelectWithBase(quantifier);\n         }\n+        quantifier = Quantifier.forEach(GroupExpressionRef.of(selectExpression));\n \n-        if (!query.getRecordTypes().isEmpty()) {\n-            quantifier = Quantifier.forEach(GroupExpressionRef.of(new LogicalTypeFilterExpression(new HashSet<>(query.getRecordTypes()), quantifier)));\n-        }\n         if (query.removesDuplicates()) {\n             quantifier = Quantifier.forEach(GroupExpressionRef.of(new LogicalDistinctExpression(quantifier)));\n         }\n-        return Iterables.getOnlyElement(quantifier.getRangesOver().getMembers());\n+\n+        if (query.getSort() != null) {\n+            quantifier = Quantifier.forEach(GroupExpressionRef.of(new LogicalSortExpression(query.getSort(), query.isSortReverse(), quantifier)));\n+        }\n+\n+        return quantifier.getRangesOver().get();\n+    }\n+\n+    @Nonnull\n+    static Optional<MatchCandidate> fromIndexDefinition(@Nonnull final RecordMetaData metaData,", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTczNDQzOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571734438", "bodyText": "Good suggestion. Done.", "author": "normen662", "createdAt": "2021-02-08T01:21:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc3MDU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc3MTUwOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565771509", "bodyText": "I think that I'm still a bit unclear on what this function means after ~20 hours of looking at this code, so I think that means it needs a Javadoc. \ud83d\ude43", "author": "nschiefer", "createdAt": "2021-01-28T02:09:17Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -532,6 +671,67 @@ default AliasMap bindIdentities(@Nonnull final RelationalExpression otherExpress\n         return AliasMap.identitiesFor(commonUnbound);\n     }\n \n+    @Nonnull\n+    default Iterable<MatchInfo> subsumedBy(@Nonnull final RelationalExpression otherExpression,", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTc0MDQyMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571740420", "bodyText": "done", "author": "normen662", "createdAt": "2021-02-08T01:52:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc3MTUwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc3MTUzOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565771539", "bodyText": "Same here.", "author": "nschiefer", "createdAt": "2021-01-28T02:09:26Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -532,6 +671,67 @@ default AliasMap bindIdentities(@Nonnull final RelationalExpression otherExpress\n         return AliasMap.identitiesFor(commonUnbound);\n     }\n \n+    @Nonnull\n+    default Iterable<MatchInfo> subsumedBy(@Nonnull final RelationalExpression otherExpression,\n+                                           @Nonnull final AliasMap aliasMap,\n+                                           @Nonnull final IdentityBiMap<Quantifier, PartialMatch> partialMatchMap) {\n+        // we don't match by default -- end\n+        return ImmutableList.of();\n+    }\n+\n+    @Nonnull\n+    default Iterable<MatchInfo> exactlySubsumedBy(@Nonnull final RelationalExpression otherExpression,", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTc0MDQ4Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571740482", "bodyText": "done", "author": "normen662", "createdAt": "2021-02-08T01:52:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc3MTUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc3NDMxMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565774313", "bodyText": "What is withPrefix doing here? I stared at it for a while and I'm not sure I understand, so it is probably worth adding a comment.", "author": "nschiefer", "createdAt": "2021-01-28T02:18:14Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/expressions/OneOfThemWithComparison.java", "diffHunk": "@@ -97,15 +101,24 @@ public QueryComponent withOtherComparison(Comparisons.Comparison comparison) {\n         return new OneOfThemWithComparison(getFieldName(), comparison);\n     }\n \n-    @Nonnull\n     @Override\n-    public QueryPredicate normalizeForPlanner(@Nonnull Source source, @Nonnull List<String> fieldNamePrefix) {\n+    public ExpandedPredicates expandForPlanner(@Nonnull final CorrelationIdentifier baseAlias, @Nonnull final List<String> fieldNamePrefix) {\n         List<String> fieldNames = ImmutableList.<String>builder()\n                 .addAll(fieldNamePrefix)\n                 .add(getFieldName())\n                 .build();\n-        final RepeatedFieldSource repeatedSource = new RepeatedFieldSource(source, fieldNames);\n-        return new ElementPredicate(new ValueElement(repeatedSource), comparison);\n+        final Quantifier childBase = Quantifier.forEach(GroupExpressionRef.of(new ExplodeExpression(baseAlias, fieldNames)));\n+        final SelectExpression selectExpression = ExpandedPredicates.ofPredicate(new ValuePredicate(\n+                new ObjectValue(childBase.getAlias()), comparison)).buildSelectWithBase(childBase);\n+        final Quantifier.Existential childQuantifier = Quantifier.existential(GroupExpressionRef.of(selectExpression));\n+\n+        QueryComponent withPrefix = this;", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcxNTg3Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571715877", "bodyText": "done", "author": "normen662", "createdAt": "2021-02-07T23:11:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc3NDMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc3NDM4MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565774380", "bodyText": "Same here.", "author": "nschiefer", "createdAt": "2021-01-28T02:18:25Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/expressions/OneOfThemWithComponent.java", "diffHunk": "@@ -96,15 +100,26 @@ public QueryComponent getChild() {\n         return child;\n     }\n \n-    @Nonnull\n     @Override\n-    public QueryPredicate normalizeForPlanner(@Nonnull Source source, @Nonnull List<String> fieldNamePrefix) {\n+    public ExpandedPredicates expandForPlanner(@Nonnull final CorrelationIdentifier baseAlias, @Nonnull final List<String> fieldNamePrefix) {\n         List<String> fieldNames = ImmutableList.<String>builder()\n                 .addAll(fieldNamePrefix)\n                 .add(getFieldName())\n                 .build();\n-        final RepeatedFieldSource repeatedSource = new RepeatedFieldSource(source, fieldNames);\n-        return child.normalizeForPlanner(repeatedSource, Collections.emptyList()); // reset field name prefix since we just added a source\n+        final Quantifier.ForEach childBase = Quantifier.forEach(GroupExpressionRef.of(new ExplodeExpression(baseAlias, fieldNames)));\n+        final SelectExpression selectExpression =\n+                getChild().expandForPlanner(childBase.getAlias(), Collections.emptyList())\n+                        .buildSelectWithBase(childBase);\n+\n+        Quantifier.Existential childQuantifier = Quantifier.existential(GroupExpressionRef.of(selectExpression));\n+\n+        QueryComponent withPrefix = this;", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcxNTk0OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571715949", "bodyText": "done", "author": "normen662", "createdAt": "2021-02-07T23:11:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc3NDM4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc3NzYyMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565777622", "bodyText": "I think it would be clearer if this were named RequireSortRule rather than ImplementSortRule since it acts more like a requirement filter than an \"implementation\" rule.", "author": "nschiefer", "createdAt": "2021-01-28T02:28:15Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/ImplementSortRule.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * ImplementDistinctRule.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.rules;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.KeyPart;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRule;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRuleCall;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.LogicalSortExpression;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.AnyChildrenMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.QuantifierMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.TypeMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.properties.OrderingProperty;\n+import com.apple.foundationdb.record.query.plan.temp.properties.OrderingProperty.OrderingInfo;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * A rule that implements a sort expression by removing this expression if appropriate.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public class ImplementSortRule extends PlannerRule<LogicalSortExpression> {", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjI2MjQwMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572262403", "bodyText": "called it RemoveSortRule", "author": "normen662", "createdAt": "2021-02-08T18:12:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc3NzYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc3ODc3NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565778774", "bodyText": "Is this used for something other than backwards compatibility? In either case, I think it would be good to add some commentary on why one would want a QueryPredicate that refers to a QueryComponent, since it doesn't seem obvious.", "author": "nschiefer", "createdAt": "2021-01-28T02:31:43Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/QueryComponentPredicate.java", "diffHunk": "@@ -44,54 +44,49 @@\n import java.util.stream.Stream;\n \n /**\n- * A {@link QueryPredicate} that evaluates a {@link Comparisons.Comparison} on the value of an {@link Element}.\n+ * A {@link QueryPredicate} that is satisfied when its child component is satisfied.", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjM0ODA2Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572348062", "bodyText": "Added comments.", "author": "normen662", "createdAt": "2021-02-08T20:27:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc3ODc3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc3OTA0NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565779044", "bodyText": "Does this work for every QueryComponent, or only if the QueryComponent is somehow completely uncorrelated?", "author": "nschiefer", "createdAt": "2021-01-28T02:32:31Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/QueryComponentPredicate.java", "diffHunk": "@@ -140,14 +134,15 @@ public int planHash(@Nonnull final PlanHashKind hashKind) {\n     @Nonnull\n     @Override\n     public Set<CorrelationIdentifier> getCorrelatedTo() {\n-        // TODO needs to return a correlation identifier synthesized from the element\n-        return ImmutableSet.of();\n+        return correlation == null ? ImmutableSet.of() : ImmutableSet.of(correlation);\n     }\n \n     @Nonnull\n     @Override\n-    public ElementPredicate rebase(@Nonnull final AliasMap translationMap) {\n-        // TODO needs to create a new element to refer to the translated correlation identifier\n-        return new ElementPredicate(getElement(), getComparison());\n+    public QueryComponentPredicate rebase(@Nonnull final AliasMap translationMap) {\n+        if (correlation != null && translationMap.containsSource(correlation)) {\n+            return new QueryComponentPredicate(getQueryComponent(), translationMap.getTargetOrThrow(correlation));", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc3OTY1Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565779652", "bodyText": "Why is this class deleted? I believe that the QueryToKeyMatcher is part of the RecordQueryPlanner, and so I feel like we should keep its tests around?", "author": "nschiefer", "createdAt": "2021-01-28T02:34:34Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/query/QueryToKeyMatcherTest.java", "diffHunk": "@@ -1,718 +0,0 @@\n-/*\n- * QueryToKeyMatcherTest.java\n- *\n- * This source file is part of the FoundationDB open source project\n- *\n- * Copyright 2015-2018 Apple Inc. and the FoundationDB project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.apple.foundationdb.record.query;\n-\n-import com.apple.foundationdb.record.ObjectPlanHash;\n-import com.apple.foundationdb.record.PlanHashable;\n-import com.apple.foundationdb.record.metadata.Key;\n-import com.apple.foundationdb.record.metadata.UnknownKeyExpression;\n-import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n-import com.apple.foundationdb.record.metadata.expressions.FunctionKeyExpression;\n-import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n-import com.apple.foundationdb.record.metadata.expressions.KeyExpression.FanType;\n-import com.apple.foundationdb.record.metadata.expressions.QueryableKeyExpression;\n-import com.apple.foundationdb.record.provider.foundationdb.FDBRecord;\n-import com.apple.foundationdb.record.query.expressions.Field;\n-import com.apple.foundationdb.record.query.expressions.Query;\n-import com.apple.foundationdb.record.query.expressions.QueryComponent;\n-import com.apple.foundationdb.record.query.expressions.RecordTypeKeyComparison;\n-import com.apple.foundationdb.record.query.plan.temp.view.Element;\n-import com.apple.foundationdb.record.query.plan.temp.view.Source;\n-import com.google.auto.service.AutoService;\n-import com.google.protobuf.Message;\n-import org.junit.jupiter.api.Test;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static com.apple.foundationdb.record.metadata.Key.Expressions.concat;\n-import static com.apple.foundationdb.record.metadata.Key.Expressions.concatenateFields;\n-import static com.apple.foundationdb.record.metadata.Key.Expressions.function;\n-import static com.apple.foundationdb.record.metadata.Key.Expressions.keyWithValue;\n-import static com.apple.foundationdb.record.metadata.Key.Expressions.recordType;\n-import static com.apple.foundationdb.record.metadata.Key.Expressions.value;\n-import static com.apple.foundationdb.record.query.QueryToKeyMatcher.Match;\n-import static com.apple.foundationdb.record.query.QueryToKeyMatcher.MatchType;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n-\n-/**\n- * Tests for {@link QueryToKeyMatcher}.\n- */\n-public class QueryToKeyMatcherTest {", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzA5MTA0Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r567091046", "bodyText": "Oooopsie, I think I removed this class when I removed the sources code. Looks like the scalpel acted a little bit more like a battle axe. Restored the file and it still passes.", "author": "normen662", "createdAt": "2021-01-29T21:00:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc3OTY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc4MDEzMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565780133", "bodyText": "As a defense against misuse, I think we should verify that normalizedKeyExpression does not produce duplicates (i.e., is not hiding a correlation).", "author": "nschiefer", "createdAt": "2021-01-28T02:35:57Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/KeyPart.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * BoundKeyPart.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+\n+/**\n+ * A key expression that can be bound by a comparison.\n+ */\n+public class KeyPart {\n+    @Nonnull\n+    private final KeyExpression normalizedKeyExpression;\n+\n+    @Nonnull\n+    private final ComparisonRange.Type comparisonRangeType;\n+\n+    protected KeyPart(@Nonnull final KeyExpression normalizedKeyExpression,\n+                      @Nonnull final ComparisonRange.Type comparisonRangeType) {\n+        this.normalizedKeyExpression = normalizedKeyExpression;", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTczMTU2NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571731565", "bodyText": "I think I cannot do that as I don't think there is a guard against misuse in the setSort API call.", "author": "normen662", "createdAt": "2021-02-08T01:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc4MDEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc4MDQ5NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565780495", "bodyText": "I don't think I properly understand the difference between the queryPredicate and candidatePredicate. Perhaps a comment would clarify that?", "author": "nschiefer", "createdAt": "2021-01-28T02:37:05Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/BoundKeyPart.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * BoundKeyPart.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n+import com.apple.foundationdb.record.query.predicates.ValueComparisonRangePredicate;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Optional;\n+\n+/**\n+ * A key expression that can be bound by a comparison.\n+ */\n+public class BoundKeyPart extends KeyPart {\n+    @Nullable\n+    private final QueryPredicate queryPredicate;\n+\n+    @Nullable\n+    private final QueryPredicate candidatePredicate;\n+\n+    private BoundKeyPart(@Nonnull final KeyExpression normalizedKeyExpression,\n+                         @Nonnull final ComparisonRange.Type comparisonRangeType,\n+                         @Nullable final QueryPredicate queryPredicate,\n+                         @Nullable final QueryPredicate candidatePredicate) {\n+        super(normalizedKeyExpression, comparisonRangeType);\n+        this.queryPredicate = queryPredicate;\n+        this.candidatePredicate = candidatePredicate;", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcxOTkyNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571719924", "bodyText": "done", "author": "normen662", "createdAt": "2021-02-07T23:42:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc4MDQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc4MTY0Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565781647", "bodyText": "I don't understand what an alternativeComponent is.", "author": "nschiefer", "createdAt": "2021-01-28T02:40:18Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/ExistsPredicate.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * ExistsPredicate.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.predicates;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.annotation.SpotBugsSuppressWarnings;\n+import com.apple.foundationdb.record.EvaluationContext;\n+import com.apple.foundationdb.record.ObjectPlanHash;\n+import com.apple.foundationdb.record.PlanHashable;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecord;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreBase;\n+import com.apple.foundationdb.record.query.expressions.QueryComponent;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+import com.apple.foundationdb.record.query.plan.temp.ComparisonRange;\n+import com.apple.foundationdb.record.query.plan.temp.Compensation;\n+import com.apple.foundationdb.record.query.plan.temp.CorrelationIdentifier;\n+import com.apple.foundationdb.record.query.plan.temp.MatchInfo;\n+import com.apple.foundationdb.record.query.plan.temp.PartialMatch;\n+import com.apple.foundationdb.record.query.plan.temp.PredicateMultiMap.PredicateMapping;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Message;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+/**\n+ * An existential predicate that is true if the inner correlation produces any values, and false otherwise.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public class ExistsPredicate implements QueryPredicate {\n+    private static final ObjectPlanHash BASE_HASH = new ObjectPlanHash(\"Exists-Predicate\");\n+    @Nonnull\n+    private final CorrelationIdentifier existentialAlias;\n+\n+    @Nonnull\n+    private final QueryComponent alternativeComponent;", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjM0MzMwMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572343303", "bodyText": "This is a shim for now. We do not have a runtime for this predicate or the graph that is below this exists(). This alternative component is used if we need to apply compensation.", "author": "normen662", "createdAt": "2021-02-08T20:18:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc4MTY0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc4MjQ5NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565782495", "bodyText": "Does this also apply to primary scans, now that they are not unified with index scans as they were in IndexEntrySourceScanExpression? If so, I think the comment needs to be updated.", "author": "nschiefer", "createdAt": "2021-01-28T02:43:19Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/properties/UnmatchedFieldsProperty.java", "diffHunk": "@@ -41,7 +41,7 @@\n  * such as {@link com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression} and\n  * {@link com.apple.foundationdb.record.metadata.expressions.RecordTypeKeyExpression}) that are not matched with at\n  * least one {@link com.apple.foundationdb.record.query.expressions.Comparisons.Comparison} in a planner expression\n- * tree. This is computed over all {@link KeyExpression}s in various {@link IndexEntrySourceScanExpression}s.\n+ * tree. This is computed over all {@link KeyExpression}s in various {@link com.apple.foundationdb.record.query.plan.temp.expressions.IndexScanExpression}s.", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc4MzAyNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565783027", "bodyText": "I like this generalization, but I think that the Javadoc needs an update.", "author": "nschiefer", "createdAt": "2021-01-28T02:45:03Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/matchers/MultiChildrenMatcher.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * MultiChildrenMatcher.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.matchers;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * An expression children matcher that tries to match all children to a single {@link ExpressionMatcher}.", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc4Mzk0MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565783941", "bodyText": "The use of an ExpressionRefTraversal inside of a PlannerRule feels off to me, since PlannerRules were designed to interact with the memo data structure as if it contained a single expression (i.e., wasn't memoized at all).\nI think this kind of behaviour is necessary, so my instinct is the matching should be done by a different type of rule (and rule invocation). See the general PR-wide comments for more thoughts on this.", "author": "nschiefer", "createdAt": "2021-01-28T02:47:41Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/MatchLeafRule.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * FlattenNestedAndPredicateRule.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.rules;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.ExpressionRefTraversal;\n+import com.apple.foundationdb.record.query.plan.temp.IdentityBiMap;\n+import com.apple.foundationdb.record.query.plan.temp.IterableHelpers;\n+import com.apple.foundationdb.record.query.plan.temp.MatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.MatchInfo;\n+import com.apple.foundationdb.record.query.plan.temp.PartialMatch;\n+import com.apple.foundationdb.record.query.plan.temp.PlanContext;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRule;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRuleCall;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ListChildrenMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.TypeMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matching.BoundMatch;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Expression-based transformation rule that matches any leaf expression. The rule creates matches of type\n+ * {@link PartialMatch} for any match between this expression and a leaf expression in a {@link MatchCandidate}.\n+ * It seeds the memoization structure for partial matches that is kept as part of {@link ExpressionRef}. It prepares\n+ * further rules such as {@link MatchIntermediateRule} and {@link AdjustMatchRule}.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public class MatchLeafRule extends PlannerRule<RelationalExpression> {\n+    // match any relational expression that is a leaf, that is, any expression that does not have any children\n+    private static final ExpressionMatcher<RelationalExpression> root =\n+            TypeMatcher.of(RelationalExpression.class, ListChildrenMatcher.empty());\n+\n+    public MatchLeafRule() {\n+        super(root);\n+    }\n+\n+    /**\n+     * Note: Transformation rules for expressions are partitioned by the class of the root matcher. This does not work\n+     * here as this rule is non-specific which means that it matches sub classes of {@link RelationalExpression} and not\n+     * just {@link RelationalExpression} itself. In order for this rule to fall into the set of rules that is always\n+     * utilized we return {@code Optional.empty()} here.\n+     * @return {@code Optional.empty()}\n+     */\n+    @Override\n+    public Optional<Class<? extends Bindable>> getRootOperator() {\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    public void onMatch(@Nonnull PlannerRuleCall call) {\n+        final PlanContext context = call.getContext();\n+        final RelationalExpression expression = call.get(root);\n+        // iterate through all candidates known to the context\n+        for (final MatchCandidate matchCandidate : context.getMatchCandidates()) {\n+            final ExpressionRefTraversal traversal = matchCandidate.getTraversal();", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjI3Mjk5MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572272991", "bodyText": "This was discussed in the review meeting also (because of this comment). The main point why I believe this is okay is that the matching rules only traverse the candidate graph, never the query query graph itself. The candidate graphs at this point are maximally pruned at that point, so in a sense references are meaningless on the candidate side and can be skipped and not exposed.", "author": "normen662", "createdAt": "2021-02-08T18:28:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc4Mzk0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjI3NzAxMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572277012", "bodyText": "Opened #1124 to track this.", "author": "normen662", "createdAt": "2021-02-08T18:35:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc4Mzk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc4NDUyNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565784526", "bodyText": "I think this needs to be copied over to the subsumedBy() methods, since I only now tracked down what is means after going through the PR several times.", "author": "nschiefer", "createdAt": "2021-01-28T02:49:36Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/MatchIntermediateRule.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * FlattenNestedAndPredicateRule.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.rules;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+import com.apple.foundationdb.record.query.plan.temp.EnumeratingIterable;\n+import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.IdentityBiMap;\n+import com.apple.foundationdb.record.query.plan.temp.IterableHelpers;\n+import com.apple.foundationdb.record.query.plan.temp.MatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.MatchInfo;\n+import com.apple.foundationdb.record.query.plan.temp.PartialMatch;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRule;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRuleCall;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.SelectExpression;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.QuantifierMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.TypeMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matching.BoundMatch;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import static com.apple.foundationdb.record.query.plan.temp.matchers.MultiChildrenMatcher.allMatching;\n+\n+/**\n+ * Expression-based transformation rule that matches any non-leaf expression (called an intermediate expression)\n+ * to a candidate expression in a {@link MatchCandidate}.\n+ * It yields matches of type {@link PartialMatch}. This rule further seeds the memoization\n+ * structure for partial matches that is kept as part of {@link ExpressionRef}. It prepares further rules such as\n+ * other applications of {@link MatchIntermediateRule} and {@link AdjustMatchRule}.\n+ *\n+ * As an intermediate expression has children (and the candidate expression also has at least one child) we\n+ * need to match up the quantifiers of the query expression to the quantifiers of the possible candidate expression\n+ * in order to determine if the query expression is in fact subsumed by the candidate. The property of subsumption\n+ * is defined as the ability of replacing the query expression with the candidate expression with the additional", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjI2NTcwOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572265708", "bodyText": "I have kind of done that now.", "author": "normen662", "createdAt": "2021-02-08T18:17:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc4NDUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc5Njk4OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565796988", "bodyText": "This method is terrifying (and I believe it necessarily so because it implements so much business logic). I think there should be a TODO to break this into smaller pieces (and ideally pull out a few abstractions) since this seems... hard to maintain, even for someone knowledgeable.", "author": "nschiefer", "createdAt": "2021-01-28T03:31:21Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/SelectExpression.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * SelectExpression.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.expressions;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.query.expressions.Comparisons;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.ComparisonRange;\n+import com.apple.foundationdb.record.query.plan.temp.Compensation;\n+import com.apple.foundationdb.record.query.plan.temp.CorrelationIdentifier;\n+import com.apple.foundationdb.record.query.plan.temp.CrossProduct;\n+import com.apple.foundationdb.record.query.plan.temp.EnumeratingIterable;\n+import com.apple.foundationdb.record.query.plan.temp.IdentityBiMap;\n+import com.apple.foundationdb.record.query.plan.temp.IterableHelpers;\n+import com.apple.foundationdb.record.query.plan.temp.MatchInfo;\n+import com.apple.foundationdb.record.query.plan.temp.PartialMatch;\n+import com.apple.foundationdb.record.query.plan.temp.PredicateMap;\n+import com.apple.foundationdb.record.query.plan.temp.PredicateMultiMap.PredicateMapping;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpressionWithPredicate;\n+import com.apple.foundationdb.record.query.plan.temp.explain.InternalPlannerGraphRewritable;\n+import com.apple.foundationdb.record.query.plan.temp.explain.PlannerGraph;\n+import com.apple.foundationdb.record.query.predicates.AndPredicate;\n+import com.apple.foundationdb.record.query.predicates.ConstantPredicate;\n+import com.apple.foundationdb.record.query.predicates.PredicateWithValue;\n+import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n+import com.apple.foundationdb.record.query.predicates.Value;\n+import com.apple.foundationdb.record.query.predicates.ValueComparisonRangePredicate;\n+import com.apple.foundationdb.record.query.predicates.ValueComparisonRangePredicate.Placeholder;\n+import com.apple.foundationdb.record.query.predicates.ValueComparisonRangePredicate.Sargable;\n+import com.apple.foundationdb.record.query.predicates.ValuePredicate;\n+import com.google.common.base.Equivalence;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableListMultimap;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A select expression.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public class SelectExpression implements RelationalExpressionWithChildren, RelationalExpressionWithPredicate, InternalPlannerGraphRewritable {\n+    @Nonnull\n+    private final List<Quantifier> children;\n+    @Nonnull\n+    private final List<QueryPredicate> predicates;\n+\n+    public SelectExpression(@Nonnull List<Quantifier> children) {\n+        this(children, ImmutableList.of());\n+    }\n+\n+    public SelectExpression(@Nonnull List<Quantifier> children, @Nonnull List<QueryPredicate> predicates) {\n+        this.children = children;\n+        this.predicates = predicates.isEmpty()\n+                          ? ImmutableList.of()\n+                          : partitionPredicates(predicates);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public List<? extends Quantifier> getQuantifiers() {\n+        return children;\n+    }\n+\n+    @Override\n+    public int getRelationalChildCount() {\n+        return children.size();\n+    }\n+\n+    @Override\n+    @Nonnull\n+    public QueryPredicate getPredicate() {\n+        return predicates.isEmpty() ? ConstantPredicate.TRUE : AndPredicate.and(predicates);\n+    }\n+\n+    @Nonnull\n+    public List<QueryPredicate> getPredicates() {\n+        return predicates;\n+    }\n+\n+    @Override\n+    public boolean canCorrelate() {\n+        return true;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return getPredicate().getCorrelatedTo();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public SelectExpression rebase(@Nonnull final AliasMap translationMap) {\n+        return (SelectExpression)RelationalExpressionWithChildren.super.rebase(translationMap);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public SelectExpression rebaseWithRebasedQuantifiers(@Nonnull final AliasMap translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {\n+        List<QueryPredicate> rebasedPredicates = predicates.stream().map(p -> p.rebase(translationMap)).collect(Collectors.toList());\n+        return new SelectExpression(rebasedQuantifiers, rebasedPredicates);\n+    }\n+\n+    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n+    @Override\n+    public boolean equals(final Object other) {\n+        return semanticEquals(other);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return semanticHashCode();\n+    }\n+\n+    @Override\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression,\n+                                         @Nonnull final AliasMap equivalencesMap) {\n+        if (this == otherExpression) {\n+            return true;\n+        }\n+        if (getClass() != otherExpression.getClass()) {\n+            return false;\n+        }\n+\n+        return getPredicate().semanticEquals(((SelectExpression)otherExpression).getPredicate(), equivalencesMap);\n+    }\n+\n+    @Override\n+    public int hashCodeWithoutChildren() {\n+        return Objects.hash(getPredicate());\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public Iterable<MatchInfo> subsumedBy(@Nonnull final RelationalExpression otherExpression,\n+                                          @Nonnull final AliasMap aliasMap,\n+                                          @Nonnull final IdentityBiMap<Quantifier, PartialMatch> partialMatchMap) {", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTc0MjUyOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r571742528", "bodyText": "added more comments and refactored things but will also add a TODO", "author": "normen662", "createdAt": "2021-02-08T02:02:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc5Njk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc5OTEwNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r565799104", "bodyText": "Is there any way to move this into the regular pruning step of the CascadesPlanner? It feels wrong to bake part of the cost model into a rule.", "author": "nschiefer", "createdAt": "2021-01-28T03:39:36Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/DataAccessRule.java", "diffHunk": "@@ -0,0 +1,446 @@\n+/*\n+ * DataAccessRule.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.rules;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.query.plan.temp.BoundKeyPart;\n+import com.apple.foundationdb.record.query.plan.temp.CascadesPlanner;\n+import com.apple.foundationdb.record.query.plan.temp.ChooseK;\n+import com.apple.foundationdb.record.query.plan.temp.ComparisonRange;\n+import com.apple.foundationdb.record.query.plan.temp.Compensation;\n+import com.apple.foundationdb.record.query.plan.temp.CorrelationIdentifier;\n+import com.apple.foundationdb.record.query.plan.temp.GroupExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.IndexScanMatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.MatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.MatchInfo;\n+import com.apple.foundationdb.record.query.plan.temp.MatchPartition;\n+import com.apple.foundationdb.record.query.plan.temp.PartialMatch;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRule;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRuleCall;\n+import com.apple.foundationdb.record.query.plan.temp.PrimaryScanMatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.IndexScanExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.LogicalDistinctExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.LogicalIntersectionExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.PrimaryScanExpression;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.MatchPartitionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PartialMatchMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * A rule that utilizes index matching information compiled by {@link CascadesPlanner} to create a logical expression\n+ * for data access. While this rule delegates specifics to the {@link MatchCandidate}s, the following are possible\n+ * outcomes of the application of this transformation rule. Based on the match info, we may create for a single match:\n+ *\n+ * <ul>\n+ *     <li>a {@link PrimaryScanExpression} for a single {@link PrimaryScanMatchCandidate},</li>\n+ *     <li>an {@link IndexScanExpression} for a single {@link IndexScanMatchCandidate}</li>\n+ * </ul>\n+ *\n+ * The logic that this rules delegates to to actually create the expressions can be found in\n+ * {@link MatchCandidate#toScanExpression(MatchInfo)}.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public class DataAccessRule extends PlannerRule<MatchPartition> {\n+    private static final ExpressionMatcher<PartialMatch> completeMatchMatcher = PartialMatchMatcher.completeMatch();\n+    private static final ExpressionMatcher<MatchPartition> rootMatcher = MatchPartitionMatcher.some(completeMatchMatcher);\n+    \n+    public DataAccessRule() {\n+        super(rootMatcher);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"java:S135\")\n+    public void onMatch(@Nonnull PlannerRuleCall call) {\n+        final PlannerBindings bindings = call.getBindings();\n+        final List<PartialMatch> completeMatches = bindings.getAll(completeMatchMatcher);\n+\n+        if (completeMatches.isEmpty()) {\n+            return;\n+        }\n+\n+        final Map<MatchCandidate, List<PartialMatch>> completeMatchMap =\n+                completeMatches\n+                        .stream()\n+                        .collect(Collectors.groupingBy(PartialMatch::getMatchCandidate));\n+\n+        // find the best match for a candidate as there may be more than one due to partial matching\n+        final ImmutableSet<PartialMatch> bestMatches =\n+                completeMatchMap.entrySet()\n+                .stream()\n+                        .flatMap(entry -> {\n+                            final List<PartialMatch> completeMatchesForCandidate = entry.getValue();\n+                            final Optional<PartialMatch> bestMatchForCandidateOptional =\n+                                    completeMatchesForCandidate\n+                                            .stream()\n+                                            .max(Comparator.comparing(PartialMatch::getNumBoundParameterPrefix));\n+                            return bestMatchForCandidateOptional.map(Stream::of).orElse(Stream.empty());\n+                        })\n+                        .collect(ImmutableSet.toImmutableSet());", "originalCommit": "2881dc61d82619e0a0cc704c6e38c389436e8c3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjQ4ODk5Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572488992", "bodyText": "As discussed in the meeting this is not using the cost model -- it's determining the maximal match among the matches for one candidate.", "author": "normen662", "createdAt": "2021-02-09T00:58:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTc5OTEwNA=="}], "type": "inlineReview"}, {"oid": "020ee1a6bb3b2ccc0f43a9004ddc2f25f7671666", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/020ee1a6bb3b2ccc0f43a9004ddc2f25f7671666", "message": "adressing commments", "committedDate": "2021-01-29T20:21:04Z", "type": "forcePushed"}, {"oid": "0018df75b71eec959213eb6fd1a0ff6643380bf8", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/0018df75b71eec959213eb6fd1a0ff6643380bf8", "message": "adressing commments", "committedDate": "2021-02-09T00:46:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUxMDEyOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572510128", "bodyText": "This was true before, but I see now that neither here nor GraphExpansion says explicitly that there is a conjunct between the predicates, which is why just expanding the children for AND is the right thing.", "author": "MMcM", "createdAt": "2021-02-09T01:53:49Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/expressions/AndComponent.java", "diffHunk": "@@ -74,9 +74,9 @@ public QueryComponent withOtherChildren(List<QueryComponent> newChildren) {\n     }\n \n     @Override\n-    public ExpandedPredicates normalizeForPlanner(@Nonnull final CorrelationIdentifier base, @Nonnull final List<String> fieldNamePrefix) {\n-        return ExpandedPredicates.ofOthers(getChildren().stream()\n-                .map(child -> child.normalizeForPlanner(base, fieldNamePrefix))\n+    public GraphExpansion expand(@Nonnull final CorrelationIdentifier base, @Nonnull final List<String> fieldNamePrefix) {\n+        return GraphExpansion.ofOthers(getChildren().stream()", "originalCommit": "0018df75b71eec959213eb6fd1a0ff6643380bf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzAyOTg1Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r573029856", "bodyText": "Will put an explicit note about the ANDing of all the predicate in GraphExpansion prior to building a SelectExpression into GraphExpansion.", "author": "normen662", "createdAt": "2021-02-09T16:23:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUxMDEyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzA5Mzk1Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r573093952", "bodyText": "\u2705", "author": "MMcM", "createdAt": "2021-02-09T17:43:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUxMDEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUxMjE4OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572512188", "bodyText": "This is still a little weird, in as much as \"applies this\" means apply the comparison condition part and ignore the child path. Does this really work like that in a compensation?", "author": "MMcM", "createdAt": "2021-02-09T01:59:18Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/expressions/OneOfThemWithComparison.java", "diffHunk": "@@ -102,23 +101,26 @@ public QueryComponent withOtherComparison(Comparisons.Comparison comparison) {\n     }\n \n     @Override\n-    public ExpandedPredicates normalizeForPlanner(@Nonnull final CorrelationIdentifier baseAlias, @Nonnull final List<String> fieldNamePrefix) {\n+    public GraphExpansion expand(@Nonnull final CorrelationIdentifier baseAlias, @Nonnull final List<String> fieldNamePrefix) {\n         List<String> fieldNames = ImmutableList.<String>builder()\n                 .addAll(fieldNamePrefix)\n                 .add(getFieldName())\n                 .build();\n         final Quantifier childBase = Quantifier.forEach(GroupExpressionRef.of(new ExplodeExpression(baseAlias, fieldNames)));\n-        final SelectExpression selectExpression = ExpandedPredicates.ofPredicate(new ValuePredicate(\n-                new ObjectValue(childBase.getAlias()), comparison)).buildSelectWithBase(childBase);\n+        final SelectExpression selectExpression =\n+                GraphExpansion.ofPredicate(new QuantifiedObjectValue(childBase.getAlias()).withComparison(comparison)).buildSelectWithBase(childBase);\n         final Quantifier.Existential childQuantifier = Quantifier.existential(GroupExpressionRef.of(selectExpression));\n \n+        // create a query component that creates a path to this prefix and then applies this to it", "originalCommit": "0018df75b71eec959213eb6fd1a0ff6643380bf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUzOTUzNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572539534", "bodyText": "In general compensation is computed by comparing two graphs. In fact this will lead us to the need of reapplying what the outcome of a particular subgraph is. Since we don't have any runtime for anything QueryComponent-like outside of the QueryComponent tree I need to keep this alternative version around -- yuck!\nHere is what happens in this case specifically: We could just reapply the original query filter. I order to be a bit better I can also (if I have to) reapply what's needed that is originally under this expansion, e.g.\nquery: Field(a).oneOfThem(Field(b).oneOfThem(c = 5) and d = 6)\nIf I have an index for a, d but nothing for a, b, c I can still use the index on a, d and reapply either the entire query filter or this one:\nField(a).oneOfThem(Field(b).oneOfThem(c = 5))\nThe code in question takes care of making a chain of Field(a).oneOfThem(Field(b))..... Note that the last step is just the current key expression at hand.", "author": "normen662", "createdAt": "2021-02-09T03:12:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUxMjE4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzA5MzMzNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r573093334", "bodyText": "\u2705", "author": "MMcM", "createdAt": "2021-02-09T17:42:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUxMjE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUxMjg2OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572512869", "bodyText": "\"her\" -> \"here\" But, really, both sentences in this paragraph could use some wordsmithing.", "author": "MMcM", "createdAt": "2021-02-09T02:01:16Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/GraphExpansion.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * GraphExpansion.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.temp.expressions.SelectExpression;\n+import com.apple.foundationdb.record.query.predicates.AndPredicate;\n+import com.apple.foundationdb.record.query.predicates.QuantifiedColumnValue;\n+import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n+import com.apple.foundationdb.record.query.predicates.Value;\n+import com.apple.foundationdb.record.query.predicates.ValueComparisonRangePredicate;\n+import com.apple.foundationdb.record.query.predicates.ValueComparisonRangePredicate.Placeholder;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Lists;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+/**\n+ * Class to abstract behavior when query expansion is applied to query components or key expressions. An object of this\n+ * class represents a conglomeration for result values, predicates, quantifiers before those elements are unified and\n+ * eventually find their homw in a {@link SelectExpression}.\n+ *\n+ * Another way of thinking about this class is to conceptualize logic implemented her as a pre-stage to actually\n+ * creating expressions, as a builder of a {@link SelectExpression}s of sorts. The fundamental difference between\n+ * a builder in an ordinary builder pattern and this class also provides getters to all elements and the ability to\n+ * merge other objects of this class in a additive manner.", "originalCommit": "0018df75b71eec959213eb6fd1a0ff6643380bf8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUxNDM5MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572514390", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * {@link GraphExpansion}s into more complex ones. This method normalizes all elements before in order to return a\n          \n          \n            \n                 * {@link GraphExpansion}s into more complex ones. This method normalizes all elements beforehand in order to return a", "author": "MMcM", "createdAt": "2021-02-09T02:06:05Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/GraphExpansion.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * GraphExpansion.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.temp.expressions.SelectExpression;\n+import com.apple.foundationdb.record.query.predicates.AndPredicate;\n+import com.apple.foundationdb.record.query.predicates.QuantifiedColumnValue;\n+import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n+import com.apple.foundationdb.record.query.predicates.Value;\n+import com.apple.foundationdb.record.query.predicates.ValueComparisonRangePredicate;\n+import com.apple.foundationdb.record.query.predicates.ValueComparisonRangePredicate.Placeholder;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Lists;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+/**\n+ * Class to abstract behavior when query expansion is applied to query components or key expressions. An object of this\n+ * class represents a conglomeration for result values, predicates, quantifiers before those elements are unified and\n+ * eventually find their homw in a {@link SelectExpression}.\n+ *\n+ * Another way of thinking about this class is to conceptualize logic implemented her as a pre-stage to actually\n+ * creating expressions, as a builder of a {@link SelectExpression}s of sorts. The fundamental difference between\n+ * a builder in an ordinary builder pattern and this class also provides getters to all elements and the ability to\n+ * merge other objects of this class in a additive manner.\n+ *\n+ * This class also hides some data cleansing process, in particular related to potential duplicity on place holders,\n+ * which must be corrected (distincted) before the place holders are used in the predicates of e.g. a match candidate.\n+ */\n+public class GraphExpansion implements KeyExpressionVisitor.Result {\n+    @Nonnull\n+    private final List<Value> resultValues;\n+\n+    @Nonnull\n+    private final List<QueryPredicate> predicates;\n+\n+    @Nonnull\n+    private final List<Quantifier> quantifiers;\n+\n+    @Nonnull\n+    private final List<Placeholder> placeholders;\n+\n+    private GraphExpansion(@Nonnull final List<? extends Value> resultValues,\n+                           @Nonnull final List<? extends QueryPredicate> predicates,\n+                           @Nonnull final List<? extends Quantifier> quantifiers,\n+                           @Nonnull final List<? extends Placeholder> placeholders) {\n+        this.resultValues = ImmutableList.copyOf(resultValues);\n+        this.predicates = ImmutableList.copyOf(predicates);\n+        this.quantifiers = ImmutableList.copyOf(quantifiers);\n+        this.placeholders = ImmutableList.copyOf(placeholders);\n+    }\n+\n+    @Nonnull\n+    public List<Value> getResultValues() {\n+        return resultValues;\n+    }\n+\n+    @Nonnull\n+    public List<QueryPredicate> getPredicates() {\n+        return predicates;\n+    }\n+\n+    @Nonnull\n+    public List<Quantifier> getQuantifiers() {\n+        return quantifiers;\n+    }\n+\n+    @Nonnull\n+    public List<Placeholder> getPlaceholders() {\n+        return placeholders;\n+    }\n+\n+    @Nonnull\n+    public List<CorrelationIdentifier> getPlaceholderAliases() {\n+        return placeholders\n+                .stream()\n+                .map(ValueComparisonRangePredicate.Placeholder::getParameterAlias)\n+                .collect(ImmutableList.toImmutableList());\n+    }\n+\n+    @Nonnull\n+    public QueryPredicate asAndPredicate() {\n+        return AndPredicate.and(getPredicates());\n+    }\n+\n+    @Nonnull\n+    public GraphExpansion withPredicate(@Nonnull final QueryPredicate predicate) {\n+        return new GraphExpansion(this.resultValues, ImmutableList.of(predicate), this.quantifiers, this.placeholders);\n+    }\n+\n+    /**\n+     * Method to <em>seal</em> a graph expansion in an instance of {@link Sealed}. A sealed graph expansion is immutable\n+     * and can only be used to (repeatedly) build actual expressions.\n+     * A graph expansion may contain duplicate information that have been added to it by callers. That is allowed and\n+     * supported. In fact, in most cases, duplicates among e.g. {@link QueryPredicate}s come from merging individual\n+     * {@link GraphExpansion}s into more complex ones. This method normalizes all elements before in order to return a", "originalCommit": "0018df75b71eec959213eb6fd1a0ff6643380bf8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUxNDg4NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572514885", "bodyText": "This doesn't seem to be precisely true. In the interesting cases, it makes local placeholders and predicates.", "author": "MMcM", "createdAt": "2021-02-09T02:07:35Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/GraphExpansion.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * GraphExpansion.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.temp.expressions.SelectExpression;\n+import com.apple.foundationdb.record.query.predicates.AndPredicate;\n+import com.apple.foundationdb.record.query.predicates.QuantifiedColumnValue;\n+import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n+import com.apple.foundationdb.record.query.predicates.Value;\n+import com.apple.foundationdb.record.query.predicates.ValueComparisonRangePredicate;\n+import com.apple.foundationdb.record.query.predicates.ValueComparisonRangePredicate.Placeholder;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Lists;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+/**\n+ * Class to abstract behavior when query expansion is applied to query components or key expressions. An object of this\n+ * class represents a conglomeration for result values, predicates, quantifiers before those elements are unified and\n+ * eventually find their homw in a {@link SelectExpression}.\n+ *\n+ * Another way of thinking about this class is to conceptualize logic implemented her as a pre-stage to actually\n+ * creating expressions, as a builder of a {@link SelectExpression}s of sorts. The fundamental difference between\n+ * a builder in an ordinary builder pattern and this class also provides getters to all elements and the ability to\n+ * merge other objects of this class in a additive manner.\n+ *\n+ * This class also hides some data cleansing process, in particular related to potential duplicity on place holders,\n+ * which must be corrected (distincted) before the place holders are used in the predicates of e.g. a match candidate.\n+ */\n+public class GraphExpansion implements KeyExpressionVisitor.Result {\n+    @Nonnull\n+    private final List<Value> resultValues;\n+\n+    @Nonnull\n+    private final List<QueryPredicate> predicates;\n+\n+    @Nonnull\n+    private final List<Quantifier> quantifiers;\n+\n+    @Nonnull\n+    private final List<Placeholder> placeholders;\n+\n+    private GraphExpansion(@Nonnull final List<? extends Value> resultValues,\n+                           @Nonnull final List<? extends QueryPredicate> predicates,\n+                           @Nonnull final List<? extends Quantifier> quantifiers,\n+                           @Nonnull final List<? extends Placeholder> placeholders) {\n+        this.resultValues = ImmutableList.copyOf(resultValues);\n+        this.predicates = ImmutableList.copyOf(predicates);\n+        this.quantifiers = ImmutableList.copyOf(quantifiers);\n+        this.placeholders = ImmutableList.copyOf(placeholders);\n+    }\n+\n+    @Nonnull\n+    public List<Value> getResultValues() {\n+        return resultValues;\n+    }\n+\n+    @Nonnull\n+    public List<QueryPredicate> getPredicates() {\n+        return predicates;\n+    }\n+\n+    @Nonnull\n+    public List<Quantifier> getQuantifiers() {\n+        return quantifiers;\n+    }\n+\n+    @Nonnull\n+    public List<Placeholder> getPlaceholders() {\n+        return placeholders;\n+    }\n+\n+    @Nonnull\n+    public List<CorrelationIdentifier> getPlaceholderAliases() {\n+        return placeholders\n+                .stream()\n+                .map(ValueComparisonRangePredicate.Placeholder::getParameterAlias)\n+                .collect(ImmutableList.toImmutableList());\n+    }\n+\n+    @Nonnull\n+    public QueryPredicate asAndPredicate() {\n+        return AndPredicate.and(getPredicates());\n+    }\n+\n+    @Nonnull\n+    public GraphExpansion withPredicate(@Nonnull final QueryPredicate predicate) {\n+        return new GraphExpansion(this.resultValues, ImmutableList.of(predicate), this.quantifiers, this.placeholders);\n+    }\n+\n+    /**\n+     * Method to <em>seal</em> a graph expansion in an instance of {@link Sealed}. A sealed graph expansion is immutable\n+     * and can only be used to (repeatedly) build actual expressions.\n+     * A graph expansion may contain duplicate information that have been added to it by callers. That is allowed and\n+     * supported. In fact, in most cases, duplicates among e.g. {@link QueryPredicate}s come from merging individual\n+     * {@link GraphExpansion}s into more complex ones. This method normalizes all elements before in order to return a\n+     * sealed version of itself.", "originalCommit": "0018df75b71eec959213eb6fd1a0ff6643380bf8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUxNTA4Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572515086", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * An interface so provide a state-based visitor pattern that can traverse a tree of {@link KeyExpression}s.\n          \n          \n            \n             * An interface to provide a state-based visitor pattern that can traverse a tree of {@link KeyExpression}s.", "author": "MMcM", "createdAt": "2021-02-09T02:08:11Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/KeyExpressionVisitor.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * KeyExpressionVisitor.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2021 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.metadata.expressions.EmptyKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpressionWithValue;\n+import com.apple.foundationdb.record.metadata.expressions.KeyWithValueExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.ThenKeyExpression;\n+\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * An interface so provide a state-based visitor pattern that can traverse a tree of {@link KeyExpression}s.", "originalCommit": "0018df75b71eec959213eb6fd1a0ff6643380bf8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUxNTcyNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572515725", "bodyText": "I know we have other instances of this same pattern, but I am not sure everyone is happy with them. Specifically, this makes it harder to tell just by looking whether a specific case is supported specially or not. For non-this cases, there are also problems where otherwise innocent widening loses the right method.", "author": "MMcM", "createdAt": "2021-02-09T02:10:03Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/KeyExpressionVisitor.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * KeyExpressionVisitor.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2021 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.metadata.expressions.EmptyKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpressionWithValue;\n+import com.apple.foundationdb.record.metadata.expressions.KeyWithValueExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.ThenKeyExpression;\n+\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * An interface so provide a state-based visitor pattern that can traverse a tree of {@link KeyExpression}s.\n+ * @param <S> the type of the state object which depends on the specific implementation\n+ * @param <R> the type of the result object which is returned by all visitation methods\n+ */\n+public interface KeyExpressionVisitor<S extends KeyExpressionVisitor.State, R extends KeyExpressionVisitor.Result> {\n+\n+    /**\n+     * Method to return the (immutable) current state.\n+     * @return the current state of type {@code S}\n+     */\n+    S getCurrentState();\n+\n+    /**\n+     * Default method that is called on unknown sub classes of {@link KeyExpression}. That makes it possible to\n+     * add a {@code visitor.visitExpression(this)} regardless whether the visitor defines an actual specific override\n+     * for the sub class of {@code this} or not.", "originalCommit": "0018df75b71eec959213eb6fd1a0ff6643380bf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzA1NTQzNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r573055434", "bodyText": "It's true. Will leave this pattern in for now unless you object. I would imagine fielding with this in the near future when we add more sorts of key expressions.", "author": "normen662", "createdAt": "2021-02-09T16:53:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUxNTcyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzA5MTA2Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r573091066", "bodyText": "\u2705", "author": "MMcM", "createdAt": "2021-02-09T17:39:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUxNTcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUxNjY0MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572516640", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * {@link ValueIndexScanMatchCandidate} or the primary range for a {@link PrimaryScanMatchCandidate} given appropriate\n          \n          \n            \n             * {@link ValueIndexScanMatchCandidate} or the primary range for a {@link PrimaryScanMatchCandidate}, given appropriate", "author": "MMcM", "createdAt": "2021-02-09T02:12:42Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/MatchCandidate.java", "diffHunk": "@@ -20,38 +20,223 @@\n \n package com.apple.foundationdb.record.query.plan.temp;\n \n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.FullUnorderedScanExpression;\n+import com.apple.foundationdb.record.query.plan.temp.expressions.LogicalTypeFilterExpression;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.collect.Sets;\n+\n import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n \n /**\n- * Case class to represent a match candidate. A match candidate on code level is just a name and a data flow graph\n+ * Interface to represent a match candidate. A match candidate on code level is just a name and a data flow graph\n  * that can be matched against a query graph. The match candidate does not keep the root to the graph to be matched but\n  * rather an instance of {@link ExpressionRefTraversal} to allow for navigation of references within the candidate.\n+ *\n+ * Match candidates also allow for creation of scans over the materialized data, e.g. the index for an\n+ * {@link ValueIndexScanMatchCandidate} or the primary range for a {@link PrimaryScanMatchCandidate} given appropriate", "originalCommit": "0018df75b71eec959213eb6fd1a0ff6643380bf8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUyMTIwNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572521204", "bodyText": "You don't really need to repeat TODO; just indenting make a multi-line todo in the IDE.", "author": "MMcM", "createdAt": "2021-02-09T02:26:39Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/SelectExpression.java", "diffHunk": "@@ -210,25 +218,26 @@ public int hashCodeWithoutChildren() {\n             return ImmutableList.of();\n         }\n \n-        // loop through all for each quantifiers on the other side to ensure that they are all matched\n+        // Loop through all for each quantifiers on the other side to ensure that they are all matched.\n+        // If any are not matched we cannot establish a match at all.\n         final boolean allOtherForEachQuantifiersMatched =\n                 otherSelectExpression.getQuantifiers()\n                         .stream()\n                         .filter(quantifier -> quantifier instanceof Quantifier.ForEach)\n                         .allMatch(quantifier -> aliasMap.containsTarget(quantifier.getAlias()));\n \n+        // TODO this is not really needed if we assign a property to the quantifier that allows us to reason about the\n+        // TODO the \"default on empty\" property as in does this quantifier flow a scalar result such as an \"empty\" value,\n+        // TODO a real value, or even null if the underlying graph evaluates to empty. The presence of such a property\n+        // TODO would help us here to make sure the additional non-matched quantifier is not eliminating records.", "originalCommit": "0018df75b71eec959213eb6fd1a0ff6643380bf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzA0OTE2Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r573049166", "bodyText": "TIL", "author": "normen662", "createdAt": "2021-02-09T16:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUyMTIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUyMjcyMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572522723", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * TODO on quantifiers.\n          \n          \n            \n             *   on quantifiers.", "author": "MMcM", "createdAt": "2021-02-09T02:30:44Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/AdjustMatchRule.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * AdjustMatchRule.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.rules;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.MatchCandidate;\n+import com.apple.foundationdb.record.query.plan.temp.MatchInfo;\n+import com.apple.foundationdb.record.query.plan.temp.PartialMatch;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRule;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerRuleCall;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PartialMatchMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.SetMultimap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * A rule that attempts to improve an existing {@link PartialMatch} by <em>absorbing</em> an expression on the\n+ * candidate side.\n+ *\n+ * Currently the only such expression that can be absorbed is\n+ * {@link com.apple.foundationdb.record.query.plan.temp.expressions.MatchableSortExpression}.\n+ * TODO Maybe that expression should just be a generic property-defining expression or properties should be kept\n+ * TODO on quantifiers.", "originalCommit": "0018df75b71eec959213eb6fd1a0ff6643380bf8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUyMzQ2Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572523466", "bodyText": "I somewhat prefer [0] to #0. But I don't feel strongly about this.", "author": "MMcM", "createdAt": "2021-02-09T02:33:24Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/QuantifiedColumnValue.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * QuantifiedColumnValue.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.predicates;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.annotation.SpotBugsSuppressWarnings;\n+import com.apple.foundationdb.record.EvaluationContext;\n+import com.apple.foundationdb.record.ObjectPlanHash;\n+import com.apple.foundationdb.record.PlanHashable;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecord;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreBase;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.CorrelationIdentifier;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.protobuf.Message;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+/**\n+ * A value representing the quantifier as an object.\n+ *\n+ * For example, this is used to represent non-nested repeated fields.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public class QuantifiedColumnValue implements Value {\n+    private static final ObjectPlanHash BASE_HASH = new ObjectPlanHash(\"Quantifier-Column-Value\");\n+\n+    @Nonnull\n+    private final CorrelationIdentifier identifier;\n+    private final int ordinalPosition;\n+\n+\n+    public QuantifiedColumnValue(@Nonnull final CorrelationIdentifier identifier,\n+                                 final int ordinalPosition) {\n+        this.identifier = identifier;\n+        this.ordinalPosition = ordinalPosition;\n+    }\n+\n+    @Nonnull\n+    public CorrelationIdentifier getIdentifier() {\n+        return identifier;\n+    }\n+\n+    public int getOrdinalPosition() {\n+        return ordinalPosition;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return Collections.singleton(identifier);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public QuantifiedColumnValue rebase(@Nonnull final AliasMap translationMap) {\n+        if (translationMap.containsSource(identifier)) {\n+            return new QuantifiedColumnValue(translationMap.getTargetOrThrow(identifier), ordinalPosition);\n+        }\n+        return this;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public <M extends Message> Object eval(@Nonnull final FDBRecordStoreBase<M> store, @Nonnull final EvaluationContext context, @Nullable final FDBRecord<M> record, @Nullable final M message) {\n+        return context.getBinding(identifier);\n+    }\n+\n+    @Override\n+    public boolean semanticEquals(@Nullable final Object other, @Nonnull final AliasMap equivalenceMap) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (other == null || getClass() != other.getClass()) {\n+            return false;\n+        }\n+        final QuantifiedColumnValue that = (QuantifiedColumnValue)other;\n+        if (ordinalPosition != that.getOrdinalPosition()) {\n+            return false;\n+        }\n+        return equivalenceMap.containsMapping(identifier, that.identifier);\n+    }\n+\n+    @Override\n+    public int semanticHashCode() {\n+        return PlanHashable.objectsPlanHash(PlanHashKind.FOR_CONTINUATION, BASE_HASH, ordinalPosition);\n+    }\n+\n+    @Override\n+    public int planHash(@Nonnull final PlanHashKind hashKind) {\n+        return PlanHashable.objectsPlanHash(hashKind, BASE_HASH, ordinalPosition);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"$\" + identifier + \"#\" + ordinalPosition;", "originalCommit": "0018df75b71eec959213eb6fd1a0ff6643380bf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzA1MDI0MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r573050240", "bodyText": "changed", "author": "normen662", "createdAt": "2021-02-09T16:47:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUyMzQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUzNzA2MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572537061", "bodyText": "I am a little bit hesitant to use the word \"unify\" in the context of matching in an ordinary / general sense.", "author": "MMcM", "createdAt": "2021-02-09T03:04:45Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -495,4 +524,45 @@ protected boolean needsRebase(@Nonnull final AliasMap translationMap) {\n     public <Q extends Quantifier> Q narrow(@Nonnull Class<Q> narrowedClass) {\n         return narrowedClass.cast(this);\n     }\n+\n+    @Nonnull\n+    public Optional<List<? extends QuantifiedColumnValue>> getFlowedValues() {\n+        return flowedValuesSupplier.get();\n+    }\n+\n+    @Nonnull\n+    protected abstract Optional<List<? extends QuantifiedColumnValue>> computeFlowedValues();\n+\n+    @Nonnull\n+    protected Optional<List<? extends Value>> unifyResultValues() {", "originalCommit": "0018df75b71eec959213eb6fd1a0ff6643380bf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUzOTg0MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r572539840", "bodyText": "Yes. It's not what some other people think this means!", "author": "normen662", "createdAt": "2021-02-09T03:13:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUzNzA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzA1Mzg0MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1084#discussion_r573053840", "bodyText": "changed to resolveValuesRangedOver", "author": "normen662", "createdAt": "2021-02-09T16:51:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUzNzA2MQ=="}], "type": "inlineReview"}, {"oid": "bab23bdb5e4ed228b83d586200ccedf390f3906e", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/bab23bdb5e4ed228b83d586200ccedf390f3906e", "message": "cascades planner and index matching milestone 0", "committedDate": "2021-02-09T16:11:50Z", "type": "commit"}, {"oid": "78ea984bca1f6acad5df88998a3890ff8fbbcd41", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/78ea984bca1f6acad5df88998a3890ff8fbbcd41", "message": "adressing commments", "committedDate": "2021-02-09T17:04:19Z", "type": "commit"}, {"oid": "78ea984bca1f6acad5df88998a3890ff8fbbcd41", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/78ea984bca1f6acad5df88998a3890ff8fbbcd41", "message": "adressing commments", "committedDate": "2021-02-09T17:04:19Z", "type": "forcePushed"}]}