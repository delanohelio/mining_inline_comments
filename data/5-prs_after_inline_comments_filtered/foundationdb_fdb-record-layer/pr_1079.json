{"pr_number": 1079, "pr_title": "Resolve #1078: Allow creating an index from an existing index", "pr_createdAt": "2020-12-01T22:32:19Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079", "timeline": [{"oid": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/5ee31a2e0c758632349f7a5b8d58723b47756fc2", "message": "Resolve #1078: Allow creating an index from an existing index\n\n    When building a single type idempotent index, provide the user with an option\n    to request an iteration over an existing, readable, source index instead of a\n    full records store scan.", "committedDate": "2020-12-01T23:44:38Z", "type": "forcePushed"}, {"oid": "659409f1cb1545818f77ee1ca0638a1a92535c20", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/659409f1cb1545818f77ee1ca0638a1a92535c20", "message": "Convert 'asssert' to 'assertTrue'\n\n  + fix style - identation\n  + convert indexFromIndex member to final", "committedDate": "2020-12-04T16:33:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ2NjY0OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r536466649", "bodyText": "Update getRecordStoreState to reuse this method instead of having two copies of code.", "author": "nblintao", "createdAt": "2020-12-05T00:56:04Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordStore.java", "diffHunk": "@@ -353,6 +353,22 @@ public RecordStoreState getRecordStoreState() {\n         return recordStoreStateRef.get();\n     }\n \n+    /**\n+     * Get a {@link CompletableFuture} with the {@link RecordStoreState} for this store.\n+     * The future value represents the indexes that are disabled or in the process of being rebuilt.\n+     * @return a CompletableFuture with the store state for this store\n+     */\n+    @Nonnull\n+    public CompletableFuture<RecordStoreState> getRecordStoreStateAsync() {", "originalCommit": "659409f1cb1545818f77ee1ca0638a1a92535c20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ2NzAxNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r536467015", "bodyText": "This can easily be a separate class.", "author": "nblintao", "createdAt": "2020-12-05T00:57:27Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2479,6 +2520,61 @@ private static void checkPositive(int value, String desc) {\n         }\n     }\n \n+    /**\n+     * A builder for the  indexFromIndex request. Allow caller to request that:\n+     *  1. The index will be scanned from another index.\n+     *  2. Whether the indexer will fail or perform a records scan, would the target index not not\n+     *     appropraite for the job.\n+     */\n+    public static class IndexFromIndexRequest {", "originalCommit": "659409f1cb1545818f77ee1ca0638a1a92535c20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE1NDk5MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r537154990", "bodyText": "It was, indeed, written with this approach in mind.", "author": "jjezra", "createdAt": "2020-12-07T00:00:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ2NzAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ2NzI0Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r536467246", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *  2. Whether the indexer will fail or perform a records scan, would the target index not not\n          \n          \n            \n                 *  2. Whether the indexer will fail or perform a records scan, would the target index not", "author": "nblintao", "createdAt": "2020-12-05T00:58:27Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2479,6 +2520,61 @@ private static void checkPositive(int value, String desc) {\n         }\n     }\n \n+    /**\n+     * A builder for the  indexFromIndex request. Allow caller to request that:\n+     *  1. The index will be scanned from another index.\n+     *  2. Whether the indexer will fail or perform a records scan, would the target index not not", "originalCommit": "659409f1cb1545818f77ee1ca0638a1a92535c20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ3NTUxNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r536475516", "bodyText": "You can set a default value for indexFromIndex in OnlineIndexer.Builder so that it can be always non-null.", "author": "nblintao", "createdAt": "2020-12-05T01:35:49Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1289,24 +1294,47 @@ private boolean shouldClearExistingIndexEntries(@Nonnull IndexState indexState,\n     }\n \n     @Nonnull\n-    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n-        CompletableFuture<Void> buildFuture = buildEndpoints().thenCompose(tupleRange -> {\n+    private CompletableFuture<Void> buildIndexFromRecordsAsync() {\n+        return buildEndpoints().thenCompose(tupleRange -> {\n             if (tupleRange != null) {\n                 return buildRange(Key.Evaluated.fromTuple(tupleRange.getLow()), Key.Evaluated.fromTuple(tupleRange.getHigh()));\n             } else {\n                 return CompletableFuture.completedFuture(null);\n             }\n         });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n+        boolean useIndexFromIndex = indexFromIndex != null && indexFromIndex.isActive();", "originalCommit": "659409f1cb1545818f77ee1ca0638a1a92535c20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE1NTQ0Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r537155443", "bodyText": "I think that having this nesting 'indexFromIndex' to hold a single value is an overkill. How about adding two fields to the builder:\n\nsrcIndexForIndexScan - to build index from index\nallowFallbackToRecScan - this can be used for other scanning methods if and when", "author": "jjezra", "createdAt": "2020-12-07T00:02:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ3NTUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ3NTU3OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r536475578", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    CompletableFuture<Void> buildFuture ;\n          \n          \n            \n                    CompletableFuture<Void> buildFuture;", "author": "nblintao", "createdAt": "2020-12-05T01:36:06Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1289,24 +1294,47 @@ private boolean shouldClearExistingIndexEntries(@Nonnull IndexState indexState,\n     }\n \n     @Nonnull\n-    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n-        CompletableFuture<Void> buildFuture = buildEndpoints().thenCompose(tupleRange -> {\n+    private CompletableFuture<Void> buildIndexFromRecordsAsync() {\n+        return buildEndpoints().thenCompose(tupleRange -> {\n             if (tupleRange != null) {\n                 return buildRange(Key.Evaluated.fromTuple(tupleRange.getLow()), Key.Evaluated.fromTuple(tupleRange.getHigh()));\n             } else {\n                 return CompletableFuture.completedFuture(null);\n             }\n         });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n+        boolean useIndexFromIndex = indexFromIndex != null && indexFromIndex.isActive();\n+        CompletableFuture<Void> buildFuture ;", "originalCommit": "659409f1cb1545818f77ee1ca0638a1a92535c20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ3NjQ0OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r536476449", "bodyText": "If you have to use exception here, yes, it should be a separate exception class. But I think a better way is to not use exception to handle it.", "author": "nblintao", "createdAt": "2020-12-05T01:40:38Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1289,24 +1294,47 @@ private boolean shouldClearExistingIndexEntries(@Nonnull IndexState indexState,\n     }\n \n     @Nonnull\n-    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n-        CompletableFuture<Void> buildFuture = buildEndpoints().thenCompose(tupleRange -> {\n+    private CompletableFuture<Void> buildIndexFromRecordsAsync() {\n+        return buildEndpoints().thenCompose(tupleRange -> {\n             if (tupleRange != null) {\n                 return buildRange(Key.Evaluated.fromTuple(tupleRange.getLow()), Key.Evaluated.fromTuple(tupleRange.getHigh()));\n             } else {\n                 return CompletableFuture.completedFuture(null);\n             }\n         });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n+        boolean useIndexFromIndex = indexFromIndex != null && indexFromIndex.isActive();\n+        CompletableFuture<Void> buildFuture ;\n+        if (useIndexFromIndex) {\n+            buildFuture = buildIndexFromIndexAsync()\n+                    .handle( (ignore, ex) ->\n+                    {\n+                        if (ex != null) {\n+                            if ( indexFromIndex.isAllowRecordsScan() &&\n+                                    // Should this exception be a distinct class?", "originalCommit": "659409f1cb1545818f77ee1ca0638a1a92535c20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ4MjIwNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r536482204", "bodyText": "The logic for continuation can be complicated considering each request can use a different source index or not use it at all, as illustrated by the chart in my design doc:\n\nI know you wanted to handle continueIfWriteOnly for indexFromIndex separately.\nBut note that the continueIfWriteOnly option is provided in the builder and client is likely to set it to true. There should be checks to forbid having continueIfWriteOnly and indexFromIndex on at the same time.\nAlso, there should be exhaustive tests to ensure this does not impact the correctness.\nFor example, if an index is started to be built by \"indexFromIndex\" (with continuation off) and stopped, then there comes another request to build by scan records with continuation on. The correct behavior for the second build is erasing the existing data and start from scratch, but the code here can't do it.\nIt's up to you to decided whether you want to have continuation as a separate change. But I feel it's not worthwhile, because you have to add more logic and more tests for something that will be replaced very soon.", "author": "nblintao", "createdAt": "2020-12-05T02:10:39Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1289,24 +1294,47 @@ private boolean shouldClearExistingIndexEntries(@Nonnull IndexState indexState,\n     }\n \n     @Nonnull\n-    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n-        CompletableFuture<Void> buildFuture = buildEndpoints().thenCompose(tupleRange -> {\n+    private CompletableFuture<Void> buildIndexFromRecordsAsync() {\n+        return buildEndpoints().thenCompose(tupleRange -> {\n             if (tupleRange != null) {\n                 return buildRange(Key.Evaluated.fromTuple(tupleRange.getLow()), Key.Evaluated.fromTuple(tupleRange.getHigh()));\n             } else {\n                 return CompletableFuture.completedFuture(null);\n             }\n         });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {", "originalCommit": "659409f1cb1545818f77ee1ca0638a1a92535c20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1OTc1OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r537759759", "bodyText": "Talked with @jjezra. He reminded me that build index with index is only enabled for idempotent indexes, so the corner case I pointed out won't affect correctness. I still feel unsafe about it but I can't find a case about it. @alecgrieser What do you think?", "author": "nblintao", "createdAt": "2020-12-07T19:12:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ4MjIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5ODg0MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r540398841", "bodyText": "For idempotent indexes, yeah, it should be safe (if a bit wasteful) to have multiple builders running at the same time and updating the same index (precisely because of the idempotency). I agree there should be tests of that, though.\nIf we ever do want to support non-idempotent indexes, we'll need the information that you mentioned in this comment. Also, if we want to support resuming a build without needing to restart all outstanding work (which is a useful property of the current index build logic), we'll also need that range information.", "author": "alecgrieser", "createdAt": "2020-12-10T18:26:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ4MjIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ4Mjc3Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r536482772", "bodyText": "Why change conditional expression to conditional operator?", "author": "nblintao", "createdAt": "2020-12-05T02:13:57Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1289,24 +1294,47 @@ private boolean shouldClearExistingIndexEntries(@Nonnull IndexState indexState,\n     }\n \n     @Nonnull\n-    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n-        CompletableFuture<Void> buildFuture = buildEndpoints().thenCompose(tupleRange -> {\n+    private CompletableFuture<Void> buildIndexFromRecordsAsync() {\n+        return buildEndpoints().thenCompose(tupleRange -> {\n             if (tupleRange != null) {\n                 return buildRange(Key.Evaluated.fromTuple(tupleRange.getLow()), Key.Evaluated.fromTuple(tupleRange.getHigh()));\n             } else {\n                 return CompletableFuture.completedFuture(null);\n             }\n         });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n+        boolean useIndexFromIndex = indexFromIndex != null && indexFromIndex.isActive();\n+        CompletableFuture<Void> buildFuture ;\n+        if (useIndexFromIndex) {\n+            buildFuture = buildIndexFromIndexAsync()\n+                    .handle( (ignore, ex) ->\n+                    {\n+                        if (ex != null) {\n+                            if ( indexFromIndex.isAllowRecordsScan() &&\n+                                    // Should this exception be a distinct class?\n+                                    ex.getMessage().contains(IndexFromIndexRequest.BAD_SRC_MESSAGE)) {\n+                                // fallback to a records scan\n+                                return buildIndexFromRecordsAsync();\n+                            }\n+                            throw FDBExceptions.wrapException(ex);\n+                        }\n+                        return AsyncUtil.DONE;\n+                    })\n+                    .thenCompose(Function.identity());\n \n-        if (markReadable) {\n-            return buildFuture.thenCompose(vignore ->\n-                getRunner().runAsync(context -> openRecordStore(context)\n-                        .thenCompose(store -> store.markIndexReadable(index))\n-                        .thenApply(ignore -> null))\n-            );\n         } else {\n-            return buildFuture;\n+            buildFuture = buildIndexFromRecordsAsync();\n         }\n+\n+        return markReadable ?", "originalCommit": "659409f1cb1545818f77ee1ca0638a1a92535c20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ4NDQ0NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r536484444", "bodyText": "Async methods should be suffixed with Async", "author": "nblintao", "createdAt": "2020-12-05T02:23:43Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2548,4 +2644,220 @@ public boolean isContinueIfWriteOnly() {\n             return continueIfWriteOnly;\n         }\n     }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexMarkBuilt(Subspace subspace) {\n+        // zz 2.1 - mark built\n+        // Grand Finale - after fully building the index, remove all missing ranges in one gulp\n+        // Note that we do not assume srcIndex has the same order as the record store, therefore did not try to handle\n+        // missing spaces (for now..)\n+        return getRunner().runAsync(context ->\n+        {\n+            RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, index.getSubspaceKey())));\n+            TransactionContext tc = context.ensureActive();\n+            return rangeSet.insertRange(tc, null, null).thenApply(bignore -> null);\n+        });\n+    }\n+\n+    private void buildIndexFromIndexThrowEx() {\n+        throw new MetaDataException(IndexFromIndexRequest.BAD_SRC_MESSAGE);\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexReadableOrThrow(FDBRecordStore store, String srcIndex) {", "originalCommit": "659409f1cb1545818f77ee1ca0638a1a92535c20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjcxNjM0Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r542716346", "bodyText": "Function removed.", "author": "jjezra", "createdAt": "2020-12-14T20:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ4NDQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ4NTg4MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r536485881", "bodyText": "It should better not be exception (as I mentioned earlier), but if it has to be, it should use include the reasons like \"source index has more than one type\", \"destination index has more than one type\", etc.", "author": "nblintao", "createdAt": "2020-12-05T02:32:22Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2548,4 +2644,220 @@ public boolean isContinueIfWriteOnly() {\n             return continueIfWriteOnly;\n         }\n     }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexMarkBuilt(Subspace subspace) {\n+        // zz 2.1 - mark built\n+        // Grand Finale - after fully building the index, remove all missing ranges in one gulp\n+        // Note that we do not assume srcIndex has the same order as the record store, therefore did not try to handle\n+        // missing spaces (for now..)\n+        return getRunner().runAsync(context ->\n+        {\n+            RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, index.getSubspaceKey())));\n+            TransactionContext tc = context.ensureActive();\n+            return rangeSet.insertRange(tc, null, null).thenApply(bignore -> null);\n+        });\n+    }\n+\n+    private void buildIndexFromIndexThrowEx() {\n+        throw new MetaDataException(IndexFromIndexRequest.BAD_SRC_MESSAGE);\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexReadableOrThrow(FDBRecordStore store, String srcIndex) {\n+        return store.getRecordStoreStateAsync()\n+                .thenCompose(state ->\n+                {\n+                    if (!state.isReadable(srcIndex)) {\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+                    return AsyncUtil.DONE;\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexAsync() {\n+        // zz 0 - sanity & trigger\n+        return getRunner().runAsync(this::openRecordStore)\n+                .thenCompose(store ->\n+                {\n+                    // first verify that both src and tgt are of a single, similar, type\n+                    final RecordMetaData metaData = store.getRecordMetaData();\n+                    final Collection<RecordType> srcRecordTypes = metaData.recordTypesForIndex(index);\n+\n+                    if ( syntheticIndex ||\n+                            recordTypes.size() != 1 ||\n+                            srcRecordTypes.size() != 1 ||\n+                            recordTypes.toArray()[0] != srcRecordTypes.toArray()[0]) {\n+\n+                        buildIndexFromIndexThrowEx();", "originalCommit": "659409f1cb1545818f77ee1ca0638a1a92535c20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ4NjQ0Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r536486443", "bodyText": "Maybe name the original buildIndexFromIndexAsync to tryToBuildIndexFromIndexAsync, and name this to buildIndexFromIndexAsync", "author": "nblintao", "createdAt": "2020-12-05T02:36:18Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2548,4 +2644,220 @@ public boolean isContinueIfWriteOnly() {\n             return continueIfWriteOnly;\n         }\n     }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexMarkBuilt(Subspace subspace) {\n+        // zz 2.1 - mark built\n+        // Grand Finale - after fully building the index, remove all missing ranges in one gulp\n+        // Note that we do not assume srcIndex has the same order as the record store, therefore did not try to handle\n+        // missing spaces (for now..)\n+        return getRunner().runAsync(context ->\n+        {\n+            RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, index.getSubspaceKey())));\n+            TransactionContext tc = context.ensureActive();\n+            return rangeSet.insertRange(tc, null, null).thenApply(bignore -> null);\n+        });\n+    }\n+\n+    private void buildIndexFromIndexThrowEx() {\n+        throw new MetaDataException(IndexFromIndexRequest.BAD_SRC_MESSAGE);\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexReadableOrThrow(FDBRecordStore store, String srcIndex) {\n+        return store.getRecordStoreStateAsync()\n+                .thenCompose(state ->\n+                {\n+                    if (!state.isReadable(srcIndex)) {\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+                    return AsyncUtil.DONE;\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexAsync() {\n+        // zz 0 - sanity & trigger\n+        return getRunner().runAsync(this::openRecordStore)\n+                .thenCompose(store ->\n+                {\n+                    // first verify that both src and tgt are of a single, similar, type\n+                    final RecordMetaData metaData = store.getRecordMetaData();\n+                    final Collection<RecordType> srcRecordTypes = metaData.recordTypesForIndex(index);\n+\n+                    if ( syntheticIndex ||\n+                            recordTypes.size() != 1 ||\n+                            srcRecordTypes.size() != 1 ||\n+                            recordTypes.toArray()[0] != srcRecordTypes.toArray()[0]) {\n+\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+\n+                    // return the build iteration. src readability & tgt/src idempotency will be verified during each iteration\n+                    return buildIndexFromIndex();\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndex() {", "originalCommit": "659409f1cb1545818f77ee1ca0638a1a92535c20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ4NjczNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r536486735", "bodyText": "Why start a new transaction?", "author": "nblintao", "createdAt": "2020-12-05T02:37:58Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2548,4 +2644,220 @@ public boolean isContinueIfWriteOnly() {\n             return continueIfWriteOnly;\n         }\n     }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexMarkBuilt(Subspace subspace) {\n+        // zz 2.1 - mark built\n+        // Grand Finale - after fully building the index, remove all missing ranges in one gulp\n+        // Note that we do not assume srcIndex has the same order as the record store, therefore did not try to handle\n+        // missing spaces (for now..)\n+        return getRunner().runAsync(context ->\n+        {\n+            RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, index.getSubspaceKey())));\n+            TransactionContext tc = context.ensureActive();\n+            return rangeSet.insertRange(tc, null, null).thenApply(bignore -> null);\n+        });\n+    }\n+\n+    private void buildIndexFromIndexThrowEx() {\n+        throw new MetaDataException(IndexFromIndexRequest.BAD_SRC_MESSAGE);\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexReadableOrThrow(FDBRecordStore store, String srcIndex) {\n+        return store.getRecordStoreStateAsync()\n+                .thenCompose(state ->\n+                {\n+                    if (!state.isReadable(srcIndex)) {\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+                    return AsyncUtil.DONE;\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexAsync() {\n+        // zz 0 - sanity & trigger\n+        return getRunner().runAsync(this::openRecordStore)\n+                .thenCompose(store ->\n+                {\n+                    // first verify that both src and tgt are of a single, similar, type\n+                    final RecordMetaData metaData = store.getRecordMetaData();\n+                    final Collection<RecordType> srcRecordTypes = metaData.recordTypesForIndex(index);\n+\n+                    if ( syntheticIndex ||\n+                            recordTypes.size() != 1 ||\n+                            srcRecordTypes.size() != 1 ||\n+                            recordTypes.toArray()[0] != srcRecordTypes.toArray()[0]) {\n+\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+\n+                    // return the build iteration. src readability & tgt/src idempotency will be verified during each iteration\n+                    return buildIndexFromIndex();\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndex() {\n+        // zz 1 - runner\n+        return getRunner().runAsync(context ->", "originalCommit": "659409f1cb1545818f77ee1ca0638a1a92535c20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE1NTkyMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r537155922", "bodyText": "To get the version and the subspace before the buildAsync iteration.\n(I repeat my question - why do we need the version? )", "author": "jjezra", "createdAt": "2020-12-07T00:05:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ4NjczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ4NjgyNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r536486825", "bodyText": "Assertion should not be in the code.", "author": "nblintao", "createdAt": "2020-12-05T02:38:51Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2548,4 +2644,220 @@ public boolean isContinueIfWriteOnly() {\n             return continueIfWriteOnly;\n         }\n     }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexMarkBuilt(Subspace subspace) {\n+        // zz 2.1 - mark built\n+        // Grand Finale - after fully building the index, remove all missing ranges in one gulp\n+        // Note that we do not assume srcIndex has the same order as the record store, therefore did not try to handle\n+        // missing spaces (for now..)\n+        return getRunner().runAsync(context ->\n+        {\n+            RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, index.getSubspaceKey())));\n+            TransactionContext tc = context.ensureActive();\n+            return rangeSet.insertRange(tc, null, null).thenApply(bignore -> null);\n+        });\n+    }\n+\n+    private void buildIndexFromIndexThrowEx() {\n+        throw new MetaDataException(IndexFromIndexRequest.BAD_SRC_MESSAGE);\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexReadableOrThrow(FDBRecordStore store, String srcIndex) {\n+        return store.getRecordStoreStateAsync()\n+                .thenCompose(state ->\n+                {\n+                    if (!state.isReadable(srcIndex)) {\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+                    return AsyncUtil.DONE;\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexAsync() {\n+        // zz 0 - sanity & trigger\n+        return getRunner().runAsync(this::openRecordStore)\n+                .thenCompose(store ->\n+                {\n+                    // first verify that both src and tgt are of a single, similar, type\n+                    final RecordMetaData metaData = store.getRecordMetaData();\n+                    final Collection<RecordType> srcRecordTypes = metaData.recordTypesForIndex(index);\n+\n+                    if ( syntheticIndex ||\n+                            recordTypes.size() != 1 ||\n+                            srcRecordTypes.size() != 1 ||\n+                            recordTypes.toArray()[0] != srcRecordTypes.toArray()[0]) {\n+\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+\n+                    // return the build iteration. src readability & tgt/src idempotency will be verified during each iteration\n+                    return buildIndexFromIndex();\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndex() {\n+        // zz 1 - runner\n+        return getRunner().runAsync(context ->\n+                context.getReadVersionAsync().thenCompose(vignore -> // Why do we need this version?\n+                {\n+                    SubspaceProvider subspaceProvider = recordStoreBuilder.getSubspaceProvider();\n+                    assert subspaceProvider != null;", "originalCommit": "659409f1cb1545818f77ee1ca0638a1a92535c20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE1NTk4MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r537155981", "bodyText": "If null, shall I throw an exception?", "author": "jjezra", "createdAt": "2020-12-07T00:06:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ4NjgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ4ODEzMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r536488132", "bodyText": "Method name overloading is used when you want different implementation for the similar task. It's confusing to make a buildIndexFromIndex call a buildIndexFromIndex.", "author": "nblintao", "createdAt": "2020-12-05T02:46:58Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2548,4 +2644,220 @@ public boolean isContinueIfWriteOnly() {\n             return continueIfWriteOnly;\n         }\n     }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexMarkBuilt(Subspace subspace) {\n+        // zz 2.1 - mark built\n+        // Grand Finale - after fully building the index, remove all missing ranges in one gulp\n+        // Note that we do not assume srcIndex has the same order as the record store, therefore did not try to handle\n+        // missing spaces (for now..)\n+        return getRunner().runAsync(context ->\n+        {\n+            RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, index.getSubspaceKey())));\n+            TransactionContext tc = context.ensureActive();\n+            return rangeSet.insertRange(tc, null, null).thenApply(bignore -> null);\n+        });\n+    }\n+\n+    private void buildIndexFromIndexThrowEx() {\n+        throw new MetaDataException(IndexFromIndexRequest.BAD_SRC_MESSAGE);\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexReadableOrThrow(FDBRecordStore store, String srcIndex) {\n+        return store.getRecordStoreStateAsync()\n+                .thenCompose(state ->\n+                {\n+                    if (!state.isReadable(srcIndex)) {\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+                    return AsyncUtil.DONE;\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexAsync() {\n+        // zz 0 - sanity & trigger\n+        return getRunner().runAsync(this::openRecordStore)\n+                .thenCompose(store ->\n+                {\n+                    // first verify that both src and tgt are of a single, similar, type\n+                    final RecordMetaData metaData = store.getRecordMetaData();\n+                    final Collection<RecordType> srcRecordTypes = metaData.recordTypesForIndex(index);\n+\n+                    if ( syntheticIndex ||\n+                            recordTypes.size() != 1 ||\n+                            srcRecordTypes.size() != 1 ||\n+                            recordTypes.toArray()[0] != srcRecordTypes.toArray()[0]) {\n+\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+\n+                    // return the build iteration. src readability & tgt/src idempotency will be verified during each iteration\n+                    return buildIndexFromIndex();\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndex() {\n+        // zz 1 - runner\n+        return getRunner().runAsync(context ->\n+                context.getReadVersionAsync().thenCompose(vignore -> // Why do we need this version?\n+                {\n+                    SubspaceProvider subspaceProvider = recordStoreBuilder.getSubspaceProvider();\n+                    assert subspaceProvider != null;\n+                    // zz 2 - subspace\n+                    return subspaceProvider.getSubspaceAsync(context)\n+                            .thenCompose(subspace ->\n+                                    buildIndexFromIndex(subspaceProvider, subspace)", "originalCommit": "659409f1cb1545818f77ee1ca0638a1a92535c20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ5MDgwNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r536490806", "bodyText": "Looks good generally but I didn't dig too deep into this method and the one below. It might be helpful to copy the code from the original path and modify it, when validating idea. But duplicated code make it impossible to find the differences (and possible issues) and keep the two path synchronized. I'll have another round of review when you finish refactoring.", "author": "nblintao", "createdAt": "2020-12-05T03:02:51Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2548,4 +2644,220 @@ public boolean isContinueIfWriteOnly() {\n             return continueIfWriteOnly;\n         }\n     }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexMarkBuilt(Subspace subspace) {\n+        // zz 2.1 - mark built\n+        // Grand Finale - after fully building the index, remove all missing ranges in one gulp\n+        // Note that we do not assume srcIndex has the same order as the record store, therefore did not try to handle\n+        // missing spaces (for now..)\n+        return getRunner().runAsync(context ->\n+        {\n+            RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, index.getSubspaceKey())));\n+            TransactionContext tc = context.ensureActive();\n+            return rangeSet.insertRange(tc, null, null).thenApply(bignore -> null);\n+        });\n+    }\n+\n+    private void buildIndexFromIndexThrowEx() {\n+        throw new MetaDataException(IndexFromIndexRequest.BAD_SRC_MESSAGE);\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexReadableOrThrow(FDBRecordStore store, String srcIndex) {\n+        return store.getRecordStoreStateAsync()\n+                .thenCompose(state ->\n+                {\n+                    if (!state.isReadable(srcIndex)) {\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+                    return AsyncUtil.DONE;\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexAsync() {\n+        // zz 0 - sanity & trigger\n+        return getRunner().runAsync(this::openRecordStore)\n+                .thenCompose(store ->\n+                {\n+                    // first verify that both src and tgt are of a single, similar, type\n+                    final RecordMetaData metaData = store.getRecordMetaData();\n+                    final Collection<RecordType> srcRecordTypes = metaData.recordTypesForIndex(index);\n+\n+                    if ( syntheticIndex ||\n+                            recordTypes.size() != 1 ||\n+                            srcRecordTypes.size() != 1 ||\n+                            recordTypes.toArray()[0] != srcRecordTypes.toArray()[0]) {\n+\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+\n+                    // return the build iteration. src readability & tgt/src idempotency will be verified during each iteration\n+                    return buildIndexFromIndex();\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndex() {\n+        // zz 1 - runner\n+        return getRunner().runAsync(context ->\n+                context.getReadVersionAsync().thenCompose(vignore -> // Why do we need this version?\n+                {\n+                    SubspaceProvider subspaceProvider = recordStoreBuilder.getSubspaceProvider();\n+                    assert subspaceProvider != null;\n+                    // zz 2 - subspace\n+                    return subspaceProvider.getSubspaceAsync(context)\n+                            .thenCompose(subspace ->\n+                                    buildIndexFromIndex(subspaceProvider, subspace)\n+                                            .thenCompose(vignore2 -> buildIndexFromIndexMarkBuilt(subspace)\n+                                            ));\n+                }));\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndex(SubspaceProvider subspaceProvider, @Nonnull Subspace subspace) {", "originalCommit": "659409f1cb1545818f77ee1ca0638a1a92535c20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQxMjY0OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r540412649", "bodyText": "You will need to set a default value in the builder to make it an nonnull.", "author": "nblintao", "createdAt": "2020-12-10T18:47:43Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -198,7 +198,7 @@\n     @Nonnull private Config config;\n     private int configLoaderInvocationCount = 0;\n \n-    private final IndexFromIndexRequest indexFromIndex;\n+    @Nonnull private final IndexFromIndexRequest indexFromIndex;", "originalCommit": "7c853b8bd3f6c4175738c2dec66fbd748ca6c65e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA4NDE1Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r541084157", "bodyText": "Shouldn't line 243 in the constructor handle this?\n  this.indexFromIndex = indexFromIndex != null ? indexFromIndex : new IndexFromIndexRequest(null);", "author": "jjezra", "createdAt": "2020-12-11T16:49:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQxMjY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0NDk2NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r541144965", "bodyText": "You can do it at https://github.com/FoundationDB/fdb-record-layer/pull/1079/files#r541144354 where all default values live", "author": "nblintao", "createdAt": "2020-12-11T18:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQxMjY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM1NzAwNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534357005", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private int configLoaderInvocationCount = 0;\n          \n          \n            \n            \n          \n          \n            \n                @Nonnull private IndexFromIndexRequest indexFromIndex;\n          \n          \n            \n                private int configLoaderInvocationCount = 0;\n          \n          \n            \n                @Nonnull private IndexFromIndexRequest indexFromIndex;\n          \n          \n            \n            \n          \n      \n    \n    \n  \n\nJust some whitespace changes", "author": "alecgrieser", "createdAt": "2020-12-02T17:39:06Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -196,6 +198,7 @@\n     @Nonnull private Config config;\n     private int configLoaderInvocationCount = 0;\n \n+    @Nonnull private IndexFromIndexRequest indexFromIndex;", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM1OTI3MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534359271", "bodyText": "I suppose this is a personal preference thing, but I think this was easier to read when it used an if block instead of a ternary operator", "author": "alecgrieser", "createdAt": "2020-12-02T17:42:28Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1289,24 +1294,44 @@ private boolean shouldClearExistingIndexEntries(@Nonnull IndexState indexState,\n     }\n \n     @Nonnull\n-    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n-        CompletableFuture<Void> buildFuture = buildEndpoints().thenCompose(tupleRange -> {\n+    private CompletableFuture<Void> buildIndexFromRecordsAsync() {\n+        return buildEndpoints().thenCompose(tupleRange -> {\n             if (tupleRange != null) {\n                 return buildRange(Key.Evaluated.fromTuple(tupleRange.getLow()), Key.Evaluated.fromTuple(tupleRange.getHigh()));\n             } else {\n                 return CompletableFuture.completedFuture(null);\n             }\n         });\n+    }\n \n-        if (markReadable) {\n-            return buildFuture.thenCompose(vignore ->\n-                getRunner().runAsync(context -> openRecordStore(context)\n-                        .thenCompose(store -> store.markIndexReadable(index))\n-                        .thenApply(ignore -> null))\n-            );\n-        } else {\n-            return buildFuture;\n-        }\n+    @Nonnull\n+    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n+        boolean useIndexFromIndex = indexFromIndex != null && indexFromIndex.isActive();\n+        CompletableFuture<Void> buildFuture =\n+                ! useIndexFromIndex  ?\n+                buildIndexFromRecordsAsync() :\n+                buildIndexFromIndexAsync()\n+                        .handle( (ignore, ex) ->\n+                        {\n+                            if (ex != null) {\n+                                if ( indexFromIndex.isAllowRecordsScan() &&\n+                                         // Should this exception be a distinct class?\n+                                         ex.getMessage().contains(IndexFromIndexRequest.BAD_SRC_MESSAGE)) {\n+                                    // fallback to a records scan\n+                                    return buildIndexFromRecordsAsync();\n+                                }\n+                                throw FDBExceptions.wrapException(ex);\n+                            }\n+                            return AsyncUtil.DONE;\n+                        })\n+                        .thenCompose(Function.identity());\n+\n+        return markReadable ?", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM2MDEyOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534360128", "bodyText": "I suspect this would be easier to read if it used an if block instead of a ternary operator (especially as there's real business logic here and it's not just choosing between two values).", "author": "alecgrieser", "createdAt": "2020-12-02T17:43:53Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1289,24 +1294,44 @@ private boolean shouldClearExistingIndexEntries(@Nonnull IndexState indexState,\n     }\n \n     @Nonnull\n-    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n-        CompletableFuture<Void> buildFuture = buildEndpoints().thenCompose(tupleRange -> {\n+    private CompletableFuture<Void> buildIndexFromRecordsAsync() {\n+        return buildEndpoints().thenCompose(tupleRange -> {\n             if (tupleRange != null) {\n                 return buildRange(Key.Evaluated.fromTuple(tupleRange.getLow()), Key.Evaluated.fromTuple(tupleRange.getHigh()));\n             } else {\n                 return CompletableFuture.completedFuture(null);\n             }\n         });\n+    }\n \n-        if (markReadable) {\n-            return buildFuture.thenCompose(vignore ->\n-                getRunner().runAsync(context -> openRecordStore(context)\n-                        .thenCompose(store -> store.markIndexReadable(index))\n-                        .thenApply(ignore -> null))\n-            );\n-        } else {\n-            return buildFuture;\n-        }\n+    @Nonnull\n+    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n+        boolean useIndexFromIndex = indexFromIndex != null && indexFromIndex.isActive();\n+        CompletableFuture<Void> buildFuture =", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM2MTA0OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534361048", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    .handle( (ignore, ex) ->\n          \n          \n            \n                                    {\n          \n          \n            \n                                    .handle( (ignore, ex) -> {", "author": "alecgrieser", "createdAt": "2020-12-02T17:45:14Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1289,24 +1294,44 @@ private boolean shouldClearExistingIndexEntries(@Nonnull IndexState indexState,\n     }\n \n     @Nonnull\n-    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n-        CompletableFuture<Void> buildFuture = buildEndpoints().thenCompose(tupleRange -> {\n+    private CompletableFuture<Void> buildIndexFromRecordsAsync() {\n+        return buildEndpoints().thenCompose(tupleRange -> {\n             if (tupleRange != null) {\n                 return buildRange(Key.Evaluated.fromTuple(tupleRange.getLow()), Key.Evaluated.fromTuple(tupleRange.getHigh()));\n             } else {\n                 return CompletableFuture.completedFuture(null);\n             }\n         });\n+    }\n \n-        if (markReadable) {\n-            return buildFuture.thenCompose(vignore ->\n-                getRunner().runAsync(context -> openRecordStore(context)\n-                        .thenCompose(store -> store.markIndexReadable(index))\n-                        .thenApply(ignore -> null))\n-            );\n-        } else {\n-            return buildFuture;\n-        }\n+    @Nonnull\n+    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n+        boolean useIndexFromIndex = indexFromIndex != null && indexFromIndex.isActive();\n+        CompletableFuture<Void> buildFuture =\n+                ! useIndexFromIndex  ?\n+                buildIndexFromRecordsAsync() :\n+                buildIndexFromIndexAsync()\n+                        .handle( (ignore, ex) ->\n+                        {", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM2MTE4Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534361182", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            if ( indexFromIndex.isAllowRecordsScan() &&\n          \n          \n            \n                                            if (indexFromIndex.isAllowRecordsScan() &&", "author": "alecgrieser", "createdAt": "2020-12-02T17:45:23Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1289,24 +1294,44 @@ private boolean shouldClearExistingIndexEntries(@Nonnull IndexState indexState,\n     }\n \n     @Nonnull\n-    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n-        CompletableFuture<Void> buildFuture = buildEndpoints().thenCompose(tupleRange -> {\n+    private CompletableFuture<Void> buildIndexFromRecordsAsync() {\n+        return buildEndpoints().thenCompose(tupleRange -> {\n             if (tupleRange != null) {\n                 return buildRange(Key.Evaluated.fromTuple(tupleRange.getLow()), Key.Evaluated.fromTuple(tupleRange.getHigh()));\n             } else {\n                 return CompletableFuture.completedFuture(null);\n             }\n         });\n+    }\n \n-        if (markReadable) {\n-            return buildFuture.thenCompose(vignore ->\n-                getRunner().runAsync(context -> openRecordStore(context)\n-                        .thenCompose(store -> store.markIndexReadable(index))\n-                        .thenApply(ignore -> null))\n-            );\n-        } else {\n-            return buildFuture;\n-        }\n+    @Nonnull\n+    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n+        boolean useIndexFromIndex = indexFromIndex != null && indexFromIndex.isActive();\n+        CompletableFuture<Void> buildFuture =\n+                ! useIndexFromIndex  ?\n+                buildIndexFromRecordsAsync() :\n+                buildIndexFromIndexAsync()\n+                        .handle( (ignore, ex) ->\n+                        {\n+                            if (ex != null) {\n+                                if ( indexFromIndex.isAllowRecordsScan() &&", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM2MjMyMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534362320", "bodyText": "Yeah, I think this should be a distinct class. One thing to watch out for is that completable futures can wrap errors in CompletionException and ExecutionException errors, so the logic might need to be something like \"unwrap the exception and look for a cause of the right type\" rather than just a simple instanceof check.", "author": "alecgrieser", "createdAt": "2020-12-02T17:47:05Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1289,24 +1294,44 @@ private boolean shouldClearExistingIndexEntries(@Nonnull IndexState indexState,\n     }\n \n     @Nonnull\n-    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n-        CompletableFuture<Void> buildFuture = buildEndpoints().thenCompose(tupleRange -> {\n+    private CompletableFuture<Void> buildIndexFromRecordsAsync() {\n+        return buildEndpoints().thenCompose(tupleRange -> {\n             if (tupleRange != null) {\n                 return buildRange(Key.Evaluated.fromTuple(tupleRange.getLow()), Key.Evaluated.fromTuple(tupleRange.getHigh()));\n             } else {\n                 return CompletableFuture.completedFuture(null);\n             }\n         });\n+    }\n \n-        if (markReadable) {\n-            return buildFuture.thenCompose(vignore ->\n-                getRunner().runAsync(context -> openRecordStore(context)\n-                        .thenCompose(store -> store.markIndexReadable(index))\n-                        .thenApply(ignore -> null))\n-            );\n-        } else {\n-            return buildFuture;\n-        }\n+    @Nonnull\n+    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n+        boolean useIndexFromIndex = indexFromIndex != null && indexFromIndex.isActive();\n+        CompletableFuture<Void> buildFuture =\n+                ! useIndexFromIndex  ?\n+                buildIndexFromRecordsAsync() :\n+                buildIndexFromIndexAsync()\n+                        .handle( (ignore, ex) ->\n+                        {\n+                            if (ex != null) {\n+                                if ( indexFromIndex.isAllowRecordsScan() &&\n+                                         // Should this exception be a distinct class?\n+                                         ex.getMessage().contains(IndexFromIndexRequest.BAD_SRC_MESSAGE)) {", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIyNjY1OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r541226658", "bodyText": "Is there an example of such \"unwrap the exception and ... \" op?", "author": "jjezra", "createdAt": "2020-12-11T20:01:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM2MjMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM2MjU4NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534362584", "bodyText": "Is this allowed? Doesn't it need to clear out the built ranges (if the index being used orders records differently than the primary key, at least)?", "author": "alecgrieser", "createdAt": "2020-12-02T17:47:30Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1289,24 +1294,44 @@ private boolean shouldClearExistingIndexEntries(@Nonnull IndexState indexState,\n     }\n \n     @Nonnull\n-    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n-        CompletableFuture<Void> buildFuture = buildEndpoints().thenCompose(tupleRange -> {\n+    private CompletableFuture<Void> buildIndexFromRecordsAsync() {\n+        return buildEndpoints().thenCompose(tupleRange -> {\n             if (tupleRange != null) {\n                 return buildRange(Key.Evaluated.fromTuple(tupleRange.getLow()), Key.Evaluated.fromTuple(tupleRange.getHigh()));\n             } else {\n                 return CompletableFuture.completedFuture(null);\n             }\n         });\n+    }\n \n-        if (markReadable) {\n-            return buildFuture.thenCompose(vignore ->\n-                getRunner().runAsync(context -> openRecordStore(context)\n-                        .thenCompose(store -> store.markIndexReadable(index))\n-                        .thenApply(ignore -> null))\n-            );\n-        } else {\n-            return buildFuture;\n-        }\n+    @Nonnull\n+    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n+        boolean useIndexFromIndex = indexFromIndex != null && indexFromIndex.isActive();\n+        CompletableFuture<Void> buildFuture =\n+                ! useIndexFromIndex  ?\n+                buildIndexFromRecordsAsync() :\n+                buildIndexFromIndexAsync()\n+                        .handle( (ignore, ex) ->\n+                        {\n+                            if (ex != null) {\n+                                if ( indexFromIndex.isAllowRecordsScan() &&\n+                                         // Should this exception be a distinct class?\n+                                         ex.getMessage().contains(IndexFromIndexRequest.BAD_SRC_MESSAGE)) {\n+                                    // fallback to a records scan\n+                                    return buildIndexFromRecordsAsync();", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI0MjU1OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r541242559", "bodyText": "To my understanding - no.\nThe index scan does not make any updates on the build ranges until it's all done. Therefore the record scan can continue from whatever valid state the built ranges was in, when this function was called. We can think about it this way - the built ranges only reflects the records scan indexing's state. I works because index scan is allowed only for idempotent indexes.\nI have a radar to change this later on, and let the built ranges be aware of which type of indexing state it is reflecting. I'm not sure if it'll be 'either' or 'both'.", "author": "jjezra", "createdAt": "2020-12-11T20:17:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM2MjU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM2MzU1Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534363552", "bodyText": "minor: I think this .handle and .thenCompose(Function.identity()) can be replaced with AsyncUtil.composeHandle", "author": "alecgrieser", "createdAt": "2020-12-02T17:48:56Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1289,24 +1294,44 @@ private boolean shouldClearExistingIndexEntries(@Nonnull IndexState indexState,\n     }\n \n     @Nonnull\n-    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n-        CompletableFuture<Void> buildFuture = buildEndpoints().thenCompose(tupleRange -> {\n+    private CompletableFuture<Void> buildIndexFromRecordsAsync() {\n+        return buildEndpoints().thenCompose(tupleRange -> {\n             if (tupleRange != null) {\n                 return buildRange(Key.Evaluated.fromTuple(tupleRange.getLow()), Key.Evaluated.fromTuple(tupleRange.getHigh()));\n             } else {\n                 return CompletableFuture.completedFuture(null);\n             }\n         });\n+    }\n \n-        if (markReadable) {\n-            return buildFuture.thenCompose(vignore ->\n-                getRunner().runAsync(context -> openRecordStore(context)\n-                        .thenCompose(store -> store.markIndexReadable(index))\n-                        .thenApply(ignore -> null))\n-            );\n-        } else {\n-            return buildFuture;\n-        }\n+    @Nonnull\n+    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n+        boolean useIndexFromIndex = indexFromIndex != null && indexFromIndex.isActive();\n+        CompletableFuture<Void> buildFuture =\n+                ! useIndexFromIndex  ?\n+                buildIndexFromRecordsAsync() :\n+                buildIndexFromIndexAsync()\n+                        .handle( (ignore, ex) ->\n+                        {\n+                            if (ex != null) {\n+                                if ( indexFromIndex.isAllowRecordsScan() &&\n+                                         // Should this exception be a distinct class?\n+                                         ex.getMessage().contains(IndexFromIndexRequest.BAD_SRC_MESSAGE)) {\n+                                    // fallback to a records scan\n+                                    return buildIndexFromRecordsAsync();\n+                                }\n+                                throw FDBExceptions.wrapException(ex);\n+                            }\n+                            return AsyncUtil.DONE;\n+                        })\n+                        .thenCompose(Function.identity());", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM2ODgyOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534368828", "bodyText": "I think you can replace getting the store state with calling FDBRecordStore::isIndexReadable.\nTechnically, there are some blocking methods in the stack there, if that's the concern, however, those methods shouldn't block if one has already opened the record store (which needs to happen anyway or there are more serious problems), so using those methods are fine (even in an async callback)", "author": "alecgrieser", "createdAt": "2020-12-02T17:56:40Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2548,4 +2641,220 @@ public boolean isContinueIfWriteOnly() {\n             return continueIfWriteOnly;\n         }\n     }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexMarkBuilt(Subspace subspace) {\n+        // zz 2.1 - mark built\n+        // Grand Finale - after fully building the index, remove all missing ranges in one gulp\n+        // Note that we do not assume srcIndex has the same order as the record store, therefore did not try to handle\n+        // missing spaces (for now..)\n+        return getRunner().runAsync(context ->\n+        {\n+            RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, index.getSubspaceKey())));\n+            TransactionContext tc = context.ensureActive();\n+            return rangeSet.insertRange(tc, null, null).thenApply(bignore -> null);\n+        });\n+    }\n+\n+    private void buildIndexFromIndexThrowEx() {\n+        throw new MetaDataException(IndexFromIndexRequest.BAD_SRC_MESSAGE);\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexReadableOrThrow(FDBRecordStore store, String srcIndex) {\n+        return store.getRecordStoreStateAsync()\n+                .thenCompose(state ->\n+                {\n+                    if (!state.isReadable(srcIndex)) {", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI1NDUyNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r541254527", "bodyText": "Yes, that was my concern. I'll change the code for this function with a comment explaining why it wouldn't block.", "author": "jjezra", "createdAt": "2020-12-11T20:28:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM2ODgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM2OTY1MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534369650", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private String sourceIndex;\n          \n          \n            \n                    @Nullable private String sourceIndex;", "author": "alecgrieser", "createdAt": "2020-12-02T17:57:49Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2479,6 +2517,61 @@ private static void checkPositive(int value, String desc) {\n         }\n     }\n \n+    /**\n+     * A builder for the  indexFromIndex request. Allow caller to request that:\n+     *  1. The index will be scanned from another index.\n+     *  2. Whether the indexer will fail or perform a records scan, would the target index not not\n+     *     appropraite for the job.\n+     */\n+    public static class IndexFromIndexRequest {\n+        public static final String BAD_SRC_MESSAGE = \"Source index cannot be used\";\n+        private String sourceIndex;", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM2OTc0Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534369743", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public IndexFromIndexRequest(String sourceIndex) {\n          \n          \n            \n                    public IndexFromIndexRequest(@Nullable String sourceIndex) {", "author": "alecgrieser", "createdAt": "2020-12-02T17:57:57Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2479,6 +2517,61 @@ private static void checkPositive(int value, String desc) {\n         }\n     }\n \n+    /**\n+     * A builder for the  indexFromIndex request. Allow caller to request that:\n+     *  1. The index will be scanned from another index.\n+     *  2. Whether the indexer will fail or perform a records scan, would the target index not not\n+     *     appropraite for the job.\n+     */\n+    public static class IndexFromIndexRequest {\n+        public static final String BAD_SRC_MESSAGE = \"Source index cannot be used\";\n+        private String sourceIndex;\n+        private boolean allowRecordsScan;\n+\n+        /**\n+         * Build the index from a source index. Source index must be readable, idempotent, and fully cover the target index.\n+         * @param sourceIndex source index\n+         */\n+        public IndexFromIndexRequest(String sourceIndex) {", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEyNzM0NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r541127345", "bodyText": "I think it would be safer to change this into\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public IndexFromIndexRequest(String sourceIndex) {\n          \n          \n            \n                    public IndexFromIndexRequest(@Nonnull String sourceIndex) {\n          \n      \n    \n    \n  \n\nand then have something like\nprivate IndexFromIndexRequest() {\n    this.sourceIndex = null;\n}\n\npublic static final IndexFromIndexRequest  NOT_INDEX_FROM_INDEX = new IndexFromIndexRequest();", "author": "nblintao", "createdAt": "2020-12-11T17:59:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM2OTc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3MDk4Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534370983", "bodyText": "There's another comment about using a class for this this error, but it also seems like this isn't really a MetaDataException (which I think is generally used for things like if there are illegal types in the meta-data or if, say, an index specified by name isn't present in the meta-data), but not for things like \"the index isn't built\".", "author": "alecgrieser", "createdAt": "2020-12-02T17:59:36Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2548,4 +2641,220 @@ public boolean isContinueIfWriteOnly() {\n             return continueIfWriteOnly;\n         }\n     }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexMarkBuilt(Subspace subspace) {\n+        // zz 2.1 - mark built\n+        // Grand Finale - after fully building the index, remove all missing ranges in one gulp\n+        // Note that we do not assume srcIndex has the same order as the record store, therefore did not try to handle\n+        // missing spaces (for now..)\n+        return getRunner().runAsync(context ->\n+        {\n+            RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, index.getSubspaceKey())));\n+            TransactionContext tc = context.ensureActive();\n+            return rangeSet.insertRange(tc, null, null).thenApply(bignore -> null);\n+        });\n+    }\n+\n+    private void buildIndexFromIndexThrowEx() {\n+        throw new MetaDataException(IndexFromIndexRequest.BAD_SRC_MESSAGE);", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwMTY3NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534501674", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * (optional) add an IndexFromIndex policy. This will be used to build the target index from a\n          \n          \n            \n                     * source index, avoiding records scan.\n          \n          \n            \n                     * Add an {@link IndexFromIndexRequest} policy. If set, this will be used to build the target index from a\n          \n          \n            \n                     * source index, avoiding a full record scan. This parameter is optional.\n          \n      \n    \n    \n  \n\nSomething like that. I'm not dead set on this wording, but I think we want to at least have parallelism with the other javadoc blurbs on this class.", "author": "alecgrieser", "createdAt": "2020-12-02T21:44:43Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2156,6 +2183,17 @@ public Builder setIncreaseLimitAfter(int increaseLimitAfter) {\n             return this;\n         }\n \n+        /**\n+         * (optional) add an IndexFromIndex policy. This will be used to build the target index from a\n+         * source index, avoiding records scan.", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwNTMxNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534505314", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * @return True if records scan is allowed\n          \n          \n            \n                     * @return {@code true} if a record scan is allowed", "author": "alecgrieser", "createdAt": "2020-12-02T21:51:27Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2479,6 +2517,61 @@ private static void checkPositive(int value, String desc) {\n         }\n     }\n \n+    /**\n+     * A builder for the  indexFromIndex request. Allow caller to request that:\n+     *  1. The index will be scanned from another index.\n+     *  2. Whether the indexer will fail or perform a records scan, would the target index not not\n+     *     appropraite for the job.\n+     */\n+    public static class IndexFromIndexRequest {\n+        public static final String BAD_SRC_MESSAGE = \"Source index cannot be used\";\n+        private String sourceIndex;\n+        private boolean allowRecordsScan;\n+\n+        /**\n+         * Build the index from a source index. Source index must be readable, idempotent, and fully cover the target index.\n+         * @param sourceIndex source index\n+         */\n+        public IndexFromIndexRequest(String sourceIndex) {\n+            this.sourceIndex = sourceIndex;\n+            this.allowRecordsScan = true;\n+        }\n+\n+        /**\n+         * After calling this function, throw an exception if the source index cannot be used to build the target index.\n+         * The default behaviour (if this function isn't called) would be performing a full record scan.\n+         * @return this builder\n+         */\n+        public IndexFromIndexRequest mustUseSourceIndex() {\n+            this.allowRecordsScan = false;\n+            return this;\n+        }\n+\n+        /**\n+         * Check if active.\n+         * @return True if active\n+         */\n+        public boolean isActive() {\n+            return sourceIndex != null;\n+        }\n+\n+        /**\n+         * If active, get the source index.\n+         * @return source index name\n+         */\n+        public String getSourceIndex() {\n+            return sourceIndex;\n+        }\n+\n+        /**\n+         * If source index is not available, check if allowed to scan the records.\n+         * @return True if records scan is allowed", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwNTQzNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534505435", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private boolean allowRecordsScan;\n          \n          \n            \n                    private boolean allowRecordScan;", "author": "alecgrieser", "createdAt": "2020-12-02T21:51:40Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2479,6 +2517,61 @@ private static void checkPositive(int value, String desc) {\n         }\n     }\n \n+    /**\n+     * A builder for the  indexFromIndex request. Allow caller to request that:\n+     *  1. The index will be scanned from another index.\n+     *  2. Whether the indexer will fail or perform a records scan, would the target index not not\n+     *     appropraite for the job.\n+     */\n+    public static class IndexFromIndexRequest {\n+        public static final String BAD_SRC_MESSAGE = \"Source index cannot be used\";\n+        private String sourceIndex;\n+        private boolean allowRecordsScan;", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwNTcyMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534505722", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public String getSourceIndex() {\n          \n          \n            \n                    @Nullable\n          \n          \n            \n                    public String getSourceIndex() {", "author": "alecgrieser", "createdAt": "2020-12-02T21:52:11Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2479,6 +2517,61 @@ private static void checkPositive(int value, String desc) {\n         }\n     }\n \n+    /**\n+     * A builder for the  indexFromIndex request. Allow caller to request that:\n+     *  1. The index will be scanned from another index.\n+     *  2. Whether the indexer will fail or perform a records scan, would the target index not not\n+     *     appropraite for the job.\n+     */\n+    public static class IndexFromIndexRequest {\n+        public static final String BAD_SRC_MESSAGE = \"Source index cannot be used\";\n+        private String sourceIndex;\n+        private boolean allowRecordsScan;\n+\n+        /**\n+         * Build the index from a source index. Source index must be readable, idempotent, and fully cover the target index.\n+         * @param sourceIndex source index\n+         */\n+        public IndexFromIndexRequest(String sourceIndex) {\n+            this.sourceIndex = sourceIndex;\n+            this.allowRecordsScan = true;\n+        }\n+\n+        /**\n+         * After calling this function, throw an exception if the source index cannot be used to build the target index.\n+         * The default behaviour (if this function isn't called) would be performing a full record scan.\n+         * @return this builder\n+         */\n+        public IndexFromIndexRequest mustUseSourceIndex() {\n+            this.allowRecordsScan = false;\n+            return this;\n+        }\n+\n+        /**\n+         * Check if active.\n+         * @return True if active\n+         */\n+        public boolean isActive() {\n+            return sourceIndex != null;\n+        }\n+\n+        /**\n+         * If active, get the source index.\n+         * @return source index name\n+         */\n+        public String getSourceIndex() {", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwNjExNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534506114", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public boolean isAllowRecordsScan() {\n          \n          \n            \n                        return allowRecordsScan;\n          \n          \n            \n                    public boolean isAllowRecordScan() {\n          \n          \n            \n                        return allowRecordScan;", "author": "alecgrieser", "createdAt": "2020-12-02T21:52:52Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2479,6 +2517,61 @@ private static void checkPositive(int value, String desc) {\n         }\n     }\n \n+    /**\n+     * A builder for the  indexFromIndex request. Allow caller to request that:\n+     *  1. The index will be scanned from another index.\n+     *  2. Whether the indexer will fail or perform a records scan, would the target index not not\n+     *     appropraite for the job.\n+     */\n+    public static class IndexFromIndexRequest {\n+        public static final String BAD_SRC_MESSAGE = \"Source index cannot be used\";\n+        private String sourceIndex;\n+        private boolean allowRecordsScan;\n+\n+        /**\n+         * Build the index from a source index. Source index must be readable, idempotent, and fully cover the target index.\n+         * @param sourceIndex source index\n+         */\n+        public IndexFromIndexRequest(String sourceIndex) {\n+            this.sourceIndex = sourceIndex;\n+            this.allowRecordsScan = true;\n+        }\n+\n+        /**\n+         * After calling this function, throw an exception if the source index cannot be used to build the target index.\n+         * The default behaviour (if this function isn't called) would be performing a full record scan.\n+         * @return this builder\n+         */\n+        public IndexFromIndexRequest mustUseSourceIndex() {\n+            this.allowRecordsScan = false;\n+            return this;\n+        }\n+\n+        /**\n+         * Check if active.\n+         * @return True if active\n+         */\n+        public boolean isActive() {\n+            return sourceIndex != null;\n+        }\n+\n+        /**\n+         * If active, get the source index.\n+         * @return source index name\n+         */\n+        public String getSourceIndex() {\n+            return sourceIndex;\n+        }\n+\n+        /**\n+         * If source index is not available, check if allowed to scan the records.\n+         * @return True if records scan is allowed\n+         */\n+        public boolean isAllowRecordsScan() {\n+            return allowRecordsScan;", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwNzA0MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534507040", "bodyText": "Something about this abstraction feels wonky to me. I don't think I like that it's mentioning a \"request\" here, just because that term seems to be a term of art for, like, \"request made over some network interface\", which isn't really necessary here. Maybe IndexFromIndexPolicy?\nIt also feels like this should be an immutable object (perhaps one with a builder) rather than a mutable class.", "author": "alecgrieser", "createdAt": "2020-12-02T21:54:31Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2479,6 +2517,61 @@ private static void checkPositive(int value, String desc) {\n         }\n     }\n \n+    /**\n+     * A builder for the  indexFromIndex request. Allow caller to request that:\n+     *  1. The index will be scanned from another index.\n+     *  2. Whether the indexer will fail or perform a records scan, would the target index not not\n+     *     appropraite for the job.\n+     */\n+    public static class IndexFromIndexRequest {", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAwMzQzMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r542003431", "bodyText": "Changed to IndexFromIndexPolicy (I like this name much better).\nAbout the immutable object - we could as well make the IndexFromIndexPolicy a builder (mutable, by definition), then use it to set final values in OnlineIndexer.\n@nblintao, what do you think?", "author": "jjezra", "createdAt": "2020-12-13T20:53:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwNzA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU5ODQ4MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r542598481", "bodyText": "I agree with @alecgrieser that IndexFromIndexPolicy can simply be an immutable object with builder.", "author": "nblintao", "createdAt": "2020-12-14T18:11:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwNzA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwNzgxMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534507813", "bodyText": "This javadoc needs some wordsmithing, but I think we're also not exactly settled on the right abstraction for this, so willing to wait on getting that done first.", "author": "alecgrieser", "createdAt": "2020-12-02T21:55:51Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2479,6 +2517,61 @@ private static void checkPositive(int value, String desc) {\n         }\n     }\n \n+    /**\n+     * A builder for the  indexFromIndex request. Allow caller to request that:\n+     *  1. The index will be scanned from another index.\n+     *  2. Whether the indexer will fail or perform a records scan, would the target index not not\n+     *     appropraite for the job.", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxMDIwNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534510206", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        recordTypes.toArray()[0] != srcRecordTypes.toArray()[0]) {\n          \n          \n            \n                                        recordTypes.get(0) != srcRecordTypes.get(0)) {\n          \n      \n    \n    \n  \n\nAnd is that supposed to be pointer equality or .equals equality?", "author": "alecgrieser", "createdAt": "2020-12-02T21:59:49Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2548,4 +2641,220 @@ public boolean isContinueIfWriteOnly() {\n             return continueIfWriteOnly;\n         }\n     }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexMarkBuilt(Subspace subspace) {\n+        // zz 2.1 - mark built\n+        // Grand Finale - after fully building the index, remove all missing ranges in one gulp\n+        // Note that we do not assume srcIndex has the same order as the record store, therefore did not try to handle\n+        // missing spaces (for now..)\n+        return getRunner().runAsync(context ->\n+        {\n+            RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, index.getSubspaceKey())));\n+            TransactionContext tc = context.ensureActive();\n+            return rangeSet.insertRange(tc, null, null).thenApply(bignore -> null);\n+        });\n+    }\n+\n+    private void buildIndexFromIndexThrowEx() {\n+        throw new MetaDataException(IndexFromIndexRequest.BAD_SRC_MESSAGE);\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexReadableOrThrow(FDBRecordStore store, String srcIndex) {\n+        return store.getRecordStoreStateAsync()\n+                .thenCompose(state ->\n+                {\n+                    if (!state.isReadable(srcIndex)) {\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+                    return AsyncUtil.DONE;\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexAsync() {\n+        // zz 0 - sanity & trigger\n+        return getRunner().runAsync(this::openRecordStore)\n+                .thenCompose(store ->\n+                {\n+                    // first verify that both src and tgt are of a single, similar, type\n+                    final RecordMetaData metaData = store.getRecordMetaData();\n+                    final Collection<RecordType> srcRecordTypes = metaData.recordTypesForIndex(index);\n+\n+                    if ( syntheticIndex ||\n+                            recordTypes.size() != 1 ||\n+                            srcRecordTypes.size() != 1 ||\n+                            recordTypes.toArray()[0] != srcRecordTypes.toArray()[0]) {", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAwNDY5OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r542004699", "bodyText": "\"Cannot resolve method 'get' in 'Collection'\"\nHow about recordTypes.equals(srcRecordTypes)?", "author": "jjezra", "createdAt": "2020-12-13T21:01:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxMDIwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAxMTM5NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r542011395", "bodyText": "This equals doesn't work. I suppose it's safer to compare by pointer.", "author": "jjezra", "createdAt": "2020-12-13T21:40:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxMDIwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY0MTgzMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r542641833", "bodyText": "As to why .get() doesn't work, I guess that's because record types is a Collection rather than List, which makes some amount of sense...\nWhy doesn't .equals work? That seems like what we \"should\" be using, in some sense.", "author": "alecgrieser", "createdAt": "2020-12-14T18:53:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxMDIwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg0NjE1NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r542846154", "bodyText": "Shouldn't we implement an equals method in RecordType to make it work as expected?", "author": "jjezra", "createdAt": "2020-12-14T22:02:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxMDIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxMDU0OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534510549", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .thenCompose(store ->\n          \n          \n            \n                            {\n          \n          \n            \n                            .thenCompose(store -> {\n          \n      \n    \n    \n  \n\nThere are other instances where the brace style isn't quite right that should probably be cleaned up, too.", "author": "alecgrieser", "createdAt": "2020-12-02T22:00:27Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2548,4 +2641,220 @@ public boolean isContinueIfWriteOnly() {\n             return continueIfWriteOnly;\n         }\n     }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexMarkBuilt(Subspace subspace) {\n+        // zz 2.1 - mark built\n+        // Grand Finale - after fully building the index, remove all missing ranges in one gulp\n+        // Note that we do not assume srcIndex has the same order as the record store, therefore did not try to handle\n+        // missing spaces (for now..)\n+        return getRunner().runAsync(context ->\n+        {\n+            RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, index.getSubspaceKey())));\n+            TransactionContext tc = context.ensureActive();\n+            return rangeSet.insertRange(tc, null, null).thenApply(bignore -> null);\n+        });\n+    }\n+\n+    private void buildIndexFromIndexThrowEx() {\n+        throw new MetaDataException(IndexFromIndexRequest.BAD_SRC_MESSAGE);\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexReadableOrThrow(FDBRecordStore store, String srcIndex) {\n+        return store.getRecordStoreStateAsync()\n+                .thenCompose(state ->\n+                {\n+                    if (!state.isReadable(srcIndex)) {\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+                    return AsyncUtil.DONE;\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexAsync() {\n+        // zz 0 - sanity & trigger\n+        return getRunner().runAsync(this::openRecordStore)\n+                .thenCompose(store ->\n+                {", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxMjI1OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534512259", "bodyText": "If there are instances where we call getReadVersion and ignore the result, it's generally so that we can instrument them and differentiate latency from getting the read version and latency from other sources.", "author": "alecgrieser", "createdAt": "2020-12-02T22:03:46Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2548,4 +2641,220 @@ public boolean isContinueIfWriteOnly() {\n             return continueIfWriteOnly;\n         }\n     }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexMarkBuilt(Subspace subspace) {\n+        // zz 2.1 - mark built\n+        // Grand Finale - after fully building the index, remove all missing ranges in one gulp\n+        // Note that we do not assume srcIndex has the same order as the record store, therefore did not try to handle\n+        // missing spaces (for now..)\n+        return getRunner().runAsync(context ->\n+        {\n+            RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, index.getSubspaceKey())));\n+            TransactionContext tc = context.ensureActive();\n+            return rangeSet.insertRange(tc, null, null).thenApply(bignore -> null);\n+        });\n+    }\n+\n+    private void buildIndexFromIndexThrowEx() {\n+        throw new MetaDataException(IndexFromIndexRequest.BAD_SRC_MESSAGE);\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexReadableOrThrow(FDBRecordStore store, String srcIndex) {\n+        return store.getRecordStoreStateAsync()\n+                .thenCompose(state ->\n+                {\n+                    if (!state.isReadable(srcIndex)) {\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+                    return AsyncUtil.DONE;\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexAsync() {\n+        // zz 0 - sanity & trigger\n+        return getRunner().runAsync(this::openRecordStore)\n+                .thenCompose(store ->\n+                {\n+                    // first verify that both src and tgt are of a single, similar, type\n+                    final RecordMetaData metaData = store.getRecordMetaData();\n+                    final Collection<RecordType> srcRecordTypes = metaData.recordTypesForIndex(index);\n+\n+                    if ( syntheticIndex ||\n+                            recordTypes.size() != 1 ||\n+                            srcRecordTypes.size() != 1 ||\n+                            recordTypes.toArray()[0] != srcRecordTypes.toArray()[0]) {\n+\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+\n+                    // return the build iteration. src readability & tgt/src idempotency will be verified during each iteration\n+                    return buildIndexFromIndex();\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndex() {\n+        // zz 1 - runner\n+        return getRunner().runAsync(context ->\n+                context.getReadVersionAsync().thenCompose(vignore -> // Why do we need this version?", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxMzYzMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534513633", "bodyText": "I believe the way the code is laid out in this class, we'll want to move these methods up to be before the builder so they're closer to the other methods. I propose that there should be some more heavyweight refactoring in a different comment, but at the very least, these methods should next to their non-FromIndex counterparts.", "author": "alecgrieser", "createdAt": "2020-12-02T22:06:19Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2548,4 +2641,220 @@ public boolean isContinueIfWriteOnly() {\n             return continueIfWriteOnly;\n         }\n     }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexMarkBuilt(Subspace subspace) {", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxNTY5Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534515693", "bodyText": "Yes and no. You're correct that if one wants to sustain an exact target records per second rate, then yeah, the time spent during the iteration should be factored in. But this wasn't just an oversite, but more of a deliberate decision, as this way, if the database slows down under load, the index build also naturally decreases the amount of work it actually gets done per second.\nThat being said it's not the first time this has confused someone, so maybe that decision was wrong.", "author": "alecgrieser", "createdAt": "2020-12-02T22:10:18Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2548,4 +2641,220 @@ public boolean isContinueIfWriteOnly() {\n             return continueIfWriteOnly;\n         }\n     }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexMarkBuilt(Subspace subspace) {\n+        // zz 2.1 - mark built\n+        // Grand Finale - after fully building the index, remove all missing ranges in one gulp\n+        // Note that we do not assume srcIndex has the same order as the record store, therefore did not try to handle\n+        // missing spaces (for now..)\n+        return getRunner().runAsync(context ->\n+        {\n+            RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, index.getSubspaceKey())));\n+            TransactionContext tc = context.ensureActive();\n+            return rangeSet.insertRange(tc, null, null).thenApply(bignore -> null);\n+        });\n+    }\n+\n+    private void buildIndexFromIndexThrowEx() {\n+        throw new MetaDataException(IndexFromIndexRequest.BAD_SRC_MESSAGE);\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexReadableOrThrow(FDBRecordStore store, String srcIndex) {\n+        return store.getRecordStoreStateAsync()\n+                .thenCompose(state ->\n+                {\n+                    if (!state.isReadable(srcIndex)) {\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+                    return AsyncUtil.DONE;\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexAsync() {\n+        // zz 0 - sanity & trigger\n+        return getRunner().runAsync(this::openRecordStore)\n+                .thenCompose(store ->\n+                {\n+                    // first verify that both src and tgt are of a single, similar, type\n+                    final RecordMetaData metaData = store.getRecordMetaData();\n+                    final Collection<RecordType> srcRecordTypes = metaData.recordTypesForIndex(index);\n+\n+                    if ( syntheticIndex ||\n+                            recordTypes.size() != 1 ||\n+                            srcRecordTypes.size() != 1 ||\n+                            recordTypes.toArray()[0] != srcRecordTypes.toArray()[0]) {\n+\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+\n+                    // return the build iteration. src readability & tgt/src idempotency will be verified during each iteration\n+                    return buildIndexFromIndex();\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndex() {\n+        // zz 1 - runner\n+        return getRunner().runAsync(context ->\n+                context.getReadVersionAsync().thenCompose(vignore -> // Why do we need this version?\n+                {\n+                    SubspaceProvider subspaceProvider = recordStoreBuilder.getSubspaceProvider();\n+                    assert subspaceProvider != null;\n+                    // zz 2 - subspace\n+                    return subspaceProvider.getSubspaceAsync(context)\n+                            .thenCompose(subspace -> // .. and subspace?\n+                                    buildIndexFromIndex(subspaceProvider, subspace)\n+                                            .thenCompose(vignore2 -> buildIndexFromIndexMarkBuilt(subspace)\n+                                            ));\n+                }));\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndex(SubspaceProvider subspaceProvider, @Nonnull Subspace subspace) {\n+        AtomicReference<byte[]> nextCont = new AtomicReference<>();\n+\n+        // zz 3 while true -> runner/store -> build chunk\n+        return AsyncUtil.whileTrue(() ->\n+        {\n+            byte [] cont = nextCont.get();\n+            final List<Object> additionalLogMessageKeyValues = Arrays.asList(LogMessageKeys.CALLING_METHOD, \"buildIndexFromIndex\",\n+                    LogMessageKeys.NEXT_CONTINUATION, cont == null ? \"\" : cont);\n+\n+            // zz 4 - buildAsync\n+            // apparently, buildAsync=buildAndCommitWithRetry\n+            return buildAsync( (store, recordsScanned) ->\n+                            // verify that source is still readable\n+                            buildIndexFromIndexReadableOrThrow(store, indexFromIndex.getSourceIndex())\n+                                    // and continue building a single range\n+                                    .thenCompose( ignore -> buildIndexFromIndexRange(store, cont, recordsScanned)),\n+                    true,\n+                    additionalLogMessageKeyValues)\n+                    .handle((retCont, ex) ->\n+                    {\n+                        // zz 4.1 - handle range\n+                        if (ex == null) {\n+                            if (LOGGER.isInfoEnabled() &&\n+                                    (config.progressLogIntervalMillis > 0 &&\n+                                    System.currentTimeMillis() - timeOfLastProgressLogMillis > config.progressLogIntervalMillis) ||\n+                                    config.progressLogIntervalMillis == 0) {\n+                                LOGGER.info(KeyValueLogMessage.of(\"Built Range\",\n+                                        LogMessageKeys.INDEX_NAME, index.getName(),\n+                                        LogMessageKeys.INDEX_VERSION, index.getLastModifiedVersion(),\n+                                        subspaceProvider.logKey(), subspaceProvider,\n+                                        LogMessageKeys.NEXT_CONTINUATION, retCont,\n+                                        LogMessageKeys.RECORDS_SCANNED, totalRecordsScanned.get()),\n+                                        LogMessageKeys.INDEXER_ID, onlineIndexerId);\n+                                timeOfLastProgressLogMillis = System.currentTimeMillis();\n+                            }\n+                            if (retCont == null) {\n+                                return AsyncUtil.READY_FALSE;\n+                            }\n+                            nextCont.set(retCont); // continuation\n+                            long toWait = (config.recordsPerSecond == UNLIMITED) ? 0 : 1000 * limit / config.recordsPerSecond;\n+                            // ? shouldn't we factor the iteration's runtime? It's not just negligible cpu cycles but also DS access time", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUzNTA1Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534535052", "bodyText": "Hm, I'm not sure about this. I think this might work, but this comment about the ordering being the not the same as the record store isn't entirely relevant. I think we could make range information work, but we'd need:\n\nTo include the ranges of keys scanned in the index, not of record primary keys\nTo record somewhere which index is being used\n\nBecause we do neither of things currently, and then we also don't record what ranges are built (and also because we require that the index is idempotent), I think this all works, but it's bit delicate. It would seem better if we could record what index we're using and also what ranges within that index have been built, particularly because without that information, any attempt to restart the build will require starting all over again. Having that range information is also required if we ever do want to support non-idempotent indexes being built this way (which I suspect we will).\n(It also looks like the index-from-index logic currently still tries to build the endpoints, which I think isn't necessary if we're not going to look at the range information anyway.)", "author": "alecgrieser", "createdAt": "2020-12-02T22:49:53Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2548,4 +2641,220 @@ public boolean isContinueIfWriteOnly() {\n             return continueIfWriteOnly;\n         }\n     }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexMarkBuilt(Subspace subspace) {\n+        // zz 2.1 - mark built\n+        // Grand Finale - after fully building the index, remove all missing ranges in one gulp\n+        // Note that we do not assume srcIndex has the same order as the record store, therefore did not try to handle\n+        // missing spaces (for now..)", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAyNjU4OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r542026588", "bodyText": "My point was that would we assume the same order, we could have updated the rangeSet (by record, not by index) and - potentially - allow a record-scan continue an index-scan. But since it is indeed misleading, I removed the comment.", "author": "jjezra", "createdAt": "2020-12-13T23:03:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUzNTA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU0NDk1OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r534544959", "bodyText": "This check seems suspect to me. It seems like it should be using .equals instead of pointer equality", "author": "alecgrieser", "createdAt": "2020-12-02T23:10:15Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2548,4 +2641,220 @@ public boolean isContinueIfWriteOnly() {\n             return continueIfWriteOnly;\n         }\n     }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexMarkBuilt(Subspace subspace) {\n+        // zz 2.1 - mark built\n+        // Grand Finale - after fully building the index, remove all missing ranges in one gulp\n+        // Note that we do not assume srcIndex has the same order as the record store, therefore did not try to handle\n+        // missing spaces (for now..)\n+        return getRunner().runAsync(context ->\n+        {\n+            RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, index.getSubspaceKey())));\n+            TransactionContext tc = context.ensureActive();\n+            return rangeSet.insertRange(tc, null, null).thenApply(bignore -> null);\n+        });\n+    }\n+\n+    private void buildIndexFromIndexThrowEx() {\n+        throw new MetaDataException(IndexFromIndexRequest.BAD_SRC_MESSAGE);\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexReadableOrThrow(FDBRecordStore store, String srcIndex) {\n+        return store.getRecordStoreStateAsync()\n+                .thenCompose(state ->\n+                {\n+                    if (!state.isReadable(srcIndex)) {\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+                    return AsyncUtil.DONE;\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexAsync() {\n+        // zz 0 - sanity & trigger\n+        return getRunner().runAsync(this::openRecordStore)\n+                .thenCompose(store ->\n+                {\n+                    // first verify that both src and tgt are of a single, similar, type\n+                    final RecordMetaData metaData = store.getRecordMetaData();\n+                    final Collection<RecordType> srcRecordTypes = metaData.recordTypesForIndex(index);\n+\n+                    if ( syntheticIndex ||\n+                            recordTypes.size() != 1 ||\n+                            srcRecordTypes.size() != 1 ||\n+                            recordTypes.toArray()[0] != srcRecordTypes.toArray()[0]) {\n+\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+\n+                    // return the build iteration. src readability & tgt/src idempotency will be verified during each iteration\n+                    return buildIndexFromIndex();\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndex() {\n+        // zz 1 - runner\n+        return getRunner().runAsync(context ->\n+                context.getReadVersionAsync().thenCompose(vignore -> // Why do we need this version?\n+                {\n+                    SubspaceProvider subspaceProvider = recordStoreBuilder.getSubspaceProvider();\n+                    assert subspaceProvider != null;\n+                    // zz 2 - subspace\n+                    return subspaceProvider.getSubspaceAsync(context)\n+                            .thenCompose(subspace -> // .. and subspace?\n+                                    buildIndexFromIndex(subspaceProvider, subspace)\n+                                            .thenCompose(vignore2 -> buildIndexFromIndexMarkBuilt(subspace)\n+                                            ));\n+                }));\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndex(SubspaceProvider subspaceProvider, @Nonnull Subspace subspace) {\n+        AtomicReference<byte[]> nextCont = new AtomicReference<>();\n+\n+        // zz 3 while true -> runner/store -> build chunk\n+        return AsyncUtil.whileTrue(() ->\n+        {\n+            byte [] cont = nextCont.get();\n+            final List<Object> additionalLogMessageKeyValues = Arrays.asList(LogMessageKeys.CALLING_METHOD, \"buildIndexFromIndex\",\n+                    LogMessageKeys.NEXT_CONTINUATION, cont == null ? \"\" : cont);\n+\n+            // zz 4 - buildAsync\n+            // apparently, buildAsync=buildAndCommitWithRetry\n+            return buildAsync( (store, recordsScanned) ->\n+                            // verify that source is still readable\n+                            buildIndexFromIndexReadableOrThrow(store, indexFromIndex.getSourceIndex())\n+                                    // and continue building a single range\n+                                    .thenCompose( ignore -> buildIndexFromIndexRange(store, cont, recordsScanned)),\n+                    true,\n+                    additionalLogMessageKeyValues)\n+                    .handle((retCont, ex) ->\n+                    {\n+                        // zz 4.1 - handle range\n+                        if (ex == null) {\n+                            if (LOGGER.isInfoEnabled() &&\n+                                    (config.progressLogIntervalMillis > 0 &&\n+                                    System.currentTimeMillis() - timeOfLastProgressLogMillis > config.progressLogIntervalMillis) ||\n+                                    config.progressLogIntervalMillis == 0) {\n+                                LOGGER.info(KeyValueLogMessage.of(\"Built Range\",\n+                                        LogMessageKeys.INDEX_NAME, index.getName(),\n+                                        LogMessageKeys.INDEX_VERSION, index.getLastModifiedVersion(),\n+                                        subspaceProvider.logKey(), subspaceProvider,\n+                                        LogMessageKeys.NEXT_CONTINUATION, retCont,\n+                                        LogMessageKeys.RECORDS_SCANNED, totalRecordsScanned.get()),\n+                                        LogMessageKeys.INDEXER_ID, onlineIndexerId);\n+                                timeOfLastProgressLogMillis = System.currentTimeMillis();\n+                            }\n+                            if (retCont == null) {\n+                                return AsyncUtil.READY_FALSE;\n+                            }\n+                            nextCont.set(retCont); // continuation\n+                            long toWait = (config.recordsPerSecond == UNLIMITED) ? 0 : 1000 * limit / config.recordsPerSecond;\n+                            // ? shouldn't we factor the iteration's runtime? It's not just negligible cpu cycles but also DS access time\n+                            return MoreAsyncUtil.delayedFuture(toWait, TimeUnit.MILLISECONDS).thenApply(vignore3 -> true);\n+                        }\n+                        final RuntimeException unwrappedEx = getRunner().getDatabase().mapAsyncToSyncException(ex);\n+                        if (LOGGER.isInfoEnabled()) {\n+                            LOGGER.info(KeyValueLogMessage.of(\"possibly non-fatal error encountered building range\",\n+                                    LogMessageKeys.NEXT_CONTINUATION, nextCont,\n+                                    LogMessageKeys.SUBSPACE, ByteArrayUtil2.loggable(subspace.pack())), ex);\n+                        }\n+                        throw unwrappedEx;\n+                    })\n+                    .thenCompose(Function.identity());\n+        }, getRunner().getExecutor());\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<byte[]> buildIndexFromIndexRange(@Nonnull FDBRecordStore store, byte[] cont, @Nonnull AtomicLong recordsScanned) {\n+        // zz 5  - buildRangeOnly\n+\n+        final Subspace scannedRecordsSubspace = indexBuildScannedRecordsSubspace(store, index);\n+        final RecordMetaDataProvider recordMetaDataProvider = recordStoreBuilder.getMetaDataProvider();\n+        if ( recordMetaDataProvider == null ||\n+                store.getRecordMetaData() != recordMetaDataProvider.getRecordMetaData()) {", "originalCommit": "5ee31a2e0c758632349f7a5b8d58723b47756fc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5NTk1OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r540395959", "bodyText": "This method and buildIndexFromIndexRange feel like they should be combined with their equivalents that perform a record scan instead of reading from an index, given how there's a lot of complicated, fiddly logic that's now duplicated. That might mean we need to abstract some things, like how one gets a range of records and how one updates the range set, etc.\nI haven't looked too closely at these methods exactly because I suspect they'll change a lot if we combine them with the other methods, but I'll have to take a closer look if there isn't a refactoring.", "author": "alecgrieser", "createdAt": "2020-12-10T18:21:49Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2548,4 +2643,212 @@ public boolean isContinueIfWriteOnly() {\n             return continueIfWriteOnly;\n         }\n     }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexMarkBuilt(Subspace subspace) {\n+        // zz 2.1 - mark built\n+        // Grand Finale - after fully building the index, remove all missing ranges in one gulp\n+        // Note that we do not assume srcIndex has the same order as the record store, therefore did not try to handle\n+        // missing spaces (for now..)\n+        return getRunner().runAsync(context ->\n+        {\n+            RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, index.getSubspaceKey())));\n+            TransactionContext tc = context.ensureActive();\n+            return rangeSet.insertRange(tc, null, null).thenApply(bignore -> null);\n+        });\n+    }\n+\n+    private void buildIndexFromIndexThrowEx() {\n+        throw new MetaDataException(IndexFromIndexRequest.BAD_SRC_MESSAGE);\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexReadableOrThrow(FDBRecordStore store, String srcIndex) {\n+        return store.getRecordStoreStateAsync()\n+                .thenCompose(state ->\n+                {\n+                    if (!state.isReadable(srcIndex)) {\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+                    return AsyncUtil.DONE;\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexAsync() {\n+        // zz 1 - runner\n+        return getRunner().runAsync(context -> openRecordStore(context)\n+                .thenCompose( store ->\n+                {\n+                    // first verify that both src and tgt are of a single, similar, type\n+                    final RecordMetaData metaData = store.getRecordMetaData();\n+                    final Collection<RecordType> srcRecordTypes = metaData.recordTypesForIndex(index);\n+\n+                    if ( syntheticIndex ||\n+                            recordTypes.size() != 1 ||\n+                            srcRecordTypes.size() != 1 ||\n+                            recordTypes.toArray()[0] != srcRecordTypes.toArray()[0]) {\n+\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+\n+                    return context.getReadVersionAsync()\n+                            .thenCompose(vignore -> // Verify we allow to run this trans.\n+                            {\n+                                SubspaceProvider subspaceProvider = recordStoreBuilder.getSubspaceProvider();\n+                                // zz 2 - subspace\n+                                return subspaceProvider.getSubspaceAsync(context)\n+                                        .thenCompose(subspace ->\n+                                                buildIndexFromIndex(subspaceProvider, subspace)\n+                                                        .thenCompose(vignore2 -> buildIndexFromIndexMarkBuilt(subspace)\n+                                                        ));\n+                            });\n+                }));\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndex(SubspaceProvider subspaceProvider, @Nonnull Subspace subspace) {", "originalCommit": "7c853b8bd3f6c4175738c2dec66fbd748ca6c65e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5OTQ1Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r540399453", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    context.asyncToSync(FDBStoreTimer.Waits.WAIT_LOAD_RECORD_STORE_STATE,\n          \n          \n            \n                            getRecordStoreStateAsync());\n          \n          \n            \n            \n          \n          \n            \n                    return recordStoreStateRef.get();\n          \n          \n            \n                    return context.asyncToSync(FDBStoreTimer.Waits.WAIT_LOAD_RECORD_STORE_STATE, getRecordStoreStateAsync());", "author": "alecgrieser", "createdAt": "2020-12-10T18:27:12Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordStore.java", "diffHunk": "@@ -346,13 +346,28 @@ public RecordMetaData getRecordMetaData() {\n      */\n     @Nonnull\n     public RecordStoreState getRecordStoreState() {\n-        if (recordStoreStateRef.get() == null) {\n-            context.asyncToSync(FDBStoreTimer.Waits.WAIT_LOAD_RECORD_STORE_STATE,\n-                    preloadRecordStoreStateAsync(StoreExistenceCheck.NONE, IsolationLevel.SERIALIZABLE, IsolationLevel.SNAPSHOT));\n-        }\n+        context.asyncToSync(FDBStoreTimer.Waits.WAIT_LOAD_RECORD_STORE_STATE,\n+                getRecordStoreStateAsync());\n+\n         return recordStoreStateRef.get();", "originalCommit": "7c853b8bd3f6c4175738c2dec66fbd748ca6c65e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4MjQ5Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r542882493", "bodyText": "I could also undo the new getRecordStoreStateAsync..", "author": "jjezra", "createdAt": "2020-12-14T22:37:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5OTQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4NjU2NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r542886565", "bodyText": "Since getRecordStoreStateAsync is now unused, I'll return FDBRecordStore.java to its original state.", "author": "jjezra", "createdAt": "2020-12-14T22:41:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5OTQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwMjQ4Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r540402487", "bodyText": "I think there's an AsyncUtil::composeHandle utility method that you can use here", "author": "alecgrieser", "createdAt": "2020-12-10T18:31:37Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1289,24 +1294,46 @@ private boolean shouldClearExistingIndexEntries(@Nonnull IndexState indexState,\n     }\n \n     @Nonnull\n-    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n-        CompletableFuture<Void> buildFuture = buildEndpoints().thenCompose(tupleRange -> {\n+    private CompletableFuture<Void> buildIndexFromRecordsAsync() {\n+        return buildEndpoints().thenCompose(tupleRange -> {\n             if (tupleRange != null) {\n                 return buildRange(Key.Evaluated.fromTuple(tupleRange.getLow()), Key.Evaluated.fromTuple(tupleRange.getHigh()));\n             } else {\n                 return CompletableFuture.completedFuture(null);\n             }\n         });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n+        CompletableFuture<Void> buildFuture;\n+        if (indexFromIndex.isActive()) {\n+            buildFuture = buildIndexFromIndexAsync()\n+                    .handle( (ignore, ex) ->", "originalCommit": "7c853b8bd3f6c4175738c2dec66fbd748ca6c65e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwMzc0OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r540403749", "bodyText": "I don't understand this comment. The get read version request isn't really about validating whether we can run the transaction, it's just necessary to (1) instrument the GRV call that's going to happen anyway if we don't call it explicitly and (2) to get the database version to read FDB from so that we see the latest updates.\nAlso, probably best to write out \"transaction\"", "author": "alecgrieser", "createdAt": "2020-12-10T18:33:35Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2548,4 +2643,212 @@ public boolean isContinueIfWriteOnly() {\n             return continueIfWriteOnly;\n         }\n     }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexMarkBuilt(Subspace subspace) {\n+        // zz 2.1 - mark built\n+        // Grand Finale - after fully building the index, remove all missing ranges in one gulp\n+        // Note that we do not assume srcIndex has the same order as the record store, therefore did not try to handle\n+        // missing spaces (for now..)\n+        return getRunner().runAsync(context ->\n+        {\n+            RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, index.getSubspaceKey())));\n+            TransactionContext tc = context.ensureActive();\n+            return rangeSet.insertRange(tc, null, null).thenApply(bignore -> null);\n+        });\n+    }\n+\n+    private void buildIndexFromIndexThrowEx() {\n+        throw new MetaDataException(IndexFromIndexRequest.BAD_SRC_MESSAGE);\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexReadableOrThrow(FDBRecordStore store, String srcIndex) {\n+        return store.getRecordStoreStateAsync()\n+                .thenCompose(state ->\n+                {\n+                    if (!state.isReadable(srcIndex)) {\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+                    return AsyncUtil.DONE;\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexAsync() {\n+        // zz 1 - runner\n+        return getRunner().runAsync(context -> openRecordStore(context)\n+                .thenCompose( store ->\n+                {\n+                    // first verify that both src and tgt are of a single, similar, type\n+                    final RecordMetaData metaData = store.getRecordMetaData();\n+                    final Collection<RecordType> srcRecordTypes = metaData.recordTypesForIndex(index);\n+\n+                    if ( syntheticIndex ||\n+                            recordTypes.size() != 1 ||\n+                            srcRecordTypes.size() != 1 ||\n+                            recordTypes.toArray()[0] != srcRecordTypes.toArray()[0]) {\n+\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+\n+                    return context.getReadVersionAsync()\n+                            .thenCompose(vignore -> // Verify we allow to run this trans.", "originalCommit": "7c853b8bd3f6c4175738c2dec66fbd748ca6c65e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjkwODQzMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r542908433", "bodyText": "Oh, it's just a leftover.", "author": "jjezra", "createdAt": "2020-12-14T23:03:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwMzc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwNjA2OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r540406069", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return getRunner().runAsync(context -> openRecordStore(context)\n          \n          \n            \n                            .thenCompose( store ->\n          \n          \n            \n                            {\n          \n          \n            \n                    return getRunner().runAsync(context -> openRecordStore(context).thenCompose(store -> {\n          \n      \n    \n    \n  \n\nI think this looks cleaner, but it's somewhat a matter of taste. Plus then you can move the inner block over 2 tabs", "author": "alecgrieser", "createdAt": "2020-12-10T18:37:11Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2548,4 +2643,212 @@ public boolean isContinueIfWriteOnly() {\n             return continueIfWriteOnly;\n         }\n     }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexMarkBuilt(Subspace subspace) {\n+        // zz 2.1 - mark built\n+        // Grand Finale - after fully building the index, remove all missing ranges in one gulp\n+        // Note that we do not assume srcIndex has the same order as the record store, therefore did not try to handle\n+        // missing spaces (for now..)\n+        return getRunner().runAsync(context ->\n+        {\n+            RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, index.getSubspaceKey())));\n+            TransactionContext tc = context.ensureActive();\n+            return rangeSet.insertRange(tc, null, null).thenApply(bignore -> null);\n+        });\n+    }\n+\n+    private void buildIndexFromIndexThrowEx() {\n+        throw new MetaDataException(IndexFromIndexRequest.BAD_SRC_MESSAGE);\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexReadableOrThrow(FDBRecordStore store, String srcIndex) {\n+        return store.getRecordStoreStateAsync()\n+                .thenCompose(state ->\n+                {\n+                    if (!state.isReadable(srcIndex)) {\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+                    return AsyncUtil.DONE;\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexAsync() {\n+        // zz 1 - runner\n+        return getRunner().runAsync(context -> openRecordStore(context)\n+                .thenCompose( store ->\n+                {", "originalCommit": "7c853b8bd3f6c4175738c2dec66fbd748ca6c65e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwNjgxMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r540406811", "bodyText": "Is this being called with the right index? Should it call recordTypesForIndex on the srcIndex?", "author": "alecgrieser", "createdAt": "2020-12-10T18:38:21Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2548,4 +2643,212 @@ public boolean isContinueIfWriteOnly() {\n             return continueIfWriteOnly;\n         }\n     }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexMarkBuilt(Subspace subspace) {\n+        // zz 2.1 - mark built\n+        // Grand Finale - after fully building the index, remove all missing ranges in one gulp\n+        // Note that we do not assume srcIndex has the same order as the record store, therefore did not try to handle\n+        // missing spaces (for now..)\n+        return getRunner().runAsync(context ->\n+        {\n+            RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, index.getSubspaceKey())));\n+            TransactionContext tc = context.ensureActive();\n+            return rangeSet.insertRange(tc, null, null).thenApply(bignore -> null);\n+        });\n+    }\n+\n+    private void buildIndexFromIndexThrowEx() {\n+        throw new MetaDataException(IndexFromIndexRequest.BAD_SRC_MESSAGE);\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexReadableOrThrow(FDBRecordStore store, String srcIndex) {\n+        return store.getRecordStoreStateAsync()\n+                .thenCompose(state ->\n+                {\n+                    if (!state.isReadable(srcIndex)) {\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+                    return AsyncUtil.DONE;\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexAsync() {\n+        // zz 1 - runner\n+        return getRunner().runAsync(context -> openRecordStore(context)\n+                .thenCompose( store ->\n+                {\n+                    // first verify that both src and tgt are of a single, similar, type\n+                    final RecordMetaData metaData = store.getRecordMetaData();\n+                    final Collection<RecordType> srcRecordTypes = metaData.recordTypesForIndex(index);", "originalCommit": "7c853b8bd3f6c4175738c2dec66fbd748ca6c65e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjkxMzExOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r542913119", "bodyText": "< I bow my head in shame />", "author": "jjezra", "createdAt": "2020-12-14T23:10:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwNjgxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjkxNDM2MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r542914361", "bodyText": "Now recordTypes.equals(srcRecordTypes) is working too.", "author": "jjezra", "createdAt": "2020-12-14T23:12:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwNjgxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQxMDY1Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r540410657", "bodyText": "IIRC, there were also other validation steps that we'd considered performing here, some of which are harder to enumerate than others. I think some might be:\n\nThe srcIndex is a VALUE index (or at least supports \"scanning by VALUE\" or something like that)\nThis one is more difficult, but ideally, the srcIndex key expression should have at least one result for each record in the destination index. One might be just to validate that createsDuplicates on the srcIndex key expression is false. Another option might be to validate that the srcIndex key expression is equal to the primary key of the record types in question (or maybe that's an option that should exist in the index to to index policy), which would rule out a bunch of valid source indexes, but it would also make it less likely someone called this with an invalid index.\nIndexMaintenanceFilters: ideally, we'd validate that the indexes have either \"the same\" filter or the src has no filter or the src has a \"more permissive filter\" than the destination index. Unfortunately, that's somewhat hard to tell because index maintenance filters are black boxes at the moment. But maybe that could be another option on the index-to-index policy object?\n\nThis check is also currently conservative when it comes to the record types list (in that it requires single-type indexes whereas the needed check is just that the destination record types are a subset of the source record types), but that might be fine for version 1.", "author": "alecgrieser", "createdAt": "2020-12-10T18:44:36Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2548,4 +2643,212 @@ public boolean isContinueIfWriteOnly() {\n             return continueIfWriteOnly;\n         }\n     }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexMarkBuilt(Subspace subspace) {\n+        // zz 2.1 - mark built\n+        // Grand Finale - after fully building the index, remove all missing ranges in one gulp\n+        // Note that we do not assume srcIndex has the same order as the record store, therefore did not try to handle\n+        // missing spaces (for now..)\n+        return getRunner().runAsync(context ->\n+        {\n+            RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, index.getSubspaceKey())));\n+            TransactionContext tc = context.ensureActive();\n+            return rangeSet.insertRange(tc, null, null).thenApply(bignore -> null);\n+        });\n+    }\n+\n+    private void buildIndexFromIndexThrowEx() {\n+        throw new MetaDataException(IndexFromIndexRequest.BAD_SRC_MESSAGE);\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexReadableOrThrow(FDBRecordStore store, String srcIndex) {\n+        return store.getRecordStoreStateAsync()\n+                .thenCompose(state ->\n+                {\n+                    if (!state.isReadable(srcIndex)) {\n+                        buildIndexFromIndexThrowEx();\n+                    }\n+                    return AsyncUtil.DONE;\n+                });\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndexAsync() {\n+        // zz 1 - runner\n+        return getRunner().runAsync(context -> openRecordStore(context)\n+                .thenCompose( store ->\n+                {\n+                    // first verify that both src and tgt are of a single, similar, type\n+                    final RecordMetaData metaData = store.getRecordMetaData();\n+                    final Collection<RecordType> srcRecordTypes = metaData.recordTypesForIndex(index);\n+\n+                    if ( syntheticIndex ||", "originalCommit": "7c853b8bd3f6c4175738c2dec66fbd748ca6c65e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjkyOTMyOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r542929328", "bodyText": "Is the isIdempotent check enough to identify it as a value index? It is being checked in buildIndexFromIndexRange\nMeantime, added :\n ! srcIndex.getType().equals(IndexTypes.VALUE) ||\nIf I remember correctly, we agreed that it's the caller responsibility to verify that the target index's records are a subset of the source one (Scott mentioned that sometimes the record layer doesn't have enough information to provide a full protection).\nBut sure - additional sanity checks are mostly harmless. Added:\n  srcIndex.getRootExpression().createsDuplicates() ||\nHow can I get/check if a filter exists?", "author": "jjezra", "createdAt": "2020-12-14T23:46:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQxMDY1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQxNjg2Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r540416866", "bodyText": "These four tests share a lot of overlap that would be nice to refactor so there's less code dupe.", "author": "alecgrieser", "createdAt": "2020-12-10T18:54:26Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerIndexFromIndexTest.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * OnlineIndexerIndexFromIndexTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.record.TestRecords1Proto;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexOptions;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.expressions.EmptyKeyExpression;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+\n+import static com.apple.foundationdb.record.metadata.Key.Expressions.field;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests for building indexes from other indexes with {@link OnlineIndexer}.\n+ */\n+\n+public class OnlineIndexerIndexFromIndexTest extends OnlineIndexerTest {\n+\n+    @Test\n+    public void testIndexFromIndexSimple() {", "originalCommit": "7c853b8bd3f6c4175738c2dec66fbd748ca6c65e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQyNjQxNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r540426415", "bodyText": "I think you should be able to replace this with a call to buildIndex() on the online indexer--you shouldn't need to manually mark the index write-only or readable, I don't think", "author": "alecgrieser", "createdAt": "2020-12-10T19:09:33Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerIndexFromIndexTest.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * OnlineIndexerIndexFromIndexTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.record.TestRecords1Proto;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexOptions;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.expressions.EmptyKeyExpression;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+\n+import static com.apple.foundationdb.record.metadata.Key.Expressions.field;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests for building indexes from other indexes with {@link OnlineIndexer}.\n+ */\n+\n+public class OnlineIndexerIndexFromIndexTest extends OnlineIndexerTest {\n+\n+    @Test\n+    public void testIndexFromIndexSimple() {\n+\n+        final FDBStoreTimer timer = new FDBStoreTimer();\n+        final long numRecords = 1000;\n+\n+        List<TestRecords1Proto.MySimpleRecord> records = LongStream.range(0, numRecords).mapToObj(val ->\n+                TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).build()\n+        ).collect(Collectors.toList());\n+        Index srcIndex = new Index(\"src_index\", field(\"num_value_2\"), EmptyKeyExpression.EMPTY, IndexTypes.VALUE, IndexOptions.UNIQUE_OPTIONS);\n+        Index tgtIndex = new Index(\"tgt_index\", field(\"num_value_3_indexed\"), IndexTypes.VALUE);\n+\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> {\n+            metaDataBuilder.addIndex(\"MySimpleRecord\", srcIndex);\n+            metaDataBuilder.addIndex(\"MySimpleRecord\", tgtIndex);\n+        } ;\n+\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext())  {\n+            records.forEach(recordStore::saveRecord);\n+            context.commit();\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            try (OnlineIndexer indexBuilder = OnlineIndexer.newBuilder()\n+                    .setDatabase(fdb).setMetaData(metaData).setIndex(srcIndex).setSubspace(subspace)\n+                    .build()) {\n+                recordStore.markIndexWriteOnly(srcIndex).join();\n+                indexBuilder.rebuildIndex(recordStore);\n+                recordStore.markIndexReadable(srcIndex).join();\n+                context.commit();\n+                assertTrue(recordStore.isIndexReadable(srcIndex));\n+            }\n+        }", "originalCommit": "7c853b8bd3f6c4175738c2dec66fbd748ca6c65e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQyNzQ4NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r540427485", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        indexBuilder.buildIndexAsync(true)\n          \n          \n            \n                                .handle((ignore, e) ->\n          \n          \n            \n                                {\n          \n          \n            \n                                    assertNull(e);\n          \n          \n            \n                                    return null;\n          \n          \n            \n                                })\n          \n          \n            \n                                .join();\n          \n          \n            \n                        indexBuilder.buildIndex();\n          \n      \n    \n    \n  \n\nI think the assert here is basically just validating that there aren't errors, and if there are, those will bubble up through buildIndex and fail the test.", "author": "alecgrieser", "createdAt": "2020-12-10T19:11:21Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerIndexFromIndexTest.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * OnlineIndexerIndexFromIndexTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.record.TestRecords1Proto;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexOptions;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.expressions.EmptyKeyExpression;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+\n+import static com.apple.foundationdb.record.metadata.Key.Expressions.field;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests for building indexes from other indexes with {@link OnlineIndexer}.\n+ */\n+\n+public class OnlineIndexerIndexFromIndexTest extends OnlineIndexerTest {\n+\n+    @Test\n+    public void testIndexFromIndexSimple() {\n+\n+        final FDBStoreTimer timer = new FDBStoreTimer();\n+        final long numRecords = 1000;\n+\n+        List<TestRecords1Proto.MySimpleRecord> records = LongStream.range(0, numRecords).mapToObj(val ->\n+                TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).build()\n+        ).collect(Collectors.toList());\n+        Index srcIndex = new Index(\"src_index\", field(\"num_value_2\"), EmptyKeyExpression.EMPTY, IndexTypes.VALUE, IndexOptions.UNIQUE_OPTIONS);\n+        Index tgtIndex = new Index(\"tgt_index\", field(\"num_value_3_indexed\"), IndexTypes.VALUE);\n+\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> {\n+            metaDataBuilder.addIndex(\"MySimpleRecord\", srcIndex);\n+            metaDataBuilder.addIndex(\"MySimpleRecord\", tgtIndex);\n+        } ;\n+\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext())  {\n+            records.forEach(recordStore::saveRecord);\n+            context.commit();\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            try (OnlineIndexer indexBuilder = OnlineIndexer.newBuilder()\n+                    .setDatabase(fdb).setMetaData(metaData).setIndex(srcIndex).setSubspace(subspace)\n+                    .build()) {\n+                recordStore.markIndexWriteOnly(srcIndex).join();\n+                indexBuilder.rebuildIndex(recordStore);\n+                recordStore.markIndexReadable(srcIndex).join();\n+                context.commit();\n+                assertTrue(recordStore.isIndexReadable(srcIndex));\n+            }\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            recordStore.markIndexWriteOnly(tgtIndex).join();\n+            context.commit();\n+            assertTrue(recordStore.isIndexWriteOnly(tgtIndex));\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (OnlineIndexer indexBuilder = OnlineIndexer.newBuilder()\n+                .setDatabase(fdb).setMetaData(metaData).setIndex(tgtIndex).setSubspace(subspace)\n+                .setIndexFromIndex(new OnlineIndexer.IndexFromIndexRequest(\"src_index\")\n+                        .mustUseSourceIndex())\n+                .setTimer(timer)\n+                .build()) {\n+\n+            indexBuilder.buildIndexAsync(true)\n+                    .handle((ignore, e) ->\n+                    {\n+                        assertNull(e);\n+                        return null;\n+                    })\n+                    .join();", "originalCommit": "7c853b8bd3f6c4175738c2dec66fbd748ca6c65e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQyOTczOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r540429738", "bodyText": "Hm, I think I'd probably call out in the name of this class that this is to test that we fall back to scanning records if the target index is not idempotent. It took me a while to see that that's what was different about this class.", "author": "alecgrieser", "createdAt": "2020-12-10T19:15:03Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerIndexFromIndexTest.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * OnlineIndexerIndexFromIndexTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.record.TestRecords1Proto;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexOptions;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.expressions.EmptyKeyExpression;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+\n+import static com.apple.foundationdb.record.metadata.Key.Expressions.field;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests for building indexes from other indexes with {@link OnlineIndexer}.\n+ */\n+\n+public class OnlineIndexerIndexFromIndexTest extends OnlineIndexerTest {\n+\n+    @Test\n+    public void testIndexFromIndexSimple() {\n+\n+        final FDBStoreTimer timer = new FDBStoreTimer();\n+        final long numRecords = 1000;\n+\n+        List<TestRecords1Proto.MySimpleRecord> records = LongStream.range(0, numRecords).mapToObj(val ->\n+                TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).build()\n+        ).collect(Collectors.toList());\n+        Index srcIndex = new Index(\"src_index\", field(\"num_value_2\"), EmptyKeyExpression.EMPTY, IndexTypes.VALUE, IndexOptions.UNIQUE_OPTIONS);\n+        Index tgtIndex = new Index(\"tgt_index\", field(\"num_value_3_indexed\"), IndexTypes.VALUE);\n+\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> {\n+            metaDataBuilder.addIndex(\"MySimpleRecord\", srcIndex);\n+            metaDataBuilder.addIndex(\"MySimpleRecord\", tgtIndex);\n+        } ;\n+\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext())  {\n+            records.forEach(recordStore::saveRecord);\n+            context.commit();\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            try (OnlineIndexer indexBuilder = OnlineIndexer.newBuilder()\n+                    .setDatabase(fdb).setMetaData(metaData).setIndex(srcIndex).setSubspace(subspace)\n+                    .build()) {\n+                recordStore.markIndexWriteOnly(srcIndex).join();\n+                indexBuilder.rebuildIndex(recordStore);\n+                recordStore.markIndexReadable(srcIndex).join();\n+                context.commit();\n+                assertTrue(recordStore.isIndexReadable(srcIndex));\n+            }\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            recordStore.markIndexWriteOnly(tgtIndex).join();\n+            context.commit();\n+            assertTrue(recordStore.isIndexWriteOnly(tgtIndex));\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (OnlineIndexer indexBuilder = OnlineIndexer.newBuilder()\n+                .setDatabase(fdb).setMetaData(metaData).setIndex(tgtIndex).setSubspace(subspace)\n+                .setIndexFromIndex(new OnlineIndexer.IndexFromIndexRequest(\"src_index\")\n+                        .mustUseSourceIndex())\n+                .setTimer(timer)\n+                .build()) {\n+\n+            indexBuilder.buildIndexAsync(true)\n+                    .handle((ignore, e) ->\n+                    {\n+                        assertNull(e);\n+                        return null;\n+                    })\n+                    .join();\n+        }\n+        assertEquals(numRecords, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED));\n+        assertEquals(numRecords, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED));\n+    }\n+\n+    @Test\n+    public void testIndexFromIndexContinuation() {\n+\n+        final FDBStoreTimer timer = new FDBStoreTimer();\n+        final int numRecords = 1327;\n+        final int chunkSize  = 42;\n+        final int numChunks  = 1 + (numRecords / chunkSize);\n+\n+        List<TestRecords1Proto.MySimpleRecord> records = LongStream.range(0, numRecords).mapToObj(val ->\n+                TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).build()\n+        ).collect(Collectors.toList());\n+        Index srcIndex = new Index(\"src_index\", field(\"num_value_2\"), EmptyKeyExpression.EMPTY, IndexTypes.VALUE, IndexOptions.UNIQUE_OPTIONS);\n+        Index tgtIndex = new Index(\"tgt_index\", field(\"num_value_3_indexed\"), IndexTypes.VALUE);\n+\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> {\n+            metaDataBuilder.addIndex(\"MySimpleRecord\", srcIndex);\n+            metaDataBuilder.addIndex(\"MySimpleRecord\", tgtIndex);\n+        } ;\n+\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext())  {\n+            records.forEach(recordStore::saveRecord);\n+            context.commit();\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            try (OnlineIndexer indexBuilder = OnlineIndexer.newBuilder()\n+                    .setDatabase(fdb).setMetaData(metaData).setIndex(srcIndex).setSubspace(subspace)\n+                    .build()) {\n+                recordStore.markIndexWriteOnly(srcIndex).join();\n+                indexBuilder.rebuildIndex(recordStore);\n+                recordStore.markIndexReadable(srcIndex).join();\n+                context.commit();\n+                assertTrue(recordStore.isIndexReadable(srcIndex));\n+            }\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            recordStore.markIndexWriteOnly(tgtIndex).join();\n+            context.commit();\n+            assertTrue(recordStore.isIndexWriteOnly(tgtIndex));\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (OnlineIndexer indexBuilder = OnlineIndexer.newBuilder()\n+                .setDatabase(fdb).setMetaData(metaData).setIndex(tgtIndex).setSubspace(subspace)\n+                .setIndexFromIndex(new OnlineIndexer.IndexFromIndexRequest(\"src_index\")\n+                        .mustUseSourceIndex())\n+                .setLimit(chunkSize)\n+                .setTimer(timer)\n+                .build()) {\n+\n+            indexBuilder.buildIndexAsync(true)\n+                    .handle((ignore, e) ->\n+                    {\n+                        assertNull(e);\n+                        return null;\n+                    })\n+                    .join();\n+        }\n+        assertEquals(numRecords, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED));\n+        assertEquals(numRecords, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED));\n+        assertEquals(numChunks , timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGES_BY_COUNT));\n+    }\n+\n+    @Test\n+    public void testIndexFromIndexFallback() {\n+\n+        final FDBStoreTimer timer = new FDBStoreTimer();\n+        final long numRecords = 6;\n+\n+        List<TestRecords1Proto.MySimpleRecord> records = LongStream.range(0, numRecords).mapToObj(val ->\n+                TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).build()\n+        ).collect(Collectors.toList());\n+        Index srcIndex = new Index(\"src_index\", field(\"num_value_2\"), EmptyKeyExpression.EMPTY, IndexTypes.VALUE, IndexOptions.UNIQUE_OPTIONS);\n+        Index tgtIndex = new Index(\"tgt_index\", field(\"num_value_3_indexed\").ungrouped(), IndexTypes.SUM);", "originalCommit": "7c853b8bd3f6c4175738c2dec66fbd748ca6c65e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzcwNDI5OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r543704299", "bodyText": "How about adding a comment?", "author": "jjezra", "createdAt": "2020-12-15T21:37:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQyOTczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQzMDYxOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r540430618", "bodyText": "I think this assert can be replaced by something like:\nMetaDataException e = assertThrows(MetaDataException.class, indexBuilder::buildIndex);\n\nAnd then you can assert on the error, etc.", "author": "alecgrieser", "createdAt": "2020-12-10T19:16:27Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerIndexFromIndexTest.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * OnlineIndexerIndexFromIndexTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.record.TestRecords1Proto;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexOptions;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.expressions.EmptyKeyExpression;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+\n+import static com.apple.foundationdb.record.metadata.Key.Expressions.field;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests for building indexes from other indexes with {@link OnlineIndexer}.\n+ */\n+\n+public class OnlineIndexerIndexFromIndexTest extends OnlineIndexerTest {\n+\n+    @Test\n+    public void testIndexFromIndexSimple() {\n+\n+        final FDBStoreTimer timer = new FDBStoreTimer();\n+        final long numRecords = 1000;\n+\n+        List<TestRecords1Proto.MySimpleRecord> records = LongStream.range(0, numRecords).mapToObj(val ->\n+                TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).build()\n+        ).collect(Collectors.toList());\n+        Index srcIndex = new Index(\"src_index\", field(\"num_value_2\"), EmptyKeyExpression.EMPTY, IndexTypes.VALUE, IndexOptions.UNIQUE_OPTIONS);\n+        Index tgtIndex = new Index(\"tgt_index\", field(\"num_value_3_indexed\"), IndexTypes.VALUE);\n+\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> {\n+            metaDataBuilder.addIndex(\"MySimpleRecord\", srcIndex);\n+            metaDataBuilder.addIndex(\"MySimpleRecord\", tgtIndex);\n+        } ;\n+\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext())  {\n+            records.forEach(recordStore::saveRecord);\n+            context.commit();\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            try (OnlineIndexer indexBuilder = OnlineIndexer.newBuilder()\n+                    .setDatabase(fdb).setMetaData(metaData).setIndex(srcIndex).setSubspace(subspace)\n+                    .build()) {\n+                recordStore.markIndexWriteOnly(srcIndex).join();\n+                indexBuilder.rebuildIndex(recordStore);\n+                recordStore.markIndexReadable(srcIndex).join();\n+                context.commit();\n+                assertTrue(recordStore.isIndexReadable(srcIndex));\n+            }\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            recordStore.markIndexWriteOnly(tgtIndex).join();\n+            context.commit();\n+            assertTrue(recordStore.isIndexWriteOnly(tgtIndex));\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (OnlineIndexer indexBuilder = OnlineIndexer.newBuilder()\n+                .setDatabase(fdb).setMetaData(metaData).setIndex(tgtIndex).setSubspace(subspace)\n+                .setIndexFromIndex(new OnlineIndexer.IndexFromIndexRequest(\"src_index\")\n+                        .mustUseSourceIndex())\n+                .setTimer(timer)\n+                .build()) {\n+\n+            indexBuilder.buildIndexAsync(true)\n+                    .handle((ignore, e) ->\n+                    {\n+                        assertNull(e);\n+                        return null;\n+                    })\n+                    .join();\n+        }\n+        assertEquals(numRecords, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED));\n+        assertEquals(numRecords, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED));\n+    }\n+\n+    @Test\n+    public void testIndexFromIndexContinuation() {\n+\n+        final FDBStoreTimer timer = new FDBStoreTimer();\n+        final int numRecords = 1327;\n+        final int chunkSize  = 42;\n+        final int numChunks  = 1 + (numRecords / chunkSize);\n+\n+        List<TestRecords1Proto.MySimpleRecord> records = LongStream.range(0, numRecords).mapToObj(val ->\n+                TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).build()\n+        ).collect(Collectors.toList());\n+        Index srcIndex = new Index(\"src_index\", field(\"num_value_2\"), EmptyKeyExpression.EMPTY, IndexTypes.VALUE, IndexOptions.UNIQUE_OPTIONS);\n+        Index tgtIndex = new Index(\"tgt_index\", field(\"num_value_3_indexed\"), IndexTypes.VALUE);\n+\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> {\n+            metaDataBuilder.addIndex(\"MySimpleRecord\", srcIndex);\n+            metaDataBuilder.addIndex(\"MySimpleRecord\", tgtIndex);\n+        } ;\n+\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext())  {\n+            records.forEach(recordStore::saveRecord);\n+            context.commit();\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            try (OnlineIndexer indexBuilder = OnlineIndexer.newBuilder()\n+                    .setDatabase(fdb).setMetaData(metaData).setIndex(srcIndex).setSubspace(subspace)\n+                    .build()) {\n+                recordStore.markIndexWriteOnly(srcIndex).join();\n+                indexBuilder.rebuildIndex(recordStore);\n+                recordStore.markIndexReadable(srcIndex).join();\n+                context.commit();\n+                assertTrue(recordStore.isIndexReadable(srcIndex));\n+            }\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            recordStore.markIndexWriteOnly(tgtIndex).join();\n+            context.commit();\n+            assertTrue(recordStore.isIndexWriteOnly(tgtIndex));\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (OnlineIndexer indexBuilder = OnlineIndexer.newBuilder()\n+                .setDatabase(fdb).setMetaData(metaData).setIndex(tgtIndex).setSubspace(subspace)\n+                .setIndexFromIndex(new OnlineIndexer.IndexFromIndexRequest(\"src_index\")\n+                        .mustUseSourceIndex())\n+                .setLimit(chunkSize)\n+                .setTimer(timer)\n+                .build()) {\n+\n+            indexBuilder.buildIndexAsync(true)\n+                    .handle((ignore, e) ->\n+                    {\n+                        assertNull(e);\n+                        return null;\n+                    })\n+                    .join();\n+        }\n+        assertEquals(numRecords, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED));\n+        assertEquals(numRecords, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED));\n+        assertEquals(numChunks , timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGES_BY_COUNT));\n+    }\n+\n+    @Test\n+    public void testIndexFromIndexFallback() {\n+\n+        final FDBStoreTimer timer = new FDBStoreTimer();\n+        final long numRecords = 6;\n+\n+        List<TestRecords1Proto.MySimpleRecord> records = LongStream.range(0, numRecords).mapToObj(val ->\n+                TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).build()\n+        ).collect(Collectors.toList());\n+        Index srcIndex = new Index(\"src_index\", field(\"num_value_2\"), EmptyKeyExpression.EMPTY, IndexTypes.VALUE, IndexOptions.UNIQUE_OPTIONS);\n+        Index tgtIndex = new Index(\"tgt_index\", field(\"num_value_3_indexed\").ungrouped(), IndexTypes.SUM);\n+\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> {\n+            metaDataBuilder.addIndex(\"MySimpleRecord\", srcIndex);\n+            metaDataBuilder.addIndex(\"MySimpleRecord\", tgtIndex);\n+        } ;\n+\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext())  {\n+            records.forEach(recordStore::saveRecord);\n+            context.commit();\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            try (OnlineIndexer indexBuilder = OnlineIndexer.newBuilder()\n+                    .setDatabase(fdb).setMetaData(metaData).setIndex(srcIndex).setSubspace(subspace)\n+                    .build()) {\n+                recordStore.markIndexWriteOnly(srcIndex).join();\n+                indexBuilder.rebuildIndex(recordStore);\n+                recordStore.markIndexReadable(srcIndex).join();\n+                context.commit();\n+                assertTrue(recordStore.isIndexReadable(srcIndex));\n+            }\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            recordStore.markIndexWriteOnly(tgtIndex).join();\n+            context.commit();\n+            assertTrue(recordStore.isIndexWriteOnly(tgtIndex));\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (OnlineIndexer indexBuilder = OnlineIndexer.newBuilder()\n+                .setDatabase(fdb).setMetaData(metaData).setIndex(tgtIndex).setSubspace(subspace)\n+                .setIndexFromIndex(new OnlineIndexer.IndexFromIndexRequest(\"src_index\"))\n+                .setTimer(timer)\n+                .build()) {\n+\n+            indexBuilder.buildIndexAsync(true)\n+                    .handle((ignore, e) ->\n+                    {\n+                        assertNull(e);\n+                        return null;\n+                    })\n+                    .join();\n+        }\n+        assertEquals(numRecords, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED));\n+        assertEquals(numRecords, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED));\n+    }\n+\n+    @Test\n+    public void testIndexFromIndexNoFallback() {\n+\n+        final FDBStoreTimer timer = new FDBStoreTimer();\n+        final long numRecords = 7;\n+\n+        List<TestRecords1Proto.MySimpleRecord> records = LongStream.range(0, numRecords).mapToObj(val ->\n+                TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).build()\n+        ).collect(Collectors.toList());\n+        Index srcIndex = new Index(\"src_index\", field(\"num_value_2\"), EmptyKeyExpression.EMPTY, IndexTypes.VALUE, IndexOptions.UNIQUE_OPTIONS);\n+        Index tgtIndex = new Index(\"tgt_index\", field(\"num_value_3_indexed\").ungrouped(), IndexTypes.SUM);\n+\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> {\n+            metaDataBuilder.addIndex(\"MySimpleRecord\", srcIndex);\n+            metaDataBuilder.addIndex(\"MySimpleRecord\", tgtIndex);\n+        } ;\n+\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext())  {\n+            records.forEach(recordStore::saveRecord);\n+            context.commit();\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            try (OnlineIndexer indexBuilder = OnlineIndexer.newBuilder()\n+                    .setDatabase(fdb).setMetaData(metaData).setIndex(srcIndex).setSubspace(subspace)\n+                    .build()) {\n+                recordStore.markIndexWriteOnly(srcIndex).join();\n+                indexBuilder.rebuildIndex(recordStore);\n+                recordStore.markIndexReadable(srcIndex).join();\n+                context.commit();\n+                assertTrue(recordStore.isIndexReadable(srcIndex));\n+            }\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            recordStore.markIndexWriteOnly(tgtIndex).join();\n+            context.commit();\n+            assertTrue(recordStore.isIndexWriteOnly(tgtIndex));\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (OnlineIndexer indexBuilder = OnlineIndexer.newBuilder()\n+                .setDatabase(fdb).setMetaData(metaData).setIndex(tgtIndex).setSubspace(subspace)\n+                .setIndexFromIndex(new OnlineIndexer.IndexFromIndexRequest(\"src_index\")\n+                        .mustUseSourceIndex())\n+                .setTimer(timer)\n+                .build()) {\n+\n+            indexBuilder.buildIndexAsync(true)\n+                    .handle((ignore, e) ->\n+                    {\n+                        assertNotNull(e);", "originalCommit": "7c853b8bd3f6c4175738c2dec66fbd748ca6c65e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzcwNzEzNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r543707136", "bodyText": "Nice!", "author": "jjezra", "createdAt": "2020-12-15T21:42:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQzMDYxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQzMzQzNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r540433436", "bodyText": "It looks like this is missing tests on:\n\nMulti-type indexes\nThe source index is on the wrong type(s)\nThe source index is not a VALUE index\nThere are concurrent builds\nAn index build from an index takes over from an index build without an index and vice versa\nThe meta-data change midway through a build (might be somewhat hard to simulate)\n\nIt would also be nice if the tests validated that the index looked correct (perhaps by running an index validation on the resulting index). I'm not sure if the tests in the other files do that or not, though perhaps they should as well.\nIf you can think of other test cases, @nblintao, it would be good to enumerate them, too.", "author": "alecgrieser", "createdAt": "2020-12-10T19:21:01Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerIndexFromIndexTest.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * OnlineIndexerIndexFromIndexTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.record.TestRecords1Proto;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexOptions;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.expressions.EmptyKeyExpression;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+\n+import static com.apple.foundationdb.record.metadata.Key.Expressions.field;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests for building indexes from other indexes with {@link OnlineIndexer}.\n+ */\n+\n+public class OnlineIndexerIndexFromIndexTest extends OnlineIndexerTest {", "originalCommit": "7c853b8bd3f6c4175738c2dec66fbd748ca6c65e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA2Mjc2Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553062762", "bodyText": "Did these tests get added?", "author": "alecgrieser", "createdAt": "2021-01-07T01:45:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQzMzQzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5NzI4MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553097280", "bodyText": "Only the third. Still struggling with the others.", "author": "jjezra", "createdAt": "2021-01-07T04:04:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQzMzQzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0NDM1NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r541144354", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    @Nullable\n          \n          \n            \n                    public IndexFromIndexRequest indexFromIndex = null;\n          \n          \n            \n                    @Nonnull\n          \n          \n            \n                    public IndexFromIndexRequest indexFromIndex = NOT_INDEX_FROM_INDEX;", "author": "nblintao", "createdAt": "2020-12-11T18:29:04Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1709,6 +1736,8 @@ public Config build() {\n         protected Index index;\n         @Nullable\n         protected Collection<RecordType> recordTypes;\n+        @Nullable\n+        public IndexFromIndexRequest indexFromIndex = null;", "originalCommit": "7c853b8bd3f6c4175738c2dec66fbd748ca6c65e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "da0e270d6d51ebd3ab0739754005370f31484572", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/da0e270d6d51ebd3ab0739754005370f31484572", "message": "Resolve #1078: Allow creating an index from an existing index\n\n    When building a single type idempotent index, provide the user with an option\n    to request an iteration over an existing, readable, source index instead of a\n    full records store scan.\n\n    This commit squashes all 'index from index' commits (pre refactoring)\n\n    TODO: OnlineIndexer refactor\n    TODO: add more unit tests\n\nConvert 'asssert' to 'assertTrue'", "committedDate": "2020-12-18T01:51:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg2NzYyMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r546867620", "bodyText": "This one should be private.", "author": "nblintao", "createdAt": "2020-12-21T18:41:42Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2479,6 +2713,119 @@ private static void checkPositive(int value, String desc) {\n         }\n     }\n \n+    /**\n+     * A builder for the  indexFromIndex policy. Let the caller set a source index and a fallback policy.\n+     */\n+    public static class IndexFromIndexPolicy {\n+        public static final IndexFromIndexPolicy INACTIVE = new IndexFromIndexPolicy();\n+        @Nullable private final String sourceIndex;\n+        private final boolean allowRecordScan;\n+\n+        /**\n+         * Build the index from a source index. Source index must be readable, idempotent, and fully cover the target index.\n+         * @param sourceIndex source index\n+         * @param allowRecordScan allow fallback to record scan\n+         */\n+        public IndexFromIndexPolicy(@Nonnull String sourceIndex, boolean allowRecordScan) {\n+            this.sourceIndex = sourceIndex;\n+            this.allowRecordScan = allowRecordScan;\n+        }\n+\n+        /**\n+         * Build a non-active object.\n+         */\n+        public IndexFromIndexPolicy() {", "originalCommit": "da0e270d6d51ebd3ab0739754005370f31484572", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4ODQyNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553488427", "bodyText": "hmm, have you pushed your change?", "author": "nblintao", "createdAt": "2021-01-07T17:54:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg2NzYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU4NjA5NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553586094", "bodyText": "Yes. I can't make it private now.", "author": "jjezra", "createdAt": "2021-01-07T21:03:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg2NzYyMA=="}], "type": "inlineReview"}, {"oid": "5f60eb372dabc1b72f2501a2f8d60f84119b6d09", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/5f60eb372dabc1b72f2501a2f8d60f84119b6d09", "message": "refactor OnlineIndexer to the structure below:\n\n  OnlineIndexer: User API + defines OnlineIndexer.Config, OnlineIndexer.IndexFromIndexPolicy, OnlineIndexer.RecordBuiltRangeException\n      Scanners:\n      OnlineIndexerScanner: base class for scanners\n          OnlineIndexerByRecords: scan by records (all records in DB)\n          OnlineIndexerByIndex: scan by source index\n             Scanners' Helper:\n             OnlineIndexerThrottle: (implements buildAsync) wraps run/commit/retry with workload adjustment on success/failure\n      Shared classes:\n      OnlineIndexerCommon: holds the operation's setup for all classes\n      OnlineIndexerException: scanner's exception", "committedDate": "2021-01-03T17:07:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIwODE4Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r552208186", "bodyText": "It might be worthwhile to move this and the other new classes into a nested package (e.g. foundationdb.indexing). I can definitely imagine a whole bunch of other implementations, and other utilities in this space, such that pulling out the internals would make sense.", "author": "ScottDugas", "createdAt": "2021-01-05T21:28:44Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerByIndex.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * OnlineIndexerByIndex.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.MutationType;\n+import com.apple.foundationdb.TransactionContext;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.RangeSet;\n+import com.apple.foundationdb.record.ExecuteProperties;\n+import com.apple.foundationdb.record.IndexScanType;\n+import com.apple.foundationdb.record.IsolationLevel;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorResult;\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.RecordMetaDataProvider;\n+import com.apple.foundationdb.record.ScanProperties;\n+import com.apple.foundationdb.record.TupleRange;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.MetaDataException;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.ByteArrayUtil2;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.google.protobuf.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * This indexer scans records by a source index.\n+ */\n+@API(API.Status.UNSTABLE)\n+public class OnlineIndexerByIndex extends OnlineIndexerScanner {", "originalCommit": "852294da638072eacc2d82f745e8d2114de9757a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI0OTUyOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r552249528", "bodyText": "++", "author": "jjezra", "createdAt": "2021-01-05T22:59:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIwODE4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzcwNTg2NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553705865", "bodyText": "I can't move the new classes to foudationdb.indexing without changing many package-private methods they're using.", "author": "jjezra", "createdAt": "2021-01-08T02:30:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIwODE4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzMjkxOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556932919", "bodyText": "What package-private methods are they using? That could also be a sign that the abstractions aren't quite right", "author": "alecgrieser", "createdAt": "2021-01-13T22:57:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIwODE4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU5MzUzMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r557593532", "bodyText": "Mostly the FDBRecordStore & OnlineIndexer:\nMethod IndexingBase.handleStateAndDoBuildIndexAsync(boolean, KeyValueLogMessage) uses package-private method FDBRecordStore.clearIndexData(Index)\nMethod IndexingBase.rebuildIndexAsync(FDBRecordStore) uses package-private method FDBRecordStore.clearIndexData(Index)\nMethod IndexingByRecords.buildUnbuiltRange(Evaluated, Evaluated) will be inaccessible from method OnlineIndexer.buildUnbuiltRange(Evaluated, Evaluated)\nMethod IndexingBase.buildIndexAsync(boolean) will be inaccessible from method OnlineIndexer.buildIndexAsync(boolean)\nField IndexMaintainer.state will be inaccessible from method RecordsWhereDeleter.deleteRecordsWhereCheckIndexes()\nField IndexMaintainer.state will be inaccessible from method RecordsWhereDeleter.run()\nField IndexMaintainer.state will be inaccessible from method IndexFunctionHelper.indexMaintainerForRecordFunction(FDBRecordStore, IndexRecordFunction, List) \nField IndexMaintainer.state will be inaccessible from method IndexFunctionHelper.indexMaintainerForAggregateFunction(FDBRecordStore, IndexAggregateFunction, List)\nField IndexMaintainer.state will be inaccessible from method IndexFunctionHelper.bindAggregateFunction(FDBRecordStore, IndexAggregateFunction, List)  \nMethod IndexingByIndex.buildRangeOnly(FDBRecordStore, byte[], AtomicLong) uses package-private method FDBRecordStore.encodeRecordCount(long)  \nMethod IndexingByRecords.buildRangeOnly(FDBRecordStore, TupleRange, boolean, AtomicLong) uses package-private method FDBRecordStore.encodeRecordCount(long) \nMethod IndexingBase.runAsync(Function>, BiFunction>, BiConsumer>, List) will be inaccessible from method OnlineIndexer.runAsync(Function>, BiFunction>, BiConsumer>, List)  \nMethod IndexingBase.indexBuildLockSubspace(FDBRecordStoreBase, Index) uses package-private method FDBRecordStore.indexBuildSubspace(Index)\nMethod IndexingBase.indexBuildScannedRecordsSubspace(FDBRecordStoreBase, Index) uses package-private method FDBRecordStore.indexBuildSubspace(Index)  \nMethod IndexingBase.indexBuildTypeSubspace(FDBRecordStoreBase, Index) uses package-private method FDBRecordStore.indexBuildSubspace(Index)\nMethod IndexingBase.decreaseLimit(FDBException, List) will be inaccessible from method OnlineIndexer.decreaseLimit(FDBException, List)", "author": "jjezra", "createdAt": "2021-01-14T18:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIwODE4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxMTE0Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r552211142", "bodyText": "What is tgt? Probably should be replaced with something that is not an acronym. It appears to show up elsewhere so probably worth more general replacements.", "author": "ScottDugas", "createdAt": "2021-01-05T21:32:01Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerByIndex.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * OnlineIndexerByIndex.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.MutationType;\n+import com.apple.foundationdb.TransactionContext;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.RangeSet;\n+import com.apple.foundationdb.record.ExecuteProperties;\n+import com.apple.foundationdb.record.IndexScanType;\n+import com.apple.foundationdb.record.IsolationLevel;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorResult;\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.RecordMetaDataProvider;\n+import com.apple.foundationdb.record.ScanProperties;\n+import com.apple.foundationdb.record.TupleRange;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.MetaDataException;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.ByteArrayUtil2;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.google.protobuf.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * This indexer scans records by a source index.\n+ */\n+@API(API.Status.UNSTABLE)\n+public class OnlineIndexerByIndex extends OnlineIndexerScanner {\n+    @Nonnull private static final Logger LOGGER = LoggerFactory.getLogger(OnlineIndexerByIndex.class);\n+    @Nonnull private final OnlineIndexer.IndexFromIndexPolicy policy;\n+\n+    OnlineIndexerByIndex(@Nonnull OnlineIndexerCommon common,\n+                         @Nonnull OnlineIndexer.IndexFromIndexPolicy policy) {\n+        super(common);\n+        this.policy = policy;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    CompletableFuture<Void> scanBuildIndexAsync() {\n+\n+        return getRunner().runAsync(context -> common.openRecordStore(context)\n+                .thenCompose( store -> {\n+                    // first verify that both src and tgt are of a single, similar, type\n+                    final RecordMetaData metaData = store.getRecordMetaData();\n+                    final Index srcIndex = metaData.getIndex(Objects.requireNonNull(policy.getSourceIndex()));\n+                    final Collection<RecordType> srcRecordTypes = metaData.recordTypesForIndex(srcIndex);\n+\n+                    if (common.isSyntheticIndex() ||\n+                            common.recordTypes.size() != 1) {\n+                        buildIndexFromIndexThrowEx(\"IndexFromIndex: tgt cannot be scanned from index\");", "originalCommit": "852294da638072eacc2d82f745e8d2114de9757a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI0ODgwMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r552248800", "bodyText": "Oh, tgt index vs. src index. I'll clarify this log message.", "author": "jjezra", "createdAt": "2021-01-05T22:57:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxMTE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4NDU2NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553484564", "bodyText": "Oh, target. Even with that it took me like 3 minutes to figure it out.", "author": "ScottDugas", "createdAt": "2021-01-07T17:47:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxMTE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxNDMyNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r552214326", "bodyText": "I suspect all of these should be labeled with @API(API.Status.INTERNAL)", "author": "ScottDugas", "createdAt": "2021-01-05T21:37:15Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerByRecords.java", "diffHunk": "@@ -0,0 +1,677 @@\n+/*\n+ * OnlineIndexerByRecords.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.MutationType;\n+import com.apple.foundationdb.Range;\n+import com.apple.foundationdb.ReadTransactionContext;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncIterator;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.RangeSet;\n+import com.apple.foundationdb.record.EndpointType;\n+import com.apple.foundationdb.record.ExecuteProperties;\n+import com.apple.foundationdb.record.IsolationLevel;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorResult;\n+import com.apple.foundationdb.record.ScanProperties;\n+import com.apple.foundationdb.record.TupleRange;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.MetaDataException;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.ByteArrayUtil2;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.Message;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ *  This indexer scans all records in the datastore.\n+ */\n+@API(API.Status.UNSTABLE)", "originalCommit": "852294da638072eacc2d82f745e8d2114de9757a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxNTkyMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r552215921", "bodyText": "I haven't given this much thought, but could this have issues with split records? (this may also be the same code as before)", "author": "ScottDugas", "createdAt": "2021-01-05T21:40:45Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerByRecords.java", "diffHunk": "@@ -0,0 +1,677 @@\n+/*\n+ * OnlineIndexerByRecords.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.MutationType;\n+import com.apple.foundationdb.Range;\n+import com.apple.foundationdb.ReadTransactionContext;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncIterator;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.RangeSet;\n+import com.apple.foundationdb.record.EndpointType;\n+import com.apple.foundationdb.record.ExecuteProperties;\n+import com.apple.foundationdb.record.IsolationLevel;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorResult;\n+import com.apple.foundationdb.record.ScanProperties;\n+import com.apple.foundationdb.record.TupleRange;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.MetaDataException;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.ByteArrayUtil2;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.Message;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ *  This indexer scans all records in the datastore.\n+ */\n+@API(API.Status.UNSTABLE)\n+public class OnlineIndexerByRecords extends OnlineIndexerScanner {\n+    @Nonnull private static final Logger LOGGER = LoggerFactory.getLogger(OnlineIndexerByRecords.class);\n+\n+    @Nonnull private final TupleRange recordsRange;\n+    @Nonnull private static final byte[] START_BYTES = new byte[]{0x00};\n+    @Nonnull private static final byte[] END_BYTES = new byte[]{(byte)0xff};\n+\n+\n+    OnlineIndexerByRecords(@Nonnull OnlineIndexerCommon common) {\n+        super(common);\n+        this.recordsRange = computeRecordsRange();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    CompletableFuture<Void> scanBuildIndexAsync() {\n+        return buildEndpoints().thenCompose(tupleRange -> {\n+            if (tupleRange != null) {\n+                return buildRange(Key.Evaluated.fromTuple(tupleRange.getLow()), Key.Evaluated.fromTuple(tupleRange.getHigh()));\n+            } else {\n+                return CompletableFuture.completedFuture(null);\n+            }\n+        });\n+    }\n+\n+    private void maybeLogBuildProgress(SubspaceProvider subspaceProvider, Tuple startTuple, Tuple endTuple, Tuple realEnd) {\n+        if (LOGGER.isInfoEnabled() && shouldLogBuildProgress()) {\n+            LOGGER.info(KeyValueLogMessage.of(\"Built Range\",\n+                    LogMessageKeys.INDEX_NAME, common.getIndex().getName(),\n+                    LogMessageKeys.INDEX_VERSION, common.getIndex().getLastModifiedVersion(),\n+                    subspaceProvider.logKey(), subspaceProvider,\n+                    LogMessageKeys.START_TUPLE, startTuple,\n+                    LogMessageKeys.END_TUPLE, endTuple,\n+                    LogMessageKeys.REAL_END, realEnd,\n+                    LogMessageKeys.RECORDS_SCANNED, common.getTotalRecordsScanned().get()),\n+                    LogMessageKeys.INDEXER_ID, common.getUuid());\n+        }\n+    }\n+\n+    @Nonnull\n+    private TupleRange computeRecordsRange() {\n+        Tuple low = null;\n+        Tuple high = null;\n+        for (RecordType recordType : common.recordTypes) {\n+            if (!recordType.primaryKeyHasRecordTypePrefix() || recordType.isSynthetic()) {\n+                // If any of the types to build for does not have a prefix, give up.\n+                return TupleRange.ALL;\n+            }\n+            Tuple prefix = recordType.getRecordTypeKeyTuple();\n+            if (low == null) {\n+                low = high = prefix;\n+            } else {\n+                if (low.compareTo(prefix) > 0) {\n+                    low = prefix;\n+                }\n+                if (high.compareTo(prefix) < 0) {\n+                    high = prefix;\n+                }\n+            }\n+        }\n+        if (low == null) {\n+            return TupleRange.ALL;\n+        } else {\n+            // Both ends inclusive.\n+            return new TupleRange(low, high, EndpointType.RANGE_INCLUSIVE, EndpointType.RANGE_INCLUSIVE);\n+        }\n+    }\n+\n+    /**\n+     * Builds (transactionally) the endpoints of an index. What this means is that builds everything from the beginning of\n+     * the key space to the first record and everything from the last record to the end of the key space.\n+     * There won't be any records within these ranges (except for the last record of the record store), but\n+     * it does mean that any records in the future that get added to these ranges will correctly update\n+     * the index. This means, e.g., that if the workload primarily adds records to the record store\n+     * after the current last record (because perhaps the primary key is based off of an atomic counter\n+     * or the current time), running this method will be highly contentious, but once it completes,\n+     * the rest of the index build should happen without any more conflicts.\n+     *\n+     * This will return a (possibly null) {@link TupleRange} that contains the primary keys of the\n+     * first and last records within the record store. This can then be used to either build the\n+     * range right away or to then divy-up the remaining ranges between multiple agents working\n+     * in parallel if one desires.\n+     *\n+     * @param store the record store in which to rebuild the index\n+     * @param recordsScanned continues counter\n+     * @return a future that will contain the range of records in the interior of the record store\n+     */\n+\n+    @Nonnull\n+    public CompletableFuture<TupleRange> buildEndpoints(@Nonnull FDBRecordStore store,\n+                                                        @Nullable AtomicLong recordsScanned) {\n+        final RangeSet rangeSet = new RangeSet(store.indexRangeSubspace(common.getIndex()));\n+        if (TupleRange.ALL.equals(recordsRange)) {\n+            return buildEndpoints(store, rangeSet, recordsScanned);\n+        }\n+        // If records do not occupy whole range, first mark outside as built.\n+        final Range asRange = recordsRange.toRange();\n+        return CompletableFuture.allOf(\n+                rangeSet.insertRange(store.ensureContextActive(), null, asRange.begin),\n+                rangeSet.insertRange(store.ensureContextActive(), asRange.end, null))\n+                .thenCompose(vignore -> buildEndpoints(store, rangeSet, recordsScanned));\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<TupleRange> buildEndpoints(@Nonnull FDBRecordStore store, @Nonnull RangeSet rangeSet,\n+                                                         @Nullable AtomicLong recordsScanned) {\n+        boolean isIdempotent = store.getIndexMaintainer(common.getIndex()).isIdempotent();\n+        final IsolationLevel isolationLevel =\n+                isIdempotent ?\n+                // If idempotent: since double indexing is harmless, we can use individual records protection instead of", "originalCommit": "852294da638072eacc2d82f745e8d2114de9757a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1MDA0MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r552250041", "bodyText": "This change gotten in a few months ago. I'm not sure what's the \"split records\" implications.", "author": "jjezra", "createdAt": "2021-01-05T23:01:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxNTkyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg1MTI0Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r552851246", "bodyText": "@jjezra \"Split records\" means storing a record with more than one key-value pair (when the record value is too large to be stored in a FDB value)\n@ScottDugas Good point. I didn't check how w/r split records was implemented so I don't have an answer yet. But even if it's not an issues, I think we can at least a test to prove it. Created #1093", "author": "nblintao", "createdAt": "2021-01-06T17:45:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxNTkyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk1MTEwMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r552951103", "bodyText": "Is there any way to change one of the value's continuation records without changing the first one? I assume that all the records of a single value are written in one transaction.", "author": "jjezra", "createdAt": "2021-01-06T20:41:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxNTkyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA0Njg5Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553046893", "bodyText": "It might make sense to move the discussion to the issue, especially if it's going to not be changed in this PR.\nI'm a little confused on the terminology you're using here. I think what you're trying to ask is: if you have a single record which is split across multiple FDB keys (because it's too big), is it possible that some (but not all) of those keys get updated in a transaction?\nAt the moment, the answer to that question is \"no\". The data are serialized so that each key is numbered, and keys 0 through n all contain chunks of protobuf data (possibly compressed or encrypted if one is using the TransformedRecordSerializer). In theory, one could edit just some of the protobuf data and not mess things up, but it would be a Bad Idea\u2122. It should be practically impossible to do that if it's compressed/encrypted. However, at split point -1, we keep the record version (i.e., the database version at which the record was committed). In theory, you could imagine we could implement something like \"touch\" where we bump the version of a record without changing the record. We don't currently support that operation, but it's a thing we might want at some point. And similarly, you could imagine that one day, we might want to use additional split points to store additional fields that we specifically want to allow the user to mutate without rewriting the full record.\nSo, tl;dr, if I understood your question correctly, the answer right now is \"no, records are always rewritten in their entirety\", but that may be something we will want to change in the future.\n\nThat being said, I'm not sure if it's totally relevant here. The conflict ranges we place on a record cover all possible keys that a record may cover.", "author": "alecgrieser", "createdAt": "2021-01-07T00:47:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxNTkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxNzM4MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r552217380", "bodyText": "Ignoring my desires to have a slightly different class layout, this class does all of the index building correct? Not just scanning, the only real method this provides is buildIndexAsync which does the entire build.\nAt the very least the javadoc and name should be updated.", "author": "ScottDugas", "createdAt": "2021-01-05T21:43:54Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerScanner.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * OnlineIndexerScanner.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.FDBException;\n+import com.apple.foundationdb.Transaction;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.MoreAsyncUtil;\n+import com.apple.foundationdb.async.RangeSet;\n+import com.apple.foundationdb.record.IndexState;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorResult;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.provider.foundationdb.synchronizedsession.SynchronizedSessionRunner;\n+import com.apple.foundationdb.record.query.plan.synthetic.SyntheticRecordFromStoredRecordPlan;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.Message;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A base class for different types of online indexing scanners.", "originalCommit": "852294da638072eacc2d82f745e8d2114de9757a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1MTAxNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r552251014", "bodyText": "I thought that OnlineIndexerBuilder would have been a little confusing :)\nHow would you name this \"scan & build\" class?", "author": "jjezra", "createdAt": "2021-01-05T23:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxNzM4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ5MDc3Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553490776", "bodyText": "FYI: IIRC OnlineIndexer actually used to be OnlineIndexBuilder, but, then it became confusing to have OnlineIndexBuilder.Builder, so it was renamed.\nPerhaps InternalOnlineIndexer or OnlineIndexerBase or AbstractOnlineIndexer, both of those are kind of confusing, because, in theory the current OnlineIndexer is simply a shell around this class with a bunch of helper methods for various types of scans. I think I like AbstractOnlineIndexer the best, although an explanation in javadocs would probably be valuable to explain the difference between AbstractOnlineIndexer and OnlineIndexer.\nAlso, Naming is one of the hard problems in CS, but if naming is hard, it's sometimes a sign that the abstraction is somewhat off. In this case though, I think it's that the logical name is already taken by OnlineIndexer", "author": "ScottDugas", "createdAt": "2021-01-07T17:58:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxNzM4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUxNDU0Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553514547", "bodyText": "How about OnlineIndexer for the API and Indexer or IndexMaker prefix for the internal implementation classes?\nSo it'll be\nIndexerBase\nIndexerByRecords\netc.", "author": "jjezra", "createdAt": "2021-01-07T18:45:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxNzM4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUzMzI2MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553533261", "bodyText": "Or Indexing -\nIndexingBase\nIndexingByRecord\nIndexingThrottle\nSeems to be more descriptive.", "author": "jjezra", "createdAt": "2021-01-07T19:22:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxNzM4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzcwNDcyNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553704727", "bodyText": "I've renamed to Indexing*. Note that I hadn't move these classes to a new package because they seem to be using many package-private entities. I hope it'll be ok for now.", "author": "jjezra", "createdAt": "2021-01-08T02:26:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxNzM4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTMwNjY3Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r555306677", "bodyText": "Yeah, Indexing* sounds fine", "author": "ScottDugas", "createdAt": "2021-01-11T20:06:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxNzM4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxOTg4Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r552219882", "bodyText": "Perhaps worth labelling this as UNSTABLE until the api can be cleaned up to be more generic.\nAt the very least it seems like when this becomes generic, it will have a config, and OnlineIndexerCommon will have a ThrottledRunnerConfig (or whatever it gets called)", "author": "ScottDugas", "createdAt": "2021-01-05T21:49:24Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerThrottle.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * OnlineIndexerThrottle.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.FDBError;\n+import com.apple.foundationdb.FDBException;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.MoreAsyncUtil;\n+import com.apple.foundationdb.record.IndexState;\n+import com.apple.foundationdb.record.RecordCoreStorageException;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.util.LoggableException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+/**\n+ * This class provides build / commit /retry with throttling to the OnlineIndexer. In the future,\n+ * this class can be generalized to serve other FDB modules.\n+ *\n+ */\n+public class OnlineIndexerThrottle {", "originalCommit": "852294da638072eacc2d82f745e8d2114de9757a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA2MDc5MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553060791", "bodyText": "I actually think we want this to be INTENRAL, like the other classes that were added", "author": "alecgrieser", "createdAt": "2021-01-07T01:37:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxOTg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIyMDY5OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r552220698", "bodyText": "Should there be a different one that is retriable?", "author": "ScottDugas", "createdAt": "2021-01-05T21:51:19Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerException.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * MetaDataException.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.RecordCoreException;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Exception thrown when there is a problem in {@link com.apple.foundationdb.record.provider.foundationdb.OnlineIndexer} during indexing.\n+ */\n+@SuppressWarnings(\"serial\")\n+@API(API.Status.INTERNAL)\n+public class OnlineIndexerException extends RecordCoreException {", "originalCommit": "852294da638072eacc2d82f745e8d2114de9757a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1MjgzNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r552252836", "bodyText": "Do you mean the backward compatible OnlineIndexer.RecordBuiltRangeException?", "author": "jjezra", "createdAt": "2021-01-05T23:09:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIyMDY5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ5Mjc1MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553492750", "bodyText": "No, I'm saying that, I think that there should be exceptions that can get thrown by an indexer that are retriable for various definitions of retriable. For example, timing out on something, or hitting a limit, or having too many transaction conflicts. Others are probably not retriable, like Uniqueness violations, or maybe RecordBuiltRangeException", "author": "ScottDugas", "createdAt": "2021-01-07T18:02:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIyMDY5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUyNTg1MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553525851", "bodyText": "I think I can see your point - it would be nice and clean to have two types of indexer exception - retriable and not. But since this PR is already a monster, maybe this change should be left for another PR? The existing logic and exceptions hadn't changed.", "author": "jjezra", "createdAt": "2021-01-07T19:07:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIyMDY5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzNTk4OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r552235989", "bodyText": "This still feels like not quite the right abstraction. It's a step in the right direction, for sure, but it still seems off.\nFull disclosure, I'm surely affected by my preference against inheritance, and my ideas before I saw your approach.\nAnd perhaps I may be having a desire to over-architect the design based on the models I have in my head.\nI think, at least one place this manifests itself is the fact that OnlineIndexerByRecords is the only one that can build an individual range, which seems weird, or more, it seems weird that adding it to OnlineIndexerByIndex requires any implementation at all.\nI may be oversimplifying, but it seems like having the two classes that currently extend from this as separate source classes that don't really know anything about writing index entries, or directly know about the index build state.\nGenerally a trick that I like to figure out how to build abstractions when there aren't a lot of implementations, is to think about how to test things.\nSpecifically of note, right now if you want to test any of the components of OnlineIndexer you have to build an index. I'm not saying we should expose all sorts of private members, but a different api might allow us to test these more in isolation. For example, I suspect we could have a simple clean IndexerSource interface, and then we could have a whole slew of tests for scanning records, versus indexes, versus multi-type indexes, etc. And all we would have to assert about is that every record is returned, always. And if the Throttle was completely decoupled (as you implied in the javadoc), we could more easily test that with random lambdas that do things like throw various retryable exceptions, etc. And it seems like you should be able to isolate the index writing part, although non-idempotent indexes might make that harder.\nAll that being said, as far as this PR goes, I would say just mark everything as INTERNAL, since nobody should really be using these classes directly anyways, and it can be hashed out / cleaned up as more behavior is added / improved.", "author": "ScottDugas", "createdAt": "2021-01-05T22:25:58Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerScanner.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * OnlineIndexerScanner.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.FDBException;\n+import com.apple.foundationdb.Transaction;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.MoreAsyncUtil;\n+import com.apple.foundationdb.async.RangeSet;\n+import com.apple.foundationdb.record.IndexState;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorResult;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.provider.foundationdb.synchronizedsession.SynchronizedSessionRunner;\n+import com.apple.foundationdb.record.query.plan.synthetic.SyntheticRecordFromStoredRecordPlan;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.Message;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A base class for different types of online indexing scanners.\n+ */\n+public abstract class OnlineIndexerScanner {", "originalCommit": "852294da638072eacc2d82f745e8d2114de9757a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI4NTQ5Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r552285493", "bodyText": "A range, if I understand it correctly, can be considered as a db's \"(interval]\" (opened at one endpoint, closed at the other) - hence a db-range. When not scanning by db records but in arbitrary order (like a source index), is there any meaningful db-range?\nWe can surely use  source index continuation pointers that can be considered as splitting the index into index-ranges, yet any existing 'single range' test would crash if attempting a db-ranges enforcement on a source index scan. What am I missing?\nI agree, of course, with the rest of the comment and will try to improve the code.", "author": "jjezra", "createdAt": "2021-01-06T00:25:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzNTk4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA1MjAwNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553052005", "bodyText": "I suppose we'd have to define the meaning, but I think it would be sensible to say that the definition of the \"range\" involved depends on the IndexerSource in question. So for the by records source, that means primary key range; for the by index source, that means ranges of index entries (or index entry keys).\n\nWe can surely use source index continuation pointers that can be considered as splitting the index into index-ranges,\n\nKind of. Note that continuations aren't quite the right solution here as splitting the index into ranges accomplishes two things:\n\nBeing able to resume an index build if one stops in the middle. Continuations would be fine to use here.\nBeing able to split up an index build and farm each piece to its own worker. The logic for that currently only exists for splitting by primary key, but splitting the index up by entry key should be able to accomplish the same thing (I think).\n\n\nyet any existing 'single range' test would crash if attempting a db-ranges enforcement on a source index scan\n\nWell, I'm not sure it would crash--it may just have incorrect behavior (including but not limited to not indexing all records). But yeah, it would be bad. That's part of the reason I had initially mentioned in a design document/review comment (I think) that this would require storing in the database what index building strategy was used and then checking it to make sure an index build wasn't incorrectly resumed.\nNote that as that is a change that can change what gets stored, it's kind of important we settle on what we want now.", "author": "alecgrieser", "createdAt": "2021-01-07T01:05:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzNTk4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA1Mzc1Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553053752", "bodyText": "One other thing that's unclear to me from this class structure: what's the difference between what goes in OnlineIndexerCommon and what goes in the OnlineIndexerScanner base class?", "author": "alecgrieser", "createdAt": "2021-01-07T01:12:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzNTk4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5Nzg0OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553097849", "bodyText": "The common class just holds the setup/metadata (+ few getters) and used by all classes (including the interface). The scanner class and its derivatives are implementing the scan & index algorithm", "author": "jjezra", "createdAt": "2021-01-07T04:07:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzNTk4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ5NzM3Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553497373", "bodyText": "I think @alecgrieser correctly rephrased my thoughts (with valuable elaboration).\nIn addition to storing the strategy, you would have to store the source index subspace key, and maybe should include the metadata version.", "author": "ScottDugas", "createdAt": "2021-01-07T18:10:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzNTk4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUwMjQ4MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553502480", "bodyText": "Yeah, I think it would be index subspace key and the index's last modified meta-data version", "author": "alecgrieser", "createdAt": "2021-01-07T18:21:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzNTk4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUwMzUzNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553503534", "bodyText": "The common class just holds the setup/metadata (+ few getters) and used by all classes (including the interface). The scanner class and its derivatives are implementing the scan & index algorithm\n\nI think it would maybe make sense if this were just a \"state\" object, then, that packaged up state that needed to be shared, with accessors/modifiers. I think the getRecordStore() method being in Common is a little strange... I guess it's there because it's used by the throttler? Hmm", "author": "alecgrieser", "createdAt": "2021-01-07T18:23:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzNTk4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUzMDY0Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553530643", "bodyText": "(did you mean openRecordStore?)\nYes, as a getter, it is a stretch. I can move it to the base class and let the throttle get the recordStoreBuilder from common and explicitly open the store (it's a simple one liner).", "author": "jjezra", "createdAt": "2021-01-07T19:16:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzNTk4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA0ODY4Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553048682", "bodyText": "I think cyclic imports are fine in Java (at least within a single project--a little bit dicier when it comes to cyclic imports between projects, which this wouldn't require)? And would seem preferable to having to need to maintain two of these enums", "author": "alecgrieser", "createdAt": "2021-01-07T00:53:57Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerCommon.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * OnlineIndexerCommon.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.provider.foundationdb.synchronizedsession.SynchronizedSessionRunner;\n+import com.apple.foundationdb.record.query.plan.synthetic.SyntheticRecordFromStoredRecordPlan;\n+import com.apple.foundationdb.record.query.plan.synthetic.SyntheticRecordPlanner;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.Tuple;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+\n+/**\n+ * Shared structure to be used (only) by the OnlineIndexer* modules.\n+ */\n+public class OnlineIndexerCommon {\n+    private final UUID uuid = UUID.randomUUID();\n+\n+    @Nonnull private final FDBDatabaseRunner runner;\n+    @Nullable private SynchronizedSessionRunner synchronizedSessionRunner = null;\n+\n+    @Nonnull private final FDBRecordStore.Builder recordStoreBuilder;\n+    @Nonnull private final Index index;\n+    @Nonnull private final IndexStatePrecondition indexStatePrecondition;\n+    @Nonnull private final AtomicLong totalRecordsScanned;\n+\n+    private final boolean useSynchronizedSession;\n+    private final boolean syntheticIndex;\n+    private final boolean trackProgress;\n+    private final long leaseLengthMillis;\n+\n+    // This is bad: the config is imported from OnlineIndexer - a user of this module. How can we move\n+    // the Config definition here without breaking backward compatibility? Shall we create the class here\n+    // and let OnlineIndexer.Config inherit it?\n+    @Nonnull public OnlineIndexer.Config config; // may be modified on the fly\n+    @Nullable private final Function<OnlineIndexer.Config, OnlineIndexer.Config> configLoader;\n+    private int configLoaderInvocationCount = 0;\n+\n+    @Nonnull public Collection<RecordType> recordTypes;\n+\n+    private static final Object INDEX_BUILD_LOCK_KEY = 0L;\n+    private static final Object INDEX_BUILD_SCANNED_RECORDS = 1L;\n+\n+    /**\n+     * Constant indicating that there should be no limit to some usually limited operation.\n+     */\n+    public static final int UNLIMITED = Integer.MAX_VALUE;\n+\n+    OnlineIndexerCommon(@Nonnull FDBDatabaseRunner runner,\n+                        @Nonnull FDBRecordStore.Builder recordStoreBuilder,\n+                        @Nonnull Index index, @Nonnull Collection<RecordType> recordTypes,\n+                        @Nonnull Function<OnlineIndexer.Config, OnlineIndexer.Config> configLoader, @Nonnull OnlineIndexer.Config config,\n+                        boolean syntheticIndex,\n+                        @Nonnull IndexStatePrecondition indexStatePrecondition,\n+                        boolean trackProgress,\n+                        boolean useSynchronizedSession,\n+                        long leaseLengthMillis\n+\n+    ) {\n+        this.useSynchronizedSession = useSynchronizedSession;\n+        this.runner = runner;\n+        this.index = index;\n+        this.recordTypes = recordTypes;\n+        this.configLoader = configLoader;\n+        this.config = config;\n+        this.syntheticIndex = syntheticIndex;\n+        this.indexStatePrecondition = indexStatePrecondition;\n+        this.trackProgress = trackProgress;\n+        this.recordStoreBuilder = recordStoreBuilder;\n+        this.leaseLengthMillis = leaseLengthMillis;\n+\n+        this.totalRecordsScanned = new AtomicLong(0);\n+    }\n+\n+    public UUID getUuid() {\n+        return uuid;\n+    }\n+\n+    public boolean isUseSynchronizedSession() {\n+        return useSynchronizedSession;\n+    }\n+\n+    @Nonnull\n+    public FDBDatabaseRunner getRunner() {\n+        return synchronizedSessionRunner == null ? runner : synchronizedSessionRunner;\n+    }\n+\n+    @Nonnull\n+    public Index getIndex() {\n+        return index;\n+    }\n+\n+    public boolean isSyntheticIndex() {\n+        return syntheticIndex;\n+    }\n+\n+    public boolean isTrackProgress() {\n+        return trackProgress;\n+    }\n+\n+    @Nonnull\n+    public FDBRecordStore.Builder getRecordStoreBuilder() {\n+        return recordStoreBuilder;\n+    }\n+\n+    @Nullable\n+    public SynchronizedSessionRunner getSynchronizedSessionRunner() {\n+        return synchronizedSessionRunner;\n+    }\n+\n+    public void setSynchronizedSessionRunner(@Nullable final SynchronizedSessionRunner synchronizedSessionRunner) {\n+        this.synchronizedSessionRunner = synchronizedSessionRunner;\n+    }\n+\n+    @Nonnull\n+    public IndexStatePrecondition getIndexStatePrecondition() {\n+        return indexStatePrecondition;\n+    }\n+\n+    @Nullable\n+    public SyntheticRecordFromStoredRecordPlan getSyntheticPlan(FDBRecordStore store) {\n+        if (!syntheticIndex) {\n+            return null;\n+        }\n+        final SyntheticRecordPlanner syntheticPlanner = new SyntheticRecordPlanner(store.getRecordMetaData(), store.getRecordStoreState().withWriteOnlyIndexes(Collections.singletonList(index.getName())));\n+        return syntheticPlanner.forIndex(index);\n+    }\n+\n+    @Nonnull\n+    public static Subspace indexBuildLockSubspace(@Nonnull FDBRecordStoreBase<?> store, @Nonnull Index index) {\n+        return store.getUntypedRecordStore().indexBuildSubspace(index).subspace(Tuple.from(INDEX_BUILD_LOCK_KEY));\n+    }\n+\n+    @Nonnull\n+    public Subspace indexBuildScannedRecordsSubspace(@Nonnull FDBRecordStoreBase<?> store) {\n+        return store.getUntypedRecordStore().indexBuildSubspace(index)\n+                .subspace(Tuple.from(INDEX_BUILD_SCANNED_RECORDS));\n+    }\n+\n+    @Nonnull\n+    public AtomicLong getTotalRecordsScanned() {\n+        return totalRecordsScanned;\n+    }\n+\n+    public int getConfigLoaderInvocationCount() {\n+        return configLoaderInvocationCount;\n+    }\n+\n+    public long getLeaseLengthMillis() {\n+        return leaseLengthMillis;\n+    }\n+\n+    public boolean loadConfig() {\n+        if (configLoader == null) {\n+            return false;\n+        }\n+        configLoaderInvocationCount++;\n+        config = configLoader.apply(config);\n+        return true;\n+    }\n+\n+    @SuppressWarnings(\"squid:S1452\")\n+    public CompletableFuture<FDBRecordStore> openRecordStore(@Nonnull FDBRecordContext context) {\n+        return recordStoreBuilder.copyBuilder().setContext(context).openAsync();\n+    }\n+\n+    public void close() {\n+        runner.close();\n+        if (synchronizedSessionRunner != null) {\n+            synchronizedSessionRunner.close();\n+        }\n+    }\n+\n+    /**\n+     * To avoid cyclic imports, this is the internal version of {@link OnlineIndexer.IndexStatePrecondition}.", "originalCommit": "5f60eb372dabc1b72f2501a2f8d60f84119b6d09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5NTU0Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553095547", "bodyText": "Yep, this was the first OnlineIndexer subclass I've looked into and I guess I was over motivated. I'll let the scanner use OnlineIndexer.IndexStatePrecondition directly.", "author": "jjezra", "createdAt": "2021-01-07T03:56:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA0ODY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA1NDg1OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553054859", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *  This indexer scans all records in the datastore.\n          \n          \n            \n             *  This indexer scans all records in the record store.", "author": "alecgrieser", "createdAt": "2021-01-07T01:16:16Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerByRecords.java", "diffHunk": "@@ -0,0 +1,677 @@\n+/*\n+ * OnlineIndexerByRecords.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.MutationType;\n+import com.apple.foundationdb.Range;\n+import com.apple.foundationdb.ReadTransactionContext;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncIterator;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.RangeSet;\n+import com.apple.foundationdb.record.EndpointType;\n+import com.apple.foundationdb.record.ExecuteProperties;\n+import com.apple.foundationdb.record.IsolationLevel;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorResult;\n+import com.apple.foundationdb.record.ScanProperties;\n+import com.apple.foundationdb.record.TupleRange;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.MetaDataException;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.ByteArrayUtil2;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.Message;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ *  This indexer scans all records in the datastore.", "originalCommit": "5f60eb372dabc1b72f2501a2f8d60f84119b6d09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA1OTIwNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553059204", "bodyText": "This feels somewhat clunky. Because it's keeping a copy of the reference (essentially), it means that updates to the throttler's totalRecordsScanned also update the OnlineIndexerCommon's copy. I think that's intentional, but buy copying the value to its own instance member, it can make the side effects less obvious. I think it would be better to remove the member and just update the value through the Common object.", "author": "alecgrieser", "createdAt": "2021-01-07T01:32:23Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerThrottle.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * OnlineIndexerThrottle.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.FDBError;\n+import com.apple.foundationdb.FDBException;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.MoreAsyncUtil;\n+import com.apple.foundationdb.record.IndexState;\n+import com.apple.foundationdb.record.RecordCoreStorageException;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.util.LoggableException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+/**\n+ * This class provides build / commit /retry with throttling to the OnlineIndexer. In the future,\n+ * this class can be generalized to serve other FDB modules.\n+ *\n+ */\n+public class OnlineIndexerThrottle {\n+\n+    @Nonnull private static final Logger LOGGER = LoggerFactory.getLogger(OnlineIndexerThrottle.class);\n+    @Nonnull private final OnlineIndexerCommon common;\n+    @Nonnull private final AtomicLong totalRecordsScanned;\n+\n+    private int limit;\n+\n+    // These error codes represent a list of errors that can occur if there is too much work to be done\n+    // in a single transaction.\n+    private static final Set<Integer> lessenWorkCodes = new HashSet<>(Arrays.asList(\n+            FDBError.TIMED_OUT.code(),\n+            FDBError.TRANSACTION_TOO_OLD.code(),\n+            FDBError.NOT_COMMITTED.code(),\n+            FDBError.TRANSACTION_TIMED_OUT.code(),\n+            FDBError.COMMIT_READ_INCOMPLETE.code(),\n+            FDBError.TRANSACTION_TOO_LARGE.code()));\n+\n+    /**\n+     * The number of successful transactions in a row as called by {@link #runAsync(Function, BiFunction, BiConsumer, List)}.\n+     */\n+    private int successCount = 0;\n+\n+    OnlineIndexerThrottle(@Nonnull OnlineIndexerCommon common) {\n+\n+        this.common = common;\n+        this.totalRecordsScanned = common.getTotalRecordsScanned();", "originalCommit": "5f60eb372dabc1b72f2501a2f8d60f84119b6d09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5NTk5MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553095991", "bodyText": "++", "author": "jjezra", "createdAt": "2021-01-07T03:58:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA1OTIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA2MDE2MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553060161", "bodyText": "These error messages are somewhat opaque because all of the different clauses lead to the same message. It would be nice if they included a reason (e.g., \"this index cannot be be built by scanning another index as the target index has too many types\").\nI'm also not sure the IndexFromIndex prefix helps. It may make sense to instead have it be its own exception class instead (BuildIndexFromIndexValidationException or something)", "author": "alecgrieser", "createdAt": "2021-01-07T01:35:42Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerByIndex.java", "diffHunk": "@@ -86,13 +86,13 @@\n \n                     if (common.isSyntheticIndex() ||\n                             common.recordTypes.size() != 1) {\n-                        buildIndexFromIndexThrowEx(\"IndexFromIndex: tgt cannot be scanned from index\");\n+                        buildIndexFromIndexThrowEx(\"IndexFromIndex: this index cannot be scanned from another index\");", "originalCommit": "e335a2aaf7ff1d5c7061f84b916d05a0945d8659", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU1OTczOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553559739", "bodyText": "Maybe BuildIndexFromIndex.ValidationException?", "author": "jjezra", "createdAt": "2021-01-07T20:05:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA2MDE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA2MTY4NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553061685", "bodyText": "I think this can be something like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected CompletableFuture<Void> iterateRangeOnly(@Nonnull FDBRecordStore store,\n          \n          \n            \n                                                                   @Nonnull RecordCursor<?> cursor,\n          \n          \n            \n                                                                   @Nonnull Function<RecordCursorResult<?>, FDBStoredRecord<Message>> getRecord,\n          \n          \n            \n                                                                   @Nonnull Consumer<RecordCursorResult<?>> lastResultSet,\n          \n          \n            \n                protected <T> CompletableFuture<Void> iterateRangeOnly(@Nonnull FDBRecordStore store,\n          \n          \n            \n                                                                   @Nonnull RecordCursor<T> cursor,\n          \n          \n            \n                                                                   @Nonnull Function<RecordCursorResult<T>, FDBStoredRecord<Message>> getRecord,\n          \n          \n            \n                                                                   @Nonnull Consumer<RecordCursorResult<T>> lastResultSet,\n          \n      \n    \n    \n  \n\nAnd then some of the cast methods that are currently passed can be made safer. But I haven't actually tried this out", "author": "alecgrieser", "createdAt": "2021-01-07T01:41:31Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerScanner.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * OnlineIndexerScanner.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.FDBException;\n+import com.apple.foundationdb.Transaction;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.MoreAsyncUtil;\n+import com.apple.foundationdb.async.RangeSet;\n+import com.apple.foundationdb.record.IndexState;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorResult;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.provider.foundationdb.synchronizedsession.SynchronizedSessionRunner;\n+import com.apple.foundationdb.record.query.plan.synthetic.SyntheticRecordFromStoredRecordPlan;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.Message;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A base class for different types of online indexing scanners.\n+ */\n+@API(API.Status.INTERNAL)\n+public abstract class OnlineIndexerScanner {\n+\n+    @Nonnull\n+    private static final Logger LOGGER = LoggerFactory.getLogger(OnlineIndexerScanner.class);\n+    @Nonnull\n+    protected final OnlineIndexerCommon common; // to be used by extenders\n+    @Nonnull\n+    private final OnlineIndexerThrottle throttle;\n+\n+    private long timeOfLastProgressLogMillis = 0;\n+\n+    OnlineIndexerScanner(OnlineIndexerCommon common) {\n+        this.common = common;\n+        this.throttle = new OnlineIndexerThrottle(common);\n+    }\n+\n+    protected FDBDatabaseRunner getRunner() {\n+        return common.getRunner();\n+    }\n+\n+    CompletableFuture<Void> buildIndexAsync(boolean markReadable) {\n+        KeyValueLogMessage message = KeyValueLogMessage.build(\"build index online\",\n+                LogMessageKeys.SHOULD_MARK_READABLE, markReadable);\n+        final CompletableFuture<Void> buildIndexAsyncFuture;\n+        FDBDatabaseRunner runner = common.getRunner();\n+        Index index = common.getIndex();\n+        if (common.isUseSynchronizedSession()) {\n+            buildIndexAsyncFuture = runner\n+                    .runAsync(context -> common.openRecordStore(context).thenApply(store -> OnlineIndexerCommon.indexBuildLockSubspace(store, index)))\n+                    .thenCompose(lockSubspace -> runner.startSynchronizedSessionAsync(lockSubspace, common.getLeaseLengthMillis()))\n+                    .thenCompose(synchronizedRunner -> {\n+                        message.addKeyAndValue(LogMessageKeys.SESSION_ID, synchronizedRunner.getSessionId());\n+                        return runWithSynchronizedRunnerAndEndSession(synchronizedRunner,\n+                                () -> handleStateAndDoBuildIndexAsync(markReadable, message));\n+                    });\n+        } else {\n+            message.addKeyAndValue(LogMessageKeys.SESSION_ID, \"none\");\n+            common.setSynchronizedSessionRunner(null);\n+            buildIndexAsyncFuture = handleStateAndDoBuildIndexAsync(markReadable, message);\n+        }\n+        return buildIndexAsyncFuture.whenComplete((vignore, ex) -> {\n+            if (LOGGER.isWarnEnabled() && (ex != null)) {\n+                message.addKeyAndValue(LogMessageKeys.RESULT, \"failure\");\n+                LOGGER.warn(message.toString(), ex);\n+            } else if (LOGGER.isInfoEnabled()) {\n+                message.addKeyAndValue(LogMessageKeys.RESULT, \"success\");\n+                LOGGER.info(message.toString());\n+            }\n+        });\n+    }\n+\n+    private <T> CompletableFuture<T> runWithSynchronizedRunnerAndEndSession(\n+            @Nonnull SynchronizedSessionRunner newSynchronizedRunner, @Nonnull Supplier<CompletableFuture<T>> runnable) {\n+        final SynchronizedSessionRunner currentSynchronizedRunner1 = common.getSynchronizedSessionRunner();\n+        if (currentSynchronizedRunner1 == null) {\n+            common.setSynchronizedSessionRunner(newSynchronizedRunner);\n+            return MoreAsyncUtil.composeWhenComplete(runnable.get(), (result, ex) -> {\n+                final SynchronizedSessionRunner currentSynchronizedRunner2 = common.getSynchronizedSessionRunner();\n+                if (newSynchronizedRunner.equals(currentSynchronizedRunner2)) {\n+                    common.setSynchronizedSessionRunner(null);\n+                } else {\n+                    LOGGER.warn(KeyValueLogMessage.of(\"synchronizedSessionRunner was modified during the run\",\n+                            LogMessageKeys.SESSION_ID, newSynchronizedRunner.getSessionId(),\n+                            LogMessageKeys.INDEXER_SESSION_ID, currentSynchronizedRunner2 == null ? null : currentSynchronizedRunner2.getSessionId()));\n+                }\n+                return newSynchronizedRunner.endSessionAsync();\n+            }, getRunner().getDatabase()::mapAsyncToSyncException);\n+        } else {\n+            return newSynchronizedRunner.endSessionAsync().thenApply(vignore -> {\n+                throw new RecordCoreException(\"another synchronized session is running on the indexer\",\n+                        LogMessageKeys.SESSION_ID, newSynchronizedRunner.getSessionId(),\n+                        LogMessageKeys.INDEXER_SESSION_ID, currentSynchronizedRunner1.getSessionId());\n+            });\n+        }\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> handleStateAndDoBuildIndexAsync(boolean markReadable, KeyValueLogMessage message) {\n+\n+        OnlineIndexerCommon.IndexStatePrecondition indexStatePrecondition = common.getIndexStatePrecondition();\n+        message.addKeyAndValue(LogMessageKeys.INDEX_STATE_PRECONDITION, indexStatePrecondition);\n+        if (indexStatePrecondition == OnlineIndexerCommon.IndexStatePrecondition.ERROR_IF_DISABLED_CONTINUE_IF_WRITE_ONLY) {\n+            message.addKeyAndValue(LogMessageKeys.SHOULD_BUILD_INDEX, true);\n+            return doBuildIndexAsync(markReadable);\n+        }\n+        final Index index = common.getIndex();\n+        return getRunner().runAsync(context -> common.openRecordStore(context).thenCompose(store -> {\n+            IndexState indexState = store.getIndexState(index);\n+            boolean shouldBuild = shouldBuildIndex(indexState, indexStatePrecondition);\n+            message.addKeyAndValue(LogMessageKeys.INITIAL_INDEX_STATE, indexState);\n+            message.addKeyAndValue(LogMessageKeys.SHOULD_BUILD_INDEX, shouldBuild);\n+            if (shouldBuild) {\n+                boolean shouldClear = shouldClearExistingIndexEntries(indexState, indexStatePrecondition);\n+                message.addKeyAndValue(LogMessageKeys.SHOULD_CLEAR_EXISTING_DATA, shouldClear);\n+                if (shouldClear) {\n+                    store.clearIndexData(index);\n+                }\n+                return store.markIndexWriteOnly(index).thenApply(vignore -> true);\n+            } else {\n+                return AsyncUtil.READY_FALSE;\n+            }\n+        })).thenCompose(shouldBuild -> shouldBuild != null && shouldBuild ? doBuildIndexAsync(markReadable) : AsyncUtil.DONE);\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    private boolean shouldBuildIndex(@Nonnull IndexState indexState, @Nonnull OnlineIndexerCommon.IndexStatePrecondition indexStatePrecondition) {\n+        switch (indexStatePrecondition) {\n+            case BUILD_IF_DISABLED:\n+                return indexState == IndexState.DISABLED;\n+\n+            case BUILD_IF_DISABLED_CONTINUE_BUILD_IF_WRITE_ONLY:\n+            case BUILD_IF_DISABLED_REBUILD_IF_WRITE_ONLY:\n+                return indexState == IndexState.DISABLED || indexState == IndexState.WRITE_ONLY;\n+\n+            case FORCE_BUILD:\n+                return true;\n+\n+            default:\n+                throw new RecordCoreException(\"unknown index state precondition \" + indexStatePrecondition);\n+        }\n+    }\n+\n+    private boolean shouldClearExistingIndexEntries(@Nonnull IndexState indexState,\n+                                                    @Nonnull OnlineIndexerCommon.IndexStatePrecondition indexStatePrecondition) {\n+        // If the index state is DISABLED, it is expected that there is no existing index entry. But we would like\n+        // to clear it anyway to play safe.\n+        return !(indexState == IndexState.WRITE_ONLY && indexStatePrecondition.isContinueIfWriteOnly());\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n+        CompletableFuture<Void> buildFuture = scanBuildIndexAsync();\n+\n+        if (markReadable) {\n+            return buildFuture.thenCompose(vignore ->\n+                    getRunner().runAsync(context -> common.openRecordStore(context)\n+                            .thenCompose(store -> store.markIndexReadable(common.getIndex()))\n+                            .thenApply(ignore -> null)));\n+        } else {\n+            return buildFuture;\n+        }\n+    }\n+\n+    abstract CompletableFuture<Void> scanBuildIndexAsync();\n+\n+    protected boolean shouldLogBuildProgress() {\n+        long interval = common.config.getProgressLogIntervalMillis();\n+        long now = System.currentTimeMillis();\n+        if (interval == 0 || interval < (now - timeOfLastProgressLogMillis)) {\n+            return false;\n+        }\n+        timeOfLastProgressLogMillis = now;\n+        return true;\n+    }\n+\n+    public int getLimit() {\n+        // made public to support tests\n+        return throttle.getLimit();\n+    }\n+\n+    protected CompletableFuture<Boolean> throttleDelay() {\n+        int limit = getLimit();\n+        int recordsPerSecond = common.config.getRecordsPerSecond();\n+        int toWait = (recordsPerSecond == OnlineIndexerCommon.UNLIMITED) ? 0 : 1000 * limit / recordsPerSecond;\n+        return MoreAsyncUtil.delayedFuture(toWait, TimeUnit.MILLISECONDS).thenApply(vignore3 -> true);\n+    }\n+\n+\n+    public <R> CompletableFuture<R> buildAsync(@Nonnull BiFunction<FDBRecordStore, AtomicLong, CompletableFuture<R>> buildFunction,\n+                                        boolean limitControl,\n+                                        @Nullable List<Object> additionalLogMessageKeyValues) {\n+\n+        return throttle.buildAsync(buildFunction, limitControl, additionalLogMessageKeyValues);\n+    }\n+\n+    private static void timerIncrement(@Nullable FDBStoreTimer timer, FDBStoreTimer.Counts event) {\n+        // helper function to reduce complexity\n+        if (timer != null) {\n+            timer.increment(event);\n+        }\n+    }\n+\n+    private static CompletableFuture<Void> updateMaintainerBuilder(SyntheticRecordFromStoredRecordPlan syntheticPlan,\n+                                                                   FDBStoredRecord<Message> rec,\n+                                                                   IndexMaintainer maintainer,\n+                                                                   FDBRecordStore store) {\n+        // helper function to reduce complexity\n+        if (syntheticPlan == null) {\n+            return maintainer.update(null, rec);\n+        }\n+        // Pipeline size is 1, since not all maintainers are thread-safe.\n+        return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n+    }\n+\n+    protected CompletableFuture<Void> iterateRangeOnly(@Nonnull FDBRecordStore store,\n+                                                       @Nonnull RecordCursor<?> cursor,\n+                                                       @Nonnull Function<RecordCursorResult<?>, FDBStoredRecord<Message>> getRecord,\n+                                                       @Nonnull Consumer<RecordCursorResult<?>> lastResultSet,", "originalCommit": "c34f077926a2f9ace8de7edd1281c932aa2cbe78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA2MjA3NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553062074", "bodyText": "This doesn't seem like a MetaDataException to me. It almost seems like an assert, as the Result from a RecordCursor should never be null--it's possible this check just isn't needed.\nI had another suggestion later on that I think would allow the generics to be removed, though, so", "author": "alecgrieser", "createdAt": "2021-01-07T01:43:15Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerByIndex.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * OnlineIndexerByIndex.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.MutationType;\n+import com.apple.foundationdb.TransactionContext;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.RangeSet;\n+import com.apple.foundationdb.record.ExecuteProperties;\n+import com.apple.foundationdb.record.IndexScanType;\n+import com.apple.foundationdb.record.IsolationLevel;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorResult;\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.RecordMetaDataProvider;\n+import com.apple.foundationdb.record.ScanProperties;\n+import com.apple.foundationdb.record.TupleRange;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.MetaDataException;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.ByteArrayUtil2;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.google.protobuf.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * This indexer scans records by a source index.\n+ */\n+@API(API.Status.INTERNAL)\n+public class OnlineIndexerByIndex extends OnlineIndexerScanner {\n+    @Nonnull private static final Logger LOGGER = LoggerFactory.getLogger(OnlineIndexerByIndex.class);\n+    @Nonnull private final OnlineIndexer.IndexFromIndexPolicy policy;\n+\n+    OnlineIndexerByIndex(@Nonnull OnlineIndexerCommon common,\n+                         @Nonnull OnlineIndexer.IndexFromIndexPolicy policy) {\n+        super(common);\n+        this.policy = policy;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    CompletableFuture<Void> scanBuildIndexAsync() {\n+\n+        return getRunner().runAsync(context -> common.openRecordStore(context)\n+                .thenCompose( store -> {\n+                    // first verify that both src and tgt are of a single, similar, type\n+                    final RecordMetaData metaData = store.getRecordMetaData();\n+                    final Index srcIndex = metaData.getIndex(Objects.requireNonNull(policy.getSourceIndex()));\n+                    final Collection<RecordType> srcRecordTypes = metaData.recordTypesForIndex(srcIndex);\n+\n+                    if (common.isSyntheticIndex() ||\n+                            common.recordTypes.size() != 1) {\n+                        buildIndexFromIndexThrowEx(\"IndexFromIndex: this index cannot be scanned from another index\");\n+                    }\n+                    if (srcRecordTypes.size() != 1 ||\n+                            srcIndex.getRootExpression().createsDuplicates() ||\n+                            ! srcIndex.getType().equals(IndexTypes.VALUE) ||\n+                            ! common.recordTypes.equals(srcRecordTypes) ) {\n+                        buildIndexFromIndexThrowEx(\"IndexFromIndex: source index cannot be used for index scan\");\n+                    }\n+\n+                    return context.getReadVersionAsync()\n+                            .thenCompose(vignore -> {\n+                                SubspaceProvider subspaceProvider = common.getRecordStoreBuilder().getSubspaceProvider();\n+                                return subspaceProvider.getSubspaceAsync(context)\n+                                        .thenCompose(subspace ->\n+                                                buildIndexFromIndex(subspaceProvider, subspace)\n+                                                        .thenCompose(vignore2 -> markBuilt(subspace)\n+                                                        ));\n+                            });\n+                }));\n+    }\n+\n+    private void buildIndexFromIndexThrowEx(@Nonnull String msg) {\n+        throw new OnlineIndexerException(msg);\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> markBuilt(Subspace subspace) {\n+        // Grand Finale - after fully building the index, remove all missing ranges in one gulp\n+        return getRunner().runAsync(context -> {\n+            final Index index = common.getIndex();\n+            RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, index.getSubspaceKey())));\n+            TransactionContext tc = context.ensureActive();\n+            return rangeSet.insertRange(tc, null, null).thenApply(bignore -> null);\n+        });\n+    }\n+\n+    private void maybeLogBuildProgress(SubspaceProvider subspaceProvider, byte[] retCont) {\n+        if (LOGGER.isInfoEnabled() && shouldLogBuildProgress()) {\n+            final Index index = common.getIndex();\n+            LOGGER.info(KeyValueLogMessage.of(\"Built Range\",\n+                    LogMessageKeys.INDEX_NAME, index.getName(),\n+                    LogMessageKeys.INDEX_VERSION, index.getLastModifiedVersion(),\n+                    subspaceProvider.logKey(), subspaceProvider,\n+                    LogMessageKeys.NEXT_CONTINUATION, retCont,\n+                    LogMessageKeys.RECORDS_SCANNED, common.getTotalRecordsScanned().get()),\n+                    LogMessageKeys.INDEXER_ID, common.getUuid());\n+        }\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndex(SubspaceProvider subspaceProvider, @Nonnull Subspace subspace) {\n+        AtomicReference<byte[]> nextCont = new AtomicReference<>();\n+\n+        return AsyncUtil.whileTrue(() -> {\n+            byte [] cont = nextCont.get();\n+            final List<Object> additionalLogMessageKeyValues = Arrays.asList(LogMessageKeys.CALLING_METHOD, \"buildIndexFromIndex\",\n+                    LogMessageKeys.NEXT_CONTINUATION, cont == null ? \"\" : cont);\n+\n+            // apparently, buildAsync=buildAndCommitWithRetry\n+            return buildAsync( (store, recordsScanned) -> buildRangeOnly(store, cont, recordsScanned),\n+                    true,\n+                    additionalLogMessageKeyValues)\n+                    .handle((retCont, ex) -> {\n+                        if (ex == null) {\n+                            maybeLogBuildProgress(subspaceProvider, retCont);\n+                            if (retCont == null) {\n+                                return AsyncUtil.READY_FALSE;\n+                            }\n+                            nextCont.set(retCont); // continuation\n+                            return throttleDelay();\n+                        }\n+                        final RuntimeException unwrappedEx = getRunner().getDatabase().mapAsyncToSyncException(ex);\n+                        if (LOGGER.isInfoEnabled()) {\n+                            LOGGER.info(KeyValueLogMessage.of(\"possibly non-fatal error encountered building range\",\n+                                    LogMessageKeys.NEXT_CONTINUATION, nextCont,\n+                                    LogMessageKeys.SUBSPACE, ByteArrayUtil2.loggable(subspace.pack())), ex);\n+                        }\n+                        throw unwrappedEx;\n+                    })\n+                    .thenCompose(Function.identity());\n+        }, getRunner().getExecutor());\n+    }\n+\n+    @Nonnull\n+    @SuppressWarnings(\"unchecked\")\n+    private static RecordCursorResult<FDBIndexedRecord<Message>> castCursorResult(RecordCursorResult<?> result) {\n+        // helper function\n+        if (result == null) {\n+            throw new MetaDataException(\"Unexpected null result\");", "originalCommit": "c34f077926a2f9ace8de7edd1281c932aa2cbe78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA2MjM4MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553062381", "bodyText": "Not sure this should be a MetaDataException", "author": "alecgrieser", "createdAt": "2021-01-07T01:44:27Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -223,23 +152,73 @@\n                   @Nonnull IndexStatePrecondition indexStatePrecondition,\n                   boolean useSynchronizedSession,\n                   long leaseLengthMillis,\n-                  boolean trackProgress) {\n+                  boolean trackProgress,\n+                  @Nonnull IndexFromIndexPolicy indexFromIndex) {\n         this.runner = runner;\n-        this.recordStoreBuilder = recordStoreBuilder;\n         this.index = index;\n-        this.recordTypes = recordTypes;\n-        this.configLoader = configLoader;\n-        this.config = config;\n-        this.limit = config.maxLimit;\n-        this.syntheticIndex = syntheticIndex;\n-        this.indexStatePrecondition = indexStatePrecondition;\n-        this.useSynchronizedSession = useSynchronizedSession;\n-        this.leaseLengthMills = leaseLengthMillis;\n-        this.trackProgress = trackProgress;\n-\n-        this.recordsRange = computeRecordsRange();\n-        timeOfLastProgressLogMillis = System.currentTimeMillis();\n-        totalRecordsScanned = new AtomicLong(0);\n+        this.indexFromIndex = indexFromIndex;\n+\n+        this.common = new OnlineIndexerCommon(runner, recordStoreBuilder,\n+                index, recordTypes, configLoader, config,\n+                syntheticIndex,\n+                indexStatePrecondition.getCommonVal(),\n+                trackProgress,\n+                useSynchronizedSession,\n+                leaseLengthMillis\n+            );\n+    }\n+\n+    @Nonnull\n+    private OnlineIndexerByIndex getScannerByIndex() {\n+        if (! (indexScanner instanceof OnlineIndexerByIndex)) { // this covers null pointer\n+            indexScanner = new OnlineIndexerByIndex(common, indexFromIndex);\n+        }\n+        return (OnlineIndexerByIndex)indexScanner;\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> handleScannerReturnOrFallback(Throwable ex, Supplier<CompletableFuture<Void>> fallback) {\n+        if (ex == null) {\n+            return AsyncUtil.DONE;\n+        }\n+        if ( indexFromIndex.isActive() &&\n+                 indexFromIndex.isAllowRecordScan() &&\n+                 (ex.getCause() instanceof OnlineIndexerException)) {\n+            // fallback to a records scan\n+            if (LOGGER.isWarnEnabled()) {\n+                final KeyValueLogMessage message =\n+                        KeyValueLogMessage.build(\"fallback to records scan\",\n+                                LogMessageKeys.INDEX_NAME, index.getName());\n+                LOGGER.warn(message.toString(), ex);\n+            }\n+            indexScanner = null;\n+            indexFromIndex.setFallback(); // deactivate indexFromIndex for this session\n+            return fallback.get();\n+        }\n+        throw FDBExceptions.wrapException(ex);\n+    }\n+\n+    @Nonnull\n+    private OnlineIndexerByRecords getScannerByRecords() {\n+        if (! (indexScanner instanceof OnlineIndexerByRecords)) { // this covers null pointer\n+            indexScanner = new OnlineIndexerByRecords(common);\n+        }\n+        return (OnlineIndexerByRecords)indexScanner;\n+    }\n+\n+    @Nonnull\n+    private OnlineIndexerByRecords getScannerByRecordsOrThrow() {\n+        if (indexFromIndex.isActive()) {\n+            throw new MetaDataException(\"indexFromIndex makes no sense here\");", "originalCommit": "c34f077926a2f9ace8de7edd1281c932aa2cbe78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA2MjUyMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553062521", "bodyText": "Likewise this null check probably shouldn't be a MetaDataException.", "author": "alecgrieser", "createdAt": "2021-01-07T01:44:58Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerByRecords.java", "diffHunk": "@@ -0,0 +1,677 @@\n+/*\n+ * OnlineIndexerByRecords.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.MutationType;\n+import com.apple.foundationdb.Range;\n+import com.apple.foundationdb.ReadTransactionContext;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncIterator;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.RangeSet;\n+import com.apple.foundationdb.record.EndpointType;\n+import com.apple.foundationdb.record.ExecuteProperties;\n+import com.apple.foundationdb.record.IsolationLevel;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorResult;\n+import com.apple.foundationdb.record.ScanProperties;\n+import com.apple.foundationdb.record.TupleRange;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.MetaDataException;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.ByteArrayUtil2;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.Message;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ *  This indexer scans all records in the datastore.\n+ */\n+@API(API.Status.INTERNAL)\n+public class OnlineIndexerByRecords extends OnlineIndexerScanner {\n+    @Nonnull private static final Logger LOGGER = LoggerFactory.getLogger(OnlineIndexerByRecords.class);\n+\n+    @Nonnull private final TupleRange recordsRange;\n+    @Nonnull private static final byte[] START_BYTES = new byte[]{0x00};\n+    @Nonnull private static final byte[] END_BYTES = new byte[]{(byte)0xff};\n+\n+\n+    OnlineIndexerByRecords(@Nonnull OnlineIndexerCommon common) {\n+        super(common);\n+        this.recordsRange = computeRecordsRange();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    CompletableFuture<Void> scanBuildIndexAsync() {\n+        return buildEndpoints().thenCompose(tupleRange -> {\n+            if (tupleRange != null) {\n+                return buildRange(Key.Evaluated.fromTuple(tupleRange.getLow()), Key.Evaluated.fromTuple(tupleRange.getHigh()));\n+            } else {\n+                return CompletableFuture.completedFuture(null);\n+            }\n+        });\n+    }\n+\n+    private void maybeLogBuildProgress(SubspaceProvider subspaceProvider, Tuple startTuple, Tuple endTuple, Tuple realEnd) {\n+        if (LOGGER.isInfoEnabled() && shouldLogBuildProgress()) {\n+            LOGGER.info(KeyValueLogMessage.of(\"Built Range\",\n+                    LogMessageKeys.INDEX_NAME, common.getIndex().getName(),\n+                    LogMessageKeys.INDEX_VERSION, common.getIndex().getLastModifiedVersion(),\n+                    subspaceProvider.logKey(), subspaceProvider,\n+                    LogMessageKeys.START_TUPLE, startTuple,\n+                    LogMessageKeys.END_TUPLE, endTuple,\n+                    LogMessageKeys.REAL_END, realEnd,\n+                    LogMessageKeys.RECORDS_SCANNED, common.getTotalRecordsScanned().get()),\n+                    LogMessageKeys.INDEXER_ID, common.getUuid());\n+        }\n+    }\n+\n+    @Nonnull\n+    private TupleRange computeRecordsRange() {\n+        Tuple low = null;\n+        Tuple high = null;\n+        for (RecordType recordType : common.recordTypes) {\n+            if (!recordType.primaryKeyHasRecordTypePrefix() || recordType.isSynthetic()) {\n+                // If any of the types to build for does not have a prefix, give up.\n+                return TupleRange.ALL;\n+            }\n+            Tuple prefix = recordType.getRecordTypeKeyTuple();\n+            if (low == null) {\n+                low = high = prefix;\n+            } else {\n+                if (low.compareTo(prefix) > 0) {\n+                    low = prefix;\n+                }\n+                if (high.compareTo(prefix) < 0) {\n+                    high = prefix;\n+                }\n+            }\n+        }\n+        if (low == null) {\n+            return TupleRange.ALL;\n+        } else {\n+            // Both ends inclusive.\n+            return new TupleRange(low, high, EndpointType.RANGE_INCLUSIVE, EndpointType.RANGE_INCLUSIVE);\n+        }\n+    }\n+\n+    /**\n+     * Builds (transactionally) the endpoints of an index. What this means is that builds everything from the beginning of\n+     * the key space to the first record and everything from the last record to the end of the key space.\n+     * There won't be any records within these ranges (except for the last record of the record store), but\n+     * it does mean that any records in the future that get added to these ranges will correctly update\n+     * the index. This means, e.g., that if the workload primarily adds records to the record store\n+     * after the current last record (because perhaps the primary key is based off of an atomic counter\n+     * or the current time), running this method will be highly contentious, but once it completes,\n+     * the rest of the index build should happen without any more conflicts.\n+     *\n+     * This will return a (possibly null) {@link TupleRange} that contains the primary keys of the\n+     * first and last records within the record store. This can then be used to either build the\n+     * range right away or to then divy-up the remaining ranges between multiple agents working\n+     * in parallel if one desires.\n+     *\n+     * @param store the record store in which to rebuild the index\n+     * @param recordsScanned continues counter\n+     * @return a future that will contain the range of records in the interior of the record store\n+     */\n+\n+    @Nonnull\n+    public CompletableFuture<TupleRange> buildEndpoints(@Nonnull FDBRecordStore store,\n+                                                        @Nullable AtomicLong recordsScanned) {\n+        final RangeSet rangeSet = new RangeSet(store.indexRangeSubspace(common.getIndex()));\n+        if (TupleRange.ALL.equals(recordsRange)) {\n+            return buildEndpoints(store, rangeSet, recordsScanned);\n+        }\n+        // If records do not occupy whole range, first mark outside as built.\n+        final Range asRange = recordsRange.toRange();\n+        return CompletableFuture.allOf(\n+                rangeSet.insertRange(store.ensureContextActive(), null, asRange.begin),\n+                rangeSet.insertRange(store.ensureContextActive(), asRange.end, null))\n+                .thenCompose(vignore -> buildEndpoints(store, rangeSet, recordsScanned));\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<TupleRange> buildEndpoints(@Nonnull FDBRecordStore store, @Nonnull RangeSet rangeSet,\n+                                                         @Nullable AtomicLong recordsScanned) {\n+        boolean isIdempotent = store.getIndexMaintainer(common.getIndex()).isIdempotent();\n+        final IsolationLevel isolationLevel =\n+                isIdempotent ?\n+                // If idempotent: since double indexing is harmless, we can use individual records protection instead of\n+                // a range conflict one - which means that new records, added to the range while indexing the SNAPSHOT,\n+                // will not cause a conflict during the commit. At worse, few records (if added after marking WRITE_ONLY but\n+                // before this method's query) will be re-indexed.\n+                IsolationLevel.SNAPSHOT :\n+                IsolationLevel.SERIALIZABLE;\n+        final ExecuteProperties limit1 = ExecuteProperties.newBuilder()\n+                .setReturnedRowLimit(1)\n+                .setIsolationLevel(isolationLevel)\n+                .build();\n+        final ScanProperties forward = new ScanProperties(limit1);\n+\n+        RecordCursor<FDBStoredRecord<Message>> beginCursor = store.scanRecords(recordsRange, null, forward);\n+        CompletableFuture<Tuple> begin = beginCursor.onNext().thenCompose(result -> {\n+            if (result.hasNext()) {\n+                Tuple firstTuple = result.get().getPrimaryKey();\n+                return buildRange(store, null, firstTuple, recordsScanned).thenApply(vignore -> firstTuple);\n+            } else {\n+                // Empty range -- add the whole thing.\n+                return rangeSet.insertRange(store.ensureContextActive(), null, null).thenApply(bignore -> null);\n+            }\n+        });\n+\n+        final ScanProperties backward = new ScanProperties(limit1, true);\n+        RecordCursor<FDBStoredRecord<Message>> endCursor = store.scanRecords(recordsRange, null, backward);\n+        CompletableFuture<Tuple> end = endCursor.onNext().thenCompose(result -> {\n+            if (result.hasNext()) {\n+                Tuple lastTuple = result.get().getPrimaryKey();\n+                return buildRange(store, lastTuple, null, recordsScanned).thenApply(vignore -> lastTuple);\n+            } else {\n+                // As the range is empty, the whole range needs to be added, but that is accomplished\n+                // by the above future, so this has nothing to do.\n+                return CompletableFuture.completedFuture(null);\n+            }\n+        });\n+\n+        return begin.thenCombine(end, (firstTuple, lastTuple) -> {\n+            if (firstTuple == null || firstTuple.equals(lastTuple)) {\n+                return null;\n+            } else {\n+                return new TupleRange(firstTuple, lastTuple, EndpointType.RANGE_INCLUSIVE, EndpointType.RANGE_EXCLUSIVE);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Builds (with a retry loop) the endpoints of an index. See the\n+     * {@link #buildEndpoints(FDBRecordStore, AtomicLong) buildEndpoints()} method that takes\n+     * an {@link FDBRecordStore} as its parameter for more details. This will retry on that function\n+     * until it gets a non-exceptional result and return the results back.\n+     *\n+     * @return a future that will contain the range of records in the interior of the record store\n+     */\n+    @Nonnull\n+    public CompletableFuture<TupleRange> buildEndpoints() {\n+        final List<Object> additionalLogMessageKeyValues = Arrays.asList(LogMessageKeys.CALLING_METHOD, \"buildEndpoints\");\n+        return buildAsync(this::buildEndpoints, false, additionalLogMessageKeyValues);\n+    }\n+\n+    // Turn a (possibly null) key into its tuple representation.\n+    @Nullable\n+    private Tuple convertOrNull(@Nullable Key.Evaluated key) {\n+        return (key == null) ? null : key.toTuple();\n+    }\n+\n+    // Turn a (possibly null) tuple into a (possibly null) byte array.\n+    @Nullable\n+    private byte[] packOrNull(@Nullable Tuple tuple) {\n+        return (tuple == null) ? null : tuple.pack();\n+    }\n+\n+    // Builds a range within a single transaction. It will look for the missing ranges within the given range and build those while\n+    // updating the range set.\n+    @Nonnull\n+    private CompletableFuture<Void> buildRange(@Nonnull FDBRecordStore store, @Nullable Tuple start, @Nullable Tuple end,\n+                                               @Nullable AtomicLong recordsScanned) {\n+        RangeSet rangeSet = new RangeSet(store.indexRangeSubspace(common.getIndex()));\n+        AsyncIterator<Range> ranges = rangeSet.missingRanges(store.ensureContextActive(), packOrNull(start), packOrNull(end)).iterator();\n+        return ranges.onHasNext().thenCompose(hasAny -> {\n+            if (hasAny) {\n+                return AsyncUtil.whileTrue(() -> {\n+                    Range range = ranges.next();\n+                    Tuple rangeStart = Arrays.equals(range.begin, START_BYTES) ? null : Tuple.fromBytes(range.begin);\n+                    Tuple rangeEnd = Arrays.equals(range.end, END_BYTES) ? null : Tuple.fromBytes(range.end);\n+                    return CompletableFuture.allOf(\n+                            // All of the requested range without limit.\n+                            // In practice, this method works because it is only called for the endpoint ranges, which are empty and\n+                            // one long, respectively.\n+                            buildRangeOnly(store, rangeStart, rangeEnd, false, recordsScanned),\n+                            rangeSet.insertRange(store.ensureContextActive(), range, true)\n+                    ).thenCompose(vignore -> ranges.onHasNext());\n+                }, store.getExecutor());\n+            } else {\n+                return AsyncUtil.DONE;\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Builds (transactionally) the index by adding records with primary keys within the given range.\n+     * This will look for gaps of keys within the given range that haven't yet been rebuilt and then\n+     * rebuild only those ranges. As a result, if this method is called twice, the first time, it will\n+     * build whatever needs to be built, and then the second time, it will notice that there are no ranges\n+     * that need to be built, so it will do nothing. In this way, it is idempotent and thus safe to\n+     * use in retry loops.\n+     *\n+     * This method will fail if there is too much work to be done in a single transaction. If one wants\n+     * to handle building a range that does not fit in a single transaction, one should use the\n+     * {@link #buildRange(Key.Evaluated, Key.Evaluated) buildRange()}\n+     * function that takes an {@link FDBDatabase} as its first parameter.\n+     *\n+     * @param store the record store in which to rebuild the range\n+     * @param start the (inclusive) beginning primary key of the range to build (or <code>null</code> to go to the end)\n+     * @param end the (exclusive) end primary key of the range to build (or <code>null</code> to go to the end)\n+     * @return a future that will be ready when the build has completed\n+     */\n+    @Nonnull\n+    public CompletableFuture<Void> buildRange(@Nonnull FDBRecordStore store, @Nullable Key.Evaluated start, @Nullable Key.Evaluated end) {\n+        RangeSet rangeSet = new RangeSet(store.indexRangeSubspace(common.getIndex()));\n+        byte[] startBytes = packOrNull(convertOrNull(start));\n+        byte[] endBytes = packOrNull(convertOrNull(end));\n+        AsyncIterator<Range> ranges = rangeSet.missingRanges(store.ensureContextActive(), startBytes, endBytes).iterator();\n+        return ranges.onHasNext().thenCompose(hasNext -> {\n+            if (hasNext) {\n+                return AsyncUtil.whileTrue(() -> {\n+                    Range toBuild = ranges.next();\n+                    Tuple startTuple = Tuple.fromBytes(toBuild.begin);\n+                    Tuple endTuple = Arrays.equals(toBuild.end, END_BYTES) ? null : Tuple.fromBytes(toBuild.end);\n+                    AtomicReference<Tuple> currStart = new AtomicReference<>(startTuple);\n+                    return AsyncUtil.whileTrue(() ->\n+                            // Bold claim: this will never cause a RecordBuiltRangeException because of transactions.\n+                            buildUnbuiltRange(store, currStart.get(), endTuple, null).thenApply(realEnd -> {\n+                                if (realEnd != null && !realEnd.equals(endTuple)) {\n+                                    currStart.set(realEnd);\n+                                    return true;\n+                                } else {\n+                                    return false;\n+                                }\n+                            }), store.getExecutor()).thenCompose(vignore -> ranges.onHasNext());\n+                }, store.getExecutor());\n+            } else {\n+                return AsyncUtil.DONE;\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Builds (with a retry loop) the index by adding records with primary keys within the given range.\n+     * This will look for gaps of keys within the given range that haven't yet been rebuilt and then rebuild\n+     * only those ranges. It will also limit each transaction to the number of records specified by the\n+     * <code>limit</code> parameter of this class's constructor. In the case that that limit is too high (i.e.,\n+     * it can't make any progress or errors out on a non-retriable error like <code>transaction_too_large</code>,\n+     * this method will actually decrease the limit so that less work is attempted each transaction. It will\n+     * also rate limit itself as to not make too many requests per second.\n+     * <p>\n+     * Note that it does not have the protections (synchronized sessions and index state precondition) which are imposed\n+     * on buildIndexAsync() (or its variations), but it does use the created synchronized session if a\n+     * buildIndexAsync() is running on the {@link OnlineIndexer} simultaneously or this range build is used as\n+     * part of buildIndexAsync internally.\n+     * </p>\n+     * @param start the (inclusive) beginning primary key of the range to build (or <code>null</code> to go from the beginning)\n+     * @param end the (exclusive) end primary key of the range to build (or <code>null</code> to go to the end)\n+     * @return a future that will be ready when the build has completed\n+     */\n+    @Nonnull\n+    public CompletableFuture<Void> buildRange(@Nullable Key.Evaluated start, @Nullable Key.Evaluated end) {\n+        return buildRange(common.getRecordStoreBuilder().getSubspaceProvider(), start, end);\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildRange(@Nonnull SubspaceProvider subspaceProvider, @Nullable Key.Evaluated start, @Nullable Key.Evaluated end) {\n+        return getRunner().runAsync(context -> context.getReadVersionAsync().thenCompose(vignore ->\n+                subspaceProvider.getSubspaceAsync(context).thenCompose(subspace -> {\n+                    RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, common.getIndex().getSubspaceKey())));\n+                    byte[] startBytes = packOrNull(convertOrNull(start));\n+                    byte[] endBytes = packOrNull(convertOrNull(end));\n+                    Queue<Range> rangeDeque = new ArrayDeque<>();\n+                    ReadTransactionContext rtc = context.ensureActive();\n+                    return rangeSet.missingRanges(rtc, startBytes, endBytes)\n+                            .thenAccept(rangeDeque::addAll)\n+                            .thenCompose(vignore2 -> buildRanges(subspaceProvider, subspace, rangeSet, rangeDeque));\n+                })\n+        ));\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildRanges(SubspaceProvider subspaceProvider, @Nonnull Subspace subspace,\n+                                                RangeSet rangeSet, Queue<Range> rangeDeque) {\n+        return AsyncUtil.whileTrue(() -> {\n+            if (rangeDeque.isEmpty()) {\n+                return CompletableFuture.completedFuture(false); // We're done.\n+            }\n+            Range toBuild = rangeDeque.remove();\n+\n+            // This only works if the things included within the rangeSet are serialized Tuples.\n+            Tuple startTuple = Tuple.fromBytes(toBuild.begin);\n+            Tuple endTuple = Arrays.equals(toBuild.end, END_BYTES) ? null : Tuple.fromBytes(toBuild.end);\n+            return buildUnbuiltRange(startTuple, endTuple)\n+                    .handle((realEnd, ex) -> handleBuiltRange(subspaceProvider, subspace, rangeSet, rangeDeque, startTuple, endTuple, realEnd, ex))\n+                    .thenCompose(Function.identity());\n+        }, getRunner().getExecutor());\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Boolean> handleBuiltRange(SubspaceProvider subspaceProvider, @Nonnull Subspace subspace,\n+                                                        RangeSet rangeSet, Queue<Range> rangeDeque,\n+                                                        Tuple startTuple, Tuple endTuple, Tuple realEnd,\n+                                                        Throwable ex) {\n+        final RuntimeException unwrappedEx = ex == null ? null : getRunner().getDatabase().mapAsyncToSyncException(ex);\n+        if (unwrappedEx == null) {\n+            if (realEnd != null && !realEnd.equals(endTuple)) {\n+                // We didn't make it to the end. Continue on to the next item.\n+                if (endTuple != null) {\n+                    rangeDeque.add(new Range(realEnd.pack(), endTuple.pack()));\n+                } else {\n+                    rangeDeque.add(new Range(realEnd.pack(), END_BYTES));\n+                }\n+            }\n+            maybeLogBuildProgress(subspaceProvider, startTuple, endTuple, realEnd);\n+            return throttleDelay();\n+        } else {\n+            Throwable cause = unwrappedEx;\n+            while (cause != null) {\n+                if (cause instanceof OnlineIndexer.RecordBuiltRangeException) {\n+                    return rangeSet.missingRanges(getRunner().getDatabase().database(), startTuple.pack(), endTuple.pack())\n+                            .thenCompose(list -> {\n+                                rangeDeque.addAll(list);\n+                                return throttleDelay();\n+                            });\n+                } else {\n+                    cause = cause.getCause();\n+                }\n+            }\n+            if (LOGGER.isInfoEnabled()) {\n+                LOGGER.info(KeyValueLogMessage.of(\"possibly non-fatal error encountered building range\",\n+                        LogMessageKeys.RANGE_START, startTuple,\n+                        LogMessageKeys.RANGE_END, endTuple,\n+                        LogMessageKeys.SUBSPACE, ByteArrayUtil2.loggable(subspace.pack())), ex);\n+            }\n+            throw unwrappedEx; // made it to the bottom, throw original exception\n+        }\n+    }\n+\n+    // Helper function that works on Tuples instead of keys.\n+    @Nonnull\n+    private CompletableFuture<Tuple> buildUnbuiltRange(@Nonnull FDBRecordStore store, @Nullable Tuple start,\n+                                                       @Nullable Tuple end, @Nullable AtomicLong recordsScanned) {\n+        CompletableFuture<Tuple> buildFuture = buildRangeOnly(store, start, end, true, recordsScanned);\n+\n+        RangeSet rangeSet = new RangeSet(store.indexRangeSubspace(common.getIndex()));\n+        byte[] startBytes = packOrNull(start);\n+\n+        AtomicReference<Tuple> toReturn = new AtomicReference<>();\n+        return buildFuture.thenCompose(realEnd -> {\n+            toReturn.set(realEnd);\n+            return rangeSet.insertRange(store.ensureContextActive(), startBytes, packOrNull(realEnd), true);\n+        }).thenApply(changed -> {\n+            if (changed) {\n+                return toReturn.get();\n+            } else {\n+                throw new OnlineIndexer.RecordBuiltRangeException(start, end);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Builds (transactionally) the index by adding records with primary keys within the given range.\n+     * This requires that the range is initially \"unbuilt\", i.e., no records within the given\n+     * range have yet been processed by the index build job. It is acceptable if there\n+     * are records within that range that have already been added to the index because they were\n+     * added to the store after the index was added in write-only mode but have not yet been\n+     * processed by the index build job.\n+     *\n+     * Note that this function is not idempotent in that if the first time this function runs, if it\n+     * fails with <code>commit_unknown_result</code> but the transaction actually succeeds, running this\n+     * function again will result in a {@link OnlineIndexer.RecordBuiltRangeException} being thrown the second\n+     * time. Retry loops used by the <code>OnlineIndexer</code> class that call this method\n+     * handle this contingency. For the most part, this method should only be used by those who know\n+     * what they are doing. It is included because it is less expensive to make this call if one\n+     * already knows that the range will be unbuilt, but the caller must be ready to handle the\n+     * circumstance that the range might be built the second time.\n+     *\n+     * Most users should use the\n+     * {@link #buildRange(FDBRecordStore, Key.Evaluated, Key.Evaluated) buildRange()}\n+     * method with the same parameters in the case that they want to build a range of keys into the index. That\n+     * method <i>is</i> idempotent, but it is slightly more costly as it firsts determines what ranges are\n+     * have not yet been built before building them.\n+     *\n+     * @param store the record store in which to rebuild the range\n+     * @param start the (inclusive) beginning primary key of the range to build (or <code>null</code> to start from the beginning)\n+     * @param end the (exclusive) end primary key of the range to build (or <code>null</code> to go to the end)\n+     * @return a future with the key of the first record not processed by this range rebuild\n+     * @throws OnlineIndexer.RecordBuiltRangeException if the given range contains keys already processed by the index build\n+     */\n+    @Nonnull\n+    public CompletableFuture<Key.Evaluated> buildUnbuiltRange(@Nonnull FDBRecordStore store,\n+                                                              @Nullable Key.Evaluated start,\n+                                                              @Nullable Key.Evaluated end) {\n+        return buildUnbuiltRange(store, start, end, null);\n+    }\n+\n+    // just like the overload that doesn't take a recordsScanned\n+    @Nonnull\n+    private CompletableFuture<Key.Evaluated> buildUnbuiltRange(@Nonnull FDBRecordStore store,\n+                                                               @Nullable Key.Evaluated start, @Nullable Key.Evaluated end,\n+                                                               @Nullable AtomicLong recordsScanned) {\n+        return buildUnbuiltRange(store, convertOrNull(start), convertOrNull(end), recordsScanned)\n+                .thenApply(tuple -> (tuple == null) ? null : Key.Evaluated.fromTuple(tuple));\n+    }\n+\n+    // Helper function with the same behavior as buildUnbuiltRange, but it works on tuples instead of primary keys.\n+    @Nonnull\n+    private CompletableFuture<Tuple> buildUnbuiltRange(@Nullable Tuple start, @Nullable Tuple end) {\n+        final List<Object> additionalLogMessageKeyValues = Arrays.asList(LogMessageKeys.CALLING_METHOD, \"buildUnbuiltRange\",\n+                LogMessageKeys.RANGE_START, start,\n+                LogMessageKeys.RANGE_END, end);\n+\n+        return buildAsync((store, recordsScanned) -> buildUnbuiltRange(store, start, end, recordsScanned),\n+                true,\n+                additionalLogMessageKeyValues);\n+    }\n+\n+    @VisibleForTesting\n+    @Nonnull\n+    CompletableFuture<Key.Evaluated> buildUnbuiltRange(@Nullable Key.Evaluated start, @Nullable Key.Evaluated end) {\n+        final List<Object> additionalLogMessageKeyValues = Arrays.asList(LogMessageKeys.CALLING_METHOD, \"buildUnbuiltRange\",\n+                LogMessageKeys.RANGE_START, start,\n+                LogMessageKeys.RANGE_END, end);\n+        return buildAsync((store, recordsScanned) -> buildUnbuiltRange(store, start, end, recordsScanned),\n+                true,\n+                additionalLogMessageKeyValues);\n+    }\n+\n+    @Nonnull\n+    @SuppressWarnings(\"unchecked\")\n+    private RecordCursorResult<FDBStoredRecord<Message>> castCursorResult(RecordCursorResult<?> result) {\n+        if (result == null) {\n+            throw new MetaDataException(\"Unexpected null result\");", "originalCommit": "c34f077926a2f9ace8de7edd1281c932aa2cbe78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4MDI3NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553480275", "bodyText": "The variable names could also be indexFromIndexPolicy to be consistent.", "author": "nblintao", "createdAt": "2021-01-07T17:39:31Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -161,58 +131,17 @@\n      */\n     public static final int DO_NOT_RE_INCREASE_LIMIT = -1;\n \n-    @Nonnull private static final byte[] START_BYTES = new byte[]{0x00};\n-    @Nonnull private static final byte[] END_BYTES = new byte[]{(byte)0xff};\n     @Nonnull private static final Logger LOGGER = LoggerFactory.getLogger(OnlineIndexer.class);\n \n-    // These error codes represent a list of errors that can occur if there is too much work to be done\n-    // in a single transaction.\n-    private static final Set<Integer> lessenWorkCodes = new HashSet<>(Arrays.asList(\n-            FDBError.TIMED_OUT.code(),\n-            FDBError.TRANSACTION_TOO_OLD.code(),\n-            FDBError.NOT_COMMITTED.code(),\n-            FDBError.TRANSACTION_TIMED_OUT.code(),\n-            FDBError.COMMIT_READ_INCOMPLETE.code(),\n-            FDBError.TRANSACTION_TOO_LARGE.code()));\n-\n     private static final Object INDEX_BUILD_LOCK_KEY = 0L;\n     private static final Object INDEX_BUILD_SCANNED_RECORDS = 1L;\n \n-    @Nonnull private UUID onlineIndexerId = UUID.randomUUID();\n+    @Nonnull private final OnlineIndexerCommon common;\n+    @Nullable private OnlineIndexerScanner indexScanner = null;\n \n     @Nonnull private final FDBDatabaseRunner runner;\n-    @Nullable private SynchronizedSessionRunner synchronizedSessionRunner;\n-    @Nonnull private final FDBRecordStore.Builder recordStoreBuilder;\n     @Nonnull private final Index index;\n-    @Nonnull private final Collection<RecordType> recordTypes;\n-    @Nonnull private final TupleRange recordsRange;\n-\n-    /**\n-     * The current number of records to process in a single transaction, this may go up or down when using\n-     * {@link #runAsync(Function, BiFunction, BiConsumer, List)}, but never above {@link Config#limit}.\n-     */\n-    private int limit;\n-    @Nonnull private final Function<Config, Config> configLoader;\n-    @Nonnull private Config config;\n-    private int configLoaderInvocationCount = 0;\n-\n-    /**\n-     * The number of successful transactions in a row as called by {@link #runAsync(Function, BiFunction, BiConsumer, List)}.\n-     */\n-    private int successCount;\n-    private long timeOfLastProgressLogMillis;\n-    /**\n-     * The total number of records scanned in the build.\n-     * @see Builder#setProgressLogIntervalMillis(long)\n-     */\n-    private AtomicLong totalRecordsScanned;\n-\n-    private final boolean syntheticIndex;\n-\n-    @Nonnull private final IndexStatePrecondition indexStatePrecondition;\n-    private final boolean useSynchronizedSession;\n-    private final long leaseLengthMills;\n-    private final boolean trackProgress;\n+    @Nonnull private final IndexFromIndexPolicy indexFromIndex;", "originalCommit": "c34f077926a2f9ace8de7edd1281c932aa2cbe78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4NzMyMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553487320", "bodyText": "If you are going to migrating everything to a new onlineindexing package, don't forget this one. Considering we can't move OnlineIndexer yet.", "author": "nblintao", "createdAt": "2021-01-07T17:52:25Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2480,6 +1690,127 @@ private static void checkPositive(int value, String desc) {\n         }\n     }\n \n+    /**\n+     * A builder for the  indexFromIndex policy. Let the caller set a source index and a fallback policy.\n+     */\n+    public static class IndexFromIndexPolicy {", "originalCommit": "c34f077926a2f9ace8de7edd1281c932aa2cbe78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg5MDIzNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556890236", "bodyText": "I think this would have to stay in the top-level package, as it's part of the API", "author": "alecgrieser", "createdAt": "2021-01-13T22:09:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4NzMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ5MDE1Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553490152", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String sourceIndex = null;\n          \n          \n            \n                        @Nonnull String sourceIndex = null;", "author": "nblintao", "createdAt": "2021-01-07T17:57:22Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2480,6 +1690,127 @@ private static void checkPositive(int value, String desc) {\n         }\n     }\n \n+    /**\n+     * A builder for the  indexFromIndex policy. Let the caller set a source index and a fallback policy.\n+     */\n+    public static class IndexFromIndexPolicy {\n+        public static final IndexFromIndexPolicy INACTIVE = new IndexFromIndexPolicy();\n+        @Nullable private final String sourceIndex;\n+        private final boolean allowRecordScan;\n+        private boolean fallback = false;\n+\n+        /**\n+         * Build the index from a source index. Source index must be readable, idempotent, and fully cover the target index.\n+         * @param sourceIndex source index\n+         * @param allowRecordScan allow fallback to record scan\n+         */\n+        public IndexFromIndexPolicy(@Nonnull String sourceIndex, boolean allowRecordScan) {\n+            this.sourceIndex = sourceIndex;\n+            this.allowRecordScan = allowRecordScan;\n+        }\n+\n+        /**\n+         * Build a non-active object.\n+         */\n+        public IndexFromIndexPolicy() {\n+            this.sourceIndex = null;\n+            this.allowRecordScan = true;\n+        }\n+\n+        /**\n+         * Check if active.\n+         * @return True if active\n+         */\n+        public boolean isActive() {\n+            return sourceIndex != null && ! fallback;\n+        }\n+\n+        /**\n+         * Fallback is needed - deactivate indexFromIndex mode.\n+         */\n+        public void setFallback() {\n+            fallback = true;\n+        }\n+\n+        /**\n+         * If active, get the source index.\n+         * @return source index name\n+         */\n+        @Nullable\n+        public String getSourceIndex() {\n+            return sourceIndex;\n+        }\n+\n+        /**\n+         * If source index is not available, check if allowed to scan the records.\n+         * @return  {@code true} if a record scan is allowed\n+         */\n+        public boolean isAllowRecordScan() {\n+            return allowRecordScan;\n+        }\n+\n+        /**\n+         * Create a index from index policy builder.\n+         * @return a new {@link IndexFromIndexPolicy} builder\n+         */\n+        @Nonnull\n+        public static Builder newBuilder() {\n+            return new Builder();\n+        }\n+\n+        /**\n+         * Builder for {@link IndexFromIndexPolicy}.\n+         *\n+         * <pre><code>\n+         * OnlineIndexer.IndexFromIndexPolicy.newBuilder().setSourceIndex(\"src_index\").build()\n+         * </code></pre>\n+         *\n+         * Forbid fallback:\n+         * <pre><code>\n+         * OnlineIndexer.IndexFromIndexPolicy.newBuilder().setSourceIndex(\"src_index\").forbidRecordScan().build()\n+         * </code></pre>\n+         *\n+         */\n+        @API(API.Status.UNSTABLE)\n+        public static class Builder {\n+            boolean allowRecordScan = true;\n+            String sourceIndex = null;", "originalCommit": "c34f077926a2f9ace8de7edd1281c932aa2cbe78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ5MDMzOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553490339", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        public Builder setSourceIndex(final String sourceIndex) {\n          \n          \n            \n                        public Builder setSourceIndex(@Nonnull final String sourceIndex) {", "author": "nblintao", "createdAt": "2021-01-07T17:57:46Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2480,6 +1690,127 @@ private static void checkPositive(int value, String desc) {\n         }\n     }\n \n+    /**\n+     * A builder for the  indexFromIndex policy. Let the caller set a source index and a fallback policy.\n+     */\n+    public static class IndexFromIndexPolicy {\n+        public static final IndexFromIndexPolicy INACTIVE = new IndexFromIndexPolicy();\n+        @Nullable private final String sourceIndex;\n+        private final boolean allowRecordScan;\n+        private boolean fallback = false;\n+\n+        /**\n+         * Build the index from a source index. Source index must be readable, idempotent, and fully cover the target index.\n+         * @param sourceIndex source index\n+         * @param allowRecordScan allow fallback to record scan\n+         */\n+        public IndexFromIndexPolicy(@Nonnull String sourceIndex, boolean allowRecordScan) {\n+            this.sourceIndex = sourceIndex;\n+            this.allowRecordScan = allowRecordScan;\n+        }\n+\n+        /**\n+         * Build a non-active object.\n+         */\n+        public IndexFromIndexPolicy() {\n+            this.sourceIndex = null;\n+            this.allowRecordScan = true;\n+        }\n+\n+        /**\n+         * Check if active.\n+         * @return True if active\n+         */\n+        public boolean isActive() {\n+            return sourceIndex != null && ! fallback;\n+        }\n+\n+        /**\n+         * Fallback is needed - deactivate indexFromIndex mode.\n+         */\n+        public void setFallback() {\n+            fallback = true;\n+        }\n+\n+        /**\n+         * If active, get the source index.\n+         * @return source index name\n+         */\n+        @Nullable\n+        public String getSourceIndex() {\n+            return sourceIndex;\n+        }\n+\n+        /**\n+         * If source index is not available, check if allowed to scan the records.\n+         * @return  {@code true} if a record scan is allowed\n+         */\n+        public boolean isAllowRecordScan() {\n+            return allowRecordScan;\n+        }\n+\n+        /**\n+         * Create a index from index policy builder.\n+         * @return a new {@link IndexFromIndexPolicy} builder\n+         */\n+        @Nonnull\n+        public static Builder newBuilder() {\n+            return new Builder();\n+        }\n+\n+        /**\n+         * Builder for {@link IndexFromIndexPolicy}.\n+         *\n+         * <pre><code>\n+         * OnlineIndexer.IndexFromIndexPolicy.newBuilder().setSourceIndex(\"src_index\").build()\n+         * </code></pre>\n+         *\n+         * Forbid fallback:\n+         * <pre><code>\n+         * OnlineIndexer.IndexFromIndexPolicy.newBuilder().setSourceIndex(\"src_index\").forbidRecordScan().build()\n+         * </code></pre>\n+         *\n+         */\n+        @API(API.Status.UNSTABLE)\n+        public static class Builder {\n+            boolean allowRecordScan = true;\n+            String sourceIndex = null;\n+\n+            protected Builder() {\n+            }\n+\n+            /**\n+             * Set a source index to scan.\n+             * Some sanity checks will be performed, but it is the caller's responsibility to verify that this source is\n+             * indexing all the relevant records for the target index.\n+             *\n+             * @param sourceIndex an existing, readable, index.\n+             * @return this builder\n+             */\n+            public Builder setSourceIndex(final String sourceIndex) {", "originalCommit": "c34f077926a2f9ace8de7edd1281c932aa2cbe78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ5Mzc0MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553493741", "bodyText": "It would be better to keep the user's configuration (an immutable object containing sourceIndex and allowRecordScan) and mutable internal state (fallback) separate.", "author": "nblintao", "createdAt": "2021-01-07T18:03:50Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2480,6 +1690,127 @@ private static void checkPositive(int value, String desc) {\n         }\n     }\n \n+    /**\n+     * A builder for the  indexFromIndex policy. Let the caller set a source index and a fallback policy.\n+     */\n+    public static class IndexFromIndexPolicy {\n+        public static final IndexFromIndexPolicy INACTIVE = new IndexFromIndexPolicy();\n+        @Nullable private final String sourceIndex;\n+        private final boolean allowRecordScan;\n+        private boolean fallback = false;", "originalCommit": "c34f077926a2f9ace8de7edd1281c932aa2cbe78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY2MDQxOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553660419", "bodyText": "I'm a little confused - since the user must use the IndexFromIndexPolicy.Builder (by your suggestion), this is not exposed to him.", "author": "jjezra", "createdAt": "2021-01-07T23:52:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ5Mzc0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkxOTU4Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556919582", "bodyText": "I'm not sure what the specific ask was before, but I think separating the configuration (i.e., the policy) from the state (i.e., whether fallback was used or not) would make sense. I don't really think the user should have to provide a Builder, though, and indeed, it looks like .setIndexFromIndex takes a non-Builder", "author": "alecgrieser", "createdAt": "2021-01-13T22:37:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ5Mzc0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ5NTkwNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553495904", "bodyText": "// this covers null pointer\n\nYou mean indexScanner is nonnull, right?", "author": "nblintao", "createdAt": "2021-01-07T18:07:54Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -223,23 +152,73 @@\n                   @Nonnull IndexStatePrecondition indexStatePrecondition,\n                   boolean useSynchronizedSession,\n                   long leaseLengthMillis,\n-                  boolean trackProgress) {\n+                  boolean trackProgress,\n+                  @Nonnull IndexFromIndexPolicy indexFromIndex) {\n         this.runner = runner;\n-        this.recordStoreBuilder = recordStoreBuilder;\n         this.index = index;\n-        this.recordTypes = recordTypes;\n-        this.configLoader = configLoader;\n-        this.config = config;\n-        this.limit = config.maxLimit;\n-        this.syntheticIndex = syntheticIndex;\n-        this.indexStatePrecondition = indexStatePrecondition;\n-        this.useSynchronizedSession = useSynchronizedSession;\n-        this.leaseLengthMills = leaseLengthMillis;\n-        this.trackProgress = trackProgress;\n-\n-        this.recordsRange = computeRecordsRange();\n-        timeOfLastProgressLogMillis = System.currentTimeMillis();\n-        totalRecordsScanned = new AtomicLong(0);\n+        this.indexFromIndex = indexFromIndex;\n+\n+        this.common = new OnlineIndexerCommon(runner, recordStoreBuilder,\n+                index, recordTypes, configLoader, config,\n+                syntheticIndex,\n+                indexStatePrecondition.getCommonVal(),\n+                trackProgress,\n+                useSynchronizedSession,\n+                leaseLengthMillis\n+            );\n+    }\n+\n+    @Nonnull\n+    private OnlineIndexerByIndex getScannerByIndex() {\n+        if (! (indexScanner instanceof OnlineIndexerByIndex)) { // this covers null pointer", "originalCommit": "c34f077926a2f9ace8de7edd1281c932aa2cbe78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY2MTY5OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553661698", "bodyText": "Yes. When writing something if(A != null && A instanceof B), the IDE is grumbling about redundancy.", "author": "jjezra", "createdAt": "2021-01-07T23:56:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ5NTkwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzMDk1NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556930955", "bodyText": "Yeah, that's because null instanceof Foo is always false according to the definition of the instanceof operator. Note that (Foo)null will not throw a cast class exception, though, so x instanceof Foo does not return true if and only if (Foo)x will succeed without error, which I think is kind of confusing and probably wouldn't be what they did if they had to make Java all over again (or at least, isn't what I'd do if I had to make Java all over again)", "author": "alecgrieser", "createdAt": "2021-01-13T22:52:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ5NTkwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUwMzc4MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553503781", "bodyText": "Maybe it's fine for a draft, but note that we don't want to \"fallback\" on every exception. It should only fallback on the ones that can possibly be resolved by falling back (e.g. src index is not readable)", "author": "nblintao", "createdAt": "2021-01-07T18:23:48Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -223,23 +152,73 @@\n                   @Nonnull IndexStatePrecondition indexStatePrecondition,\n                   boolean useSynchronizedSession,\n                   long leaseLengthMillis,\n-                  boolean trackProgress) {\n+                  boolean trackProgress,\n+                  @Nonnull IndexFromIndexPolicy indexFromIndex) {\n         this.runner = runner;\n-        this.recordStoreBuilder = recordStoreBuilder;\n         this.index = index;\n-        this.recordTypes = recordTypes;\n-        this.configLoader = configLoader;\n-        this.config = config;\n-        this.limit = config.maxLimit;\n-        this.syntheticIndex = syntheticIndex;\n-        this.indexStatePrecondition = indexStatePrecondition;\n-        this.useSynchronizedSession = useSynchronizedSession;\n-        this.leaseLengthMills = leaseLengthMillis;\n-        this.trackProgress = trackProgress;\n-\n-        this.recordsRange = computeRecordsRange();\n-        timeOfLastProgressLogMillis = System.currentTimeMillis();\n-        totalRecordsScanned = new AtomicLong(0);\n+        this.indexFromIndex = indexFromIndex;\n+\n+        this.common = new OnlineIndexerCommon(runner, recordStoreBuilder,\n+                index, recordTypes, configLoader, config,\n+                syntheticIndex,\n+                indexStatePrecondition.getCommonVal(),\n+                trackProgress,\n+                useSynchronizedSession,\n+                leaseLengthMillis\n+            );\n+    }\n+\n+    @Nonnull\n+    private OnlineIndexerByIndex getScannerByIndex() {\n+        if (! (indexScanner instanceof OnlineIndexerByIndex)) { // this covers null pointer\n+            indexScanner = new OnlineIndexerByIndex(common, indexFromIndex);\n+        }\n+        return (OnlineIndexerByIndex)indexScanner;\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> handleScannerReturnOrFallback(Throwable ex, Supplier<CompletableFuture<Void>> fallback) {\n+        if (ex == null) {\n+            return AsyncUtil.DONE;\n+        }\n+        if ( indexFromIndex.isActive() &&\n+                 indexFromIndex.isAllowRecordScan() &&\n+                 (ex.getCause() instanceof OnlineIndexerException)) {", "originalCommit": "c34f077926a2f9ace8de7edd1281c932aa2cbe78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY2MjQ3OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553662478", "bodyText": "It is now limited to validation exception:\nex.getCause() instanceof OnlineIndexerByIndex.ValidationException", "author": "jjezra", "createdAt": "2021-01-07T23:59:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUwMzc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUwNjA1Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r553506053", "bodyText": "I understand in the design you don't want to make OnlineIndexerCommon to depend on OnlineIndexer. But here I think it is fine to make IndexStatePrecondition static and import it into OnlineIndexerCommon.", "author": "nblintao", "createdAt": "2021-01-07T18:28:15Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -2514,39 +1845,45 @@ public static OnlineIndexer forRecordStoreAndIndex(@Nonnull FDBRecordStore recor\n         /**\n          * Only build if the index is disabled.\n          */\n-        BUILD_IF_DISABLED(false),\n+        BUILD_IF_DISABLED(false, OnlineIndexerCommon.IndexStatePrecondition.BUILD_IF_DISABLED),", "originalCommit": "c34f077926a2f9ace8de7edd1281c932aa2cbe78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3f532059ebed5201605785e89bfa7d59869c3464", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/3f532059ebed5201605785e89bfa7d59869c3464", "message": "Apply most of Tao's, Alec's, Scott's review requests.", "committedDate": "2021-01-08T02:23:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgzMzgyNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556833825", "bodyText": "the indentation is a bit off, and the two Atomic* parameters could use @Nonnull\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected <T> CompletableFuture<Void> iterateRangeOnly(@Nonnull FDBRecordStore store,\n          \n          \n            \n                                                                   @Nonnull RecordCursor<T> cursor,\n          \n          \n            \n                                                                   @Nonnull Function<RecordCursorResult<T>, FDBStoredRecord<Message>> getRecord,\n          \n          \n            \n                                                                   @Nonnull Consumer<RecordCursorResult<T>> lastResultSet,\n          \n          \n            \n                                                                   AtomicBoolean isEmpty,\n          \n          \n            \n                                                                   AtomicLong recordsScannedCounter\n          \n          \n            \n                ) {\n          \n          \n            \n                protected <T> CompletableFuture<Void> iterateRangeOnly(@Nonnull FDBRecordStore store,\n          \n          \n            \n                                                                       @Nonnull RecordCursor<T> cursor,\n          \n          \n            \n                                                                       @Nonnull Function<RecordCursorResult<T>, FDBStoredRecord<Message>> getRecord,\n          \n          \n            \n                                                                       @Nonnull Consumer<RecordCursorResult<T>> lastResultSet,\n          \n          \n            \n                                                                       @Nonnull AtomicBoolean isEmpty,\n          \n          \n            \n                                                                       @Nonnull AtomicLong recordsScannedCounter) {", "author": "ScottDugas", "createdAt": "2021-01-13T21:17:25Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingBase.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * OnlineIndexerScanner.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.FDBException;\n+import com.apple.foundationdb.Transaction;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.MoreAsyncUtil;\n+import com.apple.foundationdb.async.RangeSet;\n+import com.apple.foundationdb.record.IndexState;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorResult;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.provider.foundationdb.synchronizedsession.SynchronizedSessionRunner;\n+import com.apple.foundationdb.record.query.plan.synthetic.SyntheticRecordFromStoredRecordPlan;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.google.protobuf.Message;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A base class for different types of online indexing scanners.\n+ */\n+@API(API.Status.INTERNAL)\n+public abstract class IndexingBase {\n+\n+\n+    private static final Object INDEX_BUILD_LOCK_KEY = 0L;\n+    private static final Object INDEX_BUILD_SCANNED_RECORDS = 1L;\n+    private static final Object INDEX_BUILD_TYPE = 2L;\n+\n+    @Nonnull\n+    private static final Logger LOGGER = LoggerFactory.getLogger(IndexingBase.class);\n+    @Nonnull\n+    protected final IndexingCommon common; // to be used by extenders\n+    @Nonnull\n+    private final IndexingThrottle throttle;\n+\n+    private long timeOfLastProgressLogMillis = 0;\n+\n+    IndexingBase(IndexingCommon common) {\n+        this.common = common;\n+        this.throttle = new IndexingThrottle(common);\n+    }\n+\n+    protected FDBDatabaseRunner getRunner() {\n+        return common.getRunner();\n+    }\n+\n+    @Nonnull\n+    protected static Subspace indexBuildLockSubspace(@Nonnull FDBRecordStoreBase<?> store, @Nonnull Index index) {\n+        return store.getUntypedRecordStore().indexBuildSubspace(index).subspace(Tuple.from(INDEX_BUILD_LOCK_KEY));\n+    }\n+\n+    @Nonnull\n+    protected static Subspace indexBuildScannedRecordsSubspace(@Nonnull FDBRecordStoreBase<?> store, @Nonnull Index index) {\n+        return store.getUntypedRecordStore().indexBuildSubspace(index)\n+                .subspace(Tuple.from(INDEX_BUILD_SCANNED_RECORDS));\n+    }\n+\n+    @Nonnull\n+    protected static Subspace indexBuildTypeSubspace(@Nonnull FDBRecordStoreBase<?> store, @Nonnull Index index) {\n+        return store.getUntypedRecordStore().indexBuildSubspace(index).subspace(Tuple.from(INDEX_BUILD_TYPE));\n+    }\n+\n+    @SuppressWarnings(\"squid:S1452\")\n+    protected CompletableFuture<FDBRecordStore> openRecordStore(@Nonnull FDBRecordContext context) {\n+        return common.getRecordStoreBuilder().copyBuilder().setContext(context).openAsync();\n+    }\n+\n+    CompletableFuture<Void> buildIndexAsync(boolean markReadable) {\n+        KeyValueLogMessage message = KeyValueLogMessage.build(\"build index online\",\n+                LogMessageKeys.SHOULD_MARK_READABLE, markReadable);\n+        final CompletableFuture<Void> buildIndexAsyncFuture;\n+        FDBDatabaseRunner runner = common.getRunner();\n+        Index index = common.getIndex();\n+        if (common.isUseSynchronizedSession()) {\n+            buildIndexAsyncFuture = runner\n+                    .runAsync(context -> openRecordStore(context).thenApply(store -> indexBuildLockSubspace(store, index)))\n+                    .thenCompose(lockSubspace -> runner.startSynchronizedSessionAsync(lockSubspace, common.getLeaseLengthMillis()))\n+                    .thenCompose(synchronizedRunner -> {\n+                        message.addKeyAndValue(LogMessageKeys.SESSION_ID, synchronizedRunner.getSessionId());\n+                        return runWithSynchronizedRunnerAndEndSession(synchronizedRunner,\n+                                () -> handleStateAndDoBuildIndexAsync(markReadable, message));\n+                    });\n+        } else {\n+            message.addKeyAndValue(LogMessageKeys.SESSION_ID, \"none\");\n+            common.setSynchronizedSessionRunner(null);\n+            buildIndexAsyncFuture = handleStateAndDoBuildIndexAsync(markReadable, message);\n+        }\n+        return buildIndexAsyncFuture.whenComplete((vignore, ex) -> {\n+            if (LOGGER.isWarnEnabled() && (ex != null)) {\n+                message.addKeyAndValue(LogMessageKeys.RESULT, \"failure\");\n+                LOGGER.warn(message.toString(), ex);\n+            } else if (LOGGER.isInfoEnabled()) {\n+                message.addKeyAndValue(LogMessageKeys.RESULT, \"success\");\n+                LOGGER.info(message.toString());\n+            }\n+        });\n+    }\n+\n+    private <T> CompletableFuture<T> runWithSynchronizedRunnerAndEndSession(\n+            @Nonnull SynchronizedSessionRunner newSynchronizedRunner, @Nonnull Supplier<CompletableFuture<T>> runnable) {\n+        final SynchronizedSessionRunner currentSynchronizedRunner1 = common.getSynchronizedSessionRunner();\n+        if (currentSynchronizedRunner1 == null) {\n+            common.setSynchronizedSessionRunner(newSynchronizedRunner);\n+            return MoreAsyncUtil.composeWhenComplete(runnable.get(), (result, ex) -> {\n+                final SynchronizedSessionRunner currentSynchronizedRunner2 = common.getSynchronizedSessionRunner();\n+                if (newSynchronizedRunner.equals(currentSynchronizedRunner2)) {\n+                    common.setSynchronizedSessionRunner(null);\n+                } else {\n+                    LOGGER.warn(KeyValueLogMessage.of(\"synchronizedSessionRunner was modified during the run\",\n+                            LogMessageKeys.SESSION_ID, newSynchronizedRunner.getSessionId(),\n+                            LogMessageKeys.INDEXER_SESSION_ID, currentSynchronizedRunner2 == null ? null : currentSynchronizedRunner2.getSessionId()));\n+                }\n+                return newSynchronizedRunner.endSessionAsync();\n+            }, getRunner().getDatabase()::mapAsyncToSyncException);\n+        } else {\n+            return newSynchronizedRunner.endSessionAsync().thenApply(vignore -> {\n+                throw new RecordCoreException(\"another synchronized session is running on the indexer\",\n+                        LogMessageKeys.SESSION_ID, newSynchronizedRunner.getSessionId(),\n+                        LogMessageKeys.INDEXER_SESSION_ID, currentSynchronizedRunner1.getSessionId());\n+            });\n+        }\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> handleStateAndDoBuildIndexAsync(boolean markReadable, KeyValueLogMessage message) {\n+\n+        OnlineIndexer.IndexStatePrecondition indexStatePrecondition = common.getIndexStatePrecondition();\n+        message.addKeyAndValue(LogMessageKeys.INDEX_STATE_PRECONDITION, indexStatePrecondition);\n+        if (indexStatePrecondition == OnlineIndexer.IndexStatePrecondition.ERROR_IF_DISABLED_CONTINUE_IF_WRITE_ONLY) {\n+            message.addKeyAndValue(LogMessageKeys.SHOULD_BUILD_INDEX, true);\n+            return doBuildIndexAsync(markReadable);\n+        }\n+        final Index index = common.getIndex();\n+        return getRunner().runAsync(context -> openRecordStore(context).thenCompose(store -> {\n+            IndexState indexState = store.getIndexState(index);\n+            boolean shouldBuild = shouldBuildIndex(indexState, indexStatePrecondition);\n+            message.addKeyAndValue(LogMessageKeys.INITIAL_INDEX_STATE, indexState);\n+            message.addKeyAndValue(LogMessageKeys.SHOULD_BUILD_INDEX, shouldBuild);\n+            if (shouldBuild) {\n+                boolean shouldClear = shouldClearExistingIndexEntries(indexState, indexStatePrecondition);\n+                message.addKeyAndValue(LogMessageKeys.SHOULD_CLEAR_EXISTING_DATA, shouldClear);\n+                if (shouldClear) {\n+                    store.clearIndexData(index);\n+                }\n+                return store.markIndexWriteOnly(index).thenApply(vignore -> true);\n+            } else {\n+                return AsyncUtil.READY_FALSE;\n+            }\n+        })).thenCompose(shouldBuild -> shouldBuild != null && shouldBuild ? doBuildIndexAsync(markReadable) : AsyncUtil.DONE);\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    private boolean shouldBuildIndex(@Nonnull IndexState indexState, @Nonnull OnlineIndexer.IndexStatePrecondition indexStatePrecondition) {\n+        switch (indexStatePrecondition) {\n+            case BUILD_IF_DISABLED:\n+                return indexState == IndexState.DISABLED;\n+\n+            case BUILD_IF_DISABLED_CONTINUE_BUILD_IF_WRITE_ONLY:\n+            case BUILD_IF_DISABLED_REBUILD_IF_WRITE_ONLY:\n+                return indexState == IndexState.DISABLED || indexState == IndexState.WRITE_ONLY;\n+\n+            case FORCE_BUILD:\n+                return true;\n+\n+            default:\n+                throw new RecordCoreException(\"unknown index state precondition \" + indexStatePrecondition);\n+        }\n+    }\n+\n+    private boolean shouldClearExistingIndexEntries(@Nonnull IndexState indexState,\n+                                                    @Nonnull OnlineIndexer.IndexStatePrecondition indexStatePrecondition) {\n+        // If the index state is DISABLED, it is expected that there is no existing index entry. But we would like\n+        // to clear it anyway to play safe.\n+        return !(indexState == IndexState.WRITE_ONLY && indexStatePrecondition.isContinueIfWriteOnly());\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n+        CompletableFuture<Void> buildFuture = scanBuildIndexAsync();\n+\n+        if (markReadable) {\n+            return buildFuture.thenCompose(vignore ->\n+                    getRunner().runAsync(context -> openRecordStore(context)\n+                            .thenCompose(store -> store.markIndexReadable(common.getIndex()))\n+                            .thenApply(ignore -> null)));\n+        } else {\n+            return buildFuture;\n+        }\n+    }\n+\n+    abstract CompletableFuture<Void> scanBuildIndexAsync();\n+\n+    protected boolean shouldLogBuildProgress() {\n+        long interval = common.config.getProgressLogIntervalMillis();\n+        long now = System.currentTimeMillis();\n+        if (interval == 0 || interval < (now - timeOfLastProgressLogMillis)) {\n+            return false;\n+        }\n+        timeOfLastProgressLogMillis = now;\n+        return true;\n+    }\n+\n+    public int getLimit() {\n+        // made public to support tests\n+        return throttle.getLimit();\n+    }\n+\n+    protected CompletableFuture<Boolean> throttleDelay() {\n+        int limit = getLimit();\n+        int recordsPerSecond = common.config.getRecordsPerSecond();\n+        int toWait = (recordsPerSecond == IndexingCommon.UNLIMITED) ? 0 : 1000 * limit / recordsPerSecond;\n+        return MoreAsyncUtil.delayedFuture(toWait, TimeUnit.MILLISECONDS).thenApply(vignore3 -> true);\n+    }\n+\n+\n+    public <R> CompletableFuture<R> buildAsync(@Nonnull BiFunction<FDBRecordStore, AtomicLong, CompletableFuture<R>> buildFunction,\n+                                        boolean limitControl,\n+                                        @Nullable List<Object> additionalLogMessageKeyValues) {\n+\n+        return throttle.buildAsync(buildFunction, limitControl, additionalLogMessageKeyValues);\n+    }\n+\n+    private static void timerIncrement(@Nullable FDBStoreTimer timer, FDBStoreTimer.Counts event) {\n+        // helper function to reduce complexity\n+        if (timer != null) {\n+            timer.increment(event);\n+        }\n+    }\n+\n+    private static CompletableFuture<Void> updateMaintainerBuilder(SyntheticRecordFromStoredRecordPlan syntheticPlan,\n+                                                                   FDBStoredRecord<Message> rec,\n+                                                                   IndexMaintainer maintainer,\n+                                                                   FDBRecordStore store) {\n+        // helper function to reduce complexity\n+        if (syntheticPlan == null) {\n+            return maintainer.update(null, rec);\n+        }\n+        // Pipeline size is 1, since not all maintainers are thread-safe.\n+        return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n+    }\n+\n+    protected <T> CompletableFuture<Void> iterateRangeOnly(@Nonnull FDBRecordStore store,\n+                                                       @Nonnull RecordCursor<T> cursor,\n+                                                       @Nonnull Function<RecordCursorResult<T>, FDBStoredRecord<Message>> getRecord,\n+                                                       @Nonnull Consumer<RecordCursorResult<T>> lastResultSet,\n+                                                       AtomicBoolean isEmpty,\n+                                                       AtomicLong recordsScannedCounter\n+    ) {", "originalCommit": "c531ce9049a4eb57f74dedd82c09efb3a15be757", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgzNzM5OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556837399", "bodyText": "It seems strange that this is implemented here, and not in the base class.", "author": "ScottDugas", "createdAt": "2021-01-13T21:21:39Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingByIndex.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * OnlineIndexerByIndex.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.MutationType;\n+import com.apple.foundationdb.TransactionContext;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.RangeSet;\n+import com.apple.foundationdb.record.ExecuteProperties;\n+import com.apple.foundationdb.record.IndexScanType;\n+import com.apple.foundationdb.record.IsolationLevel;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorResult;\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.RecordMetaDataProvider;\n+import com.apple.foundationdb.record.ScanProperties;\n+import com.apple.foundationdb.record.TupleRange;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.MetaDataException;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.ByteArrayUtil2;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.google.protobuf.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * This indexer scans records by a source index.\n+ */\n+@API(API.Status.INTERNAL)\n+public class IndexingByIndex extends IndexingBase {\n+    @Nonnull private static final Logger LOGGER = LoggerFactory.getLogger(IndexingByIndex.class);\n+    @Nonnull private final OnlineIndexer.IndexFromIndexPolicy policy;\n+\n+    IndexingByIndex(@Nonnull IndexingCommon common,\n+                    @Nonnull OnlineIndexer.IndexFromIndexPolicy policy) {\n+        super(common);\n+        this.policy = policy;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    CompletableFuture<Void> scanBuildIndexAsync() {\n+        return getRunner().runAsync(context -> openRecordStore(context)\n+                .thenCompose( store -> {\n+                    // first validate that both src and tgt are of a single, similar, type\n+                    final RecordMetaData metaData = store.getRecordMetaData();\n+                    final Index srcIndex = metaData.getIndex(Objects.requireNonNull(policy.getSourceIndex()));\n+                    final Collection<RecordType> srcRecordTypes = metaData.recordTypesForIndex(srcIndex);\n+\n+                    validateOrThrowEx(!common.isSyntheticIndex(), \"target index is synthetic\");\n+                    validateOrThrowEx(common.recordTypes.size() == 1, \"target index has multiple types\");\n+                    validateOrThrowEx(srcRecordTypes.size() == 1, \"source index has multiple types\");\n+                    validateOrThrowEx(!srcIndex.getRootExpression().createsDuplicates(), \"source index creates duplicates\");\n+                    validateOrThrowEx(srcIndex.getType().equals(IndexTypes.VALUE), \"source index is not a VALUE index\");\n+                    validateOrThrowEx(common.recordTypes.equals(srcRecordTypes), \"source index's type is not equal to target index's\");\n+\n+                    // all valid; back to the future. Note that for practical reasons, readability and idempotency will be validated later\n+                    return context.getReadVersionAsync()\n+                            .thenCompose(vignore -> {\n+                                SubspaceProvider subspaceProvider = common.getRecordStoreBuilder().getSubspaceProvider();\n+                                return subspaceProvider.getSubspaceAsync(context)\n+                                        .thenCompose(subspace ->\n+                                                buildIndexFromIndex(subspaceProvider, subspace)\n+                                                        .thenCompose(vignore2 -> markBuilt(subspace)\n+                                                        ));\n+                            });\n+                }));\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> markBuilt(Subspace subspace) {", "originalCommit": "c531ce9049a4eb57f74dedd82c09efb3a15be757", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzYwMzc4OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r557603789", "bodyText": "The markBuilt will be overridden by the persistent continuation.", "author": "jjezra", "createdAt": "2021-01-14T18:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgzNzM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg0MDgyOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556840828", "bodyText": "This doesn't add much information beyond the name of the method\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // rebuildIndexScan", "author": "ScottDugas", "createdAt": "2021-01-13T21:24:51Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingBase.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * OnlineIndexerScanner.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.FDBException;\n+import com.apple.foundationdb.Transaction;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.MoreAsyncUtil;\n+import com.apple.foundationdb.async.RangeSet;\n+import com.apple.foundationdb.record.IndexState;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorResult;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.provider.foundationdb.synchronizedsession.SynchronizedSessionRunner;\n+import com.apple.foundationdb.record.query.plan.synthetic.SyntheticRecordFromStoredRecordPlan;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.google.protobuf.Message;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A base class for different types of online indexing scanners.\n+ */\n+@API(API.Status.INTERNAL)\n+public abstract class IndexingBase {\n+\n+\n+    private static final Object INDEX_BUILD_LOCK_KEY = 0L;\n+    private static final Object INDEX_BUILD_SCANNED_RECORDS = 1L;\n+    private static final Object INDEX_BUILD_TYPE = 2L;\n+\n+    @Nonnull\n+    private static final Logger LOGGER = LoggerFactory.getLogger(IndexingBase.class);\n+    @Nonnull\n+    protected final IndexingCommon common; // to be used by extenders\n+    @Nonnull\n+    private final IndexingThrottle throttle;\n+\n+    private long timeOfLastProgressLogMillis = 0;\n+\n+    IndexingBase(IndexingCommon common) {\n+        this.common = common;\n+        this.throttle = new IndexingThrottle(common);\n+    }\n+\n+    protected FDBDatabaseRunner getRunner() {\n+        return common.getRunner();\n+    }\n+\n+    @Nonnull\n+    protected static Subspace indexBuildLockSubspace(@Nonnull FDBRecordStoreBase<?> store, @Nonnull Index index) {\n+        return store.getUntypedRecordStore().indexBuildSubspace(index).subspace(Tuple.from(INDEX_BUILD_LOCK_KEY));\n+    }\n+\n+    @Nonnull\n+    protected static Subspace indexBuildScannedRecordsSubspace(@Nonnull FDBRecordStoreBase<?> store, @Nonnull Index index) {\n+        return store.getUntypedRecordStore().indexBuildSubspace(index)\n+                .subspace(Tuple.from(INDEX_BUILD_SCANNED_RECORDS));\n+    }\n+\n+    @Nonnull\n+    protected static Subspace indexBuildTypeSubspace(@Nonnull FDBRecordStoreBase<?> store, @Nonnull Index index) {\n+        return store.getUntypedRecordStore().indexBuildSubspace(index).subspace(Tuple.from(INDEX_BUILD_TYPE));\n+    }\n+\n+    @SuppressWarnings(\"squid:S1452\")\n+    protected CompletableFuture<FDBRecordStore> openRecordStore(@Nonnull FDBRecordContext context) {\n+        return common.getRecordStoreBuilder().copyBuilder().setContext(context).openAsync();\n+    }\n+\n+    CompletableFuture<Void> buildIndexAsync(boolean markReadable) {\n+        KeyValueLogMessage message = KeyValueLogMessage.build(\"build index online\",\n+                LogMessageKeys.SHOULD_MARK_READABLE, markReadable);\n+        final CompletableFuture<Void> buildIndexAsyncFuture;\n+        FDBDatabaseRunner runner = common.getRunner();\n+        Index index = common.getIndex();\n+        if (common.isUseSynchronizedSession()) {\n+            buildIndexAsyncFuture = runner\n+                    .runAsync(context -> openRecordStore(context).thenApply(store -> indexBuildLockSubspace(store, index)))\n+                    .thenCompose(lockSubspace -> runner.startSynchronizedSessionAsync(lockSubspace, common.getLeaseLengthMillis()))\n+                    .thenCompose(synchronizedRunner -> {\n+                        message.addKeyAndValue(LogMessageKeys.SESSION_ID, synchronizedRunner.getSessionId());\n+                        return runWithSynchronizedRunnerAndEndSession(synchronizedRunner,\n+                                () -> handleStateAndDoBuildIndexAsync(markReadable, message));\n+                    });\n+        } else {\n+            message.addKeyAndValue(LogMessageKeys.SESSION_ID, \"none\");\n+            common.setSynchronizedSessionRunner(null);\n+            buildIndexAsyncFuture = handleStateAndDoBuildIndexAsync(markReadable, message);\n+        }\n+        return buildIndexAsyncFuture.whenComplete((vignore, ex) -> {\n+            if (LOGGER.isWarnEnabled() && (ex != null)) {\n+                message.addKeyAndValue(LogMessageKeys.RESULT, \"failure\");\n+                LOGGER.warn(message.toString(), ex);\n+            } else if (LOGGER.isInfoEnabled()) {\n+                message.addKeyAndValue(LogMessageKeys.RESULT, \"success\");\n+                LOGGER.info(message.toString());\n+            }\n+        });\n+    }\n+\n+    private <T> CompletableFuture<T> runWithSynchronizedRunnerAndEndSession(\n+            @Nonnull SynchronizedSessionRunner newSynchronizedRunner, @Nonnull Supplier<CompletableFuture<T>> runnable) {\n+        final SynchronizedSessionRunner currentSynchronizedRunner1 = common.getSynchronizedSessionRunner();\n+        if (currentSynchronizedRunner1 == null) {\n+            common.setSynchronizedSessionRunner(newSynchronizedRunner);\n+            return MoreAsyncUtil.composeWhenComplete(runnable.get(), (result, ex) -> {\n+                final SynchronizedSessionRunner currentSynchronizedRunner2 = common.getSynchronizedSessionRunner();\n+                if (newSynchronizedRunner.equals(currentSynchronizedRunner2)) {\n+                    common.setSynchronizedSessionRunner(null);\n+                } else {\n+                    LOGGER.warn(KeyValueLogMessage.of(\"synchronizedSessionRunner was modified during the run\",\n+                            LogMessageKeys.SESSION_ID, newSynchronizedRunner.getSessionId(),\n+                            LogMessageKeys.INDEXER_SESSION_ID, currentSynchronizedRunner2 == null ? null : currentSynchronizedRunner2.getSessionId()));\n+                }\n+                return newSynchronizedRunner.endSessionAsync();\n+            }, getRunner().getDatabase()::mapAsyncToSyncException);\n+        } else {\n+            return newSynchronizedRunner.endSessionAsync().thenApply(vignore -> {\n+                throw new RecordCoreException(\"another synchronized session is running on the indexer\",\n+                        LogMessageKeys.SESSION_ID, newSynchronizedRunner.getSessionId(),\n+                        LogMessageKeys.INDEXER_SESSION_ID, currentSynchronizedRunner1.getSessionId());\n+            });\n+        }\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> handleStateAndDoBuildIndexAsync(boolean markReadable, KeyValueLogMessage message) {\n+\n+        OnlineIndexer.IndexStatePrecondition indexStatePrecondition = common.getIndexStatePrecondition();\n+        message.addKeyAndValue(LogMessageKeys.INDEX_STATE_PRECONDITION, indexStatePrecondition);\n+        if (indexStatePrecondition == OnlineIndexer.IndexStatePrecondition.ERROR_IF_DISABLED_CONTINUE_IF_WRITE_ONLY) {\n+            message.addKeyAndValue(LogMessageKeys.SHOULD_BUILD_INDEX, true);\n+            return doBuildIndexAsync(markReadable);\n+        }\n+        final Index index = common.getIndex();\n+        return getRunner().runAsync(context -> openRecordStore(context).thenCompose(store -> {\n+            IndexState indexState = store.getIndexState(index);\n+            boolean shouldBuild = shouldBuildIndex(indexState, indexStatePrecondition);\n+            message.addKeyAndValue(LogMessageKeys.INITIAL_INDEX_STATE, indexState);\n+            message.addKeyAndValue(LogMessageKeys.SHOULD_BUILD_INDEX, shouldBuild);\n+            if (shouldBuild) {\n+                boolean shouldClear = shouldClearExistingIndexEntries(indexState, indexStatePrecondition);\n+                message.addKeyAndValue(LogMessageKeys.SHOULD_CLEAR_EXISTING_DATA, shouldClear);\n+                if (shouldClear) {\n+                    store.clearIndexData(index);\n+                }\n+                return store.markIndexWriteOnly(index).thenApply(vignore -> true);\n+            } else {\n+                return AsyncUtil.READY_FALSE;\n+            }\n+        })).thenCompose(shouldBuild -> shouldBuild != null && shouldBuild ? doBuildIndexAsync(markReadable) : AsyncUtil.DONE);\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    private boolean shouldBuildIndex(@Nonnull IndexState indexState, @Nonnull OnlineIndexer.IndexStatePrecondition indexStatePrecondition) {\n+        switch (indexStatePrecondition) {\n+            case BUILD_IF_DISABLED:\n+                return indexState == IndexState.DISABLED;\n+\n+            case BUILD_IF_DISABLED_CONTINUE_BUILD_IF_WRITE_ONLY:\n+            case BUILD_IF_DISABLED_REBUILD_IF_WRITE_ONLY:\n+                return indexState == IndexState.DISABLED || indexState == IndexState.WRITE_ONLY;\n+\n+            case FORCE_BUILD:\n+                return true;\n+\n+            default:\n+                throw new RecordCoreException(\"unknown index state precondition \" + indexStatePrecondition);\n+        }\n+    }\n+\n+    private boolean shouldClearExistingIndexEntries(@Nonnull IndexState indexState,\n+                                                    @Nonnull OnlineIndexer.IndexStatePrecondition indexStatePrecondition) {\n+        // If the index state is DISABLED, it is expected that there is no existing index entry. But we would like\n+        // to clear it anyway to play safe.\n+        return !(indexState == IndexState.WRITE_ONLY && indexStatePrecondition.isContinueIfWriteOnly());\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n+        CompletableFuture<Void> buildFuture = scanBuildIndexAsync();\n+\n+        if (markReadable) {\n+            return buildFuture.thenCompose(vignore ->\n+                    getRunner().runAsync(context -> openRecordStore(context)\n+                            .thenCompose(store -> store.markIndexReadable(common.getIndex()))\n+                            .thenApply(ignore -> null)));\n+        } else {\n+            return buildFuture;\n+        }\n+    }\n+\n+    abstract CompletableFuture<Void> scanBuildIndexAsync();\n+\n+    protected boolean shouldLogBuildProgress() {\n+        long interval = common.config.getProgressLogIntervalMillis();\n+        long now = System.currentTimeMillis();\n+        if (interval == 0 || interval < (now - timeOfLastProgressLogMillis)) {\n+            return false;\n+        }\n+        timeOfLastProgressLogMillis = now;\n+        return true;\n+    }\n+\n+    public int getLimit() {\n+        // made public to support tests\n+        return throttle.getLimit();\n+    }\n+\n+    protected CompletableFuture<Boolean> throttleDelay() {\n+        int limit = getLimit();\n+        int recordsPerSecond = common.config.getRecordsPerSecond();\n+        int toWait = (recordsPerSecond == IndexingCommon.UNLIMITED) ? 0 : 1000 * limit / recordsPerSecond;\n+        return MoreAsyncUtil.delayedFuture(toWait, TimeUnit.MILLISECONDS).thenApply(vignore3 -> true);\n+    }\n+\n+\n+    public <R> CompletableFuture<R> buildAsync(@Nonnull BiFunction<FDBRecordStore, AtomicLong, CompletableFuture<R>> buildFunction,\n+                                        boolean limitControl,\n+                                        @Nullable List<Object> additionalLogMessageKeyValues) {\n+\n+        return throttle.buildAsync(buildFunction, limitControl, additionalLogMessageKeyValues);\n+    }\n+\n+    private static void timerIncrement(@Nullable FDBStoreTimer timer, FDBStoreTimer.Counts event) {\n+        // helper function to reduce complexity\n+        if (timer != null) {\n+            timer.increment(event);\n+        }\n+    }\n+\n+    private static CompletableFuture<Void> updateMaintainerBuilder(SyntheticRecordFromStoredRecordPlan syntheticPlan,\n+                                                                   FDBStoredRecord<Message> rec,\n+                                                                   IndexMaintainer maintainer,\n+                                                                   FDBRecordStore store) {\n+        // helper function to reduce complexity\n+        if (syntheticPlan == null) {\n+            return maintainer.update(null, rec);\n+        }\n+        // Pipeline size is 1, since not all maintainers are thread-safe.\n+        return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n+    }\n+\n+    protected <T> CompletableFuture<Void> iterateRangeOnly(@Nonnull FDBRecordStore store,\n+                                                       @Nonnull RecordCursor<T> cursor,\n+                                                       @Nonnull Function<RecordCursorResult<T>, FDBStoredRecord<Message>> getRecord,\n+                                                       @Nonnull Consumer<RecordCursorResult<T>> lastResultSet,\n+                                                       AtomicBoolean isEmpty,\n+                                                       AtomicLong recordsScannedCounter\n+    ) {\n+        final FDBStoreTimer timer = getRunner().getTimer();\n+        final Index index = common.getIndex();\n+        final IndexMaintainer maintainer = store.getIndexMaintainer(index);\n+        final boolean isIdempotent = maintainer.isIdempotent();\n+        final FDBRecordContext context = store.getContext();\n+        final SyntheticRecordFromStoredRecordPlan syntheticPlan = common.getSyntheticPlan(store);\n+        // Need to do this each transaction because other index enabled state might have changed. Could cache based on that.\n+        // Copying the state also guards against changes made by other online building from check version.\n+        // TODO: need some state to avoid generating the same synthetic record via more than one self-join path for non-idempotent indexes.\n+\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                timerIncrement(timer, FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGES_BY_COUNT);\n+                lastResultSet.accept(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n+            final FDBStoredRecord<Message> rec = getRecord.apply(result);\n+            isEmpty.set(false);\n+            timerIncrement(timer, FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n+            recordsScannedCounter.incrementAndGet();\n+            if (!common.recordTypes.contains(rec.getRecordType())) {\n+                // This record is not our type, swipe left\n+                return AsyncUtil.READY_TRUE;\n+            }\n+            // add this index to the transaction\n+            if (isIdempotent) {\n+                store.addRecordReadConflict(rec.getPrimaryKey());\n+            }\n+            timerIncrement(timer, FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n+\n+            final CompletableFuture<Void> updateMaintainer = updateMaintainerBuilder(syntheticPlan, rec, maintainer, store);\n+\n+            return updateMaintainer.thenCompose(vignore ->\n+                    context.getApproximateTransactionSize().thenApply(size -> {\n+                        if (size >= common.config.getMaxWriteLimitBytes()) {\n+                            // the transaction becomes too big - stop iterating\n+                            timerIncrement(timer, FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGES_BY_SIZE);\n+                            lastResultSet.accept(result);\n+                            return false;\n+                        }\n+                        return true;\n+                    }));\n+\n+        }), cursor.getExecutor());\n+    }\n+\n+    // rebuildIndexScan", "originalCommit": "c531ce9049a4eb57f74dedd82c09efb3a15be757", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1MDA3Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556850072", "bodyText": "There's a lot of methods in here with very similar names, that are impossible to discern without reading the implementation. There's probably better names that at least some of them could have, but assuming that there isn't a different set of names that would make everything clear, javadocs for the public/protected methods.\nSpecifically thinking of:\n\nbuildIndexAsync\nhandleStateAndDoBuildIndexAsync\ndoBuildIndexAsync\nscanBuildIndexAsync\nbuildAsync\nrebuildIndexAsync\nscanRebuildIndexAsync", "author": "ScottDugas", "createdAt": "2021-01-13T21:33:05Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingBase.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * OnlineIndexerScanner.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.FDBException;\n+import com.apple.foundationdb.Transaction;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.MoreAsyncUtil;\n+import com.apple.foundationdb.async.RangeSet;\n+import com.apple.foundationdb.record.IndexState;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorResult;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.provider.foundationdb.synchronizedsession.SynchronizedSessionRunner;\n+import com.apple.foundationdb.record.query.plan.synthetic.SyntheticRecordFromStoredRecordPlan;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.google.protobuf.Message;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A base class for different types of online indexing scanners.\n+ */\n+@API(API.Status.INTERNAL)\n+public abstract class IndexingBase {", "originalCommit": "c531ce9049a4eb57f74dedd82c09efb3a15be757", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzUwMDE4MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r557500181", "bodyText": "I strongly agree. Had my share of confusion while studying OnlineIndexer. I'll try to find better names.", "author": "jjezra", "createdAt": "2021-01-14T15:55:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1MDA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4MzI4Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556883282", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Shared structure to be used (only) by the OnlineIndexer* modules.\n          \n          \n            \n             * Shared structure to be used (only) by the Indexing* classes.", "author": "ScottDugas", "createdAt": "2021-01-13T22:03:11Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingCommon.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * OnlineIndexerCommon.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.provider.foundationdb.synchronizedsession.SynchronizedSessionRunner;\n+import com.apple.foundationdb.record.query.plan.synthetic.SyntheticRecordFromStoredRecordPlan;\n+import com.apple.foundationdb.record.query.plan.synthetic.SyntheticRecordPlanner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+\n+/**\n+ * Shared structure to be used (only) by the OnlineIndexer* modules.", "originalCommit": "c531ce9049a4eb57f74dedd82c09efb3a15be757", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk1MzE2MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556953161", "bodyText": "Oops.", "author": "jjezra", "createdAt": "2021-01-13T23:52:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4MzI4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4NDQyNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556884426", "bodyText": "I've seen \"synthetic\" pop up a few times in this PR, but what is a synthetic index, or a synthetic record type?", "author": "ScottDugas", "createdAt": "2021-01-13T22:04:11Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingCommon.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * OnlineIndexerCommon.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.provider.foundationdb.synchronizedsession.SynchronizedSessionRunner;\n+import com.apple.foundationdb.record.query.plan.synthetic.SyntheticRecordFromStoredRecordPlan;\n+import com.apple.foundationdb.record.query.plan.synthetic.SyntheticRecordPlanner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+\n+/**\n+ * Shared structure to be used (only) by the OnlineIndexer* modules.\n+ */\n+@API(API.Status.INTERNAL)\n+public class IndexingCommon {\n+    private final UUID uuid = UUID.randomUUID();\n+\n+    @Nonnull private final FDBDatabaseRunner runner;\n+    @Nullable private SynchronizedSessionRunner synchronizedSessionRunner = null;\n+\n+    @Nonnull private final FDBRecordStore.Builder recordStoreBuilder;\n+    @Nonnull private final Index index;\n+    @Nonnull private final AtomicLong totalRecordsScanned;\n+\n+    private final boolean useSynchronizedSession;\n+    private final boolean syntheticIndex;\n+    private final boolean trackProgress;\n+    private final long leaseLengthMillis;\n+\n+\n+    @Nonnull private final OnlineIndexer.IndexStatePrecondition indexStatePrecondition;\n+    @Nonnull public OnlineIndexer.Config config; // this item may be modified on the fly\n+    @Nullable private final Function<OnlineIndexer.Config, OnlineIndexer.Config> configLoader;\n+    private int configLoaderInvocationCount = 0;\n+\n+    @Nonnull public Collection<RecordType> recordTypes;\n+\n+    /**\n+     * Constant indicating that there should be no limit to some usually limited operation.\n+     */\n+    public static final int UNLIMITED = Integer.MAX_VALUE;\n+\n+    IndexingCommon(@Nonnull FDBDatabaseRunner runner,\n+                   @Nonnull FDBRecordStore.Builder recordStoreBuilder,\n+                   @Nonnull Index index, @Nonnull Collection<RecordType> recordTypes,\n+                   @Nonnull Function<OnlineIndexer.Config, OnlineIndexer.Config> configLoader, @Nonnull OnlineIndexer.Config config,\n+                   boolean syntheticIndex,\n+                   @Nonnull OnlineIndexer.IndexStatePrecondition indexStatePrecondition,\n+                   boolean trackProgress,\n+                   boolean useSynchronizedSession,\n+                   long leaseLengthMillis ) {\n+        this.useSynchronizedSession = useSynchronizedSession;\n+        this.runner = runner;\n+        this.index = index;\n+        this.recordTypes = recordTypes;\n+        this.configLoader = configLoader;\n+        this.config = config;\n+        this.syntheticIndex = syntheticIndex;\n+        this.indexStatePrecondition = indexStatePrecondition;\n+        this.trackProgress = trackProgress;\n+        this.recordStoreBuilder = recordStoreBuilder;\n+        this.leaseLengthMillis = leaseLengthMillis;\n+\n+        this.totalRecordsScanned = new AtomicLong(0);\n+    }\n+\n+    public UUID getUuid() {\n+        return uuid;\n+    }\n+\n+    public boolean isUseSynchronizedSession() {\n+        return useSynchronizedSession;\n+    }\n+\n+    @Nonnull\n+    public FDBDatabaseRunner getRunner() {\n+        return synchronizedSessionRunner == null ? runner : synchronizedSessionRunner;\n+    }\n+\n+    @Nonnull\n+    public Index getIndex() {\n+        return index;\n+    }\n+\n+    public boolean isSyntheticIndex() {", "originalCommit": "c531ce9049a4eb57f74dedd82c09efb3a15be757", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkyOTU0NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556929545", "bodyText": "Yeah, they're indexes on synthetic record types (added to support join indexes; see: #306)", "author": "alecgrieser", "createdAt": "2021-01-13T22:49:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4NDQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4NDkwMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556884901", "bodyText": "Suggested change", "author": "ScottDugas", "createdAt": "2021-01-13T22:04:37Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingThrottle.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * OnlineIndexerThrottle.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.FDBError;\n+import com.apple.foundationdb.FDBException;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.MoreAsyncUtil;\n+import com.apple.foundationdb.record.IndexState;\n+import com.apple.foundationdb.record.RecordCoreStorageException;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.util.LoggableException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+/**\n+ * This class provides build/commit/retry with throttling to the OnlineIndexer. In the future,\n+ * this class can be generalized to serve other FDB modules.\n+ */\n+@API(API.Status.INTERNAL)\n+public class IndexingThrottle {\n+\n+    @Nonnull private static final Logger LOGGER = LoggerFactory.getLogger(IndexingThrottle.class);\n+    @Nonnull private final IndexingCommon common;\n+\n+    private int limit;\n+\n+    // These error codes represent a list of errors that can occur if there is too much work to be done\n+    // in a single transaction.\n+    private static final Set<Integer> lessenWorkCodes = new HashSet<>(Arrays.asList(\n+            FDBError.TIMED_OUT.code(),\n+            FDBError.TRANSACTION_TOO_OLD.code(),\n+            FDBError.NOT_COMMITTED.code(),\n+            FDBError.TRANSACTION_TIMED_OUT.code(),\n+            FDBError.COMMIT_READ_INCOMPLETE.code(),\n+            FDBError.TRANSACTION_TOO_LARGE.code()));\n+\n+    /**\n+     * The number of successful transactions in a row as called by {@link #runAsync(Function, BiFunction, BiConsumer, List)}.\n+     */\n+    private int successCount = 0;\n+\n+    IndexingThrottle(@Nonnull IndexingCommon common) {\n+", "originalCommit": "c531ce9049a4eb57f74dedd82c09efb3a15be757", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4NTA5MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556885091", "bodyText": "Suggested change", "author": "ScottDugas", "createdAt": "2021-01-13T22:04:49Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingThrottle.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * OnlineIndexerThrottle.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.FDBError;\n+import com.apple.foundationdb.FDBException;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.MoreAsyncUtil;\n+import com.apple.foundationdb.record.IndexState;\n+import com.apple.foundationdb.record.RecordCoreStorageException;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.util.LoggableException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+/**\n+ * This class provides build/commit/retry with throttling to the OnlineIndexer. In the future,\n+ * this class can be generalized to serve other FDB modules.\n+ */\n+@API(API.Status.INTERNAL)\n+public class IndexingThrottle {\n+\n+    @Nonnull private static final Logger LOGGER = LoggerFactory.getLogger(IndexingThrottle.class);\n+    @Nonnull private final IndexingCommon common;\n+\n+    private int limit;\n+\n+    // These error codes represent a list of errors that can occur if there is too much work to be done\n+    // in a single transaction.\n+    private static final Set<Integer> lessenWorkCodes = new HashSet<>(Arrays.asList(\n+            FDBError.TIMED_OUT.code(),\n+            FDBError.TRANSACTION_TOO_OLD.code(),\n+            FDBError.NOT_COMMITTED.code(),\n+            FDBError.TRANSACTION_TIMED_OUT.code(),\n+            FDBError.COMMIT_READ_INCOMPLETE.code(),\n+            FDBError.TRANSACTION_TOO_LARGE.code()));\n+\n+    /**\n+     * The number of successful transactions in a row as called by {@link #runAsync(Function, BiFunction, BiConsumer, List)}.\n+     */\n+    private int successCount = 0;\n+\n+    IndexingThrottle(@Nonnull IndexingCommon common) {\n+\n+        this.common = common;\n+        this.limit = common.config.getMaxLimit();\n+    }\n+\n+    public <R> CompletableFuture<R> buildAsync(@Nonnull BiFunction<FDBRecordStore, AtomicLong, CompletableFuture<R>> buildFunction,\n+                                        boolean limitControl,\n+                                        @Nullable List<Object> additionalLogMessageKeyValues) {\n+", "originalCommit": "c531ce9049a4eb57f74dedd82c09efb3a15be757", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4NzIwMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556887201", "bodyText": "I'm assuming this was just copied from somewhere else, but this is a pretty complicated method... no concrete suggestions, and not necessarily arguing it should be cleaned up now.", "author": "ScottDugas", "createdAt": "2021-01-13T22:06:53Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingThrottle.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * OnlineIndexerThrottle.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.FDBError;\n+import com.apple.foundationdb.FDBException;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.MoreAsyncUtil;\n+import com.apple.foundationdb.record.IndexState;\n+import com.apple.foundationdb.record.RecordCoreStorageException;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.util.LoggableException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+/**\n+ * This class provides build/commit/retry with throttling to the OnlineIndexer. In the future,\n+ * this class can be generalized to serve other FDB modules.\n+ */\n+@API(API.Status.INTERNAL)\n+public class IndexingThrottle {\n+\n+    @Nonnull private static final Logger LOGGER = LoggerFactory.getLogger(IndexingThrottle.class);\n+    @Nonnull private final IndexingCommon common;\n+\n+    private int limit;\n+\n+    // These error codes represent a list of errors that can occur if there is too much work to be done\n+    // in a single transaction.\n+    private static final Set<Integer> lessenWorkCodes = new HashSet<>(Arrays.asList(\n+            FDBError.TIMED_OUT.code(),\n+            FDBError.TRANSACTION_TOO_OLD.code(),\n+            FDBError.NOT_COMMITTED.code(),\n+            FDBError.TRANSACTION_TIMED_OUT.code(),\n+            FDBError.COMMIT_READ_INCOMPLETE.code(),\n+            FDBError.TRANSACTION_TOO_LARGE.code()));\n+\n+    /**\n+     * The number of successful transactions in a row as called by {@link #runAsync(Function, BiFunction, BiConsumer, List)}.\n+     */\n+    private int successCount = 0;\n+\n+    IndexingThrottle(@Nonnull IndexingCommon common) {\n+\n+        this.common = common;\n+        this.limit = common.config.getMaxLimit();\n+    }\n+\n+    public <R> CompletableFuture<R> buildAsync(@Nonnull BiFunction<FDBRecordStore, AtomicLong, CompletableFuture<R>> buildFunction,\n+                                        boolean limitControl,\n+                                        @Nullable List<Object> additionalLogMessageKeyValues) {\n+\n+        AtomicLong recordsScanned = new AtomicLong(0);\n+        return runAsync(store -> buildFunction.apply(store, recordsScanned),\n+                // Run after a single transactional call within runAsync.\n+                (result, exception) -> {\n+                    if (limitControl) {\n+                        tryToIncreaseLimit(exception);\n+                    }\n+                    // Update records scanned.\n+                    if (exception == null) {\n+                        common.getTotalRecordsScanned().addAndGet(recordsScanned.get());\n+                    } else {\n+                        recordsScanned.set(0);\n+                    }\n+                    return Pair.of(result, exception);\n+                },\n+                limitControl ? this::decreaseLimit : null,\n+                additionalLogMessageKeyValues\n+        );\n+    }\n+\n+    private synchronized void loadConfig() {\n+        if (common.loadConfig()) {\n+            final int maxLimit = common.config.getMaxLimit();\n+            if (limit > maxLimit) {\n+                if (LOGGER.isInfoEnabled()) {\n+                    LOGGER.info(\n+                            KeyValueLogMessage.build(\"Decreasing the limit to the new maxLimit.\",\n+                                    LogMessageKeys.INDEX_NAME, common.getIndex().getName(),\n+                                    LogMessageKeys.LIMIT, limit,\n+                                    LogMessageKeys.MAX_LIMIT, maxLimit).toString());\n+                }\n+                limit = maxLimit;\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    void decreaseLimit(@Nonnull FDBException fdbException,\n+                       @Nullable List<Object> additionalLogMessageKeyValues) {\n+        limit = Math.max(1, (3 * limit) / 4);\n+        if (LOGGER.isInfoEnabled()) {\n+            final KeyValueLogMessage message = KeyValueLogMessage.build(\"Lessening limit of online index build\",\n+                    LogMessageKeys.ERROR, fdbException.getMessage(),\n+                    LogMessageKeys.ERROR_CODE, fdbException.getCode(),\n+                    LogMessageKeys.LIMIT, limit,\n+                    LogMessageKeys.INDEX_NAME, common.getIndex().getName(),\n+                    LogMessageKeys.INDEXER_ID, common.getUuid()\n+                    );\n+            if (additionalLogMessageKeyValues != null) {\n+                message.addKeysAndValues(additionalLogMessageKeyValues);\n+            }\n+            LOGGER.info(message.toString(), fdbException);\n+        }\n+    }\n+\n+    private void tryToIncreaseLimit(@Nullable Throwable exception) {\n+        final int increaseLimitAfter = common.config.getIncreaseLimitAfter();\n+        final int maxLimit = common.config.getMaxLimit();\n+        if (increaseLimitAfter > 0) {\n+            if (exception == null) {\n+                successCount++;\n+                if (successCount >= increaseLimitAfter && limit < maxLimit) {\n+                    increaseLimit();\n+                }\n+            } else {\n+                successCount = 0;\n+            }\n+        }\n+    }\n+\n+    private void increaseLimit() {\n+        final int maxLimit = common.config.getMaxLimit();\n+        limit = Math.min(maxLimit, Math.max(limit + 1, (4 * limit) / 3));\n+        if (LOGGER.isInfoEnabled()) {\n+            LOGGER.info(KeyValueLogMessage.of(\"Re-increasing limit of online index build\",\n+                    LogMessageKeys.INDEX_NAME, common.getIndex().getName(),\n+                    LogMessageKeys.INDEXER_ID, common.getUuid(),\n+                    LogMessageKeys.LIMIT, limit));\n+        }\n+    }\n+\n+    // Finds the FDBException that ultimately caused some throwable or\n+    // null if there is none. This can be then used to determine, for\n+    // example, the error code associated with this FDBException.\n+    @Nullable\n+    private FDBException getFDBException(@Nullable Throwable e) {\n+        Throwable curr = e;\n+        while (curr != null) {\n+            if (curr instanceof FDBException) {\n+                return (FDBException)curr;\n+            } else {\n+                curr = curr.getCause();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Nonnull\n+    <R> CompletableFuture<R> runAsync(@Nonnull final Function<FDBRecordStore, CompletableFuture<R>> function,", "originalCommit": "c531ce9049a4eb57f74dedd82c09efb3a15be757", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4ODE4MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556888181", "bodyText": "The\"scanner\" wording could be confusing now, perhaps replacing \"scanner\" with \"underlying\" would be helpful. I'm not sure though.", "author": "ScottDugas", "createdAt": "2021-01-13T22:07:51Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -223,23 +149,73 @@\n                   @Nonnull IndexStatePrecondition indexStatePrecondition,\n                   boolean useSynchronizedSession,\n                   long leaseLengthMillis,\n-                  boolean trackProgress) {\n+                  boolean trackProgress,\n+                  @Nonnull IndexFromIndexPolicy indexFromIndex) {\n         this.runner = runner;\n-        this.recordStoreBuilder = recordStoreBuilder;\n         this.index = index;\n-        this.recordTypes = recordTypes;\n-        this.configLoader = configLoader;\n-        this.config = config;\n-        this.limit = config.maxLimit;\n-        this.syntheticIndex = syntheticIndex;\n-        this.indexStatePrecondition = indexStatePrecondition;\n-        this.useSynchronizedSession = useSynchronizedSession;\n-        this.leaseLengthMills = leaseLengthMillis;\n-        this.trackProgress = trackProgress;\n-\n-        this.recordsRange = computeRecordsRange();\n-        timeOfLastProgressLogMillis = System.currentTimeMillis();\n-        totalRecordsScanned = new AtomicLong(0);\n+        this.indexFromIndexPolicy = indexFromIndex;\n+\n+        this.common = new IndexingCommon(runner, recordStoreBuilder,\n+                index, recordTypes, configLoader, config,\n+                syntheticIndex,\n+                indexStatePrecondition,\n+                trackProgress,\n+                useSynchronizedSession,\n+                leaseLengthMillis\n+            );\n+    }\n+\n+    @Nonnull\n+    private IndexingByIndex getScannerByIndex() {", "originalCommit": "c531ce9049a4eb57f74dedd82c09efb3a15be757", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk1ODI0MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556958240", "bodyText": "I was looking for something that will describe the processes of scanning the records (this way or another) and indexing them. \"underlying\" doesn't seem descriptive enough (unless it has a sub meaning that I - as a non native English speaker - am missing). Would replacing \"scanner\" with \"compiler\" be too confusing?", "author": "jjezra", "createdAt": "2021-01-14T00:07:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4ODE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzQ5NTk4Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r557495986", "bodyText": "How about indexer?\ngetIndexer()\ngetIndexerByRecord()\ngetIndexerByIndex()\nIs that less confusing?", "author": "jjezra", "createdAt": "2021-01-14T15:49:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4ODE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU2MDIzMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r557560233", "bodyText": "I think Indexer is less confusing, I suppose", "author": "alecgrieser", "createdAt": "2021-01-14T17:17:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4ODE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg5MTE0Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556891146", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Let tgtIndex be a non-idempotent index\n          \n          \n            \n                    // Let target index be a non-idempotent index", "author": "ScottDugas", "createdAt": "2021-01-13T22:10:33Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerIndexFromIndexTest.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/*\n+ * OnlineIndexerIndexFromIndexTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.record.TestRecords1Proto;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexOptions;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.expressions.EmptyKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+\n+import static com.apple.foundationdb.record.metadata.Key.Expressions.field;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests for building indexes from other indexes with {@link OnlineIndexer}.\n+ */\n+\n+public class OnlineIndexerIndexFromIndexTest extends OnlineIndexerTest {\n+\n+    private void populateData(final long numRecords) {\n+        List<TestRecords1Proto.MySimpleRecord> records = LongStream.range(0, numRecords).mapToObj(val ->\n+                TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).build()\n+        ).collect(Collectors.toList());\n+\n+        try (FDBRecordContext context = openContext())  {\n+            records.forEach(recordStore::saveRecord);\n+            context.commit();\n+        }\n+    }\n+\n+    private FDBRecordStoreTestBase.RecordMetaDataHook myHook(Index srcIndex, Index tgtIndex) {\n+        return metaDataBuilder -> {\n+            metaDataBuilder.addIndex(\"MySimpleRecord\", srcIndex);\n+            metaDataBuilder.addIndex(\"MySimpleRecord\", tgtIndex);\n+        } ;\n+    }\n+\n+    private void buildSrcIndex(Index srcIndex) {\n+        try (OnlineIndexer indexer = OnlineIndexer.newBuilder()\n+                .setDatabase(fdb).setMetaData(metaData).setIndex(srcIndex).setSubspace(subspace)\n+                .build()) {\n+            indexer.buildIndex(true);\n+        }\n+    }\n+\n+    @Test\n+    public void testIndexFromIndexSimple() {\n+\n+        final FDBStoreTimer timer = new FDBStoreTimer();\n+        final long numRecords = 1000;\n+\n+        Index srcIndex = new Index(\"src_index\", field(\"num_value_2\"), EmptyKeyExpression.EMPTY, IndexTypes.VALUE, IndexOptions.UNIQUE_OPTIONS);\n+        Index tgtIndex = new Index(\"tgt_index\", field(\"num_value_3_indexed\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = myHook(srcIndex, tgtIndex);\n+\n+        openSimpleMetaData();\n+        populateData(numRecords);\n+\n+        openSimpleMetaData(hook);\n+        buildSrcIndex(srcIndex);\n+\n+        openSimpleMetaData(hook);\n+        try (OnlineIndexer indexBuilder = OnlineIndexer.newBuilder()\n+                .setDatabase(fdb).setMetaData(metaData).setIndex(tgtIndex).setSubspace(subspace)\n+                .setIndexFromIndex(OnlineIndexer.IndexFromIndexPolicy.newBuilder()\n+                        .setSourceIndex(\"src_index\")\n+                        .forbidRecordScan()\n+                        .build())\n+                .setTimer(timer)\n+                .build()) {\n+\n+            indexBuilder.buildIndex(true);\n+        }\n+        assertEquals(numRecords, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED));\n+        assertEquals(numRecords, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED));\n+    }\n+\n+    @Test\n+    public void testIndexFromIndexContinuation() {\n+\n+        final FDBStoreTimer timer = new FDBStoreTimer();\n+        final int numRecords = 1327;\n+        final int chunkSize  = 42;\n+        final int numChunks  = 1 + (numRecords / chunkSize);\n+\n+        Index srcIndex = new Index(\"src_index\", field(\"num_value_2\"), EmptyKeyExpression.EMPTY, IndexTypes.VALUE, IndexOptions.UNIQUE_OPTIONS);\n+        Index tgtIndex = new Index(\"tgt_index\", field(\"num_value_3_indexed\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = myHook(srcIndex, tgtIndex);\n+\n+        openSimpleMetaData();\n+        populateData(numRecords);\n+\n+        openSimpleMetaData(hook);\n+        buildSrcIndex(srcIndex);\n+\n+        openSimpleMetaData(hook);\n+        try (OnlineIndexer indexBuilder = OnlineIndexer.newBuilder()\n+                .setDatabase(fdb).setMetaData(metaData).setIndex(tgtIndex).setSubspace(subspace)\n+                .setIndexFromIndex(OnlineIndexer.IndexFromIndexPolicy.newBuilder()\n+                        .setSourceIndex(\"src_index\")\n+                        .forbidRecordScan()\n+                        .build())\n+                .setLimit(chunkSize)\n+                .setTimer(timer)\n+                .build()) {\n+\n+            indexBuilder.buildIndex(true);\n+        }\n+        assertEquals(numRecords, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED));\n+        assertEquals(numRecords, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED));\n+        assertEquals(numChunks , timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGES_BY_COUNT));\n+    }\n+\n+    @Test\n+    public void testIndexFromIndexFallback() {\n+        // Let tgtIndex be a non-idempotent index\n+\n+        final FDBStoreTimer timer = new FDBStoreTimer();\n+        final long numRecords = 6;\n+\n+        Index srcIndex = new Index(\"src_index\", field(\"num_value_2\"), EmptyKeyExpression.EMPTY, IndexTypes.VALUE, IndexOptions.UNIQUE_OPTIONS);\n+        Index tgtIndex = new Index(\"tgt_index\", field(\"num_value_3_indexed\").ungrouped(), IndexTypes.SUM);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = myHook(srcIndex, tgtIndex);\n+\n+        openSimpleMetaData();\n+        populateData(numRecords);\n+\n+        openSimpleMetaData(hook);\n+        buildSrcIndex(srcIndex);\n+\n+        openSimpleMetaData(hook);\n+        try (OnlineIndexer indexBuilder = OnlineIndexer.newBuilder()\n+                .setDatabase(fdb).setMetaData(metaData).setIndex(tgtIndex).setSubspace(subspace)\n+                .setIndexFromIndex(OnlineIndexer.IndexFromIndexPolicy.newBuilder()\n+                        .setSourceIndex(\"src_index\")\n+                        .build())\n+                .setTimer(timer)\n+                .build()) {\n+\n+            indexBuilder.buildIndex(true);\n+        }\n+        assertEquals(numRecords, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED));\n+        assertEquals(numRecords, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED));\n+    }\n+\n+    @Test\n+    public void testIndexFromIndexNoFallback() {\n+        // Let tgtIndex be a non-idempotent index", "originalCommit": "c531ce9049a4eb57f74dedd82c09efb3a15be757", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3Nzg5MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556877891", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n      \n    \n    \n  \n\nObviously, a harmless change, but suggesting just so that we can keep the change set clean on this file", "author": "alecgrieser", "createdAt": "2021-01-13T21:58:24Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordStore.java", "diffHunk": "@@ -353,6 +353,7 @@ public RecordStoreState getRecordStoreState() {\n             context.asyncToSync(FDBStoreTimer.Waits.WAIT_LOAD_RECORD_STORE_STATE,\n                     preloadRecordStoreStateAsync(StoreExistenceCheck.NONE, IsolationLevel.SERIALIZABLE, IsolationLevel.SNAPSHOT));\n         }\n+", "originalCommit": "c531ce9049a4eb57f74dedd82c09efb3a15be757", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg5MjMyMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556892321", "bodyText": "minor: IndexingState might be a better name, to encapsulate that this is to be used to encapsulate shared state that is used by the indexers", "author": "alecgrieser", "createdAt": "2021-01-13T22:11:38Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingCommon.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * OnlineIndexerCommon.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.provider.foundationdb.synchronizedsession.SynchronizedSessionRunner;\n+import com.apple.foundationdb.record.query.plan.synthetic.SyntheticRecordFromStoredRecordPlan;\n+import com.apple.foundationdb.record.query.plan.synthetic.SyntheticRecordPlanner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+\n+/**\n+ * Shared structure to be used (only) by the OnlineIndexer* modules.\n+ */\n+@API(API.Status.INTERNAL)\n+public class IndexingCommon {", "originalCommit": "c531ce9049a4eb57f74dedd82c09efb3a15be757", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk2NTQyMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556965421", "bodyText": "Wouldn't it be confused with enum IndexState?", "author": "jjezra", "createdAt": "2021-01-14T00:27:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg5MjMyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODY2OTU5MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r558669591", "bodyText": "I would hope IndexingState vs IndexState would be easy enough to distinguish, but perhaps you're right...\nI feel more confident in State as a suffix than Common (and as an abstraction), which I don't think we really use, but this shouldn't block merging the PR, I suppose.", "author": "alecgrieser", "createdAt": "2021-01-15T23:37:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg5MjMyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE2MjIxNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r561162217", "bodyText": "I agree IndexingState will be a good name. But whatever name to be used, the JavaDoc could explain the intention of this object in more depth.", "author": "nblintao", "createdAt": "2021-01-20T17:55:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg5MjMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg5NDgxNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556894816", "bodyText": "Suggested change", "author": "alecgrieser", "createdAt": "2021-01-13T22:14:01Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingThrottle.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * OnlineIndexerThrottle.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.FDBError;\n+import com.apple.foundationdb.FDBException;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.MoreAsyncUtil;\n+import com.apple.foundationdb.record.IndexState;\n+import com.apple.foundationdb.record.RecordCoreStorageException;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.util.LoggableException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+/**\n+ * This class provides build/commit/retry with throttling to the OnlineIndexer. In the future,\n+ * this class can be generalized to serve other FDB modules.\n+ */\n+@API(API.Status.INTERNAL)\n+public class IndexingThrottle {\n+\n+    @Nonnull private static final Logger LOGGER = LoggerFactory.getLogger(IndexingThrottle.class);\n+    @Nonnull private final IndexingCommon common;\n+\n+    private int limit;\n+\n+    // These error codes represent a list of errors that can occur if there is too much work to be done\n+    // in a single transaction.\n+    private static final Set<Integer> lessenWorkCodes = new HashSet<>(Arrays.asList(\n+            FDBError.TIMED_OUT.code(),\n+            FDBError.TRANSACTION_TOO_OLD.code(),\n+            FDBError.NOT_COMMITTED.code(),\n+            FDBError.TRANSACTION_TIMED_OUT.code(),\n+            FDBError.COMMIT_READ_INCOMPLETE.code(),\n+            FDBError.TRANSACTION_TOO_LARGE.code()));\n+\n+    /**\n+     * The number of successful transactions in a row as called by {@link #runAsync(Function, BiFunction, BiConsumer, List)}.\n+     */\n+    private int successCount = 0;\n+\n+    IndexingThrottle(@Nonnull IndexingCommon common) {\n+", "originalCommit": "c531ce9049a4eb57f74dedd82c09efb3a15be757", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkxMTE5Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556911192", "bodyText": "Do these two castCursor methods (and the ones in the other file) still need to take a RecordCursorResult<?> as their argument, or can they take something better (like an FDBIndexedRecord<Message> in this class or an FDBStoredRecord<Message> in the other class) now that the signature on iterateRangeOnly has better generics?\n(Improving the type safety of these methods was one of the reasons I suggested that change)", "author": "alecgrieser", "createdAt": "2021-01-13T22:29:18Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingByIndex.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * OnlineIndexerByIndex.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.MutationType;\n+import com.apple.foundationdb.TransactionContext;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.RangeSet;\n+import com.apple.foundationdb.record.ExecuteProperties;\n+import com.apple.foundationdb.record.IndexScanType;\n+import com.apple.foundationdb.record.IsolationLevel;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorResult;\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.RecordMetaDataProvider;\n+import com.apple.foundationdb.record.ScanProperties;\n+import com.apple.foundationdb.record.TupleRange;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.MetaDataException;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.ByteArrayUtil2;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.google.protobuf.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * This indexer scans records by a source index.\n+ */\n+@API(API.Status.INTERNAL)\n+public class IndexingByIndex extends IndexingBase {\n+    @Nonnull private static final Logger LOGGER = LoggerFactory.getLogger(IndexingByIndex.class);\n+    @Nonnull private final OnlineIndexer.IndexFromIndexPolicy policy;\n+\n+    IndexingByIndex(@Nonnull IndexingCommon common,\n+                    @Nonnull OnlineIndexer.IndexFromIndexPolicy policy) {\n+        super(common);\n+        this.policy = policy;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    CompletableFuture<Void> scanBuildIndexAsync() {\n+        return getRunner().runAsync(context -> openRecordStore(context)\n+                .thenCompose( store -> {\n+                    // first validate that both src and tgt are of a single, similar, type\n+                    final RecordMetaData metaData = store.getRecordMetaData();\n+                    final Index srcIndex = metaData.getIndex(Objects.requireNonNull(policy.getSourceIndex()));\n+                    final Collection<RecordType> srcRecordTypes = metaData.recordTypesForIndex(srcIndex);\n+\n+                    validateOrThrowEx(!common.isSyntheticIndex(), \"target index is synthetic\");\n+                    validateOrThrowEx(common.recordTypes.size() == 1, \"target index has multiple types\");\n+                    validateOrThrowEx(srcRecordTypes.size() == 1, \"source index has multiple types\");\n+                    validateOrThrowEx(!srcIndex.getRootExpression().createsDuplicates(), \"source index creates duplicates\");\n+                    validateOrThrowEx(srcIndex.getType().equals(IndexTypes.VALUE), \"source index is not a VALUE index\");\n+                    validateOrThrowEx(common.recordTypes.equals(srcRecordTypes), \"source index's type is not equal to target index's\");\n+\n+                    // all valid; back to the future. Note that for practical reasons, readability and idempotency will be validated later\n+                    return context.getReadVersionAsync()\n+                            .thenCompose(vignore -> {\n+                                SubspaceProvider subspaceProvider = common.getRecordStoreBuilder().getSubspaceProvider();\n+                                return subspaceProvider.getSubspaceAsync(context)\n+                                        .thenCompose(subspace ->\n+                                                buildIndexFromIndex(subspaceProvider, subspace)\n+                                                        .thenCompose(vignore2 -> markBuilt(subspace)\n+                                                        ));\n+                            });\n+                }));\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> markBuilt(Subspace subspace) {\n+        // Grand Finale - after fully building the index, remove all missing ranges in one gulp\n+        return getRunner().runAsync(context -> {\n+            final Index index = common.getIndex();\n+            RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, index.getSubspaceKey())));\n+            TransactionContext tc = context.ensureActive();\n+            return rangeSet.insertRange(tc, null, null).thenApply(bignore -> null);\n+        });\n+    }\n+\n+    private void maybeLogBuildProgress(SubspaceProvider subspaceProvider, byte[] retCont) {\n+        if (LOGGER.isInfoEnabled() && shouldLogBuildProgress()) {\n+            final Index index = common.getIndex();\n+            LOGGER.info(KeyValueLogMessage.of(\"Built Range\",\n+                    LogMessageKeys.INDEX_NAME, index.getName(),\n+                    LogMessageKeys.INDEX_VERSION, index.getLastModifiedVersion(),\n+                    subspaceProvider.logKey(), subspaceProvider,\n+                    LogMessageKeys.NEXT_CONTINUATION, retCont,\n+                    LogMessageKeys.RECORDS_SCANNED, common.getTotalRecordsScanned().get()),\n+                    LogMessageKeys.INDEXER_ID, common.getUuid());\n+        }\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildIndexFromIndex(SubspaceProvider subspaceProvider, @Nonnull Subspace subspace) {\n+        AtomicReference<byte[]> nextCont = new AtomicReference<>();\n+\n+        return AsyncUtil.whileTrue(() -> {\n+            byte [] cont = nextCont.get();\n+            final List<Object> additionalLogMessageKeyValues = Arrays.asList(LogMessageKeys.CALLING_METHOD, \"buildIndexFromIndex\",\n+                    LogMessageKeys.NEXT_CONTINUATION, cont == null ? \"\" : cont);\n+\n+            // apparently, buildAsync=buildAndCommitWithRetry\n+            return buildAsync( (store, recordsScanned) -> buildRangeOnly(store, cont, recordsScanned),\n+                    true,\n+                    additionalLogMessageKeyValues)\n+                    .handle((retCont, ex) -> {\n+                        if (ex == null) {\n+                            maybeLogBuildProgress(subspaceProvider, retCont);\n+                            if (retCont == null) {\n+                                return AsyncUtil.READY_FALSE;\n+                            }\n+                            nextCont.set(retCont); // continuation\n+                            return throttleDelay();\n+                        }\n+                        final RuntimeException unwrappedEx = getRunner().getDatabase().mapAsyncToSyncException(ex);\n+                        if (LOGGER.isInfoEnabled()) {\n+                            LOGGER.info(KeyValueLogMessage.of(\"possibly non-fatal error encountered building range\",\n+                                    LogMessageKeys.NEXT_CONTINUATION, nextCont,\n+                                    LogMessageKeys.SUBSPACE, ByteArrayUtil2.loggable(subspace.pack())), ex);\n+                        }\n+                        throw unwrappedEx;\n+                    })\n+                    .thenCompose(Function.identity());\n+        }, getRunner().getExecutor());\n+    }\n+\n+    @Nonnull\n+    @SuppressWarnings(\"unchecked\")\n+    private static RecordCursorResult<FDBIndexedRecord<Message>> castCursorResult(@Nonnull RecordCursorResult<?> result) {\n+        // helper function\n+        return (RecordCursorResult<FDBIndexedRecord<Message>>)result;\n+    }\n+\n+    @Nullable\n+    private static FDBStoredRecord<Message> castCursorResultToStoreRecord(@Nonnull RecordCursorResult<?> result) {", "originalCommit": "c531ce9049a4eb57f74dedd82c09efb3a15be757", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk2NzU2Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556967567", "bodyText": "++", "author": "jjezra", "createdAt": "2021-01-14T00:34:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkxMTE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkyMDQ0OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r556920449", "bodyText": "Shouldn't be a MetaDataException", "author": "alecgrieser", "createdAt": "2021-01-13T22:38:25Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingByRecords.java", "diffHunk": "@@ -0,0 +1,677 @@\n+/*\n+ * OnlineIndexerByRecords.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.MutationType;\n+import com.apple.foundationdb.Range;\n+import com.apple.foundationdb.ReadTransactionContext;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncIterator;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.RangeSet;\n+import com.apple.foundationdb.record.EndpointType;\n+import com.apple.foundationdb.record.ExecuteProperties;\n+import com.apple.foundationdb.record.IsolationLevel;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorResult;\n+import com.apple.foundationdb.record.ScanProperties;\n+import com.apple.foundationdb.record.TupleRange;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.MetaDataException;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.ByteArrayUtil2;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.Message;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ *  This indexer scans all records in the record store.\n+ */\n+@API(API.Status.INTERNAL)\n+public class IndexingByRecords extends IndexingBase {\n+    @Nonnull private static final Logger LOGGER = LoggerFactory.getLogger(IndexingByRecords.class);\n+\n+    @Nonnull private final TupleRange recordsRange;\n+    @Nonnull private static final byte[] START_BYTES = new byte[]{0x00};\n+    @Nonnull private static final byte[] END_BYTES = new byte[]{(byte)0xff};\n+\n+\n+    IndexingByRecords(@Nonnull IndexingCommon common) {\n+        super(common);\n+        this.recordsRange = computeRecordsRange();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    CompletableFuture<Void> scanBuildIndexAsync() {\n+        return buildEndpoints().thenCompose(tupleRange -> {\n+            if (tupleRange != null) {\n+                return buildRange(Key.Evaluated.fromTuple(tupleRange.getLow()), Key.Evaluated.fromTuple(tupleRange.getHigh()));\n+            } else {\n+                return CompletableFuture.completedFuture(null);\n+            }\n+        });\n+    }\n+\n+    private void maybeLogBuildProgress(SubspaceProvider subspaceProvider, Tuple startTuple, Tuple endTuple, Tuple realEnd) {\n+        if (LOGGER.isInfoEnabled() && shouldLogBuildProgress()) {\n+            LOGGER.info(KeyValueLogMessage.of(\"Built Range\",\n+                    LogMessageKeys.INDEX_NAME, common.getIndex().getName(),\n+                    LogMessageKeys.INDEX_VERSION, common.getIndex().getLastModifiedVersion(),\n+                    subspaceProvider.logKey(), subspaceProvider,\n+                    LogMessageKeys.START_TUPLE, startTuple,\n+                    LogMessageKeys.END_TUPLE, endTuple,\n+                    LogMessageKeys.REAL_END, realEnd,\n+                    LogMessageKeys.RECORDS_SCANNED, common.getTotalRecordsScanned().get()),\n+                    LogMessageKeys.INDEXER_ID, common.getUuid());\n+        }\n+    }\n+\n+    @Nonnull\n+    private TupleRange computeRecordsRange() {\n+        Tuple low = null;\n+        Tuple high = null;\n+        for (RecordType recordType : common.recordTypes) {\n+            if (!recordType.primaryKeyHasRecordTypePrefix() || recordType.isSynthetic()) {\n+                // If any of the types to build for does not have a prefix, give up.\n+                return TupleRange.ALL;\n+            }\n+            Tuple prefix = recordType.getRecordTypeKeyTuple();\n+            if (low == null) {\n+                low = high = prefix;\n+            } else {\n+                if (low.compareTo(prefix) > 0) {\n+                    low = prefix;\n+                }\n+                if (high.compareTo(prefix) < 0) {\n+                    high = prefix;\n+                }\n+            }\n+        }\n+        if (low == null) {\n+            return TupleRange.ALL;\n+        } else {\n+            // Both ends inclusive.\n+            return new TupleRange(low, high, EndpointType.RANGE_INCLUSIVE, EndpointType.RANGE_INCLUSIVE);\n+        }\n+    }\n+\n+    /**\n+     * Builds (transactionally) the endpoints of an index. What this means is that builds everything from the beginning of\n+     * the key space to the first record and everything from the last record to the end of the key space.\n+     * There won't be any records within these ranges (except for the last record of the record store), but\n+     * it does mean that any records in the future that get added to these ranges will correctly update\n+     * the index. This means, e.g., that if the workload primarily adds records to the record store\n+     * after the current last record (because perhaps the primary key is based off of an atomic counter\n+     * or the current time), running this method will be highly contentious, but once it completes,\n+     * the rest of the index build should happen without any more conflicts.\n+     *\n+     * This will return a (possibly null) {@link TupleRange} that contains the primary keys of the\n+     * first and last records within the record store. This can then be used to either build the\n+     * range right away or to then divy-up the remaining ranges between multiple agents working\n+     * in parallel if one desires.\n+     *\n+     * @param store the record store in which to rebuild the index\n+     * @param recordsScanned continues counter\n+     * @return a future that will contain the range of records in the interior of the record store\n+     */\n+\n+    @Nonnull\n+    public CompletableFuture<TupleRange> buildEndpoints(@Nonnull FDBRecordStore store,\n+                                                        @Nullable AtomicLong recordsScanned) {\n+        final RangeSet rangeSet = new RangeSet(store.indexRangeSubspace(common.getIndex()));\n+        if (TupleRange.ALL.equals(recordsRange)) {\n+            return buildEndpoints(store, rangeSet, recordsScanned);\n+        }\n+        // If records do not occupy whole range, first mark outside as built.\n+        final Range asRange = recordsRange.toRange();\n+        return CompletableFuture.allOf(\n+                rangeSet.insertRange(store.ensureContextActive(), null, asRange.begin),\n+                rangeSet.insertRange(store.ensureContextActive(), asRange.end, null))\n+                .thenCompose(vignore -> buildEndpoints(store, rangeSet, recordsScanned));\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<TupleRange> buildEndpoints(@Nonnull FDBRecordStore store, @Nonnull RangeSet rangeSet,\n+                                                         @Nullable AtomicLong recordsScanned) {\n+        boolean isIdempotent = store.getIndexMaintainer(common.getIndex()).isIdempotent();\n+        final IsolationLevel isolationLevel =\n+                isIdempotent ?\n+                // If idempotent: since double indexing is harmless, we can use individual records protection instead of\n+                // a range conflict one - which means that new records, added to the range while indexing the SNAPSHOT,\n+                // will not cause a conflict during the commit. At worse, few records (if added after marking WRITE_ONLY but\n+                // before this method's query) will be re-indexed.\n+                IsolationLevel.SNAPSHOT :\n+                IsolationLevel.SERIALIZABLE;\n+        final ExecuteProperties limit1 = ExecuteProperties.newBuilder()\n+                .setReturnedRowLimit(1)\n+                .setIsolationLevel(isolationLevel)\n+                .build();\n+        final ScanProperties forward = new ScanProperties(limit1);\n+\n+        RecordCursor<FDBStoredRecord<Message>> beginCursor = store.scanRecords(recordsRange, null, forward);\n+        CompletableFuture<Tuple> begin = beginCursor.onNext().thenCompose(result -> {\n+            if (result.hasNext()) {\n+                Tuple firstTuple = result.get().getPrimaryKey();\n+                return buildRange(store, null, firstTuple, recordsScanned).thenApply(vignore -> firstTuple);\n+            } else {\n+                // Empty range -- add the whole thing.\n+                return rangeSet.insertRange(store.ensureContextActive(), null, null).thenApply(bignore -> null);\n+            }\n+        });\n+\n+        final ScanProperties backward = new ScanProperties(limit1, true);\n+        RecordCursor<FDBStoredRecord<Message>> endCursor = store.scanRecords(recordsRange, null, backward);\n+        CompletableFuture<Tuple> end = endCursor.onNext().thenCompose(result -> {\n+            if (result.hasNext()) {\n+                Tuple lastTuple = result.get().getPrimaryKey();\n+                return buildRange(store, lastTuple, null, recordsScanned).thenApply(vignore -> lastTuple);\n+            } else {\n+                // As the range is empty, the whole range needs to be added, but that is accomplished\n+                // by the above future, so this has nothing to do.\n+                return CompletableFuture.completedFuture(null);\n+            }\n+        });\n+\n+        return begin.thenCombine(end, (firstTuple, lastTuple) -> {\n+            if (firstTuple == null || firstTuple.equals(lastTuple)) {\n+                return null;\n+            } else {\n+                return new TupleRange(firstTuple, lastTuple, EndpointType.RANGE_INCLUSIVE, EndpointType.RANGE_EXCLUSIVE);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Builds (with a retry loop) the endpoints of an index. See the\n+     * {@link #buildEndpoints(FDBRecordStore, AtomicLong) buildEndpoints()} method that takes\n+     * an {@link FDBRecordStore} as its parameter for more details. This will retry on that function\n+     * until it gets a non-exceptional result and return the results back.\n+     *\n+     * @return a future that will contain the range of records in the interior of the record store\n+     */\n+    @Nonnull\n+    public CompletableFuture<TupleRange> buildEndpoints() {\n+        final List<Object> additionalLogMessageKeyValues = Arrays.asList(LogMessageKeys.CALLING_METHOD, \"buildEndpoints\");\n+        return buildAsync(this::buildEndpoints, false, additionalLogMessageKeyValues);\n+    }\n+\n+    // Turn a (possibly null) key into its tuple representation.\n+    @Nullable\n+    private Tuple convertOrNull(@Nullable Key.Evaluated key) {\n+        return (key == null) ? null : key.toTuple();\n+    }\n+\n+    // Turn a (possibly null) tuple into a (possibly null) byte array.\n+    @Nullable\n+    private byte[] packOrNull(@Nullable Tuple tuple) {\n+        return (tuple == null) ? null : tuple.pack();\n+    }\n+\n+    // Builds a range within a single transaction. It will look for the missing ranges within the given range and build those while\n+    // updating the range set.\n+    @Nonnull\n+    private CompletableFuture<Void> buildRange(@Nonnull FDBRecordStore store, @Nullable Tuple start, @Nullable Tuple end,\n+                                               @Nullable AtomicLong recordsScanned) {\n+        RangeSet rangeSet = new RangeSet(store.indexRangeSubspace(common.getIndex()));\n+        AsyncIterator<Range> ranges = rangeSet.missingRanges(store.ensureContextActive(), packOrNull(start), packOrNull(end)).iterator();\n+        return ranges.onHasNext().thenCompose(hasAny -> {\n+            if (hasAny) {\n+                return AsyncUtil.whileTrue(() -> {\n+                    Range range = ranges.next();\n+                    Tuple rangeStart = Arrays.equals(range.begin, START_BYTES) ? null : Tuple.fromBytes(range.begin);\n+                    Tuple rangeEnd = Arrays.equals(range.end, END_BYTES) ? null : Tuple.fromBytes(range.end);\n+                    return CompletableFuture.allOf(\n+                            // All of the requested range without limit.\n+                            // In practice, this method works because it is only called for the endpoint ranges, which are empty and\n+                            // one long, respectively.\n+                            buildRangeOnly(store, rangeStart, rangeEnd, false, recordsScanned),\n+                            rangeSet.insertRange(store.ensureContextActive(), range, true)\n+                    ).thenCompose(vignore -> ranges.onHasNext());\n+                }, store.getExecutor());\n+            } else {\n+                return AsyncUtil.DONE;\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Builds (transactionally) the index by adding records with primary keys within the given range.\n+     * This will look for gaps of keys within the given range that haven't yet been rebuilt and then\n+     * rebuild only those ranges. As a result, if this method is called twice, the first time, it will\n+     * build whatever needs to be built, and then the second time, it will notice that there are no ranges\n+     * that need to be built, so it will do nothing. In this way, it is idempotent and thus safe to\n+     * use in retry loops.\n+     *\n+     * This method will fail if there is too much work to be done in a single transaction. If one wants\n+     * to handle building a range that does not fit in a single transaction, one should use the\n+     * {@link #buildRange(Key.Evaluated, Key.Evaluated) buildRange()}\n+     * function that takes an {@link FDBDatabase} as its first parameter.\n+     *\n+     * @param store the record store in which to rebuild the range\n+     * @param start the (inclusive) beginning primary key of the range to build (or <code>null</code> to go to the end)\n+     * @param end the (exclusive) end primary key of the range to build (or <code>null</code> to go to the end)\n+     * @return a future that will be ready when the build has completed\n+     */\n+    @Nonnull\n+    public CompletableFuture<Void> buildRange(@Nonnull FDBRecordStore store, @Nullable Key.Evaluated start, @Nullable Key.Evaluated end) {\n+        RangeSet rangeSet = new RangeSet(store.indexRangeSubspace(common.getIndex()));\n+        byte[] startBytes = packOrNull(convertOrNull(start));\n+        byte[] endBytes = packOrNull(convertOrNull(end));\n+        AsyncIterator<Range> ranges = rangeSet.missingRanges(store.ensureContextActive(), startBytes, endBytes).iterator();\n+        return ranges.onHasNext().thenCompose(hasNext -> {\n+            if (hasNext) {\n+                return AsyncUtil.whileTrue(() -> {\n+                    Range toBuild = ranges.next();\n+                    Tuple startTuple = Tuple.fromBytes(toBuild.begin);\n+                    Tuple endTuple = Arrays.equals(toBuild.end, END_BYTES) ? null : Tuple.fromBytes(toBuild.end);\n+                    AtomicReference<Tuple> currStart = new AtomicReference<>(startTuple);\n+                    return AsyncUtil.whileTrue(() ->\n+                            // Bold claim: this will never cause a RecordBuiltRangeException because of transactions.\n+                            buildUnbuiltRange(store, currStart.get(), endTuple, null).thenApply(realEnd -> {\n+                                if (realEnd != null && !realEnd.equals(endTuple)) {\n+                                    currStart.set(realEnd);\n+                                    return true;\n+                                } else {\n+                                    return false;\n+                                }\n+                            }), store.getExecutor()).thenCompose(vignore -> ranges.onHasNext());\n+                }, store.getExecutor());\n+            } else {\n+                return AsyncUtil.DONE;\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Builds (with a retry loop) the index by adding records with primary keys within the given range.\n+     * This will look for gaps of keys within the given range that haven't yet been rebuilt and then rebuild\n+     * only those ranges. It will also limit each transaction to the number of records specified by the\n+     * <code>limit</code> parameter of this class's constructor. In the case that that limit is too high (i.e.,\n+     * it can't make any progress or errors out on a non-retriable error like <code>transaction_too_large</code>,\n+     * this method will actually decrease the limit so that less work is attempted each transaction. It will\n+     * also rate limit itself as to not make too many requests per second.\n+     * <p>\n+     * Note that it does not have the protections (synchronized sessions and index state precondition) which are imposed\n+     * on buildIndexAsync() (or its variations), but it does use the created synchronized session if a\n+     * buildIndexAsync() is running on the {@link OnlineIndexer} simultaneously or this range build is used as\n+     * part of buildIndexAsync internally.\n+     * </p>\n+     * @param start the (inclusive) beginning primary key of the range to build (or <code>null</code> to go from the beginning)\n+     * @param end the (exclusive) end primary key of the range to build (or <code>null</code> to go to the end)\n+     * @return a future that will be ready when the build has completed\n+     */\n+    @Nonnull\n+    public CompletableFuture<Void> buildRange(@Nullable Key.Evaluated start, @Nullable Key.Evaluated end) {\n+        return buildRange(common.getRecordStoreBuilder().getSubspaceProvider(), start, end);\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildRange(@Nonnull SubspaceProvider subspaceProvider, @Nullable Key.Evaluated start, @Nullable Key.Evaluated end) {\n+        return getRunner().runAsync(context -> context.getReadVersionAsync().thenCompose(vignore ->\n+                subspaceProvider.getSubspaceAsync(context).thenCompose(subspace -> {\n+                    RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, common.getIndex().getSubspaceKey())));\n+                    byte[] startBytes = packOrNull(convertOrNull(start));\n+                    byte[] endBytes = packOrNull(convertOrNull(end));\n+                    Queue<Range> rangeDeque = new ArrayDeque<>();\n+                    ReadTransactionContext rtc = context.ensureActive();\n+                    return rangeSet.missingRanges(rtc, startBytes, endBytes)\n+                            .thenAccept(rangeDeque::addAll)\n+                            .thenCompose(vignore2 -> buildRanges(subspaceProvider, subspace, rangeSet, rangeDeque));\n+                })\n+        ));\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildRanges(SubspaceProvider subspaceProvider, @Nonnull Subspace subspace,\n+                                                RangeSet rangeSet, Queue<Range> rangeDeque) {\n+        return AsyncUtil.whileTrue(() -> {\n+            if (rangeDeque.isEmpty()) {\n+                return CompletableFuture.completedFuture(false); // We're done.\n+            }\n+            Range toBuild = rangeDeque.remove();\n+\n+            // This only works if the things included within the rangeSet are serialized Tuples.\n+            Tuple startTuple = Tuple.fromBytes(toBuild.begin);\n+            Tuple endTuple = Arrays.equals(toBuild.end, END_BYTES) ? null : Tuple.fromBytes(toBuild.end);\n+            return buildUnbuiltRange(startTuple, endTuple)\n+                    .handle((realEnd, ex) -> handleBuiltRange(subspaceProvider, subspace, rangeSet, rangeDeque, startTuple, endTuple, realEnd, ex))\n+                    .thenCompose(Function.identity());\n+        }, getRunner().getExecutor());\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Boolean> handleBuiltRange(SubspaceProvider subspaceProvider, @Nonnull Subspace subspace,\n+                                                        RangeSet rangeSet, Queue<Range> rangeDeque,\n+                                                        Tuple startTuple, Tuple endTuple, Tuple realEnd,\n+                                                        Throwable ex) {\n+        final RuntimeException unwrappedEx = ex == null ? null : getRunner().getDatabase().mapAsyncToSyncException(ex);\n+        if (unwrappedEx == null) {\n+            if (realEnd != null && !realEnd.equals(endTuple)) {\n+                // We didn't make it to the end. Continue on to the next item.\n+                if (endTuple != null) {\n+                    rangeDeque.add(new Range(realEnd.pack(), endTuple.pack()));\n+                } else {\n+                    rangeDeque.add(new Range(realEnd.pack(), END_BYTES));\n+                }\n+            }\n+            maybeLogBuildProgress(subspaceProvider, startTuple, endTuple, realEnd);\n+            return throttleDelay();\n+        } else {\n+            Throwable cause = unwrappedEx;\n+            while (cause != null) {\n+                if (cause instanceof OnlineIndexer.RecordBuiltRangeException) {\n+                    return rangeSet.missingRanges(getRunner().getDatabase().database(), startTuple.pack(), endTuple.pack())\n+                            .thenCompose(list -> {\n+                                rangeDeque.addAll(list);\n+                                return throttleDelay();\n+                            });\n+                } else {\n+                    cause = cause.getCause();\n+                }\n+            }\n+            if (LOGGER.isInfoEnabled()) {\n+                LOGGER.info(KeyValueLogMessage.of(\"possibly non-fatal error encountered building range\",\n+                        LogMessageKeys.RANGE_START, startTuple,\n+                        LogMessageKeys.RANGE_END, endTuple,\n+                        LogMessageKeys.SUBSPACE, ByteArrayUtil2.loggable(subspace.pack())), ex);\n+            }\n+            throw unwrappedEx; // made it to the bottom, throw original exception\n+        }\n+    }\n+\n+    // Helper function that works on Tuples instead of keys.\n+    @Nonnull\n+    private CompletableFuture<Tuple> buildUnbuiltRange(@Nonnull FDBRecordStore store, @Nullable Tuple start,\n+                                                       @Nullable Tuple end, @Nullable AtomicLong recordsScanned) {\n+        CompletableFuture<Tuple> buildFuture = buildRangeOnly(store, start, end, true, recordsScanned);\n+\n+        RangeSet rangeSet = new RangeSet(store.indexRangeSubspace(common.getIndex()));\n+        byte[] startBytes = packOrNull(start);\n+\n+        AtomicReference<Tuple> toReturn = new AtomicReference<>();\n+        return buildFuture.thenCompose(realEnd -> {\n+            toReturn.set(realEnd);\n+            return rangeSet.insertRange(store.ensureContextActive(), startBytes, packOrNull(realEnd), true);\n+        }).thenApply(changed -> {\n+            if (changed) {\n+                return toReturn.get();\n+            } else {\n+                throw new OnlineIndexer.RecordBuiltRangeException(start, end);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Builds (transactionally) the index by adding records with primary keys within the given range.\n+     * This requires that the range is initially \"unbuilt\", i.e., no records within the given\n+     * range have yet been processed by the index build job. It is acceptable if there\n+     * are records within that range that have already been added to the index because they were\n+     * added to the store after the index was added in write-only mode but have not yet been\n+     * processed by the index build job.\n+     *\n+     * Note that this function is not idempotent in that if the first time this function runs, if it\n+     * fails with <code>commit_unknown_result</code> but the transaction actually succeeds, running this\n+     * function again will result in a {@link OnlineIndexer.RecordBuiltRangeException} being thrown the second\n+     * time. Retry loops used by the <code>OnlineIndexer</code> class that call this method\n+     * handle this contingency. For the most part, this method should only be used by those who know\n+     * what they are doing. It is included because it is less expensive to make this call if one\n+     * already knows that the range will be unbuilt, but the caller must be ready to handle the\n+     * circumstance that the range might be built the second time.\n+     *\n+     * Most users should use the\n+     * {@link #buildRange(FDBRecordStore, Key.Evaluated, Key.Evaluated) buildRange()}\n+     * method with the same parameters in the case that they want to build a range of keys into the index. That\n+     * method <i>is</i> idempotent, but it is slightly more costly as it firsts determines what ranges are\n+     * have not yet been built before building them.\n+     *\n+     * @param store the record store in which to rebuild the range\n+     * @param start the (inclusive) beginning primary key of the range to build (or <code>null</code> to start from the beginning)\n+     * @param end the (exclusive) end primary key of the range to build (or <code>null</code> to go to the end)\n+     * @return a future with the key of the first record not processed by this range rebuild\n+     * @throws OnlineIndexer.RecordBuiltRangeException if the given range contains keys already processed by the index build\n+     */\n+    @Nonnull\n+    public CompletableFuture<Key.Evaluated> buildUnbuiltRange(@Nonnull FDBRecordStore store,\n+                                                              @Nullable Key.Evaluated start,\n+                                                              @Nullable Key.Evaluated end) {\n+        return buildUnbuiltRange(store, start, end, null);\n+    }\n+\n+    // just like the overload that doesn't take a recordsScanned\n+    @Nonnull\n+    private CompletableFuture<Key.Evaluated> buildUnbuiltRange(@Nonnull FDBRecordStore store,\n+                                                               @Nullable Key.Evaluated start, @Nullable Key.Evaluated end,\n+                                                               @Nullable AtomicLong recordsScanned) {\n+        return buildUnbuiltRange(store, convertOrNull(start), convertOrNull(end), recordsScanned)\n+                .thenApply(tuple -> (tuple == null) ? null : Key.Evaluated.fromTuple(tuple));\n+    }\n+\n+    // Helper function with the same behavior as buildUnbuiltRange, but it works on tuples instead of primary keys.\n+    @Nonnull\n+    private CompletableFuture<Tuple> buildUnbuiltRange(@Nullable Tuple start, @Nullable Tuple end) {\n+        final List<Object> additionalLogMessageKeyValues = Arrays.asList(LogMessageKeys.CALLING_METHOD, \"buildUnbuiltRange\",\n+                LogMessageKeys.RANGE_START, start,\n+                LogMessageKeys.RANGE_END, end);\n+\n+        return buildAsync((store, recordsScanned) -> buildUnbuiltRange(store, start, end, recordsScanned),\n+                true,\n+                additionalLogMessageKeyValues);\n+    }\n+\n+    @VisibleForTesting\n+    @Nonnull\n+    CompletableFuture<Key.Evaluated> buildUnbuiltRange(@Nullable Key.Evaluated start, @Nullable Key.Evaluated end) {\n+        final List<Object> additionalLogMessageKeyValues = Arrays.asList(LogMessageKeys.CALLING_METHOD, \"buildUnbuiltRange\",\n+                LogMessageKeys.RANGE_START, start,\n+                LogMessageKeys.RANGE_END, end);\n+        return buildAsync((store, recordsScanned) -> buildUnbuiltRange(store, start, end, recordsScanned),\n+                true,\n+                additionalLogMessageKeyValues);\n+    }\n+\n+    @Nonnull\n+    @SuppressWarnings(\"unchecked\")\n+    private RecordCursorResult<FDBStoredRecord<Message>> castCursorResult(RecordCursorResult<?> result) {\n+        if (result == null) {\n+            throw new MetaDataException(\"Unexpected null result\");", "originalCommit": "c531ce9049a4eb57f74dedd82c09efb3a15be757", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "77e2f644ee55f48ae5bceb1456bd0096542ec163", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/77e2f644ee55f48ae5bceb1456bd0096542ec163", "message": "Squashing:\nrefactor OnlineIndexer to the structure below:\n\n  OnlineIndexer: User API + defines OnlineIndexer.Config, OnlineIndexer.IndexFromIndexPolicy, OnlineIndexer.RecordBuiltRangeException\n      Scanners:\n      OnlineIndexerScanner: base class for scanners\n          OnlineIndexerByRecords: scan by records (all records in DB)\n          OnlineIndexerByIndex: scan by source index\n             Scanners' Helper:\n             OnlineIndexerThrottle: (implements buildAsync) wraps run/commit/retry with workload adjustment on success/failure\n      Shared classes:\n      OnlineIndexerCommon: holds the operation's setup for all classes\n      OnlineIndexerException: scanner's exception\n\nadd test: non-VALUE source\n\nImplement (some of) Scott's requests\n\nApply most of Tao's, Alec's, Scott's review requests.\n\nspotbugsMain fixes\n\nmove indexBuildLockSubspace & indexBuildScannedRecordsSubspace to IndexingBase", "committedDate": "2021-01-14T15:33:05Z", "type": "forcePushed"}, {"oid": "c149127d7450b112a3d71bc510d429a06575b9b9", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/c149127d7450b112a3d71bc510d429a06575b9b9", "message": "Squashing:\nrefactor OnlineIndexer to the structure below:\n\n  OnlineIndexer: User API + defines OnlineIndexer.Config, OnlineIndexer.IndexFromIndexPolicy, OnlineIndexer.RecordBuiltRangeException\n      Scanners:\n      OnlineIndexerScanner: base class for scanners\n          OnlineIndexerByRecords: scan by records (all records in DB)\n          OnlineIndexerByIndex: scan by source index\n             Scanners' Helper:\n             OnlineIndexerThrottle: (implements buildAsync) wraps run/commit/retry with workload adjustment on success/failure\n      Shared classes:\n      OnlineIndexerCommon: holds the operation's setup for all classes\n      OnlineIndexerException: scanner's exception\n\nadd test: non-VALUE source\n\nImplement (some of) Scott's requests\n\nApply most of Tao's, Alec's, Scott's review requests.\n\nspotbugsMain fixes\n\nmove indexBuildLockSubspace & indexBuildScannedRecordsSubspace to IndexingBase\n\nrenaming for clarity", "committedDate": "2021-01-14T19:34:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODY3NzE5MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r558677191", "bodyText": "It looks like this is still a MetaDataException, when it shouldn't be. I also think the signature on this method can be improved so that it takes a RecordCursorResult<FDBStoredRecord<Message>> with the improved generics on iterateRangeOnly", "author": "alecgrieser", "createdAt": "2021-01-15T23:45:01Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingByRecords.java", "diffHunk": "@@ -0,0 +1,677 @@\n+/*\n+ * OnlineIndexerByRecords.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.MutationType;\n+import com.apple.foundationdb.Range;\n+import com.apple.foundationdb.ReadTransactionContext;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncIterator;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.RangeSet;\n+import com.apple.foundationdb.record.EndpointType;\n+import com.apple.foundationdb.record.ExecuteProperties;\n+import com.apple.foundationdb.record.IsolationLevel;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorResult;\n+import com.apple.foundationdb.record.ScanProperties;\n+import com.apple.foundationdb.record.TupleRange;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.MetaDataException;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.ByteArrayUtil2;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.Message;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ *  This indexer scans all records in the record store.\n+ */\n+@API(API.Status.INTERNAL)\n+public class IndexingByRecords extends IndexingBase {\n+    @Nonnull private static final Logger LOGGER = LoggerFactory.getLogger(IndexingByRecords.class);\n+\n+    @Nonnull private final TupleRange recordsRange;\n+    @Nonnull private static final byte[] START_BYTES = new byte[]{0x00};\n+    @Nonnull private static final byte[] END_BYTES = new byte[]{(byte)0xff};\n+\n+\n+    IndexingByRecords(@Nonnull IndexingCommon common) {\n+        super(common);\n+        this.recordsRange = computeRecordsRange();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    CompletableFuture<Void> buildIndexByEntityAsync() {\n+        return buildEndpoints().thenCompose(tupleRange -> {\n+            if (tupleRange != null) {\n+                return buildRange(Key.Evaluated.fromTuple(tupleRange.getLow()), Key.Evaluated.fromTuple(tupleRange.getHigh()));\n+            } else {\n+                return CompletableFuture.completedFuture(null);\n+            }\n+        });\n+    }\n+\n+    private void maybeLogBuildProgress(SubspaceProvider subspaceProvider, Tuple startTuple, Tuple endTuple, Tuple realEnd) {\n+        if (LOGGER.isInfoEnabled() && shouldLogBuildProgress()) {\n+            LOGGER.info(KeyValueLogMessage.of(\"Built Range\",\n+                    LogMessageKeys.INDEX_NAME, common.getIndex().getName(),\n+                    LogMessageKeys.INDEX_VERSION, common.getIndex().getLastModifiedVersion(),\n+                    subspaceProvider.logKey(), subspaceProvider,\n+                    LogMessageKeys.START_TUPLE, startTuple,\n+                    LogMessageKeys.END_TUPLE, endTuple,\n+                    LogMessageKeys.REAL_END, realEnd,\n+                    LogMessageKeys.RECORDS_SCANNED, common.getTotalRecordsScanned().get()),\n+                    LogMessageKeys.INDEXER_ID, common.getUuid());\n+        }\n+    }\n+\n+    @Nonnull\n+    private TupleRange computeRecordsRange() {\n+        Tuple low = null;\n+        Tuple high = null;\n+        for (RecordType recordType : common.recordTypes) {\n+            if (!recordType.primaryKeyHasRecordTypePrefix() || recordType.isSynthetic()) {\n+                // If any of the types to build for does not have a prefix, give up.\n+                return TupleRange.ALL;\n+            }\n+            Tuple prefix = recordType.getRecordTypeKeyTuple();\n+            if (low == null) {\n+                low = high = prefix;\n+            } else {\n+                if (low.compareTo(prefix) > 0) {\n+                    low = prefix;\n+                }\n+                if (high.compareTo(prefix) < 0) {\n+                    high = prefix;\n+                }\n+            }\n+        }\n+        if (low == null) {\n+            return TupleRange.ALL;\n+        } else {\n+            // Both ends inclusive.\n+            return new TupleRange(low, high, EndpointType.RANGE_INCLUSIVE, EndpointType.RANGE_INCLUSIVE);\n+        }\n+    }\n+\n+    /**\n+     * Builds (transactionally) the endpoints of an index. What this means is that builds everything from the beginning of\n+     * the key space to the first record and everything from the last record to the end of the key space.\n+     * There won't be any records within these ranges (except for the last record of the record store), but\n+     * it does mean that any records in the future that get added to these ranges will correctly update\n+     * the index. This means, e.g., that if the workload primarily adds records to the record store\n+     * after the current last record (because perhaps the primary key is based off of an atomic counter\n+     * or the current time), running this method will be highly contentious, but once it completes,\n+     * the rest of the index build should happen without any more conflicts.\n+     *\n+     * This will return a (possibly null) {@link TupleRange} that contains the primary keys of the\n+     * first and last records within the record store. This can then be used to either build the\n+     * range right away or to then divy-up the remaining ranges between multiple agents working\n+     * in parallel if one desires.\n+     *\n+     * @param store the record store in which to rebuild the index\n+     * @param recordsScanned continues counter\n+     * @return a future that will contain the range of records in the interior of the record store\n+     */\n+\n+    @Nonnull\n+    public CompletableFuture<TupleRange> buildEndpoints(@Nonnull FDBRecordStore store,\n+                                                        @Nullable AtomicLong recordsScanned) {\n+        final RangeSet rangeSet = new RangeSet(store.indexRangeSubspace(common.getIndex()));\n+        if (TupleRange.ALL.equals(recordsRange)) {\n+            return buildEndpoints(store, rangeSet, recordsScanned);\n+        }\n+        // If records do not occupy whole range, first mark outside as built.\n+        final Range asRange = recordsRange.toRange();\n+        return CompletableFuture.allOf(\n+                rangeSet.insertRange(store.ensureContextActive(), null, asRange.begin),\n+                rangeSet.insertRange(store.ensureContextActive(), asRange.end, null))\n+                .thenCompose(vignore -> buildEndpoints(store, rangeSet, recordsScanned));\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<TupleRange> buildEndpoints(@Nonnull FDBRecordStore store, @Nonnull RangeSet rangeSet,\n+                                                         @Nullable AtomicLong recordsScanned) {\n+        boolean isIdempotent = store.getIndexMaintainer(common.getIndex()).isIdempotent();\n+        final IsolationLevel isolationLevel =\n+                isIdempotent ?\n+                // If idempotent: since double indexing is harmless, we can use individual records protection instead of\n+                // a range conflict one - which means that new records, added to the range while indexing the SNAPSHOT,\n+                // will not cause a conflict during the commit. At worse, few records (if added after marking WRITE_ONLY but\n+                // before this method's query) will be re-indexed.\n+                IsolationLevel.SNAPSHOT :\n+                IsolationLevel.SERIALIZABLE;\n+        final ExecuteProperties limit1 = ExecuteProperties.newBuilder()\n+                .setReturnedRowLimit(1)\n+                .setIsolationLevel(isolationLevel)\n+                .build();\n+        final ScanProperties forward = new ScanProperties(limit1);\n+\n+        RecordCursor<FDBStoredRecord<Message>> beginCursor = store.scanRecords(recordsRange, null, forward);\n+        CompletableFuture<Tuple> begin = beginCursor.onNext().thenCompose(result -> {\n+            if (result.hasNext()) {\n+                Tuple firstTuple = result.get().getPrimaryKey();\n+                return buildRange(store, null, firstTuple, recordsScanned).thenApply(vignore -> firstTuple);\n+            } else {\n+                // Empty range -- add the whole thing.\n+                return rangeSet.insertRange(store.ensureContextActive(), null, null).thenApply(bignore -> null);\n+            }\n+        });\n+\n+        final ScanProperties backward = new ScanProperties(limit1, true);\n+        RecordCursor<FDBStoredRecord<Message>> endCursor = store.scanRecords(recordsRange, null, backward);\n+        CompletableFuture<Tuple> end = endCursor.onNext().thenCompose(result -> {\n+            if (result.hasNext()) {\n+                Tuple lastTuple = result.get().getPrimaryKey();\n+                return buildRange(store, lastTuple, null, recordsScanned).thenApply(vignore -> lastTuple);\n+            } else {\n+                // As the range is empty, the whole range needs to be added, but that is accomplished\n+                // by the above future, so this has nothing to do.\n+                return CompletableFuture.completedFuture(null);\n+            }\n+        });\n+\n+        return begin.thenCombine(end, (firstTuple, lastTuple) -> {\n+            if (firstTuple == null || firstTuple.equals(lastTuple)) {\n+                return null;\n+            } else {\n+                return new TupleRange(firstTuple, lastTuple, EndpointType.RANGE_INCLUSIVE, EndpointType.RANGE_EXCLUSIVE);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Builds (with a retry loop) the endpoints of an index. See the\n+     * {@link #buildEndpoints(FDBRecordStore, AtomicLong) buildEndpoints()} method that takes\n+     * an {@link FDBRecordStore} as its parameter for more details. This will retry on that function\n+     * until it gets a non-exceptional result and return the results back.\n+     *\n+     * @return a future that will contain the range of records in the interior of the record store\n+     */\n+    @Nonnull\n+    public CompletableFuture<TupleRange> buildEndpoints() {\n+        final List<Object> additionalLogMessageKeyValues = Arrays.asList(LogMessageKeys.CALLING_METHOD, \"buildEndpoints\");\n+        return buildCommitRetryAsync(this::buildEndpoints, false, additionalLogMessageKeyValues);\n+    }\n+\n+    // Turn a (possibly null) key into its tuple representation.\n+    @Nullable\n+    private Tuple convertOrNull(@Nullable Key.Evaluated key) {\n+        return (key == null) ? null : key.toTuple();\n+    }\n+\n+    // Turn a (possibly null) tuple into a (possibly null) byte array.\n+    @Nullable\n+    private byte[] packOrNull(@Nullable Tuple tuple) {\n+        return (tuple == null) ? null : tuple.pack();\n+    }\n+\n+    // Builds a range within a single transaction. It will look for the missing ranges within the given range and build those while\n+    // updating the range set.\n+    @Nonnull\n+    private CompletableFuture<Void> buildRange(@Nonnull FDBRecordStore store, @Nullable Tuple start, @Nullable Tuple end,\n+                                               @Nullable AtomicLong recordsScanned) {\n+        RangeSet rangeSet = new RangeSet(store.indexRangeSubspace(common.getIndex()));\n+        AsyncIterator<Range> ranges = rangeSet.missingRanges(store.ensureContextActive(), packOrNull(start), packOrNull(end)).iterator();\n+        return ranges.onHasNext().thenCompose(hasAny -> {\n+            if (hasAny) {\n+                return AsyncUtil.whileTrue(() -> {\n+                    Range range = ranges.next();\n+                    Tuple rangeStart = Arrays.equals(range.begin, START_BYTES) ? null : Tuple.fromBytes(range.begin);\n+                    Tuple rangeEnd = Arrays.equals(range.end, END_BYTES) ? null : Tuple.fromBytes(range.end);\n+                    return CompletableFuture.allOf(\n+                            // All of the requested range without limit.\n+                            // In practice, this method works because it is only called for the endpoint ranges, which are empty and\n+                            // one long, respectively.\n+                            buildRangeOnly(store, rangeStart, rangeEnd, false, recordsScanned),\n+                            rangeSet.insertRange(store.ensureContextActive(), range, true)\n+                    ).thenCompose(vignore -> ranges.onHasNext());\n+                }, store.getExecutor());\n+            } else {\n+                return AsyncUtil.DONE;\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Builds (transactionally) the index by adding records with primary keys within the given range.\n+     * This will look for gaps of keys within the given range that haven't yet been rebuilt and then\n+     * rebuild only those ranges. As a result, if this method is called twice, the first time, it will\n+     * build whatever needs to be built, and then the second time, it will notice that there are no ranges\n+     * that need to be built, so it will do nothing. In this way, it is idempotent and thus safe to\n+     * use in retry loops.\n+     *\n+     * This method will fail if there is too much work to be done in a single transaction. If one wants\n+     * to handle building a range that does not fit in a single transaction, one should use the\n+     * {@link #buildRange(Key.Evaluated, Key.Evaluated) buildRange()}\n+     * function that takes an {@link FDBDatabase} as its first parameter.\n+     *\n+     * @param store the record store in which to rebuild the range\n+     * @param start the (inclusive) beginning primary key of the range to build (or <code>null</code> to go to the end)\n+     * @param end the (exclusive) end primary key of the range to build (or <code>null</code> to go to the end)\n+     * @return a future that will be ready when the build has completed\n+     */\n+    @Nonnull\n+    public CompletableFuture<Void> buildRange(@Nonnull FDBRecordStore store, @Nullable Key.Evaluated start, @Nullable Key.Evaluated end) {\n+        RangeSet rangeSet = new RangeSet(store.indexRangeSubspace(common.getIndex()));\n+        byte[] startBytes = packOrNull(convertOrNull(start));\n+        byte[] endBytes = packOrNull(convertOrNull(end));\n+        AsyncIterator<Range> ranges = rangeSet.missingRanges(store.ensureContextActive(), startBytes, endBytes).iterator();\n+        return ranges.onHasNext().thenCompose(hasNext -> {\n+            if (hasNext) {\n+                return AsyncUtil.whileTrue(() -> {\n+                    Range toBuild = ranges.next();\n+                    Tuple startTuple = Tuple.fromBytes(toBuild.begin);\n+                    Tuple endTuple = Arrays.equals(toBuild.end, END_BYTES) ? null : Tuple.fromBytes(toBuild.end);\n+                    AtomicReference<Tuple> currStart = new AtomicReference<>(startTuple);\n+                    return AsyncUtil.whileTrue(() ->\n+                            // Bold claim: this will never cause a RecordBuiltRangeException because of transactions.\n+                            buildUnbuiltRange(store, currStart.get(), endTuple, null).thenApply(realEnd -> {\n+                                if (realEnd != null && !realEnd.equals(endTuple)) {\n+                                    currStart.set(realEnd);\n+                                    return true;\n+                                } else {\n+                                    return false;\n+                                }\n+                            }), store.getExecutor()).thenCompose(vignore -> ranges.onHasNext());\n+                }, store.getExecutor());\n+            } else {\n+                return AsyncUtil.DONE;\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Builds (with a retry loop) the index by adding records with primary keys within the given range.\n+     * This will look for gaps of keys within the given range that haven't yet been rebuilt and then rebuild\n+     * only those ranges. It will also limit each transaction to the number of records specified by the\n+     * <code>limit</code> parameter of this class's constructor. In the case that that limit is too high (i.e.,\n+     * it can't make any progress or errors out on a non-retriable error like <code>transaction_too_large</code>,\n+     * this method will actually decrease the limit so that less work is attempted each transaction. It will\n+     * also rate limit itself as to not make too many requests per second.\n+     * <p>\n+     * Note that it does not have the protections (synchronized sessions and index state precondition) which are imposed\n+     * on buildIndexAsync() (or its variations), but it does use the created synchronized session if a\n+     * buildIndexAsync() is running on the {@link OnlineIndexer} simultaneously or this range build is used as\n+     * part of buildIndexAsync internally.\n+     * </p>\n+     * @param start the (inclusive) beginning primary key of the range to build (or <code>null</code> to go from the beginning)\n+     * @param end the (exclusive) end primary key of the range to build (or <code>null</code> to go to the end)\n+     * @return a future that will be ready when the build has completed\n+     */\n+    @Nonnull\n+    public CompletableFuture<Void> buildRange(@Nullable Key.Evaluated start, @Nullable Key.Evaluated end) {\n+        return buildRange(common.getRecordStoreBuilder().getSubspaceProvider(), start, end);\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildRange(@Nonnull SubspaceProvider subspaceProvider, @Nullable Key.Evaluated start, @Nullable Key.Evaluated end) {\n+        return getRunner().runAsync(context -> context.getReadVersionAsync().thenCompose(vignore ->\n+                subspaceProvider.getSubspaceAsync(context).thenCompose(subspace -> {\n+                    RangeSet rangeSet = new RangeSet(subspace.subspace(Tuple.from(FDBRecordStore.INDEX_RANGE_SPACE_KEY, common.getIndex().getSubspaceKey())));\n+                    byte[] startBytes = packOrNull(convertOrNull(start));\n+                    byte[] endBytes = packOrNull(convertOrNull(end));\n+                    Queue<Range> rangeDeque = new ArrayDeque<>();\n+                    ReadTransactionContext rtc = context.ensureActive();\n+                    return rangeSet.missingRanges(rtc, startBytes, endBytes)\n+                            .thenAccept(rangeDeque::addAll)\n+                            .thenCompose(vignore2 -> buildRanges(subspaceProvider, subspace, rangeSet, rangeDeque));\n+                })\n+        ));\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> buildRanges(SubspaceProvider subspaceProvider, @Nonnull Subspace subspace,\n+                                                RangeSet rangeSet, Queue<Range> rangeDeque) {\n+        return AsyncUtil.whileTrue(() -> {\n+            if (rangeDeque.isEmpty()) {\n+                return CompletableFuture.completedFuture(false); // We're done.\n+            }\n+            Range toBuild = rangeDeque.remove();\n+\n+            // This only works if the things included within the rangeSet are serialized Tuples.\n+            Tuple startTuple = Tuple.fromBytes(toBuild.begin);\n+            Tuple endTuple = Arrays.equals(toBuild.end, END_BYTES) ? null : Tuple.fromBytes(toBuild.end);\n+            return buildUnbuiltRange(startTuple, endTuple)\n+                    .handle((realEnd, ex) -> handleBuiltRange(subspaceProvider, subspace, rangeSet, rangeDeque, startTuple, endTuple, realEnd, ex))\n+                    .thenCompose(Function.identity());\n+        }, getRunner().getExecutor());\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Boolean> handleBuiltRange(SubspaceProvider subspaceProvider, @Nonnull Subspace subspace,\n+                                                        RangeSet rangeSet, Queue<Range> rangeDeque,\n+                                                        Tuple startTuple, Tuple endTuple, Tuple realEnd,\n+                                                        Throwable ex) {\n+        final RuntimeException unwrappedEx = ex == null ? null : getRunner().getDatabase().mapAsyncToSyncException(ex);\n+        if (unwrappedEx == null) {\n+            if (realEnd != null && !realEnd.equals(endTuple)) {\n+                // We didn't make it to the end. Continue on to the next item.\n+                if (endTuple != null) {\n+                    rangeDeque.add(new Range(realEnd.pack(), endTuple.pack()));\n+                } else {\n+                    rangeDeque.add(new Range(realEnd.pack(), END_BYTES));\n+                }\n+            }\n+            maybeLogBuildProgress(subspaceProvider, startTuple, endTuple, realEnd);\n+            return throttleDelay();\n+        } else {\n+            Throwable cause = unwrappedEx;\n+            while (cause != null) {\n+                if (cause instanceof OnlineIndexer.RecordBuiltRangeException) {\n+                    return rangeSet.missingRanges(getRunner().getDatabase().database(), startTuple.pack(), endTuple.pack())\n+                            .thenCompose(list -> {\n+                                rangeDeque.addAll(list);\n+                                return throttleDelay();\n+                            });\n+                } else {\n+                    cause = cause.getCause();\n+                }\n+            }\n+            if (LOGGER.isInfoEnabled()) {\n+                LOGGER.info(KeyValueLogMessage.of(\"possibly non-fatal error encountered building range\",\n+                        LogMessageKeys.RANGE_START, startTuple,\n+                        LogMessageKeys.RANGE_END, endTuple,\n+                        LogMessageKeys.SUBSPACE, ByteArrayUtil2.loggable(subspace.pack())), ex);\n+            }\n+            throw unwrappedEx; // made it to the bottom, throw original exception\n+        }\n+    }\n+\n+    // Helper function that works on Tuples instead of keys.\n+    @Nonnull\n+    private CompletableFuture<Tuple> buildUnbuiltRange(@Nonnull FDBRecordStore store, @Nullable Tuple start,\n+                                                       @Nullable Tuple end, @Nullable AtomicLong recordsScanned) {\n+        CompletableFuture<Tuple> buildFuture = buildRangeOnly(store, start, end, true, recordsScanned);\n+\n+        RangeSet rangeSet = new RangeSet(store.indexRangeSubspace(common.getIndex()));\n+        byte[] startBytes = packOrNull(start);\n+\n+        AtomicReference<Tuple> toReturn = new AtomicReference<>();\n+        return buildFuture.thenCompose(realEnd -> {\n+            toReturn.set(realEnd);\n+            return rangeSet.insertRange(store.ensureContextActive(), startBytes, packOrNull(realEnd), true);\n+        }).thenApply(changed -> {\n+            if (changed) {\n+                return toReturn.get();\n+            } else {\n+                throw new OnlineIndexer.RecordBuiltRangeException(start, end);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Builds (transactionally) the index by adding records with primary keys within the given range.\n+     * This requires that the range is initially \"unbuilt\", i.e., no records within the given\n+     * range have yet been processed by the index build job. It is acceptable if there\n+     * are records within that range that have already been added to the index because they were\n+     * added to the store after the index was added in write-only mode but have not yet been\n+     * processed by the index build job.\n+     *\n+     * Note that this function is not idempotent in that if the first time this function runs, if it\n+     * fails with <code>commit_unknown_result</code> but the transaction actually succeeds, running this\n+     * function again will result in a {@link OnlineIndexer.RecordBuiltRangeException} being thrown the second\n+     * time. Retry loops used by the <code>OnlineIndexer</code> class that call this method\n+     * handle this contingency. For the most part, this method should only be used by those who know\n+     * what they are doing. It is included because it is less expensive to make this call if one\n+     * already knows that the range will be unbuilt, but the caller must be ready to handle the\n+     * circumstance that the range might be built the second time.\n+     *\n+     * Most users should use the\n+     * {@link #buildRange(FDBRecordStore, Key.Evaluated, Key.Evaluated) buildRange()}\n+     * method with the same parameters in the case that they want to build a range of keys into the index. That\n+     * method <i>is</i> idempotent, but it is slightly more costly as it firsts determines what ranges are\n+     * have not yet been built before building them.\n+     *\n+     * @param store the record store in which to rebuild the range\n+     * @param start the (inclusive) beginning primary key of the range to build (or <code>null</code> to start from the beginning)\n+     * @param end the (exclusive) end primary key of the range to build (or <code>null</code> to go to the end)\n+     * @return a future with the key of the first record not processed by this range rebuild\n+     * @throws OnlineIndexer.RecordBuiltRangeException if the given range contains keys already processed by the index build\n+     */\n+    @Nonnull\n+    public CompletableFuture<Key.Evaluated> buildUnbuiltRange(@Nonnull FDBRecordStore store,\n+                                                              @Nullable Key.Evaluated start,\n+                                                              @Nullable Key.Evaluated end) {\n+        return buildUnbuiltRange(store, start, end, null);\n+    }\n+\n+    // just like the overload that doesn't take a recordsScanned\n+    @Nonnull\n+    private CompletableFuture<Key.Evaluated> buildUnbuiltRange(@Nonnull FDBRecordStore store,\n+                                                               @Nullable Key.Evaluated start, @Nullable Key.Evaluated end,\n+                                                               @Nullable AtomicLong recordsScanned) {\n+        return buildUnbuiltRange(store, convertOrNull(start), convertOrNull(end), recordsScanned)\n+                .thenApply(tuple -> (tuple == null) ? null : Key.Evaluated.fromTuple(tuple));\n+    }\n+\n+    // Helper function with the same behavior as buildUnbuiltRange, but it works on tuples instead of primary keys.\n+    @Nonnull\n+    private CompletableFuture<Tuple> buildUnbuiltRange(@Nullable Tuple start, @Nullable Tuple end) {\n+        final List<Object> additionalLogMessageKeyValues = Arrays.asList(LogMessageKeys.CALLING_METHOD, \"buildUnbuiltRange\",\n+                LogMessageKeys.RANGE_START, start,\n+                LogMessageKeys.RANGE_END, end);\n+\n+        return buildCommitRetryAsync((store, recordsScanned) -> buildUnbuiltRange(store, start, end, recordsScanned),\n+                true,\n+                additionalLogMessageKeyValues);\n+    }\n+\n+    @VisibleForTesting\n+    @Nonnull\n+    CompletableFuture<Key.Evaluated> buildUnbuiltRange(@Nullable Key.Evaluated start, @Nullable Key.Evaluated end) {\n+        final List<Object> additionalLogMessageKeyValues = Arrays.asList(LogMessageKeys.CALLING_METHOD, \"buildUnbuiltRange\",\n+                LogMessageKeys.RANGE_START, start,\n+                LogMessageKeys.RANGE_END, end);\n+        return buildCommitRetryAsync((store, recordsScanned) -> buildUnbuiltRange(store, start, end, recordsScanned),\n+                true,\n+                additionalLogMessageKeyValues);\n+    }\n+\n+    @Nonnull\n+    @SuppressWarnings(\"unchecked\")\n+    private RecordCursorResult<FDBStoredRecord<Message>> castCursorResult(RecordCursorResult<?> result) {\n+        if (result == null) {\n+            throw new MetaDataException(\"Unexpected null result\");", "originalCommit": "c149127d7450b112a3d71bc510d429a06575b9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODcxMzI2Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r558713262", "bodyText": "Oops, missed this one (change in IndexingByIndex only).", "author": "jjezra", "createdAt": "2021-01-16T00:35:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODY3NzE5MQ=="}], "type": "inlineReview"}, {"oid": "b4b84f0e963cfec8bbd8b99dced6b1c2465f348b", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/b4b84f0e963cfec8bbd8b99dced6b1c2465f348b", "message": "Resolve #1078: Allow creating an index from an existing index\n\n    When building a single type idempotent index, provide the user with an option\n    to request an iteration over an existing, readable, source index instead of a\n    full records store scan.\n\n    This commit squashes all 'index from index' commits (pre refactoring)\n\n    TODO: OnlineIndexer refactor\n    TODO: add more unit tests", "committedDate": "2021-01-16T00:58:48Z", "type": "commit"}, {"oid": "fd6ae8830e60f880c835bafdb9f81c7a48d23015", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/fd6ae8830e60f880c835bafdb9f81c7a48d23015", "message": "Squashing:\nrefactor OnlineIndexer to the structure below:\n\n  OnlineIndexer: User API + defines OnlineIndexer.Config, OnlineIndexer.IndexFromIndexPolicy, OnlineIndexer.RecordBuiltRangeException\n      Scanners:\n      OnlineIndexerScanner: base class for scanners\n          OnlineIndexerByRecords: scan by records (all records in DB)\n          OnlineIndexerByIndex: scan by source index\n             Scanners' Helper:\n             OnlineIndexerThrottle: (implements buildAsync) wraps run/commit/retry with workload adjustment on success/failure\n      Shared classes:\n      OnlineIndexerCommon: holds the operation's setup for all classes\n      OnlineIndexerException: scanner's exception\n\nadd test: non-VALUE source\n\nImplement (some of) Scott's requests\n\nApply most of Tao's, Alec's, Scott's review requests.\n\nspotbugsMain fixes\n\nmove indexBuildLockSubspace & indexBuildScannedRecordsSubspace to IndexingBase\n\nrenaming for clarity", "committedDate": "2021-01-16T00:59:18Z", "type": "commit"}, {"oid": "fd6ae8830e60f880c835bafdb9f81c7a48d23015", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/fd6ae8830e60f880c835bafdb9f81c7a48d23015", "message": "Squashing:\nrefactor OnlineIndexer to the structure below:\n\n  OnlineIndexer: User API + defines OnlineIndexer.Config, OnlineIndexer.IndexFromIndexPolicy, OnlineIndexer.RecordBuiltRangeException\n      Scanners:\n      OnlineIndexerScanner: base class for scanners\n          OnlineIndexerByRecords: scan by records (all records in DB)\n          OnlineIndexerByIndex: scan by source index\n             Scanners' Helper:\n             OnlineIndexerThrottle: (implements buildAsync) wraps run/commit/retry with workload adjustment on success/failure\n      Shared classes:\n      OnlineIndexerCommon: holds the operation's setup for all classes\n      OnlineIndexerException: scanner's exception\n\nadd test: non-VALUE source\n\nImplement (some of) Scott's requests\n\nApply most of Tao's, Alec's, Scott's review requests.\n\nspotbugsMain fixes\n\nmove indexBuildLockSubspace & indexBuildScannedRecordsSubspace to IndexingBase\n\nrenaming for clarity", "committedDate": "2021-01-16T00:59:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTExOTIwNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r561119206", "bodyText": "The class name isn't changed here. I think auto-renaming should handle this.", "author": "nblintao", "createdAt": "2021-01-20T16:49:43Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingBase.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * OnlineIndexerScanner.java", "originalCommit": "fd6ae8830e60f880c835bafdb9f81c7a48d23015", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTEzNjA2OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r561136068", "bodyText": "store.getUntypedRecordStore().indexBuildSubspace(index)\n\nThis could be extracted as a common method the the 3 methods here.", "author": "nblintao", "createdAt": "2021-01-20T17:14:38Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingBase.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * OnlineIndexerScanner.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.FDBException;\n+import com.apple.foundationdb.Transaction;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.MoreAsyncUtil;\n+import com.apple.foundationdb.async.RangeSet;\n+import com.apple.foundationdb.record.IndexState;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorResult;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.provider.foundationdb.synchronizedsession.SynchronizedSessionRunner;\n+import com.apple.foundationdb.record.query.plan.synthetic.SyntheticRecordFromStoredRecordPlan;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.google.protobuf.Message;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A base class for different types of online indexing scanners.\n+ */\n+@API(API.Status.INTERNAL)\n+public abstract class IndexingBase {\n+\n+    private static final Object INDEX_BUILD_LOCK_KEY = 0L;\n+    private static final Object INDEX_BUILD_SCANNED_RECORDS = 1L;\n+    private static final Object INDEX_BUILD_TYPE_VERSION = 2L;\n+\n+    @Nonnull\n+    private static final Logger LOGGER = LoggerFactory.getLogger(IndexingBase.class);\n+    @Nonnull\n+    protected final IndexingCommon common; // to be used by extenders\n+    @Nonnull\n+    private final IndexingThrottle throttle;\n+\n+    private long timeOfLastProgressLogMillis = 0;\n+\n+    IndexingBase(IndexingCommon common) {\n+        this.common = common;\n+        this.throttle = new IndexingThrottle(common);\n+    }\n+\n+    protected FDBDatabaseRunner getRunner() {\n+        return common.getRunner();\n+    }\n+\n+    @Nonnull\n+    protected static Subspace indexBuildLockSubspace(@Nonnull FDBRecordStoreBase<?> store, @Nonnull Index index) {\n+        return store.getUntypedRecordStore().indexBuildSubspace(index).subspace(Tuple.from(INDEX_BUILD_LOCK_KEY));", "originalCommit": "fd6ae8830e60f880c835bafdb9f81c7a48d23015", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE0MjExMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r561142113", "bodyText": "You mean \"This method is only used by tests. Actually traffic uses throttle.throttledRunAsync directly\"?", "author": "nblintao", "createdAt": "2021-01-20T17:24:10Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingBase.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * OnlineIndexerScanner.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.FDBException;\n+import com.apple.foundationdb.Transaction;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.MoreAsyncUtil;\n+import com.apple.foundationdb.async.RangeSet;\n+import com.apple.foundationdb.record.IndexState;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorResult;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.provider.foundationdb.synchronizedsession.SynchronizedSessionRunner;\n+import com.apple.foundationdb.record.query.plan.synthetic.SyntheticRecordFromStoredRecordPlan;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.google.protobuf.Message;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A base class for different types of online indexing scanners.\n+ */\n+@API(API.Status.INTERNAL)\n+public abstract class IndexingBase {\n+\n+    private static final Object INDEX_BUILD_LOCK_KEY = 0L;\n+    private static final Object INDEX_BUILD_SCANNED_RECORDS = 1L;\n+    private static final Object INDEX_BUILD_TYPE_VERSION = 2L;\n+\n+    @Nonnull\n+    private static final Logger LOGGER = LoggerFactory.getLogger(IndexingBase.class);\n+    @Nonnull\n+    protected final IndexingCommon common; // to be used by extenders\n+    @Nonnull\n+    private final IndexingThrottle throttle;\n+\n+    private long timeOfLastProgressLogMillis = 0;\n+\n+    IndexingBase(IndexingCommon common) {\n+        this.common = common;\n+        this.throttle = new IndexingThrottle(common);\n+    }\n+\n+    protected FDBDatabaseRunner getRunner() {\n+        return common.getRunner();\n+    }\n+\n+    @Nonnull\n+    protected static Subspace indexBuildLockSubspace(@Nonnull FDBRecordStoreBase<?> store, @Nonnull Index index) {\n+        return store.getUntypedRecordStore().indexBuildSubspace(index).subspace(Tuple.from(INDEX_BUILD_LOCK_KEY));\n+    }\n+\n+    @Nonnull\n+    protected static Subspace indexBuildScannedRecordsSubspace(@Nonnull FDBRecordStoreBase<?> store, @Nonnull Index index) {\n+        return store.getUntypedRecordStore().indexBuildSubspace(index)\n+                .subspace(Tuple.from(INDEX_BUILD_SCANNED_RECORDS));\n+    }\n+\n+    @Nonnull\n+    protected static Subspace indexBuildTypeSubspace(@Nonnull FDBRecordStoreBase<?> store, @Nonnull Index index) {\n+        return store.getUntypedRecordStore().indexBuildSubspace(index).subspace(Tuple.from(INDEX_BUILD_TYPE_VERSION));\n+    }\n+\n+    @SuppressWarnings(\"squid:S1452\")\n+    protected CompletableFuture<FDBRecordStore> openRecordStore(@Nonnull FDBRecordContext context) {\n+        return common.getRecordStoreBuilder().copyBuilder().setContext(context).openAsync();\n+    }\n+\n+    CompletableFuture<Void> buildIndexAsync(boolean markReadable) {\n+        KeyValueLogMessage message = KeyValueLogMessage.build(\"build index online\",\n+                LogMessageKeys.SHOULD_MARK_READABLE, markReadable);\n+        final CompletableFuture<Void> buildIndexAsyncFuture;\n+        FDBDatabaseRunner runner = common.getRunner();\n+        Index index = common.getIndex();\n+        if (common.isUseSynchronizedSession()) {\n+            buildIndexAsyncFuture = runner\n+                    .runAsync(context -> openRecordStore(context).thenApply(store -> indexBuildLockSubspace(store, index)))\n+                    .thenCompose(lockSubspace -> runner.startSynchronizedSessionAsync(lockSubspace, common.getLeaseLengthMillis()))\n+                    .thenCompose(synchronizedRunner -> {\n+                        message.addKeyAndValue(LogMessageKeys.SESSION_ID, synchronizedRunner.getSessionId());\n+                        return runWithSynchronizedRunnerAndEndSession(synchronizedRunner,\n+                                () -> handleStateAndDoBuildIndexAsync(markReadable, message));\n+                    });\n+        } else {\n+            message.addKeyAndValue(LogMessageKeys.SESSION_ID, \"none\");\n+            common.setSynchronizedSessionRunner(null);\n+            buildIndexAsyncFuture = handleStateAndDoBuildIndexAsync(markReadable, message);\n+        }\n+        return buildIndexAsyncFuture.whenComplete((vignore, ex) -> {\n+            if (LOGGER.isWarnEnabled() && (ex != null)) {\n+                message.addKeyAndValue(LogMessageKeys.RESULT, \"failure\");\n+                LOGGER.warn(message.toString(), ex);\n+            } else if (LOGGER.isInfoEnabled()) {\n+                message.addKeyAndValue(LogMessageKeys.RESULT, \"success\");\n+                LOGGER.info(message.toString());\n+            }\n+        });\n+    }\n+\n+    private <T> CompletableFuture<T> runWithSynchronizedRunnerAndEndSession(\n+            @Nonnull SynchronizedSessionRunner newSynchronizedRunner, @Nonnull Supplier<CompletableFuture<T>> runnable) {\n+        final SynchronizedSessionRunner currentSynchronizedRunner1 = common.getSynchronizedSessionRunner();\n+        if (currentSynchronizedRunner1 == null) {\n+            common.setSynchronizedSessionRunner(newSynchronizedRunner);\n+            return MoreAsyncUtil.composeWhenComplete(runnable.get(), (result, ex) -> {\n+                final SynchronizedSessionRunner currentSynchronizedRunner2 = common.getSynchronizedSessionRunner();\n+                if (newSynchronizedRunner.equals(currentSynchronizedRunner2)) {\n+                    common.setSynchronizedSessionRunner(null);\n+                } else {\n+                    LOGGER.warn(KeyValueLogMessage.of(\"synchronizedSessionRunner was modified during the run\",\n+                            LogMessageKeys.SESSION_ID, newSynchronizedRunner.getSessionId(),\n+                            LogMessageKeys.INDEXER_SESSION_ID, currentSynchronizedRunner2 == null ? null : currentSynchronizedRunner2.getSessionId()));\n+                }\n+                return newSynchronizedRunner.endSessionAsync();\n+            }, getRunner().getDatabase()::mapAsyncToSyncException);\n+        } else {\n+            return newSynchronizedRunner.endSessionAsync().thenApply(vignore -> {\n+                throw new RecordCoreException(\"another synchronized session is running on the indexer\",\n+                        LogMessageKeys.SESSION_ID, newSynchronizedRunner.getSessionId(),\n+                        LogMessageKeys.INDEXER_SESSION_ID, currentSynchronizedRunner1.getSessionId());\n+            });\n+        }\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> handleStateAndDoBuildIndexAsync(boolean markReadable, KeyValueLogMessage message) {\n+\n+        OnlineIndexer.IndexStatePrecondition indexStatePrecondition = common.getIndexStatePrecondition();\n+        message.addKeyAndValue(LogMessageKeys.INDEX_STATE_PRECONDITION, indexStatePrecondition);\n+        if (indexStatePrecondition == OnlineIndexer.IndexStatePrecondition.ERROR_IF_DISABLED_CONTINUE_IF_WRITE_ONLY) {\n+            message.addKeyAndValue(LogMessageKeys.SHOULD_BUILD_INDEX, true);\n+            return doBuildIndexAsync(markReadable);\n+        }\n+        final Index index = common.getIndex();\n+        return getRunner().runAsync(context -> openRecordStore(context).thenCompose(store -> {\n+            IndexState indexState = store.getIndexState(index);\n+            boolean shouldBuild = shouldBuildIndex(indexState, indexStatePrecondition);\n+            message.addKeyAndValue(LogMessageKeys.INITIAL_INDEX_STATE, indexState);\n+            message.addKeyAndValue(LogMessageKeys.SHOULD_BUILD_INDEX, shouldBuild);\n+            if (shouldBuild) {\n+                boolean shouldClear = shouldClearExistingIndexEntries(indexState, indexStatePrecondition);\n+                message.addKeyAndValue(LogMessageKeys.SHOULD_CLEAR_EXISTING_DATA, shouldClear);\n+                if (shouldClear) {\n+                    store.clearIndexData(index);\n+                }\n+                return store.markIndexWriteOnly(index).thenApply(vignore -> true);\n+            } else {\n+                return AsyncUtil.READY_FALSE;\n+            }\n+        })).thenCompose(shouldBuild -> shouldBuild != null && shouldBuild ? doBuildIndexAsync(markReadable) : AsyncUtil.DONE);\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    private boolean shouldBuildIndex(@Nonnull IndexState indexState, @Nonnull OnlineIndexer.IndexStatePrecondition indexStatePrecondition) {\n+        switch (indexStatePrecondition) {\n+            case BUILD_IF_DISABLED:\n+                return indexState == IndexState.DISABLED;\n+\n+            case BUILD_IF_DISABLED_CONTINUE_BUILD_IF_WRITE_ONLY:\n+            case BUILD_IF_DISABLED_REBUILD_IF_WRITE_ONLY:\n+                return indexState == IndexState.DISABLED || indexState == IndexState.WRITE_ONLY;\n+\n+            case FORCE_BUILD:\n+                return true;\n+\n+            default:\n+                throw new RecordCoreException(\"unknown index state precondition \" + indexStatePrecondition);\n+        }\n+    }\n+\n+    private boolean shouldClearExistingIndexEntries(@Nonnull IndexState indexState,\n+                                                    @Nonnull OnlineIndexer.IndexStatePrecondition indexStatePrecondition) {\n+        // If the index state is DISABLED, it is expected that there is no existing index entry. But we would like\n+        // to clear it anyway to play safe.\n+        return !(indexState == IndexState.WRITE_ONLY && indexStatePrecondition.isContinueIfWriteOnly());\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<Void> doBuildIndexAsync(boolean markReadable) {\n+        CompletableFuture<Void> buildFuture = buildIndexByEntityAsync();\n+\n+        if (markReadable) {\n+            return buildFuture.thenCompose(vignore ->\n+                    getRunner().runAsync(context -> openRecordStore(context)\n+                            .thenCompose(store -> store.markIndexReadable(common.getIndex()))\n+                            .thenApply(ignore -> null)));\n+        } else {\n+            return buildFuture;\n+        }\n+    }\n+\n+    abstract CompletableFuture<Void> buildIndexByEntityAsync();\n+\n+    protected boolean shouldLogBuildProgress() {\n+        long interval = common.config.getProgressLogIntervalMillis();\n+        long now = System.currentTimeMillis();\n+        if (interval == 0 || interval < (now - timeOfLastProgressLogMillis)) {\n+            return false;\n+        }\n+        timeOfLastProgressLogMillis = now;\n+        return true;\n+    }\n+\n+    public int getLimit() {\n+        // made public to support tests\n+        return throttle.getLimit();\n+    }\n+\n+    protected CompletableFuture<Boolean> throttleDelay() {\n+        int limit = getLimit();\n+        int recordsPerSecond = common.config.getRecordsPerSecond();\n+        int toWait = (recordsPerSecond == IndexingCommon.UNLIMITED) ? 0 : 1000 * limit / recordsPerSecond;\n+        return MoreAsyncUtil.delayedFuture(toWait, TimeUnit.MILLISECONDS).thenApply(vignore3 -> true);\n+    }\n+\n+\n+    public <R> CompletableFuture<R> buildCommitRetryAsync(@Nonnull BiFunction<FDBRecordStore, AtomicLong, CompletableFuture<R>> buildFunction,\n+                                                          boolean limitControl,\n+                                                          @Nullable List<Object> additionalLogMessageKeyValues) {\n+\n+        return throttle.buildCommitRetryAsync(buildFunction, limitControl, additionalLogMessageKeyValues);\n+    }\n+\n+    private static void timerIncrement(@Nullable FDBStoreTimer timer, FDBStoreTimer.Counts event) {\n+        // helper function to reduce complexity\n+        if (timer != null) {\n+            timer.increment(event);\n+        }\n+    }\n+\n+    private static CompletableFuture<Void> updateMaintainerBuilder(SyntheticRecordFromStoredRecordPlan syntheticPlan,\n+                                                                   FDBStoredRecord<Message> rec,\n+                                                                   IndexMaintainer maintainer,\n+                                                                   FDBRecordStore store) {\n+        // helper function to reduce complexity\n+        if (syntheticPlan == null) {\n+            return maintainer.update(null, rec);\n+        }\n+        // Pipeline size is 1, since not all maintainers are thread-safe.\n+        return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n+    }\n+\n+    protected <T> CompletableFuture<Void> iterateRangeOnly(@Nonnull FDBRecordStore store,\n+                                                           @Nonnull RecordCursor<T> cursor,\n+                                                           @Nonnull Function<RecordCursorResult<T>, FDBStoredRecord<Message>> getRecord,\n+                                                           @Nonnull Consumer<RecordCursorResult<T>> lastResultSet,\n+                                                           @Nonnull AtomicBoolean isEmpty,\n+                                                           @Nonnull AtomicLong recordsScannedCounter) {\n+        final FDBStoreTimer timer = getRunner().getTimer();\n+        final Index index = common.getIndex();\n+        final IndexMaintainer maintainer = store.getIndexMaintainer(index);\n+        final boolean isIdempotent = maintainer.isIdempotent();\n+        final FDBRecordContext context = store.getContext();\n+        final SyntheticRecordFromStoredRecordPlan syntheticPlan = common.getSyntheticPlan(store);\n+        // Need to do this each transaction because other index enabled state might have changed. Could cache based on that.\n+        // Copying the state also guards against changes made by other online building from check version.\n+        // TODO: need some state to avoid generating the same synthetic record via more than one self-join path for non-idempotent indexes.\n+\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                timerIncrement(timer, FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGES_BY_COUNT);\n+                lastResultSet.accept(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n+            final FDBStoredRecord<Message> rec = getRecord.apply(result);\n+            isEmpty.set(false);\n+            timerIncrement(timer, FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n+            recordsScannedCounter.incrementAndGet();\n+            if (!common.recordTypes.contains(rec.getRecordType())) {\n+                // This record is not our type, swipe left\n+                return AsyncUtil.READY_TRUE;\n+            }\n+            // add this index to the transaction\n+            if (isIdempotent) {\n+                store.addRecordReadConflict(rec.getPrimaryKey());\n+            }\n+            timerIncrement(timer, FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n+\n+            final CompletableFuture<Void> updateMaintainer = updateMaintainerBuilder(syntheticPlan, rec, maintainer, store);\n+\n+            return updateMaintainer.thenCompose(vignore ->\n+                    context.getApproximateTransactionSize().thenApply(size -> {\n+                        if (size >= common.config.getMaxWriteLimitBytes()) {\n+                            // the transaction becomes too big - stop iterating\n+                            timerIncrement(timer, FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGES_BY_SIZE);\n+                            lastResultSet.accept(result);\n+                            return false;\n+                        }\n+                        return true;\n+                    }));\n+\n+        }), cursor.getExecutor());\n+    }\n+\n+    @Nonnull\n+    public CompletableFuture<Void> rebuildIndexAsync(@Nonnull FDBRecordStore store) {\n+        Index index = common.getIndex();\n+        Transaction tr = store.ensureContextActive();\n+        store.clearIndexData(index);\n+\n+        // Clear the associated range set (done as part of clearIndexData above) and make it instead equal to\n+        // the complete range. This isn't super necessary, but it is done\n+        // to avoid (1) concurrent OnlineIndexBuilders doing more work and\n+        // (2) to allow for write-only indexes to continue to do the right thing.\n+        RangeSet rangeSet = new RangeSet(store.indexRangeSubspace(index));\n+        CompletableFuture<Boolean> rangeFuture = rangeSet.insertRange(tr, null, null);\n+        CompletableFuture<Void> buildFuture = rebuildIndexByEntityAsync(store);\n+\n+        return CompletableFuture.allOf(rangeFuture, buildFuture);\n+    }\n+\n+    abstract CompletableFuture<Void> rebuildIndexByEntityAsync(FDBRecordStore store);\n+\n+    // test support", "originalCommit": "fd6ae8830e60f880c835bafdb9f81c7a48d23015", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE0MzgwMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r561143803", "bodyText": "It needs more detailed explanation but we can wait for next PR.", "author": "nblintao", "createdAt": "2021-01-20T17:26:47Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingByIndex.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * OnlineIndexerByIndex.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.MutationType;\n+import com.apple.foundationdb.TransactionContext;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.RangeSet;\n+import com.apple.foundationdb.record.ExecuteProperties;\n+import com.apple.foundationdb.record.IndexScanType;\n+import com.apple.foundationdb.record.IsolationLevel;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorResult;\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.RecordMetaDataProvider;\n+import com.apple.foundationdb.record.ScanProperties;\n+import com.apple.foundationdb.record.TupleRange;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.MetaDataException;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.subspace.Subspace;\n+import com.apple.foundationdb.tuple.ByteArrayUtil2;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.google.protobuf.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * This indexer scans records by a source index.", "originalCommit": "fd6ae8830e60f880c835bafdb9f81c7a48d23015", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE2MjU0MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1079#discussion_r561162540", "bodyText": "Also here.", "author": "nblintao", "createdAt": "2021-01-20T17:56:08Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingThrottle.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * OnlineIndexerThrottle.java", "originalCommit": "fd6ae8830e60f880c835bafdb9f81c7a48d23015", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6bdc34b6e1e6925eaf389e23ca02ae58eb7e1ac2", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/6bdc34b6e1e6925eaf389e23ca02ae58eb7e1ac2", "message": "Apply Tao's requested changes", "committedDate": "2021-01-20T20:03:37Z", "type": "commit"}]}