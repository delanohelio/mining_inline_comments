{"pr_number": 938, "pr_title": "Resolves #937: Merge PlannerExpression and RelationalPlannerExpression", "pr_createdAt": "2020-05-07T18:58:49Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/938", "timeline": [{"oid": "63149e7892ab16072aef508cdcdd9bef89b65cbb", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/63149e7892ab16072aef508cdcdd9bef89b65cbb", "message": "Remove PlannerExpression from QueryComponent.", "committedDate": "2020-05-04T16:18:38Z", "type": "commit"}, {"oid": "86ffe5c129f985dcc48f740f3ccba0565f5a4515", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/86ffe5c129f985dcc48f740f3ccba0565f5a4515", "message": "Remove PlannerExpression from QueryPredicate.\n\nAdd new matchers for QueryPredicates outside of the PlannerExpression\ngraph.", "committedDate": "2020-05-04T16:18:43Z", "type": "commit"}, {"oid": "027ff80ff1e2b04a894ef5c67b80f01429804423", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/027ff80ff1e2b04a894ef5c67b80f01429804423", "message": "Eliminate SingleExpressionRef and MutableExpressionRef.", "committedDate": "2020-05-04T16:18:43Z", "type": "commit"}, {"oid": "29889596bd400bab9953863431f9b1b40d31077b", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/29889596bd400bab9953863431f9b1b40d31077b", "message": "Resolves #937: Merge RelationalPlannerExpression and PlannerExpression.", "committedDate": "2020-05-07T18:55:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc3MTM3Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r421771372", "bodyText": "Should this be removed entirely?", "author": "ScottDugas", "createdAt": "2020-05-07T20:23:39Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/query/plan/temp/matchers/ExpressionMatcherTest.java", "diffHunk": "@@ -61,11 +61,10 @@\n public class ExpressionMatcherTest {\n     private static List<ExpressionMatcher<? extends Bindable>> existingMatchers = ImmutableList.of(\n             TypeMatcher.of(RecordQueryIndexPlan.class),\n-            TypeMatcher.of(QueryComponent.class),\n             TypeMatcher.of(RelationalPlannerExpression.class));\n     private static List<Bindable> existingBindables = ImmutableList.of(\n             new RecordQueryIndexPlan(\"fake_index\", IndexScanType.BY_VALUE, ScanComparisons.EMPTY, false),\n-            Query.field(\"fake_field\").equalsParameter(\"x\"),\n+            //Query.field(\"fake_field\").equalsParameter(\"x\"),", "originalCommit": "63149e7892ab16072aef508cdcdd9bef89b65cbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMwMzYyNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r423303626", "bodyText": "Yes, removed.", "author": "nschiefer", "createdAt": "2020-05-11T20:35:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc3MTM3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE3MjgwNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r422172804", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @param <T> tood\n          \n          \n            \n             * @param <T> the type of {@link RelationalExpressionWithPredicate} to match against", "author": "ScottDugas", "createdAt": "2020-05-08T14:24:00Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/matchers/TypeWithPredicateMatcher.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * TypeWithPredicateMatcher.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.matchers;\n+\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerExpression;\n+import com.apple.foundationdb.record.query.plan.temp.PlannerExpressionWithPredicate;\n+import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import java.util.stream.Stream;\n+\n+/**\n+ * TODO.\n+ * @param <T> tood", "originalCommit": "86ffe5c129f985dcc48f740f3ccba0565f5a4515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMwNDQ2OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r423304468", "bodyText": "Whoops \ud83d\ude43. Fixed this, and the comment above.", "author": "nschiefer", "createdAt": "2020-05-11T20:37:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE3MjgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE3OTU1Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r422179556", "bodyText": "This could be PlannerExpressionWithPredicate instead of LogicalFilterExpression, right? But that would require a withOtherPredicate method on PlannerExpressionWithPredicate", "author": "ScottDugas", "createdAt": "2020-05-08T14:35:48Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/FlattenNestedAndPredicateRule.java", "diffHunk": "@@ -56,25 +60,31 @@\n  * </code>\n  */\n @API(API.Status.EXPERIMENTAL)\n-public class FlattenNestedAndPredicateRule extends PlannerRule<AndPredicate> {\n-    private static final ExpressionMatcher<ExpressionRef<QueryPredicate>> andChildrenMatcher = ReferenceMatcher.anyRef();\n-    private static final ReferenceMatcher<QueryPredicate> otherInnerComponentsMatcher = ReferenceMatcher.anyRef();\n-    private static final ExpressionMatcher<AndPredicate> root = TypeMatcher.of(AndPredicate.class,\n-            AnyChildWithRestMatcher.anyMatchingWithRest(\n-                    TypeMatcher.of(AndPredicate.class, AllChildrenMatcher.allMatching(andChildrenMatcher)),\n-                    otherInnerComponentsMatcher));\n+public class FlattenNestedAndPredicateRule extends PlannerRule<LogicalFilterExpression> {\n+    private static final ExpressionMatcher<QueryPredicate> andChildrenMatcher = TypeMatcher.of(QueryPredicate.class, AnyChildrenMatcher.ANY);\n+    private static final ExpressionMatcher<QueryPredicate> otherInnerComponentsMatcher = TypeMatcher.of(QueryPredicate.class, AnyChildrenMatcher.ANY);\n+    private static final ExpressionMatcher<ExpressionRef<RelationalPlannerExpression>> inner = ReferenceMatcher.anyRef();\n+    private static final ExpressionMatcher<LogicalFilterExpression> root = TypeWithPredicateMatcher.ofPredicate(LogicalFilterExpression.class,", "originalCommit": "86ffe5c129f985dcc48f740f3ccba0565f5a4515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMwNDg5MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r423304890", "bodyText": "Yes, it could be (subject to the contrast you described). I'm not sure whether this is desirable but it's worth thinking about in the future.", "author": "nschiefer", "createdAt": "2020-05-11T20:38:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE3OTU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE4NzUyMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r422187522", "bodyText": "The only implementation of this is now GroupExpressionRef right? Is there a reason to keep the interface around?", "author": "ScottDugas", "createdAt": "2020-05-08T14:49:50Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRef.java", "diffHunk": "@@ -32,12 +32,13 @@\n \n /**\n  * This interface is used mostly as an (admittedly surmountable) barrier to rules mutating bound references directly,\n- * which is undefined behavior. Unlike {@link MutableExpressionRef}, it does not provide an <code>insert()</code> method,\n- * so the rule would need to cast the reference back to {@link MutableExpressionRef} before modifying it.\n+ * which is undefined behavior.\n  * @param <T> the type of planner expression that is contained in this reference\n  */\n @API(API.Status.EXPERIMENTAL)\n public interface ExpressionRef<T extends PlannerExpression> extends Bindable {", "originalCommit": "027ff80ff1e2b04a894ef5c67b80f01429804423", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMwNTUyNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r423305526", "bodyText": "Yes, that's right. There's a reason, but it might not be a good one.\nThe reason to keep it is in the Javadoc:\n\nThis interface is used mostly as an (admittedly surmountable) barrier to rules mutating bound references directly.\n\nThe idea is that it provides some kind of discouragement to a rule writer who tries to invoke the various methods in GroupExpressionRef, which will totally confuse the planner. I'm not sure if the overhead is worth it, though.", "author": "nschiefer", "createdAt": "2020-05-11T20:39:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE4NzUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE5NTYxNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r422195614", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * TODO.\n          \n          \n            \n             * Matches against a subclass of {@link RelationalExpressionWithPredicate} with a given matcher against the associated predicate, and a given matcher against the children.", "author": "ScottDugas", "createdAt": "2020-05-08T15:03:29Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/matchers/TypeWithPredicateMatcher.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * TypeWithPredicateMatcher.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.matchers;\n+\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpressionWithPredicate;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import java.util.stream.Stream;\n+\n+/**\n+ * TODO.", "originalCommit": "29889596bd400bab9953863431f9b1b40d31077b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMwNjIzMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r423306231", "bodyText": "Added, thanks.", "author": "nschiefer", "createdAt": "2020-05-11T20:40:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE5NTYxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMTU4OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r422701589", "bodyText": "Consider to have a List<QueryPredicate> here. I am assuming that ANDs are just encoded within the QueryPredicate, but it seems to be a nice property to be a able to move the AND terms underneath around into other RelationExpressions. Sometimes, it might be even beneficial to move these terms into multiple expressions where a QueryPredicate term can exist and (e.g. for reapplication purposes, etc.). In those cases it would become necessary to relate those QueryPredicate instances in some way and having a list of AND terms here let's you do that just easier I think.", "author": "normen662", "createdAt": "2020-05-10T21:16:36Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpressionWithPredicate.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * RelationalExpressionWithPredicate.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n+\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * A (relational) expression that has a predicate on it.\n+ */\n+public interface RelationalExpressionWithPredicate extends RelationalExpression {\n+    @Nonnull\n+    QueryPredicate getPredicate();", "originalCommit": "29889596bd400bab9953863431f9b1b40d31077b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMwODgyNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r423308827", "bodyText": "Yes, AND here is encoded using AndPredicate.\nI agree that it would be pretty nice to have an \"implicit top-level AND\". In particular, it would let us get rid of the conjunct/non-conjunct distinction in the planner rules.\nFor the sake of review, I'd like to make this a follow-up PR (which should be fairly short and focussed). I created #939 to track this.", "author": "nschiefer", "createdAt": "2020-05-11T20:45:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMTU4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjE0Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r422702143", "bodyText": "Shouldn't this be done for Bindable? I mean you do allow T extends Bindable in the class definition, contains() for a Bindable that is no. RelationalExpression would always be `false.", "author": "normen662", "createdAt": "2020-05-10T21:21:36Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/PlannerExpressionPointerSet.java", "diffHunk": "@@ -55,10 +55,10 @@ public void addAll(@Nonnull PlannerExpressionPointerSet<T> otherSet) {\n \n     @Override\n     public boolean contains(Object o) {\n-        if (!(o instanceof PlannerExpression)) { // also handles null check\n+        if (!(o instanceof RelationalExpression)) { // also handles null check\n             return false;\n         } else {\n-            return members.contains(new Wrapper<>((PlannerExpression) o));\n+            return members.contains(new Wrapper<>((RelationalExpression) o));", "originalCommit": "29889596bd400bab9953863431f9b1b40d31077b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMwOTg5OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r423309899", "bodyText": "Ah, good catch! This is only used to implement the Memo data structure, so it should really only contain things that can be memoized (i.e., RelationalExpressions). This looks like an artifact of how I did my (largely automated) refactoring. I've changed it here and verified that the code still builds.", "author": "nschiefer", "createdAt": "2020-05-11T20:47:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjE0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjY3Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r422702676", "bodyText": "Consider renaming!", "author": "normen662", "createdAt": "2020-05-10T21:26:24Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/PlannerExpressionPointerSet.java", "diffHunk": "@@ -27,12 +27,12 @@\n import java.util.Set;\n \n /**\n- * A set of {@link PlannerExpression}s that uses reference (\"pointer\") equality to determine equivalence for the\n+ * A set of {@link RelationalExpression}s that uses reference (\"pointer\") equality to determine equivalence for the\n  * purposes of set membership, rather than the {@link #equals(Object)} method used by the Java {@link Set} interface.\n  * This is important for implementing the memo data structure in {@link GroupExpressionRef}\n  * @param <T> the planner expression type contained in the set\n  */\n-public class PlannerExpressionPointerSet<T extends PlannerExpression> extends AbstractCollection<T> {\n+public class PlannerExpressionPointerSet<T extends Bindable> extends AbstractCollection<T> {", "originalCommit": "29889596bd400bab9953863431f9b1b40d31077b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMxMDI3Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r423310272", "bodyText": "Good idea! Changed to RelationalExpressionPointerSet.", "author": "nschiefer", "createdAt": "2020-05-11T20:48:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMzIwOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r422703208", "bodyText": "This is a general comment re: this class. Consider using Guava Equivalence class, which comes with a subclass Equivalence.Identity which I think would eliminate the reason for the Wrapper class. Also, there is IdentityHashMap which can help here.", "author": "normen662", "createdAt": "2020-05-10T21:31:14Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/PlannerExpressionPointerSet.java", "diffHunk": "@@ -27,12 +27,12 @@\n import java.util.Set;\n \n /**\n- * A set of {@link PlannerExpression}s that uses reference (\"pointer\") equality to determine equivalence for the", "originalCommit": "29889596bd400bab9953863431f9b1b40d31077b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMxMjM3Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r423312372", "bodyText": "Ah, thanks for the pointer (pun somewhat intended)! I remember looking for this a long time ago and not finding it, but clearly my Google-fu was inadequate.\nI would rather do this in another PR, so I filed #940 to track this work.", "author": "nschiefer", "createdAt": "2020-05-11T20:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMzIwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMzY3MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r422703671", "bodyText": "How do you now explore the e.g. QueryPredicate expressions hanging off RelationalExpressions?", "author": "normen662", "createdAt": "2020-05-10T21:35:18Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/GroupExpressionPrinter.java", "diffHunk": "@@ -81,23 +81,23 @@ public String toString() {\n         return builder.toString();\n     }\n \n-    private void exploreGroup(@Nonnull ExpressionRef<? extends PlannerExpression> ref) {\n+    private void exploreGroup(@Nonnull ExpressionRef<? extends RelationalExpression> ref) {\n         if (!(ref instanceof GroupExpressionRef)) {\n             throw new RecordCoreException(\"tried to print a non-group reference with the GroupExpressionPrinter\");\n         }\n-        GroupExpressionRef<? extends PlannerExpression> groupRef = (GroupExpressionRef<? extends PlannerExpression>) ref;\n+        GroupExpressionRef<? extends RelationalExpression> groupRef = (GroupExpressionRef<? extends RelationalExpression>) ref;\n         seenGroups.put(groupRef, nextId);\n         groups.add(groupRef);\n         nextId++;\n-        for (PlannerExpression member : groupRef.getMembers()) {\n+        for (RelationalExpression member : groupRef.getMembers()) {\n             exploreExpression(member);\n         }\n     }\n \n-    private void exploreExpression(@Nonnull PlannerExpression expression) {", "originalCommit": "29889596bd400bab9953863431f9b1b40d31077b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMxMzA1Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r423313052", "bodyText": "We don't. If we wanted to do that, we'd need to write this as a rule on a RelationalExpressionWithPredicate and then manipulate the QueryPredicate manually. We can consider adding custom logic for exploring predicates (but without memoization?) in the future, I suppose.", "author": "nschiefer", "createdAt": "2020-05-11T20:53:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMzY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMzkxMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r422703910", "bodyText": "Will we not ever descend into predicates, etc.?", "author": "normen662", "createdAt": "2020-05-10T21:37:32Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/CascadesPlanner.java", "diffHunk": "@@ -268,7 +267,7 @@ public void execute() {\n             getRules().getRulesMatching(expression).forEachRemaining(this::addTransformTask);\n \n             final PlanContext relativeContext = context;\n-            Iterator<? extends ExpressionRef<? extends PlannerExpression>> expressionChildren = expression.getPlannerExpressionChildren();\n+            Iterator<? extends ExpressionRef<? extends RelationalExpression>> expressionChildren = expression.getPlannerExpressionChildren();", "originalCommit": "29889596bd400bab9953863431f9b1b40d31077b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMxMzIzMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r423313233", "bodyText": "Correct, because we can't memoize them after this change.", "author": "nschiefer", "createdAt": "2020-05-11T20:53:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMzkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwNjMxMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r422706313", "bodyText": "use unqualified names if possible", "author": "normen662", "createdAt": "2020-05-10T22:00:00Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/matchers/PlannerBindings.java", "diffHunk": "@@ -32,10 +31,10 @@\n \n /**\n  * A map-like structure that supports a map from a binding to a collection of {@link Bindable}s, such as\n- * {@link PlannerExpression}s and {@link ExpressionRef}s. A binding's key is a pointer to the {@link ExpressionMatcher}\n- * that created the binding, eliminating the need for a unique string or symbol identifier. A {@code PlannerBindings}\n- * is immutable but has a {@link Builder} that can be used to build up a set of bindings incrementally. Additionally,\n- * bindings can be combined using {@link #mergedWith(PlannerBindings)}.\n+ * {@link com.apple.foundationdb.record.query.plan.temp.RelationalExpression}s and {@link ExpressionRef}s. A binding's", "originalCommit": "29889596bd400bab9953863431f9b1b40d31077b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMxNDAwMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r423314003", "bodyText": "Our style checker requires us to use qualified names here because RelationalExpression is in a different package. If we import it but only use it in a Javadoc, the unused import linter rule gets upset.\nI'd love for this to be fixed, but I wasn't successful last time I tried (some years ago).", "author": "nschiefer", "createdAt": "2020-05-11T20:55:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwNjMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwNjMzOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r422706339", "bodyText": "Same here.", "author": "normen662", "createdAt": "2020-05-10T22:00:11Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/matchers/PlannerBindings.java", "diffHunk": "@@ -83,8 +82,8 @@ public boolean containsKey(@Nonnull ExpressionMatcher<? extends Bindable> key) {\n \n     /**\n      * Retrieve all bindables bound to {@code key} if there is at least one such bindable. The bindables in the returned\n-     * list appear in same order as they appear in the list of children of the {@link PlannerExpression} that produced\n-     * this set of bindings. If no bindable is bound to this key, throw a {@link NoSuchElementException}.\n+     * list appear in same order as they appear in the list of children of the {@link com.apple.foundationdb.record.query.plan.temp.RelationalExpression}", "originalCommit": "29889596bd400bab9953863431f9b1b40d31077b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMxNDA1Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r423314057", "bodyText": "See above.", "author": "nschiefer", "createdAt": "2020-05-11T20:55:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwNjMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwODU2OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r422708568", "bodyText": "This seems to contradict with the purpose of the property as stated in the java doc of the class. Are you counting QueryComponent or QueryPredicate?", "author": "normen662", "createdAt": "2020-05-10T22:21:00Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/properties/PredicateHeightProperty.java", "diffHunk": "@@ -42,30 +42,30 @@\n     private static final PredicateHeightProperty INSTANCE = new PredicateHeightProperty();\n \n     @Override\n-    public boolean shouldVisit(@Nonnull PlannerExpression expression) {\n+    public boolean shouldVisit(@Nonnull RelationalExpression expression) {\n         return true;\n     }\n \n     @Override\n-    public boolean shouldVisit(@Nonnull ExpressionRef<? extends PlannerExpression> ref) {\n+    public boolean shouldVisit(@Nonnull ExpressionRef<? extends RelationalExpression> ref) {\n         return true;\n     }\n \n     @Nonnull\n     @Override\n-    public Integer evaluateAtExpression(@Nonnull PlannerExpression expression, @Nonnull List<Integer> childResults) {\n+    public Integer evaluateAtExpression(@Nonnull RelationalExpression expression, @Nonnull List<Integer> childResults) {\n         int maxChildDepth = 0;\n         for (Integer childDepth : childResults) {\n             if (childDepth != null && childDepth > maxChildDepth) {\n                 maxChildDepth = childDepth;\n             }\n         }\n-        return maxChildDepth + (expression instanceof QueryPredicate ? 1 : 0);", "originalCommit": "29889596bd400bab9953863431f9b1b40d31077b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMxNDUwNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/938#discussion_r423314505", "bodyText": "Ah, good point. If we wanted to implement this, we couldn't use the infrastructure for PlannerProperty anymore.\nOn the other hand, it looks like this is dead code, so I've deleted it instead.", "author": "nschiefer", "createdAt": "2020-05-11T20:56:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwODU2OA=="}], "type": "inlineReview"}, {"oid": "7817102db464fd2d6f621eba0bcab06cf1f5c50b", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/7817102db464fd2d6f621eba0bcab06cf1f5c50b", "message": "Respond to reviewer comments.", "committedDate": "2020-05-11T21:06:50Z", "type": "commit"}]}