{"pr_number": 879, "pr_title": "Resolves #866: Replace some aggregate metrics with accurate counters", "pr_createdAt": "2020-03-27T15:54:02Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/879", "timeline": [{"oid": "6f374f884f70cbaa4c2ab1d2d6c49a39ff340f39", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/6f374f884f70cbaa4c2ab1d2d6c49a39ff340f39", "message": "Resolves #866: Replace some aggregate metrics with accurate counters", "committedDate": "2020-03-27T16:25:06Z", "type": "forcePushed"}, {"oid": "1d9430155e620563859f41be886514399ef3a881", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/1d9430155e620563859f41be886514399ef3a881", "message": "Resolves #866: Replace some aggregate metrics with accurate counters", "committedDate": "2020-03-27T16:29:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2NjgyMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r399366821", "bodyText": "The original method probably should never have been public.  Should this one be protected at least?", "author": "scgray", "createdAt": "2020-03-27T15:55:04Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBDatabase.java", "diffHunk": "@@ -717,15 +718,48 @@ protected Executor newContextExecutor() {\n         return factory.newContextExecutor();\n     }\n \n+    /**\n+     * Creates a new transaction against the database.\n+     *\n+     * @param executor the executor to be used for asynchronous operations\n+     * @param mdcContext if not [@code null} and tracing is enabled, information in the context will be included\n+     *      in tracing log messages\n+     * @param transactionIsTraced if true, the transaction will produce tracing messages (for example, logging when\n+     *      the transaction is cleaned up without having been closed)\n+     * @return newly created transaction\n+     * @deprecated use {@link #createTransaction(Executor, StoreTimer, Map, boolean)} instead\n+     */\n+    @Deprecated\n+    @API(API.Status.DEPRECATED)\n     public Transaction createTransaction(Executor executor, @Nullable Map<String, String> mdcContext, boolean transactionIsTraced) {\n+        return createTransaction(executor, null, mdcContext, transactionIsTraced);\n+    }\n+\n+    /**\n+     * Creates a new transaction against the database.\n+     *\n+     * @param executor the executor to be used for asynchronous operations\n+     * @param storeTimer if not {@code null}, will be used too track low level operations (e.g. reads/writes/deletes)\n+     * @param mdcContext if not [@code null} and tracing is enabled, information in the context will be included\n+     *      in tracing log messages\n+     * @param transactionIsTraced if true, the transaction will produce tracing messages (for example, logging when\n+     *      the transaction is cleaned up without having been closed)\n+     * @return newly created transaction\n+     */\n+    public Transaction createTransaction(Executor executor, @Nullable StoreTimer storeTimer, @Nullable Map<String, String> mdcContext, boolean transactionIsTraced) {", "originalCommit": "9c7fcf88b03e0e0036dfe980854607df49d5cb03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUyNzY4Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r399527682", "bodyText": "Yeah, I think either protected or private, even. Then the deprecation warning on the other method should tell people to use openContext or whatever it's called.", "author": "alecgrieser", "createdAt": "2020-03-27T20:42:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2NjgyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDE3MDUxNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r400170516", "bodyText": "Done.  I also did some minor refactoring of how the FDBRecordContext is created.", "author": "scgray", "createdAt": "2020-03-30T12:59:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2NjgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3ODg1MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r399378850", "bodyText": "As noted, do we want per-mutation type counters as well? Obviously can always come later...", "author": "scgray", "createdAt": "2020-03-27T16:12:49Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/InstrumentedTransaction.java", "diffHunk": "@@ -0,0 +1,401 @@\n+/*\n+ * InstrumentedTransaction.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.Database;\n+import com.apple.foundationdb.FDBException;\n+import com.apple.foundationdb.KeySelector;\n+import com.apple.foundationdb.KeyValue;\n+import com.apple.foundationdb.MutationType;\n+import com.apple.foundationdb.Range;\n+import com.apple.foundationdb.ReadTransaction;\n+import com.apple.foundationdb.StreamingMode;\n+import com.apple.foundationdb.Transaction;\n+import com.apple.foundationdb.TransactionOptions;\n+import com.apple.foundationdb.async.AsyncIterable;\n+import com.apple.foundationdb.async.AsyncIterator;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.record.provider.common.StoreTimer;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.Spliterator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * Wrapper around {@link Transaction} that instruments certain calls to expose their behavior with\n+ * {@link FDBStoreTimer} metrics.\n+ */\n+public class InstrumentedTransaction implements Transaction {\n+\n+    @Nullable\n+    protected StoreTimer timer;\n+    protected Transaction underlying;\n+\n+    public InstrumentedTransaction(@Nullable StoreTimer timer, Transaction underlying) {\n+        this.timer = timer;\n+        this.underlying = underlying;\n+    }\n+\n+    @Override\n+    public void addReadConflictRange(byte[] keyBegin, byte[] keyEnd) {\n+        underlying.addReadConflictRange(keyBegin, keyEnd);\n+    }\n+\n+    @Override\n+    public void addReadConflictKey(byte[] key) {\n+        underlying.addReadConflictKey(key);\n+    }\n+\n+    @Override\n+    public void addWriteConflictRange(byte[] keyBegin, byte[] keyEnd) {\n+        underlying.addWriteConflictRange(keyBegin, keyEnd);\n+    }\n+\n+    @Override\n+    public void addWriteConflictKey(byte[] key) {\n+        underlying.addWriteConflictKey(key);\n+    }\n+\n+    @Override\n+    public void set(byte[] key, byte[] value) {\n+        underlying.set(key, value);\n+        increment(FDBStoreTimer.Counts.WRITES, FDBStoreTimer.Counts.BYTES_WRITTEN, key.length + value.length);\n+    }\n+\n+    @Override\n+    public void clear(byte[] key) {\n+        underlying.clear(key);\n+        increment(FDBStoreTimer.Counts.DELETES);\n+    }\n+\n+    @Override\n+    public void clear(byte[] keyBegin, byte[] keyEnd) {\n+        underlying.clear(keyBegin, keyEnd);\n+        increment(FDBStoreTimer.Counts.DELETES);\n+    }\n+\n+    @Override\n+    public void clear(Range range) {\n+        underlying.clear(range);\n+        increment(FDBStoreTimer.Counts.DELETES);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void clearRangeStartsWith(byte[] prefix) {\n+        underlying.clearRangeStartsWith(prefix);\n+        increment(FDBStoreTimer.Counts.DELETES);\n+    }\n+\n+    @Override\n+    public void mutate(MutationType opType, byte[] key, byte[] param) {\n+        underlying.mutate(opType, key, param);\n+        /* Do we want to track each mutation type separately as well? */", "originalCommit": "9c7fcf88b03e0e0036dfe980854607df49d5cb03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYxNDU4OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r399614588", "bodyText": "I think this is probably fine for now. Maybe some day, though.", "author": "alecgrieser", "createdAt": "2020-03-28T03:44:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3ODg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM5MTQ4MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r399391480", "bodyText": "As noted, for these iterators, they are being counted a single read. Is this ok?  Can we do better?", "author": "scgray", "createdAt": "2020-03-27T16:31:56Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/InstrumentedTransaction.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * InstrumentedTransaction.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.Database;\n+import com.apple.foundationdb.FDBException;\n+import com.apple.foundationdb.KeySelector;\n+import com.apple.foundationdb.KeyValue;\n+import com.apple.foundationdb.MutationType;\n+import com.apple.foundationdb.Range;\n+import com.apple.foundationdb.ReadTransaction;\n+import com.apple.foundationdb.StreamingMode;\n+import com.apple.foundationdb.Transaction;\n+import com.apple.foundationdb.TransactionOptions;\n+import com.apple.foundationdb.async.AsyncIterable;\n+import com.apple.foundationdb.async.AsyncIterator;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.record.provider.common.StoreTimer;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.Spliterator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * Wrapper around {@link Transaction} that instruments certain calls to expose their behavior with\n+ * {@link FDBStoreTimer} metrics.\n+ */\n+public class InstrumentedTransaction implements Transaction {\n+\n+    @Nonnull\n+    protected StoreTimer timer;\n+    @Nonnull\n+    protected Transaction underlying;\n+\n+    public InstrumentedTransaction(@Nonnull StoreTimer timer, @Nonnull Transaction underlying) {\n+        this.timer = timer;\n+        this.underlying = underlying;\n+    }\n+\n+    @Override\n+    public void addReadConflictRange(byte[] keyBegin, byte[] keyEnd) {\n+        underlying.addReadConflictRange(keyBegin, keyEnd);\n+    }\n+\n+    @Override\n+    public void addReadConflictKey(byte[] key) {\n+        underlying.addReadConflictKey(key);\n+    }\n+\n+    @Override\n+    public void addWriteConflictRange(byte[] keyBegin, byte[] keyEnd) {\n+        underlying.addWriteConflictRange(keyBegin, keyEnd);\n+    }\n+\n+    @Override\n+    public void addWriteConflictKey(byte[] key) {\n+        underlying.addWriteConflictKey(key);\n+    }\n+\n+    @Override\n+    public void set(byte[] key, byte[] value) {\n+        underlying.set(key, value);\n+        timer.increment(FDBStoreTimer.Counts.WRITES);\n+        timer.increment(FDBStoreTimer.Counts.BYTES_WRITTEN, key.length + value.length);\n+    }\n+\n+    @Override\n+    public void clear(byte[] key) {\n+        underlying.clear(key);\n+        timer.increment(FDBStoreTimer.Counts.DELETES);\n+    }\n+\n+    @Override\n+    public void clear(byte[] keyBegin, byte[] keyEnd) {\n+        underlying.clear(keyBegin, keyEnd);\n+        timer.increment(FDBStoreTimer.Counts.DELETES);\n+    }\n+\n+    @Override\n+    public void clear(Range range) {\n+        underlying.clear(range);\n+        timer.increment(FDBStoreTimer.Counts.DELETES);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void clearRangeStartsWith(byte[] prefix) {\n+        underlying.clearRangeStartsWith(prefix);\n+        timer.increment(FDBStoreTimer.Counts.DELETES);\n+    }\n+\n+    @Override\n+    public void mutate(MutationType opType, byte[] key, byte[] param) {\n+        underlying.mutate(opType, key, param);\n+        /* Do we want to track each mutation type separately as well? */\n+        timer.increment(FDBStoreTimer.Counts.MUTATIONS);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> commit() {\n+        long startTimeNanos = System.nanoTime();\n+        return underlying.commit().whenComplete((v, ex) ->\n+                timer.recordSinceNanoTime(FDBStoreTimer.Events.COMMITS, startTimeNanos));\n+    }\n+\n+    @Override\n+    public Long getCommittedVersion() {\n+        return underlying.getCommittedVersion();\n+    }\n+\n+    @Override\n+    public CompletableFuture<byte[]> getVersionstamp() {\n+        return underlying.getVersionstamp();\n+    }\n+\n+    @Override\n+    public CompletableFuture<Transaction> onError(Throwable throwable) {\n+        return underlying.onError(throwable);\n+    }\n+\n+    @Override\n+    public void cancel() {\n+        underlying.cancel();\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> watch(byte[] bytes) throws FDBException {\n+        return underlying.watch(bytes);\n+    }\n+\n+    @Override\n+    public Database getDatabase() {\n+        return underlying.getDatabase();\n+    }\n+\n+    @Override\n+    public <T> T run(Function<? super Transaction, T> function) {\n+        return function.apply(this);\n+    }\n+\n+    @Override\n+    public <T> CompletableFuture<T> runAsync(Function<? super Transaction, ? extends CompletableFuture<T>> function) {\n+        return AsyncUtil.applySafely(function, this);\n+    }\n+\n+    @Override\n+    public void close() {\n+        underlying.close();\n+    }\n+\n+    @Override\n+    public boolean isSnapshot() {\n+        return underlying.isSnapshot();\n+    }\n+\n+    @Override\n+    public ReadTransaction snapshot() {\n+        return underlying.snapshot();\n+    }\n+\n+    @Override\n+    public CompletableFuture<Long> getReadVersion() {\n+        return underlying.getReadVersion();\n+    }\n+\n+    @Override\n+    public void setReadVersion(long l) {\n+        underlying.setReadVersion(l);\n+    }\n+\n+    @Override\n+    public boolean addReadConflictRangeIfNotSnapshot(byte[] keyBegin, byte[] keyEnd) {\n+        return underlying.addReadConflictRangeIfNotSnapshot(keyBegin, keyEnd);\n+    }\n+\n+    @Override\n+    public boolean addReadConflictKeyIfNotSnapshot(byte[] key) {\n+        return underlying.addReadConflictKeyIfNotSnapshot(key);\n+    }\n+\n+    @Override\n+    public CompletableFuture<byte[]> get(byte[] key) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return underlying.get(key).thenApply(this::recordRead);\n+    }\n+\n+    @Override\n+    public CompletableFuture<byte[]> getKey(KeySelector keySelector) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return underlying.getKey(keySelector).thenApply(this::recordRead);\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(KeySelector begin, KeySelector end) {\n+        /* Should this could as one read? */\n+        timer.increment(FDBStoreTimer.Counts.READS);", "originalCommit": "1d9430155e620563859f41be886514399ef3a881", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7da9b38afdc937a4de597d5997f055952d0e7b5d", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/7da9b38afdc937a4de597d5997f055952d0e7b5d", "message": "Resolves #866: Replace some aggregate metrics with accurate counters", "committedDate": "2020-03-27T20:35:12Z", "type": "forcePushed"}, {"oid": "ded1808beaf1c6fcb792b1bd98431e4e5674e310", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/ded1808beaf1c6fcb792b1bd98431e4e5674e310", "message": "Resolves #866: Replace some aggregate metrics with accurate counters", "committedDate": "2020-03-27T20:54:40Z", "type": "commit"}, {"oid": "ded1808beaf1c6fcb792b1bd98431e4e5674e310", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/ded1808beaf1c6fcb792b1bd98431e4e5674e310", "message": "Resolves #866: Replace some aggregate metrics with accurate counters", "committedDate": "2020-03-27T20:54:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUyODM3OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r399528378", "bodyText": "EventAggregates, we hardly knew ye", "author": "alecgrieser", "createdAt": "2020-03-27T20:44:21Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBStoreTimer.java", "diffHunk": "@@ -238,58 +240,6 @@ public String logKey() {\n         }\n     }\n \n-    /**\n-     * An aggregate over other count events.\n-     */\n-    public enum EventAggregates implements Aggregate, Event {", "originalCommit": "7da9b38afdc937a4de597d5997f055952d0e7b5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDE3MDY5Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r400170692", "bodyText": "Sniff", "author": "scgray", "createdAt": "2020-03-30T12:59:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUyODM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU0MTY3OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r399541678", "bodyText": "Alternatively, I suppose this could be:\nreturn underlying.asList().whenComplete((list, err) -> {\n   if (list != null) {\n       list.forEach(this::recordRead);\n   }\n});\nI think then you don't need to copy things into the intermediate result list? Though it probably doesn't matter much either way.", "author": "alecgrieser", "createdAt": "2020-03-27T21:15:52Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/InstrumentedReadTransaction.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * InstrumentedReadTransaction.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.KeySelector;\n+import com.apple.foundationdb.KeyValue;\n+import com.apple.foundationdb.Range;\n+import com.apple.foundationdb.ReadTransaction;\n+import com.apple.foundationdb.StreamingMode;\n+import com.apple.foundationdb.TransactionOptions;\n+import com.apple.foundationdb.async.AsyncIterable;\n+import com.apple.foundationdb.async.AsyncIterator;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.record.provider.common.StoreTimer;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.function.Function;\n+\n+abstract class InstrumentedReadTransaction<T extends ReadTransaction> implements ReadTransaction {\n+    @Nonnull\n+    protected StoreTimer timer;\n+    @Nonnull\n+    protected T underlying;\n+\n+    public InstrumentedReadTransaction(@Nonnull StoreTimer timer, @Nonnull T underlying) {\n+        this.timer = timer;\n+        this.underlying = underlying;\n+    }\n+\n+    @Override\n+    public boolean isSnapshot() {\n+        return underlying.isSnapshot();\n+    }\n+\n+    @Override\n+    public CompletableFuture<Long> getReadVersion() {\n+        return underlying.getReadVersion();\n+    }\n+\n+    @Override\n+    public void setReadVersion(long l) {\n+        underlying.setReadVersion(l);\n+    }\n+\n+    @Override\n+    public boolean addReadConflictRangeIfNotSnapshot(byte[] keyBegin, byte[] keyEnd) {\n+        return underlying.addReadConflictRangeIfNotSnapshot(keyBegin, keyEnd);\n+    }\n+\n+    @Override\n+    public boolean addReadConflictKeyIfNotSnapshot(byte[] key) {\n+        return underlying.addReadConflictKeyIfNotSnapshot(key);\n+    }\n+\n+    @Override\n+    public CompletableFuture<byte[]> get(byte[] key) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return underlying.get(key).thenApply(this::recordRead);\n+    }\n+\n+    @Override\n+    public CompletableFuture<byte[]> getKey(KeySelector keySelector) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return underlying.getKey(keySelector).thenApply(this::recordRead);\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(KeySelector begin, KeySelector end) {\n+        /* Should this could as one read? */\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(begin, end));\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(KeySelector begin, KeySelector end, int limit) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(begin, end, limit));\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(KeySelector begin, KeySelector end, int limit, boolean reverse) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(begin, end, limit, reverse));\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(KeySelector begin, KeySelector end, int limit, boolean reverse, StreamingMode streamingMode) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(begin, end, limit, reverse, streamingMode));\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(byte[] begin, byte[] end) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(begin, end));\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(byte[] begin, byte[] end, int limit) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(begin, end, limit));\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(byte[] begin, byte[] end, int limit, boolean reverse) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(begin, end, limit, reverse));\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(byte[] begin, byte[] end, int limit, boolean reverse, StreamingMode streamingMode) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(begin, end, limit, reverse, streamingMode));\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(Range range) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(range));\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(Range range, int limit) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(range, limit));\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(Range range, int limit, boolean reverse) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(range, limit, reverse));\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(Range range, int limit, boolean reverse, StreamingMode streamingMode) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(range, limit, reverse, streamingMode));\n+    }\n+\n+    @Override\n+    public TransactionOptions options() {\n+        return underlying.options();\n+    }\n+\n+    @Override\n+    public <T> T read(Function<? super ReadTransaction, T> function) {\n+        return function.apply(this);\n+    }\n+\n+    @Override\n+    public <T> CompletableFuture<T> readAsync(Function<? super ReadTransaction, ? extends CompletableFuture<T>> function) {\n+        return AsyncUtil.applySafely(function, this);\n+    }\n+\n+    @Override\n+    public Executor getExecutor() {\n+        return underlying.getExecutor();\n+    }\n+\n+    @Nullable\n+    protected byte[] recordRead(@Nullable byte[] value) {\n+        if (value != null) {\n+            timer.increment(FDBStoreTimer.Counts.BYTES_READ, value.length);\n+        }\n+        return value;\n+    }\n+\n+    @Nullable\n+    protected KeyValue recordRead(@Nonnull KeyValue keyValue) {\n+        timer.increment(FDBStoreTimer.Counts.BYTES_READ, keyValue.getKey().length + keyValue.getValue().length);\n+        return keyValue;\n+    }\n+\n+    private class ByteCountingAsyncIterable implements AsyncIterable<KeyValue> {\n+        private AsyncIterable<KeyValue> underlying;\n+\n+        public ByteCountingAsyncIterable(AsyncIterable<KeyValue> underlying) {\n+            this.underlying = underlying;\n+        }\n+\n+        @Override\n+        public AsyncIterator<KeyValue> iterator() {\n+            return new ByteCountingAsyncIterator(underlying.iterator());\n+        }\n+\n+        @Override\n+        public CompletableFuture<List<KeyValue>> asList() {\n+            final List<KeyValue> result = new ArrayList<>();\n+            final AsyncIterator<KeyValue> iterator = iterator();\n+            return AsyncUtil.whileTrue(() -> iterator.onHasNext().thenApply(hasNext -> {\n+                if (hasNext) {\n+                    result.add(iterator.next());\n+                }\n+                return hasNext;\n+            })).thenApply(vignore -> result);", "originalCommit": "ded1808beaf1c6fcb792b1bd98431e4e5674e310", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDE3NDU4MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r400174581", "bodyText": "Presumably my loop is just doing what the underlying code would have done, however I agree that the underlying code should be in charge of building the list.  Updated.", "author": "scgray", "createdAt": "2020-03-30T13:05:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU0MTY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM0OTM2MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r400349361", "bodyText": "Yeah, both the old loop and new look look the same in terms of \"what gets recorded\", but I was mostly \"concerned\" with reconstructing the list.", "author": "alecgrieser", "createdAt": "2020-03-30T17:00:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU0MTY3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYxNDcyNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r399614725", "bodyText": "Good question. I think (?) that the FDB metric that goes into machine readable status is 1 range read = 1 read, so if we wanted to be able to correlated, say, reads from this timer to reads from that timer, we'd want them to be the same. This also means that we count work from empty range reads, which we may care about. I suppose we still know how many entries get back from our other, higher level metrics (like FDBStoreTimer.Counts.LOAD_RECORD). Hmm.", "author": "alecgrieser", "createdAt": "2020-03-28T03:46:40Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/InstrumentedReadTransaction.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * InstrumentedReadTransaction.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.KeySelector;\n+import com.apple.foundationdb.KeyValue;\n+import com.apple.foundationdb.Range;\n+import com.apple.foundationdb.ReadTransaction;\n+import com.apple.foundationdb.StreamingMode;\n+import com.apple.foundationdb.TransactionOptions;\n+import com.apple.foundationdb.async.AsyncIterable;\n+import com.apple.foundationdb.async.AsyncIterator;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.record.provider.common.StoreTimer;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.function.Function;\n+\n+abstract class InstrumentedReadTransaction<T extends ReadTransaction> implements ReadTransaction {\n+    @Nonnull\n+    protected StoreTimer timer;\n+    @Nonnull\n+    protected T underlying;\n+\n+    public InstrumentedReadTransaction(@Nonnull StoreTimer timer, @Nonnull T underlying) {\n+        this.timer = timer;\n+        this.underlying = underlying;\n+    }\n+\n+    @Override\n+    public boolean isSnapshot() {\n+        return underlying.isSnapshot();\n+    }\n+\n+    @Override\n+    public CompletableFuture<Long> getReadVersion() {\n+        return underlying.getReadVersion();\n+    }\n+\n+    @Override\n+    public void setReadVersion(long l) {\n+        underlying.setReadVersion(l);\n+    }\n+\n+    @Override\n+    public boolean addReadConflictRangeIfNotSnapshot(byte[] keyBegin, byte[] keyEnd) {\n+        return underlying.addReadConflictRangeIfNotSnapshot(keyBegin, keyEnd);\n+    }\n+\n+    @Override\n+    public boolean addReadConflictKeyIfNotSnapshot(byte[] key) {\n+        return underlying.addReadConflictKeyIfNotSnapshot(key);\n+    }\n+\n+    @Override\n+    public CompletableFuture<byte[]> get(byte[] key) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return underlying.get(key).thenApply(this::recordRead);\n+    }\n+\n+    @Override\n+    public CompletableFuture<byte[]> getKey(KeySelector keySelector) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return underlying.getKey(keySelector).thenApply(this::recordRead);\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(KeySelector begin, KeySelector end) {\n+        /* Should this could as one read? */", "originalCommit": "ded1808beaf1c6fcb792b1bd98431e4e5674e310", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYxNDg3MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r399614871", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /** Total number of mutations operations. */\n          \n          \n            \n                    /** Total number of mutation operations. */", "author": "alecgrieser", "createdAt": "2020-03-28T03:48:29Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBStoreTimer.java", "diffHunk": "@@ -634,6 +584,18 @@ public String logKey() {\n         INVALID_KEY_LENGTH(\"invalid record key\", false),\n         /** The number of indexes that need to be rebuilt in the record store. */\n         INDEXES_NEED_REBUILDING(\"indexes need rebuilding\", false),\n+        /** The number of bytes read. */\n+        BYTES_READ(\"bytes read\", true),\n+        /** The number of bytes written, not including deletes. */\n+        BYTES_WRITTEN(\"bytes written\", true),\n+        /** Total number of delete (clear) operations. */\n+        READS(\"reads\", false),\n+        /** Total number of write operations. */\n+        WRITES(\"writes\", false),\n+        /** Total number of delete (clear) operations. */\n+        DELETES(\"deletes\", false),\n+        /** Total number of mutations operations. */", "originalCommit": "ded1808beaf1c6fcb792b1bd98431e4e5674e310", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDE3MTA1Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r400171053", "bodyText": "Done.", "author": "scgray", "createdAt": "2020-03-30T12:59:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYxNDg3MQ=="}], "type": "inlineReview"}, {"oid": "570540442eb123ef0b027da8b588b9b536c44371", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/570540442eb123ef0b027da8b588b9b536c44371", "message": "Respond to Alec's comments", "committedDate": "2020-03-30T14:06:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDMyMjIwNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r400322207", "bodyText": "Suggested change", "author": "alecgrieser", "createdAt": "2020-03-30T16:20:38Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBDatabase.java", "diffHunk": "@@ -717,15 +722,57 @@ protected Executor newContextExecutor() {\n         return factory.newContextExecutor();\n     }\n \n+    /**\n+     * Creates a new transaction against the database.\n+     *\n+     * @param executor the executor to be used for asynchronous operations\n+     * @param mdcContext if not [@code null} and tracing is enabled, information in the context will be included\n+     *      in tracing log messages\n+     * @param transactionIsTraced if true, the transaction will produce tracing messages (for example, logging when\n+     *      the transaction is cleaned up without having been closed)\n+     * @return newly created transaction\n+     * @deprecated use {@link #openContext()} instead\n+     */\n+    @Deprecated\n+    @API(API.Status.DEPRECATED)\n     public Transaction createTransaction(Executor executor, @Nullable Map<String, String> mdcContext, boolean transactionIsTraced) {\n+        return createTransaction(executor, null, mdcContext, transactionIsTraced);\n+    }\n+\n+    /**\n+     * Creates a new transaction against the database.\n+     *\n+     * @param executor the executor to be used for asynchronous operations\n+     * @param storeTimer if not {@code null}, will be used too track low level operations (e.g. reads/writes/deletes)\n+     * @param mdcContext if not [@code null} and tracing is enabled, information in the context will be included\n+     *      in tracing log messages\n+     * @param transactionIsTraced if true, the transaction will produce tracing messages (for example, logging when\n+     *      the transaction is cleaned up without having been closed)\n+     * @return newly created transaction\n+     */\n+    private Transaction createTransaction(Executor executor, @Nullable StoreTimer storeTimer, @Nullable Map<String, String> mdcContext, boolean transactionIsTraced) {\n         Transaction transaction = database.createTransaction(executor);\n+\n+        if (storeTimer != null) {\n+            transaction = new InstrumentedTransaction(storeTimer, transaction);\n+        }\n+\n         if (transactionIsTraced) {\n-            return new TracedTransaction(transaction, mdcContext);\n-        } else {\n-            return transaction;\n+            transaction = new TracedTransaction(transaction, mdcContext);\n+        }\n+\n+        return transaction;\n+    }\n+\n+    protected Executor newExecutor(@Nullable Map<String, String> mdcContext) {\n+        Executor executor = newContextExecutor();\n+        if (mdcContext != null) {\n+            executor = new ContextRestoringExecutor(executor, mdcContext);\n         }\n+        return executor;\n     }\n-    \n+\n+", "originalCommit": "570540442eb123ef0b027da8b588b9b536c44371", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1b5a09008914142fbb8da6b8754e1ffd2d3b8ff1", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/1b5a09008914142fbb8da6b8754e1ffd2d3b8ff1", "message": "Respond to Alec's comments", "committedDate": "2020-03-31T13:38:53Z", "type": "commit"}, {"oid": "1b5a09008914142fbb8da6b8754e1ffd2d3b8ff1", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/1b5a09008914142fbb8da6b8754e1ffd2d3b8ff1", "message": "Respond to Alec's comments", "committedDate": "2020-03-31T13:38:53Z", "type": "forcePushed"}]}