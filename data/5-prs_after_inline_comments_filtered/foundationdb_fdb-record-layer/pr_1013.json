{"pr_number": 1013, "pr_title": "Resolves #1012: BITMAP_VALUE index cursors can be bit-wise merged", "pr_createdAt": "2020-08-13T00:31:19Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013", "timeline": [{"oid": "bbc39b3988491c2b792373a2e451b7fa6bedd2f2", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/bbc39b3988491c2b792373a2e451b7fa6bedd2f2", "message": "Adjust visibility of MergeCursor classes and methods\nFix various warnings that are now checked for a public class.", "committedDate": "2020-08-12T19:14:32Z", "type": "commit"}, {"oid": "18853c623f0e78f63dc1e5cf805bc8d3e15eb397", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/18853c623f0e78f63dc1e5cf805bc8d3e15eb397", "message": "Make the result of planCoveringAggregateIndex more generally useful.", "committedDate": "2020-08-12T19:14:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2NTY3MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470065670", "bodyText": "This should be considered a binary-incompatible change of the stable API.", "author": "normen662", "createdAt": "2020-08-13T16:11:21Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -1530,7 +1530,7 @@ private static boolean addCoveringField(@Nonnull KeyExpression requiredExpr,\n     }\n     \n     @Nullable\n-    public RecordQueryPlan planCoveringAggregateIndex(@Nonnull RecordQuery query, @Nonnull String indexName) {\n+    public RecordQueryCoveringIndexPlan planCoveringAggregateIndex(@Nonnull RecordQuery query, @Nonnull String indexName) {", "originalCommit": "692970d1bca8301fec18736aba5bfedd8f971d7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIyOTQ3MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470229470", "bodyText": "I added a note in the release notes. Do we think stronger action is needed?", "author": "MMcM", "createdAt": "2020-08-13T20:30:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2NTY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzMTc4MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470231781", "bodyText": "@alecgrieser Do we need a release bump? It's source compatible, but would break on binary level.", "author": "normen662", "createdAt": "2020-08-13T20:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2NTY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI0MDg1NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470240855", "bodyText": "Good question. (I'm not sure if there's a settled answer on that.) I guess technically we only make guarantees about our API stability (and not our ABI stability). This...feels like it's probably fine to just make a note of, I suppose, but I'm not certain.\nIt seems a little weird to me that this method would return a concrete implementation of RecordQueryPlan rather than an interface (from an API perspective), but I've not yet gone through the code enough to understand the justification for that change yet.", "author": "alecgrieser", "createdAt": "2020-08-13T20:51:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2NTY3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2NTgxMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470065813", "bodyText": "This should be considered a binary-incompatible change of the stable API.", "author": "normen662", "createdAt": "2020-08-13T16:11:35Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -1542,7 +1542,7 @@ public RecordQueryPlan planCoveringAggregateIndex(@Nonnull RecordQuery query, @N\n     }\n \n     @Nullable\n-    public RecordQueryPlan planCoveringAggregateIndex(@Nonnull RecordQuery query, @Nonnull Index index, @Nonnull KeyExpression indexExpr) {\n+    public RecordQueryCoveringIndexPlan planCoveringAggregateIndex(@Nonnull RecordQuery query, @Nonnull Index index, @Nonnull KeyExpression indexExpr) {", "originalCommit": "692970d1bca8301fec18736aba5bfedd8f971d7f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2NjgyMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470066821", "bodyText": "nitpick -- maybe this should be named something tryBuild", "author": "normen662", "createdAt": "2020-08-13T16:13:17Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexAggregate.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * ComposedBitmapIndex.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.bitmap;\n+\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexAggregateFunction;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStore;\n+import com.apple.foundationdb.record.provider.foundationdb.IndexAggregateGroupKeys;\n+import com.apple.foundationdb.record.provider.foundationdb.IndexFunctionHelper;\n+import com.apple.foundationdb.record.provider.foundationdb.indexes.BitmapValueIndexMaintainer;\n+import com.apple.foundationdb.record.query.QueryToKeyMatcher;\n+import com.apple.foundationdb.record.query.RecordQuery;\n+import com.apple.foundationdb.record.query.expressions.AndOrComponent;\n+import com.apple.foundationdb.record.query.expressions.ComponentWithComparison;\n+import com.apple.foundationdb.record.query.expressions.FieldWithComparison;\n+import com.apple.foundationdb.record.query.expressions.NotComponent;\n+import com.apple.foundationdb.record.query.expressions.OrComponent;\n+import com.apple.foundationdb.record.query.expressions.Query;\n+import com.apple.foundationdb.record.query.expressions.QueryComponent;\n+import com.apple.foundationdb.record.query.expressions.QueryKeyExpressionWithComparison;\n+import com.apple.foundationdb.record.query.plan.RecordQueryPlanner;\n+import com.apple.foundationdb.record.query.plan.planning.FilterSatisfiedMask;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryCoveringIndexPlan;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Transform a tree of Boolean expressions into a tree of bitwise operations on streams of bitmaps.\n+ *\n+ * So, {@code AND} turns into {@code BITAND} and {@code OR} into {@code BITOR}, with the leaves of the streams\n+ * being scans of a {@code BITMAP_VALUE} index keyed by the leaf condition.\n+ *\n+ * Optional additional grouping predicates for all indexes are also preserved.\n+ */\n+public class ComposedBitmapIndexAggregate {\n+    @Nonnull\n+    private final Node root;\n+\n+    ComposedBitmapIndexAggregate(@Nonnull Node root) {\n+        this.root = root;\n+    }\n+\n+    /**\n+     * Try to build a composed bitmap for the given aggregate function and filters.\n+     * <p>\n+     * The function should use a supported aggregate function (currently {@value BitmapValueIndexMaintainer#AGGREGATE_FUNCTION_NAME})\n+     * and the bitmap-indexed position field grouped by any common fields.\n+     * The filter should supply equality conditions to the common fields.\n+     * The filter can include additional equality conditions on various other fields for which there are appropriate bitmap indexes, in a Boolean\n+     * expression that will be transformed into a set the corresponding bit operations on the bitmaps.\n+     * The filter can also include range conditions on the position field.\n+     * </p>\n+     * @param recordStore the record store containing the indexed data\n+     * @param recordTypeNames the record types on which the indexes are defined\n+     * @param indexAggregateFunction the function giving the desired position and grouping\n+     * @param filter conditions on the groups and position\n+     * @return an {@code Optional} composed bitmap or {@code Optional.empty} if there conditions could not be satisfied\n+     */\n+    @Nonnull\n+    public static Optional<ComposedBitmapIndexAggregate> tryBuild(@Nonnull FDBRecordStore recordStore,\n+                                                                  @Nonnull List<String> recordTypeNames,\n+                                                                  @Nonnull IndexAggregateFunction indexAggregateFunction,\n+                                                                  @Nonnull QueryComponent filter) {\n+        List<QueryComponent> groupFilters = new ArrayList<>();\n+        List<QueryComponent> indexFilters = new ArrayList<>();\n+        if (!separateGroupFilters(filter, indexAggregateFunction, groupFilters, indexFilters) || indexFilters.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        Builder builder = new Builder(recordStore, recordTypeNames, groupFilters, indexAggregateFunction);\n+        return builder.build(indexFilters.size() > 1 ? Query.and(indexFilters) : indexFilters.get(0))\n+            .map(ComposedBitmapIndexAggregate::new);\n+    }\n+\n+    /**\n+     * Try to turn this composed bitmap into an executable plan.\n+     * @param query a base query over the target record types\n+     * @param recordMetaData the record meta-data for planning\n+     * @param planner a query planner to use to construct the plans\n+     * @return an {@code Optional} query plan or {@code Optional.empty} if planning is not possible\n+     */\n+    @Nonnull\n+    public Optional<ComposedBitmapIndexQueryPlan> tryPlan(@Nonnull RecordQuery.Builder query,\n+                                                          @Nonnull RecordMetaData recordMetaData,\n+                                                          @Nonnull RecordQueryPlanner planner) {\n+        final List<RecordQueryCoveringIndexPlan> indexScans = new ArrayList<>();\n+        final Map<IndexNode, ComposedBitmapIndexQueryPlan.IndexComposer> indexComposers = new IdentityHashMap<>();\n+        return Optional.ofNullable(plan(root, query, recordMetaData, planner, indexScans, indexComposers))\n+                .map(composer -> new ComposedBitmapIndexQueryPlan(indexScans, composer));\n+    }\n+\n+    private static boolean separateGroupFilters(@Nonnull QueryComponent filter,\n+                                                @Nonnull IndexAggregateFunction indexAggregateFunction,\n+                                                @Nonnull List<QueryComponent> groupFilters,\n+                                                @Nonnull List<QueryComponent> indexFilters) {\n+        QueryToKeyMatcher matcher = new QueryToKeyMatcher(filter);\n+        FilterSatisfiedMask filterMask = FilterSatisfiedMask.of(filter);\n+        QueryToKeyMatcher.Match match = matcher.matchesCoveringKey(((GroupingKeyExpression)indexAggregateFunction.getOperand()).getGroupingSubKey(), filterMask);\n+        if (match.getType() != QueryToKeyMatcher.MatchType.EQUALITY) {\n+            return false;   // Did not manage to fully restrict the grouping key.\n+        }\n+        // The position key(s) can also be constrained with inequalities and those go among the group filters.\n+        matcher.matchesCoveringKey(((GroupingKeyExpression)indexAggregateFunction.getOperand()).getGroupedSubKey(), filterMask);\n+        if (filterMask.allSatisfied()) {\n+            return false;   // Not enough conditions left over.\n+        }\n+        for (FilterSatisfiedMask child : filterMask.getChildren()) {\n+            if (child.allSatisfied()) {\n+                groupFilters.add(child.getFilter());\n+            } else {\n+                indexFilters.add(child.getFilter());\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Nullable\n+    private ComposedBitmapIndexQueryPlan.ComposerBase plan(@Nonnull Node node, @Nonnull RecordQuery.Builder query,\n+                                                           @Nonnull RecordMetaData recordMetaData, @Nonnull RecordQueryPlanner planner,\n+                                                           @Nonnull List<RecordQueryCoveringIndexPlan> indexScans,\n+                                                           @Nonnull Map<IndexNode, ComposedBitmapIndexQueryPlan.IndexComposer> indexComposers) {\n+        if (node instanceof OperatorNode) {\n+            final OperatorNode operatorNode = (OperatorNode) node;\n+            final List<ComposedBitmapIndexQueryPlan.ComposerBase> children = new ArrayList<>();\n+            for (Node n : operatorNode.operands) {\n+                ComposedBitmapIndexQueryPlan.ComposerBase plan = plan(n, query, recordMetaData, planner, indexScans, indexComposers);\n+                if (plan == null) {\n+                    return null;\n+                }\n+                children.add(plan);\n+            }\n+            switch (operatorNode.operator) {\n+                case AND:\n+                    return new ComposedBitmapIndexQueryPlan.AndComposer(children);\n+                case OR:\n+                    return new ComposedBitmapIndexQueryPlan.OrComposer(children);\n+                case NOT:\n+                    return new ComposedBitmapIndexQueryPlan.NotComposer(children.get(0));\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown operator node: \" + node);\n+            }\n+        } else if (node instanceof IndexNode) {\n+            return indexComposers.computeIfAbsent((IndexNode)node, indexNode -> {\n+                query.setFilter(indexNode.filter);\n+                final Index index = recordMetaData.getIndex(indexNode.indexName);\n+                final KeyExpression wholeKey = ((GroupingKeyExpression)index.getRootExpression()).getWholeKey();\n+                final RecordQueryCoveringIndexPlan indexScan = planner.planCoveringAggregateIndex(query.build(), index, wholeKey);\n+                if (indexScan == null) {\n+                    return null;\n+                }\n+                final int position = indexScans.size();\n+                indexScans.add(indexScan);\n+                return new ComposedBitmapIndexQueryPlan.IndexComposer(position);\n+            });\n+        } else {\n+            throw new IllegalArgumentException(\"Unknown node type: \" + node);\n+        }\n+    }\n+\n+    static class Node {\n+    }\n+\n+    static class OperatorNode extends Node {\n+        enum Operator { AND, OR, NOT }\n+\n+        @Nonnull\n+        private final Operator operator;\n+        @Nonnull\n+        private final List<Node> operands;\n+\n+        OperatorNode(@Nonnull Operator operator, @Nonnull List<Node> operands) {\n+            this.operator = operator;\n+            this.operands = operands;\n+        }\n+    }\n+\n+    // Note that the same IndexNode can occur multiple times in the tree, if the same condition subexpression appears\n+    // multiple times in the filter.\n+    static class IndexNode extends Node {\n+        @Nonnull\n+        private final QueryComponent filter;\n+        @Nonnull\n+        private final IndexAggregateGroupKeys groupKeys;\n+        @Nonnull\n+        private final String indexName;\n+\n+        IndexNode(@Nonnull QueryComponent filter, @Nonnull IndexAggregateGroupKeys groupKeys, @Nonnull String indexName) {\n+            this.filter = filter;\n+            this.groupKeys = groupKeys;\n+            this.indexName = indexName;\n+        }\n+    }\n+\n+    static class Builder {\n+        @Nonnull\n+        private final FDBRecordStore recordStore;\n+        @Nonnull\n+        private final List<String> recordTypeNames;\n+        @Nonnull\n+        private final List<QueryComponent> groupFilters;\n+        @Nonnull\n+        private final IndexAggregateFunction indexAggregateFunction;\n+        @Nullable\n+        private Map<KeyExpression, Index> bitmapIndexes;\n+        @Nullable\n+        private Map<QueryComponent, IndexNode> indexNodes;\n+\n+        Builder(@Nonnull final FDBRecordStore recordStore, @Nonnull List<String> recordTypeNames,\n+                @Nonnull List<QueryComponent> groupFilters, @Nonnull IndexAggregateFunction indexAggregateFunction) {\n+            this.recordStore = recordStore;\n+            this.recordTypeNames = recordTypeNames;\n+            this.groupFilters = groupFilters;\n+            this.indexAggregateFunction = indexAggregateFunction;\n+        }\n+\n+        @Nonnull\n+        Optional<Node> build(@Nonnull QueryComponent indexFilter) {", "originalCommit": "692970d1bca8301fec18736aba5bfedd8f971d7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIyOTUzMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470229533", "bodyText": "Sure. Changed.", "author": "MMcM", "createdAt": "2020-08-13T20:30:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2NjgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEzNzA2NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470137064", "bodyText": "this should call structuralEquals() as it is a plan", "author": "normen662", "createdAt": "2020-08-13T17:48:22Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexQueryPlan.java", "diffHunk": "@@ -0,0 +1,503 @@\n+/*\n+ * ComposedBitmapIndexQueryPlan.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.bitmap;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.EvaluationContext;\n+import com.apple.foundationdb.record.ExecuteProperties;\n+import com.apple.foundationdb.record.IndexEntry;\n+import com.apple.foundationdb.record.PlanHashable;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.provider.common.StoreTimer;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBQueriedRecord;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreBase;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBStoreTimer;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryCoveringIndexPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlanWithNoChildren;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.CorrelationIdentifier;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.explain.NodeInfo;\n+import com.apple.foundationdb.record.query.plan.temp.explain.PlannerGraph;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.Message;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A query plan implementing a bit-wise merge of two or more covering index scans of {@code BITMAP_VALUE} indexes.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public class ComposedBitmapIndexQueryPlan implements RecordQueryPlanWithNoChildren {\n+\n+    @Nonnull\n+    // NOTE: These aren't children in the sense of RecordQueryPlanWithChildren\n+    // for the same reason as RecordQueryCoveringIndexPlan isn't RecordQueryPlanWithChild.\n+    private final List<RecordQueryCoveringIndexPlan> indexPlans;\n+    @Nonnull\n+    private final ComposerBase composer;\n+\n+    ComposedBitmapIndexQueryPlan(@Nonnull List<RecordQueryCoveringIndexPlan> indexPlans, @Nonnull ComposerBase composer) {\n+        this.indexPlans = indexPlans;\n+        this.composer = composer;\n+    }\n+\n+    @Nonnull\n+    public List<RecordQueryCoveringIndexPlan> getIndexPlans() {\n+        return indexPlans;\n+    }\n+\n+    @Nonnull\n+    public ComposerBase getComposer() {\n+        return composer;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public <M extends Message> RecordCursor<FDBQueriedRecord<M>> execute(@Nonnull FDBRecordStoreBase<M> store, @Nonnull EvaluationContext context,\n+                                                                         @Nullable byte[] continuation, @Nonnull ExecuteProperties executeProperties) {\n+        final ExecuteProperties scanExecuteProperties = executeProperties.getSkip() > 0 ? executeProperties.clearSkipAndAdjustLimit() : executeProperties;\n+        final List<Function<byte[], RecordCursor<IndexEntry>>> cursorFunctions = indexPlans.stream()\n+                .map(RecordQueryCoveringIndexPlan::getIndexPlan)\n+                .map(scan -> (Function<byte[], RecordCursor<IndexEntry>>) childContinuation -> scan.executeEntries(store, context, childContinuation, scanExecuteProperties))\n+                .collect(Collectors.toList());\n+        return ComposedBitmapIndexCursor.create(cursorFunctions, composer, continuation, store.getTimer())\n+                // Composers can return null bitmaps when empty, which is then left out of the result set.\n+                .filter(indexEntry -> indexEntry.getValue().get(0) != null)\n+                .map(indexPlans.get(0).indexEntryToQueriedRecord(store));\n+    }\n+\n+    @Override\n+    public boolean isReverse() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean hasRecordScan() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean hasFullRecordScan() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean hasIndexScan(@Nonnull String indexName) {\n+        return indexPlans.stream().anyMatch(p -> p.hasIndexScan(indexName));\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public Set<String> getUsedIndexes() {\n+        return indexPlans.stream().map(RecordQueryPlan::getUsedIndexes).flatMap(Set::stream).collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    public boolean hasLoadBykeys() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void logPlanStructure(StoreTimer timer) {\n+        timer.increment(FDBStoreTimer.Counts.PLAN_COMPOSED_BITMAP_INDEX);\n+        for (RecordQueryPlan indexPlan : indexPlans) {\n+            indexPlan.logPlanStructure(timer);\n+        }\n+    }\n+\n+    @Override\n+    public int getComplexity() {\n+        int complexity = 1;\n+        for (RecordQueryPlan child : indexPlans) {\n+            complexity += child.getComplexity();\n+        }\n+        return complexity;\n+    }\n+\n+    @Override\n+    public int planHash() {\n+        return PlanHashable.planHash(indexPlans) + composer.planHash();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public PlannerGraph rewritePlannerGraph(@Nonnull List<? extends PlannerGraph> childGraphs) {\n+        return PlannerGraph.fromNodeAndChildGraphs(\n+                new PlannerGraph.OperatorNodeWithInfo(this, NodeInfo.COMPOSED_BITMAP_OPERATOR),\n+                childGraphs);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return indexPlans.stream().map(RecordQueryPlan::getCorrelatedTo).flatMap(Set::stream).collect(Collectors.toSet());\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public ComposedBitmapIndexQueryPlan rebase(@Nonnull AliasMap translationMap) {\n+        return new ComposedBitmapIndexQueryPlan(indexPlans.stream().map(i -> i.rebase(translationMap)).collect(Collectors.toList()), composer);\n+    }\n+\n+    @Override\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression other, @Nonnull AliasMap equivalences) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (getClass() != other.getClass()) {\n+            return false;\n+        }\n+        ComposedBitmapIndexQueryPlan that = (ComposedBitmapIndexQueryPlan) other;\n+        if (!composer.equals(that.composer)) {\n+            return false;\n+        }\n+        List<RecordQueryCoveringIndexPlan> otherIndexPlans = that.indexPlans;\n+        if (indexPlans.size() != otherIndexPlans.size()) {\n+            return false;\n+        }\n+        for (int i = 0; i < indexPlans.size(); i++) {\n+            if (!indexPlans.get(i).equalsWithoutChildren(otherIndexPlans.get(i), equivalences)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCodeWithoutChildren() {\n+        return composer.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {", "originalCommit": "692970d1bca8301fec18736aba5bfedd8f971d7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIyOTYwNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470229606", "bodyText": "Fixed.", "author": "MMcM", "createdAt": "2020-08-13T20:30:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEzNzA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEzNzUwMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470137503", "bodyText": "this should call structuralHash() as it is a plan", "author": "normen662", "createdAt": "2020-08-13T17:49:03Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexQueryPlan.java", "diffHunk": "@@ -0,0 +1,503 @@\n+/*\n+ * ComposedBitmapIndexQueryPlan.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.bitmap;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.EvaluationContext;\n+import com.apple.foundationdb.record.ExecuteProperties;\n+import com.apple.foundationdb.record.IndexEntry;\n+import com.apple.foundationdb.record.PlanHashable;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.provider.common.StoreTimer;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBQueriedRecord;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreBase;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBStoreTimer;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryCoveringIndexPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlanWithNoChildren;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.CorrelationIdentifier;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.explain.NodeInfo;\n+import com.apple.foundationdb.record.query.plan.temp.explain.PlannerGraph;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.Message;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A query plan implementing a bit-wise merge of two or more covering index scans of {@code BITMAP_VALUE} indexes.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public class ComposedBitmapIndexQueryPlan implements RecordQueryPlanWithNoChildren {\n+\n+    @Nonnull\n+    // NOTE: These aren't children in the sense of RecordQueryPlanWithChildren\n+    // for the same reason as RecordQueryCoveringIndexPlan isn't RecordQueryPlanWithChild.\n+    private final List<RecordQueryCoveringIndexPlan> indexPlans;\n+    @Nonnull\n+    private final ComposerBase composer;\n+\n+    ComposedBitmapIndexQueryPlan(@Nonnull List<RecordQueryCoveringIndexPlan> indexPlans, @Nonnull ComposerBase composer) {\n+        this.indexPlans = indexPlans;\n+        this.composer = composer;\n+    }\n+\n+    @Nonnull\n+    public List<RecordQueryCoveringIndexPlan> getIndexPlans() {\n+        return indexPlans;\n+    }\n+\n+    @Nonnull\n+    public ComposerBase getComposer() {\n+        return composer;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public <M extends Message> RecordCursor<FDBQueriedRecord<M>> execute(@Nonnull FDBRecordStoreBase<M> store, @Nonnull EvaluationContext context,\n+                                                                         @Nullable byte[] continuation, @Nonnull ExecuteProperties executeProperties) {\n+        final ExecuteProperties scanExecuteProperties = executeProperties.getSkip() > 0 ? executeProperties.clearSkipAndAdjustLimit() : executeProperties;\n+        final List<Function<byte[], RecordCursor<IndexEntry>>> cursorFunctions = indexPlans.stream()\n+                .map(RecordQueryCoveringIndexPlan::getIndexPlan)\n+                .map(scan -> (Function<byte[], RecordCursor<IndexEntry>>) childContinuation -> scan.executeEntries(store, context, childContinuation, scanExecuteProperties))\n+                .collect(Collectors.toList());\n+        return ComposedBitmapIndexCursor.create(cursorFunctions, composer, continuation, store.getTimer())\n+                // Composers can return null bitmaps when empty, which is then left out of the result set.\n+                .filter(indexEntry -> indexEntry.getValue().get(0) != null)\n+                .map(indexPlans.get(0).indexEntryToQueriedRecord(store));\n+    }\n+\n+    @Override\n+    public boolean isReverse() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean hasRecordScan() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean hasFullRecordScan() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean hasIndexScan(@Nonnull String indexName) {\n+        return indexPlans.stream().anyMatch(p -> p.hasIndexScan(indexName));\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public Set<String> getUsedIndexes() {\n+        return indexPlans.stream().map(RecordQueryPlan::getUsedIndexes).flatMap(Set::stream).collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    public boolean hasLoadBykeys() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void logPlanStructure(StoreTimer timer) {\n+        timer.increment(FDBStoreTimer.Counts.PLAN_COMPOSED_BITMAP_INDEX);\n+        for (RecordQueryPlan indexPlan : indexPlans) {\n+            indexPlan.logPlanStructure(timer);\n+        }\n+    }\n+\n+    @Override\n+    public int getComplexity() {\n+        int complexity = 1;\n+        for (RecordQueryPlan child : indexPlans) {\n+            complexity += child.getComplexity();\n+        }\n+        return complexity;\n+    }\n+\n+    @Override\n+    public int planHash() {\n+        return PlanHashable.planHash(indexPlans) + composer.planHash();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public PlannerGraph rewritePlannerGraph(@Nonnull List<? extends PlannerGraph> childGraphs) {\n+        return PlannerGraph.fromNodeAndChildGraphs(\n+                new PlannerGraph.OperatorNodeWithInfo(this, NodeInfo.COMPOSED_BITMAP_OPERATOR),\n+                childGraphs);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return indexPlans.stream().map(RecordQueryPlan::getCorrelatedTo).flatMap(Set::stream).collect(Collectors.toSet());\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public ComposedBitmapIndexQueryPlan rebase(@Nonnull AliasMap translationMap) {\n+        return new ComposedBitmapIndexQueryPlan(indexPlans.stream().map(i -> i.rebase(translationMap)).collect(Collectors.toList()), composer);\n+    }\n+\n+    @Override\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression other, @Nonnull AliasMap equivalences) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (getClass() != other.getClass()) {\n+            return false;\n+        }\n+        ComposedBitmapIndexQueryPlan that = (ComposedBitmapIndexQueryPlan) other;\n+        if (!composer.equals(that.composer)) {\n+            return false;\n+        }\n+        List<RecordQueryCoveringIndexPlan> otherIndexPlans = that.indexPlans;\n+        if (indexPlans.size() != otherIndexPlans.size()) {\n+            return false;\n+        }\n+        for (int i = 0; i < indexPlans.size(); i++) {\n+            if (!indexPlans.get(i).equalsWithoutChildren(otherIndexPlans.get(i), equivalences)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCodeWithoutChildren() {\n+        return composer.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        ComposedBitmapIndexQueryPlan that = (ComposedBitmapIndexQueryPlan) o;\n+        return indexPlans.equals(that.indexPlans) &&\n+                composer.equals(that.composer);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(indexPlans, composer);", "originalCommit": "692970d1bca8301fec18736aba5bfedd8f971d7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIyOTgwNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470229806", "bodyText": "Fixed.", "author": "MMcM", "createdAt": "2020-08-13T20:30:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEzNzUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE4MzI3Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470183273", "bodyText": "all these getters are now done per record and could be done once per execute(). Not sure if in one of these you have anything computationally expensive going on...", "author": "normen662", "createdAt": "2020-08-13T19:05:20Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "diffHunk": "@@ -73,19 +75,25 @@ public RecordQueryCoveringIndexPlan(@Nonnull RecordQueryPlanWithIndex indexPlan,\n \n     @Nonnull\n     @Override\n-    @SuppressWarnings(\"unchecked\")\n     public <M extends Message> RecordCursor<FDBQueriedRecord<M>> execute(@Nonnull FDBRecordStoreBase<M> store,\n                                                                          @Nonnull EvaluationContext context,\n                                                                          @Nullable byte[] continuation,\n                                                                          @Nonnull ExecuteProperties executeProperties) {\n+        return indexPlan\n+                .executeEntries(store, context, continuation, executeProperties)\n+                .map(indexEntryToQueriedRecord(store));\n+    }\n+\n+    @Nonnull\n+    @SuppressWarnings(\"unchecked\")\n+    @API(API.Status.INTERNAL)\n+    public <M extends Message> Function<IndexEntry, FDBQueriedRecord<M>> indexEntryToQueriedRecord(final @Nonnull FDBRecordStoreBase<M> store) {\n         final RecordMetaData metaData = store.getRecordMetaData();", "originalCommit": "692970d1bca8301fec18736aba5bfedd8f971d7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzMDQ4Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470230483", "bodyText": "It doesn't map calls to indexEntryToQueriedRecord over them; it maps the result of indexEntryToQueriedRecord, which is a function, closing over all those variables, over them.", "author": "MMcM", "createdAt": "2020-08-13T20:32:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE4MzI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzMTA1NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470231054", "bodyText": "ah my bad", "author": "normen662", "createdAt": "2020-08-13T20:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE4MzI3Mw=="}], "type": "inlineReview"}, {"oid": "66a70d1ac604906c04117d9e117b5d6d81dfbc3d", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/66a70d1ac604906c04117d9e117b5d6d81dfbc3d", "message": "Resolves #1012: BITMAP_VALUE index cursors can be bit-wise merged", "committedDate": "2020-08-13T20:29:16Z", "type": "commit"}, {"oid": "66a70d1ac604906c04117d9e117b5d6d81dfbc3d", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/66a70d1ac604906c04117d9e117b5d6d81dfbc3d", "message": "Resolves #1012: BITMAP_VALUE index cursors can be bit-wise merged", "committedDate": "2020-08-13T20:29:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYzMzc3MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r469633770", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * A {@link RecordCursor} doing as bit-wise merge of bitmaps from two or more {@code BITMAP_VALUE} indexes.\n          \n          \n            \n             * A {@link RecordCursor} doing a bit-wise merge of bitmaps from two or more {@code BITMAP_VALUE} indexes.", "author": "alecgrieser", "createdAt": "2020-08-13T01:00:06Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexCursor.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * ComposedBitmapIndexCursor.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.bitmap;\n+\n+import com.apple.foundationdb.record.IndexEntry;\n+import com.apple.foundationdb.record.RecordCoreArgumentException;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorContinuation;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBStoreTimer;\n+import com.apple.foundationdb.record.provider.foundationdb.cursors.MergeCursor;\n+import com.apple.foundationdb.record.provider.foundationdb.cursors.MergeCursorState;\n+import com.apple.foundationdb.record.provider.foundationdb.indexes.BitmapValueIndexMaintainer;\n+import com.apple.foundationdb.tuple.Tuple;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+\n+/**\n+ * A {@link RecordCursor} doing as bit-wise merge of bitmaps from two or more {@code BITMAP_VALUE} indexes.", "originalCommit": "692970d1bca8301fec18736aba5bfedd8f971d7f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzMzM5OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470233399", "bodyText": "I suppose the construction of indexNodes should be delayed until after bitmapIndexes.isEmpty() is checked... Not that I expect that change will make any, like, measurable difference in performance", "author": "alecgrieser", "createdAt": "2020-08-13T20:37:47Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexAggregate.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * ComposedBitmapIndex.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.bitmap;\n+\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexAggregateFunction;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStore;\n+import com.apple.foundationdb.record.provider.foundationdb.IndexAggregateGroupKeys;\n+import com.apple.foundationdb.record.provider.foundationdb.IndexFunctionHelper;\n+import com.apple.foundationdb.record.provider.foundationdb.indexes.BitmapValueIndexMaintainer;\n+import com.apple.foundationdb.record.query.QueryToKeyMatcher;\n+import com.apple.foundationdb.record.query.RecordQuery;\n+import com.apple.foundationdb.record.query.expressions.AndOrComponent;\n+import com.apple.foundationdb.record.query.expressions.ComponentWithComparison;\n+import com.apple.foundationdb.record.query.expressions.FieldWithComparison;\n+import com.apple.foundationdb.record.query.expressions.NotComponent;\n+import com.apple.foundationdb.record.query.expressions.OrComponent;\n+import com.apple.foundationdb.record.query.expressions.Query;\n+import com.apple.foundationdb.record.query.expressions.QueryComponent;\n+import com.apple.foundationdb.record.query.expressions.QueryKeyExpressionWithComparison;\n+import com.apple.foundationdb.record.query.plan.RecordQueryPlanner;\n+import com.apple.foundationdb.record.query.plan.planning.FilterSatisfiedMask;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryCoveringIndexPlan;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Transform a tree of Boolean expressions into a tree of bitwise operations on streams of bitmaps.\n+ *\n+ * So, {@code AND} turns into {@code BITAND} and {@code OR} into {@code BITOR}, with the leaves of the streams\n+ * being scans of a {@code BITMAP_VALUE} index keyed by the leaf condition.\n+ *\n+ * Optional additional grouping predicates for all indexes are also preserved.\n+ */\n+public class ComposedBitmapIndexAggregate {\n+    @Nonnull\n+    private final Node root;\n+\n+    ComposedBitmapIndexAggregate(@Nonnull Node root) {\n+        this.root = root;\n+    }\n+\n+    /**\n+     * Try to build a composed bitmap for the given aggregate function and filters.\n+     * <p>\n+     * The function should use a supported aggregate function (currently {@value BitmapValueIndexMaintainer#AGGREGATE_FUNCTION_NAME})\n+     * and the bitmap-indexed position field grouped by any common fields.\n+     * The filter should supply equality conditions to the common fields.\n+     * The filter can include additional equality conditions on various other fields for which there are appropriate bitmap indexes, in a Boolean\n+     * expression that will be transformed into a set the corresponding bit operations on the bitmaps.\n+     * The filter can also include range conditions on the position field.\n+     * </p>\n+     * @param recordStore the record store containing the indexed data\n+     * @param recordTypeNames the record types on which the indexes are defined\n+     * @param indexAggregateFunction the function giving the desired position and grouping\n+     * @param filter conditions on the groups and position\n+     * @return an {@code Optional} composed bitmap or {@code Optional.empty} if there conditions could not be satisfied\n+     */\n+    @Nonnull\n+    public static Optional<ComposedBitmapIndexAggregate> tryBuild(@Nonnull FDBRecordStore recordStore,\n+                                                                  @Nonnull List<String> recordTypeNames,\n+                                                                  @Nonnull IndexAggregateFunction indexAggregateFunction,\n+                                                                  @Nonnull QueryComponent filter) {\n+        List<QueryComponent> groupFilters = new ArrayList<>();\n+        List<QueryComponent> indexFilters = new ArrayList<>();\n+        if (!separateGroupFilters(filter, indexAggregateFunction, groupFilters, indexFilters) || indexFilters.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        Builder builder = new Builder(recordStore, recordTypeNames, groupFilters, indexAggregateFunction);\n+        return builder.tryBuild(indexFilters.size() > 1 ? Query.and(indexFilters) : indexFilters.get(0))\n+            .map(ComposedBitmapIndexAggregate::new);\n+    }\n+\n+    /**\n+     * Try to turn this composed bitmap into an executable plan.\n+     * @param query a base query over the target record types\n+     * @param recordMetaData the record meta-data for planning\n+     * @param planner a query planner to use to construct the plans\n+     * @return an {@code Optional} query plan or {@code Optional.empty} if planning is not possible\n+     */\n+    @Nonnull\n+    public Optional<ComposedBitmapIndexQueryPlan> tryPlan(@Nonnull RecordQuery.Builder query,\n+                                                          @Nonnull RecordMetaData recordMetaData,\n+                                                          @Nonnull RecordQueryPlanner planner) {\n+        final List<RecordQueryCoveringIndexPlan> indexScans = new ArrayList<>();\n+        final Map<IndexNode, ComposedBitmapIndexQueryPlan.IndexComposer> indexComposers = new IdentityHashMap<>();\n+        return Optional.ofNullable(plan(root, query, recordMetaData, planner, indexScans, indexComposers))\n+                .map(composer -> new ComposedBitmapIndexQueryPlan(indexScans, composer));\n+    }\n+\n+    private static boolean separateGroupFilters(@Nonnull QueryComponent filter,\n+                                                @Nonnull IndexAggregateFunction indexAggregateFunction,\n+                                                @Nonnull List<QueryComponent> groupFilters,\n+                                                @Nonnull List<QueryComponent> indexFilters) {\n+        QueryToKeyMatcher matcher = new QueryToKeyMatcher(filter);\n+        FilterSatisfiedMask filterMask = FilterSatisfiedMask.of(filter);\n+        QueryToKeyMatcher.Match match = matcher.matchesCoveringKey(((GroupingKeyExpression)indexAggregateFunction.getOperand()).getGroupingSubKey(), filterMask);\n+        if (match.getType() != QueryToKeyMatcher.MatchType.EQUALITY) {\n+            return false;   // Did not manage to fully restrict the grouping key.\n+        }\n+        // The position key(s) can also be constrained with inequalities and those go among the group filters.\n+        matcher.matchesCoveringKey(((GroupingKeyExpression)indexAggregateFunction.getOperand()).getGroupedSubKey(), filterMask);\n+        if (filterMask.allSatisfied()) {\n+            return false;   // Not enough conditions left over.\n+        }\n+        for (FilterSatisfiedMask child : filterMask.getChildren()) {\n+            if (child.allSatisfied()) {\n+                groupFilters.add(child.getFilter());\n+            } else {\n+                indexFilters.add(child.getFilter());\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Nullable\n+    private ComposedBitmapIndexQueryPlan.ComposerBase plan(@Nonnull Node node, @Nonnull RecordQuery.Builder query,\n+                                                           @Nonnull RecordMetaData recordMetaData, @Nonnull RecordQueryPlanner planner,\n+                                                           @Nonnull List<RecordQueryCoveringIndexPlan> indexScans,\n+                                                           @Nonnull Map<IndexNode, ComposedBitmapIndexQueryPlan.IndexComposer> indexComposers) {\n+        if (node instanceof OperatorNode) {\n+            final OperatorNode operatorNode = (OperatorNode) node;\n+            final List<ComposedBitmapIndexQueryPlan.ComposerBase> children = new ArrayList<>();\n+            for (Node n : operatorNode.operands) {\n+                ComposedBitmapIndexQueryPlan.ComposerBase plan = plan(n, query, recordMetaData, planner, indexScans, indexComposers);\n+                if (plan == null) {\n+                    return null;\n+                }\n+                children.add(plan);\n+            }\n+            switch (operatorNode.operator) {\n+                case AND:\n+                    return new ComposedBitmapIndexQueryPlan.AndComposer(children);\n+                case OR:\n+                    return new ComposedBitmapIndexQueryPlan.OrComposer(children);\n+                case NOT:\n+                    return new ComposedBitmapIndexQueryPlan.NotComposer(children.get(0));\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown operator node: \" + node);\n+            }\n+        } else if (node instanceof IndexNode) {\n+            return indexComposers.computeIfAbsent((IndexNode)node, indexNode -> {\n+                query.setFilter(indexNode.filter);\n+                final Index index = recordMetaData.getIndex(indexNode.indexName);\n+                final KeyExpression wholeKey = ((GroupingKeyExpression)index.getRootExpression()).getWholeKey();\n+                final RecordQueryCoveringIndexPlan indexScan = planner.planCoveringAggregateIndex(query.build(), index, wholeKey);\n+                if (indexScan == null) {\n+                    return null;\n+                }\n+                final int position = indexScans.size();\n+                indexScans.add(indexScan);\n+                return new ComposedBitmapIndexQueryPlan.IndexComposer(position);\n+            });\n+        } else {\n+            throw new IllegalArgumentException(\"Unknown node type: \" + node);\n+        }\n+    }\n+\n+    static class Node {\n+    }\n+\n+    static class OperatorNode extends Node {\n+        enum Operator { AND, OR, NOT }\n+\n+        @Nonnull\n+        private final Operator operator;\n+        @Nonnull\n+        private final List<Node> operands;\n+\n+        OperatorNode(@Nonnull Operator operator, @Nonnull List<Node> operands) {\n+            this.operator = operator;\n+            this.operands = operands;\n+        }\n+    }\n+\n+    // Note that the same IndexNode can occur multiple times in the tree, if the same condition subexpression appears\n+    // multiple times in the filter.\n+    static class IndexNode extends Node {\n+        @Nonnull\n+        private final QueryComponent filter;\n+        @Nonnull\n+        private final IndexAggregateGroupKeys groupKeys;\n+        @Nonnull\n+        private final String indexName;\n+\n+        IndexNode(@Nonnull QueryComponent filter, @Nonnull IndexAggregateGroupKeys groupKeys, @Nonnull String indexName) {\n+            this.filter = filter;\n+            this.groupKeys = groupKeys;\n+            this.indexName = indexName;\n+        }\n+    }\n+\n+    static class Builder {\n+        @Nonnull\n+        private final FDBRecordStore recordStore;\n+        @Nonnull\n+        private final List<String> recordTypeNames;\n+        @Nonnull\n+        private final List<QueryComponent> groupFilters;\n+        @Nonnull\n+        private final IndexAggregateFunction indexAggregateFunction;\n+        @Nullable\n+        private Map<KeyExpression, Index> bitmapIndexes;\n+        @Nullable\n+        private Map<QueryComponent, IndexNode> indexNodes;\n+\n+        Builder(@Nonnull final FDBRecordStore recordStore, @Nonnull List<String> recordTypeNames,\n+                @Nonnull List<QueryComponent> groupFilters, @Nonnull IndexAggregateFunction indexAggregateFunction) {\n+            this.recordStore = recordStore;\n+            this.recordTypeNames = recordTypeNames;\n+            this.groupFilters = groupFilters;\n+            this.indexAggregateFunction = indexAggregateFunction;\n+        }\n+\n+        @Nonnull\n+        Optional<Node> tryBuild(@Nonnull QueryComponent indexFilter) {\n+            if (indexFilter instanceof ComponentWithComparison) {\n+                return indexScan(indexFilter);\n+            }\n+            if (indexFilter instanceof AndOrComponent) {\n+                final AndOrComponent andOrComponent = (AndOrComponent) indexFilter;\n+                List<Node> childNodes = new ArrayList<>(andOrComponent.getChildren().size());\n+                for (QueryComponent child : andOrComponent.getChildren()) {\n+                    Optional<Node> childNode = tryBuild(child);\n+                    if (!childNode.isPresent()) {\n+                        return Optional.empty();\n+                    }\n+                    childNodes.add(childNode.get());\n+                }\n+                final OperatorNode.Operator operator = indexFilter instanceof OrComponent ? OperatorNode.Operator.OR : OperatorNode.Operator.AND;\n+                return Optional.of(new OperatorNode(operator, childNodes));\n+            }\n+            if (indexFilter instanceof NotComponent) {\n+                return tryBuild(((NotComponent) indexFilter).getChild())\n+                        .map(childNode -> new OperatorNode(OperatorNode.Operator.NOT, Collections.singletonList(childNode)));\n+            }\n+            return Optional.empty();\n+        }\n+\n+        @Nonnull\n+        Optional<Node> indexScan(@Nonnull QueryComponent indexFilter) {\n+            if (bitmapIndexes == null) {\n+                bitmapIndexes = findBitmapIndexes(indexAggregateFunction.getName());\n+                indexNodes = new HashMap<>();", "originalCommit": "66a70d1ac604906c04117d9e117b5d6d81dfbc3d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI0ODA4NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470248084", "bodyText": "Sure. Not much of a difference, it's it's only a matter of reordering the statements.", "author": "MMcM", "createdAt": "2020-08-13T21:05:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzMzM5OQ=="}], "type": "inlineReview"}, {"oid": "ab706ac9ad502f4da7a66268251b336bcfb0bb48", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/ab706ac9ad502f4da7a66268251b336bcfb0bb48", "message": "Update fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexCursor.java\n\nCo-authored-by: Alec Grieser <alloc@apple.com>", "committedDate": "2020-08-13T21:01:56Z", "type": "commit"}, {"oid": "ee39171c186302229dbd9ee1911a3003ffd07a89", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/ee39171c186302229dbd9ee1911a3003ffd07a89", "message": "Defer a map creation since it's easy", "committedDate": "2020-08-13T21:05:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI0MjQxNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470242415", "bodyText": "This is a little unclear to me. It's separating the satisfied filters and the unsatisfied filters, but the satisfied filters might not be on the group (unless I'm missing something). In particular, if there's a filter on the position key, does that belong as a member of groupFilters?", "author": "alecgrieser", "createdAt": "2020-08-13T20:54:03Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexAggregate.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * ComposedBitmapIndex.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.bitmap;\n+\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexAggregateFunction;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStore;\n+import com.apple.foundationdb.record.provider.foundationdb.IndexAggregateGroupKeys;\n+import com.apple.foundationdb.record.provider.foundationdb.IndexFunctionHelper;\n+import com.apple.foundationdb.record.provider.foundationdb.indexes.BitmapValueIndexMaintainer;\n+import com.apple.foundationdb.record.query.QueryToKeyMatcher;\n+import com.apple.foundationdb.record.query.RecordQuery;\n+import com.apple.foundationdb.record.query.expressions.AndOrComponent;\n+import com.apple.foundationdb.record.query.expressions.ComponentWithComparison;\n+import com.apple.foundationdb.record.query.expressions.FieldWithComparison;\n+import com.apple.foundationdb.record.query.expressions.NotComponent;\n+import com.apple.foundationdb.record.query.expressions.OrComponent;\n+import com.apple.foundationdb.record.query.expressions.Query;\n+import com.apple.foundationdb.record.query.expressions.QueryComponent;\n+import com.apple.foundationdb.record.query.expressions.QueryKeyExpressionWithComparison;\n+import com.apple.foundationdb.record.query.plan.RecordQueryPlanner;\n+import com.apple.foundationdb.record.query.plan.planning.FilterSatisfiedMask;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryCoveringIndexPlan;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Transform a tree of Boolean expressions into a tree of bitwise operations on streams of bitmaps.\n+ *\n+ * So, {@code AND} turns into {@code BITAND} and {@code OR} into {@code BITOR}, with the leaves of the streams\n+ * being scans of a {@code BITMAP_VALUE} index keyed by the leaf condition.\n+ *\n+ * Optional additional grouping predicates for all indexes are also preserved.\n+ */\n+public class ComposedBitmapIndexAggregate {\n+    @Nonnull\n+    private final Node root;\n+\n+    ComposedBitmapIndexAggregate(@Nonnull Node root) {\n+        this.root = root;\n+    }\n+\n+    /**\n+     * Try to build a composed bitmap for the given aggregate function and filters.\n+     * <p>\n+     * The function should use a supported aggregate function (currently {@value BitmapValueIndexMaintainer#AGGREGATE_FUNCTION_NAME})\n+     * and the bitmap-indexed position field grouped by any common fields.\n+     * The filter should supply equality conditions to the common fields.\n+     * The filter can include additional equality conditions on various other fields for which there are appropriate bitmap indexes, in a Boolean\n+     * expression that will be transformed into a set the corresponding bit operations on the bitmaps.\n+     * The filter can also include range conditions on the position field.\n+     * </p>\n+     * @param recordStore the record store containing the indexed data\n+     * @param recordTypeNames the record types on which the indexes are defined\n+     * @param indexAggregateFunction the function giving the desired position and grouping\n+     * @param filter conditions on the groups and position\n+     * @return an {@code Optional} composed bitmap or {@code Optional.empty} if there conditions could not be satisfied\n+     */\n+    @Nonnull\n+    public static Optional<ComposedBitmapIndexAggregate> tryBuild(@Nonnull FDBRecordStore recordStore,\n+                                                                  @Nonnull List<String> recordTypeNames,\n+                                                                  @Nonnull IndexAggregateFunction indexAggregateFunction,\n+                                                                  @Nonnull QueryComponent filter) {\n+        List<QueryComponent> groupFilters = new ArrayList<>();\n+        List<QueryComponent> indexFilters = new ArrayList<>();\n+        if (!separateGroupFilters(filter, indexAggregateFunction, groupFilters, indexFilters) || indexFilters.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        Builder builder = new Builder(recordStore, recordTypeNames, groupFilters, indexAggregateFunction);\n+        return builder.tryBuild(indexFilters.size() > 1 ? Query.and(indexFilters) : indexFilters.get(0))\n+            .map(ComposedBitmapIndexAggregate::new);\n+    }\n+\n+    /**\n+     * Try to turn this composed bitmap into an executable plan.\n+     * @param query a base query over the target record types\n+     * @param recordMetaData the record meta-data for planning\n+     * @param planner a query planner to use to construct the plans\n+     * @return an {@code Optional} query plan or {@code Optional.empty} if planning is not possible\n+     */\n+    @Nonnull\n+    public Optional<ComposedBitmapIndexQueryPlan> tryPlan(@Nonnull RecordQuery.Builder query,\n+                                                          @Nonnull RecordMetaData recordMetaData,\n+                                                          @Nonnull RecordQueryPlanner planner) {\n+        final List<RecordQueryCoveringIndexPlan> indexScans = new ArrayList<>();\n+        final Map<IndexNode, ComposedBitmapIndexQueryPlan.IndexComposer> indexComposers = new IdentityHashMap<>();\n+        return Optional.ofNullable(plan(root, query, recordMetaData, planner, indexScans, indexComposers))\n+                .map(composer -> new ComposedBitmapIndexQueryPlan(indexScans, composer));\n+    }\n+\n+    private static boolean separateGroupFilters(@Nonnull QueryComponent filter,\n+                                                @Nonnull IndexAggregateFunction indexAggregateFunction,\n+                                                @Nonnull List<QueryComponent> groupFilters,\n+                                                @Nonnull List<QueryComponent> indexFilters) {\n+        QueryToKeyMatcher matcher = new QueryToKeyMatcher(filter);\n+        FilterSatisfiedMask filterMask = FilterSatisfiedMask.of(filter);\n+        QueryToKeyMatcher.Match match = matcher.matchesCoveringKey(((GroupingKeyExpression)indexAggregateFunction.getOperand()).getGroupingSubKey(), filterMask);\n+        if (match.getType() != QueryToKeyMatcher.MatchType.EQUALITY) {\n+            return false;   // Did not manage to fully restrict the grouping key.\n+        }\n+        // The position key(s) can also be constrained with inequalities and those go among the group filters.\n+        matcher.matchesCoveringKey(((GroupingKeyExpression)indexAggregateFunction.getOperand()).getGroupedSubKey(), filterMask);\n+        if (filterMask.allSatisfied()) {\n+            return false;   // Not enough conditions left over.\n+        }\n+        for (FilterSatisfiedMask child : filterMask.getChildren()) {\n+            if (child.allSatisfied()) {\n+                groupFilters.add(child.getFilter());\n+            } else {\n+                indexFilters.add(child.getFilter());", "originalCommit": "66a70d1ac604906c04117d9e117b5d6d81dfbc3d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwOTMwNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470909307", "bodyText": "A filter can only be satisfied if it matches a key in what was given to the matcher, first the common prefix conditions from the aggregate function and second the position key. I renamed groupFilters to commonFilters and added some comments to this effect.", "author": "MMcM", "createdAt": "2020-08-14T23:57:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI0MjQxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMyMjkxNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470322916", "bodyText": "Hm, something seems fishy about how all of the operate methods for the binary operators are the same except for this line (I think?). Like, that there should be a BinaryOperator (or NAryOperator or something) method with an abstract operateOnByte method that the implementations should use or something.", "author": "alecgrieser", "createdAt": "2020-08-14T00:19:32Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexQueryPlan.java", "diffHunk": "@@ -0,0 +1,496 @@\n+/*\n+ * ComposedBitmapIndexQueryPlan.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.bitmap;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.EvaluationContext;\n+import com.apple.foundationdb.record.ExecuteProperties;\n+import com.apple.foundationdb.record.IndexEntry;\n+import com.apple.foundationdb.record.PlanHashable;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.provider.common.StoreTimer;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBQueriedRecord;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreBase;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBStoreTimer;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryCoveringIndexPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlanWithNoChildren;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.CorrelationIdentifier;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.explain.NodeInfo;\n+import com.apple.foundationdb.record.query.plan.temp.explain.PlannerGraph;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.Message;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A query plan implementing a bit-wise merge of two or more covering index scans of {@code BITMAP_VALUE} indexes.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public class ComposedBitmapIndexQueryPlan implements RecordQueryPlanWithNoChildren {\n+\n+    @Nonnull\n+    // NOTE: These aren't children in the sense of RecordQueryPlanWithChildren\n+    // for the same reason as RecordQueryCoveringIndexPlan isn't RecordQueryPlanWithChild.\n+    private final List<RecordQueryCoveringIndexPlan> indexPlans;\n+    @Nonnull\n+    private final ComposerBase composer;\n+\n+    ComposedBitmapIndexQueryPlan(@Nonnull List<RecordQueryCoveringIndexPlan> indexPlans, @Nonnull ComposerBase composer) {\n+        this.indexPlans = indexPlans;\n+        this.composer = composer;\n+    }\n+\n+    @Nonnull\n+    public List<RecordQueryCoveringIndexPlan> getIndexPlans() {\n+        return indexPlans;\n+    }\n+\n+    @Nonnull\n+    public ComposerBase getComposer() {\n+        return composer;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public <M extends Message> RecordCursor<FDBQueriedRecord<M>> execute(@Nonnull FDBRecordStoreBase<M> store, @Nonnull EvaluationContext context,\n+                                                                         @Nullable byte[] continuation, @Nonnull ExecuteProperties executeProperties) {\n+        final ExecuteProperties scanExecuteProperties = executeProperties.getSkip() > 0 ? executeProperties.clearSkipAndAdjustLimit() : executeProperties;\n+        final List<Function<byte[], RecordCursor<IndexEntry>>> cursorFunctions = indexPlans.stream()\n+                .map(RecordQueryCoveringIndexPlan::getIndexPlan)\n+                .map(scan -> (Function<byte[], RecordCursor<IndexEntry>>) childContinuation -> scan.executeEntries(store, context, childContinuation, scanExecuteProperties))\n+                .collect(Collectors.toList());\n+        return ComposedBitmapIndexCursor.create(cursorFunctions, composer, continuation, store.getTimer())\n+                // Composers can return null bitmaps when empty, which is then left out of the result set.\n+                .filter(indexEntry -> indexEntry.getValue().get(0) != null)\n+                .map(indexPlans.get(0).indexEntryToQueriedRecord(store));\n+    }\n+\n+    @Override\n+    public boolean isReverse() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean hasRecordScan() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean hasFullRecordScan() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean hasIndexScan(@Nonnull String indexName) {\n+        return indexPlans.stream().anyMatch(p -> p.hasIndexScan(indexName));\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public Set<String> getUsedIndexes() {\n+        return indexPlans.stream().map(RecordQueryPlan::getUsedIndexes).flatMap(Set::stream).collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    public boolean hasLoadBykeys() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void logPlanStructure(StoreTimer timer) {\n+        timer.increment(FDBStoreTimer.Counts.PLAN_COMPOSED_BITMAP_INDEX);\n+        for (RecordQueryPlan indexPlan : indexPlans) {\n+            indexPlan.logPlanStructure(timer);\n+        }\n+    }\n+\n+    @Override\n+    public int getComplexity() {\n+        int complexity = 1;\n+        for (RecordQueryPlan child : indexPlans) {\n+            complexity += child.getComplexity();\n+        }\n+        return complexity;\n+    }\n+\n+    @Override\n+    public int planHash() {\n+        return PlanHashable.planHash(indexPlans) + composer.planHash();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public PlannerGraph rewritePlannerGraph(@Nonnull List<? extends PlannerGraph> childGraphs) {\n+        return PlannerGraph.fromNodeAndChildGraphs(\n+                new PlannerGraph.OperatorNodeWithInfo(this, NodeInfo.COMPOSED_BITMAP_OPERATOR),\n+                childGraphs);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return indexPlans.stream().map(RecordQueryPlan::getCorrelatedTo).flatMap(Set::stream).collect(Collectors.toSet());\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public ComposedBitmapIndexQueryPlan rebase(@Nonnull AliasMap translationMap) {\n+        return new ComposedBitmapIndexQueryPlan(indexPlans.stream().map(i -> i.rebase(translationMap)).collect(Collectors.toList()), composer);\n+    }\n+\n+    @Override\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression other, @Nonnull AliasMap equivalences) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (getClass() != other.getClass()) {\n+            return false;\n+        }\n+        ComposedBitmapIndexQueryPlan that = (ComposedBitmapIndexQueryPlan) other;\n+        if (!composer.equals(that.composer)) {\n+            return false;\n+        }\n+        List<RecordQueryCoveringIndexPlan> otherIndexPlans = that.indexPlans;\n+        if (indexPlans.size() != otherIndexPlans.size()) {\n+            return false;\n+        }\n+        for (int i = 0; i < indexPlans.size(); i++) {\n+            if (!indexPlans.get(i).equalsWithoutChildren(otherIndexPlans.get(i), equivalences)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCodeWithoutChildren() {\n+        return Objects.hash(indexPlans, composer);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n+    public boolean equals(Object other) {\n+        return structuralEquals(other);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return structuralHashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return composer.toString(indexPlans);\n+    }\n+\n+    /**\n+     * Plan extension of {@link ComposedBitmapIndexCursor.Composer}.\n+     */\n+    @VisibleForTesting\n+    public abstract static class ComposerBase implements ComposedBitmapIndexCursor.Composer, PlanHashable {\n+        @Nonnull\n+        abstract String toString(@Nullable List<?> sources);\n+\n+        @Override\n+        public String toString() {\n+            return toString(null);\n+        }\n+    }\n+\n+    static class IndexComposer extends ComposerBase {\n+        private final int position;\n+\n+        IndexComposer(int position) {\n+            this.position = position;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        String toString(@Nullable List<?> sources) {\n+            if (sources == null) {\n+                return String.format(\"[%d]\", position);\n+            } else {\n+                return sources.get(position).toString();\n+            }\n+        }\n+\n+        @Nullable\n+        @Override\n+        public byte[] compose(@Nonnull List<byte[]> bitmaps, int size) {\n+            return bitmaps.get(position);\n+        }\n+\n+        @Override\n+        public int planHash() {\n+            return position;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) {\n+                return true;\n+            }\n+            if (o == null || getClass() != o.getClass()) {\n+                return false;\n+            }\n+            IndexComposer that = (IndexComposer) o;\n+            return position == that.position;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(position);\n+        }\n+    }\n+\n+    abstract static class OperatorComposer extends ComposerBase {\n+        @Nonnull\n+        private final List<ComposerBase> children;\n+\n+        OperatorComposer(@Nonnull List<ComposerBase> children) {\n+            this.children = children;\n+        }\n+\n+        @Nonnull\n+        abstract String operator();\n+\n+        @Nonnull\n+        @Override\n+        String toString(@Nullable List<?> sources) {\n+            return children.stream().map(child -> child.toString(sources)).collect(Collectors.joining(\" \" + operator() + \" \"));\n+        }\n+\n+        @Nullable\n+        @Override\n+        public byte[] compose(@Nonnull List<byte[]> bitmaps, int size) {\n+            final List<byte[]> operands = new ArrayList<>(children.size());\n+            for (ComposerBase child : children) {\n+                operands.add(child.compose(bitmaps, size));\n+            }\n+            return operate(operands, new byte[size]);\n+        }\n+\n+        @Nullable\n+        abstract byte[] operate(@Nonnull List<byte[]> operands, @Nonnull byte[] result);\n+\n+        @Override\n+        public int planHash() {\n+            return PlanHashable.planHash(children) + operator().hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) {\n+                return true;\n+            }\n+            if (o == null || getClass() != o.getClass()) {\n+                return false;\n+            }\n+            OperatorComposer that = (OperatorComposer) o;\n+            return children.equals(that.children) &&\n+                    operator().equals(that.operator());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(children) + operator().hashCode();\n+        }\n+    }\n+\n+    static class AndComposer extends OperatorComposer {\n+        public AndComposer(@Nonnull List<ComposerBase> children) {\n+            super(children);\n+        }\n+\n+        @Nonnull\n+        @Override\n+        String operator() {\n+            return \"BITAND\";\n+        }\n+\n+        @Nullable\n+        @Override\n+        byte[] operate(@Nonnull List<byte[]> operands, @Nonnull byte[] result) {\n+            boolean first = true;\n+            boolean empty = true;\n+            for (final byte[] operand : operands) {\n+                if (operand == null) {\n+                    return null;\n+                }\n+                if (first) {\n+                    System.arraycopy(operand, 0, result, 0, result.length);\n+                    empty = first = false;\n+                } else {\n+                    empty = true;\n+                    for (int j = 0; j < result.length; j++) {\n+                        final byte b = (byte) (result[j] & operand[j]);", "originalCommit": "ee39171c186302229dbd9ee1911a3003ffd07a89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwOTI5NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470909294", "bodyText": "The handling of a null bitmap is also different between AND and [X]OR. I am concerned about JIT doing as well with a virtual in the middle of the inner loop over the bitmap. I added a comment.", "author": "MMcM", "createdAt": "2020-08-14T23:57:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMyMjkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMzMTE4Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470331182", "bodyText": "Hm, I guess the bitmap index function doesn't support sorting descending by position? That's probably fine (at least for now)", "author": "alecgrieser", "createdAt": "2020-08-14T00:31:46Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexQueryPlan.java", "diffHunk": "@@ -0,0 +1,496 @@\n+/*\n+ * ComposedBitmapIndexQueryPlan.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.bitmap;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.EvaluationContext;\n+import com.apple.foundationdb.record.ExecuteProperties;\n+import com.apple.foundationdb.record.IndexEntry;\n+import com.apple.foundationdb.record.PlanHashable;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.provider.common.StoreTimer;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBQueriedRecord;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreBase;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBStoreTimer;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryCoveringIndexPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlanWithNoChildren;\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.CorrelationIdentifier;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.explain.NodeInfo;\n+import com.apple.foundationdb.record.query.plan.temp.explain.PlannerGraph;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.Message;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A query plan implementing a bit-wise merge of two or more covering index scans of {@code BITMAP_VALUE} indexes.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public class ComposedBitmapIndexQueryPlan implements RecordQueryPlanWithNoChildren {\n+\n+    @Nonnull\n+    // NOTE: These aren't children in the sense of RecordQueryPlanWithChildren\n+    // for the same reason as RecordQueryCoveringIndexPlan isn't RecordQueryPlanWithChild.\n+    private final List<RecordQueryCoveringIndexPlan> indexPlans;\n+    @Nonnull\n+    private final ComposerBase composer;\n+\n+    ComposedBitmapIndexQueryPlan(@Nonnull List<RecordQueryCoveringIndexPlan> indexPlans, @Nonnull ComposerBase composer) {\n+        this.indexPlans = indexPlans;\n+        this.composer = composer;\n+    }\n+\n+    @Nonnull\n+    public List<RecordQueryCoveringIndexPlan> getIndexPlans() {\n+        return indexPlans;\n+    }\n+\n+    @Nonnull\n+    public ComposerBase getComposer() {\n+        return composer;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public <M extends Message> RecordCursor<FDBQueriedRecord<M>> execute(@Nonnull FDBRecordStoreBase<M> store, @Nonnull EvaluationContext context,\n+                                                                         @Nullable byte[] continuation, @Nonnull ExecuteProperties executeProperties) {\n+        final ExecuteProperties scanExecuteProperties = executeProperties.getSkip() > 0 ? executeProperties.clearSkipAndAdjustLimit() : executeProperties;\n+        final List<Function<byte[], RecordCursor<IndexEntry>>> cursorFunctions = indexPlans.stream()\n+                .map(RecordQueryCoveringIndexPlan::getIndexPlan)\n+                .map(scan -> (Function<byte[], RecordCursor<IndexEntry>>) childContinuation -> scan.executeEntries(store, context, childContinuation, scanExecuteProperties))\n+                .collect(Collectors.toList());\n+        return ComposedBitmapIndexCursor.create(cursorFunctions, composer, continuation, store.getTimer())\n+                // Composers can return null bitmaps when empty, which is then left out of the result set.\n+                .filter(indexEntry -> indexEntry.getValue().get(0) != null)\n+                .map(indexPlans.get(0).indexEntryToQueriedRecord(store));\n+    }\n+\n+    @Override\n+    public boolean isReverse() {\n+        return false;", "originalCommit": "ee39171c186302229dbd9ee1911a3003ffd07a89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxMDM0NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470910344", "bodyText": "Yes, I think it's kind of ill-defined. Like does the whole bitmap reverse or just the enumeration order?", "author": "MMcM", "createdAt": "2020-08-15T00:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMzMTE4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI2Mjc1OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r474262758", "bodyText": "Yeah. I...think it would reverse the whole bitmap, though I suppose in some sense, that's a little Endian vs big Endian debate. In any case, leaving it as not allowed (at least for now) rather than trying to settle that debate seems like the right call to me.", "author": "alecgrieser", "createdAt": "2020-08-20T20:46:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMzMTE4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg0ODM1Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470848357", "bodyText": "It's a little weird that planning takes an FDBRecordStore here. I think the only things it uses are the meta-data and which indexes are readable. Should this take those two items instead (or a RecordQueryPlanner if the appropriate accessor methods on the meta-data and record store state are added)?\nThere's something about the API that is a little weird in general (like having separate tryBuild and tryPlan methods). Like, it would seem like most users would want a method that's closer to the plan method in the test class, or a variant that takes a RecordQuery that provides the record types, the required results, and the filter (and errors on a sort?).", "author": "alecgrieser", "createdAt": "2020-08-14T20:22:24Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexAggregate.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * ComposedBitmapIndex.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.bitmap;\n+\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexAggregateFunction;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStore;\n+import com.apple.foundationdb.record.provider.foundationdb.IndexAggregateGroupKeys;\n+import com.apple.foundationdb.record.provider.foundationdb.IndexFunctionHelper;\n+import com.apple.foundationdb.record.provider.foundationdb.indexes.BitmapValueIndexMaintainer;\n+import com.apple.foundationdb.record.query.QueryToKeyMatcher;\n+import com.apple.foundationdb.record.query.RecordQuery;\n+import com.apple.foundationdb.record.query.expressions.AndOrComponent;\n+import com.apple.foundationdb.record.query.expressions.ComponentWithComparison;\n+import com.apple.foundationdb.record.query.expressions.FieldWithComparison;\n+import com.apple.foundationdb.record.query.expressions.NotComponent;\n+import com.apple.foundationdb.record.query.expressions.OrComponent;\n+import com.apple.foundationdb.record.query.expressions.Query;\n+import com.apple.foundationdb.record.query.expressions.QueryComponent;\n+import com.apple.foundationdb.record.query.expressions.QueryKeyExpressionWithComparison;\n+import com.apple.foundationdb.record.query.plan.RecordQueryPlanner;\n+import com.apple.foundationdb.record.query.plan.planning.FilterSatisfiedMask;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryCoveringIndexPlan;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Transform a tree of Boolean expressions into a tree of bitwise operations on streams of bitmaps.\n+ *\n+ * So, {@code AND} turns into {@code BITAND} and {@code OR} into {@code BITOR}, with the leaves of the streams\n+ * being scans of a {@code BITMAP_VALUE} index keyed by the leaf condition.\n+ *\n+ * Optional additional grouping predicates for all indexes are also preserved.\n+ */\n+public class ComposedBitmapIndexAggregate {\n+    @Nonnull\n+    private final Node root;\n+\n+    ComposedBitmapIndexAggregate(@Nonnull Node root) {\n+        this.root = root;\n+    }\n+\n+    /**\n+     * Try to build a composed bitmap for the given aggregate function and filters.\n+     * <p>\n+     * The function should use a supported aggregate function (currently {@value BitmapValueIndexMaintainer#AGGREGATE_FUNCTION_NAME})\n+     * and the bitmap-indexed position field grouped by any common fields.\n+     * The filter should supply equality conditions to the common fields.\n+     * The filter can include additional equality conditions on various other fields for which there are appropriate bitmap indexes, in a Boolean\n+     * expression that will be transformed into a set the corresponding bit operations on the bitmaps.\n+     * The filter can also include range conditions on the position field.\n+     * </p>\n+     * @param recordStore the record store containing the indexed data\n+     * @param recordTypeNames the record types on which the indexes are defined\n+     * @param indexAggregateFunction the function giving the desired position and grouping\n+     * @param filter conditions on the groups and position\n+     * @return an {@code Optional} composed bitmap or {@code Optional.empty} if there conditions could not be satisfied\n+     */\n+    @Nonnull\n+    public static Optional<ComposedBitmapIndexAggregate> tryBuild(@Nonnull FDBRecordStore recordStore,", "originalCommit": "ee39171c186302229dbd9ee1911a3003ffd07a89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwOTI4NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470909284", "bodyText": "I added some more public methods elsewhere so that it could take a planner and a query as the basic entry and made the test fixture use that.", "author": "MMcM", "createdAt": "2020-08-14T23:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg0ODM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1MjkwNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470852906", "bodyText": "This parameter in general, taking a query, was confusing to me for a long time, I guess because it wasn't clear to me that this was intended to be a \"query prototype\" to be filled in with the appropriate filter when planning the various legs.", "author": "alecgrieser", "createdAt": "2020-08-14T20:34:20Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexAggregate.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * ComposedBitmapIndex.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.bitmap;\n+\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexAggregateFunction;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStore;\n+import com.apple.foundationdb.record.provider.foundationdb.IndexAggregateGroupKeys;\n+import com.apple.foundationdb.record.provider.foundationdb.IndexFunctionHelper;\n+import com.apple.foundationdb.record.provider.foundationdb.indexes.BitmapValueIndexMaintainer;\n+import com.apple.foundationdb.record.query.QueryToKeyMatcher;\n+import com.apple.foundationdb.record.query.RecordQuery;\n+import com.apple.foundationdb.record.query.expressions.AndOrComponent;\n+import com.apple.foundationdb.record.query.expressions.ComponentWithComparison;\n+import com.apple.foundationdb.record.query.expressions.FieldWithComparison;\n+import com.apple.foundationdb.record.query.expressions.NotComponent;\n+import com.apple.foundationdb.record.query.expressions.OrComponent;\n+import com.apple.foundationdb.record.query.expressions.Query;\n+import com.apple.foundationdb.record.query.expressions.QueryComponent;\n+import com.apple.foundationdb.record.query.expressions.QueryKeyExpressionWithComparison;\n+import com.apple.foundationdb.record.query.plan.RecordQueryPlanner;\n+import com.apple.foundationdb.record.query.plan.planning.FilterSatisfiedMask;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryCoveringIndexPlan;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Transform a tree of Boolean expressions into a tree of bitwise operations on streams of bitmaps.\n+ *\n+ * So, {@code AND} turns into {@code BITAND} and {@code OR} into {@code BITOR}, with the leaves of the streams\n+ * being scans of a {@code BITMAP_VALUE} index keyed by the leaf condition.\n+ *\n+ * Optional additional grouping predicates for all indexes are also preserved.\n+ */\n+public class ComposedBitmapIndexAggregate {\n+    @Nonnull\n+    private final Node root;\n+\n+    ComposedBitmapIndexAggregate(@Nonnull Node root) {\n+        this.root = root;\n+    }\n+\n+    /**\n+     * Try to build a composed bitmap for the given aggregate function and filters.\n+     * <p>\n+     * The function should use a supported aggregate function (currently {@value BitmapValueIndexMaintainer#AGGREGATE_FUNCTION_NAME})\n+     * and the bitmap-indexed position field grouped by any common fields.\n+     * The filter should supply equality conditions to the common fields.\n+     * The filter can include additional equality conditions on various other fields for which there are appropriate bitmap indexes, in a Boolean\n+     * expression that will be transformed into a set the corresponding bit operations on the bitmaps.\n+     * The filter can also include range conditions on the position field.\n+     * </p>\n+     * @param recordStore the record store containing the indexed data\n+     * @param recordTypeNames the record types on which the indexes are defined\n+     * @param indexAggregateFunction the function giving the desired position and grouping\n+     * @param filter conditions on the groups and position\n+     * @return an {@code Optional} composed bitmap or {@code Optional.empty} if there conditions could not be satisfied\n+     */\n+    @Nonnull\n+    public static Optional<ComposedBitmapIndexAggregate> tryBuild(@Nonnull FDBRecordStore recordStore,\n+                                                                  @Nonnull List<String> recordTypeNames,\n+                                                                  @Nonnull IndexAggregateFunction indexAggregateFunction,\n+                                                                  @Nonnull QueryComponent filter) {\n+        List<QueryComponent> groupFilters = new ArrayList<>();\n+        List<QueryComponent> indexFilters = new ArrayList<>();\n+        if (!separateGroupFilters(filter, indexAggregateFunction, groupFilters, indexFilters) || indexFilters.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        Builder builder = new Builder(recordStore, recordTypeNames, groupFilters, indexAggregateFunction);\n+        return builder.tryBuild(indexFilters.size() > 1 ? Query.and(indexFilters) : indexFilters.get(0))\n+            .map(ComposedBitmapIndexAggregate::new);\n+    }\n+\n+    /**\n+     * Try to turn this composed bitmap into an executable plan.\n+     * @param query a base query over the target record types\n+     * @param recordMetaData the record meta-data for planning\n+     * @param planner a query planner to use to construct the plans\n+     * @return an {@code Optional} query plan or {@code Optional.empty} if planning is not possible\n+     */\n+    @Nonnull\n+    public Optional<ComposedBitmapIndexQueryPlan> tryPlan(@Nonnull RecordQuery.Builder query,", "originalCommit": "ee39171c186302229dbd9ee1911a3003ffd07a89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwOTI3OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470909278", "bodyText": "Renamed to queryBuilder and java doc updated. The \"simpler\" entry takes a whole RecordQuery now.", "author": "MMcM", "createdAt": "2020-08-14T23:57:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1MjkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1MzE4Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470853183", "bodyText": "Hm, so the idea is that the base query provides the type(s) and the required results and the index node provides the filter, and then, as a side effect, the final planned index node's filter will end up in the query builder, but that's not a desired side effect (per se), it just \"happens\".\nI wonder if instead the object (or method) should take a query (which I also suggested above), and then it can call .toBuilder on the query here to get a temporary object and override the filter.", "author": "alecgrieser", "createdAt": "2020-08-14T20:34:58Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexAggregate.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * ComposedBitmapIndex.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.bitmap;\n+\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexAggregateFunction;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStore;\n+import com.apple.foundationdb.record.provider.foundationdb.IndexAggregateGroupKeys;\n+import com.apple.foundationdb.record.provider.foundationdb.IndexFunctionHelper;\n+import com.apple.foundationdb.record.provider.foundationdb.indexes.BitmapValueIndexMaintainer;\n+import com.apple.foundationdb.record.query.QueryToKeyMatcher;\n+import com.apple.foundationdb.record.query.RecordQuery;\n+import com.apple.foundationdb.record.query.expressions.AndOrComponent;\n+import com.apple.foundationdb.record.query.expressions.ComponentWithComparison;\n+import com.apple.foundationdb.record.query.expressions.FieldWithComparison;\n+import com.apple.foundationdb.record.query.expressions.NotComponent;\n+import com.apple.foundationdb.record.query.expressions.OrComponent;\n+import com.apple.foundationdb.record.query.expressions.Query;\n+import com.apple.foundationdb.record.query.expressions.QueryComponent;\n+import com.apple.foundationdb.record.query.expressions.QueryKeyExpressionWithComparison;\n+import com.apple.foundationdb.record.query.plan.RecordQueryPlanner;\n+import com.apple.foundationdb.record.query.plan.planning.FilterSatisfiedMask;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryCoveringIndexPlan;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Transform a tree of Boolean expressions into a tree of bitwise operations on streams of bitmaps.\n+ *\n+ * So, {@code AND} turns into {@code BITAND} and {@code OR} into {@code BITOR}, with the leaves of the streams\n+ * being scans of a {@code BITMAP_VALUE} index keyed by the leaf condition.\n+ *\n+ * Optional additional grouping predicates for all indexes are also preserved.\n+ */\n+public class ComposedBitmapIndexAggregate {\n+    @Nonnull\n+    private final Node root;\n+\n+    ComposedBitmapIndexAggregate(@Nonnull Node root) {\n+        this.root = root;\n+    }\n+\n+    /**\n+     * Try to build a composed bitmap for the given aggregate function and filters.\n+     * <p>\n+     * The function should use a supported aggregate function (currently {@value BitmapValueIndexMaintainer#AGGREGATE_FUNCTION_NAME})\n+     * and the bitmap-indexed position field grouped by any common fields.\n+     * The filter should supply equality conditions to the common fields.\n+     * The filter can include additional equality conditions on various other fields for which there are appropriate bitmap indexes, in a Boolean\n+     * expression that will be transformed into a set the corresponding bit operations on the bitmaps.\n+     * The filter can also include range conditions on the position field.\n+     * </p>\n+     * @param recordStore the record store containing the indexed data\n+     * @param recordTypeNames the record types on which the indexes are defined\n+     * @param indexAggregateFunction the function giving the desired position and grouping\n+     * @param filter conditions on the groups and position\n+     * @return an {@code Optional} composed bitmap or {@code Optional.empty} if there conditions could not be satisfied\n+     */\n+    @Nonnull\n+    public static Optional<ComposedBitmapIndexAggregate> tryBuild(@Nonnull FDBRecordStore recordStore,\n+                                                                  @Nonnull List<String> recordTypeNames,\n+                                                                  @Nonnull IndexAggregateFunction indexAggregateFunction,\n+                                                                  @Nonnull QueryComponent filter) {\n+        List<QueryComponent> groupFilters = new ArrayList<>();\n+        List<QueryComponent> indexFilters = new ArrayList<>();\n+        if (!separateGroupFilters(filter, indexAggregateFunction, groupFilters, indexFilters) || indexFilters.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        Builder builder = new Builder(recordStore, recordTypeNames, groupFilters, indexAggregateFunction);\n+        return builder.tryBuild(indexFilters.size() > 1 ? Query.and(indexFilters) : indexFilters.get(0))\n+            .map(ComposedBitmapIndexAggregate::new);\n+    }\n+\n+    /**\n+     * Try to turn this composed bitmap into an executable plan.\n+     * @param query a base query over the target record types\n+     * @param recordMetaData the record meta-data for planning\n+     * @param planner a query planner to use to construct the plans\n+     * @return an {@code Optional} query plan or {@code Optional.empty} if planning is not possible\n+     */\n+    @Nonnull\n+    public Optional<ComposedBitmapIndexQueryPlan> tryPlan(@Nonnull RecordQuery.Builder query,\n+                                                          @Nonnull RecordMetaData recordMetaData,\n+                                                          @Nonnull RecordQueryPlanner planner) {\n+        final List<RecordQueryCoveringIndexPlan> indexScans = new ArrayList<>();\n+        final Map<IndexNode, ComposedBitmapIndexQueryPlan.IndexComposer> indexComposers = new IdentityHashMap<>();\n+        return Optional.ofNullable(plan(root, query, recordMetaData, planner, indexScans, indexComposers))\n+                .map(composer -> new ComposedBitmapIndexQueryPlan(indexScans, composer));\n+    }\n+\n+    private static boolean separateGroupFilters(@Nonnull QueryComponent filter,\n+                                                @Nonnull IndexAggregateFunction indexAggregateFunction,\n+                                                @Nonnull List<QueryComponent> groupFilters,\n+                                                @Nonnull List<QueryComponent> indexFilters) {\n+        QueryToKeyMatcher matcher = new QueryToKeyMatcher(filter);\n+        FilterSatisfiedMask filterMask = FilterSatisfiedMask.of(filter);\n+        QueryToKeyMatcher.Match match = matcher.matchesCoveringKey(((GroupingKeyExpression)indexAggregateFunction.getOperand()).getGroupingSubKey(), filterMask);\n+        if (match.getType() != QueryToKeyMatcher.MatchType.EQUALITY) {\n+            return false;   // Did not manage to fully restrict the grouping key.\n+        }\n+        // The position key(s) can also be constrained with inequalities and those go among the group filters.\n+        matcher.matchesCoveringKey(((GroupingKeyExpression)indexAggregateFunction.getOperand()).getGroupedSubKey(), filterMask);\n+        if (filterMask.allSatisfied()) {\n+            return false;   // Not enough conditions left over.\n+        }\n+        for (FilterSatisfiedMask child : filterMask.getChildren()) {\n+            if (child.allSatisfied()) {\n+                groupFilters.add(child.getFilter());\n+            } else {\n+                indexFilters.add(child.getFilter());\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Nullable\n+    private ComposedBitmapIndexQueryPlan.ComposerBase plan(@Nonnull Node node, @Nonnull RecordQuery.Builder query,\n+                                                           @Nonnull RecordMetaData recordMetaData, @Nonnull RecordQueryPlanner planner,\n+                                                           @Nonnull List<RecordQueryCoveringIndexPlan> indexScans,\n+                                                           @Nonnull Map<IndexNode, ComposedBitmapIndexQueryPlan.IndexComposer> indexComposers) {\n+        if (node instanceof OperatorNode) {\n+            final OperatorNode operatorNode = (OperatorNode) node;\n+            final List<ComposedBitmapIndexQueryPlan.ComposerBase> children = new ArrayList<>();\n+            for (Node n : operatorNode.operands) {\n+                ComposedBitmapIndexQueryPlan.ComposerBase plan = plan(n, query, recordMetaData, planner, indexScans, indexComposers);\n+                if (plan == null) {\n+                    return null;\n+                }\n+                children.add(plan);\n+            }\n+            switch (operatorNode.operator) {\n+                case AND:\n+                    return new ComposedBitmapIndexQueryPlan.AndComposer(children);\n+                case OR:\n+                    return new ComposedBitmapIndexQueryPlan.OrComposer(children);\n+                case NOT:\n+                    return new ComposedBitmapIndexQueryPlan.NotComposer(children.get(0));\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown operator node: \" + node);\n+            }\n+        } else if (node instanceof IndexNode) {\n+            return indexComposers.computeIfAbsent((IndexNode)node, indexNode -> {\n+                query.setFilter(indexNode.filter);", "originalCommit": "ee39171c186302229dbd9ee1911a3003ffd07a89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwOTI1Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470909257", "bodyText": "The builder is now only reused in the advanced case and there is a comment about this.,", "author": "MMcM", "createdAt": "2020-08-14T23:57:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1MzE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1NDA3NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470854075", "bodyText": "What is the purpose of additionalKey here?", "author": "alecgrieser", "createdAt": "2020-08-14T20:37:31Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexAggregate.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * ComposedBitmapIndex.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.bitmap;\n+\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexAggregateFunction;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStore;\n+import com.apple.foundationdb.record.provider.foundationdb.IndexAggregateGroupKeys;\n+import com.apple.foundationdb.record.provider.foundationdb.IndexFunctionHelper;\n+import com.apple.foundationdb.record.provider.foundationdb.indexes.BitmapValueIndexMaintainer;\n+import com.apple.foundationdb.record.query.QueryToKeyMatcher;\n+import com.apple.foundationdb.record.query.RecordQuery;\n+import com.apple.foundationdb.record.query.expressions.AndOrComponent;\n+import com.apple.foundationdb.record.query.expressions.ComponentWithComparison;\n+import com.apple.foundationdb.record.query.expressions.FieldWithComparison;\n+import com.apple.foundationdb.record.query.expressions.NotComponent;\n+import com.apple.foundationdb.record.query.expressions.OrComponent;\n+import com.apple.foundationdb.record.query.expressions.Query;\n+import com.apple.foundationdb.record.query.expressions.QueryComponent;\n+import com.apple.foundationdb.record.query.expressions.QueryKeyExpressionWithComparison;\n+import com.apple.foundationdb.record.query.plan.RecordQueryPlanner;\n+import com.apple.foundationdb.record.query.plan.planning.FilterSatisfiedMask;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryCoveringIndexPlan;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Transform a tree of Boolean expressions into a tree of bitwise operations on streams of bitmaps.\n+ *\n+ * So, {@code AND} turns into {@code BITAND} and {@code OR} into {@code BITOR}, with the leaves of the streams\n+ * being scans of a {@code BITMAP_VALUE} index keyed by the leaf condition.\n+ *\n+ * Optional additional grouping predicates for all indexes are also preserved.\n+ */\n+public class ComposedBitmapIndexAggregate {\n+    @Nonnull\n+    private final Node root;\n+\n+    ComposedBitmapIndexAggregate(@Nonnull Node root) {\n+        this.root = root;\n+    }\n+\n+    /**\n+     * Try to build a composed bitmap for the given aggregate function and filters.\n+     * <p>\n+     * The function should use a supported aggregate function (currently {@value BitmapValueIndexMaintainer#AGGREGATE_FUNCTION_NAME})\n+     * and the bitmap-indexed position field grouped by any common fields.\n+     * The filter should supply equality conditions to the common fields.\n+     * The filter can include additional equality conditions on various other fields for which there are appropriate bitmap indexes, in a Boolean\n+     * expression that will be transformed into a set the corresponding bit operations on the bitmaps.\n+     * The filter can also include range conditions on the position field.\n+     * </p>\n+     * @param recordStore the record store containing the indexed data\n+     * @param recordTypeNames the record types on which the indexes are defined\n+     * @param indexAggregateFunction the function giving the desired position and grouping\n+     * @param filter conditions on the groups and position\n+     * @return an {@code Optional} composed bitmap or {@code Optional.empty} if there conditions could not be satisfied\n+     */\n+    @Nonnull\n+    public static Optional<ComposedBitmapIndexAggregate> tryBuild(@Nonnull FDBRecordStore recordStore,\n+                                                                  @Nonnull List<String> recordTypeNames,\n+                                                                  @Nonnull IndexAggregateFunction indexAggregateFunction,\n+                                                                  @Nonnull QueryComponent filter) {\n+        List<QueryComponent> groupFilters = new ArrayList<>();\n+        List<QueryComponent> indexFilters = new ArrayList<>();\n+        if (!separateGroupFilters(filter, indexAggregateFunction, groupFilters, indexFilters) || indexFilters.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        Builder builder = new Builder(recordStore, recordTypeNames, groupFilters, indexAggregateFunction);\n+        return builder.tryBuild(indexFilters.size() > 1 ? Query.and(indexFilters) : indexFilters.get(0))\n+            .map(ComposedBitmapIndexAggregate::new);\n+    }\n+\n+    /**\n+     * Try to turn this composed bitmap into an executable plan.\n+     * @param query a base query over the target record types\n+     * @param recordMetaData the record meta-data for planning\n+     * @param planner a query planner to use to construct the plans\n+     * @return an {@code Optional} query plan or {@code Optional.empty} if planning is not possible\n+     */\n+    @Nonnull\n+    public Optional<ComposedBitmapIndexQueryPlan> tryPlan(@Nonnull RecordQuery.Builder query,\n+                                                          @Nonnull RecordMetaData recordMetaData,\n+                                                          @Nonnull RecordQueryPlanner planner) {\n+        final List<RecordQueryCoveringIndexPlan> indexScans = new ArrayList<>();\n+        final Map<IndexNode, ComposedBitmapIndexQueryPlan.IndexComposer> indexComposers = new IdentityHashMap<>();\n+        return Optional.ofNullable(plan(root, query, recordMetaData, planner, indexScans, indexComposers))\n+                .map(composer -> new ComposedBitmapIndexQueryPlan(indexScans, composer));\n+    }\n+\n+    private static boolean separateGroupFilters(@Nonnull QueryComponent filter,\n+                                                @Nonnull IndexAggregateFunction indexAggregateFunction,\n+                                                @Nonnull List<QueryComponent> groupFilters,\n+                                                @Nonnull List<QueryComponent> indexFilters) {\n+        QueryToKeyMatcher matcher = new QueryToKeyMatcher(filter);\n+        FilterSatisfiedMask filterMask = FilterSatisfiedMask.of(filter);\n+        QueryToKeyMatcher.Match match = matcher.matchesCoveringKey(((GroupingKeyExpression)indexAggregateFunction.getOperand()).getGroupingSubKey(), filterMask);\n+        if (match.getType() != QueryToKeyMatcher.MatchType.EQUALITY) {\n+            return false;   // Did not manage to fully restrict the grouping key.\n+        }\n+        // The position key(s) can also be constrained with inequalities and those go among the group filters.\n+        matcher.matchesCoveringKey(((GroupingKeyExpression)indexAggregateFunction.getOperand()).getGroupedSubKey(), filterMask);\n+        if (filterMask.allSatisfied()) {\n+            return false;   // Not enough conditions left over.\n+        }\n+        for (FilterSatisfiedMask child : filterMask.getChildren()) {\n+            if (child.allSatisfied()) {\n+                groupFilters.add(child.getFilter());\n+            } else {\n+                indexFilters.add(child.getFilter());\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Nullable\n+    private ComposedBitmapIndexQueryPlan.ComposerBase plan(@Nonnull Node node, @Nonnull RecordQuery.Builder query,\n+                                                           @Nonnull RecordMetaData recordMetaData, @Nonnull RecordQueryPlanner planner,\n+                                                           @Nonnull List<RecordQueryCoveringIndexPlan> indexScans,\n+                                                           @Nonnull Map<IndexNode, ComposedBitmapIndexQueryPlan.IndexComposer> indexComposers) {\n+        if (node instanceof OperatorNode) {\n+            final OperatorNode operatorNode = (OperatorNode) node;\n+            final List<ComposedBitmapIndexQueryPlan.ComposerBase> children = new ArrayList<>();\n+            for (Node n : operatorNode.operands) {\n+                ComposedBitmapIndexQueryPlan.ComposerBase plan = plan(n, query, recordMetaData, planner, indexScans, indexComposers);\n+                if (plan == null) {\n+                    return null;\n+                }\n+                children.add(plan);\n+            }\n+            switch (operatorNode.operator) {\n+                case AND:\n+                    return new ComposedBitmapIndexQueryPlan.AndComposer(children);\n+                case OR:\n+                    return new ComposedBitmapIndexQueryPlan.OrComposer(children);\n+                case NOT:\n+                    return new ComposedBitmapIndexQueryPlan.NotComposer(children.get(0));\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown operator node: \" + node);\n+            }\n+        } else if (node instanceof IndexNode) {\n+            return indexComposers.computeIfAbsent((IndexNode)node, indexNode -> {\n+                query.setFilter(indexNode.filter);\n+                final Index index = recordMetaData.getIndex(indexNode.indexName);\n+                final KeyExpression wholeKey = ((GroupingKeyExpression)index.getRootExpression()).getWholeKey();\n+                final RecordQueryCoveringIndexPlan indexScan = planner.planCoveringAggregateIndex(query.build(), index, wholeKey);\n+                if (indexScan == null) {\n+                    return null;\n+                }\n+                final int position = indexScans.size();\n+                indexScans.add(indexScan);\n+                return new ComposedBitmapIndexQueryPlan.IndexComposer(position);\n+            });\n+        } else {\n+            throw new IllegalArgumentException(\"Unknown node type: \" + node);\n+        }\n+    }\n+\n+    static class Node {\n+    }\n+\n+    static class OperatorNode extends Node {\n+        enum Operator { AND, OR, NOT }\n+\n+        @Nonnull\n+        private final Operator operator;\n+        @Nonnull\n+        private final List<Node> operands;\n+\n+        OperatorNode(@Nonnull Operator operator, @Nonnull List<Node> operands) {\n+            this.operator = operator;\n+            this.operands = operands;\n+        }\n+    }\n+\n+    // Note that the same IndexNode can occur multiple times in the tree, if the same condition subexpression appears\n+    // multiple times in the filter.\n+    static class IndexNode extends Node {\n+        @Nonnull\n+        private final QueryComponent filter;\n+        @Nonnull\n+        private final IndexAggregateGroupKeys groupKeys;\n+        @Nonnull\n+        private final String indexName;\n+\n+        IndexNode(@Nonnull QueryComponent filter, @Nonnull IndexAggregateGroupKeys groupKeys, @Nonnull String indexName) {\n+            this.filter = filter;\n+            this.groupKeys = groupKeys;\n+            this.indexName = indexName;\n+        }\n+    }\n+\n+    static class Builder {\n+        @Nonnull\n+        private final FDBRecordStore recordStore;\n+        @Nonnull\n+        private final List<String> recordTypeNames;\n+        @Nonnull\n+        private final List<QueryComponent> groupFilters;\n+        @Nonnull\n+        private final IndexAggregateFunction indexAggregateFunction;\n+        @Nullable\n+        private Map<KeyExpression, Index> bitmapIndexes;\n+        @Nullable\n+        private Map<QueryComponent, IndexNode> indexNodes;\n+\n+        Builder(@Nonnull final FDBRecordStore recordStore, @Nonnull List<String> recordTypeNames,\n+                @Nonnull List<QueryComponent> groupFilters, @Nonnull IndexAggregateFunction indexAggregateFunction) {\n+            this.recordStore = recordStore;\n+            this.recordTypeNames = recordTypeNames;\n+            this.groupFilters = groupFilters;\n+            this.indexAggregateFunction = indexAggregateFunction;\n+        }\n+\n+        @Nonnull\n+        Optional<Node> tryBuild(@Nonnull QueryComponent indexFilter) {\n+            if (indexFilter instanceof ComponentWithComparison) {\n+                return indexScan(indexFilter);\n+            }\n+            if (indexFilter instanceof AndOrComponent) {\n+                final AndOrComponent andOrComponent = (AndOrComponent) indexFilter;\n+                List<Node> childNodes = new ArrayList<>(andOrComponent.getChildren().size());\n+                for (QueryComponent child : andOrComponent.getChildren()) {\n+                    Optional<Node> childNode = tryBuild(child);\n+                    if (!childNode.isPresent()) {\n+                        return Optional.empty();\n+                    }\n+                    childNodes.add(childNode.get());\n+                }\n+                final OperatorNode.Operator operator = indexFilter instanceof OrComponent ? OperatorNode.Operator.OR : OperatorNode.Operator.AND;\n+                return Optional.of(new OperatorNode(operator, childNodes));\n+            }\n+            if (indexFilter instanceof NotComponent) {\n+                return tryBuild(((NotComponent) indexFilter).getChild())\n+                        .map(childNode -> new OperatorNode(OperatorNode.Operator.NOT, Collections.singletonList(childNode)));\n+            }\n+            return Optional.empty();\n+        }\n+\n+        @Nonnull\n+        Optional<Node> indexScan(@Nonnull QueryComponent indexFilter) {\n+            if (bitmapIndexes == null) {\n+                bitmapIndexes = findBitmapIndexes(indexAggregateFunction.getName());\n+                if (bitmapIndexes.isEmpty()) {\n+                    return Optional.empty();\n+                }\n+                indexNodes = new HashMap<>();\n+            }\n+            IndexNode existing = indexNodes.get(indexFilter);\n+            if (existing != null) {\n+                return Optional.of(existing);\n+            }\n+            final KeyExpression additionalKey;\n+            if (indexFilter instanceof FieldWithComparison) {\n+                additionalKey = Key.Expressions.field(((FieldWithComparison) indexFilter).getFieldName());\n+            } else if (indexFilter instanceof QueryKeyExpressionWithComparison) {\n+                additionalKey = ((QueryKeyExpressionWithComparison) indexFilter).getKeyExpression();\n+            } else {\n+                return Optional.empty();\n+            }\n+            GroupingKeyExpression groupKeyExpression = (GroupingKeyExpression)indexAggregateFunction.getOperand();\n+            GroupingKeyExpression fullKey = Key.Expressions.concat(groupKeyExpression.getGroupingSubKey(), additionalKey, groupKeyExpression.getGroupedSubKey())", "originalCommit": "ee39171c186302229dbd9ee1911a3003ffd07a89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwOTI0NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470909245", "bodyText": "Renamed to indexKey.", "author": "MMcM", "createdAt": "2020-08-14T23:57:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1NDA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2NDc1NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470864755", "bodyText": "Hm, this doesn't seem right to me. In particular, I think if you had disjoint ranges of positions for the physical bitmaps from different indexes, then I think it won't merge them together correctly, if I understand how those work. (This doesn't matter for ANDs, but for ORs and NOTs, etc.)", "author": "alecgrieser", "createdAt": "2020-08-14T21:05:20Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexCursor.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * ComposedBitmapIndexCursor.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.bitmap;\n+\n+import com.apple.foundationdb.record.IndexEntry;\n+import com.apple.foundationdb.record.RecordCoreArgumentException;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorContinuation;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBStoreTimer;\n+import com.apple.foundationdb.record.provider.foundationdb.cursors.MergeCursor;\n+import com.apple.foundationdb.record.provider.foundationdb.cursors.MergeCursorState;\n+import com.apple.foundationdb.record.provider.foundationdb.indexes.BitmapValueIndexMaintainer;\n+import com.apple.foundationdb.tuple.Tuple;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+\n+/**\n+ * A {@link RecordCursor} doing a bit-wise merge of bitmaps from two or more {@code BITMAP_VALUE} indexes.\n+ *\n+ * The bit operations can correspond to a Boolean expression over those indexes' rightmost grouping keys.\n+ *\n+ * @see BitmapValueIndexMaintainer\n+ */\n+class ComposedBitmapIndexCursor extends MergeCursor<IndexEntry, IndexEntry, MergeCursorState<IndexEntry>> {\n+    @Nonnull\n+    private final Composer composer;\n+\n+    /**\n+     * Function for generating a bitmap from several others, all of the same size.\n+     */\n+    @FunctionalInterface\n+    public interface Composer {\n+        /**\n+         * Generate a bitmap from several others.\n+         * @param bitmaps a list of bitmaps or {@code null} if the corresponding input is absent / empty\n+         * @param size the common size of the bitmaps\n+         * @return a new bitmap formed from the inputs or {@code null} to represent an empty (all zero) bitmap\n+         */\n+        @Nullable\n+        byte[] compose(@Nonnull List<byte[]> bitmaps, int size);\n+    }\n+\n+    protected ComposedBitmapIndexCursor(@Nonnull List<MergeCursorState<IndexEntry>> cursorStates, @Nullable FDBStoreTimer timer, @Nonnull Composer composer) {\n+        super(cursorStates, timer);\n+        this.composer = composer;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    protected CompletableFuture<List<MergeCursorState<IndexEntry>>> computeNextResultStates() {\n+        final List<MergeCursorState<IndexEntry>> cursorStates = getCursorStates();\n+        return whenAll(cursorStates).thenApply(vignore -> {\n+            boolean anyHasNext = false;\n+            for (MergeCursorState<IndexEntry> cursorState : cursorStates) {\n+                if (cursorState.getResult().hasNext()) {\n+                    anyHasNext = true;\n+                } else if (cursorState.getResult().getNoNextReason().isLimitReached()) {\n+                    // Stop if any has reached limit.\n+                    return Collections.emptyList();\n+                }\n+            }\n+            if (anyHasNext) {\n+                final List<MergeCursorState<IndexEntry>> resultStates = new ArrayList<>();\n+                long nextPosition = Long.MAX_VALUE;\n+                for (MergeCursorState<IndexEntry> cursorState : cursorStates) {\n+                    if (cursorState.getResult().hasNext()) {\n+                        final IndexEntry indexEntry = cursorState.getResult().get();\n+                        final Tuple indexKey = indexEntry.getKey();\n+                        final long position = indexKey.getLong(indexKey.size() - 1);\n+                        if (nextPosition > position) {\n+                            resultStates.clear();\n+                            nextPosition = position;\n+                        }\n+                        if (nextPosition == position) {\n+                            resultStates.add(cursorState);\n+                        }", "originalCommit": "ee39171c186302229dbd9ee1911a3003ffd07a89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxMTA0NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470911044", "bodyText": "Did you have a particular failure scenario in mind? In computeNextResultStates we should get all the states that share a min next position. Then, in getNextResult, we collect the bitmap from those and null from the rest. Composer.compose treats null like an empty bitmap, that is one that is all zeros, that is one that has no positions set.", "author": "MMcM", "createdAt": "2020-08-15T00:07:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2NDc1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNTU0Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470915543", "bodyText": "Oh, I was definitely confused by nextPosition > position. (For whatever reason, I find it easier to reason about if the comparison is the other way around.) Okay, now I understand what this is doing, and I think it looks correct to me. Maybe it could use a comment explaining that it's choosing all of the bitmaps with the minimum position?", "author": "alecgrieser", "createdAt": "2020-08-15T00:38:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2NDc1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI4OTIzNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r474289235", "bodyText": "I added a comment for what it's trying to accomplish.\nSomewhere along the line I developed a preference for\nif (x <op> y) {\n  x = y;\n}", "author": "MMcM", "createdAt": "2020-08-20T21:43:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2NDc1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2NTAwOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470865008", "bodyText": "Should it be part of the planning that the parameter for the size needs to be the same? It seems like the \"ideal\" version would figure it out then, but maybe it's sufficient for the time being for it to be an error here.", "author": "alecgrieser", "createdAt": "2020-08-14T21:06:03Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexCursor.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * ComposedBitmapIndexCursor.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.bitmap;\n+\n+import com.apple.foundationdb.record.IndexEntry;\n+import com.apple.foundationdb.record.RecordCoreArgumentException;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorContinuation;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBStoreTimer;\n+import com.apple.foundationdb.record.provider.foundationdb.cursors.MergeCursor;\n+import com.apple.foundationdb.record.provider.foundationdb.cursors.MergeCursorState;\n+import com.apple.foundationdb.record.provider.foundationdb.indexes.BitmapValueIndexMaintainer;\n+import com.apple.foundationdb.tuple.Tuple;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+\n+/**\n+ * A {@link RecordCursor} doing a bit-wise merge of bitmaps from two or more {@code BITMAP_VALUE} indexes.\n+ *\n+ * The bit operations can correspond to a Boolean expression over those indexes' rightmost grouping keys.\n+ *\n+ * @see BitmapValueIndexMaintainer\n+ */\n+class ComposedBitmapIndexCursor extends MergeCursor<IndexEntry, IndexEntry, MergeCursorState<IndexEntry>> {\n+    @Nonnull\n+    private final Composer composer;\n+\n+    /**\n+     * Function for generating a bitmap from several others, all of the same size.\n+     */\n+    @FunctionalInterface\n+    public interface Composer {\n+        /**\n+         * Generate a bitmap from several others.\n+         * @param bitmaps a list of bitmaps or {@code null} if the corresponding input is absent / empty\n+         * @param size the common size of the bitmaps\n+         * @return a new bitmap formed from the inputs or {@code null} to represent an empty (all zero) bitmap\n+         */\n+        @Nullable\n+        byte[] compose(@Nonnull List<byte[]> bitmaps, int size);\n+    }\n+\n+    protected ComposedBitmapIndexCursor(@Nonnull List<MergeCursorState<IndexEntry>> cursorStates, @Nullable FDBStoreTimer timer, @Nonnull Composer composer) {\n+        super(cursorStates, timer);\n+        this.composer = composer;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    protected CompletableFuture<List<MergeCursorState<IndexEntry>>> computeNextResultStates() {\n+        final List<MergeCursorState<IndexEntry>> cursorStates = getCursorStates();\n+        return whenAll(cursorStates).thenApply(vignore -> {\n+            boolean anyHasNext = false;\n+            for (MergeCursorState<IndexEntry> cursorState : cursorStates) {\n+                if (cursorState.getResult().hasNext()) {\n+                    anyHasNext = true;\n+                } else if (cursorState.getResult().getNoNextReason().isLimitReached()) {\n+                    // Stop if any has reached limit.\n+                    return Collections.emptyList();\n+                }\n+            }\n+            if (anyHasNext) {\n+                final List<MergeCursorState<IndexEntry>> resultStates = new ArrayList<>();\n+                long nextPosition = Long.MAX_VALUE;\n+                for (MergeCursorState<IndexEntry> cursorState : cursorStates) {\n+                    if (cursorState.getResult().hasNext()) {\n+                        final IndexEntry indexEntry = cursorState.getResult().get();\n+                        final Tuple indexKey = indexEntry.getKey();\n+                        final long position = indexKey.getLong(indexKey.size() - 1);\n+                        if (nextPosition > position) {\n+                            resultStates.clear();\n+                            nextPosition = position;\n+                        }\n+                        if (nextPosition == position) {\n+                            resultStates.add(cursorState);\n+                        }\n+                    }\n+                }\n+                return resultStates;\n+            } else {\n+                return Collections.emptyList();\n+            }\n+        });\n+    }\n+\n+    @Nonnull\n+    @Override\n+    protected IndexEntry getNextResult(@Nonnull List<MergeCursorState<IndexEntry>> resultStates) {\n+        final List<MergeCursorState<IndexEntry>> cursorStates = getCursorStates();\n+        final IndexEntry firstEntry = resultStates.get(0).getResult().get();\n+        final int size = firstEntry.getValue().getBytes(0).length;\n+        final List<byte[]> bitmaps = new ArrayList<>(cursorStates.size());\n+        for (MergeCursorState<IndexEntry> cursorState : cursorStates) {\n+            if (resultStates.contains(cursorState)) {\n+                byte[] bitmap = cursorState.getResult().get().getValue().getBytes(0);\n+                if (bitmap.length != size) {\n+                    throw new RecordCoreException(\"Index bitmaps are not all the same size\");", "originalCommit": "ee39171c186302229dbd9ee1911a3003ffd07a89", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2NTI4NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470865284", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new RecordCoreArgumentException(\"not enough child cursors provided to UnionCursor\")\n          \n          \n            \n                        throw new RecordCoreArgumentException(\"not enough child cursors provided to ComposedBitmapIndexCursor\")", "author": "alecgrieser", "createdAt": "2020-08-14T21:06:48Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexCursor.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * ComposedBitmapIndexCursor.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.bitmap;\n+\n+import com.apple.foundationdb.record.IndexEntry;\n+import com.apple.foundationdb.record.RecordCoreArgumentException;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.RecordCursorContinuation;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBStoreTimer;\n+import com.apple.foundationdb.record.provider.foundationdb.cursors.MergeCursor;\n+import com.apple.foundationdb.record.provider.foundationdb.cursors.MergeCursorState;\n+import com.apple.foundationdb.record.provider.foundationdb.indexes.BitmapValueIndexMaintainer;\n+import com.apple.foundationdb.tuple.Tuple;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+\n+/**\n+ * A {@link RecordCursor} doing a bit-wise merge of bitmaps from two or more {@code BITMAP_VALUE} indexes.\n+ *\n+ * The bit operations can correspond to a Boolean expression over those indexes' rightmost grouping keys.\n+ *\n+ * @see BitmapValueIndexMaintainer\n+ */\n+class ComposedBitmapIndexCursor extends MergeCursor<IndexEntry, IndexEntry, MergeCursorState<IndexEntry>> {\n+    @Nonnull\n+    private final Composer composer;\n+\n+    /**\n+     * Function for generating a bitmap from several others, all of the same size.\n+     */\n+    @FunctionalInterface\n+    public interface Composer {\n+        /**\n+         * Generate a bitmap from several others.\n+         * @param bitmaps a list of bitmaps or {@code null} if the corresponding input is absent / empty\n+         * @param size the common size of the bitmaps\n+         * @return a new bitmap formed from the inputs or {@code null} to represent an empty (all zero) bitmap\n+         */\n+        @Nullable\n+        byte[] compose(@Nonnull List<byte[]> bitmaps, int size);\n+    }\n+\n+    protected ComposedBitmapIndexCursor(@Nonnull List<MergeCursorState<IndexEntry>> cursorStates, @Nullable FDBStoreTimer timer, @Nonnull Composer composer) {\n+        super(cursorStates, timer);\n+        this.composer = composer;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    protected CompletableFuture<List<MergeCursorState<IndexEntry>>> computeNextResultStates() {\n+        final List<MergeCursorState<IndexEntry>> cursorStates = getCursorStates();\n+        return whenAll(cursorStates).thenApply(vignore -> {\n+            boolean anyHasNext = false;\n+            for (MergeCursorState<IndexEntry> cursorState : cursorStates) {\n+                if (cursorState.getResult().hasNext()) {\n+                    anyHasNext = true;\n+                } else if (cursorState.getResult().getNoNextReason().isLimitReached()) {\n+                    // Stop if any has reached limit.\n+                    return Collections.emptyList();\n+                }\n+            }\n+            if (anyHasNext) {\n+                final List<MergeCursorState<IndexEntry>> resultStates = new ArrayList<>();\n+                long nextPosition = Long.MAX_VALUE;\n+                for (MergeCursorState<IndexEntry> cursorState : cursorStates) {\n+                    if (cursorState.getResult().hasNext()) {\n+                        final IndexEntry indexEntry = cursorState.getResult().get();\n+                        final Tuple indexKey = indexEntry.getKey();\n+                        final long position = indexKey.getLong(indexKey.size() - 1);\n+                        if (nextPosition > position) {\n+                            resultStates.clear();\n+                            nextPosition = position;\n+                        }\n+                        if (nextPosition == position) {\n+                            resultStates.add(cursorState);\n+                        }\n+                    }\n+                }\n+                return resultStates;\n+            } else {\n+                return Collections.emptyList();\n+            }\n+        });\n+    }\n+\n+    @Nonnull\n+    @Override\n+    protected IndexEntry getNextResult(@Nonnull List<MergeCursorState<IndexEntry>> resultStates) {\n+        final List<MergeCursorState<IndexEntry>> cursorStates = getCursorStates();\n+        final IndexEntry firstEntry = resultStates.get(0).getResult().get();\n+        final int size = firstEntry.getValue().getBytes(0).length;\n+        final List<byte[]> bitmaps = new ArrayList<>(cursorStates.size());\n+        for (MergeCursorState<IndexEntry> cursorState : cursorStates) {\n+            if (resultStates.contains(cursorState)) {\n+                byte[] bitmap = cursorState.getResult().get().getValue().getBytes(0);\n+                if (bitmap.length != size) {\n+                    throw new RecordCoreException(\"Index bitmaps are not all the same size\");\n+                }\n+                bitmaps.add(bitmap);\n+            } else {\n+                bitmaps.add(null);\n+            }\n+        }\n+        final byte[] composed = composer.compose(bitmaps, size);\n+        return new IndexEntry(firstEntry.getIndex(), firstEntry.getKey(), Tuple.fromList(Collections.singletonList(composed)));\n+    }\n+\n+    @Nonnull\n+    @Override\n+    protected NoNextReason mergeNoNextReasons() {\n+        return getStrongestNoNextReason(getCursorStates());\n+    }\n+\n+    @Nonnull\n+    @Override\n+    protected RecordCursorContinuation getContinuationObject() {\n+        return new ComposedBitmapIndexContinuation(getChildContinuations(), null);\n+    }\n+\n+    @Nonnull\n+    public static ComposedBitmapIndexCursor create(@Nonnull List<Function<byte[], RecordCursor<IndexEntry>>> cursorFunctions,\n+                                                   @Nonnull Composer composer,\n+                                                   @Nullable byte[] byteContinuation,\n+                                                   @Nullable FDBStoreTimer timer) {\n+        if (cursorFunctions.size() < 2) {\n+            throw new RecordCoreArgumentException(\"not enough child cursors provided to UnionCursor\")", "originalCommit": "ee39171c186302229dbd9ee1911a3003ffd07a89", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2ODQ3Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470868476", "bodyText": "I think this could use a few more tests. Namely:\n\nSomething that uses not. If there's a way to get an XOR, then that would be nice too, but I don't think we have that in our API (nor do we simplify \"(a \u2228 b) \u2227 \u00ac (a \u2227 b)\" into \"a \u2295 b\", I don't think).\nSomething that has a union of elements with disjoint physical bitmaps in the index. Something like (using a pseudo-SQL syntax) SELECT bitmap(rec_no) FROM MySimpleRecord WHERE num_value_2 = 3 OR num_value_2 = 4 where all of the records with num_value_2 = 3 are in one position group and all of the records where num_value_2 = 3 are in a different one.", "author": "alecgrieser", "createdAt": "2020-08-14T21:15:25Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/indexes/BitmapValueIndexTest.java", "diffHunk": "@@ -242,18 +265,176 @@ public void uniquenessViolationNotChecked() {\n         }\n     }\n \n+    @Test", "originalCommit": "ee39171c186302229dbd9ee1911a3003ffd07a89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwOTIyOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r470909228", "bodyText": "Added a test for NOT, which can be supported.\nAdded a test for non-overlapping indexes.", "author": "MMcM", "createdAt": "2020-08-14T23:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2ODQ3Ng=="}], "type": "inlineReview"}, {"oid": "091f549be7b7a66261788df39708dee77aea7d64", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/091f549be7b7a66261788df39708dee77aea7d64", "message": "Update fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexCursor.java\n\nCo-authored-by: Alec Grieser <alloc@apple.com>", "committedDate": "2020-08-14T23:43:22Z", "type": "commit"}, {"oid": "413a1928baf3660c26ffbbf43fbc91b4a668b658", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/413a1928baf3660c26ffbbf43fbc91b4a668b658", "message": "Address review comments.", "committedDate": "2020-08-14T23:44:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI2MTE5MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r474261191", "bodyText": "Should this also reject the query if query.getSort() != null?", "author": "alecgrieser", "createdAt": "2020-08-20T20:43:17Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexAggregate.java", "diffHunk": "@@ -73,6 +73,39 @@\n         this.root = root;\n     }\n \n+    /**\n+     * Try to build a composed bitmap plan for the given query and aggregate function.\n+     * @param planner a query planner to use to construct the plans\n+     * @param query a query providing target record type, filter, and required fields\n+     * @param indexAggregateFunction the function giving the desired position and grouping\n+     * @return an {@code Optional} query plan or {@code Optional.empty} if planning is not possible\n+     */\n+    @Nonnull\n+    public static Optional<ComposedBitmapIndexQueryPlan> tryPlan(@Nonnull RecordQueryPlanner planner,\n+                                                                 @Nonnull RecordQuery query,\n+                                                                 @Nonnull IndexAggregateFunction indexAggregateFunction) {\n+        if (query.getFilter() == null) {\n+            return Optional.empty();\n+        }", "originalCommit": "413a1928baf3660c26ffbbf43fbc91b4a668b658", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI4OTIwOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1013#discussion_r474289209", "bodyText": "Yes, that seems like good added safety.", "author": "MMcM", "createdAt": "2020-08-20T21:43:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI2MTE5MQ=="}], "type": "inlineReview"}, {"oid": "551b9696cfb24412341c68ebfafff9827a0b7f3e", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/551b9696cfb24412341c68ebfafff9827a0b7f3e", "message": "Addition review reaction", "committedDate": "2020-08-20T21:42:10Z", "type": "forcePushed"}, {"oid": "4de4a2ede3de706152c464507cb28626be90cfc4", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/4de4a2ede3de706152c464507cb28626be90cfc4", "message": "Addition review reaction", "committedDate": "2020-08-20T21:42:21Z", "type": "forcePushed"}, {"oid": "0432370c763f72c2e5449d34f29114ca25c798ef", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/0432370c763f72c2e5449d34f29114ca25c798ef", "message": "Addition review reaction", "committedDate": "2020-08-20T21:42:49Z", "type": "commit"}, {"oid": "0432370c763f72c2e5449d34f29114ca25c798ef", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/0432370c763f72c2e5449d34f29114ca25c798ef", "message": "Addition review reaction", "committedDate": "2020-08-20T21:42:49Z", "type": "forcePushed"}]}