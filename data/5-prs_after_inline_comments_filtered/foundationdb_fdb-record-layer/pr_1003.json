{"pr_number": 1003, "pr_title": "Resolves #991: Perform record fetches after union/intersection.", "pr_createdAt": "2020-07-27T18:25:38Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003", "timeline": [{"oid": "a43b415a9d6ed02e700b7392d48dff9e02f44cfc", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/a43b415a9d6ed02e700b7392d48dff9e02f44cfc", "message": "Resolves #991: Perform record fetches after union/intersection.\n\nImplements a delicate-but-working pushdown of union, intersection, and\nprimary key distinct operations below the record fetch (from an index\nscan) within the RecordQueryPlanner.\n\nThis is a fairly delicate operation that isn't easy to express properly\nwithin the RecordQueryPlanner. In a number of places, the transformation\nas expressed is incorrect, but happens to be correct in all the\ncircumstances where we happen to use it.\n\nBecause the execution framework cannot currently manipulate streams of\nobjects other than records, index entries are represented as partial\nrecords, as in covering index scans.", "committedDate": "2020-07-27T18:28:04Z", "type": "forcePushed"}, {"oid": "64e0c5a18cbf4590d5f4646cd0052a3365a3d902", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/64e0c5a18cbf4590d5f4646cd0052a3365a3d902", "message": "Resolves #991: Perform record fetches after union/intersection.\n\nImplements a delicate-but-working pushdown of union, intersection, and\nprimary key distinct operations below the record fetch (from an index\nscan) within the RecordQueryPlanner.\n\nThis is a fairly delicate operation that isn't easy to express properly\nwithin the RecordQueryPlanner. In a number of places, the transformation\nas expressed is incorrect, but happens to be correct in all the\ncircumstances where we happen to use it.\n\nBecause the execution framework cannot currently manipulate streams of\nobjects other than records, index entries are represented as partial\nrecords, as in covering index scans.", "committedDate": "2020-07-27T18:30:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEzNDc0OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461134749", "bodyText": "couldn't these just be regular selfish methods instead of statics? in that way you can call rootExpression.getKeyFields()?", "author": "normen662", "createdAt": "2020-07-27T19:59:19Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/metadata/expressions/KeyExpression.java", "diffHunk": "@@ -230,6 +231,38 @@ public static FanType valueOf(RecordMetaDataProto.Field.FanType fanType) throws\n     @Nonnull\n     KeyExpression normalizeForPlanner(@Nonnull Source source, @Nonnull List<String> fieldNamePrefix);\n \n+    /**\n+     * Return the key fields for an expression.\n+     * @param rootExpression a key expression\n+     * @return the parts of the key expression that are in the key\n+     */\n+    @API(API.Status.EXPERIMENTAL)\n+    static List<KeyExpression> getKeyFields(@Nonnull KeyExpression rootExpression) {", "originalCommit": "64e0c5a18cbf4590d5f4646cd0052a3365a3d902", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE3ODAyMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461178023", "bodyText": "John had it that way but I think this is preferable. The awkward thing about the key fields/value fields distinction is that it's really only conceptually defined on the root expression (which might be a KeyWithValueExpression).\nI have an old issue somewhere about splitting the KeyExpression interface into a KeyExpression (which is a true tree-like data structure) and IndexExpression (which might be a KeyWithValueExpression, GroupingExpression, or  just a plain KeyExpression), but obviously that's a highly invasive change.\nGiven that, I'd rather keep these as static methods, since that seems to contain the \"conceptual bleed\". I'm willing to change it up if there's strong disagreement, though.", "author": "nschiefer", "createdAt": "2020-07-27T21:22:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEzNDc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE4Mjk4NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461182985", "bodyText": "Fine either way.", "author": "normen662", "createdAt": "2020-07-27T21:32:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEzNDc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEzNDk3Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461134977", "bodyText": "same here", "author": "normen662", "createdAt": "2020-07-27T19:59:44Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/metadata/expressions/KeyExpression.java", "diffHunk": "@@ -230,6 +231,38 @@ public static FanType valueOf(RecordMetaDataProto.Field.FanType fanType) throws\n     @Nonnull\n     KeyExpression normalizeForPlanner(@Nonnull Source source, @Nonnull List<String> fieldNamePrefix);\n \n+    /**\n+     * Return the key fields for an expression.\n+     * @param rootExpression a key expression\n+     * @return the parts of the key expression that are in the key\n+     */\n+    @API(API.Status.EXPERIMENTAL)\n+    static List<KeyExpression> getKeyFields(@Nonnull KeyExpression rootExpression) {\n+        final List<KeyExpression> normalizedKeys = rootExpression.normalizeKeyForPositions();\n+        if (rootExpression instanceof KeyWithValueExpression) {\n+            final KeyWithValueExpression keyWithValue = (KeyWithValueExpression) rootExpression;\n+            return new ArrayList<>(normalizedKeys.subList(0, keyWithValue.getSplitPoint()));\n+        } else {\n+            return new ArrayList<>(normalizedKeys);\n+        }\n+    }\n+\n+    /**\n+     * Return the value fields for an expression.\n+     * @param rootExpression a key expression\n+     * @return the parts of the key expression that are in the value\n+     */\n+    @API(API.Status.EXPERIMENTAL)\n+    static List<KeyExpression> getValueFields(@Nonnull KeyExpression rootExpression) {", "originalCommit": "64e0c5a18cbf4590d5f4646cd0052a3365a3d902", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE3ODA1MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461178051", "bodyText": "See above.", "author": "nschiefer", "createdAt": "2020-07-27T21:22:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEzNDk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEzNjE3OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461136178", "bodyText": "maybe that should be defer... instead of push which usually means to push it closer to the source.", "author": "normen662", "createdAt": "2020-07-27T20:01:53Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlannerConfiguration.java", "diffHunk": "@@ -35,15 +35,18 @@\n     private final boolean attemptFailedInJoinAsOr;\n     private final int complexityThreshold;\n     private boolean checkForDuplicateConditions;\n+    private boolean pushFetchAboveUnionAndIntersection;\n \n     private RecordQueryPlannerConfiguration(@Nonnull QueryPlanner.IndexScanPreference indexScanPreference,\n                                             boolean attemptFailedInJoinAsOr,\n                                             int complexityThreshold,\n-                                            boolean checkForDuplicateConditions) {\n+                                            boolean checkForDuplicateConditions,\n+                                            boolean pushFetchAboveUnionAndIntersection) {", "originalCommit": "64e0c5a18cbf4590d5f4646cd0052a3365a3d902", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgyMDA0Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461820046", "bodyText": "agreed.", "author": "jleach4", "createdAt": "2020-07-28T19:27:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEzNjE3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUxMzE3OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r462513179", "bodyText": "Fixed.", "author": "nschiefer", "createdAt": "2020-07-29T18:48:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEzNjE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEzNjg4Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461136882", "bodyText": "We need to be extra careful merging my PR on top of this because I heavily messed around with equals() and such.", "author": "normen662", "createdAt": "2020-07-27T20:03:16Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "diffHunk": "@@ -156,9 +156,6 @@ public boolean equals(Object o) {\n         if (o == null || getClass() != o.getClass()) {\n             return false;\n         }", "originalCommit": "64e0c5a18cbf4590d5f4646cd0052a3365a3d902", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE3ODU5NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461178595", "bodyText": "Yes, we'll definitely  need some careful rebasing work.", "author": "nschiefer", "createdAt": "2020-07-27T21:23:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEzNjg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEzODc0MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461138740", "bodyText": "Hmmm, let's not reuse that NodeInfo for this as load by keys needs some bound outer and this one gets the keys from its inner.", "author": "normen662", "createdAt": "2020-07-27T20:07:00Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryFetchFromPartialRecordPlan.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * RecordQueryFetchFromPartialRecordPlan.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.plans;\n+\n+import com.apple.foundationdb.record.EvaluationContext;\n+import com.apple.foundationdb.record.ExecuteProperties;\n+import com.apple.foundationdb.record.RecordCursor;\n+import com.apple.foundationdb.record.provider.common.StoreTimer;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBQueriedRecord;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreBase;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBStoreTimer;\n+import com.apple.foundationdb.record.provider.foundationdb.IndexOrphanBehavior;\n+import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.GroupExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.explain.NodeInfo;\n+import com.apple.foundationdb.record.query.plan.temp.explain.PlannerGraph;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Message;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class RecordQueryFetchFromPartialRecordPlan implements RecordQueryPlanWithChild {\n+    @Nonnull\n+    private final ExpressionRef<RecordQueryPlan> inner;\n+\n+    public RecordQueryFetchFromPartialRecordPlan(@Nonnull RecordQueryPlan inner) {\n+        this(GroupExpressionRef.of(inner));\n+    }\n+\n+    public RecordQueryFetchFromPartialRecordPlan(@Nonnull final ExpressionRef<RecordQueryPlan> inner) {\n+        this.inner = inner;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public <M extends Message> RecordCursor<FDBQueriedRecord<M>> execute(@Nonnull final FDBRecordStoreBase<M> store,\n+                                                                         @Nonnull final EvaluationContext context,\n+                                                                         @Nullable final byte[] continuation,\n+                                                                         @Nonnull final ExecuteProperties executeProperties) {\n+        // Plan return exactly one (full) record for each (partial) record from inner, so we can preserve all limits.\n+        return store.fetchIndexRecords(getChild().execute(store, context, continuation, executeProperties)\n+                        .map(FDBQueriedRecord::getIndexEntry), IndexOrphanBehavior.ERROR, executeProperties.getState())\n+                .map(store::queriedRecord);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public RecordQueryPlan getChild() {\n+        return inner.get();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public List<? extends Quantifier> getQuantifiers() {\n+        return ImmutableList.of(Quantifier.physical(inner));\n+    }\n+\n+    @Override\n+    public boolean isReverse() {\n+        return getChild().isReverse();\n+    }\n+\n+    @Override\n+    public void logPlanStructure(final StoreTimer timer) {\n+        timer.increment(FDBStoreTimer.Counts.PLAN_FETCH);\n+    }\n+\n+    @Override\n+    public int getComplexity() {\n+        return 1 + getChild().getComplexity();\n+    }\n+\n+    @Override\n+    public boolean equalsWithoutChildren(@Nonnull final RelationalExpression otherExpression) {\n+        return otherExpression instanceof RecordQueryFetchFromPartialRecordPlan;\n+    }\n+\n+    @Override\n+    public boolean equals(final Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        final RecordQueryFetchFromPartialRecordPlan that = (RecordQueryFetchFromPartialRecordPlan)o;\n+        return getChild().equals(that.getChild());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(getChild());\n+    }\n+\n+    @Override\n+    public int planHash() {\n+        return 13 + 7 * getChild().planHash();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Fetch(\" + getChild().toString() + \")\";\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public PlannerGraph rewritePlannerGraph(@Nonnull final List<? extends PlannerGraph> childGraphs) {\n+        return PlannerGraph.fromNodeAndChildGraphs(\n+                new PlannerGraph.OperatorNodeWithInfo(this, NodeInfo.LOAD_BY_KEYS_OPERATOR),", "originalCommit": "64e0c5a18cbf4590d5f4646cd0052a3365a3d902", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE3ODc5NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461178794", "bodyText": "Do you have a NodeInfo that you'd rather use, or should I just create a new one?", "author": "nschiefer", "createdAt": "2020-07-27T21:24:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEzODc0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU0NDQ5Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r462544492", "bodyText": "Created NodeInfo.FETCH_OPERATOR.", "author": "nschiefer", "createdAt": "2020-07-29T19:44:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEzODc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE0MzI0Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461143247", "bodyText": "Another approach could be to have accept() and by extension visit() return an Optional<RecordQueryPlan> or a Nullable. If that's empty, by contract it has not modified the node, if it is not empty, the contained value is the replacement node. In this way you give the explicit choice of what to do (i.e., to rewrite or not to rewrite) to the visitor instead of implicitly making it dependent on an (non)-equality of the RecordQueryPlan that the visitor returns.", "author": "normen662", "createdAt": "2020-07-27T20:15:55Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryPlan.java", "diffHunk": "@@ -117,4 +121,29 @@\n     default List<? extends QueryPlan<?>> getQueryPlanChildren() {\n         return getChildren();\n     }\n+\n+    @Nonnull\n+    @SuppressWarnings(\"unchecked\") // we know the type of the group, even though the compiler doesn't\n+    default RecordQueryPlan accept(@Nonnull RecordQueryPlannerSubstitutionVisitor visitor) {\n+        // Using a quantifier here is a bit of a hack since quantifiers only make conceptual sense in the data model\n+        // of the experimental planner. However, they provide access to the underlying groups, which allow us to\n+        // substitute children without adding additional mutable access to the children of a query plan.\n+        // This makes some amount of conceptual sense, too, since we're performing the same kind of substitution\n+        // that a PlannerRule would provide.\n+        for (Quantifier childQuantifier : getQuantifiers()) {\n+            if (!(childQuantifier instanceof Quantifier.Physical)) {\n+                throw new RecordCoreException(\"quantifiers of RecordQueryPlans must be physical\");\n+            }\n+            // Group expression is the only type of reference at this point.\n+            GroupExpressionRef<RecordQueryPlan> childGroup = ((GroupExpressionRef)((Quantifier.Physical)childQuantifier).getRangesOver());\n+            RecordQueryPlan child = childGroup.get(); // Group is generated by the RecordQueryPlanner so must have a single member\n+\n+            RecordQueryPlan modifiedChild = child.accept(visitor);\n+            if (child != modifiedChild) { // intentional use of reference equality, since equals() might not be conservative enough for plans", "originalCommit": "64e0c5a18cbf4590d5f4646cd0052a3365a3d902", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE3OTQ2Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461179467", "bodyText": "I'm happy to make this nullable and return null instead of an unchanged plan if the visitor doesn't make any changes. Is that preferable?", "author": "nschiefer", "createdAt": "2020-07-27T21:25:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE0MzI0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE4ODY3Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461188676", "bodyText": "No big deal, it is doing the same thing. It's just style. In some visitor pattern variations you can even reject the accept or the visit(). In other variations you return Optional<...> with a default implementation returning Optional.empty(), so you don't have to overwrite it for every subclass. In any case it's producing something, it just matters it is correctly interpreted.", "author": "normen662", "createdAt": "2020-07-27T21:45:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE0MzI0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE0NTQyNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461145425", "bodyText": "This feels like it should belong somewhere else. I know that this Visitor was only invented for the problem at hand but it should serve a more general purpose that to just deal with index fetches.", "author": "normen662", "createdAt": "2020-07-27T20:20:05Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/visitor/RecordQueryPlannerSubstitutionVisitor.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * RecordQueryPlannerSubstitutionVisitor.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.plans.visitor;\n+\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.query.plan.IndexKeyValueToPartialRecord;\n+import com.apple.foundationdb.record.query.plan.RecordQueryPlanner;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryCoveringIndexPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryFetchFromPartialRecordPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlanWithIndex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Visitor interface for performing substitution-type rules on {@link RecordQueryPlan}s.\n+ */\n+public abstract class RecordQueryPlannerSubstitutionVisitor {\n+    @Nonnull\n+    private static final Logger logger = LoggerFactory.getLogger(RecordQueryPlanner.class);\n+\n+    @Nonnull\n+    protected final RecordMetaData recordMetadata;\n+    @Nullable\n+    private final KeyExpression commonPrimaryKey;\n+\n+    public RecordQueryPlannerSubstitutionVisitor(@Nonnull RecordMetaData recordMetadata, @Nullable KeyExpression commonPrimaryKey) {\n+        this.recordMetadata = recordMetadata;\n+        this.commonPrimaryKey = commonPrimaryKey;\n+    }\n+\n+    public static RecordQueryPlan applyVisitors(@Nonnull RecordQueryPlan plan, @Nonnull RecordMetaData recordMetaData, @Nullable KeyExpression commonPrimaryKey) {\n+        return plan.accept(new UnorderedPrimaryKeyDistinctVisitor(recordMetaData, commonPrimaryKey))\n+                .accept(new UnionVisitor(recordMetaData, commonPrimaryKey))\n+                .accept(new IntersectionVisitor(recordMetaData, commonPrimaryKey))\n+                .accept(new UnorderedPrimaryKeyDistinctVisitor(recordMetaData, commonPrimaryKey));\n+    }\n+\n+    @Nonnull\n+    public abstract RecordQueryPlan visit(@Nonnull RecordQueryPlan recordQueryPlan);\n+\n+    @Nullable\n+    protected RecordQueryPlan removeIndexFetch(@Nonnull RecordQueryPlan plan) {", "originalCommit": "64e0c5a18cbf4590d5f4646cd0052a3365a3d902", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE4MDc5Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461180793", "bodyText": "Originally, the visitor was an interface and there was a BaseMetadataVisitor as a common super class of all the visitors we have. It seemed sort of strange to have an interface with exactly one implementation (which was an abstract class of all things).\nI think I agree in general, but in this particular case I don't think we're trying to build much of a \"conceptual model\" with the visitors here (unlike with the rules in the new planner). I don't mind separating the interface and the abstract base class, though.", "author": "nschiefer", "createdAt": "2020-07-27T21:28:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE0NTQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE0NjA3Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461146077", "bodyText": "Iterables.getOnlyElement() seems more intuitive.", "author": "normen662", "createdAt": "2020-07-27T20:21:06Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/visitor/RecordQueryPlannerSubstitutionVisitor.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * RecordQueryPlannerSubstitutionVisitor.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.plans.visitor;\n+\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.query.plan.IndexKeyValueToPartialRecord;\n+import com.apple.foundationdb.record.query.plan.RecordQueryPlanner;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryCoveringIndexPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryFetchFromPartialRecordPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlanWithIndex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Visitor interface for performing substitution-type rules on {@link RecordQueryPlan}s.\n+ */\n+public abstract class RecordQueryPlannerSubstitutionVisitor {\n+    @Nonnull\n+    private static final Logger logger = LoggerFactory.getLogger(RecordQueryPlanner.class);\n+\n+    @Nonnull\n+    protected final RecordMetaData recordMetadata;\n+    @Nullable\n+    private final KeyExpression commonPrimaryKey;\n+\n+    public RecordQueryPlannerSubstitutionVisitor(@Nonnull RecordMetaData recordMetadata, @Nullable KeyExpression commonPrimaryKey) {\n+        this.recordMetadata = recordMetadata;\n+        this.commonPrimaryKey = commonPrimaryKey;\n+    }\n+\n+    public static RecordQueryPlan applyVisitors(@Nonnull RecordQueryPlan plan, @Nonnull RecordMetaData recordMetaData, @Nullable KeyExpression commonPrimaryKey) {\n+        return plan.accept(new UnorderedPrimaryKeyDistinctVisitor(recordMetaData, commonPrimaryKey))\n+                .accept(new UnionVisitor(recordMetaData, commonPrimaryKey))\n+                .accept(new IntersectionVisitor(recordMetaData, commonPrimaryKey))\n+                .accept(new UnorderedPrimaryKeyDistinctVisitor(recordMetaData, commonPrimaryKey));\n+    }\n+\n+    @Nonnull\n+    public abstract RecordQueryPlan visit(@Nonnull RecordQueryPlan recordQueryPlan);\n+\n+    @Nullable\n+    protected RecordQueryPlan removeIndexFetch(@Nonnull RecordQueryPlan plan) {\n+        if (plan instanceof RecordQueryPlanWithIndex) {\n+            RecordQueryPlanWithIndex indexPlan = (RecordQueryPlanWithIndex) plan;\n+            Index index = recordMetadata.getIndex(indexPlan.getIndexName());\n+            final Collection<RecordType> recordTypes = recordMetadata.recordTypesForIndex(index);\n+            final IndexKeyValueToPartialRecord keyValueToPartialRecord = generateIndexKeyValueToPartialRecord(indexPlan);\n+            if (keyValueToPartialRecord != null && recordTypes.size() == 1) {\n+                RecordType recordType = recordTypes.iterator().next();", "originalCommit": "64e0c5a18cbf4590d5f4646cd0052a3365a3d902", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE4MTAzMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461181031", "bodyText": "Changed.", "author": "nschiefer", "createdAt": "2020-07-27T21:28:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE0NjA3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE0NjczNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461146735", "bodyText": "clever", "author": "normen662", "createdAt": "2020-07-27T20:22:21Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/visitor/RecordQueryPlannerSubstitutionVisitor.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * RecordQueryPlannerSubstitutionVisitor.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.plans.visitor;\n+\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.query.plan.IndexKeyValueToPartialRecord;\n+import com.apple.foundationdb.record.query.plan.RecordQueryPlanner;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryCoveringIndexPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryFetchFromPartialRecordPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlanWithIndex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Visitor interface for performing substitution-type rules on {@link RecordQueryPlan}s.\n+ */\n+public abstract class RecordQueryPlannerSubstitutionVisitor {\n+    @Nonnull\n+    private static final Logger logger = LoggerFactory.getLogger(RecordQueryPlanner.class);\n+\n+    @Nonnull\n+    protected final RecordMetaData recordMetadata;\n+    @Nullable\n+    private final KeyExpression commonPrimaryKey;\n+\n+    public RecordQueryPlannerSubstitutionVisitor(@Nonnull RecordMetaData recordMetadata, @Nullable KeyExpression commonPrimaryKey) {\n+        this.recordMetadata = recordMetadata;\n+        this.commonPrimaryKey = commonPrimaryKey;\n+    }\n+\n+    public static RecordQueryPlan applyVisitors(@Nonnull RecordQueryPlan plan, @Nonnull RecordMetaData recordMetaData, @Nullable KeyExpression commonPrimaryKey) {\n+        return plan.accept(new UnorderedPrimaryKeyDistinctVisitor(recordMetaData, commonPrimaryKey))\n+                .accept(new UnionVisitor(recordMetaData, commonPrimaryKey))\n+                .accept(new IntersectionVisitor(recordMetaData, commonPrimaryKey))\n+                .accept(new UnorderedPrimaryKeyDistinctVisitor(recordMetaData, commonPrimaryKey));\n+    }\n+\n+    @Nonnull\n+    public abstract RecordQueryPlan visit(@Nonnull RecordQueryPlan recordQueryPlan);\n+\n+    @Nullable\n+    protected RecordQueryPlan removeIndexFetch(@Nonnull RecordQueryPlan plan) {\n+        if (plan instanceof RecordQueryPlanWithIndex) {\n+            RecordQueryPlanWithIndex indexPlan = (RecordQueryPlanWithIndex) plan;\n+            Index index = recordMetadata.getIndex(indexPlan.getIndexName());\n+            final Collection<RecordType> recordTypes = recordMetadata.recordTypesForIndex(index);\n+            final IndexKeyValueToPartialRecord keyValueToPartialRecord = generateIndexKeyValueToPartialRecord(indexPlan);\n+            if (keyValueToPartialRecord != null && recordTypes.size() == 1) {\n+                RecordType recordType = recordTypes.iterator().next();\n+                return new RecordQueryCoveringIndexPlan(indexPlan, recordType.getName(), keyValueToPartialRecord);", "originalCommit": "64e0c5a18cbf4590d5f4646cd0052a3365a3d902", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE4MTEzNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461181135", "bodyText": "Thanks :) Getting this all lined up just-so was tricky but I'm happy with the result.", "author": "nschiefer", "createdAt": "2020-07-27T21:29:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE0NjczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE1MDU4MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461150581", "bodyText": "Hmm, so we walk this n times?", "author": "normen662", "createdAt": "2020-07-27T20:29:40Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/visitor/RecordQueryPlannerSubstitutionVisitor.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * RecordQueryPlannerSubstitutionVisitor.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.plans.visitor;\n+\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.query.plan.IndexKeyValueToPartialRecord;\n+import com.apple.foundationdb.record.query.plan.RecordQueryPlanner;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryCoveringIndexPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryFetchFromPartialRecordPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlanWithIndex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Visitor interface for performing substitution-type rules on {@link RecordQueryPlan}s.\n+ */\n+public abstract class RecordQueryPlannerSubstitutionVisitor {\n+    @Nonnull\n+    private static final Logger logger = LoggerFactory.getLogger(RecordQueryPlanner.class);\n+\n+    @Nonnull\n+    protected final RecordMetaData recordMetadata;\n+    @Nullable\n+    private final KeyExpression commonPrimaryKey;\n+\n+    public RecordQueryPlannerSubstitutionVisitor(@Nonnull RecordMetaData recordMetadata, @Nullable KeyExpression commonPrimaryKey) {\n+        this.recordMetadata = recordMetadata;\n+        this.commonPrimaryKey = commonPrimaryKey;\n+    }\n+\n+    public static RecordQueryPlan applyVisitors(@Nonnull RecordQueryPlan plan, @Nonnull RecordMetaData recordMetaData, @Nullable KeyExpression commonPrimaryKey) {\n+        return plan.accept(new UnorderedPrimaryKeyDistinctVisitor(recordMetaData, commonPrimaryKey))", "originalCommit": "64e0c5a18cbf4590d5f4646cd0052a3365a3d902", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE3OTc2Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461179767", "bodyText": "Yes, we walk it four times. I don't think that's a big deal, and it's really hard to improve on without basically recreating the memo data structure from the Cascades planner. \ud83d\ude43", "author": "nschiefer", "createdAt": "2020-07-27T21:26:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE1MDU4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE4OTgzNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r461189836", "bodyText": "Well, you could dispatch within the visitor but I agree that makes the code harder to understand and it undermines orthogonality. I also agree with the statement that it shouldn't be a big deal.", "author": "normen662", "createdAt": "2020-07-27T21:47:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE1MDU4MQ=="}], "type": "inlineReview"}, {"oid": "dfd9f439250ba2a50b8cf0f1490a1628cb4bba9f", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/dfd9f439250ba2a50b8cf0f1490a1628cb4bba9f", "message": "Resolves #991: Perform record fetches after union/intersection.\n\nImplements a delicate-but-working pushdown of union, intersection, and\nprimary key distinct operations below the record fetch (from an index\nscan) within the RecordQueryPlanner.\n\nThis is a fairly delicate operation that isn't easy to express properly\nwithin the RecordQueryPlanner. In a number of places, the transformation\nas expressed is incorrect, but happens to be correct in all the\ncircumstances where we happen to use it.\n\nBecause the execution framework cannot currently manipulate streams of\nobjects other than records, index entries are represented as partial\nrecords, as in covering index scans.", "committedDate": "2020-07-29T23:20:05Z", "type": "forcePushed"}, {"oid": "4af7e793b2d9b9fff230e2deedb01737ce4f51ba", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/4af7e793b2d9b9fff230e2deedb01737ce4f51ba", "message": "Resolves #991: Perform record fetches after union/intersection.\n\nImplements a delicate-but-working pushdown of union, intersection, and\nprimary key distinct operations below the record fetch (from an index\nscan) within the RecordQueryPlanner.\n\nThis is a fairly delicate operation that isn't easy to express properly\nwithin the RecordQueryPlanner. In a number of places, the transformation\nas expressed is incorrect, but happens to be correct in all the\ncircumstances where we happen to use it.\n\nBecause the execution framework cannot currently manipulate streams of\nobjects other than records, index entries are represented as partial\nrecords, as in covering index scans.", "committedDate": "2020-07-29T23:23:43Z", "type": "forcePushed"}, {"oid": "cef7a5c89f4947cb261e14c2e7b4b93f850d3903", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/cef7a5c89f4947cb261e14c2e7b4b93f850d3903", "message": "Resolves #991: Perform record fetches after union/intersection.\n\nImplements a delicate-but-working pushdown of union, intersection, and\nprimary key distinct operations below the record fetch (from an index\nscan) within the RecordQueryPlanner.\n\nThis is a fairly delicate operation that isn't easy to express properly\nwithin the RecordQueryPlanner. In a number of places, the transformation\nas expressed is incorrect, but happens to be correct in all the\ncircumstances where we happen to use it.\n\nBecause the execution framework cannot currently manipulate streams of\nobjects other than records, index entries are represented as partial\nrecords, as in covering index scans.", "committedDate": "2020-07-29T23:41:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2NjM4MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r463166380", "bodyText": "There is duplication between here and generateIndexKeyValueToPartialRecord:\n\nget index from metadata\nget record types from index\nassert only one record type\n\nSince the method is private, it seems like a little bit of refactoring could avoid that.", "author": "MMcM", "createdAt": "2020-07-30T17:45:58Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/visitor/RecordQueryPlannerSubstitutionVisitor.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * RecordQueryPlannerSubstitutionVisitor.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.plans.visitor;\n+\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.query.plan.IndexKeyValueToPartialRecord;\n+import com.apple.foundationdb.record.query.plan.RecordQueryPlanner;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryCoveringIndexPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryFetchFromPartialRecordPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlanWithIndex;\n+import com.google.common.collect.Iterators;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Visitor interface for performing substitution-type rules on {@link RecordQueryPlan}s.\n+ */\n+public abstract class RecordQueryPlannerSubstitutionVisitor {\n+    @Nonnull\n+    private static final Logger logger = LoggerFactory.getLogger(RecordQueryPlanner.class);\n+\n+    @Nonnull\n+    protected final RecordMetaData recordMetadata;\n+    @Nullable\n+    private final KeyExpression commonPrimaryKey;\n+\n+    public RecordQueryPlannerSubstitutionVisitor(@Nonnull RecordMetaData recordMetadata, @Nullable KeyExpression commonPrimaryKey) {\n+        this.recordMetadata = recordMetadata;\n+        this.commonPrimaryKey = commonPrimaryKey;\n+    }\n+\n+    public static RecordQueryPlan applyVisitors(@Nonnull RecordQueryPlan plan, @Nonnull RecordMetaData recordMetaData, @Nullable KeyExpression commonPrimaryKey) {\n+        return plan.accept(new UnorderedPrimaryKeyDistinctVisitor(recordMetaData, commonPrimaryKey))\n+                .accept(new UnionVisitor(recordMetaData, commonPrimaryKey))\n+                .accept(new IntersectionVisitor(recordMetaData, commonPrimaryKey))\n+                .accept(new UnorderedPrimaryKeyDistinctVisitor(recordMetaData, commonPrimaryKey));\n+    }\n+\n+    @Nonnull\n+    public abstract RecordQueryPlan visit(@Nonnull RecordQueryPlan recordQueryPlan);\n+\n+    @Nullable\n+    protected RecordQueryPlan removeIndexFetch(@Nonnull RecordQueryPlan plan) {\n+        if (plan instanceof RecordQueryPlanWithIndex) {\n+            RecordQueryPlanWithIndex indexPlan = (RecordQueryPlanWithIndex) plan;\n+            Index index = recordMetadata.getIndex(indexPlan.getIndexName());\n+            final Collection<RecordType> recordTypes = recordMetadata.recordTypesForIndex(index);\n+            final IndexKeyValueToPartialRecord keyValueToPartialRecord = generateIndexKeyValueToPartialRecord(indexPlan);\n+            if (keyValueToPartialRecord != null && recordTypes.size() == 1) {", "originalCommit": "cef7a5c89f4947cb261e14c2e7b4b93f850d3903", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIyNTMxNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r463225317", "bodyText": "Extracted into a private method.", "author": "nschiefer", "createdAt": "2020-07-30T19:35:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2NjM4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI1NTE5MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r463255190", "bodyText": "Did this get pushed?\nIn addition to the source code duplication, can't we avoid doing these more than one in quick succession?", "author": "MMcM", "createdAt": "2020-07-30T20:34:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2NjM4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI1NjExMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r463256113", "bodyText": "No, not yet. I'm still getting the comparison key validation logic working. I think I've found a way to pull this out into a single spot per evaluation.", "author": "nschiefer", "createdAt": "2020-07-30T20:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2NjM4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2NzY0NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r463167645", "bodyText": "Needs java doc.", "author": "MMcM", "createdAt": "2020-07-30T17:48:05Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/query/plan/match/FetchMatcher.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * FetchMatcher.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.match;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryFetchFromPartialRecordPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+\n+import javax.annotation.Nonnull;\n+\n+public class FetchMatcher extends PlanMatcherWithChild {", "originalCommit": "cef7a5c89f4947cb261e14c2e7b4b93f850d3903", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2ODQ1NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r463168454", "bodyText": "Needs java doc.", "author": "MMcM", "createdAt": "2020-07-30T17:49:25Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/indexes/TextIndexTestUtils.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * TextIndexTestUtils.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb.indexes;\n+\n+import com.apple.foundationdb.record.TestRecordsTextProto;\n+import com.apple.foundationdb.record.provider.common.TransformedRecordSerializer;\n+import com.google.protobuf.Message;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class TextIndexTestUtils {", "originalCommit": "cef7a5c89f4947cb261e14c2e7b4b93f850d3903", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0f7d6602b018247c753b597abc3e7158857fc613", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/0f7d6602b018247c753b597abc3e7158857fc613", "message": "Check comparison key field availability before transformation.", "committedDate": "2020-07-30T22:28:52Z", "type": "forcePushed"}, {"oid": "23b7827326bd9fe142f22e1c26ce0d3bd6323fe8", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/23b7827326bd9fe142f22e1c26ce0d3bd6323fe8", "message": "Check comparison key field availability before transformation.", "committedDate": "2020-07-30T22:32:04Z", "type": "forcePushed"}, {"oid": "81454b4339fed3dc21494467b8dce68975a2f969", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/81454b4339fed3dc21494467b8dce68975a2f969", "message": "Check comparison key field availability before transformation.", "committedDate": "2020-07-30T22:33:28Z", "type": "forcePushed"}, {"oid": "65ee4d0f6a66f43109e5bbb21299c427cbc6ce54", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/65ee4d0f6a66f43109e5bbb21299c427cbc6ce54", "message": "Resolves #991: Perform record fetches after union/intersection.\n\nImplements a delicate-but-working pushdown of union, intersection, and\nprimary key distinct operations below the record fetch (from an index\nscan) within the RecordQueryPlanner.\n\nThis is a fairly delicate operation that isn't easy to express properly\nwithin the RecordQueryPlanner. In a number of places, the transformation\nas expressed is incorrect, but happens to be correct in all the\ncircumstances where we happen to use it.\n\nBecause the execution framework cannot currently manipulate streams of\nobjects other than records, index entries are represented as partial\nrecords, as in covering index scans.", "committedDate": "2020-07-30T22:39:44Z", "type": "commit"}, {"oid": "d7b22652f6ba2fe56b0accf0c8fc9cd637985980", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/d7b22652f6ba2fe56b0accf0c8fc9cd637985980", "message": "Check comparison key field availability before transformation.", "committedDate": "2020-07-30T22:39:44Z", "type": "commit"}, {"oid": "d7b22652f6ba2fe56b0accf0c8fc9cd637985980", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/d7b22652f6ba2fe56b0accf0c8fc9cd637985980", "message": "Check comparison key field availability before transformation.", "committedDate": "2020-07-30T22:39:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyMzkyNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r463323926", "bodyText": "chosenPlan ?", "author": "normen662", "createdAt": "2020-07-30T23:21:42Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -1438,52 +1439,62 @@ private RecordQueryPlan tryToConvertToCoveringPlan(@Nonnull PlanContext context,\n                 resultFields.addAll(filterField.normalizeKeyForPositions());\n             }\n         }\n-        final KeyExpression rootExpression = index.getRootExpression();\n-        final List<KeyExpression> normalizedKeys = rootExpression.normalizeKeyForPositions();\n-        final List<KeyExpression> keyFields;\n-        final List<KeyExpression> valueFields;\n-        if (rootExpression instanceof KeyWithValueExpression) {\n-            final KeyWithValueExpression keyWithValue = (KeyWithValueExpression) rootExpression;\n-            keyFields = new ArrayList<>(normalizedKeys.subList(0, keyWithValue.getSplitPoint()));\n-            valueFields = new ArrayList<>(normalizedKeys.subList(keyWithValue.getSplitPoint(), normalizedKeys.size()));\n-        } else {\n-            keyFields = new ArrayList<>(normalizedKeys);\n-            valueFields = Collections.singletonList(EmptyKeyExpression.EMPTY);\n+\n+        @Nullable IndexKeyValueToPartialRecord indexKeyValueToPartialRecord =\n+                buildIndexKeyValueToPartialRecord(metaData, index, context.commonPrimaryKey, resultFields);\n+\n+        if (indexKeyValueToPartialRecord != null) {\n+            final RecordType recordType = indexKeyValueToPartialRecord.getRecordType();\n+            if (recordType != null) {\n+                return new RecordQueryCoveringIndexPlan(chosenPlan, recordType.getName(), indexKeyValueToPartialRecord);\n+            }\n+        }\n+        return chosenPlan;\n+    }\n+\n+    @Nullable\n+    public static IndexKeyValueToPartialRecord buildIndexKeyValueToPartialRecord(@Nonnull RecordMetaData metaData,\n+                                                                                 @Nonnull Index index,\n+                                                                                 @Nullable KeyExpression commonPrimaryKey,\n+                                                                                 @Nonnull Set<KeyExpression> requiredFields) {\n+        final Collection<RecordType> recordTypes = metaData.recordTypesForIndex(index);\n+        if (recordTypes.size() != 1) {\n+            return null;\n         }\n+        final RecordType recordType = Iterables.getOnlyElement(recordTypes);\n+\n+        final KeyExpression rootExpression = index.getRootExpression();\n+        final List<KeyExpression> keyFields = KeyExpression.getKeyFields(rootExpression);\n+        final List<KeyExpression> valueFields = KeyExpression.getValueFields(rootExpression);\n \n         // Like FDBRecordStoreBase.indexEntryKey(), but with key expressions instead of actual values.\n-        final List<KeyExpression> primaryKeys = context.commonPrimaryKey == null\n-                ? Collections.emptyList()\n-                : context.commonPrimaryKey.normalizeKeyForPositions();\n+        final List<KeyExpression> primaryKeys = commonPrimaryKey == null\n+                                                ? Collections.emptyList()\n+                                                : commonPrimaryKey.normalizeKeyForPositions();\n         index.trimPrimaryKey(primaryKeys);\n         keyFields.addAll(primaryKeys);\n \n-        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType.getDescriptor());\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n \n-        for (KeyExpression resultField : resultFields) {\n-            if (!addCoveringField(resultField, builder, keyFields, valueFields)) {\n-                return chosenPlan;\n-            }\n+        Set<KeyExpression> fields = new HashSet<>(requiredFields);\n+        if (commonPrimaryKey != null) {\n+            // Need the primary key, even if it wasn't one of the explicit result fields.\n+            fields.addAll(commonPrimaryKey.normalizeKeyForPositions());\n         }\n-\n-        if (context.commonPrimaryKey != null) {\n-            for (KeyExpression primaryKeyField : context.commonPrimaryKey.normalizeKeyForPositions()) {\n-                // Need the primary key, even if it wasn't one of the explicit result fields.\n-                if (!resultFields.contains(primaryKeyField)) {\n-                    addCoveringField(primaryKeyField, builder, keyFields, valueFields);\n-                }\n+        for (KeyExpression field: fields) {\n+            if (!addCoveringField(field, builder, keyFields, valueFields)) {\n+                return null;\n             }\n         }\n \n+        // Validity check ensures that we don't attempt this transformation if there are any repeated fields..\n         if (!builder.isValid()) {\n-            return chosenPlan;\n+            return null;", "originalCommit": "d7b22652f6ba2fe56b0accf0c8fc9cd637985980", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyNDAzOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r463324039", "bodyText": "oh got it -- different contract in a different method", "author": "normen662", "createdAt": "2020-07-30T23:22:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyMzkyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyNDQxMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1003#discussion_r463324412", "bodyText": "chosenPlan is the index plan before the covering index transformation. I pulled out the building logic from the convert-to-covering logic so that it could be reused by the visitor. Returning null is the equivalent for the new control flow.", "author": "nschiefer", "createdAt": "2020-07-30T23:23:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyMzkyNg=="}], "type": "inlineReview"}]}