{"pr_number": 1049, "pr_title": "Resolves #1048: preloadRecordAsync should cache negative results", "pr_createdAt": "2020-10-21T12:59:15Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/1049", "timeline": [{"oid": "177fd5b8efab0905c2616e47c9df3f4b0101458d", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/177fd5b8efab0905c2616e47c9df3f4b0101458d", "message": "Resolves #1048: preloadRecordAsync should cache negative results", "committedDate": "2020-10-21T14:28:29Z", "type": "commit"}, {"oid": "177fd5b8efab0905c2616e47c9df3f4b0101458d", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/177fd5b8efab0905c2616e47c9df3f4b0101458d", "message": "Resolves #1048: preloadRecordAsync should cache negative results", "committedDate": "2020-10-21T14:28:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA1ODkzOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1049#discussion_r511058938", "bodyText": "What is the purpose of having incomplete entries in the cache at all? They aren't returned to another load attempt or even shared by it?", "author": "MMcM", "createdAt": "2020-10-23T18:17:06Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBPreloadRecordCache.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * FDBRecordCache.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A cache used to track and handle the results of asynchronously preloaded records.\n+ */\n+@API(API.Status.INTERNAL)\n+class FDBPreloadRecordCache {\n+    @Nonnull\n+    private final Cache<Tuple, EntryImpl>  cache;\n+\n+    public FDBPreloadRecordCache(int maximumSize) {\n+        cache = CacheBuilder.newBuilder().maximumSize(maximumSize).build();\n+    }\n+\n+    /**\n+     * Called prior to performing a prefetch for a given {@code Tuple}, returning a future holder that must\n+     * be filled in with the record when it has completed.", "originalCommit": "177fd5b8efab0905c2616e47c9df3f4b0101458d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEzNDAzNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1049#discussion_r511134034", "bodyText": "I should have commented on this.  The current strategy allows for a race condition I believe.\nThread 1                    Thread 2\n-----------------      ------------------\nbegin pre-fetch    \nread record\n                       replace record\n                       invalidate (non-existant) cache entry\nput record in cache\n\nwith the strategy I'm proposing, the holder for the record being pre-fetched is pre-allocated in the cache and completed when the read is finished.  An invalidate kicks the holder out of the cache, so that the results will never be seen.", "author": "scgray", "createdAt": "2020-10-23T20:13:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA1ODkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEzNDMzOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1049#discussion_r511134339", "bodyText": "There may even be a path for the pre-fetch read to pick up a portion of the replaced record as well....", "author": "scgray", "createdAt": "2020-10-23T20:13:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA1ODkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1MjI4OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1049#discussion_r511152288", "bodyText": "Okay. I guess there should be a short comment there for why it does that.\nSuch race conditions seem more fundamentally problematic. For instance,\nThread 1                    Thread 2\n-----------------      ------------------\nbegin pre-fetch    \nread record\n                       replace record\n                       invalidate (incomplete) cache entry\n(put record in orphan entry)\ntake action based on out-of-date record\n\nBut there's no reason not to try to avoid what can be relatively cheaply.", "author": "MMcM", "createdAt": "2020-10-23T20:58:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA1ODkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1NTMzNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1049#discussion_r511155334", "bodyText": "I think we are saying the same thing...unless I'm interpreting your example wrong.  Since the orphaned entry is ejected from the cache, its value (the record that thread #1 was reading), will never be visible to the outside world to act upon it.   But, yes, I'll add a comment to explain the reason for the design.", "author": "scgray", "createdAt": "2020-10-23T21:06:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA1ODkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTM0MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1049#discussion_r511169341", "bodyText": "Yes, but thread 1 continues to make changes elsewhere dependent on stale information. I am not saying we need to try to fix this here. Or that we should give up on concurrency within the same context because of it. Just that it's hard to solve without synchronization outside of what we provide.", "author": "MMcM", "createdAt": "2020-10-23T21:45:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA1ODkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQwNDk1Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1049#discussion_r511404956", "bodyText": "Got it.", "author": "scgray", "createdAt": "2020-10-24T11:22:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA1ODkzOA=="}], "type": "inlineReview"}, {"oid": "61501d23027cd6b4a7d2b8cbae741675dc00f1c4", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/61501d23027cd6b4a7d2b8cbae741675dc00f1c4", "message": "Comment to explain why the cache behavior looks so strange", "committedDate": "2020-10-23T21:20:41Z", "type": "commit"}]}