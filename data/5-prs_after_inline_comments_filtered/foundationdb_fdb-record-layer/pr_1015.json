{"pr_number": 1015, "pr_title": "Resolves #1019: Avoid repeating index endpoints conflicts", "pr_createdAt": "2020-08-14T22:17:26Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015", "timeline": [{"oid": "d093083a32ac1a54872e9a542240a3824f038041", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/d093083a32ac1a54872e9a542240a3824f038041", "message": "While setting endpoints for indexer, repeating conflicts with other transaction could prevent the job from running\n\n   resolution: Since the store is marked WRITE_ONLY while determining endpoints and reading the records,\n   is seems safe to ignore conflicts caused by insertion of new records - as the inseration should already\n   imply valid index entries.", "committedDate": "2020-08-14T22:26:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxODUzOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r470918539", "bodyText": "Hm, what is this line trying to accomplish?", "author": "alecgrieser", "createdAt": "2020-08-15T01:04:17Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerBuildSumIndexTest.java", "diffHunk": "@@ -103,6 +103,9 @@ public void run() {\n                 try (FDBRecordContext context = openContext()) {\n                     long sum = recordStore.evaluateAggregateFunction(Collections.singletonList(\"MySimpleRecord\"), aggregateFunction, TupleRange.ALL, IsolationLevel.SNAPSHOT).join().getLong(0);\n                     long expected = updatedRecords.stream().mapToInt(msg -> msg.hasNumValue2() ? msg.getNumValue2() : 0).sum();\n+                    for (int i = 0; sum != expected && i < 20; i ++) {\n+                        Thread.yield();", "originalCommit": "d093083a32ac1a54872e9a542240a3824f038041", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk3OTcwNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r470979705", "bodyText": "This meaningless code made the sum test pass, I do not understand why.\nAfter distinguishing between idempotent and accumulative indexes, the sum test passes without this ghost hunting.", "author": "jjezra", "createdAt": "2020-08-15T13:29:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxODUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxODc2Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r470918767", "bodyText": "Hm, perhaps this is a sign with our tests if it's not catching a bug here, but I think this needs to validate that the index is idempotent before it sets the isolation level to SNAPSHOT. Otherwise, there's not a guarantee that the concurrently written record will be indexed.\nWe should probably have a comment here explaining why SNAPSHOT is used, and then another explaining why we need to add the read conflict range at the place we do.", "author": "alecgrieser", "createdAt": "2020-08-15T01:06:05Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -539,7 +539,7 @@ private void increaseLimit() {\n         }\n         final IndexMaintainer maintainer = store.getIndexMaintainer(index);\n         final ExecuteProperties.Builder executeProperties = ExecuteProperties.newBuilder()\n-                .setIsolationLevel(IsolationLevel.SERIALIZABLE);\n+                .setIsolationLevel(IsolationLevel.SNAPSHOT);", "originalCommit": "d093083a32ac1a54872e9a542240a3824f038041", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk4MjU2Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r470982567", "bodyText": "The sum index test did fail, do not lose hope :)\nYou did mention before that the SNAPSHOT approach must be limited to idempotent indexes only, but I failed to assimilate (sorry). I'll fix it now.", "author": "jjezra", "createdAt": "2020-08-15T13:34:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxODc2Nw=="}], "type": "inlineReview"}, {"oid": "cc5a22bf9cfe0674a4aae5ab0835bb9a4d5681df", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/cc5a22bf9cfe0674a4aae5ab0835bb9a4d5681df", "message": "While setting endpoints for indexer, repeating conflicts with other transaction could prevent the job from running\n\n   resolution (for idempotent indexes only): Since the store is marked WRITE_ONLY while determining endpoints and\n   reading the records,is seems safe to ignore conflicts caused by insertion of new records - as the inseration\n   should already imply valid index entries.\n   TODO: add tests.", "committedDate": "2020-08-17T14:03:27Z", "type": "forcePushed"}, {"oid": "f707d2d05801980019b89bc63fe5ce27c3d49a65", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/f707d2d05801980019b89bc63fe5ce27c3d49a65", "message": "Resolves #1015: Avoid repeating index endpoints conflicts\n\n     Add utests.", "committedDate": "2020-08-19T13:30:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMwNDA1Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473304057", "bodyText": "Hmm. IIUC from offline conversations, this was needed to make future commits down the line not fail with a conflict, but this call seems suspicious to me. It essentially marks the index as already built, so the index build won't do much of anything, so it seems more likely to me that this is either masking some other problem, or there is some issue or is a sign that there is some other kind of misconfiguration going on with these tests.", "author": "alecgrieser", "createdAt": "2020-08-19T20:37:45Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * OnlineIndexerConflictsTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2018 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.record.IndexState;\n+import com.apple.foundationdb.record.TestRecords1Proto;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.test.Tags;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+\n+import static com.apple.foundationdb.record.metadata.Key.Expressions.field;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests for {@link OnlineIndexer}. Checking different db manipulations the indexing process.\n+ */\n+\n+@Tag(Tags.RequiresFDB)\n+public class OnlineIndexerConflictsTest extends OnlineIndexerTest {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(OnlineIndexerConflictsTest.class);\n+\n+    @Test\n+    public void testOnlineIndexerIdempotent() throws Exception {\n+\n+        Random rand = new Random();\n+        final long seed = rand.nextInt();\n+        LOGGER.info(\"Random seed is \" + seed);\n+        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+\n+        List<TestRecords1Proto.MySimpleRecord> records =\n+                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                                                 ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext()) {\n+            for (int i = 50; i <= 150; i++) {\n+                // even numbers 100-300 (that's 101 values)\n+                recordStore.saveRecord(records.get(i * 2));\n+            }\n+            context.commit();\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            assertTrue(recordStore.uncheckedMarkIndexReadable(index.getName()).join());", "originalCommit": "acdd84b077ab54cfa4c32895dca8602cbd99e734", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMxMzk5OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473313999", "bodyText": "I agree. This line was copied from the tests in OnlineIndexerSimpleTest. Would you have any idea why the indexer commit was failing without this line?", "author": "jjezra", "createdAt": "2020-08-19T20:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMwNDA1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMxOTU2OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473319569", "bodyText": "I believe all of the instances of that method being used in OnlineIndexerSimpleTest, it does so so that it can then scan the index without either (1) being told that the index isn't readable (which is what happens if you scan an unbuilt index normally) or (2) building the index and therefore disturbing it. It also looks like in all of the instances (that I could find) in OnlinIndexerSimpleTest, the transaction that calls uncheckedMarkIndexReadable isn't committed (and indeed, there are comments saying // do NOT commit instead of calls to commit()).\nI'm not sure why it's currently failing without that change, though. I had some theories, but most of the theories ended up being falsified by further experiments that you did. It's possible this needs more investigation, which might mean turning on detailed FDB client trace logging, or possibly investing in #1002 (or something temporary along those lines) to see what the conflict is.", "author": "alecgrieser", "createdAt": "2020-08-19T21:06:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMwNDA1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ2NTc5NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473465795", "bodyText": "I've added the test you've suggested above. Here I could mark the index as write only.", "author": "jjezra", "createdAt": "2020-08-20T00:18:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMwNDA1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3MjMzMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473472331", "bodyText": "I don't think this comment applies to this test any more", "author": "alecgrieser", "createdAt": "2020-08-20T00:28:29Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java", "diffHunk": "@@ -201,5 +201,60 @@ public void run() {\n         assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n         assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n+\n+    @Test\n+    public void testOnlineIndexerIdempotentNested() throws Exception {\n+        // If a conflict happens, this test should succeed by retries\n+        Random rand = new Random();\n+        final long seed = rand.nextInt();\n+        LOGGER.info(\"Random seed is \" + seed);\n+        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)", "originalCommit": "57772c69d76d3d8951d9bf34b0854b580021d12f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NjE2OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473476169", "bodyText": "I don't think this test needs quite as many records now. I think...three would suffice? The main tests have lots of records in order to make sure that during the random operations, we get lots of different combinations. That shouldn't be necessary with this test, though, as it's more about testing specific concurrent operations.", "author": "alecgrieser", "createdAt": "2020-08-20T00:34:33Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java", "diffHunk": "@@ -201,5 +201,60 @@ public void run() {\n         assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n         assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n+\n+    @Test\n+    public void testOnlineIndexerIdempotentNested() throws Exception {\n+        // If a conflict happens, this test should succeed by retries\n+        Random rand = new Random();\n+        final long seed = rand.nextInt();\n+        LOGGER.info(\"Random seed is \" + seed);\n+        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+\n+        List<TestRecords1Proto.MySimpleRecord> records =\n+                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());", "originalCommit": "57772c69d76d3d8951d9bf34b0854b580021d12f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ5MDk0OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473490949", "bodyText": "Sure. Shall I keep the other two (random) tests?", "author": "jjezra", "createdAt": "2020-08-20T00:57:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NjE2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ5NTkwMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473495903", "bodyText": "I don't think so, really. I think the tests in OnlineIndexerBuildValueIndexTest and OnlineIndexerBuildSumIndexTest are essentially trying to test the same thing, and so I think we'd want to stick with those (or add more tests there if we think they are insufficient).\nI'd also think we'd want to track down the weird conflict if we kept them in.", "author": "alecgrieser", "createdAt": "2020-08-20T01:05:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NjE2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUwMDcwMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473500703", "bodyText": "Ok.", "author": "jjezra", "createdAt": "2020-08-20T01:13:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NjE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NjY4MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473476680", "bodyText": "Hm, it's weird that you need to mark the index as write only.... It should be marking the index as write only when the record store is opened, I think, unless I'm misunderstanding how this all works.", "author": "alecgrieser", "createdAt": "2020-08-20T00:35:18Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java", "diffHunk": "@@ -201,5 +201,60 @@ public void run() {\n         assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n         assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n+\n+    @Test\n+    public void testOnlineIndexerIdempotentNested() throws Exception {\n+        // If a conflict happens, this test should succeed by retries\n+        Random rand = new Random();\n+        final long seed = rand.nextInt();\n+        LOGGER.info(\"Random seed is \" + seed);\n+        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+\n+        List<TestRecords1Proto.MySimpleRecord> records =\n+                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext()) {\n+            for (int i = 50; i <= 150; i++) {\n+                // even numbers 100-300 (that's 101 values)\n+                recordStore.saveRecord(records.get(i * 2));\n+            }\n+            context.commit();\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            recordStore.markIndexWriteOnly(index.getName()).join();", "originalCommit": "57772c69d76d3d8951d9bf34b0854b580021d12f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ5MjAwNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473492007", "bodyText": "Removing the writeOnly but keeping the commit works!", "author": "jjezra", "createdAt": "2020-08-20T00:59:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NjY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NzIwNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473477207", "bodyText": "I don't think doing this in a loop really adds much. Probably sufficient to just have the one insert. As written, this also builds the full index repeatedly within the loop, which probably isn't quite what we want.", "author": "alecgrieser", "createdAt": "2020-08-20T00:36:11Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java", "diffHunk": "@@ -201,5 +201,60 @@ public void run() {\n         assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n         assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n+\n+    @Test\n+    public void testOnlineIndexerIdempotentNested() throws Exception {\n+        // If a conflict happens, this test should succeed by retries\n+        Random rand = new Random();\n+        final long seed = rand.nextInt();\n+        LOGGER.info(\"Random seed is \" + seed);\n+        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+\n+        List<TestRecords1Proto.MySimpleRecord> records =\n+                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext()) {\n+            for (int i = 50; i <= 150; i++) {\n+                // even numbers 100-300 (that's 101 values)\n+                recordStore.saveRecord(records.get(i * 2));\n+            }\n+            context.commit();\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            recordStore.markIndexWriteOnly(index.getName()).join();\n+            context.commit();\n+        }\n+\n+        int[] inserts = {99, 101, 133, 201, 350, 299, 301};\n+        for (int i = 0; i < inserts.length; i++) {", "originalCommit": "57772c69d76d3d8951d9bf34b0854b580021d12f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ5MDEzNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473490134", "bodyText": "Actually that is intentional, I was trying to add a single record each time outside the range (from both sides), next the the first/last items, and in the middle of it. The result is repeatedly adding a record while repeatedly indexing.", "author": "jjezra", "createdAt": "2020-08-20T00:56:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NzIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ5NDgwMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473494800", "bodyText": "I believe that the way that OnlineIndexer.buildRange works, it'll build the whole range, so I think what this test is currently doing is:\n\nThe first iteration, building the index and inserting a record in separate transactions and asserting that they both succeed\nAll subsequent iterations, inserting a record and then validating that the index doesn't need to be built because it already has\n\nSo, I'm not quite sure it's testing what's desired, unless I'm misunderstanding the goal here.", "author": "alecgrieser", "createdAt": "2020-08-20T01:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NzIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUwMTcyMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473501720", "bodyText": "Is there an easy way to delete the index?", "author": "jjezra", "createdAt": "2020-08-20T01:14:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NzIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUwNTM4OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473505388", "bodyText": "If you create a new record store and call clearAndMarkIndexWriteOnly, that will delete all of the index's data, if that's what you want to do.", "author": "alecgrieser", "createdAt": "2020-08-20T01:20:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NzIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUwNTYxOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473505619", "bodyText": "Got it:\nFDBRecordStoreTestBase.RecordMetaDataHook hookDel = metaDataBuilder -> metaDataBuilder.removeIndex(index.getName());", "author": "jjezra", "createdAt": "2020-08-20T01:20:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NzIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUxNjEyMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473516122", "bodyText": "Sorry I didn't see your reply before submitting (my browser, as it seems, does not refresh frequently enough). Shall I change the removeIndex to clearAndMarkIndexWriteOnly?", "author": "jjezra", "createdAt": "2020-08-20T01:36:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NzIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUxNzIxOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473517218", "bodyText": "It depends on what you are trying to accomplish. The removeIndex method will...remove the index from the meta-data (so it will require adding it back to then build the index, if that's the idea). Whereas the method I gave simply \"clears out\" the index. I think you just want to clear it out here, but I could be misunderstanding the desired effect.", "author": "alecgrieser", "createdAt": "2020-08-20T01:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NzIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUxOTI0Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473519246", "bodyText": "Either one will work for my desired effect (which is to add a record in different locations while indexing). Would you be willing to review it as is?", "author": "jjezra", "createdAt": "2020-08-20T01:41:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NzIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3ODAzNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473478035", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        LOGGER.info(\"newIndex thread run\");\n          \n      \n    \n    \n  \n\nNow that it's not its own thread", "author": "alecgrieser", "createdAt": "2020-08-20T00:37:29Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java", "diffHunk": "@@ -201,5 +201,60 @@ public void run() {\n         assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n         assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n+\n+    @Test\n+    public void testOnlineIndexerIdempotentNested() throws Exception {\n+        // If a conflict happens, this test should succeed by retries\n+        Random rand = new Random();\n+        final long seed = rand.nextInt();\n+        LOGGER.info(\"Random seed is \" + seed);\n+        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+\n+        List<TestRecords1Proto.MySimpleRecord> records =\n+                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext()) {\n+            for (int i = 50; i <= 150; i++) {\n+                // even numbers 100-300 (that's 101 values)\n+                recordStore.saveRecord(records.get(i * 2));\n+            }\n+            context.commit();\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            recordStore.markIndexWriteOnly(index.getName()).join();\n+            context.commit();\n+        }\n+\n+        int[] inserts = {99, 101, 133, 201, 350, 299, 301};\n+        for (int i = 0; i < inserts.length; i++) {\n+            int record_i = inserts[i];\n+\n+            final FDBStoreTimer timer = new FDBStoreTimer();\n+            LOGGER.info(\"newIndex thread run\");", "originalCommit": "57772c69d76d3d8951d9bf34b0854b580021d12f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ5Mzc2Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473493762", "bodyText": "", "author": "jjezra", "createdAt": "2020-08-20T01:02:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3ODAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3ODQwOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473478409", "bodyText": "But...a conflict shouldn't happen?", "author": "alecgrieser", "createdAt": "2020-08-20T00:38:04Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java", "diffHunk": "@@ -201,5 +201,60 @@ public void run() {\n         assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n         assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n+\n+    @Test\n+    public void testOnlineIndexerIdempotentNested() throws Exception {\n+        // If a conflict happens, this test should succeed by retries", "originalCommit": "57772c69d76d3d8951d9bf34b0854b580021d12f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3OTkyMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473479922", "bodyText": "This assert isn't hurting anything, I suppose, but it's also already covered by the two contexts committing successfully above. It may be worth adding a comment on context1.commit() about how a record is being added in the range added by the indexer, but the transaction still commits because it's value isn't needed by the indexer.", "author": "alecgrieser", "createdAt": "2020-08-20T00:40:32Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java", "diffHunk": "@@ -201,5 +201,60 @@ public void run() {\n         assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n         assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n+\n+    @Test\n+    public void testOnlineIndexerIdempotentNested() throws Exception {\n+        // If a conflict happens, this test should succeed by retries\n+        Random rand = new Random();\n+        final long seed = rand.nextInt();\n+        LOGGER.info(\"Random seed is \" + seed);\n+        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+\n+        List<TestRecords1Proto.MySimpleRecord> records =\n+                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext()) {\n+            for (int i = 50; i <= 150; i++) {\n+                // even numbers 100-300 (that's 101 values)\n+                recordStore.saveRecord(records.get(i * 2));\n+            }\n+            context.commit();\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            recordStore.markIndexWriteOnly(index.getName()).join();\n+            context.commit();\n+        }\n+\n+        int[] inserts = {99, 101, 133, 201, 350, 299, 301};\n+        for (int i = 0; i < inserts.length; i++) {\n+            int record_i = inserts[i];\n+\n+            final FDBStoreTimer timer = new FDBStoreTimer();\n+            LOGGER.info(\"newIndex thread run\");\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n+                             OnlineIndexer.newBuilder()\n+                                     .setRecordStore(recordStore)\n+                                     .setIndex(\"newIndex\")\n+                                     .setTimer(timer)\n+                                     .build()) {\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(records.get(record_i));\n+                        context2.commit();\n+                    }\n+                    context1.commit();\n+                }\n+            }\n+\n+            assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));", "originalCommit": "57772c69d76d3d8951d9bf34b0854b580021d12f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ4MjQwNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473482404", "bodyText": "Hm, maybe something more like testAddRecordToRangeWhileIndexedIdempotent? Or something with those words?\nI don't think we want \"nested\" in the title. We typically use that to refer to nested key expressions (i.e., indexes defined on elements of nested messages), and having it here might cause confusion.", "author": "alecgrieser", "createdAt": "2020-08-20T00:44:24Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java", "diffHunk": "@@ -201,5 +201,60 @@ public void run() {\n         assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n         assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n+\n+    @Test\n+    public void testOnlineIndexerIdempotentNested() throws Exception {", "originalCommit": "57772c69d76d3d8951d9bf34b0854b580021d12f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxMjIxNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r474412217", "bodyText": "It's a good place to illustrate on \"range conflict protection\": allow records being added to the range (so they may be or may not be seen by indexer) while scanning.", "author": "nblintao", "createdAt": "2020-08-21T05:12:14Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1015,11 +1022,19 @@ public void rebuildIndex(@Nonnull FDBRecordStore store) {\n     @Nonnull\n     private CompletableFuture<TupleRange> buildEndpoints(@Nonnull FDBRecordStore store, @Nonnull RangeSet rangeSet,\n                                                          @Nullable AtomicLong recordsScanned) {\n+        boolean isIdempotent = store.getIndexMaintainer(index).isIdempotent();\n+        final IsolationLevel isolationLevel =\n+                isIdempotent ?\n+                // if idempotent: since double indexing is harmless, we can skip the range conflict protection. At worse,", "originalCommit": "779aef648d481dbf55b3b1135a6b263ffb0f3897", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcyNDA1OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r474724058", "bodyText": "I'm not sure I understand this action item. Are you suggesting to add a test to do it?\n(Alec said that this scenario is already covered in other tests)", "author": "jjezra", "createdAt": "2020-08-21T14:12:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxMjIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMjMxOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r474812318", "bodyText": "I meant it should help to explain \"range conflict protection\" in more detail in this comment.", "author": "nblintao", "createdAt": "2020-08-21T16:48:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxMjIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyMzAwOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r474823009", "bodyText": "Sure. NP!", "author": "jjezra", "createdAt": "2020-08-21T17:10:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxMjIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxMzY2Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r474413666", "bodyText": "Even though only one record is scanned, I think that record should be added to read conflict.\nI wouldn't worry about reproducing it from tests though.", "author": "nblintao", "createdAt": "2020-08-21T05:18:02Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1015,11 +1022,19 @@ public void rebuildIndex(@Nonnull FDBRecordStore store) {\n     @Nonnull\n     private CompletableFuture<TupleRange> buildEndpoints(@Nonnull FDBRecordStore store, @Nonnull RangeSet rangeSet,\n                                                          @Nullable AtomicLong recordsScanned) {\n+        boolean isIdempotent = store.getIndexMaintainer(index).isIdempotent();\n+        final IsolationLevel isolationLevel =\n+                isIdempotent ?\n+                // if idempotent: since double indexing is harmless, we can skip the range conflict protection. At worse,\n+                // some records will be re-indexed.\n+                IsolationLevel.SNAPSHOT :\n+                IsolationLevel.SERIALIZABLE;\n         final ExecuteProperties limit1 = ExecuteProperties.newBuilder()\n                 .setReturnedRowLimit(1)\n-                .setIsolationLevel(IsolationLevel.SERIALIZABLE)\n+                .setIsolationLevel(isolationLevel)", "originalCommit": "779aef648d481dbf55b3b1135a6b263ffb0f3897", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcyODA1Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r474728056", "bodyText": "If I understand it correctly:\nWhen idempotent - the endpoints will always be added to the conflicts list during the full scan, because the data doesn't change in a SNAPSHOT mode. And if an endpoint is not being indexed (other type), why should we care if it changes?\nWhen accumulative - we use the range protection, which includes the endpoints.\nWhat am I missing?", "author": "jjezra", "createdAt": "2020-08-21T14:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxMzY2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxODgyNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r474818826", "bodyText": "After taking close look, I think the implementation is correct. We don't need to add the endpoints to read conflict list because this method will call buildRange which will do it.", "author": "nblintao", "createdAt": "2020-08-21T17:01:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxMzY2Ng=="}], "type": "inlineReview"}, {"oid": "1d54d963231c6b06b25169fd81607f50d05b9d45", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/1d54d963231c6b06b25169fd81607f50d05b9d45", "message": "Resolves #1019: Avoid repeating index endpoints conflicts\n\n   While setting the indexer's range, repeating conflicts with other transaction could prevent the job from running\n\n   resolution (for idempotent indexes only): Set the endpoints and read the records in a non-conflicting SNAPSHOT isolation,\n   and add each indexed record to a conflict list. Having the index in WRITE_ONLY mode, new records within the range will be\n   indexed while inserted and shall not cause a rejection.", "committedDate": "2020-08-21T14:51:26Z", "type": "commit"}, {"oid": "1d54d963231c6b06b25169fd81607f50d05b9d45", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/1d54d963231c6b06b25169fd81607f50d05b9d45", "message": "Resolves #1019: Avoid repeating index endpoints conflicts\n\n   While setting the indexer's range, repeating conflicts with other transaction could prevent the job from running\n\n   resolution (for idempotent indexes only): Set the endpoints and read the records in a non-conflicting SNAPSHOT isolation,\n   and add each indexed record to a conflict list. Having the index in WRITE_ONLY mode, new records within the range will be\n   indexed while inserted and shall not cause a rejection.", "committedDate": "2020-08-21T14:51:26Z", "type": "forcePushed"}, {"oid": "9a857ec3666b81d75ce21ae79cd67f318ec77bf9", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/9a857ec3666b81d75ce21ae79cd67f318ec77bf9", "message": "Implement Tao's change request", "committedDate": "2020-08-21T17:24:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgzMTc1MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r474831751", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testAddRecordToRangeWhileIndexedIdempotentFailure() {\n          \n          \n            \n                public void testModifyRecordInRangeWhileIndexedIdempotentFailure() {\n          \n      \n    \n    \n  \n\nI think that's probably a more accurate description", "author": "alecgrieser", "createdAt": "2020-08-21T17:28:45Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * OnlineIndexerConflictsTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2018 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.record.TestRecords1Proto;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.test.Tags;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+\n+import static com.apple.foundationdb.record.metadata.Key.Expressions.field;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+/**\n+ * Tests for {@link OnlineIndexer}. Checking different db manipulations during the indexing process.\n+ */\n+\n+@Tag(Tags.RequiresFDB)\n+public class OnlineIndexerConflictsTest extends OnlineIndexerTest {\n+\n+    @Test\n+    public void testAddRecordToRangeWhileIndexedIdempotent() {\n+\n+        List<TestRecords1Proto.MySimpleRecord> records =\n+                LongStream.range(0, 20).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext()) {\n+            for (int i = 2; i <= 8; i++) {\n+                // even numbers from 4 to 16\n+                recordStore.saveRecord(records.get(i * 2));\n+            }\n+            context.commit();\n+        }\n+        openSimpleMetaData(hookAdd);\n+        try (FDBRecordContext context = openContext()) {\n+            context.commit();\n+        }\n+\n+        int[] inserts = {2, 5, 11, 17, 15};\n+        for (int i = 0; i < inserts.length; i++) {\n+            int record_i = inserts[i];\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n+                             OnlineIndexer.newBuilder()\n+                                     .setRecordStore(recordStore)\n+                                     .setIndex(\"newIndex\")\n+                                     .build()) {\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(records.get(record_i));\n+                        // This record might be added in the indexer's range, but the transaction still commits because it doesn't\n+                        // change any existing records.\n+                        context2.commit();\n+                    }\n+                    context1.commit();\n+                }\n+            }\n+\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testAddRecordToRangeWhileIndexedOtherType() {\n+\n+        List<TestRecords1Proto.MySimpleRecord> records =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val * 2).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        List<TestRecords1Proto.MyOtherRecord> otherRecords =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MyOtherRecord.newBuilder().setRecNo(val * 2 + 1).setNumValue2((int) val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        List<TestRecords1Proto.MyOtherRecord> otherRecordsOverwrite =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MyOtherRecord.newBuilder().setRecNo(val * 2 + 1).setNumValue2((int) val + 101).build()\n+                ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext()) {\n+            records.forEach(recordStore::saveRecord);\n+            otherRecords.forEach(recordStore::saveRecord);\n+            context.commit();\n+        }\n+        openSimpleMetaData(hookAdd);\n+        try (FDBRecordContext context = openContext()) {\n+            context.commit();\n+        }\n+\n+        otherRecordsOverwrite.forEach(rec -> {\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n+                             OnlineIndexer.newBuilder()\n+                                     .setRecordStore(recordStore)\n+                                     .setIndex(\"newIndex\")\n+                                     .build()) {\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(rec);\n+                        // This record's type is different than the indexer's, so both commits should succeed\n+                        context2.commit();\n+                    }\n+                    context1.commit();\n+                }\n+            }\n+\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testAddRecordToRangeWhileIndexedIdempotentFailure() {", "originalCommit": "9a857ec3666b81d75ce21ae79cd67f318ec77bf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "12b07955f26082a418f529c0b44c2571b9718b16", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/12b07955f26082a418f529c0b44c2571b9718b16", "message": "implement changes requested by Alec", "committedDate": "2020-08-22T01:35:28Z", "type": "commit"}]}