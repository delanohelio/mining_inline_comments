{"pr_number": 854, "pr_title": "Resolves #852: Enhance KeySpaceCountTree to allow for application-specific resolution", "pr_createdAt": "2020-03-14T02:21:09Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/854", "timeline": [{"oid": "b43c02e442f2698943182309acead378dc564fb4", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/b43c02e442f2698943182309acead378dc564fb4", "message": "Resolves #852: Enhance KeySpaceCountTree to allow for application-specific resolution", "committedDate": "2020-03-14T03:01:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzczMzY5Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/854#discussion_r393733696", "bodyText": "Maybe not for this PR, but it seems that it may be very useful to formalize where record stores live in the keyspace (so that a directory \"knows\" that is contains record stores)...but, I guess for this to really be useful, then the directory should also have some way to describe how to find the metadata for the stores under it.  Anyway, just thinking out loud.", "author": "scgray", "createdAt": "2020-03-17T14:46:43Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/clientlog/KeySpaceCountTree.java", "diffHunk": "@@ -83,35 +389,181 @@ protected TupleKeyCountTree newPrefixChild(@Nonnull Object prefix) {\n         }\n     }\n \n-    protected CompletableFuture<Void> resolvePathValue(@Nonnull FDBRecordContext context,\n-                                                       @Nonnull KeySpaceDirectory parentDirectory, @Nullable ResolvedKeySpacePath parentPath) {\n-        if (resolvedPath != null || !hasObject()) {\n+    protected CompletableFuture<Void> resolve(@Nonnull FDBRecordContext context, @Nonnull Resolved resolvedParent) {\n+        if (resolved != null || !hasObject()) {\n             return AsyncUtil.DONE;\n         }\n-        try {\n-            return parentDirectory.findChildForValue(context, parentPath, getObject()).handle((resolved, ex) -> {\n-                if (resolved != null) {\n-                    // Null case includes swallowing async error (ex).\n-                    this.resolvedPath = resolved;\n-                    this.directory = resolved.getDirectory();\n+        return resolve(context, resolvedParent, getObject()).thenAccept(resolved -> {\n+            if (resolved != null) {\n+                this.resolved = resolved;\n+            }\n+        });\n+    }\n+\n+    protected CompletableFuture<Resolved> resolve(@Nonnull FDBRecordContext context, @Nonnull Resolved resolvedParent, @Nullable Object object) {\n+        if (resolvedParent.getDirectory() != null) {\n+            if (resolvedParent.getDirectory().getSubdirectories().isEmpty()) {\n+                if (isRecordStoreLeaf(context, resolvedParent, object)) {\n+                    // The top level keys in a record store use FDBRecordStoreKeyspace.\n+                    FDBRecordStoreKeyspace recordStoreKeyspace;\n+                    if (object == null) {\n+                        // The store header is read with a range scan from the first subkey (Tuple null) to detect various anomalies.\n+                        recordStoreKeyspace = FDBRecordStoreKeyspace.STORE_INFO;\n+                    } else {\n+                        try {\n+                            recordStoreKeyspace = FDBRecordStoreKeyspace.fromKey(object);\n+                        } catch (RecordCoreException ex) {\n+                            return UNRESOLVED;\n+                        }\n+                    }\n+                    if (recordStoreKeyspace != FDBRecordStoreKeyspace.STORE_INFO) {\n+                        return getRecordStoreMetaData(context, resolvedParent, object)\n+                                .thenApply(metaData -> new ResolvedRecordStoreKeyspace(resolvedParent, recordStoreKeyspace, metaData, object));\n+                    } else {\n+                        return CompletableFuture.completedFuture(new ResolvedRecordStoreKeyspace(resolvedParent, recordStoreKeyspace, null, object));\n+                    }\n                 }\n-                return null;\n-            });\n-        } catch (RecordCoreException ex) {\n-            return AsyncUtil.DONE;\n+            } else {\n+                try {\n+                    return resolvedParent.getDirectory().findChildForValue(context, resolvedParent.getResolvedPath(), object).handle((resolved, ex) -> {\n+                        // Null case includes swallowing async error (ex).\n+                        return resolved == null ? null : new ResolvedPath(resolvedParent, resolved);\n+                    });\n+                } catch (RecordCoreException ex) {\n+                    return UNRESOLVED;\n+                }\n+            }\n+        }\n+        return resolveNonDirectory(context, resolvedParent, object);\n+    }\n+\n+    /**\n+     * Resolve something other than a {@link KeySpaceDirectory} node.\n+     * @param context an open transaction to use to read from the database\n+     * @param resolvedParent the resolved parent node\n+     * @param object the {@link com.apple.foundationdb.tuple.Tuple} element for this node\n+     * @return a future that completes to a new {@link Resolved} or {@code null}\n+     */\n+    protected CompletableFuture<Resolved> resolveNonDirectory(@Nonnull FDBRecordContext context, @Nonnull Resolved resolvedParent, @Nullable Object object) {\n+        int distance = 0;\n+        ResolvedRecordStoreKeyspace recordStoreKeyspace = null;\n+        ResolvedRecordTypeKeyspace recordTypeKeyspace = null;\n+        ResolvedIndexKeyspace indexKeyspace = null;\n+        for (Resolved resolved = resolvedParent; resolved != null && resolved.getDirectory() == null; resolved = resolved.getParent()) {\n+            if (resolved instanceof ResolvedRecordTypeKeyspace) {\n+                recordTypeKeyspace = (ResolvedRecordTypeKeyspace)resolved;\n+                break;\n+            }\n+            if (resolved instanceof ResolvedIndexKeyspace) {\n+                indexKeyspace = (ResolvedIndexKeyspace)resolved;\n+                break;\n+            }\n+            if (resolved instanceof ResolvedRecordStoreKeyspace) {\n+                recordStoreKeyspace = (ResolvedRecordStoreKeyspace)resolved;\n+                break;\n+            }\n+            distance++;\n+        }\n+        if (recordStoreKeyspace != null && recordStoreKeyspace.getRecordMetaData() != null) {\n+            switch (recordStoreKeyspace.getRecordStoreKeyspace()) {\n+                case RECORD:\n+                    if (distance == 0 && object != null && recordStoreKeyspace.getRecordMetaData().primaryKeyHasRecordTypePrefix()) {\n+                        final RecordType recordType;\n+                        try {\n+                            recordType = recordStoreKeyspace.getRecordMetaData().getRecordTypeFromRecordTypeKey(object);\n+                        } catch (RecordCoreException ex) {\n+                            break;\n+                        }\n+                        return CompletableFuture.completedFuture(new ResolvedRecordTypeKeyspace(resolvedParent, recordType));\n+                    }\n+                    KeyExpression commonPrimaryKey = recordStoreKeyspace.getRecordMetaData().commonPrimaryKey();\n+                    if (commonPrimaryKey != null && distance < commonPrimaryKey.getColumnSize()) {\n+                        return resolvePrimaryKeyField(context, resolvedParent, object, commonPrimaryKey, distance);\n+                    }\n+                    break;\n+                case INDEX:\n+                case INDEX_SECONDARY_SPACE:\n+                case INDEX_RANGE_SPACE:\n+                case INDEX_UNIQUENESS_VIOLATIONS_SPACE:\n+                case INDEX_BUILD_SPACE:\n+                    if (distance == 0 && object != null) {\n+                        final Index index;\n+                        try {\n+                            index = recordStoreKeyspace.getRecordMetaData().getIndexFromSubspaceKey(object);\n+                        } catch (RecordCoreException ex) {\n+                            break;\n+                        }\n+                        return CompletableFuture.completedFuture(new ResolvedIndexKeyspace(resolvedParent, index));\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        if (recordTypeKeyspace != null) {\n+            KeyExpression primaryKey = recordTypeKeyspace.getRecordType().getPrimaryKey();\n+            if (distance + 1 < primaryKey.getColumnSize()) {\n+                return resolvePrimaryKeyField(context, resolvedParent, object, primaryKey, distance + 1);\n+            }\n         }\n+        if (indexKeyspace != null &&\n+                indexKeyspace.getParent() instanceof ResolvedRecordStoreKeyspace &&\n+                ((ResolvedRecordStoreKeyspace)indexKeyspace.getParent()).getRecordStoreKeyspace() == FDBRecordStoreKeyspace.INDEX) {\n+            Index index = indexKeyspace.getIndex();\n+            KeyExpression indexExpression = index.getRootExpression();\n+            if (distance < indexExpression.getColumnSize()) {\n+                return resolveIndexField(context, resolvedParent, object, index, indexExpression, distance);\n+            }\n+        }\n+        return UNRESOLVED;\n+    }\n+\n+    /**\n+     * Determine whether this leaf of the {@link KeySpaceDirectory} tree is the root of a {@link com.apple.foundationdb.record.provider.foundationdb.FDBRecordStore}.\n+     * @param context an open transaction to use to read from the database\n+     * @param resolvedParent the resolved parent node\n+     * @param object the {@link com.apple.foundationdb.tuple.Tuple} element for this node\n+     * @return {@code true} if this path stores a record store\n+     */\n+    protected boolean isRecordStoreLeaf(@Nonnull FDBRecordContext context, @Nonnull Resolved resolvedParent, @Nullable Object object) {", "originalCommit": "b43c02e442f2698943182309acead378dc564fb4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "48d67b56c07f4ef1c36e363b3ac0fe7e14bcb777", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/48d67b56c07f4ef1c36e363b3ac0fe7e14bcb777", "message": "Resolves #852: Enhance KeySpaceCountTree to allow for application-specific resolution", "committedDate": "2020-03-17T21:38:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcxNjEzMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/854#discussion_r394716131", "bodyText": "This and getIndexFromSubspaceKey should probably document that they throw a MetaDataException if the object specified is not found in the meta-data.", "author": "alecgrieser", "createdAt": "2020-03-19T00:20:05Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/RecordMetaData.java", "diffHunk": "@@ -171,6 +171,16 @@ public RecordType getRecordTypeForDescriptor(@Nonnull Descriptors.Descriptor des\n         return recordType;\n     }\n \n+    @Nonnull\n+    public RecordType getRecordTypeFromRecordTypeKey(@Nonnull Object recordTypeKey) {", "originalCommit": "48d67b56c07f4ef1c36e363b3ac0fe7e14bcb777", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1Njg2Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/854#discussion_r394756862", "bodyText": "Added.", "author": "MMcM", "createdAt": "2020-03-19T02:30:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcxNjEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcyMTc5NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/854#discussion_r394721794", "bodyText": "If I understand the implementation correctly, is the idea that users will extend this class and provide their own implementation of getRecordStoreMetaData and isRecordStoreLeaf? It might be good to clarify that, though this class is maybe a tad experimental for too much documentation.", "author": "alecgrieser", "createdAt": "2020-03-19T00:31:14Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/clientlog/KeySpaceCountTree.java", "diffHunk": "@@ -23,29 +23,335 @@\n import com.apple.foundationdb.async.AsyncUtil;\n import com.apple.foundationdb.clientlog.TupleKeyCountTree;\n import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n import com.apple.foundationdb.record.provider.foundationdb.FDBRecordContext;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreKeyspace;\n import com.apple.foundationdb.record.provider.foundationdb.keyspace.KeySpace;\n import com.apple.foundationdb.record.provider.foundationdb.keyspace.KeySpaceDirectory;\n+import com.apple.foundationdb.record.provider.foundationdb.keyspace.KeySpacePath;\n import com.apple.foundationdb.record.provider.foundationdb.keyspace.ResolvedKeySpacePath;\n \n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.Objects;\n import java.util.concurrent.CompletableFuture;\n \n /**\n  * Count keys and resolve back to key space paths.\n  */\n public class KeySpaceCountTree extends TupleKeyCountTree {", "originalCommit": "48d67b56c07f4ef1c36e363b3ac0fe7e14bcb777", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1Njk1MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/854#discussion_r394756951", "bodyText": "Yes. I added Javadoc to that effect on those two methods.", "author": "MMcM", "createdAt": "2020-03-19T02:30:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcyMTc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcyNDU0MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/854#discussion_r394724541", "bodyText": "Hm, we have a few places that we try and rendezvous the tuple we see with a key expression, but they're all a little scattershot. I think having this is here is probably fine, though perhaps when some of the new planner changes make that easier, it would be good to switch to that, or something.", "author": "alecgrieser", "createdAt": "2020-03-19T00:41:31Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/clientlog/KeySpaceCountTree.java", "diffHunk": "@@ -83,35 +389,181 @@ protected TupleKeyCountTree newPrefixChild(@Nonnull Object prefix) {\n         }\n     }\n \n-    protected CompletableFuture<Void> resolvePathValue(@Nonnull FDBRecordContext context,\n-                                                       @Nonnull KeySpaceDirectory parentDirectory, @Nullable ResolvedKeySpacePath parentPath) {\n-        if (resolvedPath != null || !hasObject()) {\n+    protected CompletableFuture<Void> resolve(@Nonnull FDBRecordContext context, @Nonnull Resolved resolvedParent) {\n+        if (resolved != null || !hasObject()) {\n             return AsyncUtil.DONE;\n         }\n-        try {\n-            return parentDirectory.findChildForValue(context, parentPath, getObject()).handle((resolved, ex) -> {\n-                if (resolved != null) {\n-                    // Null case includes swallowing async error (ex).\n-                    this.resolvedPath = resolved;\n-                    this.directory = resolved.getDirectory();\n+        return resolve(context, resolvedParent, getObject()).thenAccept(resolved -> {\n+            if (resolved != null) {\n+                this.resolved = resolved;\n+            }\n+        });\n+    }\n+\n+    protected CompletableFuture<Resolved> resolve(@Nonnull FDBRecordContext context, @Nonnull Resolved resolvedParent, @Nullable Object object) {\n+        if (resolvedParent.getDirectory() != null) {\n+            if (resolvedParent.getDirectory().getSubdirectories().isEmpty()) {\n+                if (isRecordStoreLeaf(context, resolvedParent, object)) {\n+                    // The top level keys in a record store use FDBRecordStoreKeyspace.\n+                    FDBRecordStoreKeyspace recordStoreKeyspace;\n+                    if (object == null) {\n+                        // The store header is read with a range scan from the first subkey (Tuple null) to detect various anomalies.\n+                        recordStoreKeyspace = FDBRecordStoreKeyspace.STORE_INFO;\n+                    } else {\n+                        try {\n+                            recordStoreKeyspace = FDBRecordStoreKeyspace.fromKey(object);\n+                        } catch (RecordCoreException ex) {\n+                            return UNRESOLVED;\n+                        }\n+                    }\n+                    if (recordStoreKeyspace != FDBRecordStoreKeyspace.STORE_INFO) {\n+                        return getRecordStoreMetaData(context, resolvedParent, object)\n+                                .thenApply(metaData -> new ResolvedRecordStoreKeyspace(resolvedParent, recordStoreKeyspace, metaData, object));\n+                    } else {\n+                        return CompletableFuture.completedFuture(new ResolvedRecordStoreKeyspace(resolvedParent, recordStoreKeyspace, null, object));\n+                    }\n                 }\n-                return null;\n-            });\n-        } catch (RecordCoreException ex) {\n-            return AsyncUtil.DONE;\n+            } else {\n+                try {\n+                    return resolvedParent.getDirectory().findChildForValue(context, resolvedParent.getResolvedPath(), object).handle((resolved, ex) -> {\n+                        // Null case includes swallowing async error (ex).\n+                        return resolved == null ? null : new ResolvedPath(resolvedParent, resolved);\n+                    });\n+                } catch (RecordCoreException ex) {\n+                    return UNRESOLVED;\n+                }\n+            }\n+        }\n+        return resolveNonDirectory(context, resolvedParent, object);\n+    }\n+\n+    /**\n+     * Resolve something other than a {@link KeySpaceDirectory} node.\n+     * @param context an open transaction to use to read from the database\n+     * @param resolvedParent the resolved parent node\n+     * @param object the {@link com.apple.foundationdb.tuple.Tuple} element for this node\n+     * @return a future that completes to a new {@link Resolved} or {@code null}\n+     */\n+    protected CompletableFuture<Resolved> resolveNonDirectory(@Nonnull FDBRecordContext context, @Nonnull Resolved resolvedParent, @Nullable Object object) {\n+        int distance = 0;\n+        ResolvedRecordStoreKeyspace recordStoreKeyspace = null;\n+        ResolvedRecordTypeKeyspace recordTypeKeyspace = null;\n+        ResolvedIndexKeyspace indexKeyspace = null;\n+        for (Resolved resolved = resolvedParent; resolved != null && resolved.getDirectory() == null; resolved = resolved.getParent()) {\n+            if (resolved instanceof ResolvedRecordTypeKeyspace) {\n+                recordTypeKeyspace = (ResolvedRecordTypeKeyspace)resolved;\n+                break;\n+            }\n+            if (resolved instanceof ResolvedIndexKeyspace) {\n+                indexKeyspace = (ResolvedIndexKeyspace)resolved;\n+                break;\n+            }\n+            if (resolved instanceof ResolvedRecordStoreKeyspace) {\n+                recordStoreKeyspace = (ResolvedRecordStoreKeyspace)resolved;\n+                break;\n+            }\n+            distance++;\n+        }\n+        if (recordStoreKeyspace != null && recordStoreKeyspace.getRecordMetaData() != null) {\n+            switch (recordStoreKeyspace.getRecordStoreKeyspace()) {\n+                case RECORD:\n+                    if (distance == 0 && object != null && recordStoreKeyspace.getRecordMetaData().primaryKeyHasRecordTypePrefix()) {\n+                        final RecordType recordType;\n+                        try {\n+                            recordType = recordStoreKeyspace.getRecordMetaData().getRecordTypeFromRecordTypeKey(object);\n+                        } catch (RecordCoreException ex) {\n+                            break;\n+                        }\n+                        return CompletableFuture.completedFuture(new ResolvedRecordTypeKeyspace(resolvedParent, recordType));\n+                    }\n+                    KeyExpression commonPrimaryKey = recordStoreKeyspace.getRecordMetaData().commonPrimaryKey();\n+                    if (commonPrimaryKey != null && distance < commonPrimaryKey.getColumnSize()) {\n+                        return resolvePrimaryKeyField(context, resolvedParent, object, commonPrimaryKey, distance);\n+                    }\n+                    break;\n+                case INDEX:\n+                case INDEX_SECONDARY_SPACE:\n+                case INDEX_RANGE_SPACE:\n+                case INDEX_UNIQUENESS_VIOLATIONS_SPACE:\n+                case INDEX_BUILD_SPACE:\n+                    if (distance == 0 && object != null) {\n+                        final Index index;\n+                        try {\n+                            index = recordStoreKeyspace.getRecordMetaData().getIndexFromSubspaceKey(object);\n+                        } catch (RecordCoreException ex) {\n+                            break;\n+                        }\n+                        return CompletableFuture.completedFuture(new ResolvedIndexKeyspace(resolvedParent, index));\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        if (recordTypeKeyspace != null) {\n+            KeyExpression primaryKey = recordTypeKeyspace.getRecordType().getPrimaryKey();\n+            if (distance + 1 < primaryKey.getColumnSize()) {\n+                return resolvePrimaryKeyField(context, resolvedParent, object, primaryKey, distance + 1);\n+            }\n         }\n+        if (indexKeyspace != null &&\n+                indexKeyspace.getParent() instanceof ResolvedRecordStoreKeyspace &&\n+                ((ResolvedRecordStoreKeyspace)indexKeyspace.getParent()).getRecordStoreKeyspace() == FDBRecordStoreKeyspace.INDEX) {\n+            Index index = indexKeyspace.getIndex();\n+            KeyExpression indexExpression = index.getRootExpression();\n+            if (distance < indexExpression.getColumnSize()) {\n+                return resolveIndexField(context, resolvedParent, object, index, indexExpression, distance);\n+            }\n+        }\n+        return UNRESOLVED;\n+    }\n+\n+    /**\n+     * Determine whether this leaf of the {@link KeySpaceDirectory} tree is the root of a {@link com.apple.foundationdb.record.provider.foundationdb.FDBRecordStore}.\n+     * @param context an open transaction to use to read from the database\n+     * @param resolvedParent the resolved parent node\n+     * @param object the {@link com.apple.foundationdb.tuple.Tuple} element for this node\n+     * @return {@code true} if this path stores a record store\n+     */\n+    protected boolean isRecordStoreLeaf(@Nonnull FDBRecordContext context, @Nonnull Resolved resolvedParent, @Nullable Object object) {\n+        return false;\n+    }\n+\n+    /**\n+     * Given a key space path for which {@link #isRecordStoreLeaf} is {@code true}, get the record store's meta-data.\n+     * @param context an open transaction to use to read from the database\n+     * @param resolvedParent the resolved parent node\n+     * @param object the {@link com.apple.foundationdb.tuple.Tuple} element for this node\n+     * @return a future that completes to the record store's meta-data or {@code null}\n+     */\n+    protected CompletableFuture<RecordMetaData> getRecordStoreMetaData(@Nonnull FDBRecordContext context, @Nonnull Resolved resolvedParent, @Nullable Object object) {\n+        return NO_META_DATA;\n+    }\n+\n+    protected CompletableFuture<Resolved> resolvePrimaryKeyField(@Nonnull FDBRecordContext context, @Nonnull Resolved resolvedParent, @Nullable Object object,\n+                                                                 @Nonnull KeyExpression primaryKey, int index) {\n+        List<KeyExpression> keys = primaryKey.normalizeKeyForPositions();", "originalCommit": "48d67b56c07f4ef1c36e363b3ac0fe7e14bcb777", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1NzAyMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/854#discussion_r394757021", "bodyText": "Yes, agreed. But that feels outside the scope of this branch.", "author": "MMcM", "createdAt": "2020-03-19T02:31:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcyNDU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcyNDY3OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/854#discussion_r394724679", "bodyText": "Why is this UNRESOLVED rather than following the same logic as in resolvePrimaryKey?", "author": "alecgrieser", "createdAt": "2020-03-19T00:42:07Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/clientlog/KeySpaceCountTree.java", "diffHunk": "@@ -83,35 +389,181 @@ protected TupleKeyCountTree newPrefixChild(@Nonnull Object prefix) {\n         }\n     }\n \n-    protected CompletableFuture<Void> resolvePathValue(@Nonnull FDBRecordContext context,\n-                                                       @Nonnull KeySpaceDirectory parentDirectory, @Nullable ResolvedKeySpacePath parentPath) {\n-        if (resolvedPath != null || !hasObject()) {\n+    protected CompletableFuture<Void> resolve(@Nonnull FDBRecordContext context, @Nonnull Resolved resolvedParent) {\n+        if (resolved != null || !hasObject()) {\n             return AsyncUtil.DONE;\n         }\n-        try {\n-            return parentDirectory.findChildForValue(context, parentPath, getObject()).handle((resolved, ex) -> {\n-                if (resolved != null) {\n-                    // Null case includes swallowing async error (ex).\n-                    this.resolvedPath = resolved;\n-                    this.directory = resolved.getDirectory();\n+        return resolve(context, resolvedParent, getObject()).thenAccept(resolved -> {\n+            if (resolved != null) {\n+                this.resolved = resolved;\n+            }\n+        });\n+    }\n+\n+    protected CompletableFuture<Resolved> resolve(@Nonnull FDBRecordContext context, @Nonnull Resolved resolvedParent, @Nullable Object object) {\n+        if (resolvedParent.getDirectory() != null) {\n+            if (resolvedParent.getDirectory().getSubdirectories().isEmpty()) {\n+                if (isRecordStoreLeaf(context, resolvedParent, object)) {\n+                    // The top level keys in a record store use FDBRecordStoreKeyspace.\n+                    FDBRecordStoreKeyspace recordStoreKeyspace;\n+                    if (object == null) {\n+                        // The store header is read with a range scan from the first subkey (Tuple null) to detect various anomalies.\n+                        recordStoreKeyspace = FDBRecordStoreKeyspace.STORE_INFO;\n+                    } else {\n+                        try {\n+                            recordStoreKeyspace = FDBRecordStoreKeyspace.fromKey(object);\n+                        } catch (RecordCoreException ex) {\n+                            return UNRESOLVED;\n+                        }\n+                    }\n+                    if (recordStoreKeyspace != FDBRecordStoreKeyspace.STORE_INFO) {\n+                        return getRecordStoreMetaData(context, resolvedParent, object)\n+                                .thenApply(metaData -> new ResolvedRecordStoreKeyspace(resolvedParent, recordStoreKeyspace, metaData, object));\n+                    } else {\n+                        return CompletableFuture.completedFuture(new ResolvedRecordStoreKeyspace(resolvedParent, recordStoreKeyspace, null, object));\n+                    }\n                 }\n-                return null;\n-            });\n-        } catch (RecordCoreException ex) {\n-            return AsyncUtil.DONE;\n+            } else {\n+                try {\n+                    return resolvedParent.getDirectory().findChildForValue(context, resolvedParent.getResolvedPath(), object).handle((resolved, ex) -> {\n+                        // Null case includes swallowing async error (ex).\n+                        return resolved == null ? null : new ResolvedPath(resolvedParent, resolved);\n+                    });\n+                } catch (RecordCoreException ex) {\n+                    return UNRESOLVED;\n+                }\n+            }\n+        }\n+        return resolveNonDirectory(context, resolvedParent, object);\n+    }\n+\n+    /**\n+     * Resolve something other than a {@link KeySpaceDirectory} node.\n+     * @param context an open transaction to use to read from the database\n+     * @param resolvedParent the resolved parent node\n+     * @param object the {@link com.apple.foundationdb.tuple.Tuple} element for this node\n+     * @return a future that completes to a new {@link Resolved} or {@code null}\n+     */\n+    protected CompletableFuture<Resolved> resolveNonDirectory(@Nonnull FDBRecordContext context, @Nonnull Resolved resolvedParent, @Nullable Object object) {\n+        int distance = 0;\n+        ResolvedRecordStoreKeyspace recordStoreKeyspace = null;\n+        ResolvedRecordTypeKeyspace recordTypeKeyspace = null;\n+        ResolvedIndexKeyspace indexKeyspace = null;\n+        for (Resolved resolved = resolvedParent; resolved != null && resolved.getDirectory() == null; resolved = resolved.getParent()) {\n+            if (resolved instanceof ResolvedRecordTypeKeyspace) {\n+                recordTypeKeyspace = (ResolvedRecordTypeKeyspace)resolved;\n+                break;\n+            }\n+            if (resolved instanceof ResolvedIndexKeyspace) {\n+                indexKeyspace = (ResolvedIndexKeyspace)resolved;\n+                break;\n+            }\n+            if (resolved instanceof ResolvedRecordStoreKeyspace) {\n+                recordStoreKeyspace = (ResolvedRecordStoreKeyspace)resolved;\n+                break;\n+            }\n+            distance++;\n+        }\n+        if (recordStoreKeyspace != null && recordStoreKeyspace.getRecordMetaData() != null) {\n+            switch (recordStoreKeyspace.getRecordStoreKeyspace()) {\n+                case RECORD:\n+                    if (distance == 0 && object != null && recordStoreKeyspace.getRecordMetaData().primaryKeyHasRecordTypePrefix()) {\n+                        final RecordType recordType;\n+                        try {\n+                            recordType = recordStoreKeyspace.getRecordMetaData().getRecordTypeFromRecordTypeKey(object);\n+                        } catch (RecordCoreException ex) {\n+                            break;\n+                        }\n+                        return CompletableFuture.completedFuture(new ResolvedRecordTypeKeyspace(resolvedParent, recordType));\n+                    }\n+                    KeyExpression commonPrimaryKey = recordStoreKeyspace.getRecordMetaData().commonPrimaryKey();\n+                    if (commonPrimaryKey != null && distance < commonPrimaryKey.getColumnSize()) {\n+                        return resolvePrimaryKeyField(context, resolvedParent, object, commonPrimaryKey, distance);\n+                    }\n+                    break;\n+                case INDEX:\n+                case INDEX_SECONDARY_SPACE:\n+                case INDEX_RANGE_SPACE:\n+                case INDEX_UNIQUENESS_VIOLATIONS_SPACE:\n+                case INDEX_BUILD_SPACE:\n+                    if (distance == 0 && object != null) {\n+                        final Index index;\n+                        try {\n+                            index = recordStoreKeyspace.getRecordMetaData().getIndexFromSubspaceKey(object);\n+                        } catch (RecordCoreException ex) {\n+                            break;\n+                        }\n+                        return CompletableFuture.completedFuture(new ResolvedIndexKeyspace(resolvedParent, index));\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        if (recordTypeKeyspace != null) {\n+            KeyExpression primaryKey = recordTypeKeyspace.getRecordType().getPrimaryKey();\n+            if (distance + 1 < primaryKey.getColumnSize()) {\n+                return resolvePrimaryKeyField(context, resolvedParent, object, primaryKey, distance + 1);\n+            }\n         }\n+        if (indexKeyspace != null &&\n+                indexKeyspace.getParent() instanceof ResolvedRecordStoreKeyspace &&\n+                ((ResolvedRecordStoreKeyspace)indexKeyspace.getParent()).getRecordStoreKeyspace() == FDBRecordStoreKeyspace.INDEX) {\n+            Index index = indexKeyspace.getIndex();\n+            KeyExpression indexExpression = index.getRootExpression();\n+            if (distance < indexExpression.getColumnSize()) {\n+                return resolveIndexField(context, resolvedParent, object, index, indexExpression, distance);\n+            }\n+        }\n+        return UNRESOLVED;\n+    }\n+\n+    /**\n+     * Determine whether this leaf of the {@link KeySpaceDirectory} tree is the root of a {@link com.apple.foundationdb.record.provider.foundationdb.FDBRecordStore}.\n+     * @param context an open transaction to use to read from the database\n+     * @param resolvedParent the resolved parent node\n+     * @param object the {@link com.apple.foundationdb.tuple.Tuple} element for this node\n+     * @return {@code true} if this path stores a record store\n+     */\n+    protected boolean isRecordStoreLeaf(@Nonnull FDBRecordContext context, @Nonnull Resolved resolvedParent, @Nullable Object object) {\n+        return false;\n+    }\n+\n+    /**\n+     * Given a key space path for which {@link #isRecordStoreLeaf} is {@code true}, get the record store's meta-data.\n+     * @param context an open transaction to use to read from the database\n+     * @param resolvedParent the resolved parent node\n+     * @param object the {@link com.apple.foundationdb.tuple.Tuple} element for this node\n+     * @return a future that completes to the record store's meta-data or {@code null}\n+     */\n+    protected CompletableFuture<RecordMetaData> getRecordStoreMetaData(@Nonnull FDBRecordContext context, @Nonnull Resolved resolvedParent, @Nullable Object object) {\n+        return NO_META_DATA;\n+    }\n+\n+    protected CompletableFuture<Resolved> resolvePrimaryKeyField(@Nonnull FDBRecordContext context, @Nonnull Resolved resolvedParent, @Nullable Object object,\n+                                                                 @Nonnull KeyExpression primaryKey, int index) {\n+        List<KeyExpression> keys = primaryKey.normalizeKeyForPositions();\n+        if (index < keys.size()) {\n+            KeyExpression key = keys.get(index);\n+            while (key instanceof NestingKeyExpression) {\n+                key = ((NestingKeyExpression)key).getChild();\n+            }\n+            if (key instanceof FieldKeyExpression) {\n+                return CompletableFuture.completedFuture(new ResolvedPrimaryKeyField(resolvedParent, ((FieldKeyExpression)key).getFieldName(), object, object));\n+            }\n+        }\n+        return UNRESOLVED;\n+    }\n+\n+    protected CompletableFuture<Resolved> resolveIndexField(@Nonnull FDBRecordContext context, @Nonnull Resolved resolvedParent, @Nullable Object object,\n+                                                            @Nonnull Index index, @Nonnull KeyExpression rootExpression, int fieldIndex) {\n+        return UNRESOLVED;", "originalCommit": "48d67b56c07f4ef1c36e363b3ac0fe7e14bcb777", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1Nzc2MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/854#discussion_r394757760", "bodyText": "Absent some new protocol in the factory / maintainer, this class would need to know for each index type how the keys it uses correspond to the root expression.\nFor example, a time-window leaderboard has a leaderboard index before the group starts.\nIs it worth doing for, like, VALUE?", "author": "MMcM", "createdAt": "2020-03-19T02:33:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcyNDY3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc3MjEwNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/854#discussion_r394772105", "bodyText": "I suppose there could be a method on the factory (the maintainer needs a record store and I'm not sure making one from the example path is legit) that returned a list of key expression, defaulting to normalizing the root expression. Aggregate indexes could return just the group and leaderboard could prepend a leaderboard id field.", "author": "MMcM", "createdAt": "2020-03-19T03:34:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcyNDY3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM4MzE4NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/854#discussion_r395383184", "bodyText": "Yeah, I think maybe having a method on the factory is the right choice at some point. I believe there's some possibility that something like that will come out of the planner work, in order to accommodate producing some IR based on the index definition. I could also see us wanting to do VALUE indexes sooner rather than later, but maybe not yet.", "author": "alecgrieser", "createdAt": "2020-03-19T23:58:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcyNDY3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcyNTI1NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/854#discussion_r394725255", "bodyText": "Would it also make sense to have a case INDEX_STATE_SPACE that got the index from the name (instead of the subspace key)? Or do we not want to do that to protect against that changing because of how #514 could be resolved?", "author": "alecgrieser", "createdAt": "2020-03-19T00:44:27Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/clientlog/KeySpaceCountTree.java", "diffHunk": "@@ -83,35 +389,181 @@ protected TupleKeyCountTree newPrefixChild(@Nonnull Object prefix) {\n         }\n     }\n \n-    protected CompletableFuture<Void> resolvePathValue(@Nonnull FDBRecordContext context,\n-                                                       @Nonnull KeySpaceDirectory parentDirectory, @Nullable ResolvedKeySpacePath parentPath) {\n-        if (resolvedPath != null || !hasObject()) {\n+    protected CompletableFuture<Void> resolve(@Nonnull FDBRecordContext context, @Nonnull Resolved resolvedParent) {\n+        if (resolved != null || !hasObject()) {\n             return AsyncUtil.DONE;\n         }\n-        try {\n-            return parentDirectory.findChildForValue(context, parentPath, getObject()).handle((resolved, ex) -> {\n-                if (resolved != null) {\n-                    // Null case includes swallowing async error (ex).\n-                    this.resolvedPath = resolved;\n-                    this.directory = resolved.getDirectory();\n+        return resolve(context, resolvedParent, getObject()).thenAccept(resolved -> {\n+            if (resolved != null) {\n+                this.resolved = resolved;\n+            }\n+        });\n+    }\n+\n+    protected CompletableFuture<Resolved> resolve(@Nonnull FDBRecordContext context, @Nonnull Resolved resolvedParent, @Nullable Object object) {\n+        if (resolvedParent.getDirectory() != null) {\n+            if (resolvedParent.getDirectory().getSubdirectories().isEmpty()) {\n+                if (isRecordStoreLeaf(context, resolvedParent, object)) {\n+                    // The top level keys in a record store use FDBRecordStoreKeyspace.\n+                    FDBRecordStoreKeyspace recordStoreKeyspace;\n+                    if (object == null) {\n+                        // The store header is read with a range scan from the first subkey (Tuple null) to detect various anomalies.\n+                        recordStoreKeyspace = FDBRecordStoreKeyspace.STORE_INFO;\n+                    } else {\n+                        try {\n+                            recordStoreKeyspace = FDBRecordStoreKeyspace.fromKey(object);\n+                        } catch (RecordCoreException ex) {\n+                            return UNRESOLVED;\n+                        }\n+                    }\n+                    if (recordStoreKeyspace != FDBRecordStoreKeyspace.STORE_INFO) {\n+                        return getRecordStoreMetaData(context, resolvedParent, object)\n+                                .thenApply(metaData -> new ResolvedRecordStoreKeyspace(resolvedParent, recordStoreKeyspace, metaData, object));\n+                    } else {\n+                        return CompletableFuture.completedFuture(new ResolvedRecordStoreKeyspace(resolvedParent, recordStoreKeyspace, null, object));\n+                    }\n                 }\n-                return null;\n-            });\n-        } catch (RecordCoreException ex) {\n-            return AsyncUtil.DONE;\n+            } else {\n+                try {\n+                    return resolvedParent.getDirectory().findChildForValue(context, resolvedParent.getResolvedPath(), object).handle((resolved, ex) -> {\n+                        // Null case includes swallowing async error (ex).\n+                        return resolved == null ? null : new ResolvedPath(resolvedParent, resolved);\n+                    });\n+                } catch (RecordCoreException ex) {\n+                    return UNRESOLVED;\n+                }\n+            }\n+        }\n+        return resolveNonDirectory(context, resolvedParent, object);\n+    }\n+\n+    /**\n+     * Resolve something other than a {@link KeySpaceDirectory} node.\n+     * @param context an open transaction to use to read from the database\n+     * @param resolvedParent the resolved parent node\n+     * @param object the {@link com.apple.foundationdb.tuple.Tuple} element for this node\n+     * @return a future that completes to a new {@link Resolved} or {@code null}\n+     */\n+    protected CompletableFuture<Resolved> resolveNonDirectory(@Nonnull FDBRecordContext context, @Nonnull Resolved resolvedParent, @Nullable Object object) {\n+        int distance = 0;\n+        ResolvedRecordStoreKeyspace recordStoreKeyspace = null;\n+        ResolvedRecordTypeKeyspace recordTypeKeyspace = null;\n+        ResolvedIndexKeyspace indexKeyspace = null;\n+        for (Resolved resolved = resolvedParent; resolved != null && resolved.getDirectory() == null; resolved = resolved.getParent()) {\n+            if (resolved instanceof ResolvedRecordTypeKeyspace) {\n+                recordTypeKeyspace = (ResolvedRecordTypeKeyspace)resolved;\n+                break;\n+            }\n+            if (resolved instanceof ResolvedIndexKeyspace) {\n+                indexKeyspace = (ResolvedIndexKeyspace)resolved;\n+                break;\n+            }\n+            if (resolved instanceof ResolvedRecordStoreKeyspace) {\n+                recordStoreKeyspace = (ResolvedRecordStoreKeyspace)resolved;\n+                break;\n+            }\n+            distance++;\n+        }\n+        if (recordStoreKeyspace != null && recordStoreKeyspace.getRecordMetaData() != null) {\n+            switch (recordStoreKeyspace.getRecordStoreKeyspace()) {\n+                case RECORD:\n+                    if (distance == 0 && object != null && recordStoreKeyspace.getRecordMetaData().primaryKeyHasRecordTypePrefix()) {\n+                        final RecordType recordType;\n+                        try {\n+                            recordType = recordStoreKeyspace.getRecordMetaData().getRecordTypeFromRecordTypeKey(object);\n+                        } catch (RecordCoreException ex) {\n+                            break;\n+                        }\n+                        return CompletableFuture.completedFuture(new ResolvedRecordTypeKeyspace(resolvedParent, recordType));\n+                    }\n+                    KeyExpression commonPrimaryKey = recordStoreKeyspace.getRecordMetaData().commonPrimaryKey();\n+                    if (commonPrimaryKey != null && distance < commonPrimaryKey.getColumnSize()) {\n+                        return resolvePrimaryKeyField(context, resolvedParent, object, commonPrimaryKey, distance);\n+                    }\n+                    break;\n+                case INDEX:\n+                case INDEX_SECONDARY_SPACE:\n+                case INDEX_RANGE_SPACE:\n+                case INDEX_UNIQUENESS_VIOLATIONS_SPACE:\n+                case INDEX_BUILD_SPACE:\n+                    if (distance == 0 && object != null) {\n+                        final Index index;\n+                        try {\n+                            index = recordStoreKeyspace.getRecordMetaData().getIndexFromSubspaceKey(object);\n+                        } catch (RecordCoreException ex) {\n+                            break;\n+                        }\n+                        return CompletableFuture.completedFuture(new ResolvedIndexKeyspace(resolvedParent, index));\n+                    }\n+                    break;\n+                default:", "originalCommit": "48d67b56c07f4ef1c36e363b3ac0fe7e14bcb777", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1NzkzMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/854#discussion_r394757933", "bodyText": "Yes. Also, since the current value is the name of the index, resolving it isn't so important. It will display more or less correctly just as an unresolved value.", "author": "MMcM", "createdAt": "2020-03-19T02:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcyNTI1NQ=="}], "type": "inlineReview"}, {"oid": "e8868448f0699c6c8249efd1f0f46187ff650303", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/e8868448f0699c6c8249efd1f0f46187ff650303", "message": "Resolves #852: Enhance KeySpaceCountTree to allow for application-specific resolution", "committedDate": "2020-03-19T02:17:06Z", "type": "commit"}, {"oid": "5be36fdc12d23c7c5a82c523b3393982163c40eb", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/5be36fdc12d23c7c5a82c523b3393982163c40eb", "message": "Update some comments", "committedDate": "2020-03-19T02:30:03Z", "type": "commit"}, {"oid": "5be36fdc12d23c7c5a82c523b3393982163c40eb", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/5be36fdc12d23c7c5a82c523b3393982163c40eb", "message": "Update some comments", "committedDate": "2020-03-19T02:30:03Z", "type": "forcePushed"}, {"oid": "d1da6e9673dfe7bdd57d764f68bfde8f7592fd98", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/d1da6e9673dfe7bdd57d764f68bfde8f7592fd98", "message": "Might need to unwrap CompletionException", "committedDate": "2020-03-19T22:03:22Z", "type": "commit"}]}