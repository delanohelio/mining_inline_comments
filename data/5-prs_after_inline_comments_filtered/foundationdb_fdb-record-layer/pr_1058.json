{"pr_number": 1058, "pr_title": "Resolves #1057: Composed bitmaps from map-like fields", "pr_createdAt": "2020-10-28T21:36:18Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058", "timeline": [{"oid": "5f3b95c7e8d959e0ab0e40b249fe84b30a376cfb", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/5f3b95c7e8d959e0ab0e40b249fe84b30a376cfb", "message": "Allow for partial record with incomplete repeated field for special case of composed bitmap.", "committedDate": "2020-10-28T21:37:41Z", "type": "forcePushed"}, {"oid": "d2eded10aabf538655393dfdf4a976ccd368f8b4", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/d2eded10aabf538655393dfdf4a976ccd368f8b4", "message": "Allow for partial record with incomplete repeated field for special case of composed bitmap.", "committedDate": "2020-10-29T19:35:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU3MDgyMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r514570823", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                                               @Nonnull KeyExpression indexExpr, Boolean allowRepeated) {\n          \n          \n            \n                                                                               @Nonnull KeyExpression indexExpr, boolean allowRepeated) {\n          \n      \n    \n    \n  \n\nUnless I'm missing something and there's a reason why this needs to be a Boolean object.", "author": "alecgrieser", "createdAt": "2020-10-29T21:12:26Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -1527,6 +1528,12 @@ public RecordQueryCoveringIndexPlan planCoveringAggregateIndex(@Nonnull RecordQu\n \n     @Nullable\n     public RecordQueryCoveringIndexPlan planCoveringAggregateIndex(@Nonnull RecordQuery query, @Nonnull Index index, @Nonnull KeyExpression indexExpr) {\n+        return planCoveringAggregateIndex(query, index, indexExpr, false);\n+    }\n+\n+    @Nullable\n+    public RecordQueryCoveringIndexPlan planCoveringAggregateIndex(@Nonnull RecordQuery query, @Nonnull Index index,\n+                                                                   @Nonnull KeyExpression indexExpr, Boolean allowRepeated) {", "originalCommit": "d2eded10aabf538655393dfdf4a976ccd368f8b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYxNTk3NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r514615974", "bodyText": "There's something about this where it seems like the right thing is to have a key expression or something like a key expression that means \"one entry from a repeated field\" to avoid having a Boolean special case, but I suppose that's a much larger discussion. cc @normen662", "author": "alecgrieser", "createdAt": "2020-10-29T23:02:34Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/IndexKeyValueToPartialRecord.java", "diffHunk": "@@ -298,16 +303,20 @@ public void addRequiredMessageFields() {\n          * @return whether this is a valid use\n          */\n         public boolean isValid() {\n+            return isValid(false);\n+        }\n+\n+        public boolean isValid(boolean allowRepeated) {", "originalCommit": "d2eded10aabf538655393dfdf4a976ccd368f8b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0NzI0MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r514647241", "bodyText": "I'm not sure how a new key expression might be used, since as things stand no new types are introduced.\nI think the \"right thing\" is to have dynamic row types so that it isn't necessary to impersonate the record with varying degrees of fidelity. Maybe that's the same thing.", "author": "MMcM", "createdAt": "2020-10-30T00:50:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYxNTk3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI4MzMxOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r515283318", "bodyText": "Yeah, I think maybe by \"key expression\", I should have said, like, \"query expression\", so that you can say that you want back in your required results the \"matching\" entry from some nested expression, if that makes sense. I think something similar was discussed before, when discussing how to better expression more complicated queries.\nIn any case, not something for this PR or to block this PR on.", "author": "alecgrieser", "createdAt": "2020-10-30T17:56:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYxNTk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYyMjc0Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r514622743", "bodyText": "Can this still end up splicing up a nested concat? I'm thinking of something like if groupKey.getGroupedCount() == 2 and groupKey is something like concat(nest(a, concat(b, c)), d)?", "author": "alecgrieser", "createdAt": "2020-10-29T23:22:53Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexAggregate.java", "diffHunk": "@@ -319,9 +321,26 @@ private static boolean separateGroupFilters(@Nonnull QueryComponent filter,\n                 return Optional.empty();\n             }\n             // Splice the index's key between the common grouping key and the position.\n-            GroupingKeyExpression groupKeyExpression = (GroupingKeyExpression)indexAggregateFunction.getOperand();\n-            GroupingKeyExpression fullKey = Key.Expressions.concat(groupKeyExpression.getGroupingSubKey(), indexKey, groupKeyExpression.getGroupedSubKey())\n-                    .group(groupKeyExpression.getGroupedCount());\n+            // The simplest place is directly before the position.\n+            // But if part of the group is a nested concat, breaking that up would need support in QueryToKeyMatcher.\n+            // Moreover, the caller needs to have arranged for a compatible index to exist, which requires new support.\n+            // (https://github.com/FoundationDB/fdb-record-layer/issues/1056)\n+            final GroupingKeyExpression groupKey = (GroupingKeyExpression)indexAggregateFunction.getOperand();\n+            int lastKeySize = 1;\n+            if (groupKey.getWholeKey() instanceof ThenKeyExpression) {\n+                ThenKeyExpression thenKey = (ThenKeyExpression)groupKey.getWholeKey();\n+                lastKeySize = thenKey.getChildren().get(thenKey.getChildren().size() - 1).getColumnSize();\n+            }\n+            final ThenKeyExpression splicedKey;\n+            if (lastKeySize > groupKey.getGroupedCount()) {", "originalCommit": "d2eded10aabf538655393dfdf4a976ccd368f8b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0NjEyMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r514646120", "bodyText": "The new version will always take whole children of a Then. So that it would have to go after a.", "author": "MMcM", "createdAt": "2020-10-30T00:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYyMjc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYyNTE0Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r514625142", "bodyText": "It's a little unclear to me why this is a legal transformation. Why is it okay if some of the grouping columns from the operand end up in the grouped columns?", "author": "alecgrieser", "createdAt": "2020-10-29T23:30:24Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexAggregate.java", "diffHunk": "@@ -319,9 +321,26 @@ private static boolean separateGroupFilters(@Nonnull QueryComponent filter,\n                 return Optional.empty();\n             }\n             // Splice the index's key between the common grouping key and the position.\n-            GroupingKeyExpression groupKeyExpression = (GroupingKeyExpression)indexAggregateFunction.getOperand();\n-            GroupingKeyExpression fullKey = Key.Expressions.concat(groupKeyExpression.getGroupingSubKey(), indexKey, groupKeyExpression.getGroupedSubKey())\n-                    .group(groupKeyExpression.getGroupedCount());\n+            // The simplest place is directly before the position.\n+            // But if part of the group is a nested concat, breaking that up would need support in QueryToKeyMatcher.\n+            // Moreover, the caller needs to have arranged for a compatible index to exist, which requires new support.\n+            // (https://github.com/FoundationDB/fdb-record-layer/issues/1056)\n+            final GroupingKeyExpression groupKey = (GroupingKeyExpression)indexAggregateFunction.getOperand();\n+            int lastKeySize = 1;\n+            if (groupKey.getWholeKey() instanceof ThenKeyExpression) {\n+                ThenKeyExpression thenKey = (ThenKeyExpression)groupKey.getWholeKey();\n+                lastKeySize = thenKey.getChildren().get(thenKey.getChildren().size() - 1).getColumnSize();\n+            }\n+            final ThenKeyExpression splicedKey;\n+            if (lastKeySize > groupKey.getGroupedCount()) {\n+                final KeyExpression wholeKey = groupKey.getWholeKey();\n+                final int wholeSize = wholeKey.getColumnSize();\n+                final int splicePoint = wholeSize - lastKeySize;\n+                splicedKey = Key.Expressions.concat(wholeKey.getSubKey(0, splicePoint), indexKey, wholeKey.getSubKey(splicePoint, wholeSize));", "originalCommit": "d2eded10aabf538655393dfdf4a976ccd368f8b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzNTkxMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r514635910", "bodyText": "The grouped count of fullKey does not change.\nIt should be that the splice is always in the grouping columns.\nLet me try to write this in a way that is more clear.", "author": "MMcM", "createdAt": "2020-10-30T00:06:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYyNTE0Mg=="}], "type": "inlineReview"}, {"oid": "13751c65b927a3c26cdda850809c48d41ed2ed78", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/13751c65b927a3c26cdda850809c48d41ed2ed78", "message": "Don't pick a splice point in the middle of a nested concat.", "committedDate": "2020-10-29T23:56:26Z", "type": "commit"}, {"oid": "48f7943940bf99689cc8292a04a2233c56e7764b", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/48f7943940bf99689cc8292a04a2233c56e7764b", "message": "Allow for partial record with incomplete repeated field for special case of composed bitmap.", "committedDate": "2020-10-29T23:56:26Z", "type": "commit"}, {"oid": "815940a91a2c94773501424eaf0e8c058fcdd604", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/815940a91a2c94773501424eaf0e8c058fcdd604", "message": "Update fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java\n\nCo-authored-by: Alec Grieser <alloc@apple.com>", "committedDate": "2020-10-29T23:56:26Z", "type": "commit"}, {"oid": "630dffad8e1bb085047ab4b927b6b223403caf0f", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/630dffad8e1bb085047ab4b927b6b223403caf0f", "message": "Redo splicing to always take whole children, no matter how many", "committedDate": "2020-10-30T00:45:42Z", "type": "commit"}, {"oid": "630dffad8e1bb085047ab4b927b6b223403caf0f", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/630dffad8e1bb085047ab4b927b6b223403caf0f", "message": "Redo splicing to always take whole children, no matter how many", "committedDate": "2020-10-30T00:45:42Z", "type": "forcePushed"}, {"oid": "13c6c329dc0688ae8c861e15077262bc6f5fff3e", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/13c6c329dc0688ae8c861e15077262bc6f5fff3e", "message": "Add a test case that shows complex splicing", "committedDate": "2020-10-30T02:49:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIxNzg4NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r515217885", "bodyText": "Probably should call fail() rather than creating an IllegalStateException as a more idiomatic way to indicate test failure.", "author": "alecgrieser", "createdAt": "2020-10-30T16:20:13Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/indexes/BitmapValueIndexTest.java", "diffHunk": "@@ -483,9 +488,65 @@ public void nonOverlappingOrQuery() {\n         }\n     }\n \n-    protected static final KeyExpression REC_NO_BY_STR = concatenateFields(\"str_value_indexed\", \"rec_no\").group(1);\n-    protected static final KeyExpression REC_NO_BY_STR_NUM2 = concatenateFields(\"str_value_indexed\", \"num_value_2\", \"rec_no\").group(1);\n-    protected static final KeyExpression REC_NO_BY_STR_NUM3 = concatenateFields(\"str_value_indexed\", \"num_value_3_indexed\", \"rec_no\").group(1);\n+    @Test\n+    public void nestedAndQuery() {\n+        final KeyExpression num_by_str = field(\"nested\").nest(field(\"entry\", FanOut).nest(concatenateFields(\"str_value\", \"num_value\")));\n+        final KeyExpression nested_num_by_str = concat(field(\"num_value_1\"), num_by_str).group(1);\n+        final KeyExpression nested_num_by_str_num2 = concat(field(\"num_value_1\"), field(\"num_value_2\"), num_by_str).group(1);\n+        final KeyExpression nested_num_by_str_num3 = concat(field(\"num_value_1\"), field(\"num_value_3\"), num_by_str).group(1);\n+        final RecordMetaDataHook nested_rec_no_by_str_nums_hook = metadata -> {\n+            final RecordTypeBuilder recordType = metadata.getRecordType(\"MyNestedRecord\");\n+            metadata.addIndex(recordType, new Index(\"nested_num_by_str_num2\", nested_num_by_str_num2, IndexTypes.BITMAP_VALUE, SMALL_BITMAP_OPTIONS));\n+            metadata.addIndex(recordType, new Index(\"nested_num_by_str_num3\", nested_num_by_str_num3, IndexTypes.BITMAP_VALUE, SMALL_BITMAP_OPTIONS));\n+        };\n+        final IndexAggregateFunction bitmap_value_nested_num_by_str = new IndexAggregateFunction(FunctionNames.BITMAP_VALUE, nested_num_by_str, null);\n+        try (FDBRecordContext context = openContext()) {\n+            createOrOpenRecordStore(context, metaData(nested_rec_no_by_str_nums_hook));\n+            for (int recNo = 100; recNo < 200; recNo++) {\n+                recordStore.saveRecord(TestRecordsBitmapProto.MyNestedRecord.newBuilder()\n+                        .setRecNo(recNo)\n+                        .setNumValue1(1)\n+                        .setNested(TestRecordsBitmapProto.MyNestedRecord.Nested.newBuilder()\n+                                .addEntry(TestRecordsBitmapProto.MyNestedRecord.Nested.Entry.newBuilder()\n+                                        .setStrValue((recNo & 1) == 1 ? \"odd\" : \"even\")\n+                                        .setNumValue(recNo + 1000)))\n+                        .setNumValue2(recNo % 7)\n+                        .setNumValue3(recNo % 5)\n+                        .build());\n+            }\n+            commit(context);\n+        }\n+        try (FDBRecordContext context = openContext()) {\n+            createOrOpenRecordStore(context, metaData(nested_rec_no_by_str_nums_hook));\n+            setupPlanner(null);\n+            final RecordQuery recordQuery = RecordQuery.newBuilder()\n+                    .setRecordType(\"MyNestedRecord\")\n+                    .setFilter(Query.and(\n+                            Query.field(\"num_value_1\").equalsValue(1),\n+                            Query.field(\"nested\").matches(Query.field(\"entry\").oneOfThem().matches(Query.field(\"str_value\").equalsValue(\"odd\"))),\n+                            Query.field(\"num_value_2\").equalsValue(3),\n+                            Query.field(\"num_value_3\").equalsValue(4)))\n+                    .setRequiredResults(Collections.singletonList(field(\"nested\").nest(field(\"entry\", FanOut).nest(\"num_value\"))))\n+                    .build();\n+            final RecordQueryPlan queryPlan =  ComposedBitmapIndexAggregate.tryPlan((RecordQueryPlanner)planner, recordQuery, bitmap_value_nested_num_by_str)\n+                    .orElseThrow(() -> new IllegalStateException(\"Cannot plan query\"));", "originalCommit": "13c6c329dc0688ae8c861e15077262bc6f5fff3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM0NDY2NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r515344664", "bodyText": "Yes, that makes sense.", "author": "MMcM", "createdAt": "2020-10-30T19:53:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIxNzg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIxOTEwMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r515219102", "bodyText": "If the required results also included the str_value field, would this still plan? And should it? (I assume if it returns, the str_value associated with each bitmap array?) Similarly, if this were missing the predicate on str_value but it were present in the required results, would it return results grouped together by str_value?", "author": "alecgrieser", "createdAt": "2020-10-30T16:22:16Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/indexes/BitmapValueIndexTest.java", "diffHunk": "@@ -483,9 +488,65 @@ public void nonOverlappingOrQuery() {\n         }\n     }\n \n-    protected static final KeyExpression REC_NO_BY_STR = concatenateFields(\"str_value_indexed\", \"rec_no\").group(1);\n-    protected static final KeyExpression REC_NO_BY_STR_NUM2 = concatenateFields(\"str_value_indexed\", \"num_value_2\", \"rec_no\").group(1);\n-    protected static final KeyExpression REC_NO_BY_STR_NUM3 = concatenateFields(\"str_value_indexed\", \"num_value_3_indexed\", \"rec_no\").group(1);\n+    @Test\n+    public void nestedAndQuery() {\n+        final KeyExpression num_by_str = field(\"nested\").nest(field(\"entry\", FanOut).nest(concatenateFields(\"str_value\", \"num_value\")));\n+        final KeyExpression nested_num_by_str = concat(field(\"num_value_1\"), num_by_str).group(1);\n+        final KeyExpression nested_num_by_str_num2 = concat(field(\"num_value_1\"), field(\"num_value_2\"), num_by_str).group(1);\n+        final KeyExpression nested_num_by_str_num3 = concat(field(\"num_value_1\"), field(\"num_value_3\"), num_by_str).group(1);\n+        final RecordMetaDataHook nested_rec_no_by_str_nums_hook = metadata -> {\n+            final RecordTypeBuilder recordType = metadata.getRecordType(\"MyNestedRecord\");\n+            metadata.addIndex(recordType, new Index(\"nested_num_by_str_num2\", nested_num_by_str_num2, IndexTypes.BITMAP_VALUE, SMALL_BITMAP_OPTIONS));\n+            metadata.addIndex(recordType, new Index(\"nested_num_by_str_num3\", nested_num_by_str_num3, IndexTypes.BITMAP_VALUE, SMALL_BITMAP_OPTIONS));\n+        };\n+        final IndexAggregateFunction bitmap_value_nested_num_by_str = new IndexAggregateFunction(FunctionNames.BITMAP_VALUE, nested_num_by_str, null);\n+        try (FDBRecordContext context = openContext()) {\n+            createOrOpenRecordStore(context, metaData(nested_rec_no_by_str_nums_hook));\n+            for (int recNo = 100; recNo < 200; recNo++) {\n+                recordStore.saveRecord(TestRecordsBitmapProto.MyNestedRecord.newBuilder()\n+                        .setRecNo(recNo)\n+                        .setNumValue1(1)\n+                        .setNested(TestRecordsBitmapProto.MyNestedRecord.Nested.newBuilder()\n+                                .addEntry(TestRecordsBitmapProto.MyNestedRecord.Nested.Entry.newBuilder()\n+                                        .setStrValue((recNo & 1) == 1 ? \"odd\" : \"even\")\n+                                        .setNumValue(recNo + 1000)))\n+                        .setNumValue2(recNo % 7)\n+                        .setNumValue3(recNo % 5)\n+                        .build());\n+            }\n+            commit(context);\n+        }\n+        try (FDBRecordContext context = openContext()) {\n+            createOrOpenRecordStore(context, metaData(nested_rec_no_by_str_nums_hook));\n+            setupPlanner(null);\n+            final RecordQuery recordQuery = RecordQuery.newBuilder()\n+                    .setRecordType(\"MyNestedRecord\")\n+                    .setFilter(Query.and(\n+                            Query.field(\"num_value_1\").equalsValue(1),\n+                            Query.field(\"nested\").matches(Query.field(\"entry\").oneOfThem().matches(Query.field(\"str_value\").equalsValue(\"odd\"))),\n+                            Query.field(\"num_value_2\").equalsValue(3),\n+                            Query.field(\"num_value_3\").equalsValue(4)))\n+                    .setRequiredResults(Collections.singletonList(field(\"nested\").nest(field(\"entry\", FanOut).nest(\"num_value\"))))", "originalCommit": "13c6c329dc0688ae8c861e15077262bc6f5fff3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM0NTUxNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r515345514", "bodyText": "Adding str_value is fine; the partial record has an entry with both -- which doesn't matter much, since we just get the index entry directly.\nRemoving the condition and expecting a rollup is sensible, but does not work with the code today. Specifically, it fails separateGroupFilters as not matching the bitmap_value operand.", "author": "MMcM", "createdAt": "2020-10-30T19:55:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIxOTEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM4MzAwMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r515383002", "bodyText": "Okay, sounds good. I suppose at some point, we may care about roll up, but that sounds fine for now.", "author": "alecgrieser", "createdAt": "2020-10-30T21:06:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIxOTEwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMwMTU5OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r515301598", "bodyText": "Okay, it took me a while to refamiliarize myself with this code, but I think I understand now the basic approach here.\nThis part of the code is essentially trying out different candidate grouping expressions to match each predicate and seeing if a particular index matching that expression exists. So the important invariant is that the grouped key remains the same (and this does that), and then the grouping keys can be changed kind of at will. So, I think I understand how this works, I think.\nI guess the remaining question is that it seems like the grouping key order shouldn't really matter (at least for the keys with equality predicates), and that we \"should\" be able to just place the indexKey at the beginning of the expression. But I'd also buy that the planner isn't quite sophisticated enough for that (yet?).", "author": "alecgrieser", "createdAt": "2020-10-30T18:31:20Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexAggregate.java", "diffHunk": "@@ -319,9 +321,37 @@ private static boolean separateGroupFilters(@Nonnull QueryComponent filter,\n                 return Optional.empty();\n             }\n             // Splice the index's key between the common grouping key and the position.\n-            GroupingKeyExpression groupKeyExpression = (GroupingKeyExpression)indexAggregateFunction.getOperand();\n-            GroupingKeyExpression fullKey = Key.Expressions.concat(groupKeyExpression.getGroupingSubKey(), indexKey, groupKeyExpression.getGroupedSubKey())\n-                    .group(groupKeyExpression.getGroupedCount());\n+            // The simplest place is directly before the position.\n+            // But if part of the group is a nested concat, breaking that up would need support in QueryToKeyMatcher.\n+            // Moreover, the caller needs to have arranged for a compatible index to exist, which requires new support to define.\n+            // (https://github.com/FoundationDB/fdb-record-layer/issues/1056)\n+            final GroupingKeyExpression groupKey = (GroupingKeyExpression)indexAggregateFunction.getOperand();\n+            final int groupedCount = groupKey.getGroupedCount();\n+            final int wholeCount = groupKey.getColumnSize();\n+            int afterSpliceCount = groupedCount;\n+            if (groupKey.getWholeKey() instanceof ThenKeyExpression) {\n+                final List<KeyExpression> thenChildren = ((ThenKeyExpression)groupKey.getWholeKey()).getChildren();\n+                int childPosition = thenChildren.size();\n+                // Compute the minimum number that includes all grouped fields and keeps involved children intact.\n+                afterSpliceCount = 0;\n+                while (afterSpliceCount < groupedCount) {\n+                    afterSpliceCount += thenChildren.get(--childPosition).getColumnSize();\n+                }\n+            }\n+            final ThenKeyExpression splicedKey;\n+            if (afterSpliceCount == groupedCount) {\n+                // Preferred position at end of grouping keys.\n+                splicedKey = Key.Expressions.concat(groupKey.getGroupingSubKey(), indexKey, groupKey.getGroupedSubKey());\n+            } else {\n+                final KeyExpression wholeKey = groupKey.getWholeKey();\n+                final int splicePoint = wholeCount - afterSpliceCount;\n+                if (splicePoint == 0) {\n+                    splicedKey = Key.Expressions.concat(indexKey, wholeKey);\n+                } else {\n+                    splicedKey = Key.Expressions.concat(wholeKey.getSubKey(0, splicePoint), indexKey, wholeKey.getSubKey(splicePoint, wholeCount));\n+                }\n+            }\n+            GroupingKeyExpression fullKey = splicedKey.group(groupedCount);", "originalCommit": "13c6c329dc0688ae8c861e15077262bc6f5fff3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM4MzExMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r515383112", "bodyText": "Yes, given some more code here and a somewhat smarter planner, there is no fundamental reason it could not hunt around for an index some some permutation of the equality constraints. But today it just opts for a workable canonical form, which is as far to the right as possible without splitting.", "author": "MMcM", "createdAt": "2020-10-30T21:06:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMwMTU5OA=="}], "type": "inlineReview"}, {"oid": "9823547308649a40ba9d24198afe83f72b5595e0", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/9823547308649a40ba9d24198afe83f72b5595e0", "message": "Use `fail` instead", "committedDate": "2020-10-30T19:39:10Z", "type": "commit"}]}