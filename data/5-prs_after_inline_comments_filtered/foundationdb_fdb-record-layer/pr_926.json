{"pr_number": 926, "pr_title": "Resolves #925: Add assertions into record layer", "pr_createdAt": "2020-04-29T18:32:58Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/926", "timeline": [{"oid": "d1795eb6744adbc752c66e45db3835d86362a9f5", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/d1795eb6744adbc752c66e45db3835d86362a9f5", "message": "Resolves #925: Add assertions into record layer\n\nThis change allows `FDBDatabaseFactory` to be configured with a supplier which\ncan decide whether or not assertions are to be enabled within the record layer\nAPI.  This supplier is polled each time an `FDBRecordContext` is created and,\nthus, all operations from the context will have assertions checked (or not)\nas it is used.  The initial set of assertions are around validating key and\nvalue byte sizes.", "committedDate": "2020-04-30T15:36:15Z", "type": "forcePushed"}, {"oid": "86d0a370b042d78f892aa8898d8dc7fa3f1b1e90", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/86d0a370b042d78f892aa8898d8dc7fa3f1b1e90", "message": "Resolves #925: Add assertions into record layer\n\nThis change allows `FDBDatabaseFactory` to be configured with a supplier which\ncan decide whether or not assertions are to be enabled within the record layer\nAPI.  This supplier is polled each time an `FDBRecordContext` is created and,\nthus, all operations from the context will have assertions checked (or not)\nas it is used.  The initial set of assertions are around validating key and\nvalue byte sizes.", "committedDate": "2020-04-30T19:26:25Z", "type": "commit"}, {"oid": "86d0a370b042d78f892aa8898d8dc7fa3f1b1e90", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/86d0a370b042d78f892aa8898d8dc7fa3f1b1e90", "message": "Resolves #925: Add assertions into record layer\n\nThis change allows `FDBDatabaseFactory` to be configured with a supplier which\ncan decide whether or not assertions are to be enabled within the record layer\nAPI.  This supplier is polled each time an `FDBRecordContext` is created and,\nthus, all operations from the context will have assertions checked (or not)\nas it is used.  The initial set of assertions are around validating key and\nvalue byte sizes.", "committedDate": "2020-04-30T19:26:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM0ODE3Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/926#discussion_r418348176", "bodyText": "Hmm, I'm not sure this is necessarily the best way to determine whether or not to enable assertions or not. In particular, it wouldn't let you do something like set it for a single transaction (if, for example, if one wanted to turn on \"debugging\" for a single transaction that both, like, traced it and enabled assertions). Like, the other mechanism I can think of would be to add a new field to the FDBRecordContextConfig (and, in theory, one could want that for tracing). I suppose it's possible that we could go with this \"for now\", see how it goes, and add a new mechanism, if we don't like the way that that works in practice.", "author": "alecgrieser", "createdAt": "2020-04-30T23:39:07Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBDatabaseFactory.java", "diffHunk": "@@ -121,6 +122,13 @@\n      */\n     @Nonnull\n     private Supplier<Boolean> transactionIsTracedSupplier = LOGGER::isTraceEnabled;\n+    /**\n+     * A supplier that, when it returns true, enables assertions/sanity checks on certain operations. This supplier is\n+     * polled upon the creation of a new {@code FDBRecordContext} and all subsequent operations on that context will\n+     * (or will not) enforce assertions based upon the return value.\n+     */\n+    @Nonnull\n+    private Supplier<Boolean> enableAssertionsSupplier = DEFAULT_ENABLE_ASSERTIONS_SUPPLIER;", "originalCommit": "86d0a370b042d78f892aa8898d8dc7fa3f1b1e90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1NzIzMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/926#discussion_r418557233", "bodyText": "Yeah, you are absolutely right. I had forgotten about that object. I have moved the configuration there.", "author": "scgray", "createdAt": "2020-05-01T14:10:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM0ODE3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM0ODY5NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/926#discussion_r418348694", "bodyText": "A new FDBStoreTimer is a little bit of a weird choice if StoreTimer is null, rather than sending null down to the InstrumentedTransaction (and, um, I guess not instrumenting it). Maybe it's preferable to introducing possible NPEs from that class, though? Not sure.", "author": "alecgrieser", "createdAt": "2020-04-30T23:40:57Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBDatabase.java", "diffHunk": "@@ -748,10 +748,13 @@ public Transaction createTransaction(Executor executor, @Nullable Map<String, St\n      * @return newly created transaction\n      */\n     private Transaction createTransaction(Executor executor, @Nullable StoreTimer storeTimer, @Nullable Map<String, String> mdcContext, boolean transactionIsTraced) {\n+        final boolean enableAssertions = factory.areAssertionsEnabled();\n         Transaction transaction = database.createTransaction(executor);\n \n         if (storeTimer != null) {\n-            transaction = new InstrumentedTransaction(storeTimer, transaction);\n+            transaction = new InstrumentedTransaction(storeTimer, transaction, enableAssertions);\n+        } else if (enableAssertions) {\n+            transaction = new InstrumentedTransaction(new FDBStoreTimer(), transaction, enableAssertions);", "originalCommit": "86d0a370b042d78f892aa8898d8dc7fa3f1b1e90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1NzAzMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/926#discussion_r418557033", "bodyText": "Yeah, it just bothers me that we have this log everywhere of if (storeTimer != null).  I took at stab at creating a NullStoreTimer implementation so we can enforce that it is never nullable, but it gets into problems because it doesn't really extend into NullFDBStoreTimer. Anyway, I updated this to allow for null :(", "author": "scgray", "createdAt": "2020-05-01T14:09:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM0ODY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1MDc0OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/926#discussion_r418350749", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    underlying.mutate(opType, checkKey(key), param);\n          \n          \n            \n                    underlying.mutate(opType, checkKey(key), checkValue(param));", "author": "alecgrieser", "createdAt": "2020-04-30T23:48:08Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/InstrumentedTransaction.java", "diffHunk": "@@ -38,70 +39,74 @@\n  * Wrapper around {@link Transaction} that instruments certain calls to expose their behavior with\n  * {@link FDBStoreTimer} metrics.\n  */\n+@API(API.Status.INTERNAL)\n public class InstrumentedTransaction extends InstrumentedReadTransaction<Transaction> implements Transaction {\n \n     @Nullable\n     protected ReadTransaction snapshot; // lazily cached snapshot wrapper\n \n-    public InstrumentedTransaction(@Nonnull StoreTimer timer, @Nonnull Transaction underlying) {\n-        super(timer, underlying);\n+    public InstrumentedTransaction(@Nonnull StoreTimer timer, @Nonnull Transaction underlying, boolean enableAssertions) {\n+        super(timer, underlying, enableAssertions);\n     }\n \n     @Override\n     public void addReadConflictRange(byte[] keyBegin, byte[] keyEnd) {\n-        underlying.addReadConflictRange(keyBegin, keyEnd);\n+        underlying.addReadConflictRange(checkKey(keyBegin), checkKey(keyEnd));\n     }\n \n     @Override\n     public void addReadConflictKey(byte[] key) {\n-        underlying.addReadConflictKey(key);\n+        underlying.addReadConflictKey(checkKey(key));\n     }\n \n     @Override\n     public void addWriteConflictRange(byte[] keyBegin, byte[] keyEnd) {\n-        underlying.addWriteConflictRange(keyBegin, keyEnd);\n+        underlying.addWriteConflictRange(checkKey(keyBegin), checkKey(keyEnd));\n     }\n \n     @Override\n     public void addWriteConflictKey(byte[] key) {\n-        underlying.addWriteConflictKey(key);\n+        underlying.addWriteConflictKey(checkKey(key));\n     }\n \n     @Override\n     public void set(byte[] key, byte[] value) {\n-        underlying.set(key, value);\n+        underlying.set(checkKey(key), checkValue(value));\n         timer.increment(FDBStoreTimer.Counts.WRITES);\n         timer.increment(FDBStoreTimer.Counts.BYTES_WRITTEN, key.length + value.length);\n     }\n \n     @Override\n     public void clear(byte[] key) {\n-        underlying.clear(key);\n+        underlying.clear(checkKey(key));\n         timer.increment(FDBStoreTimer.Counts.DELETES);\n     }\n \n     @Override\n     public void clear(byte[] keyBegin, byte[] keyEnd) {\n-        underlying.clear(keyBegin, keyEnd);\n+        underlying.clear(checkKey(keyBegin), checkKey(keyEnd));\n         timer.increment(FDBStoreTimer.Counts.DELETES);\n     }\n \n     @Override\n     public void clear(Range range) {\n+        checkKey(range.begin);\n+        checkKey(range.end);\n+\n         underlying.clear(range);\n         timer.increment(FDBStoreTimer.Counts.DELETES);\n     }\n \n     @Override\n     @Deprecated\n     public void clearRangeStartsWith(byte[] prefix) {\n-        underlying.clearRangeStartsWith(prefix);\n+        underlying.clearRangeStartsWith(checkKey(prefix));\n         timer.increment(FDBStoreTimer.Counts.DELETES);\n     }\n \n     @Override\n     public void mutate(MutationType opType, byte[] key, byte[] param) {\n-        underlying.mutate(opType, key, param);\n+        underlying.mutate(opType, checkKey(key), param);", "originalCommit": "86d0a370b042d78f892aa8898d8dc7fa3f1b1e90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1MTA0NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/926#discussion_r418351045", "bodyText": "Technically, the versionstamp operations can shrink the key and value sizes, and...I'm not actually sure whether a 100,004 byte value where the last four bytes are a versionstamp offset as part of a SET_VERSIONSTAMPED_VALUE operation are actually allowed.", "author": "alecgrieser", "createdAt": "2020-04-30T23:49:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1MDc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1MTI3Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/926#discussion_r418351277", "bodyText": "AFAICT, key and value size limits are only imposed on set operations (and mutate). I think clear, clear range, the conflict range operations, and the read operations actually allow larger keys. I've validated this by playing around with the Python API in its shell, but maybe it's worth getting better validation.", "author": "alecgrieser", "createdAt": "2020-04-30T23:49:51Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/InstrumentedTransaction.java", "diffHunk": "@@ -38,70 +39,74 @@\n  * Wrapper around {@link Transaction} that instruments certain calls to expose their behavior with\n  * {@link FDBStoreTimer} metrics.\n  */\n+@API(API.Status.INTERNAL)\n public class InstrumentedTransaction extends InstrumentedReadTransaction<Transaction> implements Transaction {\n \n     @Nullable\n     protected ReadTransaction snapshot; // lazily cached snapshot wrapper\n \n-    public InstrumentedTransaction(@Nonnull StoreTimer timer, @Nonnull Transaction underlying) {\n-        super(timer, underlying);\n+    public InstrumentedTransaction(@Nonnull StoreTimer timer, @Nonnull Transaction underlying, boolean enableAssertions) {\n+        super(timer, underlying, enableAssertions);\n     }\n \n     @Override\n     public void addReadConflictRange(byte[] keyBegin, byte[] keyEnd) {\n-        underlying.addReadConflictRange(keyBegin, keyEnd);\n+        underlying.addReadConflictRange(checkKey(keyBegin), checkKey(keyEnd));\n     }\n \n     @Override\n     public void addReadConflictKey(byte[] key) {\n-        underlying.addReadConflictKey(key);\n+        underlying.addReadConflictKey(checkKey(key));\n     }\n \n     @Override\n     public void addWriteConflictRange(byte[] keyBegin, byte[] keyEnd) {\n-        underlying.addWriteConflictRange(keyBegin, keyEnd);\n+        underlying.addWriteConflictRange(checkKey(keyBegin), checkKey(keyEnd));\n     }\n \n     @Override\n     public void addWriteConflictKey(byte[] key) {\n-        underlying.addWriteConflictKey(key);\n+        underlying.addWriteConflictKey(checkKey(key));\n     }\n \n     @Override\n     public void set(byte[] key, byte[] value) {\n-        underlying.set(key, value);\n+        underlying.set(checkKey(key), checkValue(value));", "originalCommit": "86d0a370b042d78f892aa8898d8dc7fa3f1b1e90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1NzUxOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/926#discussion_r418557519", "bodyText": "But, just because you can, should you?  Is there a case where this is legitimate and the server can make sense of the trailing bytes?", "author": "scgray", "createdAt": "2020-05-01T14:10:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1MTI3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYwMjAyNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/926#discussion_r418602024", "bodyText": "There's one only mediumly contrived example that I can think of right now: if you have a key of exactly 10k bytes, and you want to get the next key in the database, you might perform a scan from key + \\x00, which would have length 10,001. In theory, if you had the right logic, you can notice that it's hit the limit and only scan from key[:9999] + str(key[9999] + 1) (or something like that)", "author": "alecgrieser", "createdAt": "2020-05-01T15:49:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1MTI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1MTc5Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/926#discussion_r418351792", "bodyText": "Seems like this should set it to the original asserterions supplier instead of () -> false. At the moment, those are the same same thing, but if we ever started running our tests with assertions on for everything (for example), I don't think we'd want this test to mess with that.", "author": "alecgrieser", "createdAt": "2020-04-30T23:51:37Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/FDBDatabaseTest.java", "diffHunk": "@@ -489,4 +489,42 @@ public void performNoOpAgainstFakeCluster() throws IOException {\n             LOGGER.info(logMessage.toString());\n         }\n     }\n+\n+    @Test\n+    public void testAssertionsOnKeySize() {\n+        testSizeAssertion(context ->\n+                        context.ensureActive().set(Tuple.from(1, new byte[InstrumentedTransaction.MAX_KEY_LENGTH]).pack(), Tuple.from(1).pack()),\n+                FDBExceptions.FDBStoreKeySizeException.class);\n+    }\n+\n+    @Test\n+    public void testAssertionsOnValueSize() {\n+        testSizeAssertion(context ->\n+                        context.ensureActive().set(Tuple.from(1).pack(), Tuple.from(2, new byte[InstrumentedTransaction.MAX_VALUE_LENGTH]).pack()),\n+                FDBExceptions.FDBStoreValueSizeException.class);\n+    }\n+\n+    private void testSizeAssertion(Consumer<FDBRecordContext> consumer, Class<? extends Exception> exception) {\n+        FDBDatabaseFactory factory = FDBDatabaseFactory.instance();\n+        FDBDatabase database = factory.getDatabase();\n+\n+        // By default key size validation happens in the FDB driver at commit time\n+        try (FDBRecordContext context = database.openContext()) {\n+            consumer.accept(context);\n+            assertThrows(exception, () -> context.commit());\n+        }\n+\n+        try {\n+            factory.clear();\n+\n+            // enabling assertions causes checks to happen in record layer code\n+            factory.setEnableAssertionsSupplier(() -> true);\n+            try (FDBRecordContext context = database.openContext()) {\n+                assertThrows(exception, () -> consumer.accept(context));\n+            }\n+        } finally {\n+            factory.setEnableAssertionsSupplier(() -> false);", "originalCommit": "86d0a370b042d78f892aa8898d8dc7fa3f1b1e90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1NzgwMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/926#discussion_r418557803", "bodyText": "Good point, but I removed this manner of configuration anyway.", "author": "scgray", "createdAt": "2020-05-01T14:11:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1MTc5Mg=="}], "type": "inlineReview"}, {"oid": "2cc6627efc5af3db82f2086d15ee7484ef9192fb", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/2cc6627efc5af3db82f2086d15ee7484ef9192fb", "message": "Respond to Alec's comments", "committedDate": "2020-05-01T14:51:27Z", "type": "forcePushed"}, {"oid": "1e290b690a9de94598d9aa1f022dde92b6ef88a0", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/1e290b690a9de94598d9aa1f022dde92b6ef88a0", "message": "Respond to Alec's comments", "committedDate": "2020-05-01T14:55:39Z", "type": "commit"}, {"oid": "1e290b690a9de94598d9aa1f022dde92b6ef88a0", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/1e290b690a9de94598d9aa1f022dde92b6ef88a0", "message": "Respond to Alec's comments", "committedDate": "2020-05-01T14:55:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYwMjYyNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/926#discussion_r418602624", "bodyText": "I think this can be removed, too.", "author": "alecgrieser", "createdAt": "2020-05-01T15:51:07Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBDatabaseFactory.java", "diffHunk": "@@ -50,6 +50,7 @@\n     private static final Logger LOGGER = LoggerFactory.getLogger(FDBDatabaseFactory.class);\n \n     protected static final Function<FDBLatencySource, Long> DEFAULT_LATENCY_INJECTOR = api -> 0L;\n+    protected static final Supplier<Boolean> DEFAULT_ENABLE_ASSERTIONS_SUPPLIER = () -> false;", "originalCommit": "1e290b690a9de94598d9aa1f022dde92b6ef88a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIwNTM2Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/926#discussion_r420205367", "bodyText": "Oopsy.  Thanks for catching that.  Removed.", "author": "scgray", "createdAt": "2020-05-05T15:36:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYwMjYyNA=="}], "type": "inlineReview"}, {"oid": "581434d6cb7bd89af23bcea4c80a5e73634743f9", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/581434d6cb7bd89af23bcea4c80a5e73634743f9", "message": "Remove unused code from first commit", "committedDate": "2020-05-05T15:36:26Z", "type": "commit"}]}