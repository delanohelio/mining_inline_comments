{"pr_number": 4296, "pr_title": "Try compacting table multiple times if compaction has failed", "pr_createdAt": "2020-07-01T12:18:42Z", "pr_url": "https://github.com/trinodb/trino/pull/4296", "timeline": [{"oid": "db95f5cc55cd8f78ecde3480f9d80d1c50ee7851", "url": "https://github.com/trinodb/trino/commit/db95f5cc55cd8f78ecde3480f9d80d1c50ee7851", "message": "Try compacting table multiple times if compaction has failed", "committedDate": "2020-07-03T11:04:00Z", "type": "commit"}, {"oid": "db95f5cc55cd8f78ecde3480f9d80d1c50ee7851", "url": "https://github.com/trinodb/trino/commit/db95f5cc55cd8f78ecde3480f9d80d1c50ee7851", "message": "Try compacting table multiple times if compaction has failed", "committedDate": "2020-07-03T11:04:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU2OTM3OQ==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r449569379", "bodyText": "nit: getOnlyElement()", "author": "losipiuk", "createdAt": "2020-07-03T12:55:30Z", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,25 +189,82 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());\n+                })\n+                .onSuccess(event -> log.info(\"Finished %s compaction on %s in %s (%d tries)\", compactMode, tableName, event.getElapsedTime(), event.getAttemptCount()))\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, Duration.valueOf(\"60s\")));\n+    }\n+\n+    private static void tryCompactingTable(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n+            throws TimeoutException\n+    {\n+        long beforeCompactionStart = Instant.now().getEpochSecond();\n         onHive().executeQuery(format(\"ALTER TABLE %s %s COMPACT '%s'\", tableName, partitionString, compactMode.name())).getRowsCount();\n \n-        // Since we disabled table auto compaction and we checked that there are no compaction to the table\n-        // we can assume that every compaction from now on is triggered in this test\n-        // and all compaction should complete successfully before proceeding.\n-        assertEventually(timeout, () -> {\n-            Map<String, String> compaction = getOnlyElement(getTableCompactions(compactMode, tableName)\n-                    .collect(toImmutableList()));\n+        log.info(\"Started compactions: %s\", getTableCompactions(compactMode, tableName, OptionalLong.empty()));\n \n-            verify(!compaction.get(\"state\").equals(\"failed\"), \"compaction has failed\");\n-            assertEquals(compaction.get(\"state\"), \"succeeded\");\n-        });\n+        long loopStart = System.nanoTime();\n+        while (true) {\n+            try {\n+                // Compaction takes couple of second so there is no need to check state more frequent than 1s\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new RuntimeException(e);\n+            }\n+\n+            // Since we disabled auto compaction for uniquely named table and every compaction is triggered in this test\n+            // we can expect that single compaction in given mode should complete before proceeding.\n+            List<Map<String, String>> startedCompactions = getTableCompactions(compactMode, tableName, OptionalLong.of(beforeCompactionStart));\n+            verify(startedCompactions.size() < 2, \"Expected at most 1 compaction\");\n+\n+            if (startedCompactions.isEmpty()) {\n+                log.info(\"Compaction has not started yet\");\n+                continue;\n+            }\n+\n+            String compactionState = startedCompactions.get(0).get(\"state\");", "originalCommit": "db95f5cc55cd8f78ecde3480f9d80d1c50ee7851", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}