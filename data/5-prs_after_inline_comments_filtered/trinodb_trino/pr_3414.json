{"pr_number": 3414, "pr_title": "Allow blocking page source until dynamic filters are ready", "pr_createdAt": "2020-04-11T12:22:48Z", "pr_url": "https://github.com/trinodb/trino/pull/3414", "timeline": [{"oid": "ba93c071fde690b2ae6bdf79ec9988770b59c894", "url": "https://github.com/trinodb/trino/commit/ba93c071fde690b2ae6bdf79ec9988770b59c894", "message": "Support lazy dynamic filtering at memory connector", "committedDate": "2020-08-22T17:37:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU4NzYwOA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475587608", "bodyText": "you can use com.google.common.collect.ImmutableSetMultimap#toImmutableSetMultimap:\ndescriptors.stream()\n  .collect(toImmutableSetMultimap(Descriptor::getId(), descriptor -> Symbol.from(descriptor.getInput()));", "author": "sopel39", "createdAt": "2020-08-24T13:09:31Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,155 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n-    @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n-\n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    // Each future blocks until its dynamic filter is collected.\n+    private final Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n+\n+    public LocalDynamicFiltersCollector()\n+    {\n+    }\n+\n+    // Called during JoinNode planning (no need to be synchronized as local planning is single threaded)\n+    public void register(Set<DynamicFilterId> filterIds)\n+    {\n+        filterIds.forEach(filterId -> verify(\n+                futures.put(filterId, SettableFuture.create()) == null,\n+                \"LocalDynamicFiltersCollector: duplicate filter %s\", filterId));\n+    }\n+\n+    // Used during execution (after build-side dynamic filter collection is over).\n+    // No need to be synchronized as the futures map doesn't change.\n+    public void collectDynamicTupleDomain(Map<DynamicFilterId, Domain> dynamicFilterDomains)\n+    {\n+        dynamicFilterDomains\n+                .entrySet()\n+                .stream()\n+                .forEach(entry -> {\n+                    SettableFuture<Domain> future = futures.get(entry.getKey());\n+                    // Skip dynamic filters that are not applied locally.\n+                    if (future != null) {\n+                        verify(future.set(entry.getValue()), \"Dynamic filter %s already collected\", entry.getKey());\n+                    }\n+                });\n+    }\n+\n+    // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n+    public DynamicFilter createDynamicFilter(List<DynamicFilters.Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Map<Symbol, Domain> probeSymbolDomains = dynamicFilterDomainsResult.entrySet().stream()\n-                .filter(entry -> probeSymbols.contains(entry.getKey()))\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n-        return TupleDomain.withColumnDomains(probeSymbolDomains);\n+        ImmutableMultimap.Builder<DynamicFilterId, Symbol> symbolsMapBuilder = ImmutableMultimap.builder();", "originalCommit": "ae0dc5dedebf7d33817ee2b0a0bd4f8988af5874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU4OTY1Mg==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475589652", "bodyText": "You can now change it too:\nsymbolsMap.keySet().stream()\n  .map(filterId -> ...", "author": "sopel39", "createdAt": "2020-08-24T13:13:05Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,155 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n-    @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n-\n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    // Each future blocks until its dynamic filter is collected.\n+    private final Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n+\n+    public LocalDynamicFiltersCollector()\n+    {\n+    }\n+\n+    // Called during JoinNode planning (no need to be synchronized as local planning is single threaded)\n+    public void register(Set<DynamicFilterId> filterIds)\n+    {\n+        filterIds.forEach(filterId -> verify(\n+                futures.put(filterId, SettableFuture.create()) == null,\n+                \"LocalDynamicFiltersCollector: duplicate filter %s\", filterId));\n+    }\n+\n+    // Used during execution (after build-side dynamic filter collection is over).\n+    // No need to be synchronized as the futures map doesn't change.\n+    public void collectDynamicTupleDomain(Map<DynamicFilterId, Domain> dynamicFilterDomains)\n+    {\n+        dynamicFilterDomains\n+                .entrySet()\n+                .stream()\n+                .forEach(entry -> {\n+                    SettableFuture<Domain> future = futures.get(entry.getKey());\n+                    // Skip dynamic filters that are not applied locally.\n+                    if (future != null) {\n+                        verify(future.set(entry.getValue()), \"Dynamic filter %s already collected\", entry.getKey());\n+                    }\n+                });\n+    }\n+\n+    // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n+    public DynamicFilter createDynamicFilter(List<DynamicFilters.Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Map<Symbol, Domain> probeSymbolDomains = dynamicFilterDomainsResult.entrySet().stream()\n-                .filter(entry -> probeSymbols.contains(entry.getKey()))\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n-        return TupleDomain.withColumnDomains(probeSymbolDomains);\n+        ImmutableMultimap.Builder<DynamicFilterId, Symbol> symbolsMapBuilder = ImmutableMultimap.builder();\n+        for (DynamicFilters.Descriptor descriptor : descriptors) {\n+            symbolsMapBuilder.put(descriptor.getId(), Symbol.from(descriptor.getInput()));\n+        }\n+        Multimap<DynamicFilterId, Symbol> symbolsMap = symbolsMapBuilder.build();\n+\n+        // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n+        // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n+        // It is also possible that not all local dynamic filters are needed for this specific table scan.\n+        Set<DynamicFilterId> filterIds = Sets.intersection(symbolsMap.keySet(), futures.keySet());", "originalCommit": "ae0dc5dedebf7d33817ee2b0a0bd4f8988af5874", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg0Mzg1NQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475843855", "bodyText": "I am not sure that I understand... is it correct to replace:\nSet<DynamicFilterId> filterIds = Sets.intersection(symbolsMap.keySet(), futures.keySet());\nwith:\nSet<DynamicFilterId> filterIds = symbolsMap.keySet();\nFor example, in case of a partitioned join, symbolsMap.keySet() may contain dynamic filters collected in another stage - causing the following line to fail:\nrequireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId))", "author": "rzeyde-varada", "createdAt": "2020-08-24T19:27:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU4OTY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI5OTA3MA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r476299070", "bodyText": "You are right. We cannot simplify it.", "author": "sopel39", "createdAt": "2020-08-25T09:09:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU4OTY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5MTM5NA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475591394", "bodyText": "ah. This name doesn't make sense (it's not TupleDomain). Just rename it to collectDynamicFilterDomains here and in TaskContext", "author": "sopel39", "createdAt": "2020-08-24T13:15:59Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,155 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n-    @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n-\n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    // Each future blocks until its dynamic filter is collected.\n+    private final Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n+\n+    public LocalDynamicFiltersCollector()\n+    {\n+    }\n+\n+    // Called during JoinNode planning (no need to be synchronized as local planning is single threaded)\n+    public void register(Set<DynamicFilterId> filterIds)\n+    {\n+        filterIds.forEach(filterId -> verify(\n+                futures.put(filterId, SettableFuture.create()) == null,\n+                \"LocalDynamicFiltersCollector: duplicate filter %s\", filterId));\n+    }\n+\n+    // Used during execution (after build-side dynamic filter collection is over).\n+    // No need to be synchronized as the futures map doesn't change.\n+    public void collectDynamicTupleDomain(Map<DynamicFilterId, Domain> dynamicFilterDomains)", "originalCommit": "ae0dc5dedebf7d33817ee2b0a0bd4f8988af5874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5MjE2NQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475592165", "bodyText": "I would not rely on isComplete() method in constructor. What if somebody changes order of assignments? Just inline condition here", "author": "sopel39", "createdAt": "2020-08-24T13:17:11Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,155 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n-    @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n-\n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    // Each future blocks until its dynamic filter is collected.\n+    private final Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n+\n+    public LocalDynamicFiltersCollector()\n+    {\n+    }\n+\n+    // Called during JoinNode planning (no need to be synchronized as local planning is single threaded)\n+    public void register(Set<DynamicFilterId> filterIds)\n+    {\n+        filterIds.forEach(filterId -> verify(\n+                futures.put(filterId, SettableFuture.create()) == null,\n+                \"LocalDynamicFiltersCollector: duplicate filter %s\", filterId));\n+    }\n+\n+    // Used during execution (after build-side dynamic filter collection is over).\n+    // No need to be synchronized as the futures map doesn't change.\n+    public void collectDynamicTupleDomain(Map<DynamicFilterId, Domain> dynamicFilterDomains)\n+    {\n+        dynamicFilterDomains\n+                .entrySet()\n+                .stream()\n+                .forEach(entry -> {\n+                    SettableFuture<Domain> future = futures.get(entry.getKey());\n+                    // Skip dynamic filters that are not applied locally.\n+                    if (future != null) {\n+                        verify(future.set(entry.getValue()), \"Dynamic filter %s already collected\", entry.getKey());\n+                    }\n+                });\n+    }\n+\n+    // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n+    public DynamicFilter createDynamicFilter(List<DynamicFilters.Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Map<Symbol, Domain> probeSymbolDomains = dynamicFilterDomainsResult.entrySet().stream()\n-                .filter(entry -> probeSymbols.contains(entry.getKey()))\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n-        return TupleDomain.withColumnDomains(probeSymbolDomains);\n+        ImmutableMultimap.Builder<DynamicFilterId, Symbol> symbolsMapBuilder = ImmutableMultimap.builder();\n+        for (DynamicFilters.Descriptor descriptor : descriptors) {\n+            symbolsMapBuilder.put(descriptor.getId(), Symbol.from(descriptor.getInput()));\n+        }\n+        Multimap<DynamicFilterId, Symbol> symbolsMap = symbolsMapBuilder.build();\n+\n+        // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n+        // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n+        // It is also possible that not all local dynamic filters are needed for this specific table scan.\n+        Set<DynamicFilterId> filterIds = Sets.intersection(symbolsMap.keySet(), futures.keySet());\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = filterIds.stream()\n+                .map(filterId -> {\n+                    // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n+                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n+                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n+                            .collect(toImmutableList());\n+                    return Futures.transform(\n+                            futures.get(filterId),\n+                            // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n+                            domain -> TupleDomain.withColumnDomains(\n+                                    probeColumns.stream()\n+                                            .collect(toImmutableMap(\n+                                                    column -> column,\n+                                                    column -> domain))),\n+                            directExecutor());\n+                })\n+                .collect(toImmutableList());\n+        return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n-    public synchronized void addDynamicFilter(Map<Symbol, Domain> dynamicFilterDomains)\n+    // Table-specific dynamic filter (collects all domains for a specific table scan)\n+    private static class TableSpecificDynamicFilter\n+            implements DynamicFilter\n     {\n-        for (Map.Entry<Symbol, Domain> entry : dynamicFilterDomains.entrySet()) {\n-            dynamicFilterDomainsResult.merge(entry.getKey(), entry.getValue(), Domain::intersect);\n+        @GuardedBy(\"this\")\n+        private CompletableFuture<?> isBlocked;\n+\n+        @GuardedBy(\"this\")\n+        private TupleDomain<ColumnHandle> currentPredicate;\n+\n+        @GuardedBy(\"this\")\n+        private int futuresLeft;\n+\n+        public TableSpecificDynamicFilter(List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures)\n+        {\n+            this.futuresLeft = predicateFutures.size();\n+            this.isBlocked = isComplete() ? NOT_BLOCKED : new CompletableFuture();", "originalCommit": "ae0dc5dedebf7d33817ee2b0a0bd4f8988af5874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYyODU5Mg==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475628592", "bodyText": "use requireNotNull(futures.get(filterId), ...", "author": "sopel39", "createdAt": "2020-08-24T13:56:12Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,155 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n-    @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n-\n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    // Each future blocks until its dynamic filter is collected.\n+    private final Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n+\n+    public LocalDynamicFiltersCollector()\n+    {\n+    }\n+\n+    // Called during JoinNode planning (no need to be synchronized as local planning is single threaded)\n+    public void register(Set<DynamicFilterId> filterIds)\n+    {\n+        filterIds.forEach(filterId -> verify(\n+                futures.put(filterId, SettableFuture.create()) == null,\n+                \"LocalDynamicFiltersCollector: duplicate filter %s\", filterId));\n+    }\n+\n+    // Used during execution (after build-side dynamic filter collection is over).\n+    // No need to be synchronized as the futures map doesn't change.\n+    public void collectDynamicTupleDomain(Map<DynamicFilterId, Domain> dynamicFilterDomains)\n+    {\n+        dynamicFilterDomains\n+                .entrySet()\n+                .stream()\n+                .forEach(entry -> {\n+                    SettableFuture<Domain> future = futures.get(entry.getKey());\n+                    // Skip dynamic filters that are not applied locally.\n+                    if (future != null) {\n+                        verify(future.set(entry.getValue()), \"Dynamic filter %s already collected\", entry.getKey());\n+                    }\n+                });\n+    }\n+\n+    // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n+    public DynamicFilter createDynamicFilter(List<DynamicFilters.Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Map<Symbol, Domain> probeSymbolDomains = dynamicFilterDomainsResult.entrySet().stream()\n-                .filter(entry -> probeSymbols.contains(entry.getKey()))\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n-        return TupleDomain.withColumnDomains(probeSymbolDomains);\n+        ImmutableMultimap.Builder<DynamicFilterId, Symbol> symbolsMapBuilder = ImmutableMultimap.builder();\n+        for (DynamicFilters.Descriptor descriptor : descriptors) {\n+            symbolsMapBuilder.put(descriptor.getId(), Symbol.from(descriptor.getInput()));\n+        }\n+        Multimap<DynamicFilterId, Symbol> symbolsMap = symbolsMapBuilder.build();\n+\n+        // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n+        // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n+        // It is also possible that not all local dynamic filters are needed for this specific table scan.\n+        Set<DynamicFilterId> filterIds = Sets.intersection(symbolsMap.keySet(), futures.keySet());\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = filterIds.stream()\n+                .map(filterId -> {\n+                    // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n+                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n+                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n+                            .collect(toImmutableList());\n+                    return Futures.transform(\n+                            futures.get(filterId),", "originalCommit": "ae0dc5dedebf7d33817ee2b0a0bd4f8988af5874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYzNzYzOQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475637639", "bodyText": "put each argument in new line", "author": "sopel39", "createdAt": "2020-08-24T14:05:20Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -100,21 +103,32 @@ public void testJoinDynamicFilteringNone()\n         assertEquals(result.getResult().getRowCount(), 0);\n \n         // Probe-side is not scanned at all, due to dynamic filtering:\n-        QueryStats stats = runner.getCoordinator().getQueryManager().getFullQueryInfo(result.getQueryId()).getQueryStats();\n-        Set<Long> rowsRead = stats.getOperatorSummaries()\n-                .stream()\n-                .filter(summary -> summary.getOperatorType().equals(\"ScanFilterAndProjectOperator\"))\n-                .map(OperatorStats::getInputPositions)\n-                .collect(toImmutableSet());\n-        assertEquals(rowsRead, ImmutableSet.of(0L, buildSideRowsCount));\n+        Set<Long> rowsRead = getOperatorRowsRead(runner, result.getQueryId());\n+        assertEquals(rowsRead, ImmutableSet.of(0L, ORDERS_COUNT));\n     }\n \n     @Test\n-    public void testJoinDynamicFilteringSingleValue()\n+    public void testPartitionedJoinNoDynamicFiltering()\n     {\n-        final long buildSideRowsCount = 15_000L;\n+        assertQueryResult(\"SELECT COUNT() FROM orders WHERE totalprice < 0\", 0L);\n+\n+        Session session = Session.builder(getSession())\n+                .setSystemProperty(ENABLE_DYNAMIC_FILTERING, \"true\")\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.PARTITIONED.name())\n+                .build();\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(session, \"SELECT * FROM lineitem JOIN orders \" +", "originalCommit": "ba93c071fde690b2ae6bdf79ec9988770b59c894", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYzODEzOA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475638138", "bodyText": "you don't need to run this assertion for every test case", "author": "sopel39", "createdAt": "2020-08-24T14:06:01Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -100,21 +103,32 @@ public void testJoinDynamicFilteringNone()\n         assertEquals(result.getResult().getRowCount(), 0);\n \n         // Probe-side is not scanned at all, due to dynamic filtering:\n-        QueryStats stats = runner.getCoordinator().getQueryManager().getFullQueryInfo(result.getQueryId()).getQueryStats();\n-        Set<Long> rowsRead = stats.getOperatorSummaries()\n-                .stream()\n-                .filter(summary -> summary.getOperatorType().equals(\"ScanFilterAndProjectOperator\"))\n-                .map(OperatorStats::getInputPositions)\n-                .collect(toImmutableSet());\n-        assertEquals(rowsRead, ImmutableSet.of(0L, buildSideRowsCount));\n+        Set<Long> rowsRead = getOperatorRowsRead(runner, result.getQueryId());\n+        assertEquals(rowsRead, ImmutableSet.of(0L, ORDERS_COUNT));\n     }\n \n     @Test\n-    public void testJoinDynamicFilteringSingleValue()\n+    public void testPartitionedJoinNoDynamicFiltering()\n     {\n-        final long buildSideRowsCount = 15_000L;\n+        assertQueryResult(\"SELECT COUNT() FROM orders WHERE totalprice < 0\", 0L);", "originalCommit": "ba93c071fde690b2ae6bdf79ec9988770b59c894", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY0MDA5NA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475640094", "bodyText": "you can remove this test case. It's essentially identical to the one above", "author": "sopel39", "createdAt": "2020-08-24T14:09:06Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -129,13 +143,48 @@ public void testJoinDynamicFilteringSingleValue()\n         assertEquals(result.getResult().getRowCount(), 6);\n \n         // Probe-side is dynamically filtered:\n-        QueryStats stats = runner.getCoordinator().getQueryManager().getFullQueryInfo(result.getQueryId()).getQueryStats();\n-        Set<Long> rowsRead = stats.getOperatorSummaries()\n+        Set<Long> rowsRead = getOperatorRowsRead(runner, result.getQueryId());\n+        assertEquals(rowsRead, ImmutableSet.of(6L, ORDERS_COUNT));\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringBlockProbeSide()\n+    {\n+        Session session = Session.builder(getSession())\n+                .setSystemProperty(ENABLE_DYNAMIC_FILTERING, \"true\")\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, FeaturesConfig.JoinReorderingStrategy.NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.BROADCAST.name())\n+                .build();\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        // Wait for both build sides to finish before starting the scan of 'lineitem' table (should be very selective given the dynamic filters).\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                session,\n+                \"SELECT l.comment\" +\n+                        \" FROM  lineitem l, part p, orders o\" +\n+                        \" WHERE l.orderkey = o.orderkey AND o.comment = 'nstructions sleep furiously among '\" +\n+                        \" AND p.partkey = l.partkey AND p.comment = 'onic deposits'\");\n+        assertEquals(result.getResult().getRowCount(), 1);\n+        assertEquals(getOperatorRowsRead(runner, result.getQueryId()), ImmutableSet.of(1L, ORDERS_COUNT, PART_COUNT));\n+\n+        // Make sure that a single join doesn't doesn't narrow lineitem to single row.", "originalCommit": "ba93c071fde690b2ae6bdf79ec9988770b59c894", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc0MTQwMQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475741401", "bodyText": "Oops, thanks for catching this!\nRemove the duplicate and added a new test case to testJoinDynamicFilteringSingleValue.", "author": "rzeyde-varada", "createdAt": "2020-08-24T16:31:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY0MDA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY0MDk5OA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475640998", "bodyText": "please add a test case where build side is large. see #4946, e.g:\nSELECT * FROM orders a JOIN tpch.tiny.orders b ON a.orderkey = b.orderkey\n\nThe query should not be blocked", "author": "sopel39", "createdAt": "2020-08-24T14:10:24Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -43,6 +44,10 @@\n public class TestMemorySmoke\n         extends AbstractTestQueryFramework\n {\n+    private static final long LINEITEM_COUNT = 60175;", "originalCommit": "ba93c071fde690b2ae6bdf79ec9988770b59c894", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg0NjYxNA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475846614", "bodyText": "Cherry-picked 0f34989 and added testJoinLargeBuildSideNoDynamicFiltering.", "author": "rzeyde-varada", "createdAt": "2020-08-24T19:33:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY0MDk5OA=="}], "type": "inlineReview"}, {"oid": "88691c75aa5689810df34d2758a4f7e325b7d013", "url": "https://github.com/trinodb/trino/commit/88691c75aa5689810df34d2758a4f7e325b7d013", "message": "Do not enable dynamic filtering explicitly in TestMemorySmoke\n\nIt is enabled by default.", "committedDate": "2020-08-25T18:57:41Z", "type": "commit"}, {"oid": "572115ef83ffc4b5427635db4634a0f533f4a1a5", "url": "https://github.com/trinodb/trino/commit/572115ef83ffc4b5427635db4634a0f533f4a1a5", "message": "Allow blocking page source until dynamic filters are ready\n\nWe allow the connector to block according to dynamic filter collection\nstate. Some connectors would prefer to wait a bit, to benefit from\nmore selective scanning (using the collected dynamic filters).", "committedDate": "2020-08-26T10:50:19Z", "type": "commit"}, {"oid": "d5bb8c84c7b779cbef2747edc8cb9bab8571b54d", "url": "https://github.com/trinodb/trino/commit/d5bb8c84c7b779cbef2747edc8cb9bab8571b54d", "message": "Support lazy dynamic filtering at memory connector", "committedDate": "2020-08-26T10:50:19Z", "type": "commit"}, {"oid": "d5bb8c84c7b779cbef2747edc8cb9bab8571b54d", "url": "https://github.com/trinodb/trino/commit/d5bb8c84c7b779cbef2747edc8cb9bab8571b54d", "message": "Support lazy dynamic filtering at memory connector", "committedDate": "2020-08-26T10:50:19Z", "type": "forcePushed"}]}