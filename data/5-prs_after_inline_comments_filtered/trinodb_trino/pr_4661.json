{"pr_number": 4661, "pr_title": "Integrate Coral with Presto to enable querying hive views", "pr_createdAt": "2020-08-01T00:53:53Z", "pr_url": "https://github.com/trinodb/trino/pull/4661", "timeline": [{"oid": "f93122c17424bed9e39b6a4a29b6fede102dc8d2", "url": "https://github.com/trinodb/trino/commit/f93122c17424bed9e39b6a4a29b6fede102dc8d2", "message": "Integrate Coral with Presto to enable querying hive views", "committedDate": "2020-10-09T19:24:24Z", "type": "commit"}, {"oid": "f93122c17424bed9e39b6a4a29b6fede102dc8d2", "url": "https://github.com/trinodb/trino/commit/f93122c17424bed9e39b6a4a29b6fede102dc8d2", "message": "Integrate Coral with Presto to enable querying hive views", "committedDate": "2020-10-09T19:24:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA1NjIxNQ==", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r507056215", "bodyText": "Just double checking. Is this deliberate choice to execute Hive views by INVOKER? Previously they were executed by INVOKER. It sounds like a backward incompatible change (just noting for release notes if it is deliberate choice).", "author": "kokosing", "createdAt": "2020-10-18T09:16:37Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/ViewReaderUtil.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import com.linkedin.coral.hive.hive2rel.HiveToRelConverter;\n+import com.linkedin.coral.presto.rel2presto.RelToPrestoConverter;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.json.JsonCodecFactory;\n+import io.airlift.json.ObjectMapperProvider;\n+import io.airlift.log.Logger;\n+import io.prestosql.plugin.base.CatalogName;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.CoralSemiTransactionalHiveMSCAdapter;\n+import io.prestosql.plugin.hive.metastore.SemiTransactionalHiveMetastore;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorViewDefinition;\n+import io.prestosql.spi.connector.ConnectorViewDefinition.ViewColumn;\n+import io.prestosql.spi.type.TypeManager;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.hadoop.hive.metastore.TableType;\n+\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_VIEW_DATA;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_VIEW_TRANSLATION_ERROR;\n+import static io.prestosql.plugin.hive.HiveMetadata.TABLE_COMMENT;\n+import static io.prestosql.plugin.hive.util.HiveUtil.checkCondition;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.joining;\n+import static org.apache.hadoop.hive.metastore.TableType.VIRTUAL_VIEW;\n+\n+public final class ViewReaderUtil\n+{\n+    private ViewReaderUtil()\n+    {}\n+\n+    public interface ViewReader\n+    {\n+        ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName);\n+    }\n+\n+    public static ViewReader createViewReader(SemiTransactionalHiveMetastore metastore, HiveIdentity identity, Table table, TypeManager typemanager)\n+    {\n+        if (isPrestoView(table)) {\n+            return new PrestoViewReader();\n+        }\n+        return new HiveViewReader(new CoralSemiTransactionalHiveMSCAdapter(metastore, identity), typemanager);\n+    }\n+\n+    public static final String PRESTO_VIEW_FLAG = \"presto_view\";\n+    static final String VIEW_PREFIX = \"/* Presto View: \";\n+    static final String VIEW_SUFFIX = \" */\";\n+    private static final JsonCodec<ConnectorViewDefinition> VIEW_CODEC =\n+            new JsonCodecFactory(new ObjectMapperProvider()).jsonCodec(ConnectorViewDefinition.class);\n+    private static Logger log = Logger.get(io.prestosql.plugin.hive.ViewReaderUtil.class);\n+\n+    public static boolean isPrestoView(Table table)\n+    {\n+        return \"true\".equals(table.getParameters().get(PRESTO_VIEW_FLAG));\n+    }\n+\n+    public static boolean isHiveOrPrestoView(Table table)\n+    {\n+        return table.getTableType().equals(TableType.VIRTUAL_VIEW.name());\n+    }\n+\n+    public static boolean canDecodeView(Table table)\n+    {\n+        // we can decode Hive or Presto view\n+        return table.getTableType().equals(VIRTUAL_VIEW.name());\n+    }\n+\n+    public static String encodeViewData(ConnectorViewDefinition definition)\n+    {\n+        byte[] bytes = VIEW_CODEC.toJsonBytes(definition);\n+        String data = Base64.getEncoder().encodeToString(bytes);\n+        return VIEW_PREFIX + data + VIEW_SUFFIX;\n+    }\n+\n+    /**\n+     * Supports decoding of Presto views\n+     */\n+    public static class PrestoViewReader\n+            implements ViewReader\n+    {\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName)\n+        {\n+            checkCondition(viewData.startsWith(VIEW_PREFIX), HIVE_INVALID_VIEW_DATA, \"View data missing prefix: %s\", viewData);\n+            checkCondition(viewData.endsWith(VIEW_SUFFIX), HIVE_INVALID_VIEW_DATA, \"View data missing suffix: %s\", viewData);\n+            viewData = viewData.substring(VIEW_PREFIX.length());\n+            viewData = viewData.substring(0, viewData.length() - VIEW_SUFFIX.length());\n+            byte[] bytes = Base64.getDecoder().decode(viewData);\n+            return VIEW_CODEC.fromJson(bytes);\n+        }\n+    }\n+\n+    /**\n+     * Class to decode Hive view definitions\n+     */\n+    public static class HiveViewReader\n+            implements ViewReader\n+    {\n+        private final HiveMetastoreClient metastoreClient;\n+        private final TypeManager typeManager;\n+\n+        public HiveViewReader(HiveMetastoreClient hiveMetastoreClient, TypeManager typemanager)\n+        {\n+            this.metastoreClient = requireNonNull(hiveMetastoreClient, \"metastoreClient is null\");\n+            this.typeManager = requireNonNull(typemanager, \"typeManager is null\");\n+        }\n+\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewSql, Table table, CatalogName catalogName)\n+        {\n+            try {\n+                HiveToRelConverter hiveToRelConverter = HiveToRelConverter.create(metastoreClient);\n+                RelNode rel = hiveToRelConverter.convertView(table.getDatabaseName(), table.getTableName());\n+                RelToPrestoConverter rel2Presto = new RelToPrestoConverter();\n+                String prestoSql = rel2Presto.convert(rel);\n+                RelDataType rowType = rel.getRowType();\n+                List<ViewColumn> columns = rowType.getFieldList().stream()\n+                        .map(field -> new ViewColumn(\n+                                field.getName(),\n+                                typeManager.fromSqlType(getTypeString(field.getType())).getTypeId()))\n+                        .collect(toImmutableList());\n+                return new ConnectorViewDefinition(prestoSql,\n+                        Optional.of(catalogName.toString()),\n+                        Optional.of(table.getDatabaseName()),\n+                        columns,\n+                        Optional.ofNullable(table.getParameters().get(TABLE_COMMENT)),\n+                        Optional.empty(),\n+                        true);", "originalCommit": "f93122c17424bed9e39b6a4a29b6fede102dc8d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE5OTgzMQ==", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r507199831", "bodyText": "@kokosing Thanks for noticing that. I just noticed it is incompatible with previous version.  It has been running in our production environment with RunAsInvoker set to true. But if it is preferred to be backward compatible, I am ok to change.", "author": "laurachenyu", "createdAt": "2020-10-18T19:00:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA1NjIxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzIwMzM5MA==", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r507203390", "bodyText": "I am not that much concerned about being backward compatible, I wonder more about correctness. The question is what is the view semantic in Hive. Does Hive support running as invoker only or as owner only, does it allow to choose? We should do what view says we should do.\nI found it with a case when user has only access to a view and no access to underlying table, and query fails because we check the access to the table for that user (invoker), while previously we checked access to table but for the view owner.\nDo you use views in your production environment for access control purposes?\nRegarding backward compatibility, I hope that previous behavior was deliberate but I am not 100% sure.", "author": "kokosing", "createdAt": "2020-10-18T19:33:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA1NjIxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzIwNTA5Ng==", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r507205096", "bodyText": "Actually, I tested this with Hive and it works there, while in Presto I now get access denied.", "author": "kokosing", "createdAt": "2020-10-18T19:49:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA1NjIxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4NTc4NA==", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r507685784", "bodyText": "#5597", "author": "findepi", "createdAt": "2020-10-19T11:54:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA1NjIxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0ODk0MA==", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r515548940", "bodyText": "@findepi - Would it be better to have this Config controlled?", "author": "dmitryfill", "createdAt": "2020-10-31T22:47:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA1NjIxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY2NTg1MA==", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r515665850", "bodyText": "@dmitryfill\nIn #5597 we made those VIEWs back in line with SQL standard.\ni do not see why we would want this to be controlled by config just yet.\nPlease do not hesitate to file a new issue and ideally provide some rationale too.", "author": "findepi", "createdAt": "2020-11-01T20:08:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA1NjIxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY2NjI3MQ==", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r515666271", "bodyText": "Alternatively, possibly more powerful would be to have ALTER VIEW x SET SECURITY DEFINER", "author": "kokosing", "createdAt": "2020-11-01T20:12:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA1NjIxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY2NjM2OA==", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r515666368", "bodyText": "I was too quick. It won't work for Hive views as Presto do not control them.", "author": "kokosing", "createdAt": "2020-11-01T20:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA1NjIxNQ=="}], "type": "inlineReview"}]}