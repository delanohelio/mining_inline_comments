{"pr_number": 3533, "pr_title": "Handle unwrapping of casts with partial injective coercion", "pr_createdAt": "2020-04-24T00:22:48Z", "pr_url": "https://github.com/trinodb/trino/pull/3533", "timeline": [{"oid": "4b04deceba1ad7ec4a49e296ca4a63473c01cee3", "url": "https://github.com/trinodb/trino/commit/4b04deceba1ad7ec4a49e296ca4a63473c01cee3", "message": "Handle unwrapping of casts with partial injective coercion", "committedDate": "2020-06-21T15:44:34Z", "type": "commit"}, {"oid": "4b04deceba1ad7ec4a49e296ca4a63473c01cee3", "url": "https://github.com/trinodb/trino/commit/4b04deceba1ad7ec4a49e296ca4a63473c01cee3", "message": "Handle unwrapping of casts with partial injective coercion", "committedDate": "2020-06-21T15:44:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk5MDYzNw==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r443990637", "bodyText": "Can you explain why we return true in these cases?", "author": "martint", "createdAt": "2020-06-23T06:31:12Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -382,14 +382,27 @@ private Expression unwrapCast(ComparisonExpression expression)\n             return new ComparisonExpression(operator, cast.getExpression(), literalEncoder.toExpression(literalInSourceType, sourceType));\n         }\n \n-        private boolean hasInjectiveImplicitCoercion(Type source, Type target)\n+        private boolean hasInjectiveImplicitCoercion(Type source, Type target, Object value)\n         {\n             if ((source.equals(BIGINT) && target.equals(DOUBLE)) ||\n                     (source.equals(BIGINT) && target.equals(REAL)) ||\n                     (source.equals(INTEGER) && target.equals(REAL))) {\n                 // Not every BIGINT fits in DOUBLE/REAL due to 64 bit vs 53-bit/23-bit mantissa. Similarly,\n                 // not every INTEGER fits in a REAL (32-bit vs 23-bit mantissa)\n-                return false;\n+                if (target.equals(DOUBLE)) {\n+                    double doubleValue = (double) value;\n+                    return doubleValue > Long.MAX_VALUE ||\n+                            doubleValue < Long.MIN_VALUE ||\n+                            Double.isNaN(doubleValue) ||", "originalCommit": "4b04deceba1ad7ec4a49e296ca4a63473c01cee3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk5NjM5OQ==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r443996399", "bodyText": "For cases where the double literal is greater (or less) than any possible bigint value when casted to a double, we can treat it as a beyond/below type boundary check for bigint type - example if the expression is like bigint_col < cast(2^100 as double), then we can unwrap that case.\nThe NaN case is sent true because it gets unwrapped later as a part of NaN unwrap opt. done recently.", "author": "rohangarg", "createdAt": "2020-06-23T06:45:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk5MDYzNw=="}], "type": "inlineReview"}]}