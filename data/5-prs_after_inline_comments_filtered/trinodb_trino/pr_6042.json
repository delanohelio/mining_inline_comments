{"pr_number": 6042, "pr_title": "Aggregation simplify declarations", "pr_createdAt": "2020-11-21T21:02:44Z", "pr_url": "https://github.com/trinodb/trino/pull/6042", "timeline": [{"oid": "532ff583e780db131b7771c705e613757ec3f0cd", "url": "https://github.com/trinodb/trino/commit/532ff583e780db131b7771c705e613757ec3f0cd", "message": "Require aggregation metadata at construction\n\nRequire full aggregation function metadata during construction of aggregation.\nChange intermediate types to allow generic type signatures.", "committedDate": "2021-09-06T19:46:03Z", "type": "forcePushed"}, {"id": "PRRC_kwDOCezRTs4q6DGj", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r719860131", "bodyText": "This needs a better name. If you can you describe what concept this represents I can help come up with another name.", "author": "martint", "createdAt": "2021-10-01T00:29:31Z", "path": "core/trino-main/src/main/java/io/trino/operator/aggregation/AggregationFromAnnotationsParser.java", "diffHunk": "@@ -72,101 +70,112 @@ public static ParametricAggregation parseFunctionDefinitionWithTypesConstraint(C\n     {\n         AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n         requireNonNull(aggregationAnnotation, \"aggregationAnnotation is null\");\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n-\n-        ImmutableList.Builder<ParametricAggregation> builder = ImmutableList.builder();\n-\n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n-                for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                    Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                    for (AggregationHeader header : parseHeaders(aggregationDefinition, outputFunction)) {\n-                        AggregationImplementation onlyImplementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                        ParametricImplementationsGroup<AggregationImplementation> implementations = ParametricImplementationsGroup.of(onlyImplementation);\n-                        builder.add(new ParametricAggregation(signatureWithName(header.getName(), implementations.getSignature()), header, implementations, deprecated));\n-                    }\n+\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // There must be a single state class and combine function\n+        Class<?> stateClass = getStateClass(aggregationDefinition);\n+        Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n+\n+        // Each output function defines a new aggregation function\n+        for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n+            AggregationHeader header = parseHeader(aggregationDefinition, outputFunction);\n+\n+            // Input functions can have either an exact signature, or generic/calculate signature\n+            List<AggregationImplementation> exactImplementations = new ArrayList<>();\n+            List<AggregationImplementation> nonExactImplementations = new ArrayList<>();\n+            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n+                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n+                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header.getName(), inputFunction, removeInputFunction, outputFunction, combineFunction);\n+                if (isExact(implementation.getSignature())) {\n+                    exactImplementations.add(implementation);\n+                }\n+                else {\n+                    nonExactImplementations.add(implementation);\n                 }\n             }\n+\n+            // register a set functions for the canonical name, and each alias\n+            functions.addAll(buildFunctions(header.getName(), header, stateClass, exactImplementations, nonExactImplementations));\n+            for (String alias : getAliases(aggregationDefinition.getAnnotation(AggregationFunction.class), outputFunction)) {\n+                functions.addAll(buildFunctions(alias, header, stateClass, exactImplementations, nonExactImplementations));\n+            }\n         }\n \n-        return builder.build();\n+        return functions.build();\n     }\n \n-    public static ParametricAggregation parseFunctionDefinition(Class<?> aggregationDefinition)\n+    private static List<ParametricAggregation> buildFunctions(\n+            String name,\n+            AggregationHeader header,\n+            Class<?> stateClass,\n+            List<AggregationImplementation> exactImplementations,\n+            List<AggregationImplementation> nonExactImplementations)\n     {\n-        ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n-        AggregationHeader header = parseHeader(aggregationDefinition);\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // create a separate function for each exact implementation\n+        for (AggregationImplementation exactImplementation : exactImplementations) {\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, exactImplementation.getSignature()),\n+                    header,\n+                    stateClass,\n+                    ParametricImplementationsGroup.of(exactImplementation).withAlias(name)));\n+        }\n \n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            Method outputFunction = getOnlyElement(getOutputFunctions(aggregationDefinition, stateClass));\n-            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                implementationsBuilder.addImplementation(implementation);\n-            }\n+        // if there are non-exact functions, create a single generic/calculated function using these implementations\n+        if (!nonExactImplementations.isEmpty()) {\n+            ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n+            nonExactImplementations.forEach(implementationsBuilder::addImplementation);\n+            ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, implementations.getSignature()),\n+                    header,\n+                    stateClass,\n+                    implementations.withAlias(name)));\n         }\n \n-        ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n-        return new ParametricAggregation(signatureWithName(header.getName(), implementations.getSignature()), header, implementations, deprecated);\n+        return functions.build();\n+    }\n+\n+    private static boolean isExact(Signature signature)", "originalCommit": "8317c1c369ef96fce3ed80347f87aba5a8f08b9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "PRRC_kwDOCezRTs4q6DQs", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r719860780", "bodyText": "Move arguments to the same line", "author": "martint", "createdAt": "2021-10-01T00:31:40Z", "path": "core/trino-main/src/main/java/io/trino/operator/aggregation/AggregationFromAnnotationsParser.java", "diffHunk": "@@ -72,101 +70,112 @@ public static ParametricAggregation parseFunctionDefinitionWithTypesConstraint(C\n     {\n         AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n         requireNonNull(aggregationAnnotation, \"aggregationAnnotation is null\");\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n-\n-        ImmutableList.Builder<ParametricAggregation> builder = ImmutableList.builder();\n-\n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n-                for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                    Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                    for (AggregationHeader header : parseHeaders(aggregationDefinition, outputFunction)) {\n-                        AggregationImplementation onlyImplementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                        ParametricImplementationsGroup<AggregationImplementation> implementations = ParametricImplementationsGroup.of(onlyImplementation);\n-                        builder.add(new ParametricAggregation(signatureWithName(header.getName(), implementations.getSignature()), header, implementations, deprecated));\n-                    }\n+\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // There must be a single state class and combine function\n+        Class<?> stateClass = getStateClass(aggregationDefinition);\n+        Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n+\n+        // Each output function defines a new aggregation function\n+        for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n+            AggregationHeader header = parseHeader(aggregationDefinition, outputFunction);\n+\n+            // Input functions can have either an exact signature, or generic/calculate signature\n+            List<AggregationImplementation> exactImplementations = new ArrayList<>();\n+            List<AggregationImplementation> nonExactImplementations = new ArrayList<>();\n+            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n+                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n+                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header.getName(), inputFunction, removeInputFunction, outputFunction, combineFunction);\n+                if (isExact(implementation.getSignature())) {\n+                    exactImplementations.add(implementation);\n+                }\n+                else {\n+                    nonExactImplementations.add(implementation);\n                 }\n             }\n+\n+            // register a set functions for the canonical name, and each alias\n+            functions.addAll(buildFunctions(header.getName(), header, stateClass, exactImplementations, nonExactImplementations));\n+            for (String alias : getAliases(aggregationDefinition.getAnnotation(AggregationFunction.class), outputFunction)) {\n+                functions.addAll(buildFunctions(alias, header, stateClass, exactImplementations, nonExactImplementations));\n+            }\n         }\n \n-        return builder.build();\n+        return functions.build();\n     }\n \n-    public static ParametricAggregation parseFunctionDefinition(Class<?> aggregationDefinition)\n+    private static List<ParametricAggregation> buildFunctions(\n+            String name,\n+            AggregationHeader header,\n+            Class<?> stateClass,\n+            List<AggregationImplementation> exactImplementations,\n+            List<AggregationImplementation> nonExactImplementations)\n     {\n-        ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n-        AggregationHeader header = parseHeader(aggregationDefinition);\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // create a separate function for each exact implementation\n+        for (AggregationImplementation exactImplementation : exactImplementations) {\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, exactImplementation.getSignature()),\n+                    header,\n+                    stateClass,\n+                    ParametricImplementationsGroup.of(exactImplementation).withAlias(name)));\n+        }\n \n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            Method outputFunction = getOnlyElement(getOutputFunctions(aggregationDefinition, stateClass));\n-            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                implementationsBuilder.addImplementation(implementation);\n-            }\n+        // if there are non-exact functions, create a single generic/calculated function using these implementations\n+        if (!nonExactImplementations.isEmpty()) {\n+            ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n+            nonExactImplementations.forEach(implementationsBuilder::addImplementation);\n+            ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, implementations.getSignature()),\n+                    header,\n+                    stateClass,\n+                    implementations.withAlias(name)));\n         }\n \n-        ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n-        return new ParametricAggregation(signatureWithName(header.getName(), implementations.getSignature()), header, implementations, deprecated);\n+        return functions.build();\n+    }\n+\n+    private static boolean isExact(Signature signature)\n+    {\n+        return signature.getTypeVariableConstraints().isEmpty()\n+                && signature.getArgumentTypes().stream().noneMatch(TypeSignature::isCalculated)\n+                && !signature.getReturnType().isCalculated();\n     }\n \n-    private static AggregationHeader parseHeader(AnnotatedElement aggregationDefinition)\n+    private static AggregationHeader parseHeader(AnnotatedElement aggregationDefinition, AnnotatedElement outputFunction)\n     {\n         AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n         requireNonNull(aggregationAnnotation, \"aggregationAnnotation is null\");\n+        String name = getName(aggregationAnnotation, outputFunction);\n         return new AggregationHeader(\n-                aggregationAnnotation.value(),\n-                aggregationAnnotation.value(),\n-                parseDescription(aggregationDefinition),\n+                name,\n+                parseDescription(aggregationDefinition, outputFunction),\n                 aggregationAnnotation.decomposable(),\n                 aggregationAnnotation.isOrderSensitive(),\n-                aggregationAnnotation.hidden());\n+                aggregationAnnotation.hidden(),\n+                aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0);\n     }\n \n-    private static List<AggregationHeader> parseHeaders(AnnotatedElement aggregationDefinition, AnnotatedElement toParse)\n+    private static String getName(AggregationFunction aggregationAnnotation, AnnotatedElement outputFunction)\n     {\n-        AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n-\n-        return getNames(toParse, aggregationAnnotation).stream()\n-                .map(aggregationFunctionName ->\n-                        new AggregationHeader(\n-                                aggregationFunctionName.getActualName(),\n-                                aggregationFunctionName.getCanonicalName(),\n-                                parseDescription(aggregationDefinition, toParse),\n-                                aggregationAnnotation.decomposable(),\n-                                aggregationAnnotation.isOrderSensitive(),\n-                                aggregationAnnotation.hidden()))\n-                .collect(toImmutableList());\n+        AggregationFunction annotation = outputFunction.getAnnotation(AggregationFunction.class);\n+        if (annotation != null && !annotation.value().isEmpty()) {\n+            return emptyToNull(annotation.value());\n+        }\n+        return emptyToNull(aggregationAnnotation.value());\n     }\n \n-    private static List<AggregationFunctionName> getNames(@Nullable AnnotatedElement outputFunction, AggregationFunction aggregationAnnotation)\n+    private static List<String> getAliases(AggregationFunction aggregationAnnotation,\n+            AnnotatedElement outputFunction)", "originalCommit": "8317c1c369ef96fce3ed80347f87aba5a8f08b9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "250227ffda48a4ba1eedc7c2c83daa163bbc9607", "url": "https://github.com/trinodb/trino/commit/250227ffda48a4ba1eedc7c2c83daa163bbc9607", "message": "Require aggregation metadata at construction\n\nRequire full aggregation function metadata during construction of aggregation.\nChange intermediate types to allow generic type signatures.", "committedDate": "2021-10-09T03:50:55Z", "type": "forcePushed"}, {"oid": "b87377002fbb1a6b8061def4da4de34b37b140a7", "url": "https://github.com/trinodb/trino/commit/b87377002fbb1a6b8061def4da4de34b37b140a7", "message": "Require aggregation metadata at construction\n\nRequire full aggregation function metadata during construction of aggregation.\nChange intermediate types to allow generic type signatures.", "committedDate": "2021-10-09T05:36:04Z", "type": "forcePushed"}, {"oid": "6e02559f6a43715557b15e643cc5f11c5b1bb91c", "url": "https://github.com/trinodb/trino/commit/6e02559f6a43715557b15e643cc5f11c5b1bb91c", "message": "Change FunctionMetadata signature to be the actual caller signature\n\nRemove actual name field since signature carries actual name\nAdd canonical name field so push down can use canonical name", "committedDate": "2021-10-09T05:38:42Z", "type": "commit"}, {"oid": "770d3fe1bc83a346775ef180287ba4fbace925c0", "url": "https://github.com/trinodb/trino/commit/770d3fe1bc83a346775ef180287ba4fbace925c0", "message": "Move boolean approx_distinct to separate class", "committedDate": "2021-10-09T05:38:42Z", "type": "commit"}, {"oid": "db0c4be1912a140e8311dd3020c16de886aceff4", "url": "https://github.com/trinodb/trino/commit/db0c4be1912a140e8311dd3020c16de886aceff4", "message": "Move legacy approx_percentile to separate classes", "committedDate": "2021-10-09T05:38:42Z", "type": "commit"}, {"oid": "5c1ea5696b20f1d76494f4308b5e01d7fba09b2e", "url": "https://github.com/trinodb/trino/commit/5c1ea5696b20f1d76494f4308b5e01d7fba09b2e", "message": "Simplify parametric aggregation\n\nConsolidate the two annotation processing strategy into a single strategy\nSimplify handling of function aliases\nMove deprecated flag to AggregationHeader", "committedDate": "2021-10-09T05:38:42Z", "type": "commit"}, {"oid": "c6f8536601cb1e55a30fce8a4cf2e6c4137ad13e", "url": "https://github.com/trinodb/trino/commit/c6f8536601cb1e55a30fce8a4cf2e6c4137ad13e", "message": "Add generic aggregation state holders\n\nGeneric state holders can use an explicit type as opposed to only\nBIGINT, DOUBLE, and BOOLEAN", "committedDate": "2021-10-09T05:38:42Z", "type": "commit"}, {"oid": "e7818e667cdf132092d473ac32f03dab625ce6d7", "url": "https://github.com/trinodb/trino/commit/e7818e667cdf132092d473ac32f03dab625ce6d7", "message": "Require aggregation metadata at construction\n\nRequire full aggregation function metadata during construction of aggregation.\nChange intermediate types to allow generic type signatures.", "committedDate": "2021-10-09T05:54:21Z", "type": "commit"}, {"oid": "e7818e667cdf132092d473ac32f03dab625ce6d7", "url": "https://github.com/trinodb/trino/commit/e7818e667cdf132092d473ac32f03dab625ce6d7", "message": "Require aggregation metadata at construction\n\nRequire full aggregation function metadata during construction of aggregation.\nChange intermediate types to allow generic type signatures.", "committedDate": "2021-10-09T05:54:21Z", "type": "forcePushed"}]}