{"pr_number": 6066, "pr_title": "Add support for coercions in table scan redirections", "pr_createdAt": "2020-11-23T22:41:05Z", "pr_url": "https://github.com/trinodb/trino/pull/6066", "timeline": [{"oid": "c8dcea9ff07cb83a68421ee32fb2e9d8c8102042", "url": "https://github.com/trinodb/trino/commit/c8dcea9ff07cb83a68421ee32fb2e9d8c8102042", "message": "Add support for coercions in table scan redirections", "committedDate": "2020-11-24T09:10:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkwOTk3OQ==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r639909979", "bodyText": "What's dest_col_a in this example?", "author": "martint", "createdAt": "2021-05-26T16:36:22Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -201,6 +211,25 @@ public void testRedirectAfterColumnPruningOnPushedDownPredicate()\n         }\n     }\n \n+    @Test\n+    public void testPredicateTypeMismatch()\n+    {\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(typeMismatchedRedirectionMappingBC, Optional.of(ImmutableSet.of(sourceColumnHandleB))),\n+                Optional.of(this::mockApplyProjection),\n+                Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleC))))) {\n+            // After 'source_col_c = 1' is pushed into source table scan, it's possible for 'source_col_c' table scan assignment to be pruned\n+            // Redirection results in Project('dest_col_b') -> Filter('dest_col_c = 1') -> TableScan for such case\n+            // but dest_col_a has mismatched type compared to source domain", "originalCommit": "a1f28760519f36f1d7083eedc1460ed401e522b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDYwNjY5Mw==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640606693", "bodyText": "dest_col_a is integer", "author": "sopel39", "createdAt": "2021-05-27T13:08:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkwOTk3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDc2NzE0MA==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640767140", "bodyText": "Sorry, I meant what role does it play since it seems unrelated to the example given. But then I noticed you changed this to say dest_col_c in another commit.", "author": "martint", "createdAt": "2021-05-27T16:06:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkwOTk3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDkyNTQ0Nw==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640925447", "bodyText": "source_col_c gets redirected to dest_col_a, but dest_col_a has different type (int) than source_col_c (varchar)", "author": "sopel39", "createdAt": "2021-05-27T19:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkwOTk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxMTkyMQ==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r639911921", "bodyText": "Commit message should provide some explanation on what this change is about", "author": "martint", "createdAt": "2021-05-26T16:37:51Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -16,6 +16,8 @@\n import com.google.common.collect.ImmutableBiMap;", "originalCommit": "c8dcea9ff07cb83a68421ee32fb2e9d8c8102042", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxNDA0OQ==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r639914049", "bodyText": "When and why would this ever be false? This doesn't seem necessary. If the connector doesn't want to allow coercions, it should just not perform the redirection.", "author": "martint", "createdAt": "2021-05-26T16:40:40Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/TableScanRedirectApplicationResult.java", "diffHunk": "@@ -26,12 +26,27 @@\n     private final Map<ColumnHandle, String> destinationColumns;\n     // filter that needs to be applied on top of table scan\n     private final TupleDomain<String> filter;\n+    // should coercions be used when source and redirected column types don't match\n+    private boolean allowCoercions;", "originalCommit": "c8dcea9ff07cb83a68421ee32fb2e9d8c8102042", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDUyMjIzMw==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640522233", "bodyText": "I was thinking this would be useful for connectors that want to match source with redirected table 1-1 (without mismatched type) and would prefer to throw exception when types mismatch", "author": "sopel39", "createdAt": "2021-05-27T11:07:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxNDA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDczMzUxNA==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640733514", "bodyText": "The can do this on its own. It needs to somehow be aware of the target table anyway, so it can do this check by itself.", "author": "martint", "createdAt": "2021-05-27T15:26:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxNDA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDkyNTkxNg==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640925916", "bodyText": "It needs to somehow be aware of the target table anyway, so it can do this check by itself.\n\nIt might not be aware of target table types since it can be in different catalog and could be created externally.", "author": "sopel39", "createdAt": "2021-05-27T19:57:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxNDA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDkyOTI2MA==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640929260", "bodyText": "Then how is it going to know to redirect to those tables, or that they are the right table to redirect to? Table redirections don't seem very useful without that level of understanding, so it seems reasonable to me to expect that from connectors.", "author": "martint", "createdAt": "2021-05-27T20:03:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxNDA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDk0Mjg5Mw==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640942893", "bodyText": "removed toggle", "author": "sopel39", "createdAt": "2021-05-27T20:26:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxNDA0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxNTExNg==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r639915116", "bodyText": "This belongs in the previous commit", "author": "martint", "createdAt": "2021-05-26T16:42:03Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -215,12 +223,12 @@ public void testRedirectAfterColumnPruningOnPushedDownPredicate()\n     public void testPredicateTypeMismatch()\n     {\n         try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n-                getMockApplyRedirectAfterPredicatePushdown(typeMismatchedRedirectionMappingBC, Optional.of(ImmutableSet.of(sourceColumnHandleB))),\n+                getMockApplyRedirectAfterPredicatePushdown(typeMismatchedRedirectionMappingBC, Optional.of(ImmutableSet.of(sourceColumnHandleB)), false),\n                 Optional.of(this::mockApplyProjection),\n                 Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleC))))) {\n             // After 'source_col_c = 1' is pushed into source table scan, it's possible for 'source_col_c' table scan assignment to be pruned\n             // Redirection results in Project('dest_col_b') -> Filter('dest_col_c = 1') -> TableScan for such case\n-            // but dest_col_a has mismatched type compared to source domain\n+            // but dest_col_c has mismatched type compared to source domain", "originalCommit": "c8dcea9ff07cb83a68421ee32fb2e9d8c8102042", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxNjA2Nw==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r639916067", "bodyText": "TrinoException", "author": "martint", "createdAt": "2021-05-26T16:43:19Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -88,49 +94,56 @@ public Result apply(TableScanNode scanNode, Captures captures, Context context)\n \n         Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n         Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n-        Map<Symbol, ColumnHandle> newAssignments = scanNode.getAssignments().entrySet().stream()\n-                .collect(toImmutableMap(Map.Entry::getKey, entry -> {\n-                    String destinationColumn = columnMapping.get(entry.getValue());\n-                    if (destinationColumn == null) {\n-                        throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find mapping for source column %s in table scan redirection\", entry.getValue()));\n-                    }\n-                    ColumnHandle destinationColumnHandle = destinationColumnHandles.get(destinationColumn);\n-                    if (destinationColumnHandle == null) {\n-                        throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n-                    }\n-\n-                    // validate that redirected types match source types\n-                    Type sourceType = context.getSymbolAllocator().getTypes().get(entry.getKey());\n-                    Type redirectedType = metadata.getColumnMetadata(context.getSession(), destinationTableHandle.get(), destinationColumnHandle).getType();\n-                    if (!sourceType.equals(redirectedType)) {\n-                        throwTypeMismatchException(\n-                                destinationTable,\n-                                destinationColumn,\n-                                redirectedType,\n-                                scanNode.getTable(),\n-                                entry.getValue(),\n-                                sourceType);\n-                    }\n-\n-                    return destinationColumnHandle;\n-                }));\n+        ImmutableMap.Builder<Symbol, Cast> casts = ImmutableMap.builder();\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newAssignmentsBuilder = ImmutableMap.builder();\n+        for (Map.Entry<Symbol, ColumnHandle> assignment : scanNode.getAssignments().entrySet()) {\n+            String destinationColumn = columnMapping.get(assignment.getValue());\n+            if (destinationColumn == null) {\n+                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find mapping for source column %s in table scan redirection\", assignment.getValue()));", "originalCommit": "c8dcea9ff07cb83a68421ee32fb2e9d8c8102042", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxODY2NA==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r639918664", "bodyText": "This is missing the typeOnlyCoercion flag.", "author": "martint", "createdAt": "2021-05-26T16:47:01Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -144,70 +157,118 @@ public Result apply(TableScanNode scanNode, Captures captures, Context context)\n                 return symbol;\n             }\n \n-            // validate that redirected types match source types\n+            // Column pruning after predicate is pushed into table scan can remove assignments for filter columns from the scan node\n             Type domainType = requiredFilter.getDomains().get().get(destinationColumn).getType();\n+            symbol = context.getSymbolAllocator().newSymbol(destinationColumn, domainType);\n+\n             ColumnHandle destinationColumnHandle = destinationColumnHandles.get(destinationColumn);\n+            if (destinationColumnHandle == null) {\n+                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+            }\n+\n+            // insert casts if redirected types don't match domain types\n             Type redirectedType = metadata.getColumnMetadata(context.getSession(), destinationTableHandle.get(), destinationColumnHandle).getType();\n             if (!domainType.equals(redirectedType)) {\n-                throwTypeMismatchException(\n+                Symbol redirectedSymbol = context.getSymbolAllocator().newSymbol(destinationColumn, redirectedType);\n+                Cast cast = getCast(\n+                        tableScanRedirectApplicationResult.get().isAllowCoercions(),\n                         destinationTable,\n                         destinationColumn,\n                         redirectedType,\n+                        redirectedSymbol,\n                         scanNode.getTable(),\n                         sourceColumnHandle,\n                         domainType);\n+                casts.put(symbol, cast);\n+                newAssignmentsBuilder.put(redirectedSymbol, destinationColumnHandle);\n             }\n-\n-            // Column pruning after predicate is pushed into table scan can remove assignments for filter columns from the scan node\n-            symbol = context.getSymbolAllocator().newSymbol(destinationColumn, domainType);\n-            if (destinationColumnHandle == null) {\n-                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+            else {\n+                newAssignmentsBuilder.put(symbol, destinationColumnHandle);\n             }\n-            newAssignmentsBuilder.put(symbol, destinationColumnHandle);\n-            newOutputSymbolsBuilder.add(symbol);\n+\n             return symbol;\n         });\n \n-        List<Symbol> newOutputSymbols = newOutputSymbolsBuilder.build();\n+        Map<Symbol, ColumnHandle> newAssignments = newAssignmentsBuilder.build();\n         TableScanNode newScanNode = new TableScanNode(\n                 scanNode.getId(),\n                 destinationTableHandle.get(),\n-                newOutputSymbols,\n-                newAssignmentsBuilder.build(),\n+                ImmutableList.copyOf(newAssignments.keySet()),\n+                newAssignments,\n                 TupleDomain.all(),\n                 scanNode.isForDelete());\n \n         FilterNode filterNode = new FilterNode(\n                 context.getIdAllocator().getNextId(),\n-                newScanNode,\n+                applyProjection(\n+                        context.getIdAllocator(),\n+                        newAssignments.keySet(),\n+                        casts.build(),\n+                        newScanNode),\n                 domainTranslator.toPredicate(transformedConstraint));\n-        if (newOutputSymbols.size() == scanNode.getOutputSymbols().size()) {\n-            return Result.ofPlanNode(filterNode);\n+\n+        return Result.ofPlanNode(applyProjection(\n+                context.getIdAllocator(),\n+                ImmutableSet.copyOf(scanNode.getOutputSymbols()),\n+                ImmutableMap.of(),\n+                filterNode));\n+    }\n+\n+    private PlanNode applyProjection(\n+            PlanNodeIdAllocator idAllocator,\n+            Set<Symbol> requiredSymbols,\n+            Map<Symbol, Cast> casts,\n+            PlanNode source)\n+    {\n+        if (casts.isEmpty() && requiredSymbols.equals(ImmutableSet.copyOf(source.getOutputSymbols()))) {\n+            return source;\n         }\n \n-        return Result.ofPlanNode(\n-                new ProjectNode(\n-                        context.getIdAllocator().getNextId(),\n-                        filterNode,\n-                        Assignments.identity(scanNode.getOutputSymbols())));\n+        return new ProjectNode(\n+                idAllocator.getNextId(),\n+                source,\n+                Assignments.builder()\n+                        .putIdentities(Sets.difference(requiredSymbols, casts.keySet()))\n+                        .putAll(casts)\n+                        .build());\n     }\n \n-    private static void throwTypeMismatchException(\n+    private Cast getCast(\n+            boolean allowCoercions,\n             CatalogSchemaTableName destinationTable,\n             String destinationColumn,\n             Type destinationType,\n+            Symbol destinationSymbol,\n             TableHandle sourceTable,\n             ColumnHandle sourceColumnHandle,\n             Type sourceType)\n     {\n-        throw new PrestoException(TYPE_MISMATCH, format(\n-                \"Redirected column %s.%s has type %s, different from source column %s.%s type: %s\",\n-                destinationTable,\n-                destinationColumn,\n-                destinationType,\n-                // TODO report source table and column name instead of ConnectorTableHandle, ConnectorColumnHandle toString\n-                sourceTable,\n-                sourceColumnHandle,\n-                sourceType));\n+        if (!allowCoercions) {\n+            throw new PrestoException(TYPE_MISMATCH, format(\n+                    \"Redirected column %s.%s has type %s, different from source column %s.%s type: %s\",\n+                    destinationTable,\n+                    destinationColumn,\n+                    destinationType,\n+                    // TODO report source table and column name instead of ConnectorTableHandle, ConnectorColumnHandle toString\n+                    sourceTable,\n+                    sourceColumnHandle,\n+                    sourceType));\n+        }\n+\n+        try {\n+            metadata.getCoercion(destinationType, sourceType);\n+        }\n+        catch (PrestoException e) {\n+            throw new PrestoException(FUNCTION_NOT_FOUND, format(\n+                    \"Cast not possible from redirected column %s.%s with type %s to source column %s.%s with type: %s\",\n+                    destinationTable,\n+                    destinationColumn,\n+                    destinationType,\n+                    sourceTable,\n+                    sourceColumnHandle,\n+                    sourceType));\n+        }\n+\n+        return new Cast(destinationSymbol.toSymbolReference(), toSqlType(sourceType));", "originalCommit": "c8dcea9ff07cb83a68421ee32fb2e9d8c8102042", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDUyMzc5Nw==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640523797", "bodyText": "It can't be type only coercion. E.g we can coerce from timestamp(9) -> timestamp(0)", "author": "sopel39", "createdAt": "2021-05-27T11:10:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxODY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDczNDM5Nw==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640734397", "bodyText": "I know. But currently it's saying every coercions is \"not type-only coercion\". It needs to pass the true/false flag depending on whether that's the case.", "author": "martint", "createdAt": "2021-05-27T15:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxODY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDc4MDQ3NA==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640780474", "bodyText": "@martint shouldn't this not be a concern of this rule?\nie shouldn't we have a canonicalizer which can determine a certain cast is type-only?\nit's a function of types being converted from/to, not a function of particular creating site", "author": "findepi", "createdAt": "2021-05-27T16:22:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxODY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDkwNDYzNA==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640904634", "bodyText": "Well, the notion of type-only casts in the planner has always been somewhat of a misfeature. It's not clear it even does anything (a type-only cast will be just a passthrough method in the implementation, so the JIT should be able to inline and remove them).\nBut we don't have any such thing today, and we rely on the callsites to construct the cast properly. In a way, you can think of an IR cast as having (from, to, type-only) elements (vs the AST cast, which only has (from, to))\nTL;DR, we should consider getting rid of type-only casts, but in the meantime, we should construct them properly if at all possible.", "author": "martint", "createdAt": "2021-05-27T19:22:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxODY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDkxNzc2OA==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640917768", "bodyText": "TL;DR, we should consider getting rid of type-only casts,\n\ncan you please file an issue for that?", "author": "findepi", "createdAt": "2021-05-27T19:45:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxODY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDkyODE5Ng==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640928196", "bodyText": "#8111", "author": "martint", "createdAt": "2021-05-27T20:01:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxODY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDkzMDkyNQ==", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640930925", "bodyText": "added call to isTypeOnlyCoercion", "author": "sopel39", "createdAt": "2021-05-27T20:06:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxODY2NA=="}], "type": "inlineReview"}, {"oid": "54942cad9b6373d52b94b2ebf82fc4e4aea680b6", "url": "https://github.com/trinodb/trino/commit/54942cad9b6373d52b94b2ebf82fc4e4aea680b6", "message": "Remove SPI support for UNION ALL types of redirections\n\nRedirections SPI will be deprecated and Trino engine won't be extended\nfor UNION ALL support in a foreseeable future.", "committedDate": "2021-05-27T13:04:49Z", "type": "commit"}, {"oid": "9c9b955c83ebbee54ca0c35069a0c43641ffad62", "url": "https://github.com/trinodb/trino/commit/9c9b955c83ebbee54ca0c35069a0c43641ffad62", "message": "Add support for coercions in table scan redirections\n\nRedirected table can have different column types\nthan source table. In that case, an explicit cast\nwill be inserted by the engine.", "committedDate": "2021-05-27T20:26:00Z", "type": "commit"}, {"oid": "9c9b955c83ebbee54ca0c35069a0c43641ffad62", "url": "https://github.com/trinodb/trino/commit/9c9b955c83ebbee54ca0c35069a0c43641ffad62", "message": "Add support for coercions in table scan redirections\n\nRedirected table can have different column types\nthan source table. In that case, an explicit cast\nwill be inserted by the engine.", "committedDate": "2021-05-27T20:26:00Z", "type": "forcePushed"}]}