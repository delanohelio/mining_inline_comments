{"pr_number": 5792, "pr_title": "Implement table scan redirection", "pr_createdAt": "2020-11-03T10:42:36Z", "pr_url": "https://github.com/trinodb/trino/pull/5792", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAzNzgwNg==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518037806", "bodyText": "reverse the condition and add a comment:\nif (symbol != null) {\n  // symbol should be mapped in redirected table scan\n  return symbol;\n}", "author": "sopel39", "createdAt": "2020-11-05T13:09:58Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.DomainTranslator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isTableScanRedirectionEnabled;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ApplyTableScanRedirection\n+        implements Rule<TableScanNode>\n+{\n+    private static final Pattern<TableScanNode> PATTERN = tableScan();\n+\n+    private final Metadata metadata;\n+    private final DomainTranslator domainTranslator;\n+\n+    public ApplyTableScanRedirection(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.domainTranslator = new DomainTranslator(metadata);\n+    }\n+\n+    @Override\n+    public Pattern<TableScanNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isTableScanRedirectionEnabled(session);\n+    }\n+\n+    @Override\n+    public Result apply(TableScanNode scanNode, Captures captures, Context context)\n+    {\n+        Optional<TableScanRedirectApplicationResult> tableScanRedirectApplicationResult = metadata.applyTableScanRedirect(context.getSession(), scanNode.getTable());\n+        if (tableScanRedirectApplicationResult.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        CatalogSchemaTableName destinationTable = tableScanRedirectApplicationResult.get().getDestinationTable();\n+        Optional<TableHandle> destinationTableHandle = metadata.getTableHandle(\n+                context.getSession(),\n+                convertFromSchemaTableName(destinationTable.getCatalogName()).apply(destinationTable.getSchemaTableName()));\n+        if (destinationTableHandle.isEmpty()) {\n+            throw new PrestoException(GENERIC_INTERNAL_ERROR, format(\"Destination table %s from table scan redirection not found\", destinationTable));\n+        }\n+        if (destinationTableHandle.get().equals(scanNode.getTable())) {\n+            return Result.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n+        Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n+        Map<Symbol, ColumnHandle> newAssignments = scanNode.getAssignments().entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, entry -> {\n+                    String destinationColumn = requireNonNull(\n+                            columnMapping.get(entry.getValue()),\n+                            format(\"Did not find mapping for source column %s in table scan redirection\", entry.getValue()));\n+                    return requireNonNull(\n+                            destinationColumnHandles.get(destinationColumn),\n+                            format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+                }));\n+\n+        TupleDomain<ColumnHandle> enforcedConstraint = scanNode.getEnforcedConstraint();\n+        if (enforcedConstraint.isAll()) {\n+            return Result.ofPlanNode(\n+                    new TableScanNode(\n+                            scanNode.getId(),\n+                            destinationTableHandle.get(),\n+                            scanNode.getOutputSymbols(),\n+                            newAssignments,\n+                            enforcedConstraint));\n+        }\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newAssignmentsBuilder = ImmutableMap.<Symbol, ColumnHandle>builder()\n+                .putAll(newAssignments);\n+        ImmutableList.Builder<Symbol> newOutputSymbolsBuilder = ImmutableList.<Symbol>builder()\n+                .addAll(scanNode.getOutputSymbols());\n+        Map<ColumnHandle, Symbol> assignments = ImmutableBiMap.copyOf(scanNode.getAssignments()).inverse();\n+        TupleDomain<Symbol> transformedFilters = enforcedConstraint.transform(sourceColumnHandle -> {\n+            Symbol symbol = assignments.get(sourceColumnHandle);\n+            if (symbol == null) {", "originalCommit": "f89a975f373ef9d4bac499ae771034783c42ecc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA0MjgyOQ==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518042829", "bodyText": "extract enforcedConstraint.getDomains().get().get(sourceColumnHandle).getType() as Type domainType", "author": "sopel39", "createdAt": "2020-11-05T13:18:02Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.DomainTranslator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isTableScanRedirectionEnabled;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ApplyTableScanRedirection\n+        implements Rule<TableScanNode>\n+{\n+    private static final Pattern<TableScanNode> PATTERN = tableScan();\n+\n+    private final Metadata metadata;\n+    private final DomainTranslator domainTranslator;\n+\n+    public ApplyTableScanRedirection(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.domainTranslator = new DomainTranslator(metadata);\n+    }\n+\n+    @Override\n+    public Pattern<TableScanNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isTableScanRedirectionEnabled(session);\n+    }\n+\n+    @Override\n+    public Result apply(TableScanNode scanNode, Captures captures, Context context)\n+    {\n+        Optional<TableScanRedirectApplicationResult> tableScanRedirectApplicationResult = metadata.applyTableScanRedirect(context.getSession(), scanNode.getTable());\n+        if (tableScanRedirectApplicationResult.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        CatalogSchemaTableName destinationTable = tableScanRedirectApplicationResult.get().getDestinationTable();\n+        Optional<TableHandle> destinationTableHandle = metadata.getTableHandle(\n+                context.getSession(),\n+                convertFromSchemaTableName(destinationTable.getCatalogName()).apply(destinationTable.getSchemaTableName()));\n+        if (destinationTableHandle.isEmpty()) {\n+            throw new PrestoException(GENERIC_INTERNAL_ERROR, format(\"Destination table %s from table scan redirection not found\", destinationTable));\n+        }\n+        if (destinationTableHandle.get().equals(scanNode.getTable())) {\n+            return Result.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n+        Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n+        Map<Symbol, ColumnHandle> newAssignments = scanNode.getAssignments().entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, entry -> {\n+                    String destinationColumn = requireNonNull(\n+                            columnMapping.get(entry.getValue()),\n+                            format(\"Did not find mapping for source column %s in table scan redirection\", entry.getValue()));\n+                    return requireNonNull(\n+                            destinationColumnHandles.get(destinationColumn),\n+                            format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+                }));\n+\n+        TupleDomain<ColumnHandle> enforcedConstraint = scanNode.getEnforcedConstraint();\n+        if (enforcedConstraint.isAll()) {\n+            return Result.ofPlanNode(\n+                    new TableScanNode(\n+                            scanNode.getId(),\n+                            destinationTableHandle.get(),\n+                            scanNode.getOutputSymbols(),\n+                            newAssignments,\n+                            enforcedConstraint));\n+        }\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newAssignmentsBuilder = ImmutableMap.<Symbol, ColumnHandle>builder()\n+                .putAll(newAssignments);\n+        ImmutableList.Builder<Symbol> newOutputSymbolsBuilder = ImmutableList.<Symbol>builder()\n+                .addAll(scanNode.getOutputSymbols());\n+        Map<ColumnHandle, Symbol> assignments = ImmutableBiMap.copyOf(scanNode.getAssignments()).inverse();\n+        TupleDomain<Symbol> transformedFilters = enforcedConstraint.transform(sourceColumnHandle -> {\n+            Symbol symbol = assignments.get(sourceColumnHandle);\n+            if (symbol == null) {\n+                // Column pruning after PPD into table scan can remove assignments for filter columns from the scan node\n+                String destinationColumn = requireNonNull(\n+                        columnMapping.get(sourceColumnHandle),\n+                        format(\"Did not find mapping for source column %s in table scan redirection\", sourceColumnHandle));", "originalCommit": "f89a975f373ef9d4bac499ae771034783c42ecc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA0NDE2NA==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518044164", "bodyText": "rename to transformedConstraint", "author": "sopel39", "createdAt": "2020-11-05T13:20:06Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.DomainTranslator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isTableScanRedirectionEnabled;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ApplyTableScanRedirection\n+        implements Rule<TableScanNode>\n+{\n+    private static final Pattern<TableScanNode> PATTERN = tableScan();\n+\n+    private final Metadata metadata;\n+    private final DomainTranslator domainTranslator;\n+\n+    public ApplyTableScanRedirection(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.domainTranslator = new DomainTranslator(metadata);\n+    }\n+\n+    @Override\n+    public Pattern<TableScanNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isTableScanRedirectionEnabled(session);\n+    }\n+\n+    @Override\n+    public Result apply(TableScanNode scanNode, Captures captures, Context context)\n+    {\n+        Optional<TableScanRedirectApplicationResult> tableScanRedirectApplicationResult = metadata.applyTableScanRedirect(context.getSession(), scanNode.getTable());\n+        if (tableScanRedirectApplicationResult.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        CatalogSchemaTableName destinationTable = tableScanRedirectApplicationResult.get().getDestinationTable();\n+        Optional<TableHandle> destinationTableHandle = metadata.getTableHandle(\n+                context.getSession(),\n+                convertFromSchemaTableName(destinationTable.getCatalogName()).apply(destinationTable.getSchemaTableName()));\n+        if (destinationTableHandle.isEmpty()) {\n+            throw new PrestoException(GENERIC_INTERNAL_ERROR, format(\"Destination table %s from table scan redirection not found\", destinationTable));\n+        }\n+        if (destinationTableHandle.get().equals(scanNode.getTable())) {\n+            return Result.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n+        Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n+        Map<Symbol, ColumnHandle> newAssignments = scanNode.getAssignments().entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, entry -> {\n+                    String destinationColumn = requireNonNull(\n+                            columnMapping.get(entry.getValue()),\n+                            format(\"Did not find mapping for source column %s in table scan redirection\", entry.getValue()));\n+                    return requireNonNull(\n+                            destinationColumnHandles.get(destinationColumn),\n+                            format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+                }));\n+\n+        TupleDomain<ColumnHandle> enforcedConstraint = scanNode.getEnforcedConstraint();\n+        if (enforcedConstraint.isAll()) {\n+            return Result.ofPlanNode(\n+                    new TableScanNode(\n+                            scanNode.getId(),\n+                            destinationTableHandle.get(),\n+                            scanNode.getOutputSymbols(),\n+                            newAssignments,\n+                            enforcedConstraint));\n+        }\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newAssignmentsBuilder = ImmutableMap.<Symbol, ColumnHandle>builder()\n+                .putAll(newAssignments);\n+        ImmutableList.Builder<Symbol> newOutputSymbolsBuilder = ImmutableList.<Symbol>builder()\n+                .addAll(scanNode.getOutputSymbols());\n+        Map<ColumnHandle, Symbol> assignments = ImmutableBiMap.copyOf(scanNode.getAssignments()).inverse();\n+        TupleDomain<Symbol> transformedFilters = enforcedConstraint.transform(sourceColumnHandle -> {", "originalCommit": "f89a975f373ef9d4bac499ae771034783c42ecc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA1NDk5Mw==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518054993", "bodyText": "extract into separate method", "author": "sopel39", "createdAt": "2020-11-05T13:36:35Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.Constraint;\n+import io.prestosql.spi.connector.ConstraintApplicationResult;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.assertions.PlanAssert;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.optimizations.PlanOptimizer;\n+import io.prestosql.testing.LocalQueryRunner;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Predicates.equalTo;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyFilter;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyProjection;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyTableScanRedirect;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.planner.LogicalPlanner.Stage.OPTIMIZED_AND_VALIDATED;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.expression;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.output;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestTableScanRedirectionWithPushdown\n+{\n+    private static final String MOCK_CATALOG = \"mock_catalog\";\n+    private static final String TEST_SCHEMA = \"test_schema\";\n+    private static final String TEST_TABLE = \"test_table\";\n+    private static final SchemaTableName sourceTable = new SchemaTableName(TEST_SCHEMA, TEST_TABLE);\n+\n+    private static final Session MOCK_SESSION = testSessionBuilder().setCatalog(MOCK_CATALOG).setSchema(TEST_SCHEMA).build();\n+\n+    private static final String sourceColumnNameA = \"source_col_a\";\n+    private static final ColumnHandle sourceColumnHandleA = new MockConnectorColumnHandle(sourceColumnNameA, INTEGER);\n+    private static final String sourceColumnNameB = \"source_col_b\";\n+    private static final ColumnHandle sourceColumnHandleB = new MockConnectorColumnHandle(sourceColumnNameB, INTEGER);\n+\n+    private static final SchemaTableName destinationTable = new SchemaTableName(\"target_schema\", \"target_table\");\n+    private static final String destinationColumnNameA = \"destination_col_a\";\n+    private static final ColumnHandle destinationColumnHandleA = new MockConnectorColumnHandle(destinationColumnNameA, INTEGER);\n+    private static final String destinationColumnNameB = \"destination_col_b\";\n+    private static final ColumnHandle destinationColumnHandleB = new MockConnectorColumnHandle(destinationColumnNameB, INTEGER);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingA = ImmutableMap.of(sourceColumnHandleA, destinationColumnNameA);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingAB = ImmutableMap.of(\n+            sourceColumnHandleA, destinationColumnNameA,\n+            sourceColumnHandleB, destinationColumnNameB);\n+\n+    @Test\n+    public void testRedirectionAfterProjectionPushdown()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect that source_col_a is projected\n+        ApplyTableScanRedirect tableScanRedirection =\n+                (session, handle) -> {", "originalCommit": "f89a975f373ef9d4bac499ae771034783c42ecc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA1NjUzOQ==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518056539", "bodyText": "redundant test? what does projection change here?", "author": "sopel39", "createdAt": "2020-11-05T13:39:02Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.Constraint;\n+import io.prestosql.spi.connector.ConstraintApplicationResult;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.assertions.PlanAssert;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.optimizations.PlanOptimizer;\n+import io.prestosql.testing.LocalQueryRunner;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Predicates.equalTo;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyFilter;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyProjection;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyTableScanRedirect;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.planner.LogicalPlanner.Stage.OPTIMIZED_AND_VALIDATED;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.expression;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.output;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestTableScanRedirectionWithPushdown\n+{\n+    private static final String MOCK_CATALOG = \"mock_catalog\";\n+    private static final String TEST_SCHEMA = \"test_schema\";\n+    private static final String TEST_TABLE = \"test_table\";\n+    private static final SchemaTableName sourceTable = new SchemaTableName(TEST_SCHEMA, TEST_TABLE);\n+\n+    private static final Session MOCK_SESSION = testSessionBuilder().setCatalog(MOCK_CATALOG).setSchema(TEST_SCHEMA).build();\n+\n+    private static final String sourceColumnNameA = \"source_col_a\";\n+    private static final ColumnHandle sourceColumnHandleA = new MockConnectorColumnHandle(sourceColumnNameA, INTEGER);\n+    private static final String sourceColumnNameB = \"source_col_b\";\n+    private static final ColumnHandle sourceColumnHandleB = new MockConnectorColumnHandle(sourceColumnNameB, INTEGER);\n+\n+    private static final SchemaTableName destinationTable = new SchemaTableName(\"target_schema\", \"target_table\");\n+    private static final String destinationColumnNameA = \"destination_col_a\";\n+    private static final ColumnHandle destinationColumnHandleA = new MockConnectorColumnHandle(destinationColumnNameA, INTEGER);\n+    private static final String destinationColumnNameB = \"destination_col_b\";\n+    private static final ColumnHandle destinationColumnHandleB = new MockConnectorColumnHandle(destinationColumnNameB, INTEGER);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingA = ImmutableMap.of(sourceColumnHandleA, destinationColumnNameA);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingAB = ImmutableMap.of(\n+            sourceColumnHandleA, destinationColumnNameA,\n+            sourceColumnHandleB, destinationColumnNameB);\n+\n+    @Test\n+    public void testRedirectionAfterProjectionPushdown()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect that source_col_a is projected\n+        ApplyTableScanRedirect tableScanRedirection =\n+                (session, handle) -> {\n+                    MockConnectorTableHandle mockConnectorTable = (MockConnectorTableHandle) handle;\n+                    Optional<List<ColumnHandle>> projectedColumns = mockConnectorTable.getColumns();\n+                    if (projectedColumns.isEmpty()) {\n+                        return Optional.empty();\n+                    }\n+                    List<String> projectedColumnNames = projectedColumns.get().stream()\n+                            .map(MockConnectorColumnHandle.class::cast)\n+                            .map(MockConnectorColumnHandle::getName)\n+                            .collect(toImmutableList());\n+                    if (!projectedColumnNames.equals(ImmutableList.of(sourceColumnNameA))) {\n+                        return Optional.empty();\n+                    }\n+                    return Optional.of(\n+                            new TableScanRedirectApplicationResult(\n+                                    new CatalogSchemaTableName(MOCK_CATALOG, destinationTable),\n+                                    redirectionMappingA));\n+                };\n+\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(tableScanRedirection, Optional.of(this::mockApplyProjection), Optional.empty())) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\"target_table\", ImmutableMap.of(\"DEST_COL\", destinationColumnNameA))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a, source_col_b FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COLA\", \"SOURCE_COLB\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COLA\", sourceColumnNameA, \"SOURCE_COLB\", sourceColumnNameB))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a > 0\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            filter(\n+                                    \"DEST_COL > 0\",\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.all(),\n+                                            ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testRedirectionAfterPredicatePushdownIntoTableScan()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect a filter\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingA),\n+                Optional.empty(),\n+                Optional.of(this::mockApplyFilter))) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a = 1\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\n+                                    equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                    TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleA), singleValue(INTEGER, 1L))),\n+                                    ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA)))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COL\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COL\", sourceColumnNameA))));\n+\n+            assertPlan(", "originalCommit": "f89a975f373ef9d4bac499ae771034783c42ecc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODEwMzc3NA==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518103774", "bodyText": "removed, it wasn't testing anything extra", "author": "raunaqmorarka", "createdAt": "2020-11-05T14:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA1NjUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA1OTczNw==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518059737", "bodyText": "I think it should be:\nProject('dest_col_b') -> Filter('dest_col_a = 1') -> TableScan", "author": "sopel39", "createdAt": "2020-11-05T13:43:45Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.Constraint;\n+import io.prestosql.spi.connector.ConstraintApplicationResult;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.assertions.PlanAssert;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.optimizations.PlanOptimizer;\n+import io.prestosql.testing.LocalQueryRunner;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Predicates.equalTo;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyFilter;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyProjection;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyTableScanRedirect;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.planner.LogicalPlanner.Stage.OPTIMIZED_AND_VALIDATED;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.expression;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.output;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestTableScanRedirectionWithPushdown\n+{\n+    private static final String MOCK_CATALOG = \"mock_catalog\";\n+    private static final String TEST_SCHEMA = \"test_schema\";\n+    private static final String TEST_TABLE = \"test_table\";\n+    private static final SchemaTableName sourceTable = new SchemaTableName(TEST_SCHEMA, TEST_TABLE);\n+\n+    private static final Session MOCK_SESSION = testSessionBuilder().setCatalog(MOCK_CATALOG).setSchema(TEST_SCHEMA).build();\n+\n+    private static final String sourceColumnNameA = \"source_col_a\";\n+    private static final ColumnHandle sourceColumnHandleA = new MockConnectorColumnHandle(sourceColumnNameA, INTEGER);\n+    private static final String sourceColumnNameB = \"source_col_b\";\n+    private static final ColumnHandle sourceColumnHandleB = new MockConnectorColumnHandle(sourceColumnNameB, INTEGER);\n+\n+    private static final SchemaTableName destinationTable = new SchemaTableName(\"target_schema\", \"target_table\");\n+    private static final String destinationColumnNameA = \"destination_col_a\";\n+    private static final ColumnHandle destinationColumnHandleA = new MockConnectorColumnHandle(destinationColumnNameA, INTEGER);\n+    private static final String destinationColumnNameB = \"destination_col_b\";\n+    private static final ColumnHandle destinationColumnHandleB = new MockConnectorColumnHandle(destinationColumnNameB, INTEGER);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingA = ImmutableMap.of(sourceColumnHandleA, destinationColumnNameA);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingAB = ImmutableMap.of(\n+            sourceColumnHandleA, destinationColumnNameA,\n+            sourceColumnHandleB, destinationColumnNameB);\n+\n+    @Test\n+    public void testRedirectionAfterProjectionPushdown()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect that source_col_a is projected\n+        ApplyTableScanRedirect tableScanRedirection =\n+                (session, handle) -> {\n+                    MockConnectorTableHandle mockConnectorTable = (MockConnectorTableHandle) handle;\n+                    Optional<List<ColumnHandle>> projectedColumns = mockConnectorTable.getColumns();\n+                    if (projectedColumns.isEmpty()) {\n+                        return Optional.empty();\n+                    }\n+                    List<String> projectedColumnNames = projectedColumns.get().stream()\n+                            .map(MockConnectorColumnHandle.class::cast)\n+                            .map(MockConnectorColumnHandle::getName)\n+                            .collect(toImmutableList());\n+                    if (!projectedColumnNames.equals(ImmutableList.of(sourceColumnNameA))) {\n+                        return Optional.empty();\n+                    }\n+                    return Optional.of(\n+                            new TableScanRedirectApplicationResult(\n+                                    new CatalogSchemaTableName(MOCK_CATALOG, destinationTable),\n+                                    redirectionMappingA));\n+                };\n+\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(tableScanRedirection, Optional.of(this::mockApplyProjection), Optional.empty())) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\"target_table\", ImmutableMap.of(\"DEST_COL\", destinationColumnNameA))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a, source_col_b FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COLA\", \"SOURCE_COLB\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COLA\", sourceColumnNameA, \"SOURCE_COLB\", sourceColumnNameB))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a > 0\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            filter(\n+                                    \"DEST_COL > 0\",\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.all(),\n+                                            ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testRedirectionAfterPredicatePushdownIntoTableScan()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect a filter\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingA),\n+                Optional.empty(),\n+                Optional.of(this::mockApplyFilter))) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a = 1\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\n+                                    equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                    TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleA), singleValue(INTEGER, 1L))),\n+                                    ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA)))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COL\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COL\", sourceColumnNameA))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT (2 * source_col_a) + 1 FROM test_table WHERE source_col_a = 1\",\n+                    output(\n+                            ImmutableList.of(\"expr\"),\n+                            project(\n+                                    ImmutableMap.of(\"expr\", expression(\"(DEST_COL * 2) + 1\")),\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleA), singleValue(INTEGER, 1L))),\n+                                            ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testPredicatePushdownAfterRedirect()\n+    {\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingAB),\n+                Optional.empty(),\n+                Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleA, destinationColumnHandleB))))) {\n+            // Only 'source_col_a = 1' will get pushed down into source table scan\n+            // Only 'source_col_b = 2' will get pushed down into destination table scan\n+            // This test verifies that the Filter('source_col_a = 1') produced by redirection\n+            // does not prevent pushdown of 'source_col_b = 2' into destination table scan\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a, source_col_b FROM test_table WHERE source_col_a = 1 AND source_col_b = 2\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL_A\", \"DEST_COL_B\"),\n+                            filter(\n+                                    \"DEST_COL_A = 1\",\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleB), singleValue(INTEGER, 2L))),\n+                                            ImmutableMap.of(\n+                                                    \"DEST_COL_A\", equalTo(destinationColumnHandleA),\n+                                                    \"DEST_COL_B\", equalTo(destinationColumnHandleB))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testRedirectAfterColumnPruningOnPushedDownPredicate()\n+    {\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingAB),\n+                Optional.of(this::mockApplyProjection),\n+                Optional.of(this::mockApplyFilter))) {\n+            // After 'source_col_a = 1' is pushed into source table scan, it's possible for 'source_col_a' table scan assignment to be pruned\n+            // Redirection results in Project('source_col_b') -> Filter('source_col_a = 1') -> TableScan for such case", "originalCommit": "f89a975f373ef9d4bac499ae771034783c42ecc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA3MDE2NQ==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518070165", "bodyText": "extract this into utility method if possible", "author": "sopel39", "createdAt": "2020-11-05T13:58:37Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestApplyTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.rule.test.RuleTester;\n+import io.prestosql.testing.TestingTransactionHandle;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static com.google.common.base.Predicates.equalTo;\n+import static io.airlift.slice.Slices.utf8Slice;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyTableScanRedirect;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.expression;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static io.prestosql.sql.planner.iterative.rule.test.RuleTester.defaultRuleTester;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestApplyTableScanRedirection\n+{\n+    private static final String MOCK_CATALOG = \"mock_catalog\";\n+    private static final String TEST_SCHEMA = \"test_schema\";\n+    private static final String TEST_TABLE = \"test_table\";\n+    private static final SchemaTableName sourceTable = new SchemaTableName(TEST_SCHEMA, TEST_TABLE);\n+    private static final TableHandle TEST_TABLE_HANDLE = createTableHandle(new MockConnectorTableHandle(sourceTable));\n+\n+    private static final Session MOCK_SESSION = testSessionBuilder().setCatalog(MOCK_CATALOG).setSchema(TEST_SCHEMA).build();\n+\n+    private static final String sourceColumnNameA = \"source_col_a\";\n+    private static final ColumnHandle sourceColumnHandleA = new MockConnectorColumnHandle(sourceColumnNameA, INTEGER);\n+    private static final String sourceColumnNameB = \"source_col_b\";\n+    private static final ColumnHandle sourceColumnHandleB = new MockConnectorColumnHandle(sourceColumnNameB, INTEGER);\n+\n+    private static final SchemaTableName destinationTable = new SchemaTableName(\"target_schema\", \"target_table\");\n+    private static final String destinationColumnNameA = \"destination_col_a\";\n+    private static final ColumnHandle destinationColumnHandleA = new MockConnectorColumnHandle(destinationColumnNameA, INTEGER);\n+    private static final String destinationColumnNameB = \"destination_col_b\";\n+    private static final ColumnHandle destinationColumnHandleB = new MockConnectorColumnHandle(destinationColumnNameB, INTEGER);\n+\n+    private static TableHandle createTableHandle(ConnectorTableHandle tableHandle)\n+    {\n+        return new TableHandle(\n+                new CatalogName(MOCK_CATALOG),\n+                tableHandle,\n+                TestingTransactionHandle.create(),\n+                Optional.empty());\n+    }\n+\n+    @Test\n+    public void testDoesNotFire()\n+    {\n+        try (RuleTester ruleTester = defaultRuleTester()) {\n+            MockConnectorFactory mockFactory = createMockFactory(Optional.empty());\n+            ruleTester.getQueryRunner().createCatalog(MOCK_CATALOG, mockFactory, ImmutableMap.of());\n+\n+            ruleTester.assertThat(new ApplyTableScanRedirection(ruleTester.getMetadata()))\n+                    .on(p -> {\n+                        Symbol column = p.symbol(sourceColumnNameA, VARCHAR);\n+                        return p.tableScan(TEST_TABLE_HANDLE,\n+                                        ImmutableList.of(column),\n+                                        ImmutableMap.of(column, sourceColumnHandleA));\n+                    })\n+                    .withSession(MOCK_SESSION)\n+                    .doesNotFire();\n+        }\n+    }\n+\n+    @Test\n+    public void doesNotFireIfNoTableScan()\n+    {\n+        try (RuleTester ruleTester = defaultRuleTester()) {\n+            ApplyTableScanRedirect applyTableScanRedirect =\n+                    (session, handle) -> Optional.of(", "originalCommit": "f89a975f373ef9d4bac499ae771034783c42ecc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7637be1d92ee009198f89680ef2b913b325bc9c1", "url": "https://github.com/trinodb/trino/commit/7637be1d92ee009198f89680ef2b913b325bc9c1", "message": "Add applyTableScanRedirect SPI and ApplyTableScanRedirection rule\n\nAllows connectors to offload table scans to any other connector during\nthe plan optimization phase. The connector may choose to delegate\nbased on criteria like selected columns and applied predicates.", "committedDate": "2020-11-17T15:54:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1MzAwMg==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r525953002", "bodyText": "technically, there doesn't have to be an inverse mapping for destinationColumn here, e.g this could be predicate on some other, new column", "author": "sopel39", "createdAt": "2020-11-18T09:53:41Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.DomainTranslator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static io.prestosql.spi.StandardErrorCode.COLUMN_NOT_FOUND;\n+import static io.prestosql.spi.StandardErrorCode.TABLE_NOT_FOUND;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ApplyTableScanRedirection\n+        implements Rule<TableScanNode>\n+{\n+    private static final Pattern<TableScanNode> PATTERN = tableScan();\n+\n+    private final Metadata metadata;\n+    private final DomainTranslator domainTranslator;\n+\n+    public ApplyTableScanRedirection(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.domainTranslator = new DomainTranslator(metadata);\n+    }\n+\n+    @Override\n+    public Pattern<TableScanNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(TableScanNode scanNode, Captures captures, Context context)\n+    {\n+        Optional<TableScanRedirectApplicationResult> tableScanRedirectApplicationResult = metadata.applyTableScanRedirect(context.getSession(), scanNode.getTable());\n+        if (tableScanRedirectApplicationResult.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        CatalogSchemaTableName destinationTable = tableScanRedirectApplicationResult.get().getDestinationTable();\n+        Optional<TableHandle> destinationTableHandle = metadata.getTableHandle(\n+                context.getSession(),\n+                convertFromSchemaTableName(destinationTable.getCatalogName()).apply(destinationTable.getSchemaTableName()));\n+        if (destinationTableHandle.isEmpty()) {\n+            throw new PrestoException(TABLE_NOT_FOUND, format(\"Destination table %s from table scan redirection not found\", destinationTable));\n+        }\n+        if (destinationTableHandle.get().equals(scanNode.getTable())) {\n+            return Result.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n+        Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n+        Map<Symbol, ColumnHandle> newAssignments = scanNode.getAssignments().entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, entry -> {\n+                    String destinationColumn = columnMapping.get(entry.getValue());\n+                    if (destinationColumn == null) {\n+                        throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find mapping for source column %s in table scan redirection\", entry.getValue()));\n+                    }\n+                    ColumnHandle destinationColumnHandle = destinationColumnHandles.get(destinationColumn);\n+                    if (destinationColumnHandle == null) {\n+                        throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+                    }\n+                    return destinationColumnHandle;\n+                }));\n+\n+        TupleDomain<String> requiredFilter = tableScanRedirectApplicationResult.get().getFilter();\n+        if (requiredFilter.isAll()) {\n+            return Result.ofPlanNode(\n+                    new TableScanNode(\n+                            scanNode.getId(),\n+                            destinationTableHandle.get(),\n+                            scanNode.getOutputSymbols(),\n+                            newAssignments,\n+                            TupleDomain.all(),\n+                            scanNode.isForDelete()));\n+        }\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newAssignmentsBuilder = ImmutableMap.<Symbol, ColumnHandle>builder()\n+                .putAll(newAssignments);\n+        ImmutableList.Builder<Symbol> newOutputSymbolsBuilder = ImmutableList.<Symbol>builder()\n+                .addAll(scanNode.getOutputSymbols());\n+        Map<ColumnHandle, Symbol> inverseAssignments = ImmutableBiMap.copyOf(scanNode.getAssignments()).inverse();\n+        Map<String, ColumnHandle> inverseColumnsMapping = ImmutableBiMap.copyOf(columnMapping).inverse();\n+        TupleDomain<Symbol> transformedConstraint = requiredFilter.transform(destinationColumn -> {\n+            ColumnHandle sourceColumnHandle = inverseColumnsMapping.get(destinationColumn);\n+            if (sourceColumnHandle == null) {", "originalCommit": "7637be1d92ee009198f89680ef2b913b325bc9c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0aca274b196608b223193e8636b4a0692acc2063", "url": "https://github.com/trinodb/trino/commit/0aca274b196608b223193e8636b4a0692acc2063", "message": "Implement table scan redirection in TPCH connector", "committedDate": "2020-11-18T10:40:10Z", "type": "commit"}, {"oid": "3c76c2029805c734bfbf0e5c83c46d921c7c8df7", "url": "https://github.com/trinodb/trino/commit/3c76c2029805c734bfbf0e5c83c46d921c7c8df7", "message": "Implement applyTableScanRedirect API in JdbcMetadata", "committedDate": "2020-11-18T10:40:15Z", "type": "commit"}, {"oid": "3c76c2029805c734bfbf0e5c83c46d921c7c8df7", "url": "https://github.com/trinodb/trino/commit/3c76c2029805c734bfbf0e5c83c46d921c7c8df7", "message": "Implement applyTableScanRedirect API in JdbcMetadata", "committedDate": "2020-11-18T10:40:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNTQ5MTkxNA==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r635491914", "bodyText": "it's not guaranteed, since ApplyTableScanRedirection and PushPredicateIntoTableScan are part of one IterativeOptimizer. Did you intend to have them as two separate optimizers? if not, i don't know how to interpret this comment", "author": "findepi", "createdAt": "2021-05-19T18:35:18Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/PlanOptimizers.java", "diffHunk": "@@ -537,6 +538,21 @@ public PlanOptimizers(\n                         estimatedExchangesCostCalculator,\n                         ImmutableSet.of(new TransformFilteringSemiJoinToInnerJoin()))); // must run after PredicatePushDown\n \n+        // Perform redirection before CBO rules to ensure stats from destination connector are used\n+        // Perform redirection before agg, topN, limit, sample etc. push down into table scan as the destination connector may support a different set of push downs\n+        // Perform redirection after at least one PredicatePushDown and PushPredicateIntoTableScan to allow connector to use pushed down predicates in redirection decision\n+        // Perform redirection after at least table scan pruning rules because redirected table might have fewer columns\n+        // PushPredicateIntoTableScan must be run after redirection", "originalCommit": "3c76c2029805c734bfbf0e5c83c46d921c7c8df7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNTk5NDMwMg==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r635994302", "bodyText": "As part of table scan redirection, we take predicates which were pushed down into source table scan and create a filter node on top of the target table scan node. Now we need to re-run PushPredicateIntoTableScan to allow this new filter node to be pushed down into the target table scan. This was done because target connector's predicate pushdown capability might be different to source connector's.\nWe are running pushIntoTableScanOptimizer next, so I thought that will ensure PPD into TS and satisfy the above requirement.", "author": "raunaqmorarka", "createdAt": "2021-05-20T10:56:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNTQ5MTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjE1NDI5Mg==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r636154292", "bodyText": "i read \"must be run after redirection\" as \"must not be run before\", while you're saying \"it needs to be run again afterwards\"\ncan you please consider rewording?", "author": "findepi", "createdAt": "2021-05-20T14:23:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNTQ5MTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjE2NzE3OA==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r636167178", "bodyText": "oh, i see now, ya PushPredicateIntoTableScan needs to be run again after redirection is more accurate, I'll update it", "author": "raunaqmorarka", "createdAt": "2021-05-20T14:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNTQ5MTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjI1NjYxMQ==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r636256611", "bodyText": "created #8002\nPTAL", "author": "raunaqmorarka", "createdAt": "2021-05-20T16:16:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNTQ5MTkxNA=="}], "type": "inlineReview"}]}