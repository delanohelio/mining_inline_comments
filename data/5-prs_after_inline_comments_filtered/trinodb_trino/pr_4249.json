{"pr_number": 4249, "pr_title": "SPI and optimizer rule for connectors that can support complete topN \u2026", "pr_createdAt": "2020-06-26T21:35:49Z", "pr_url": "https://github.com/trinodb/trino/pull/4249", "timeline": [{"oid": "9c94323428ea17bd492b0e809456dc2b164ba009", "url": "https://github.com/trinodb/trino/commit/9c94323428ea17bd492b0e809456dc2b164ba009", "message": "Add support for TopN pushdown", "committedDate": "2020-08-05T03:40:07Z", "type": "commit"}, {"oid": "9c94323428ea17bd492b0e809456dc2b164ba009", "url": "https://github.com/trinodb/trino/commit/9c94323428ea17bd492b0e809456dc2b164ba009", "message": "Add support for TopN pushdown", "committedDate": "2020-08-05T03:40:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDk3NDA5NQ==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r580974095", "bodyText": "I think this should trigger no SINGLE step only.\nWe should not push partial and final separately (and IMO -- we should not push them at all)", "author": "findepi", "createdAt": "2021-02-23T11:52:56Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushTopNIntoTableScan.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortItem;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.planner.plan.TopNNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static io.prestosql.sql.planner.plan.Patterns.topN;\n+\n+public class PushTopNIntoTableScan\n+        implements Rule<TopNNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<TopNNode> PATTERN = topN().with(source().matching(\n+            tableScan().capturedAs(TABLE_SCAN)));", "originalCommit": "9c94323428ea17bd492b0e809456dc2b164ba009", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDk3ODY5OQ==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r580978699", "bodyText": "This should be added to pushIntoTableScanOptimizer, when other PushXxxIntoTableScan rules are registered.\nThis is important for two reasons:\n\nthis will unlock other pushdowns once TopN is pushed into TableScan fully\nthis will let the rule operate on TopNNode while it is SINGLE step (and consume it fully), making reasoning about engine-connector interactions simpler\n\n@wendigo is going to address this in #6847", "author": "findepi", "createdAt": "2021-02-23T12:00:24Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/PlanOptimizers.java", "diffHunk": "@@ -623,7 +624,8 @@ public PlanOptimizers(\n                         new CreatePartialTopN(),\n                         new PushTopNThroughProject(),\n                         new PushTopNThroughOuterJoin(),\n-                        new PushTopNThroughUnion())));\n+                        new PushTopNThroughUnion(),\n+                        new PushTopNIntoTableScan(metadata))));", "originalCommit": "9c94323428ea17bd492b0e809456dc2b164ba009", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDk4MDcwMg==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r580980702", "bodyText": "Relates  to #4249 (comment)\nInserting FINAL step is not correct when the rule triggered on TopNNode with Step PARTIAL.\nI suggest\n\nmake the rule trigger for SINGLE step only (my preferred)\n\ni am aware sibling PushLimitIntoTableScan triggers for partial limits, but i am not convinced it is beneficial\n\n\nkeep same step as it used to be used (basically, use topNNode.replaceChildren)\n\n(this is not being addressed in @wendigo #6847)", "author": "findepi", "createdAt": "2021-02-23T12:03:55Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushTopNIntoTableScan.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortItem;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.planner.plan.TopNNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static io.prestosql.sql.planner.plan.Patterns.topN;\n+\n+public class PushTopNIntoTableScan\n+        implements Rule<TopNNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<TopNNode> PATTERN = topN().with(source().matching(\n+            tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushTopNIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<TopNNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(TopNNode topNNode, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+\n+        long topNCount = topNNode.getCount();\n+        List<SortItem> sortItems = topNNode.getOrderingScheme().toSortItems();\n+\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+\n+        return metadata.applyTopN(context.getSession(), tableScan.getTable(), topNCount, sortItems, assignments)\n+                .map(result -> {\n+                    PlanNode node = TableScanNode.newInstance(\n+                            context.getIdAllocator().getNextId(),\n+                            result.getHandle(),\n+                            tableScan.getOutputSymbols(),\n+                            tableScan.getAssignments());\n+\n+                    if (!result.isTopNGuaranteed()) {\n+                        node = new TopNNode(topNNode.getId(), node, topNNode.getCount(), topNNode.getOrderingScheme(), TopNNode.Step.FINAL);", "originalCommit": "9c94323428ea17bd492b0e809456dc2b164ba009", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}