{"pr_number": 2672, "pr_title": "Dereference Projection Pushdown in Query Plan", "pr_createdAt": "2020-01-29T21:34:43Z", "pr_url": "https://github.com/trinodb/trino/pull/2672", "timeline": [{"oid": "5259429e761205470cdb0ff1d0747b15fe10378b", "url": "https://github.com/trinodb/trino/commit/5259429e761205470cdb0ff1d0747b15fe10378b", "message": "(drop this commit) Verify behavior of TestDereferencePushdown tests in hive", "committedDate": "2020-04-22T04:49:27Z", "type": "forcePushed"}, {"oid": "86e5d867cf745a1e010a1dcb1b2d4971470e62a5", "url": "https://github.com/trinodb/trino/commit/86e5d867cf745a1e010a1dcb1b2d4971470e62a5", "message": "(drop this commit before merging) Verify behavior of TestDereferencePushdown tests in hive", "committedDate": "2020-05-06T17:59:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIyMzI4Nw==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423223287", "bodyText": "Referring to this as \"dereference chain\" is more idiomatic.", "author": "martint", "createdAt": "2020-05-11T18:06:32Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/DereferencePushdown.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.tree.DefaultExpressionTraversalVisitor;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.LambdaExpression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractAll;\n+\n+/**\n+ * Provides helper methods to push down dereferences in the query plan.\n+ */\n+class DereferencePushdown\n+{\n+    private DereferencePushdown() {}\n+\n+    /**\n+     * Create new symbols for dereference expressions extracted from {@param expressions}\n+     */\n+    public static Map<DereferenceExpression, Symbol> validDereferences(\n+            Collection<Expression> expressions,\n+            Rule.Context context,\n+            TypeAnalyzer typeAnalyzer,\n+            boolean noOverlap)\n+    {\n+        Set<Expression> symbolReferencesAndDereferences = expressions.stream()\n+                .flatMap(expression -> getSymbolReferencesAndDereferences(expression).stream())\n+                .collect(Collectors.toSet());\n+\n+        // Remove overlap if required\n+        Set<Expression> candidateExpressions = symbolReferencesAndDereferences;\n+        if (noOverlap) {\n+            candidateExpressions = symbolReferencesAndDereferences.stream()\n+                    .filter(expression -> !prefixExists(expression, symbolReferencesAndDereferences))\n+                    .collect(Collectors.toSet());\n+        }\n+\n+        Set<DereferenceExpression> dereferencesToPushdown = candidateExpressions.stream()\n+                .filter(expression -> (expression instanceof DereferenceExpression))\n+                .map(expression -> (DereferenceExpression) expression)\n+                .collect(Collectors.toSet());\n+\n+        return dereferencesToPushdown.stream()\n+                .collect(toImmutableMap(Function.identity(), expression -> newSymbol(expression, context, typeAnalyzer)));\n+    }\n+\n+    public static Symbol getBase(DereferenceExpression expression)\n+    {\n+        return getOnlyElement(extractAll(expression));\n+    }\n+\n+    /**\n+     * Extract the sub-expressions of type {@link DereferenceExpression} or {@link SymbolReference} from the {@param expression}\n+     * in a top-down manner. The expressions within the base of a valid {@link DereferenceExpression} sequence are not extracted.\n+     */\n+    private static List<Expression> getSymbolReferencesAndDereferences(Expression expression)\n+    {\n+        ImmutableList.Builder<Expression> builder = ImmutableList.builder();\n+\n+        new DefaultExpressionTraversalVisitor<ImmutableList.Builder<Expression>>()\n+        {\n+            @Override\n+            protected Void visitDereferenceExpression(DereferenceExpression node, ImmutableList.Builder<Expression> context)\n+            {\n+                if (isDereferenceSequence(node)) {\n+                    context.add(node);\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            protected Void visitSymbolReference(SymbolReference node, ImmutableList.Builder<Expression> context)\n+            {\n+                context.add(node);\n+                return null;\n+            }\n+\n+            @Override\n+            protected Void visitLambdaExpression(LambdaExpression node, ImmutableList.Builder<Expression> context)\n+            {\n+                return null;\n+            }\n+        }.process(expression, builder);\n+\n+        return builder.build();\n+    }\n+\n+    private static boolean isDereferenceSequence(DereferenceExpression expression)", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIyNjczMA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423226730", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .filter(expression -> (expression instanceof DereferenceExpression))\n          \n          \n            \n                            .map(expression -> (DereferenceExpression) expression)\n          \n          \n            \n                            .filter(DereferenceExpression.class::isInstance)\n          \n          \n            \n                            .map(DereferenceExpression.class::cast)", "author": "martint", "createdAt": "2020-05-11T18:12:42Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/DereferencePushdown.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.tree.DefaultExpressionTraversalVisitor;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.LambdaExpression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractAll;\n+\n+/**\n+ * Provides helper methods to push down dereferences in the query plan.\n+ */\n+class DereferencePushdown\n+{\n+    private DereferencePushdown() {}\n+\n+    /**\n+     * Create new symbols for dereference expressions extracted from {@param expressions}\n+     */\n+    public static Map<DereferenceExpression, Symbol> validDereferences(\n+            Collection<Expression> expressions,\n+            Rule.Context context,\n+            TypeAnalyzer typeAnalyzer,\n+            boolean noOverlap)\n+    {\n+        Set<Expression> symbolReferencesAndDereferences = expressions.stream()\n+                .flatMap(expression -> getSymbolReferencesAndDereferences(expression).stream())\n+                .collect(Collectors.toSet());\n+\n+        // Remove overlap if required\n+        Set<Expression> candidateExpressions = symbolReferencesAndDereferences;\n+        if (noOverlap) {\n+            candidateExpressions = symbolReferencesAndDereferences.stream()\n+                    .filter(expression -> !prefixExists(expression, symbolReferencesAndDereferences))\n+                    .collect(Collectors.toSet());\n+        }\n+\n+        Set<DereferenceExpression> dereferencesToPushdown = candidateExpressions.stream()\n+                .filter(expression -> (expression instanceof DereferenceExpression))\n+                .map(expression -> (DereferenceExpression) expression)", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIzNTIxNw==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423235217", "bodyText": "Pass the session and symbol allocator directly instead of Rule.Context. Creating a symbol does not inherently need a rule context.", "author": "martint", "createdAt": "2020-05-11T18:28:04Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/DereferencePushdown.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.tree.DefaultExpressionTraversalVisitor;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.LambdaExpression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractAll;\n+\n+/**\n+ * Provides helper methods to push down dereferences in the query plan.\n+ */\n+class DereferencePushdown\n+{\n+    private DereferencePushdown() {}\n+\n+    /**\n+     * Create new symbols for dereference expressions extracted from {@param expressions}\n+     */\n+    public static Map<DereferenceExpression, Symbol> validDereferences(\n+            Collection<Expression> expressions,\n+            Rule.Context context,\n+            TypeAnalyzer typeAnalyzer,\n+            boolean noOverlap)\n+    {\n+        Set<Expression> symbolReferencesAndDereferences = expressions.stream()\n+                .flatMap(expression -> getSymbolReferencesAndDereferences(expression).stream())\n+                .collect(Collectors.toSet());\n+\n+        // Remove overlap if required\n+        Set<Expression> candidateExpressions = symbolReferencesAndDereferences;\n+        if (noOverlap) {\n+            candidateExpressions = symbolReferencesAndDereferences.stream()\n+                    .filter(expression -> !prefixExists(expression, symbolReferencesAndDereferences))\n+                    .collect(Collectors.toSet());\n+        }\n+\n+        Set<DereferenceExpression> dereferencesToPushdown = candidateExpressions.stream()\n+                .filter(expression -> (expression instanceof DereferenceExpression))\n+                .map(expression -> (DereferenceExpression) expression)\n+                .collect(Collectors.toSet());\n+\n+        return dereferencesToPushdown.stream()\n+                .collect(toImmutableMap(Function.identity(), expression -> newSymbol(expression, context, typeAnalyzer)));\n+    }\n+\n+    public static Symbol getBase(DereferenceExpression expression)\n+    {\n+        return getOnlyElement(extractAll(expression));\n+    }\n+\n+    /**\n+     * Extract the sub-expressions of type {@link DereferenceExpression} or {@link SymbolReference} from the {@param expression}\n+     * in a top-down manner. The expressions within the base of a valid {@link DereferenceExpression} sequence are not extracted.\n+     */\n+    private static List<Expression> getSymbolReferencesAndDereferences(Expression expression)\n+    {\n+        ImmutableList.Builder<Expression> builder = ImmutableList.builder();\n+\n+        new DefaultExpressionTraversalVisitor<ImmutableList.Builder<Expression>>()\n+        {\n+            @Override\n+            protected Void visitDereferenceExpression(DereferenceExpression node, ImmutableList.Builder<Expression> context)\n+            {\n+                if (isDereferenceSequence(node)) {\n+                    context.add(node);\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            protected Void visitSymbolReference(SymbolReference node, ImmutableList.Builder<Expression> context)\n+            {\n+                context.add(node);\n+                return null;\n+            }\n+\n+            @Override\n+            protected Void visitLambdaExpression(LambdaExpression node, ImmutableList.Builder<Expression> context)\n+            {\n+                return null;\n+            }\n+        }.process(expression, builder);\n+\n+        return builder.build();\n+    }\n+\n+    private static boolean isDereferenceSequence(DereferenceExpression expression)\n+    {\n+        return (expression.getBase() instanceof SymbolReference) ||\n+            ((expression.getBase() instanceof DereferenceExpression) && isDereferenceSequence((DereferenceExpression) (expression.getBase())));\n+    }\n+\n+    private static Symbol newSymbol(Expression expression, Rule.Context context, TypeAnalyzer typeAnalyzer)", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIzNTcwNA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423235704", "bodyText": "It'd be cleaner to split this method into two -- currently it's doing too much:\n\nextractDereferences(Collection<Expression> expressions, boolean noOverlap)\ncreateAssignments(Collection<Expression>,  session, symbolAllocator, typeAnalyzer)\n\nDepending on how the result of the latter is being used, it could even go into the Assignments class and return an Assignments object or builder directly:\npublic static Assignments of(Collection<? extends Expression> expressions, Session session, SymbolAllocator symbolAllocator, TypeAnalyzer typeAnalyzer)\n{\n    Assignments.Builder assignments = Assignments.builder();\n\n    for (Expression expression : expressions) {\n        Type type = typeAnalyzer.getType(session, symbolAllocator.getTypes(), expression);\n        assignments.put(symbolAllocator.newSymbol(expression, type), expression);\n    }                                                                                    \n\n    return assignments.build();\n}", "author": "martint", "createdAt": "2020-05-11T18:28:52Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/DereferencePushdown.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.tree.DefaultExpressionTraversalVisitor;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.LambdaExpression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractAll;\n+\n+/**\n+ * Provides helper methods to push down dereferences in the query plan.\n+ */\n+class DereferencePushdown\n+{\n+    private DereferencePushdown() {}\n+\n+    /**\n+     * Create new symbols for dereference expressions extracted from {@param expressions}\n+     */\n+    public static Map<DereferenceExpression, Symbol> validDereferences(", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI0MTEwNA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423241104", "bodyText": "Switch to allowOverlap. Trying to read double-negatives is more confusing: validaDereferences(...., noOverlap = false) vs validDereferences(..., allowOverlap = true)", "author": "martint", "createdAt": "2020-05-11T18:39:09Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/DereferencePushdown.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.tree.DefaultExpressionTraversalVisitor;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.LambdaExpression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractAll;\n+\n+/**\n+ * Provides helper methods to push down dereferences in the query plan.\n+ */\n+class DereferencePushdown\n+{\n+    private DereferencePushdown() {}\n+\n+    /**\n+     * Create new symbols for dereference expressions extracted from {@param expressions}\n+     */\n+    public static Map<DereferenceExpression, Symbol> validDereferences(\n+            Collection<Expression> expressions,\n+            Rule.Context context,\n+            TypeAnalyzer typeAnalyzer,\n+            boolean noOverlap)", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI1MTg1NA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423251854", "bodyText": "With the suggestions in DereferencePushdown, this could become:\nSet<DereferenceExpression> dereferences = extractDereferences(ImmutableList.of(node.getPredicate()), false);\nif (dereferences.isEmpty()) {\n    return Result.empty();\n}\n\nAssignments assignments = Assignments.of(dereferences, context.getSession(), context.getSymbolAllocator(), typeAnalyzer);\nMap<Expression, SymbolReference> mappings = HashBiMap.create(assignments.getMap())\n        .inverse()\n        .entrySet().stream()\n        .collect(toImmutableMap(Map.Entry::getKey, entry -> entry.getValue().toSymbolReference()));\n\nPlanNode source = node.getSource();\nreturn Result.ofPlanNode(new ProjectNode(\n        context.getIdAllocator().getNextId(),\n        new FilterNode(\n                context.getIdAllocator().getNextId(),\n                new ProjectNode(\n                        context.getIdAllocator().getNextId(),\n                        source,\n                        Assignments.builder()\n                                .putIdentities(source.getOutputSymbols())\n                                .putAll(assignments)\n                                .build()),\n                replaceExpression(node.getPredicate(), mappings)),\n        Assignments.identity(node.getOutputSymbols())));", "author": "martint", "createdAt": "2020-05-11T18:57:53Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/ExtractDereferencesFromFilterAboveScan.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.ExpressionNodeInliner.replaceExpression;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.DereferencePushdown.validDereferences;\n+import static io.prestosql.sql.planner.plan.Patterns.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * This optimizer extracts all dereference expressions from a filter node located above a table scan into a ProjectNode.\n+ *\n+ * Extracting dereferences from a filter (eg. FilterNode(a.x = 5)) can be suboptimal if full columns are being accessed up the\n+ * plan tree (eg. a), because it can result in replicated shuffling of fields (eg. a.x). So it is safer to pushdown dereferences from\n+ * Filter only when there's an explicit projection on top of the filter node (Ref PushDereferencesThroughFilter).\n+ *\n+ * In case of a FilterNode on top of TableScanNode, we want to push all dereferences into a new ProjectNode below, so that\n+ * PushProjectionIntoTableScan optimizer can push those columns in the connector, and provide new column handles for the\n+ * projected subcolumns. PushPredicateIntoTableScan optimizer can then push predicates on these subcolumns into the connector.\n+ */\n+public class ExtractDereferencesFromFilterAboveScan\n+        implements Rule<FilterNode>\n+{\n+    private static final Capture<TableScanNode> CHILD = newCapture();\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public ExtractDereferencesFromFilterAboveScan(TypeAnalyzer typeAnalyzer)\n+    {\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n+    }\n+\n+    @Override\n+    public Pattern<FilterNode> getPattern()\n+    {\n+        return filter()\n+                .with(source().matching(tableScan().capturedAs(CHILD)));\n+    }\n+\n+    @Override\n+    public Result apply(FilterNode node, Captures captures, Context context)\n+    {\n+        BiMap<DereferenceExpression, Symbol> expressions =\n+                HashBiMap.create(validDereferences(ImmutableList.of(node.getPredicate()), context, typeAnalyzer, false));\n+\n+        if (expressions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        PlanNode source = node.getSource();\n+        Assignments assignments = Assignments.builder()\n+                .putIdentities(source.getOutputSymbols())\n+                .putAll(expressions.inverse())\n+                .build();\n+\n+        return Result.ofPlanNode(new ProjectNode(\n+                context.getIdAllocator().getNextId(),\n+                new FilterNode(\n+                        context.getIdAllocator().getNextId(),\n+                        new ProjectNode(context.getIdAllocator().getNextId(), source, assignments),\n+                        replaceExpression(\n+                                node.getPredicate(),\n+                                expressions.entrySet().stream()\n+                                        .collect(toImmutableMap(Map.Entry::getKey, mapping -> mapping.getValue().toSymbolReference())))),\n+                Assignments.identity(node.getOutputSymbols())));\n+    }", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI2MDAyMw==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423260023", "bodyText": "Why not just ExpressionNodeInliner.replaceExpression(filterNode.getPredicate(), <mappings>)?", "author": "martint", "createdAt": "2020-05-11T19:12:54Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferenceThroughFilter.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.ExpressionNodeInliner;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.ExpressionTreeRewriter;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.DereferencePushdown.validDereferences;\n+import static io.prestosql.sql.planner.plan.Patterns.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.project;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Transforms:\n+ * <pre>\n+ *  Project(a_x := a.x, b := b)\n+ *      Filter(a.x.y = 5 AND b.m = 3)\n+ *          Source(a, b)\n+ *  </pre>\n+ * to:\n+ * <pre>\n+ *  Project(a_x := expr, b := b)\n+ *      Filter(expr.y = 5 AND b.m = 3)\n+ *          Project(a := a, b := b, expr := a.x)\n+ *              Source(a, b)\n+ * </pre>\n+ *\n+ * Pushes down dereference projections in project node assignments and filter node predicate.\n+ */\n+public class PushDownDereferenceThroughFilter\n+        implements Rule<ProjectNode>\n+{\n+    private static final Capture<FilterNode> CHILD = newCapture();\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PushDownDereferenceThroughFilter(TypeAnalyzer typeAnalyzer)\n+    {\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n+    }\n+\n+    @Override\n+    public Pattern<ProjectNode> getPattern()\n+    {\n+        return project()\n+                .with(source().matching(filter().capturedAs(CHILD)));\n+    }\n+\n+    @Override\n+    public Result apply(ProjectNode node, Captures captures, Rule.Context context)\n+    {\n+        FilterNode filterNode = captures.get(CHILD);\n+\n+        // Pushdown superset of dereference expressions from projections and filtering predicate\n+        List<Expression> expressions = ImmutableList.<Expression>builder()\n+                .addAll(node.getAssignments().getExpressions())\n+                .add(filterNode.getPredicate())\n+                .build();\n+\n+        Map<DereferenceExpression, Symbol> pushdownDereferences = validDereferences(expressions, context, typeAnalyzer, true);\n+\n+        if (pushdownDereferences.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        PlanNode source = filterNode.getSource();\n+\n+        ProjectNode projectNode = new ProjectNode(\n+                context.getIdAllocator().getNextId(),\n+                source,\n+                Assignments.builder()\n+                    .putIdentities(source.getOutputSymbols())\n+                    .putAll(HashBiMap.create(pushdownDereferences).inverse())\n+                    .build());\n+\n+        ExpressionNodeInliner dereferenceReplacer = new ExpressionNodeInliner(pushdownDereferences.entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, mapping -> mapping.getValue().toSymbolReference())));\n+\n+        PlanNode newFilterNode = new FilterNode(\n+                context.getIdAllocator().getNextId(),\n+                projectNode,\n+                ExpressionTreeRewriter.rewriteWith(dereferenceReplacer, filterNode.getPredicate()));", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI2MjU4NA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423262584", "bodyText": "You can use the Function<Expression, Expression> variant of Assignments.rewrite():\nAssignments assignments = node.getAssignments().rewrite(expression -> replaceExpression(expression, mappings))", "author": "martint", "createdAt": "2020-05-11T19:17:37Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferenceThroughProject.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.HashBiMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.ExpressionNodeInliner;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.DereferencePushdown.getBase;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.DereferencePushdown.validDereferences;\n+import static io.prestosql.sql.planner.plan.Patterns.project;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Transforms:\n+ * <pre>\n+ *  Project(msg_x := msg.x)\n+ *    Project(msg := msg)\n+ *      Source(msg)\n+ *  </pre>\n+ * to:\n+ * <pre>\n+ *  Project(msg_x := symbol)\n+ *    Project(msg := msg, symbol := msg.x)\n+ *      Source(msg)\n+ * </pre>\n+ */\n+public class PushDownDereferenceThroughProject\n+        implements Rule<ProjectNode>\n+{\n+    private static final Capture<ProjectNode> CHILD = newCapture();\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PushDownDereferenceThroughProject(TypeAnalyzer typeAnalyzer)\n+    {\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n+    }\n+\n+    @Override\n+    public Pattern<ProjectNode> getPattern()\n+    {\n+        return project()\n+                .with(source().matching(project().capturedAs(CHILD)));\n+    }\n+\n+    @Override\n+    public Result apply(ProjectNode node, Captures captures, Context context)\n+    {\n+        ProjectNode child = captures.get(CHILD);\n+\n+        // Extract dereferences from assignments for pushdown\n+        Map<DereferenceExpression, Symbol> dereferences = validDereferences(node.getAssignments().getExpressions(), context, typeAnalyzer, true).entrySet().stream()\n+                .filter(entry -> child.getSource().getOutputSymbols().contains(getBase(entry.getKey()))) // exclude dereferences on symbols being synthesized within child\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+        if (dereferences.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        // Prepare new assignments replacing dereferences with new symbols\n+        Assignments assignments = node.getAssignments().rewrite(new ExpressionNodeInliner(dereferences.entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, mapping -> mapping.getValue().toSymbolReference()))));", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM4NjQ4OA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423386488", "bodyText": "It'd be worth adding more projections to the example, otherwise it's not immediately obvious why the rule doesn't just push the whole projection below the limit:\nProject(msg_x := msg.x, y = f(...))\n   Limit\n\n->\n\nProject(msg_x := symbol, y = f(...))\n   Limit\n      Project(msg := msg, symbol := msg.x)\n\nThe same comment applies to all other examples.", "author": "martint", "createdAt": "2020-05-12T00:00:01Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferencesThroughLimit.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.ExpressionNodeInliner;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.LimitNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.DereferencePushdown.validDereferences;\n+import static io.prestosql.sql.planner.plan.Patterns.limit;\n+import static io.prestosql.sql.planner.plan.Patterns.project;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Transforms:\n+ * <pre>\n+ *  Project(msg_x := msg.x)", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ2NzQ1Mg==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423467452", "bodyText": "Why are these commented out? Remove them if no longer relevant", "author": "martint", "createdAt": "2020-05-12T05:18:05Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestPushProjectionThroughUnion.java", "diffHunk": "@@ -73,29 +80,37 @@ public void test()\n                     Symbol a = p.symbol(\"a\");\n                     Symbol b = p.symbol(\"b\");\n                     Symbol c = p.symbol(\"c\");\n+                    Symbol d = p.symbol(\"d\", MSG_TYPE);\n                     Symbol cTimes3 = p.symbol(\"c_times_3\");\n+                    Symbol dX = p.symbol(\"d_x\");\n+                    Symbol z = p.symbol(\"z\", MSG_TYPE);\n+                    Symbol w = p.symbol(\"w\", MSG_TYPE);\n                     return p.project(\n-                            Assignments.of(cTimes3, new ArithmeticBinaryExpression(ArithmeticBinaryExpression.Operator.MULTIPLY, c.toSymbolReference(), new LongLiteral(\"3\"))),\n+                            Assignments.of(\n+                                    cTimes3, new ArithmeticBinaryExpression(ArithmeticBinaryExpression.Operator.MULTIPLY, c.toSymbolReference(), new LongLiteral(\"3\")),\n+                                    dX, PlanBuilder.expression(\"d.x\")),\n                             p.union(\n                                     ImmutableListMultimap.<Symbol, Symbol>builder()\n                                             .put(c, a)\n                                             .put(c, b)\n+                                            .put(d, z)\n+                                            .put(d, w)\n                                             .build(),\n                                     ImmutableList.of(\n-                                            p.values(a),\n-                                            p.values(b))));\n+                                            p.values(a, z),\n+                                            p.values(b, w))));\n                 })\n                 .matches(\n                         union(\n                                 project(\n-                                        ImmutableMap.of(\"a_times_3\", expression(\"a * 3\")),\n-                                        values(ImmutableList.of(\"a\"))),\n+                                        ImmutableMap.of(\"a_times_3\", expression(\"a * 3\"), \"z_x\", expression(\"z.x\")),\n+                                        values(ImmutableList.of(\"a\", \"z\"))),\n                                 project(\n-                                        ImmutableMap.of(\"b_times_3\", expression(\"b * 3\")),\n-                                        values(ImmutableList.of(\"b\"))))\n-                                // verify that data originally on symbols aliased as x1 and x2 is part of exchange output\n-                                .withNumberOfOutputColumns(1)\n-                                .withAlias(\"a_times_3\")\n-                                .withAlias(\"b_times_3\"));\n+                                        ImmutableMap.of(\"b_times_3\", expression(\"b * 3\"), \"w_x\", expression(\"w.x\")),\n+                                        values(ImmutableList.of(\"b\", \"w\")))));\n+//                                // verify that data originally on symbols aliased as x1 and x2 is part of exchange output\n+//                                .withNumberOfOutputColumns(1)\n+//                                .withAlias(\"a_times_3\")\n+//                                .withAlias(\"b_times_3\"));", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6e1e576d234eb7e6d8a876c8ea3576f1766bf02b", "url": "https://github.com/trinodb/trino/commit/6e1e576d234eb7e6d8a876c8ea3576f1766bf02b", "message": "Remove unused method", "committedDate": "2020-05-21T02:06:41Z", "type": "commit"}, {"oid": "8b1ef81409b543076e283aadcab6b30754dc127e", "url": "https://github.com/trinodb/trino/commit/8b1ef81409b543076e283aadcab6b30754dc127e", "message": "Fix error message in WindowNode.Function constructor", "committedDate": "2020-05-21T02:06:41Z", "type": "commit"}, {"oid": "8389ea85979249e9ac2ec20de2a44ee565fb81fe", "url": "https://github.com/trinodb/trino/commit/8389ea85979249e9ac2ec20de2a44ee565fb81fe", "message": "Support multiple unnest outputs in unnest matcher", "committedDate": "2020-05-21T02:06:41Z", "type": "commit"}, {"oid": "0163c39cafa7ad4b6a4e271f19c2d2398707cd5c", "url": "https://github.com/trinodb/trino/commit/0163c39cafa7ad4b6a4e271f19c2d2398707cd5c", "message": "Pushdown dereference expressions in the query plan\n\nCo-authored-by: qqibrow <qqibrow@gmail.com>\nCo-authored-by: Zhenxiao Luo <luoz@uber.com>", "committedDate": "2020-05-21T02:06:41Z", "type": "commit"}, {"oid": "f95f644432676d0b00eaa20a73f4aa980cd87e29", "url": "https://github.com/trinodb/trino/commit/f95f644432676d0b00eaa20a73f4aa980cd87e29", "message": "Plan assertions for end to end dereference pushdown in hive", "committedDate": "2020-05-21T16:40:53Z", "type": "commit"}, {"oid": "f95f644432676d0b00eaa20a73f4aa980cd87e29", "url": "https://github.com/trinodb/trino/commit/f95f644432676d0b00eaa20a73f4aa980cd87e29", "message": "Plan assertions for end to end dereference pushdown in hive", "committedDate": "2020-05-21T16:40:53Z", "type": "forcePushed"}]}