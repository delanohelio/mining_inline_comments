{"pr_number": 4101, "pr_title": "Add test for dynamic filter materialization on coordinator", "pr_createdAt": "2020-06-19T16:44:42Z", "pr_url": "https://github.com/trinodb/trino/pull/4101", "timeline": [{"oid": "ce4f1927049a95e515cb7d27859a0e5199b0ebcf", "url": "https://github.com/trinodb/trino/commit/ce4f1927049a95e515cb7d27859a0e5199b0ebcf", "message": "Add test for dynamic filter materialization on coordinator", "committedDate": "2020-06-22T10:14:23Z", "type": "commit"}, {"oid": "ce4f1927049a95e515cb7d27859a0e5199b0ebcf", "url": "https://github.com/trinodb/trino/commit/ce4f1927049a95e515cb7d27859a0e5199b0ebcf", "message": "Add test for dynamic filter materialization on coordinator", "committedDate": "2020-06-22T10:14:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2MzYxMA==", "url": "https://github.com/trinodb/trino/pull/4101#discussion_r443463610", "bodyText": "nanos might flip in comparison, see: https://docs.oracle.com/javase/7/docs/api/java/lang/System.html#nanoTime()\nEither use difference for comparison or https://guava.dev/releases/18.0/api/docs/com/google/common/base/Stopwatch.html", "author": "sopel39", "createdAt": "2020-06-22T10:27:35Z", "path": "presto-tests/src/test/java/io/prestosql/execution/TestCoordinatorDynamicFiltering.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.units.Duration;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.plugin.tpch.TpchPlugin;\n+import io.prestosql.spi.Plugin;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.Connector;\n+import io.prestosql.spi.connector.ConnectorContext;\n+import io.prestosql.spi.connector.ConnectorFactory;\n+import io.prestosql.spi.connector.ConnectorHandleResolver;\n+import io.prestosql.spi.connector.ConnectorMetadata;\n+import io.prestosql.spi.connector.ConnectorPageSinkProvider;\n+import io.prestosql.spi.connector.ConnectorPageSource;\n+import io.prestosql.spi.connector.ConnectorPageSourceProvider;\n+import io.prestosql.spi.connector.ConnectorPartitionHandle;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorSplit;\n+import io.prestosql.spi.connector.ConnectorSplitManager;\n+import io.prestosql.spi.connector.ConnectorSplitSource;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.ConnectorTransactionHandle;\n+import io.prestosql.spi.connector.EmptyPageSource;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.transaction.IsolationLevel;\n+import io.prestosql.split.EmptySplit;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.TestingHandleResolver;\n+import io.prestosql.testing.TestingMetadata;\n+import io.prestosql.testing.TestingPageSinkProvider;\n+import io.prestosql.testing.TestingTransactionHandle;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static io.prestosql.testing.TestingMetadata.TestingColumnHandle;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+import static java.lang.String.format;\n+import static java.util.Collections.nCopies;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.CompletableFuture.completedFuture;\n+\n+@Test(singleThreaded = true)\n+public class TestCoordinatorDynamicFiltering\n+        extends AbstractTestQueryFramework\n+{\n+    private static final TestingColumnHandle suppKeyHandle = new TestingColumnHandle(\"suppkey\", 2, BIGINT);\n+    private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter = new AtomicReference<>(TupleDomain.all());\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        Session session = testSessionBuilder()\n+                .setCatalog(\"test\")\n+                .setSchema(\"default\")\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, PARTITIONED.name())\n+                .build();\n+        return DistributedQueryRunner.builder(session).build();\n+    }\n+\n+    @BeforeClass\n+    public void setUp()\n+    {\n+        getQueryRunner().installPlugin(new TestPlugin(expectedDynamicFilter));\n+        getQueryRunner().installPlugin(new TpchPlugin());\n+        getQueryRunner().createCatalog(\"test\", \"test\", ImmutableMap.of());\n+        getQueryRunner().createCatalog(\"tpch\", \"tpch\", ImmutableMap.of());\n+        computeActual(\"CREATE TABLE lineitem AS SELECT * FROM tpch.tiny.lineitem\");\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void afterMethod()\n+    {\n+        expectedDynamicFilter.set(TupleDomain.all());\n+    }\n+\n+    @Test\n+    public void testJoinWithEmptyBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\",\n+                TupleDomain.none());\n+    }\n+\n+    @Test\n+    public void testJoinWithSelectiveBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'Supplier#000000001'\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        suppKeyHandle,\n+                        singleValue(BIGINT, 1L))));\n+    }\n+\n+    @Test\n+    public void testJoinWithNonSelectiveBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        suppKeyHandle,\n+                        Domain.create(ValueSet.ofRanges(Range.range(BIGINT, 1L, true, 100L, true)), false))));\n+    }\n+\n+    @Test\n+    public void testJoinWithMultipleDynamicFiltersOnProbe()\n+    {\n+        // supplier names Supplier#000000001 and Supplier#000000002 match suppkey 1 and 2\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM (\" +\n+                        \"SELECT supplier.suppkey FROM \" +\n+                            \"lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name IN ('Supplier#000000001', 'Supplier#000000002')\" +\n+                        \") t JOIN tpch.tiny.partsupp ON t.suppkey = partsupp.suppkey AND partsupp.suppkey IN (2, 3)\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        suppKeyHandle,\n+                        singleValue(BIGINT, 2L))));\n+    }\n+\n+    private void assertQueryDynamicFilters(@Language(\"SQL\") String query, TupleDomain<ColumnHandle> expectedTupleDomain)\n+    {\n+        expectedDynamicFilter.set(expectedTupleDomain);\n+        computeActual(query);\n+    }\n+\n+    private static class TestPlugin\n+            implements Plugin\n+    {\n+        private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter;\n+\n+        private TestPlugin(AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter)\n+        {\n+            this.expectedDynamicFilter = requireNonNull(expectedDynamicFilter, \"expectedDynamicFilter is null\");\n+        }\n+\n+        @Override\n+        public Iterable<ConnectorFactory> getConnectorFactories()\n+        {\n+            return ImmutableList.of(new ConnectorFactory()\n+            {\n+                private final ConnectorMetadata metadata = new TestingMetadata();\n+\n+                @Override\n+                public String getName()\n+                {\n+                    return \"test\";\n+                }\n+\n+                @Override\n+                public ConnectorHandleResolver getHandleResolver()\n+                {\n+                    return new TestingHandleResolver();\n+                }\n+\n+                @Override\n+                public Connector create(String catalogName, Map<String, String> config, ConnectorContext context)\n+                {\n+                    return new TestConnector(metadata, Duration.valueOf(\"10s\"), expectedDynamicFilter);\n+                }\n+            });\n+        }\n+    }\n+\n+    private static class TestConnector\n+            implements Connector\n+    {\n+        private final ConnectorMetadata metadata;\n+        private final Duration scanDuration;\n+        private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter;\n+\n+        private TestConnector(ConnectorMetadata metadata, Duration scanDuration, AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter)\n+        {\n+            this.metadata = requireNonNull(metadata, \"metadata is null\");\n+            this.scanDuration = requireNonNull(scanDuration, \"scanDuration is null\");\n+            this.expectedDynamicFilter = requireNonNull(expectedDynamicFilter, \"expectedDynamicFilter is null\");\n+        }\n+\n+        @Override\n+        public ConnectorTransactionHandle beginTransaction(IsolationLevel isolationLevel, boolean readOnly)\n+        {\n+            return TestingTransactionHandle.create();\n+        }\n+\n+        @Override\n+        public ConnectorMetadata getMetadata(ConnectorTransactionHandle transactionHandle)\n+        {\n+            return metadata;\n+        }\n+\n+        @Override\n+        public ConnectorSplitManager getSplitManager()\n+        {\n+            return new ConnectorSplitManager()\n+            {\n+                @Override\n+                public ConnectorSplitSource getSplits(\n+                        ConnectorTransactionHandle transaction,\n+                        ConnectorSession session,\n+                        ConnectorTableHandle table,\n+                        SplitSchedulingStrategy splitSchedulingStrategy,\n+                        Supplier<TupleDomain<ColumnHandle>> dynamicFilter)\n+                {\n+                    long start = System.nanoTime();\n+                    return new ConnectorSplitSource()\n+                    {\n+                        @Override\n+                        public CompletableFuture<ConnectorSplitBatch> getNextBatch(ConnectorPartitionHandle partitionHandle, int maxSize)\n+                        {\n+                            return completedFuture(new ConnectorSplitBatch(\n+                                    nCopies(maxSize, new EmptySplit(new CatalogName(\"test\"))),\n+                                    isFinished()));\n+                        }\n+\n+                        @Override\n+                        public void close()\n+                        {\n+                        }\n+\n+                        @Override\n+                        public boolean isFinished()\n+                        {\n+                            if (dynamicFilter.get().equals(expectedDynamicFilter.get())) {\n+                                // if we received expected dynamic filter then we are done\n+                                return true;\n+                            }\n+                            else if (Duration.nanosSince(start).compareTo(scanDuration) > 0) {", "originalCommit": "ce4f1927049a95e515cb7d27859a0e5199b0ebcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ3NDYyOA==", "url": "https://github.com/trinodb/trino/pull/4101#discussion_r443474628", "bodyText": "I think this should ok since Duration. nanosSince performs subtraction between the nano time recordings and creates a duration interval from it. I see multiple examples of this way of comparing else where in the code\nE.g.: https://github.com/prestosql/presto/blob/f66f62e2cdc752cd30d0acb2040a9a7ec1bde3c0/presto-main/src/main/java/io/prestosql/failuredetector/HeartbeatFailureDetector.java#L358", "author": "raunaqmorarka", "createdAt": "2020-06-22T10:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2MzYxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4NjI4MQ==", "url": "https://github.com/trinodb/trino/pull/4101#discussion_r443486281", "bodyText": "Ah, Right. Thanks!", "author": "sopel39", "createdAt": "2020-06-22T11:14:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2MzYxMA=="}], "type": "inlineReview"}]}