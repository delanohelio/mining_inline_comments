{"pr_number": 5379, "pr_title": " Validate user objects for HiveProcedures", "pr_createdAt": "2020-10-01T14:28:24Z", "pr_url": "https://github.com/trinodb/trino/pull/5379", "timeline": [{"oid": "553aaceb856159602f29c1840956693776be7bd5", "url": "https://github.com/trinodb/trino/commit/553aaceb856159602f29c1840956693776be7bd5", "message": "Validate user objects for HiveProcedures", "committedDate": "2020-11-05T07:25:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDYwNzk0Mw==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r524607943", "bodyText": "This check is actually reversed (as is the existing one for ConnectorSession). It would succeed if the parameter type is a subclass of ConnectorAccessControl, which would cause an error when the method is invoked (since the instance would not match).\nI think this should be switched to equality, since we wouldn't want to inject or instance for any superclass either (in this case only Object).\nWe should also fix the ConnectorSession check, but that can be a separate PR (or feel free to throw another commit on this PR).", "author": "electrum", "createdAt": "2020-11-16T21:31:23Z", "path": "presto-main/src/main/java/io/prestosql/execution/CallTask.java", "diffHunk": "@@ -169,6 +171,9 @@ else if (i < procedure.getArguments().size()) {\n             if (ConnectorSession.class.isAssignableFrom(type)) {\n                 arguments.add(session.toConnectorSession(catalogName));\n             }\n+            else if (ConnectorAccessControl.class.isAssignableFrom(type)) {", "originalCommit": "6cfd6d936bda879e92e3eeb6990bdfaee9d375f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzMzMxNw==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r525533317", "bodyText": "Same comment as above about isAssignableFrom", "author": "electrum", "createdAt": "2020-11-17T21:23:23Z", "path": "presto-main/src/main/java/io/prestosql/metadata/ProcedureRegistry.java", "diffHunk": "@@ -86,6 +87,7 @@ private void validateProcedure(Procedure procedure)\n     {\n         List<Class<?>> parameters = procedure.getMethodHandle().type().parameterList().stream()\n                 .filter(type -> !ConnectorSession.class.isAssignableFrom(type))\n+                .filter(type -> !ConnectorAccessControl.class.isAssignableFrom(type))", "originalCommit": "6cfd6d936bda879e92e3eeb6990bdfaee9d375f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNTc4NQ==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r525535785", "bodyText": "Let's change this to\nthrow new PrestoException(NOT_SUPPORTED, \"Row filtering not supported\");", "author": "electrum", "createdAt": "2020-11-17T21:27:50Z", "path": "presto-main/src/main/java/io/prestosql/security/InjectedConnectorAccessControl.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.security;\n+\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.spi.connector.CatalogSchemaName;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorAccessControl;\n+import io.prestosql.spi.connector.ConnectorSecurityContext;\n+import io.prestosql.spi.connector.SchemaRoutineName;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.security.PrestoPrincipal;\n+import io.prestosql.spi.security.Privilege;\n+import io.prestosql.spi.security.ViewExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class InjectedConnectorAccessControl\n+        implements ConnectorAccessControl\n+{\n+    private final AccessControl accessControl;\n+    private final SecurityContext securityContext;\n+    private final String catalogName;\n+\n+    public InjectedConnectorAccessControl(AccessControl accessControl, SecurityContext securityContext, String catalogName)\n+    {\n+        this.accessControl = requireNonNull(accessControl, \"accessControl is null\");\n+        this.securityContext = requireNonNull(securityContext, \"securityContext is null\");\n+        this.catalogName = requireNonNull(catalogName, \"catalogName is null\");\n+    }\n+\n+    @Override\n+    public void checkCanCreateSchema(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanCreateSchema(securityContext, getCatalogSchemaName(schemaName));\n+    }\n+\n+    @Override\n+    public void checkCanDropSchema(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDropSchema(securityContext, getCatalogSchemaName(schemaName));\n+    }\n+\n+    @Override\n+    public void checkCanRenameSchema(ConnectorSecurityContext context, String schemaName, String newSchemaName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRenameSchema(securityContext, getCatalogSchemaName(schemaName), newSchemaName);\n+    }\n+\n+    @Override\n+    public void checkCanSetSchemaAuthorization(ConnectorSecurityContext context, String schemaName, PrestoPrincipal principal)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSetSchemaAuthorization(securityContext, getCatalogSchemaName(schemaName), principal);\n+    }\n+\n+    @Override\n+    public void checkCanShowSchemas(ConnectorSecurityContext context)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowSchemas(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public Set<String> filterSchemas(ConnectorSecurityContext context, Set<String> schemaNames)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        return accessControl.filterSchemas(securityContext, catalogName, schemaNames);\n+    }\n+\n+    @Override\n+    public void checkCanShowCreateSchema(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowCreateSchema(securityContext, getCatalogSchemaName(schemaName));\n+    }\n+\n+    @Override\n+    public void checkCanShowCreateTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowCreateTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanCreateTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanCreateTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanDropTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDropTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanRenameTable(ConnectorSecurityContext context, SchemaTableName tableName, SchemaTableName newTableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRenameTable(securityContext, getQualifiedObjectName(tableName), getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanSetTableComment(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSetTableComment(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanSetColumnComment(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSetColumnComment(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanShowTables(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowTables(securityContext, getCatalogSchemaName(schemaName));\n+    }\n+\n+    @Override\n+    public Set<SchemaTableName> filterTables(ConnectorSecurityContext context, Set<SchemaTableName> tableNames)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        return accessControl.filterTables(securityContext, catalogName, tableNames);\n+    }\n+\n+    @Override\n+    public void checkCanShowColumns(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowColumns(securityContext, new CatalogSchemaTableName(catalogName, tableName));\n+    }\n+\n+    @Override\n+    public List<ColumnMetadata> filterColumns(ConnectorSecurityContext context, SchemaTableName tableName, List<ColumnMetadata> columns)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        return accessControl.filterColumns(securityContext, new CatalogSchemaTableName(catalogName, tableName), columns);\n+    }\n+\n+    @Override\n+    public void checkCanAddColumn(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanAddColumns(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanDropColumn(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDropColumn(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanSetTableAuthorization(ConnectorSecurityContext context, SchemaTableName tableName, PrestoPrincipal principal)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSetTableAuthorization(securityContext, getQualifiedObjectName(tableName), principal);\n+    }\n+\n+    @Override\n+    public void checkCanRenameColumn(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRenameColumn(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanSelectFromColumns(ConnectorSecurityContext context, SchemaTableName tableName, Set<String> columnNames)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSelectFromColumns(securityContext, getQualifiedObjectName(tableName), columnNames);\n+    }\n+\n+    @Override\n+    public void checkCanInsertIntoTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanInsertIntoTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanDeleteFromTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDeleteFromTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanCreateView(ConnectorSecurityContext context, SchemaTableName viewName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanCreateView(securityContext, getQualifiedObjectName(viewName));\n+    }\n+\n+    @Override\n+    public void checkCanRenameView(ConnectorSecurityContext context, SchemaTableName viewName, SchemaTableName newViewName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRenameView(securityContext, getQualifiedObjectName(viewName), getQualifiedObjectName(viewName));\n+    }\n+\n+    @Override\n+    public void checkCanDropView(ConnectorSecurityContext context, SchemaTableName viewName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDropView(securityContext, getQualifiedObjectName(viewName));\n+    }\n+\n+    @Override\n+    public void checkCanCreateViewWithSelectFromColumns(ConnectorSecurityContext context, SchemaTableName tableName, Set<String> columnNames)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanCreateViewWithSelectFromColumns(securityContext, getQualifiedObjectName(tableName), columnNames);\n+    }\n+\n+    @Override\n+    public void checkCanSetCatalogSessionProperty(ConnectorSecurityContext context, String propertyName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSetCatalogSessionProperty(securityContext, propertyName, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanGrantSchemaPrivilege(ConnectorSecurityContext context, Privilege privilege, String schemaName, PrestoPrincipal grantee, boolean grantOption)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanGrantSchemaPrivilege(securityContext, privilege, getCatalogSchemaName(schemaName), grantee, grantOption);\n+    }\n+\n+    @Override\n+    public void checkCanRevokeSchemaPrivilege(ConnectorSecurityContext context, Privilege privilege, String schemaName, PrestoPrincipal revokee, boolean grantOption)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRevokeSchemaPrivilege(securityContext, privilege, getCatalogSchemaName(schemaName), revokee, grantOption);\n+    }\n+\n+    @Override\n+    public void checkCanGrantTablePrivilege(ConnectorSecurityContext context, Privilege privilege, SchemaTableName tableName, PrestoPrincipal grantee, boolean grantOption)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanGrantTablePrivilege(securityContext, privilege, getQualifiedObjectName(tableName), grantee, grantOption);\n+    }\n+\n+    @Override\n+    public void checkCanRevokeTablePrivilege(ConnectorSecurityContext context, Privilege privilege, SchemaTableName tableName, PrestoPrincipal revokee, boolean grantOption)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRevokeTablePrivilege(securityContext, privilege, getQualifiedObjectName(tableName), revokee, grantOption);\n+    }\n+\n+    @Override\n+    public void checkCanCreateRole(ConnectorSecurityContext context, String role, Optional<PrestoPrincipal> grantor)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanCreateRole(securityContext, role, grantor, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanDropRole(ConnectorSecurityContext context, String role)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDropRole(securityContext, role, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanGrantRoles(ConnectorSecurityContext context, Set<String> roles, Set<PrestoPrincipal> grantees, boolean adminOption, Optional<PrestoPrincipal> grantor, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanGrantRoles(securityContext, roles, grantees, adminOption, grantor, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanRevokeRoles(ConnectorSecurityContext context, Set<String> roles, Set<PrestoPrincipal> grantees, boolean adminOption, Optional<PrestoPrincipal> grantor, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRevokeRoles(securityContext, roles, grantees, adminOption, grantor, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanSetRole(ConnectorSecurityContext context, String role, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSetRole(securityContext, role, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanShowRoleAuthorizationDescriptors(ConnectorSecurityContext context, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowRoleAuthorizationDescriptors(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanShowRoles(ConnectorSecurityContext context, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowRoles(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanShowCurrentRoles(ConnectorSecurityContext context, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowCurrentRoles(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanShowRoleGrants(ConnectorSecurityContext context, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowRoleGrants(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanExecuteProcedure(ConnectorSecurityContext context, SchemaRoutineName procedure)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanExecuteProcedure(securityContext, new QualifiedObjectName(catalogName, procedure.getSchemaName(), procedure.getRoutineName()));\n+    }\n+\n+    @Override\n+    public Optional<ViewExpression> getRowFilter(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        if (accessControl.getRowFilters(securityContext, new QualifiedObjectName(catalogName, tableName.getSchemaName(), tableName.getTableName())).isEmpty()) {\n+            return Optional.empty();\n+        }\n+        throw new IllegalStateException(\"Not yet supported\");", "originalCommit": "6cfd6d936bda879e92e3eeb6990bdfaee9d375f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNjMzMQ==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r525536331", "bodyText": "Same comment about isAssignableFrom", "author": "electrum", "createdAt": "2020-11-17T21:28:53Z", "path": "presto-spi/src/main/java/io/prestosql/spi/procedure/Procedure.java", "diffHunk": "@@ -58,6 +59,7 @@ public Procedure(String schema, String name, List<Argument> arguments, MethodHan\n \n         long parameterCount = methodHandle.type().parameterList().stream()\n                 .filter(type -> !ConnectorSession.class.isAssignableFrom(type))\n+                .filter(type -> !ConnectorAccessControl.class.isAssignableFrom(type))", "originalCommit": "6cfd6d936bda879e92e3eeb6990bdfaee9d375f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNzkxMQ==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r525537911", "bodyText": "Let's make this checkCanInsertIntoTable to match ANALYZE, since we're not deleting data. This would mean a user who has insert permission can drop stats and then run analyze.\nFrom the connector's point of view, analyze actually overwrites (i.e. deletes) the existing statistics, so drop stats can be thought of as a limited form of analyze.\nSeparately, we should probably add a new permission for analyze.", "author": "electrum", "createdAt": "2020-11-17T21:31:37Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/procedure/DropStatsProcedure.java", "diffHunk": "@@ -87,20 +89,23 @@ public Procedure get()\n                 DROP_STATS.bindTo(this));\n     }\n \n-    public void dropStats(ConnectorSession session, String schema, String table, List<?> partitionValues)\n+    public void dropStats(ConnectorSession session, ConnectorAccessControl accessControl, String schema, String table, List<?> partitionValues)\n     {\n         try (ThreadContextClassLoader ignored = new ThreadContextClassLoader(getClass().getClassLoader())) {\n-            doDropStats(session, schema, table, partitionValues);\n+            doDropStats(session, accessControl, schema, table, partitionValues);\n         }\n     }\n \n-    private void doDropStats(ConnectorSession session, String schema, String table, List<?> partitionValues)\n+    private void doDropStats(ConnectorSession session, ConnectorAccessControl accessControl, String schema, String table, List<?> partitionValues)\n     {\n         TransactionalMetadata hiveMetadata = hiveMetadataFactory.create();\n         HiveTableHandle handle = (HiveTableHandle) hiveMetadata.getTableHandle(session, new SchemaTableName(schema, table));\n         if (handle == null) {\n             throw new PrestoException(INVALID_PROCEDURE_ARGUMENT, format(\"Table '%s' does not exist\", new SchemaTableName(schema, table)));\n         }\n+\n+        accessControl.checkCanDeleteFromTable(null, new SchemaTableName(schema, table));", "originalCommit": "553aaceb856159602f29c1840956693776be7bd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "de158e23ea00e96088fc9a25254b888bc3d58c9d", "url": "https://github.com/trinodb/trino/commit/de158e23ea00e96088fc9a25254b888bc3d58c9d", "message": "Minor cleanup in checks involving ConnectorSession for Procedure", "committedDate": "2020-11-19T06:05:45Z", "type": "commit"}, {"oid": "e946b87c0072289996f1c3a487dadca537b58e9b", "url": "https://github.com/trinodb/trino/commit/e946b87c0072289996f1c3a487dadca537b58e9b", "message": "Inject ConnectorAccessControl for Procedures", "committedDate": "2020-11-19T06:05:46Z", "type": "commit"}, {"oid": "497062d0f445ef5f72d3f5afd7df322fcfe6abdf", "url": "https://github.com/trinodb/trino/commit/497062d0f445ef5f72d3f5afd7df322fcfe6abdf", "message": "Validate user objects for HiveProcedures", "committedDate": "2020-11-19T06:05:46Z", "type": "commit"}, {"oid": "497062d0f445ef5f72d3f5afd7df322fcfe6abdf", "url": "https://github.com/trinodb/trino/commit/497062d0f445ef5f72d3f5afd7df322fcfe6abdf", "message": "Validate user objects for HiveProcedures", "committedDate": "2020-11-19T06:05:46Z", "type": "forcePushed"}]}