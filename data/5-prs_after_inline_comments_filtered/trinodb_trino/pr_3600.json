{"pr_number": 3600, "pr_title": "Revamp TranslationMap and planner", "pr_createdAt": "2020-05-02T16:34:45Z", "pr_url": "https://github.com/trinodb/trino/pull/3600", "timeline": [{"oid": "2706fc40d5a4e0cf88f69ad27d8e4044271adfe0", "url": "https://github.com/trinodb/trino/commit/2706fc40d5a4e0cf88f69ad27d8e4044271adfe0", "message": "Simplify expression", "committedDate": "2020-06-27T01:33:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU1OTkwMg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447559902", "bodyText": "it would be nice to have concat accepts more arguments", "author": "kokosing", "createdAt": "2020-06-30T09:53:02Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/Analysis.java", "diffHunk": "@@ -1027,6 +1028,18 @@ public GroupingSetAnalysis(\n         {\n             return complexExpressions;\n         }\n+\n+        public Set<FieldId> getAllFields()\n+        {\n+            return Stream.concat(", "originalCommit": "d46b1610af40d6ee001a02f5eb5c652e665f35c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg3MzIxMQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r448873211", "bodyText": "You can use https://guava.dev/releases/23.0/api/docs/com/google/common/collect/Streams.html#concat-java.util.stream.Stream...- instead", "author": "sopel39", "createdAt": "2020-07-02T09:30:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU1OTkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU2MzU5NA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447563594", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // TODO: this should properly be multiset(row(...))\n          \n          \n            \n                        // TODO: this should be multiset(row(...))\n          \n      \n    \n    \n  \n\n?\nWouldn't be more proper for io.prestosql.sql.tree.ExistsPredicate to store io.prestosql.sql.tree.Query instead of Expression? Is it legal to have EXISTS (1)", "author": "kokosing", "createdAt": "2020-06-30T09:58:48Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -1280,8 +1278,24 @@ else if (previousNode instanceof QuantifiedComparisonExpression) {\n         protected Type visitExists(ExistsPredicate node, StackableAstVisitorContext<Context> context)\n         {\n             StatementAnalyzer analyzer = statementAnalyzerFactory.apply(node);\n-            Scope subqueryScope = Scope.builder().withParent(context.getContext().getScope()).build();\n-            analyzer.analyze(node.getSubquery(), subqueryScope);\n+            Scope subqueryScope = Scope.builder()\n+                    .withParent(context.getContext().getScope())\n+                    .build();\n+\n+            List<RowType.Field> fields = analyzer.analyze(node.getSubquery(), subqueryScope)\n+                    .getRelationType()\n+                    .getAllFields().stream()\n+                    .map(field -> {\n+                        if (field.getName().isPresent()) {\n+                            return RowType.field(field.getName().get(), field.getType());\n+                        }\n+\n+                        return RowType.field(field.getType());\n+                    })\n+                    .collect(toImmutableList());\n+\n+            // TODO: this should properly be multiset(row(...))", "originalCommit": "d46b1610af40d6ee001a02f5eb5c652e665f35c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY5NDE0Ng==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447694146", "bodyText": "I agree. Unfortunately, the AST doesn\u2019t allow for such structure. That\u2019s why subqueries were modeled that way.\nOnce this PR is in, we can start splitting AST from IR and have more flexibility to evolve the IR to fit the needs of the planner and optimizer", "author": "martint", "createdAt": "2020-06-30T13:45:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU2MzU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU2NzQwMw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447567403", "bodyText": "separate commit?", "author": "kokosing", "createdAt": "2020-06-30T10:05:20Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -1622,7 +1636,11 @@ public static ExpressionAnalysis analyzeExpressions(\n         Analysis analysis = new Analysis(null, parameters, isDescribe);\n         ExpressionAnalyzer analyzer = create(analysis, session, metadata, sqlParser, accessControl, types, warningCollector);\n         for (Expression expression : expressions) {\n-            analyzer.analyze(expression, Scope.builder().withRelationType(RelationId.anonymous(), new RelationType()).build());", "originalCommit": "d46b1610af40d6ee001a02f5eb5c652e665f35c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5MzM3MQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447593371", "bodyText": "extract variable selectExpressions", "author": "kokosing", "createdAt": "2020-06-30T10:52:35Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1322,22 +1321,20 @@ protected Scope visitQuerySpecification(QuerySpecification node, Optional<Scope>\n                 }\n             }\n \n-            List<Expression> sourceExpressions = new ArrayList<>(outputExpressions);\n+            List<Expression> sourceExpressions = new ArrayList<>(analysis.getSelectExpressions(node).stream().map(SelectExpression::getExpression).collect(Collectors.toList()));", "originalCommit": "d46b1610af40d6ee001a02f5eb5c652e665f35c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5MzgzNA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447593834", "bodyText": "seperate commit?", "author": "kokosing", "createdAt": "2020-06-30T10:53:26Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1601,8 +1598,10 @@ protected Scope visitValues(Values node, Optional<Scope> scope)\n         {\n             checkState(node.getRows().size() >= 1);\n \n+            Scope valuesScope = createScope(scope);\n+\n             List<List<Type>> rowTypes = node.getRows().stream()\n-                    .map(row -> analyzeExpression(row, createScope(scope)).getType(row))\n+                    .map(row -> analyzeExpression(row, valuesScope).getType(row))", "originalCommit": "d46b1610af40d6ee001a02f5eb5c652e665f35c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5NjUwNQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447596505", "bodyText": "private", "author": "kokosing", "createdAt": "2020-06-30T10:58:44Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -466,130 +331,154 @@ private PlanBuilder aggregate(PlanBuilder subPlan, QuerySpecification node)\n                 .map(OrderBy::getSortItems)\n                 .flatMap(List::stream)\n                 .map(SortItem::getSortKey)\n-                .forEach(arguments::add);\n+                .forEach(inputBuilder::add);\n \n         // filter expressions need to be projected first\n         analysis.getAggregates(node).stream()\n                 .map(FunctionCall::getFilter)\n                 .filter(Optional::isPresent)\n                 .map(Optional::get)\n-                .forEach(arguments::add);\n+                .forEach(inputBuilder::add);\n \n-        Iterable<Expression> inputs = Iterables.concat(groupByExpressions, arguments.build());\n-        subPlan = handleSubqueries(subPlan, node, inputs);\n+        GroupingSetAnalysis groupingSetAnalysis = analysis.getGroupingSets(node);\n+        inputBuilder.addAll(groupingSetAnalysis.getComplexExpressions());\n \n-        if (!Iterables.isEmpty(inputs)) { // avoid an empty projection if the only aggregation is COUNT (which has no arguments)\n-            subPlan = project(subPlan, inputs);\n-        }\n+        List<Expression> inputs = inputBuilder.build();\n+        subPlan = subqueryPlanner.handleSubqueries(subPlan, inputs, node);\n+        subPlan = subPlan.appendProjections(inputs, symbolAllocator, idAllocator);\n \n-        // 2. Aggregate\n+        // Add projection to coerce inputs to their site-specific types.\n+        // This is important because the same lexical expression may need to be coerced\n+        // in different ways if it's referenced by multiple arguments to the window function.\n+        // For example, given v::integer,\n+        //    avg(v)\n+        // Needs to be rewritten as\n+        //    avg(CAST(v AS double))\n+        PlanAndMappings coercions = coerce(subPlan, inputs, analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subPlan = coercions.getSubPlan();\n \n-        // 2.a. Rewrite aggregate arguments\n-        TranslationMap argumentTranslations = new TranslationMap(subPlan.getRelationPlan(), analysis, lambdaDeclarationToSymbolMap);\n+        GroupingSetsPlan groupingSets = planGroupingSets(subPlan, node, groupingSetAnalysis);\n \n-        ImmutableList.Builder<Symbol> aggregationArgumentsBuilder = ImmutableList.builder();\n-        for (Expression argument : arguments.build()) {\n-            Symbol symbol = subPlan.translate(argument);\n-            argumentTranslations.put(argument, symbol);\n-            aggregationArgumentsBuilder.add(symbol);\n-        }\n-        List<Symbol> aggregationArguments = aggregationArgumentsBuilder.build();\n+        subPlan = planAggregation(groupingSets.getSubPlan(), groupingSets.getGroupingSets(), groupingSets.getGroupIdSymbol(), analysis.getAggregates(node), coercions::get);\n \n-        // 2.b. Rewrite grouping columns\n-        TranslationMap groupingTranslations = new TranslationMap(subPlan.getRelationPlan(), analysis, lambdaDeclarationToSymbolMap);\n+        return planGroupingOperations(subPlan, node, groupingSets.getGroupIdSymbol(), groupingSets.getColumnOnlyGroupingSets());\n+    }\n+\n+    public GroupingSetsPlan planGroupingSets(PlanBuilder subPlan, QuerySpecification node, GroupingSetAnalysis groupingSetAnalysis)", "originalCommit": "d46b1610af40d6ee001a02f5eb5c652e665f35c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwMDcwOA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447600708", "bodyText": "I think it makes a sense to extract Cluster class", "author": "kokosing", "createdAt": "2020-06-30T11:07:32Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/SubqueryPlanner.java", "diffHunk": "@@ -108,482 +111,316 @@ public PlanBuilder handleSubqueries(PlanBuilder builder, Collection<Expression>\n \n     public PlanBuilder handleSubqueries(PlanBuilder builder, Expression expression, Node node)\n     {\n-        builder = appendInPredicateApplyNodes(builder, collectInPredicateSubqueries(expression, node), node);\n-        builder = appendScalarSubqueryCorrelatedJoins(builder, collectScalarSubqueries(expression, node));\n-        builder = appendExistsSubqueryApplyNodes(builder, collectExistsSubqueries(expression, node));\n-        builder = appendQuantifiedComparisonApplyNodes(builder, collectQuantifiedComparisonSubqueries(expression, node), node);\n+        for (List<InPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getInPredicateSubqueries(node)))) {\n+            builder = planInPredicate(builder, cluster, node);\n+        }\n+        for (List<SubqueryExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getScalarSubqueries(node)))) {\n+            builder = planScalarSubquery(builder, cluster);\n+        }\n+        for (List<ExistsPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getExistsSubqueries(node)))) {\n+            builder = planExists(builder, cluster);\n+        }\n+        for (List<QuantifiedComparisonExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getQuantifiedComparisonSubqueries(node)))) {\n+            builder = planQuantifiedComparison(builder, cluster, node);\n+        }\n+\n         return builder;\n     }\n \n-    public Set<InPredicate> collectInPredicateSubqueries(Expression expression, Node node)\n+    /**\n+     * Find subqueries from the candidate set that are children of the given parent\n+     * and that have not already been handled in the subplan\n+     */\n+    private <T extends Expression> List<T> selectSubqueries(PlanBuilder subPlan, Expression parent, List<T> candidates)\n     {\n-        return analysis.getInPredicateSubqueries(node)\n-                .stream()\n-                .filter(inPredicate -> nodeContains(expression, inPredicate.getValueList()))\n-                .collect(toImmutableSet());\n-    }\n+        SuccessorsFunction<Node> recurse = expression -> {\n+            if (expression instanceof Expression &&\n+                    !analysis.isColumnReference((Expression) expression) && // no point in following dereference chains\n+                    !subPlan.canTranslate((Expression) expression)) { // don't consider subqueries under parts of the expression that have already been handled\n+                return expression.getChildren();\n+            }\n \n-    public Set<SubqueryExpression> collectScalarSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getScalarSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+            return ImmutableList.of();\n+        };\n \n-    public Set<ExistsPredicate> collectExistsSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getExistsSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+        Iterable<Node> allSubExpressions = Traverser.forTree(recurse).depthFirstPreOrder(parent);\n \n-    public Set<QuantifiedComparisonExpression> collectQuantifiedComparisonSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getQuantifiedComparisonSubqueries(node)\n+        return candidates\n                 .stream()\n-                .filter(quantifiedComparison -> nodeContains(expression, quantifiedComparison.getSubquery()))\n-                .collect(toImmutableSet());\n+                .filter(candidate -> stream(allSubExpressions).anyMatch(child -> child == candidate))\n+                .filter(candidate -> !subPlan.canTranslate(candidate))\n+                .collect(toImmutableList());\n     }\n \n-    private PlanBuilder appendInPredicateApplyNodes(PlanBuilder subPlan, Set<InPredicate> inPredicates, Node node)\n+    /**\n+     * Group expressions into clusters such that all entries in a cluster are #equals to each other\n+     */\n+    private <T extends Expression> Collection<List<T>> cluster(List<T> expressions)\n     {\n-        for (InPredicate inPredicate : inPredicates) {\n-            subPlan = appendInPredicateApplyNode(subPlan, inPredicate, node);\n+        Map<T, List<T>> sets = new LinkedHashMap<>();\n+\n+        for (T expression : expressions) {\n+            sets.computeIfAbsent(expression, key -> new ArrayList<>())\n+                    .add(expression);\n         }\n-        return subPlan;\n+\n+        return sets.values();\n     }\n \n-    private PlanBuilder appendInPredicateApplyNode(PlanBuilder subPlan, InPredicate inPredicate, Node node)\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, List<InPredicate> cluster, Node node)\n     {\n-        if (subPlan.canTranslate(inPredicate)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");", "originalCommit": "d46b1610af40d6ee001a02f5eb5c652e665f35c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMDMzOQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447830339", "bodyText": "What's the benefit? A \"cluster\" is just a list of expressions, so that would be just a wrapper over a list.", "author": "martint", "createdAt": "2020-06-30T16:45:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwMDcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE4NTQzMA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r448185430", "bodyText": "A \"cluster\" is just a list of expressions\n\nIt is just an implementation of collection of equal elements. Having this abstraction you wouldn't need to call such checks.\nAlso do you actually need this list? Maybe you could have an representative element and count of copies?", "author": "kokosing", "createdAt": "2020-07-01T07:58:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwMDcwOA=="}], "type": "inlineReview"}, {"oid": "0021100712c13f47721667c40b13d9e41fa162a7", "url": "https://github.com/trinodb/trino/commit/0021100712c13f47721667c40b13d9e41fa162a7", "message": "Reuse scope when analyzing VALUEs expressions", "committedDate": "2020-07-08T16:49:25Z", "type": "commit"}, {"oid": "edb4b8b12a01d4b5ecad3395b87bc92daa829902", "url": "https://github.com/trinodb/trino/commit/edb4b8b12a01d4b5ecad3395b87bc92daa829902", "message": "Revamp query planner\n\nNow there's a clean separation between expression in AST-land vs IR-land. Expressions\nare no longer rewritten over and over, which complicated maintaining that separation.\n\nTranslationMap is now responsible for Translating expressions from AST-land into IR-land by:\n* Inserting implicit coercions for intermediate expressions\n* Translating FunctionCalls to IR FunctionCalls (i.e., with information about the resolved function)\n* Rewriting sub-expressions based of a mapping of expressions in the current query scope that\n  have already been translated and the symbol from the tip of the current plan that contains their\n  value.\n* Tracking how fields in the current local scope (the FROM, SELECT, etc scopes) map to symbols\n  in the tip of the current plan.\n\nPreviously, the planning of subqueries went through these steps:\n* Plan the subquery. If any references originate from the outer scope, TranslationMap\n  leaves the Identifiers or references untouched. As a result, the temporary\n  subquery plan contains nodes from AST-land.\n* Collect any Identifiers from the temporary subplan and attemt to translate them against the\n  current scope. Any identifiers that are not local to the current scope are left untouched. Since\n  this also implies the current scope is with a subquery, the process repeats as the recursion\n  unwinds.\n* Stitch in the subplan via an Apply or CorrelatedJoin node.\n\nOne of the problems with this approach is that the intermediate temporary plans are invalid, as they\ncontain AST-land expressions. In the new implementation the TranslationMaps form a hierarchy mimicking\nquery scopes. Whenever an identifier cannot be resolved from a local scope, TranslationMap delegates to\nits parent.\n\nMany of the operation are now based on comparing expresions with awareness of what scopes identifiers\nbind to. Two expressions expressions that come from the same query scope are considered equal if all\ntheir references to columns in the query scope are the same.\n\nAs an example, in the following query:\n\n    SELECT f(k) as k\n    FROM (VALUES 1) t(k)\n    ORDER BY k\n\neven though the \"k\" in \"f(k)\" is syntactically equal to the \"k\"\nin the ORDER BY clause, they reference different fields. The former\ncomes from the scope associated with the FROM clause, while the\nlatter comes from the scope associated with the SELECT clause.", "committedDate": "2020-07-08T16:49:25Z", "type": "commit"}, {"oid": "1676ddc4600dd6e29b8b431e66fca551959dc2bf", "url": "https://github.com/trinodb/trino/commit/1676ddc4600dd6e29b8b431e66fca551959dc2bf", "message": "Simplify argument and field name\n\nlambdaDeclarationToSymbolMap is too verbose and doesn't provide any\nadditional information that the type of the variable doesn't convey.", "committedDate": "2020-07-08T16:49:25Z", "type": "commit"}, {"oid": "02947c40f0a965c4d380b414c4a1450bdf42548a", "url": "https://github.com/trinodb/trino/commit/02947c40f0a965c4d380b414c4a1450bdf42548a", "message": "Simplify expression", "committedDate": "2020-07-08T16:49:25Z", "type": "commit"}, {"oid": "b6ce459fa25e55290588c3472c258361fe0cc96c", "url": "https://github.com/trinodb/trino/commit/b6ce459fa25e55290588c3472c258361fe0cc96c", "message": "Improve formatting", "committedDate": "2020-07-08T16:49:26Z", "type": "commit"}, {"oid": "b6ce459fa25e55290588c3472c258361fe0cc96c", "url": "https://github.com/trinodb/trino/commit/b6ce459fa25e55290588c3472c258361fe0cc96c", "message": "Improve formatting", "committedDate": "2020-07-08T16:49:26Z", "type": "forcePushed"}]}