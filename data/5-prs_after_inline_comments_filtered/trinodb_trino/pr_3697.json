{"pr_number": 3697, "pr_title": "SPI and engine changes for aggregation pushdown", "pr_createdAt": "2020-05-11T17:03:02Z", "pr_url": "https://github.com/trinodb/trino/pull/3697", "timeline": [{"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "url": "https://github.com/trinodb/trino/commit/5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "message": "SPI changes to support nonpartial and complete aggregate pushdown to connectors.\nThe commit also includes the top level optimizer rule", "committedDate": "2020-05-18T21:37:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1OTM2MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428459360", "bodyText": "Place the first argument on the next line", "author": "martint", "createdAt": "2020-05-21T05:54:55Z", "path": "presto-main/src/main/java/io/prestosql/metadata/Metadata.java", "diffHunk": "@@ -352,6 +354,12 @@\n \n     Optional<TableHandle> applySample(Session session, TableHandle table, SampleType sampleType, double sampleRatio);\n \n+    Optional<AggregationPushdownResult<TableHandle>> applyAggregation(Session session,", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDI2Mg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130262", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1OTM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MTI5OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428461299", "bodyText": "Rename to AggregationApplicationResult for consistency with ProjectionApplicationResult", "author": "martint", "createdAt": "2020-05-21T06:01:32Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregationPushdownResult.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregationPushdownResult<T>", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDIxMg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130212", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MTI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MzA4MQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428463081", "bodyText": "Format as:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .map(\n          \n          \n            \n                                    result -> {\n          \n          \n            \n                            .map(result -> {", "author": "martint", "createdAt": "2020-05-21T06:07:51Z", "path": "presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java", "diffHunk": "@@ -1100,6 +1103,56 @@ public boolean usesLegacyTableLayouts(Session session, TableHandle table)\n                         Optional.empty()));\n     }\n \n+    @Override\n+    public Optional<AggregationPushdownResult<TableHandle>> applyAggregation(\n+            Session session,\n+            TableHandle table,\n+            List<AggregateFunction> aggregations,\n+            Map<String, ColumnHandle> assignments,\n+            List<List<ColumnHandle>> groupBy)\n+    {\n+        CatalogName catalogName = table.getCatalogName();\n+        ConnectorMetadata metadata = getMetadata(session, catalogName);\n+\n+        if (metadata.usesLegacyTableLayouts()) {\n+            return Optional.empty();\n+        }\n+\n+        ConnectorSession connectorSession = session.toConnectorSession(catalogName);\n+        return metadata.applyAggregation(connectorSession, table.getConnectorHandle(), aggregations, assignments, groupBy)\n+                .map(\n+                        result -> {", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDE4OA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130188", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MzA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MzU2MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428463560", "bodyText": "Format as:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .findAny().ifPresent(variableName -> { throw new IllegalStateException(\"Unbound variable: \" + variableName); });\n          \n          \n            \n                            .findAny()\n          \n          \n            \n                            .ifPresent(variableName -> { throw new IllegalStateException(\"Unbound variable: \" + variableName); });", "author": "martint", "createdAt": "2020-05-21T06:09:39Z", "path": "presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java", "diffHunk": "@@ -1100,6 +1103,56 @@ public boolean usesLegacyTableLayouts(Session session, TableHandle table)\n                         Optional.empty()));\n     }\n \n+    @Override\n+    public Optional<AggregationPushdownResult<TableHandle>> applyAggregation(\n+            Session session,\n+            TableHandle table,\n+            List<AggregateFunction> aggregations,\n+            Map<String, ColumnHandle> assignments,\n+            List<List<ColumnHandle>> groupBy)\n+    {\n+        CatalogName catalogName = table.getCatalogName();\n+        ConnectorMetadata metadata = getMetadata(session, catalogName);\n+\n+        if (metadata.usesLegacyTableLayouts()) {\n+            return Optional.empty();\n+        }\n+\n+        ConnectorSession connectorSession = session.toConnectorSession(catalogName);\n+        return metadata.applyAggregation(connectorSession, table.getConnectorHandle(), aggregations, assignments, groupBy)\n+                .map(\n+                        result -> {\n+                            verifyProjection(table, result.getProjections(), result.getAssignments(), aggregations.size());\n+\n+                            return new AggregationPushdownResult<>(\n+                                    new TableHandle(catalogName, result.getHandle(), table.getTransaction(), Optional.empty()),\n+                                    result.getProjections(),\n+                                    result.getAssignments());\n+                        });\n+    }\n+\n+    private void verifyProjection(TableHandle table, List<ConnectorExpression> projections, List<Assignment> assignments, int expectedProjectionSize)\n+    {\n+        projections.forEach(projection -> requireNonNull(projection, \"one of the projections is null\"));\n+        assignments.forEach(assignment -> requireNonNull(assignment, \"one of the assignments is null\"));\n+\n+        verify(\n+                expectedProjectionSize == projections.size(),\n+                \"ConnectorMetadata returned invalid number of projections: %s instead of %s for %s\",\n+                projections.size(),\n+                expectedProjectionSize,\n+                table);\n+\n+        Set<String> assignedVariables = assignments.stream()\n+                .map(Assignment::getVariable)\n+                .collect(toImmutableSet());\n+        projections.stream()\n+                .flatMap(connectorExpression -> ConnectorExpressions.extractVariables(connectorExpression).stream())\n+                .map(Variable::getName)\n+                .filter(variableName -> !assignedVariables.contains(variableName))\n+                .findAny().ifPresent(variableName -> { throw new IllegalStateException(\"Unbound variable: \" + variableName); });", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDE2NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130165", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MzU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NDI5NA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428464294", "bodyText": "Put the first argument on the next line", "author": "martint", "createdAt": "2020-05-21T06:12:12Z", "path": "presto-main/src/test/java/io/prestosql/metadata/AbstractMockMetadata.java", "diffHunk": "@@ -447,6 +449,16 @@ public boolean usesLegacyTableLayouts(Session session, TableHandle table)\n         return Optional.empty();\n     }\n \n+    @Override\n+    public Optional<AggregationPushdownResult<TableHandle>> applyAggregation(Session session,", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDE0Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130143", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NDI5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NDM4Nw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428464387", "bodyText": "First argument on the next line", "author": "martint", "createdAt": "2020-05-21T06:12:30Z", "path": "presto-plugin-toolkit/src/main/java/io/prestosql/plugin/base/classloader/ClassLoaderSafeConnectorMetadata.java", "diffHunk": "@@ -687,6 +689,18 @@ public ConnectorTableProperties getTableProperties(ConnectorSession session, Con\n         }\n     }\n \n+    @Override\n+    public Optional<AggregationPushdownResult<ConnectorTableHandle>> applyAggregation(ConnectorSession session,", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDEyMQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130121", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NDM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NTQ0Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428465443", "bodyText": "It's not a great idea to piggyback on Map.Entry to represent a sort item. For one, it doesn't clearly convey what the key and value represent. Let's create a dedicated class named SortItem.", "author": "martint", "createdAt": "2020-05-21T06:15:51Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;\n+\n+    public AggregateFunction(\n+            String aggregateFunctionName,\n+            Type outputType,\n+            List<ConnectorExpression> inputs,\n+            List<Map.Entry<String, SortOrder>> sortOrder,", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDEwNA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130104", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NTQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NjIwNw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428466207", "bodyText": "requireNonNull", "author": "martint", "createdAt": "2020-05-21T06:18:16Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;\n+\n+    public AggregateFunction(\n+            String aggregateFunctionName,\n+            Type outputType,\n+            List<ConnectorExpression> inputs,\n+            List<Map.Entry<String, SortOrder>> sortOrder,\n+            boolean isDistinct,\n+            Optional<String> filter)\n+    {\n+        this.functionName = requireNonNull(aggregateFunctionName, \"name is null\");\n+        this.outputType = requireNonNull(outputType, \"outputType is null\");\n+        this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n+        this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));\n+        this.isDistinct = requireNonNull(isDistinct, \"isDistinct is null\");\n+        this.filter = filter;", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDA4OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130089", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NjIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NzA1MQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428467051", "bodyText": "Move the requireNonNull for the arguments outside of the call. Having them inline muddles the code and makes it harder to read. Also, use List.copyOf():\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n          \n          \n            \n                    this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));\n          \n          \n            \n                    requireNonNull(inputs, \"inputs is null\");\n          \n          \n            \n                    requireNonNull(sortOrder, \"sortOrder is null\")\n          \n          \n            \n                    \n          \n          \n            \n                    this.inputs = List.copyOf(inputs);\n          \n          \n            \n                    this.sortOrder = List.copyOf(inputs);", "author": "martint", "createdAt": "2020-05-21T06:20:53Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;\n+\n+    public AggregateFunction(\n+            String aggregateFunctionName,\n+            Type outputType,\n+            List<ConnectorExpression> inputs,\n+            List<Map.Entry<String, SortOrder>> sortOrder,\n+            boolean isDistinct,\n+            Optional<String> filter)\n+    {\n+        this.functionName = requireNonNull(aggregateFunctionName, \"name is null\");\n+        this.outputType = requireNonNull(outputType, \"outputType is null\");\n+        this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n+        this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDA1OA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130058", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NzA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2ODA5OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428468099", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.projections = unmodifiableList(new ArrayList<>(requireNonNull(projections, \"projections is null\")));\n          \n          \n            \n                    this.assignments = unmodifiableList(new ArrayList<>(requireNonNull(assignments, \"assignment is null\")));\n          \n          \n            \n                    requireNonNull(projections, \"projections is null\");\n          \n          \n            \n                    requireNonNull(assignments, \"assignment is null\");\n          \n          \n            \n                    this.projections = List.copyOf(projections);\n          \n          \n            \n                    this.assignments = List.copyOf(assignments);", "author": "martint", "createdAt": "2020-05-21T06:24:07Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregationPushdownResult.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregationPushdownResult<T>\n+{\n+    private final T handle;\n+    private final List<ConnectorExpression> projections;\n+    private final List<Assignment> assignments;\n+\n+    public AggregationPushdownResult(T handle, List<ConnectorExpression> projections, List<Assignment> assignments)\n+    {\n+        this.handle = requireNonNull(handle, \"handle is null\");\n+        this.projections = unmodifiableList(new ArrayList<>(requireNonNull(projections, \"projections is null\")));\n+        this.assignments = unmodifiableList(new ArrayList<>(requireNonNull(assignments, \"assignment is null\")));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDA0OA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130048", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2ODA5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjMzOA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428906338", "bodyText": "We generally place the .stream() call next to the previous one as it's immaterial to understanding what the transformation does:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .entrySet()\n          \n          \n            \n                            .stream()\n          \n          \n            \n                            .entrySet().stream()", "author": "martint", "createdAt": "2020-05-21T20:49:22Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDAzMQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130031", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjUyNg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428906526", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n          \n          \n            \n                            .stream()\n          \n          \n            \n                    List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations.stream()", "author": "martint", "createdAt": "2020-05-21T20:49:43Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwODUwOA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428908508", "bodyText": "If you change toAggregateFunction to process a single aggregation, you can rewrite this as:\nList<AggregateFunction> aggregateFunctions = aggregations.stream()\n        .map(Entry::getValue)\n        .map(this::toAggregateFunction)\n        .collect(toImmutableList());\nAlso, since some aggregations are not candidates to be pushed down (e.g., if they contain lambda expressions), add a check before that bails out early if the condition doesn't hold, although it'd be it'd be better to add this condition to the pattern:\n    private static final Pattern<AggregationNode> PATTERN = aggregation()\n            .matching(PushAggregationIntoTableScan::allArgumentsAreSimpleReferences) // skip arguments that are, for instance, lambda expressions\n            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n\n    private static boolean allArgumentsAreSimpleReferences(AggregationNode node)\n    {\n        return node.getAggregations()\n                .values().stream()\n                .flatMap(aggregation -> aggregation.getArguments().stream())\n                .allMatch(SymbolReference.class::isInstance)\n    }", "author": "martint", "createdAt": "2020-05-21T20:53:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjUyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTk4Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129983", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMjg4MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428912880", "bodyText": "Add this to the pattern:\nprivate static final Pattern<AggregationNode> PATTERN = aggregation()\n        .matching(node -> node.getGroupingSets().getGroupingSetCount() == 1)\n        .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));", "author": "martint", "createdAt": "2020-05-21T21:02:29Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTk1OA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129958", "bodyText": "Changed the pattern to capture this and no masks.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMjg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxODczNA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428918734", "bodyText": "These variables are used only once. Inline them where they are referenced.", "author": "martint", "createdAt": "2020-05-21T21:15:35Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (AggregationNode.Aggregation aggregation : aggregations) {\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = metadata.getType(signature.getReturnType());\n+            String name = signature.getName();", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTY1Ng==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129656", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxODczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTEzMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428919130", "bodyText": "This should unnecessary once you add the filter to the pattern as described above.", "author": "martint", "createdAt": "2020-05-21T21:16:24Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (AggregationNode.Aggregation aggregation : aggregations) {\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = metadata.getType(signature.getReturnType());\n+            String name = signature.getName();\n+            List<Expression> arguments = aggregation.getArguments();\n+            List<Symbol> symbols = arguments.stream()\n+                    .filter(expression -> expression instanceof SymbolReference)", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTYzMg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129632", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTEzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTcxMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428919710", "bodyText": "This can only be a SymbolReference, so it'd be more appropriate to do:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                .map(SymbolsExtractor::extractUnique)\n          \n          \n            \n                                .flatMap(Collection::stream)\n          \n          \n            \n                                .map(Symbol::from)", "author": "martint", "createdAt": "2020-05-21T21:17:49Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (AggregationNode.Aggregation aggregation : aggregations) {\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = metadata.getType(signature.getReturnType());\n+            String name = signature.getName();\n+            List<Expression> arguments = aggregation.getArguments();\n+            List<Symbol> symbols = arguments.stream()\n+                    .filter(expression -> expression instanceof SymbolReference)\n+                    .map(SymbolsExtractor::extractUnique)\n+                    .flatMap(Collection::stream)", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTU4NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129585", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTg0Mg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428919842", "bodyText": "This should unnecessary once you add the filter to the pattern as described above.", "author": "martint", "createdAt": "2020-05-21T21:18:06Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (AggregationNode.Aggregation aggregation : aggregations) {\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = metadata.getType(signature.getReturnType());\n+            String name = signature.getName();\n+            List<Expression> arguments = aggregation.getArguments();\n+            List<Symbol> symbols = arguments.stream()\n+                    .filter(expression -> expression instanceof SymbolReference)\n+                    .map(SymbolsExtractor::extractUnique)\n+                    .flatMap(Collection::stream)\n+                    .collect(toImmutableList());\n+\n+            if (arguments.size() != symbols.size()) {\n+                return ImmutableList.of();\n+            }", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTUwMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129500", "bodyText": "removed.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:18:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyMjg0OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428922849", "bodyText": "Once you apply all the suggestions above and below, this method can simplify to:\nprivate AggregateFunction toAggregateFunction(AggregationNode.Aggregation aggregation)\n{\n    Signature signature = aggregation.getResolvedFunction().getSignature();\n\n    ImmutableList.Builder<ConnectorExpression> arguments = new ImmutableList.Builder<>();\n    for (int i = 0; i < aggregation.getArguments().size(); i++) {\n        SymbolReference argument = (SymbolReference) aggregation.getArguments().get(i);\n        arguments.add(new Variable(argument.getName(), metadata.getType(signature.getArgumentTypes().get(i))));\n    }\n\n    Optional<OrderingScheme> orderingScheme = aggregation.getOrderingScheme();\n    Optional<List<Map.Entry<String, SortOrder>>> sortBy = orderingScheme.map(orderings ->\n            orderings.getOrderBy().stream()\n                    .map(orderBy -> new AbstractMap.SimpleEntry<>(\n                            orderBy.getName(),\n                            SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\n                    .collect(toImmutableList()));\n\n    return new AggregateFunction(\n            signature.getName(),\n            metadata.getType(signature.getReturnType()),\n            arguments.build(),\n            sortBy.orElse(ImmutableList.of()),\n            aggregation.isDistinct(),\n            aggregation.getFilter().map(Symbol::getName));\n}", "author": "martint", "createdAt": "2020-05-21T21:24:03Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5OTAwNQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429899005", "bodyText": "what about aggregation.getMask()? we should verify aggregation.getMask() is not present (yet).", "author": "findepi", "createdAt": "2020-05-25T12:04:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyMjg0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTQyNA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129424", "bodyText": "Done, added check for masks in pattern.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyMjg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyNDI5MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428924290", "bodyText": "This is incorrect. The new scan outputs should be the symbols associated with grouping columns plus the symbols associated with aggregations.", "author": "martint", "createdAt": "2020-05-21T21:26:50Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTM2NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129365", "bodyText": "comment removed.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyNDI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg2NDk5MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429864990", "bodyText": "6d9d47e", "author": "findepi", "createdAt": "2020-05-25T10:37:23Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODczMQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128731", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:17:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg2NDk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg2NjMzNQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429866335", "bodyText": "Why not ImmutableList.of(groupByColumns) always?\n[ [] ] would correctly describe the fact that there is 1 grouping set and that it is a global aggregation.", "author": "findepi", "createdAt": "2020-05-25T10:41:05Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODcwOQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128709", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:17:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg2NjMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MDUxNA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429870514", "bodyText": "i think #3697 (comment) is still waiting for final resolution. @martint ?\n(nit: if this stays, would be good to avoid \"unioned\" as intellij spellchecker highlights this)", "author": "findepi", "createdAt": "2020-05-25T10:51:58Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODY3OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128679", "bodyText": "unioned removed. I have assumed @martint 's last comment is what we want the API to do and changed both the contract and docs to reflect that. Let me know if there is a gap in my understanding vs what is expected.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:16:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MDUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTA5NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429871095", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *", "author": "findepi", "createdAt": "2020-05-25T10:53:23Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODA2Mg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128062", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTA5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTQ5OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429871499", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n          \n          \n            \n                 *              { functionName=agg_fn1, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} a]} ,\n          \n      \n    \n    \n  \n\notherwise you would need to use &lt; &gt;", "author": "findepi", "createdAt": "2020-05-25T10:54:24Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODA0MQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128041", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTQ5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTkwOA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429871908", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * group_by=[{@link ColumnHandle} CH2]\n          \n          \n            \n                 * group_by=[[{@link ColumnHandle} CH2]]\n          \n      \n    \n    \n  \n\n(it's list of lists)", "author": "findepi", "createdAt": "2020-05-25T10:55:33Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MjA5OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429872099", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * assignments = {a = CH0, b=CH1, c=CH2}\n          \n          \n            \n                 * assignments = {a = CH0, b = CH1, c = CH2}", "author": "findepi", "createdAt": "2020-05-25T10:56:00Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MjgzNA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429872834", "bodyText": "c assignments seems redundant, as there is no c variable", "author": "findepi", "createdAt": "2020-05-25T10:57:50Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3Mjk5Ng==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429872996", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *  - aggregation\n          \n          \n            \n                 *          variable0 = agg_fn1(a)\n          \n          \n            \n                 *          variable1 = agg_fn2(b, 2)\n          \n          \n            \n                 *          variable2 = group_by c\n          \n          \n            \n                 *  - aggregation (GROUP BY c)\n          \n          \n            \n                 *          variable0 = agg_fn1(a)\n          \n          \n            \n                 *          variable1 = agg_fn2(b, 2)\n          \n          \n            \n                 *          variable2 = c", "author": "findepi", "createdAt": "2020-05-25T10:58:15Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MzM3Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429873373", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *", "author": "findepi", "createdAt": "2020-05-25T10:59:19Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MzY1Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429873653", "bodyText": "i like the way you wrote this!\njust consider adding an indent (here and following).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * {@link AggregationPushdownResult} {\n          \n          \n            \n                 * handle = TH1\n          \n          \n            \n                 * {@link AggregationPushdownResult} {\n          \n          \n            \n                 *     handle = TH1", "author": "findepi", "createdAt": "2020-05-25T11:00:01Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3Mzk3MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429873970", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n          \n          \n            \n                 * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>", "author": "findepi", "createdAt": "2020-05-25T11:00:51Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1\n+     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3NDIxNw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429874217", "bodyText": "CH0, CH1, and CH2 are already used above", "author": "findepi", "createdAt": "2020-05-25T11:01:31Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1\n+     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n+     * assignments = {\n+     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n+     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3NDQxNQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429874415", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.\n          \n          \n            \n                 * if the connector only knows how to handle {@code agg_fn1}, but not {@code agg_fn2}, it should return {@link Optional#empty()}.", "author": "findepi", "createdAt": "2020-05-25T11:02:03Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1\n+     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n+     * assignments = {\n+     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n+     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3NDc2OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429874769", "bodyText": "Should we call this groupingSets? @martint ?", "author": "findepi", "createdAt": "2020-05-25T11:03:00Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1\n+     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n+     * assignments = {\n+     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n+     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.\n+     */\n+    default Optional<AggregationPushdownResult<ConnectorTableHandle>> applyAggregation(\n+            ConnectorSession session,\n+            ConnectorTableHandle handle,\n+            List<AggregateFunction> aggregates,\n+            Map<String, ColumnHandle> assignments,\n+            List<List<ColumnHandle>> groupBy)", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3NTY5NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429875695", "bodyText": "isDistinct is primitive, so\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.isDistinct = requireNonNull(isDistinct, \"isDistinct is null\");\n          \n          \n            \n                    this.isDistinct = isDistinct;", "author": "findepi", "createdAt": "2020-05-25T11:05:33Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;\n+\n+    public AggregateFunction(\n+            String aggregateFunctionName,\n+            Type outputType,\n+            List<ConnectorExpression> inputs,\n+            List<Map.Entry<String, SortOrder>> sortOrder,\n+            boolean isDistinct,\n+            Optional<String> filter)\n+    {\n+        this.functionName = requireNonNull(aggregateFunctionName, \"name is null\");\n+        this.outputType = requireNonNull(outputType, \"outputType is null\");\n+        this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n+        this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));\n+        this.isDistinct = requireNonNull(isDistinct, \"isDistinct is null\");", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg4NTY5Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429885693", "bodyText": "Moving out Assignment as a top level class touches a lot of files, that are otherwise unrelated to the change.\nCan you please extract this to a preparatory commit?", "author": "findepi", "createdAt": "2020-05-25T11:31:37Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneTableScanColumns.java", "diffHunk": "@@ -91,7 +92,7 @@ public PruneTableScanColumns(Metadata metadata, TypeAnalyzer typeAnalyzer)\n             handle = result.get().getHandle();\n \n             Map<String, ColumnHandle> assignments = result.get().getAssignments().stream()\n-                    .collect(toImmutableMap(ProjectionApplicationResult.Assignment::getVariable, ProjectionApplicationResult.Assignment::getColumn));\n+                    .collect(toImmutableMap(Assignment::getVariable, Assignment::getColumn));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg4Nzg2NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429887865", "bodyText": "Why?\nIf you remove this, the rule would be applicable also for queries like\nSELECT DISTINCT regionkey FROM tpch.tiny.nation;", "author": "findepi", "createdAt": "2020-05-25T11:36:51Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MTA0NA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429891044", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Pattern<AggregationNode> PATTERN = aggregation()\n          \n          \n            \n                        .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n          \n          \n            \n                    private static final Pattern<AggregationNode> PATTERN =\n          \n          \n            \n                        aggregation()\n          \n          \n            \n                                .with(step().equalTo(SINGLE))\n          \n          \n            \n                                .matching(node -> node.getGroupingSetCount() == 1)\n          \n          \n            \n                                .matching(node -> node.getGroupIdSymbol().isEmpty())\n          \n          \n            \n                                .matching(node -> node.getHashSymbol().isEmpty())\n          \n          \n            \n                                .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n          \n      \n    \n    \n  \n\n\na few additional checks\nif you move aggregation() to new line, this fill be formatted better", "author": "findepi", "createdAt": "2020-05-25T11:44:49Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5OTM5MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429899390", "bodyText": "plus additional conditions\n\n@martint 's all agg args are symbols condition\nagg mask is not present\nanything else?", "author": "findepi", "createdAt": "2020-05-25T12:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MTA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MjcxMw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429892713", "bodyText": "what does \"partial project\" mean here? (can this be  newProjections?)", "author": "findepi", "createdAt": "2020-05-25T11:49:02Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODAxNQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128015", "bodyText": "renamed.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MjcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MzEzMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429893130", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    groupingSets.getGroupingKeys().stream()\n          \n          \n            \n                            .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n          \n          \n            \n                    groupingSets.getGroupingKeys()\n          \n          \n            \n                            .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n          \n      \n    \n    \n  \n\n-- use Collection#forEach without going thru Stream", "author": "findepi", "createdAt": "2020-05-25T11:50:01Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNzcxNg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432127716", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:14:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MzEzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NDk0Ng==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429894946", "bodyText": "add verify(aggregationOutputSymbols.size() == newPartialProjections.size()); just before this line as this is where you depend on this\nno need for good exc msg, since it's in fact already validated in MetadataManager, so it's more for documenting assumptions/dependencies of the code here", "author": "findepi", "createdAt": "2020-05-25T11:54:37Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNzcwMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432127700", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:14:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NDk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429896486", "bodyText": "Optional<Variable>", "author": "findepi", "createdAt": "2020-05-25T11:58:16Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNzY4Mg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432127682", "bodyText": "Not sure about this, Why would this need to be a variable given the filter on the agg side is just a Symbol?", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:14:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4NTI5NA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432385294", "bodyText": "Symbols (engine things) are mapped to Variables in ConnectorExpression.\nUsing Variable here would give semantics to this field -- connector would know it needs to check assignments to know which column handle this is.", "author": "findepi", "createdAt": "2020-05-29T10:05:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUzMTYwMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r434531600", "bodyText": "BTW why isn't filter a Optional<ConnectorExpression> (or ConnectorExpression without Optional,  using new Constant(true, BOOLEAN) instead of empty).\n@Parth-Brahmbhatt  @martint did you discuss this bit already?", "author": "findepi", "createdAt": "2020-06-03T12:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1NTM5NA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r436055394", "bodyText": "We haven't discussed this, originally I did not have mask or filter as I couldn't quite understand how those were used. I will figure out how to get the corresponding connector expression from the symbol and update the PR today.", "author": "Parth-Brahmbhatt", "createdAt": "2020-06-05T17:16:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0NDUxMw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r436144513", "bodyText": "we haven't discussed this, I originally had no filters or masks as I did not completely understand what masks are for. @martint asked to add the filter in this PR in the first pass so the connectors have to explicitly decide to not handle them. For the current rule given it will only be matched when agg is followed by scan node the only possible place to look for filter symbol is tablescan assignment so I think it makes sense to just map it to Variable for now. I can't think of a scenario where we match this rule and it has a filter but the symbol is not in tablescan assignment so I have not added a check for that If you think we should add a defensive check I can add a condition.\nI personally prefer Optional so I have kept it as is, let me know if you would like me to remove Optional.", "author": "Parth-Brahmbhatt", "createdAt": "2020-06-05T20:17:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng=="}], "type": "inlineReview"}, {"oid": "0a598fdfffa13d60136ab89df3370bf637b362a1", "url": "https://github.com/trinodb/trino/commit/0a598fdfffa13d60136ab89df3370bf637b362a1", "message": "Add support for aggregation pushdow", "committedDate": "2020-06-11T18:05:43Z", "type": "commit"}, {"oid": "0a598fdfffa13d60136ab89df3370bf637b362a1", "url": "https://github.com/trinodb/trino/commit/0a598fdfffa13d60136ab89df3370bf637b362a1", "message": "Add support for aggregation pushdow", "committedDate": "2020-06-11T18:05:43Z", "type": "forcePushed"}]}