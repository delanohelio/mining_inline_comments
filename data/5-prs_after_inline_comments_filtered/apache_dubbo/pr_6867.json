{"pr_number": 6867, "pr_title": "tackled some class<?> newInstance depeated, and some code refactor", "pr_createdAt": "2020-11-03T08:30:46Z", "pr_url": "https://github.com/apache/dubbo/pull/6867", "timeline": [{"oid": "0fd0a0d8e2d85ed327440e78101f5e65191ad8f5", "url": "https://github.com/apache/dubbo/commit/0fd0a0d8e2d85ed327440e78101f5e65191ad8f5", "message": "refactor: class<?> newInstance depeated tackled, and some code refactor\n\nSigned-off-by: licho <lecho.sun@gmail.com>", "committedDate": "2020-11-03T02:34:06Z", "type": "commit"}, {"oid": "bf9b55d55aea25f20d8f7c3a4e877b22f06b718c", "url": "https://github.com/apache/dubbo/commit/bf9b55d55aea25f20d8f7c3a4e877b22f06b718c", "message": "Merge branch 'master' into master", "committedDate": "2021-03-20T06:28:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODM3MDU4Nw==", "url": "https://github.com/apache/dubbo/pull/6867#discussion_r598370587", "bodyText": "Pls recover end-line format of this file", "author": "AlbumenJ", "createdAt": "2021-03-22T01:03:32Z", "path": "dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/ClassUtils.java", "diffHunk": "@@ -1,445 +1,445 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *     http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.dubbo.common.compiler.support;\r\n-\r\n-import org.apache.dubbo.common.utils.StringUtils;\r\n-\r\n-import java.io.PrintWriter;\r\n-import java.io.StringWriter;\r\n-import java.lang.reflect.Array;\r\n-import java.lang.reflect.GenericArrayType;\r\n-import java.lang.reflect.Method;\r\n-import java.lang.reflect.Modifier;\r\n-import java.lang.reflect.ParameterizedType;\r\n-import java.lang.reflect.Type;\r\n-import java.lang.reflect.TypeVariable;\r\n-import java.net.URI;\r\n-import java.net.URISyntaxException;\r\n-import java.util.Collection;\r\n-import java.util.HashMap;\r\n-import java.util.Map;\r\n-\r\n-/**\r\n- * ClassUtils. (Tool, Static, ThreadSafe)\r\n- */\r\n-public class ClassUtils {\r\n-\r\n-    public static final String CLASS_EXTENSION = \".class\";\r\n-\r\n-    public static final String JAVA_EXTENSION = \".java\";\r\n-    private static final int JIT_LIMIT = 5 * 1024;\r\n-\r\n-    private ClassUtils() {\r\n-    }\r\n-\r\n-    public static Object newInstance(String name) {\r\n-        try {\r\n-            return forName(name).newInstance();\r\n-        } catch (InstantiationException | IllegalAccessException e) {\r\n-            throw new IllegalStateException(e.getMessage(), e);\r\n-        }\r\n-    }\r\n-\r\n-    public static Class<?> forName(String[] packages, String className) {\r\n-        try {\r\n-            return classForName(className);\r\n-        } catch (ClassNotFoundException e) {\r\n-            if (packages != null && packages.length > 0) {\r\n-                for (String pkg : packages) {\r\n-                    try {\r\n-                        return classForName(pkg + \".\" + className);\r\n-                    } catch (ClassNotFoundException e2) {\r\n-                    }\r\n-                }\r\n-            }\r\n-            throw new IllegalStateException(e.getMessage(), e);\r\n-        }\r\n-    }\r\n-\r\n-    public static Class<?> forName(String className) {\r\n-        try {\r\n-            return classForName(className);\r\n-        } catch (ClassNotFoundException e) {\r\n-            throw new IllegalStateException(e.getMessage(), e);\r\n-        }\r\n-    }\r\n-\r\n-    public static Class<?> classForName(String className) throws ClassNotFoundException {\r\n-        switch (className) {\r\n-            case \"boolean\":\r\n-                return boolean.class;\r\n-            case \"byte\":\r\n-                return byte.class;\r\n-            case \"char\":\r\n-                return char.class;\r\n-            case \"short\":\r\n-                return short.class;\r\n-            case \"int\":\r\n-                return int.class;\r\n-            case \"long\":\r\n-                return long.class;\r\n-            case \"float\":\r\n-                return float.class;\r\n-            case \"double\":\r\n-                return double.class;\r\n-            case \"boolean[]\":\r\n-                return boolean[].class;\r\n-            case \"byte[]\":\r\n-                return byte[].class;\r\n-            case \"char[]\":\r\n-                return char[].class;\r\n-            case \"short[]\":\r\n-                return short[].class;\r\n-            case \"int[]\":\r\n-                return int[].class;\r\n-            case \"long[]\":\r\n-                return long[].class;\r\n-            case \"float[]\":\r\n-                return float[].class;\r\n-            case \"double[]\":\r\n-                return double[].class;\r\n-            default:\r\n-        }\r\n-        try {\r\n-            return arrayForName(className);\r\n-        } catch (ClassNotFoundException e) {\r\n-            // try to load from java.lang package\r\n-            if (className.indexOf('.') == -1) {\r\n-                try {\r\n-                    return arrayForName(\"java.lang.\" + className);\r\n-                } catch (ClassNotFoundException e2) {\r\n-                    // ignore, let the original exception be thrown\r\n-                }\r\n-            }\r\n-            throw e;\r\n-        }\r\n-    }\r\n-\r\n-    private static Class<?> arrayForName(String className) throws ClassNotFoundException {\r\n-        return Class.forName(className.endsWith(\"[]\")\r\n-                ? \"[L\" + className.substring(0, className.length() - 2) + \";\"\r\n-                : className, true, Thread.currentThread().getContextClassLoader());\r\n-    }\r\n-\r\n-    public static Class<?> getBoxedClass(Class<?> type) {\r\n-        if (type == boolean.class) {\r\n-            return Boolean.class;\r\n-        } else if (type == char.class) {\r\n-            return Character.class;\r\n-        } else if (type == byte.class) {\r\n-            return Byte.class;\r\n-        } else if (type == short.class) {\r\n-            return Short.class;\r\n-        } else if (type == int.class) {\r\n-            return Integer.class;\r\n-        } else if (type == long.class) {\r\n-            return Long.class;\r\n-        } else if (type == float.class) {\r\n-            return Float.class;\r\n-        } else if (type == double.class) {\r\n-            return Double.class;\r\n-        } else {\r\n-            return type;\r\n-        }\r\n-    }\r\n-\r\n-    public static Boolean boxed(boolean v) {\r\n-        return Boolean.valueOf(v);\r\n-    }\r\n-\r\n-    public static Character boxed(char v) {\r\n-        return Character.valueOf(v);\r\n-    }\r\n-\r\n-    public static Byte boxed(byte v) {\r\n-        return Byte.valueOf(v);\r\n-    }\r\n-\r\n-    public static Short boxed(short v) {\r\n-        return Short.valueOf(v);\r\n-    }\r\n-\r\n-    public static Integer boxed(int v) {\r\n-        return Integer.valueOf(v);\r\n-    }\r\n-\r\n-    public static Long boxed(long v) {\r\n-        return Long.valueOf(v);\r\n-    }\r\n-\r\n-    public static Float boxed(float v) {\r\n-        return Float.valueOf(v);\r\n-    }\r\n-\r\n-    public static Double boxed(double v) {\r\n-        return Double.valueOf(v);\r\n-    }\r\n-\r\n-    public static Object boxed(Object v) {\r\n-        return v;\r\n-    }\r\n-\r\n-    public static boolean unboxed(Boolean v) {\r\n-        return v == null ? false : v.booleanValue();\r\n-    }\r\n-\r\n-    public static char unboxed(Character v) {\r\n-        return v == null ? '\\0' : v.charValue();\r\n-    }\r\n-\r\n-    public static byte unboxed(Byte v) {\r\n-        return v == null ? 0 : v.byteValue();\r\n-    }\r\n-\r\n-    public static short unboxed(Short v) {\r\n-        return v == null ? 0 : v.shortValue();\r\n-    }\r\n-\r\n-    public static int unboxed(Integer v) {\r\n-        return v == null ? 0 : v.intValue();\r\n-    }\r\n-\r\n-    public static long unboxed(Long v) {\r\n-        return v == null ? 0 : v.longValue();\r\n-    }\r\n-\r\n-    public static float unboxed(Float v) {\r\n-        return v == null ? 0 : v.floatValue();\r\n-    }\r\n-\r\n-    public static double unboxed(Double v) {\r\n-        return v == null ? 0 : v.doubleValue();\r\n-    }\r\n-\r\n-    public static Object unboxed(Object v) {\r\n-        return v;\r\n-    }\r\n-\r\n-    public static boolean isNotEmpty(Object object) {\r\n-        return getSize(object) > 0;\r\n-    }\r\n-\r\n-    public static int getSize(Object object) {\r\n-        if (object == null) {\r\n-            return 0;\r\n-        }\r\n-        if (object instanceof Collection<?>) {\r\n-            return ((Collection<?>) object).size();\r\n-        } else if (object instanceof Map<?, ?>) {\r\n-            return ((Map<?, ?>) object).size();\r\n-        } else if (object.getClass().isArray()) {\r\n-            return Array.getLength(object);\r\n-        } else {\r\n-            return -1;\r\n-        }\r\n-    }\r\n-\r\n-    public static URI toURI(String name) {\r\n-        try {\r\n-            return new URI(name);\r\n-        } catch (URISyntaxException e) {\r\n-            throw new RuntimeException(e);\r\n-        }\r\n-    }\r\n-\r\n-    public static Class<?> getGenericClass(Class<?> cls) {\r\n-        return getGenericClass(cls, 0);\r\n-    }\r\n-\r\n-    public static Class<?> getGenericClass(Class<?> cls, int i) {\r\n-        try {\r\n-            ParameterizedType parameterizedType = ((ParameterizedType) cls.getGenericInterfaces()[0]);\r\n-            Object genericClass = parameterizedType.getActualTypeArguments()[i];\r\n-            if (genericClass instanceof ParameterizedType) {\r\n-                return (Class<?>) ((ParameterizedType) genericClass).getRawType();\r\n-            } else if (genericClass instanceof GenericArrayType) {\r\n-                Type type = ((GenericArrayType) genericClass).getGenericComponentType();\r\n-                if (type instanceof TypeVariable) {\r\n-                    return type.getClass();\r\n-                }\r\n-                return (((GenericArrayType) genericClass).getGenericComponentType() instanceof Class<?>)\r\n-                        ? (Class<?>) ((GenericArrayType) genericClass).getGenericComponentType()\r\n-                        : ((GenericArrayType) genericClass).getGenericComponentType().getClass();\r\n-            } else if (genericClass != null) {\r\n-                if (genericClass instanceof TypeVariable) {\r\n-                    return genericClass.getClass();\r\n-                }\r\n-                return (Class<?>) genericClass;\r\n-            }\r\n-        } catch (Throwable e) {\r\n-\r\n-        }\r\n-        if (cls.getSuperclass() != null) {\r\n-            return getGenericClass(cls.getSuperclass(), i);\r\n-        } else {\r\n-            throw new IllegalArgumentException(cls.getName() + \" generic type undefined!\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean isBeforeJava5(String javaVersion) {\r\n-        return (StringUtils.isEmpty(javaVersion) || \"1.0\".equals(javaVersion)\r\n-                || \"1.1\".equals(javaVersion) || \"1.2\".equals(javaVersion)\r\n-                || \"1.3\".equals(javaVersion) || \"1.4\".equals(javaVersion));\r\n-    }\r\n-\r\n-    public static boolean isBeforeJava6(String javaVersion) {\r\n-        return isBeforeJava5(javaVersion) || \"1.5\".equals(javaVersion);\r\n-    }\r\n-\r\n-    public static String toString(Throwable e) {\r\n-        StringWriter w = new StringWriter();\r\n-        PrintWriter p = new PrintWriter(w);\r\n-        p.print(e.getClass().getName() + \": \");\r\n-        if (e.getMessage() != null) {\r\n-            p.print(e.getMessage() + \"\\n\");\r\n-        }\r\n-        p.println();\r\n-        try {\r\n-            e.printStackTrace(p);\r\n-            return w.toString();\r\n-        } finally {\r\n-            p.close();\r\n-        }\r\n-    }\r\n-\r\n-    public static void checkBytecode(String name, byte[] bytecode) {\r\n-        if (bytecode.length > JIT_LIMIT) {\r\n-            System.err.println(\"The template bytecode too long, may be affect the JIT compiler. template class: \" + name);\r\n-        }\r\n-    }\r\n-\r\n-    public static String getSizeMethod(Class<?> cls) {\r\n-        try {\r\n-            return cls.getMethod(\"size\", new Class<?>[0]).getName() + \"()\";\r\n-        } catch (NoSuchMethodException e) {\r\n-            try {\r\n-                return cls.getMethod(\"length\", new Class<?>[0]).getName() + \"()\";\r\n-            } catch (NoSuchMethodException e2) {\r\n-                try {\r\n-                    return cls.getMethod(\"getSize\", new Class<?>[0]).getName() + \"()\";\r\n-                } catch (NoSuchMethodException e3) {\r\n-                    try {\r\n-                        return cls.getMethod(\"getLength\", new Class<?>[0]).getName() + \"()\";\r\n-                    } catch (NoSuchMethodException e4) {\r\n-                        return null;\r\n-                    }\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public static String getMethodName(Method method, Class<?>[] parameterClasses, String rightCode) {\r\n-        if (method.getParameterTypes().length > parameterClasses.length) {\r\n-            Class<?>[] types = method.getParameterTypes();\r\n-            StringBuilder buf = new StringBuilder(rightCode);\r\n-            for (int i = parameterClasses.length; i < types.length; i++) {\r\n-                if (buf.length() > 0) {\r\n-                    buf.append(\",\");\r\n-                }\r\n-                Class<?> type = types[i];\r\n-                String def;\r\n-                if (type == boolean.class) {\r\n-                    def = \"false\";\r\n-                } else if (type == char.class) {\r\n-                    def = \"\\'\\\\0\\'\";\r\n-                } else if (type == byte.class\r\n-                        || type == short.class\r\n-                        || type == int.class\r\n-                        || type == long.class\r\n-                        || type == float.class\r\n-                        || type == double.class) {\r\n-                    def = \"0\";\r\n-                } else {\r\n-                    def = \"null\";\r\n-                }\r\n-                buf.append(def);\r\n-            }\r\n-        }\r\n-        return method.getName() + \"(\" + rightCode + \")\";\r\n-    }\r\n-\r\n-    public static Method searchMethod(Class<?> currentClass, String name, Class<?>[] parameterTypes) throws NoSuchMethodException {\r\n-        if (currentClass == null) {\r\n-            throw new NoSuchMethodException(\"class == null\");\r\n-        }\r\n-        try {\r\n-            return currentClass.getMethod(name, parameterTypes);\r\n-        } catch (NoSuchMethodException e) {\r\n-            for (Method method : currentClass.getMethods()) {\r\n-                if (method.getName().equals(name)\r\n-                        && parameterTypes.length == method.getParameterTypes().length\r\n-                        && Modifier.isPublic(method.getModifiers())) {\r\n-                    if (parameterTypes.length > 0) {\r\n-                        Class<?>[] types = method.getParameterTypes();\r\n-                        boolean match = true;\r\n-                        for (int i = 0; i < parameterTypes.length; i++) {\r\n-                            if (!types[i].isAssignableFrom(parameterTypes[i])) {\r\n-                                match = false;\r\n-                                break;\r\n-                            }\r\n-                        }\r\n-                        if (!match) {\r\n-                            continue;\r\n-                        }\r\n-                    }\r\n-                    return method;\r\n-                }\r\n-            }\r\n-            throw e;\r\n-        }\r\n-    }\r\n-\r\n-    public static String getInitCode(Class<?> type) {\r\n-        if (byte.class.equals(type)\r\n-                || short.class.equals(type)\r\n-                || int.class.equals(type)\r\n-                || long.class.equals(type)\r\n-                || float.class.equals(type)\r\n-                || double.class.equals(type)) {\r\n-            return \"0\";\r\n-        } else if (char.class.equals(type)) {\r\n-            return \"'\\\\0'\";\r\n-        } else if (boolean.class.equals(type)) {\r\n-            return \"false\";\r\n-        } else {\r\n-            return \"null\";\r\n-        }\r\n-    }\r\n-\r\n-    public static <K, V> Map<K, V> toMap(Map.Entry<K, V>[] entries) {\r\n-        Map<K, V> map = new HashMap<K, V>();\r\n-        if (entries != null && entries.length > 0) {\r\n-            for (Map.Entry<K, V> entry : entries) {\r\n-                map.put(entry.getKey(), entry.getValue());\r\n-            }\r\n-        }\r\n-        return map;\r\n-    }\r\n-    \r\n-    /**\r\n-     * get simple class name from qualified class name\r\n-     */\r\n-    public static String getSimpleClassName(String qualifiedName) {\r\n-        if (null == qualifiedName) {\r\n-            return null;\r\n-        }\r\n-        \r\n-        int i = qualifiedName.lastIndexOf('.');\r\n-        return i < 0 ? qualifiedName : qualifiedName.substring(i + 1);\r\n-    }\r\n-\r\n-}\r\n+/*", "originalCommit": "bf9b55d55aea25f20d8f7c3a4e877b22f06b718c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODM5MDQ2Mw==", "url": "https://github.com/apache/dubbo/pull/6867#discussion_r598390463", "bodyText": "it's CRLF to LF problem. recover it already.", "author": "leechor", "createdAt": "2021-03-22T02:33:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODM3MDU4Nw=="}], "type": "inlineReview"}, {"oid": "5540ddd216148cc6d65c8929aa660b780b925578", "url": "https://github.com/apache/dubbo/commit/5540ddd216148cc6d65c8929aa660b780b925578", "message": "fix: ClassUtils.java LF to CRLF\n\nSigned-off-by: licho <lecho.sun@gmail.com>", "committedDate": "2021-03-22T02:07:19Z", "type": "commit"}]}