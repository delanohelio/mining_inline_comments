{"pr_number": 5880, "pr_title": "[Dubbo-Performance] Reduce memory allocation for URL parse", "pr_createdAt": "2020-03-17T15:27:50Z", "pr_url": "https://github.com/apache/dubbo/pull/5880", "timeline": [{"oid": "5ec8012d985263938301986ee9a3522175578021", "url": "https://github.com/apache/dubbo/commit/5ec8012d985263938301986ee9a3522175578021", "message": "perf: optimize URL decode and parse", "committedDate": "2020-03-14T14:31:19Z", "type": "commit"}, {"oid": "40b082271c4a37562b41293db689aef40995e301", "url": "https://github.com/apache/dubbo/commit/40b082271c4a37562b41293db689aef40995e301", "message": "refactor: Refactor URLStrDecoder for readable", "committedDate": "2020-03-14T17:03:21Z", "type": "commit"}, {"oid": "16154f540fa520e11a23ec47a66cae596b61fd48", "url": "https://github.com/apache/dubbo/commit/16154f540fa520e11a23ec47a66cae596b61fd48", "message": "perf: add URLStrParser#parseDecodedStr(String) to replace URL.valueOf(String)", "committedDate": "2020-03-16T16:16:55Z", "type": "commit"}, {"oid": "2662e186f68849040f7a323d9b5ec890528ae9f0", "url": "https://github.com/apache/dubbo/commit/2662e186f68849040f7a323d9b5ec890528ae9f0", "message": "perf: add short path for decodedParams", "committedDate": "2020-03-17T15:06:45Z", "type": "commit"}, {"oid": "48b0c9de6e1dac941ed43b25708f5ddd4a86e91c", "url": "https://github.com/apache/dubbo/commit/48b0c9de6e1dac941ed43b25708f5ddd4a86e91c", "message": "fix: Remove .* import", "committedDate": "2020-03-18T15:47:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY1OTQzNw==", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r395659437", "bodyText": "Line 98 - 115\n\u8fd9\u91cc\u5148\u7528 idx = indexOf(\":/\")\n\u7136\u540e\u5224\u65ad idx + 1 \u7684\u5b57\u7b26\u662f\u5426\u4e3a '/' \u53ef\u4ee5\u5728 file:/path \u7684\u60c5\u51b5\u4e0b\u51cf\u5c11\u4e00\u6b21 indexOf", "author": "guohao", "createdAt": "2020-03-20T14:07:14Z", "path": "dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.common;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.dubbo.common.utils.StringUtils.EMPTY_STRING;\n+import static org.apache.dubbo.common.utils.StringUtils.decodeHexByte;\n+import static org.apache.dubbo.common.utils.Utf8Utils.decodeUtf8;\n+\n+public final class URLStrParser {\n+\n+    private static final char SPACE = 0x20;\n+\n+    private static final ThreadLocal<TempBuf> DECODE_TEMP_BUF = ThreadLocal.withInitial(() -> new TempBuf(1024));\n+\n+    private URLStrParser() {\n+        //empty\n+    }\n+\n+    /**\n+     * @param decodedURLStr : after {@link URL#decode} string\n+     *                      decodedURLStr format: protocol://username:password@host:port/path?k1=v1&k2=v2\n+     *                      [protocol://][username:password@][host:port]/[path][?k1=v1&k2=v2]\n+     */\n+    public static URL parseDecodedStr(String decodedURLStr) {\n+        Map<String, String> parameters = null;\n+        int pathEndIdx = decodedURLStr.indexOf('?');\n+        if (pathEndIdx >= 0) {\n+            parameters = parseDecodedParams(decodedURLStr, pathEndIdx + 1);\n+        } else {\n+            pathEndIdx = decodedURLStr.length();\n+        }\n+\n+        String decodedBody = decodedURLStr.substring(0, pathEndIdx);\n+        return parseURLBody(decodedURLStr, decodedBody, parameters);\n+    }\n+\n+    private static Map<String, String> parseDecodedParams(String str, int from) {\n+        int len = str.length();\n+        if (from >= len) {\n+            return Collections.emptyMap();\n+        }\n+\n+        TempBuf tempBuf = DECODE_TEMP_BUF.get();\n+        Map<String, String> params = new HashMap<>();\n+        int nameStart = from;\n+        int valueStart = -1;\n+        int i;\n+        for (i = from; i < len; i++) {\n+            char ch = str.charAt(i);\n+            switch (ch) {\n+                case '=':\n+                    if (nameStart == i) {\n+                        nameStart = i + 1;\n+                    } else if (valueStart < nameStart) {\n+                        valueStart = i + 1;\n+                    }\n+                    break;\n+                case ';':\n+                case '&':\n+                    addParam(str, false, nameStart, valueStart, i, params, tempBuf);\n+                    nameStart = i + 1;\n+                    break;\n+                default:\n+                    // continue\n+            }\n+        }\n+        addParam(str, false, nameStart, valueStart, i, params, tempBuf);\n+        return params;\n+    }\n+\n+    /**\n+     * @param fullURLStr  : fullURLString\n+     * @param decodedBody : format: [protocol://][username:password@][host:port]/[path]\n+     * @param parameters  :\n+     * @return URL\n+     */\n+    private static URL parseURLBody(String fullURLStr, String decodedBody, Map<String, String> parameters) {\n+        int starIdx = 0, endIdx = decodedBody.length();\n+        String protocol = null;\n+        int protoEndIdx = decodedBody.indexOf(\"://\");", "originalCommit": "48b0c9de6e1dac941ed43b25708f5ddd4a86e91c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc1NTE4MA==", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r395755180", "bodyText": "\u903b\u8f91\u4e0a\u662f\u53ef\u884c\u7684\uff0c\u4f46\u662f\u4f1a\u727a\u7272\u4e00\u5b9a\u7684\u53ef\u8bfb\u6027", "author": "LinShunKang", "createdAt": "2020-03-20T16:32:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY1OTQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY2MTkwNw==", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r395661907", "bodyText": "\u8fd9\u91cc\u662f\u5426\u53ef\u4ee5\u76f4\u63a5\u7528decodedBoyd.indexOf('/',startIdx)", "author": "guohao", "createdAt": "2020-03-20T14:11:18Z", "path": "dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.common;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.dubbo.common.utils.StringUtils.EMPTY_STRING;\n+import static org.apache.dubbo.common.utils.StringUtils.decodeHexByte;\n+import static org.apache.dubbo.common.utils.Utf8Utils.decodeUtf8;\n+\n+public final class URLStrParser {\n+\n+    private static final char SPACE = 0x20;\n+\n+    private static final ThreadLocal<TempBuf> DECODE_TEMP_BUF = ThreadLocal.withInitial(() -> new TempBuf(1024));\n+\n+    private URLStrParser() {\n+        //empty\n+    }\n+\n+    /**\n+     * @param decodedURLStr : after {@link URL#decode} string\n+     *                      decodedURLStr format: protocol://username:password@host:port/path?k1=v1&k2=v2\n+     *                      [protocol://][username:password@][host:port]/[path][?k1=v1&k2=v2]\n+     */\n+    public static URL parseDecodedStr(String decodedURLStr) {\n+        Map<String, String> parameters = null;\n+        int pathEndIdx = decodedURLStr.indexOf('?');\n+        if (pathEndIdx >= 0) {\n+            parameters = parseDecodedParams(decodedURLStr, pathEndIdx + 1);\n+        } else {\n+            pathEndIdx = decodedURLStr.length();\n+        }\n+\n+        String decodedBody = decodedURLStr.substring(0, pathEndIdx);\n+        return parseURLBody(decodedURLStr, decodedBody, parameters);\n+    }\n+\n+    private static Map<String, String> parseDecodedParams(String str, int from) {\n+        int len = str.length();\n+        if (from >= len) {\n+            return Collections.emptyMap();\n+        }\n+\n+        TempBuf tempBuf = DECODE_TEMP_BUF.get();\n+        Map<String, String> params = new HashMap<>();\n+        int nameStart = from;\n+        int valueStart = -1;\n+        int i;\n+        for (i = from; i < len; i++) {\n+            char ch = str.charAt(i);\n+            switch (ch) {\n+                case '=':\n+                    if (nameStart == i) {\n+                        nameStart = i + 1;\n+                    } else if (valueStart < nameStart) {\n+                        valueStart = i + 1;\n+                    }\n+                    break;\n+                case ';':\n+                case '&':\n+                    addParam(str, false, nameStart, valueStart, i, params, tempBuf);\n+                    nameStart = i + 1;\n+                    break;\n+                default:\n+                    // continue\n+            }\n+        }\n+        addParam(str, false, nameStart, valueStart, i, params, tempBuf);\n+        return params;\n+    }\n+\n+    /**\n+     * @param fullURLStr  : fullURLString\n+     * @param decodedBody : format: [protocol://][username:password@][host:port]/[path]\n+     * @param parameters  :\n+     * @return URL\n+     */\n+    private static URL parseURLBody(String fullURLStr, String decodedBody, Map<String, String> parameters) {\n+        int starIdx = 0, endIdx = decodedBody.length();\n+        String protocol = null;\n+        int protoEndIdx = decodedBody.indexOf(\"://\");\n+        if (protoEndIdx >= 0) {\n+            if (protoEndIdx == 0) {\n+                throw new IllegalStateException(\"url missing protocol: \\\"\" + fullURLStr + \"\\\"\");\n+            }\n+            protocol = decodedBody.substring(0, protoEndIdx);\n+            starIdx = protoEndIdx + 3;\n+        } else {\n+            // case: file:/path/to/file.txt\n+            protoEndIdx = decodedBody.indexOf(\":/\");\n+            if (protoEndIdx >= 0) {\n+                if (protoEndIdx == 0) {\n+                    throw new IllegalStateException(\"url missing protocol: \\\"\" + fullURLStr + \"\\\"\");\n+                }\n+                protocol = decodedBody.substring(0, protoEndIdx);\n+                starIdx = protoEndIdx + 1;\n+            }\n+        }\n+\n+        String path = null;\n+        int pathStartIdx = indexOf(decodedBody, '/', starIdx, endIdx);", "originalCommit": "48b0c9de6e1dac941ed43b25708f5ddd4a86e91c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc1NjkzNA==", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r395756934", "bodyText": "\u662f\u7684\uff0c\u53ef\u4ee5\uff0c\u4e4b\u6240\u4ee5\u8fd9\u4e48\u5199\u662f\u4e3a\u4e86\u4fdd\u6301\u4e0a\u4e0b\u6587\u903b\u8f91\u7684\u4e00\u81f4\u6027\uff0c\u7edf\u4e00\u4f7f\u7528 indexof(String, char, int, int)", "author": "LinShunKang", "createdAt": "2020-03-20T16:35:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY2MTkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY2MzE3NQ==", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r395663175", "bodyText": "protocol \u8fd9\u79cd\u57fa\u672c\u4e0d\u53d8\u6216\u7c7b\u578b\u53ef\u679a\u4e3e\u7684\u5c5e\u6027\u503c\uff0c\u53ef\u4ee5\u8003\u8651\u4f7f\u7528\u7f13\u5b58\uff0c\u51cf\u5c11 substring \u751f\u6210\u65b0\u5bf9\u8c61\u6570\u91cf", "author": "guohao", "createdAt": "2020-03-20T14:13:14Z", "path": "dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.common;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.dubbo.common.utils.StringUtils.EMPTY_STRING;\n+import static org.apache.dubbo.common.utils.StringUtils.decodeHexByte;\n+import static org.apache.dubbo.common.utils.Utf8Utils.decodeUtf8;\n+\n+public final class URLStrParser {\n+\n+    private static final char SPACE = 0x20;\n+\n+    private static final ThreadLocal<TempBuf> DECODE_TEMP_BUF = ThreadLocal.withInitial(() -> new TempBuf(1024));\n+\n+    private URLStrParser() {\n+        //empty\n+    }\n+\n+    /**\n+     * @param decodedURLStr : after {@link URL#decode} string\n+     *                      decodedURLStr format: protocol://username:password@host:port/path?k1=v1&k2=v2\n+     *                      [protocol://][username:password@][host:port]/[path][?k1=v1&k2=v2]\n+     */\n+    public static URL parseDecodedStr(String decodedURLStr) {\n+        Map<String, String> parameters = null;\n+        int pathEndIdx = decodedURLStr.indexOf('?');\n+        if (pathEndIdx >= 0) {\n+            parameters = parseDecodedParams(decodedURLStr, pathEndIdx + 1);\n+        } else {\n+            pathEndIdx = decodedURLStr.length();\n+        }\n+\n+        String decodedBody = decodedURLStr.substring(0, pathEndIdx);\n+        return parseURLBody(decodedURLStr, decodedBody, parameters);\n+    }\n+\n+    private static Map<String, String> parseDecodedParams(String str, int from) {\n+        int len = str.length();\n+        if (from >= len) {\n+            return Collections.emptyMap();\n+        }\n+\n+        TempBuf tempBuf = DECODE_TEMP_BUF.get();\n+        Map<String, String> params = new HashMap<>();\n+        int nameStart = from;\n+        int valueStart = -1;\n+        int i;\n+        for (i = from; i < len; i++) {\n+            char ch = str.charAt(i);\n+            switch (ch) {\n+                case '=':\n+                    if (nameStart == i) {\n+                        nameStart = i + 1;\n+                    } else if (valueStart < nameStart) {\n+                        valueStart = i + 1;\n+                    }\n+                    break;\n+                case ';':\n+                case '&':\n+                    addParam(str, false, nameStart, valueStart, i, params, tempBuf);\n+                    nameStart = i + 1;\n+                    break;\n+                default:\n+                    // continue\n+            }\n+        }\n+        addParam(str, false, nameStart, valueStart, i, params, tempBuf);\n+        return params;\n+    }\n+\n+    /**\n+     * @param fullURLStr  : fullURLString\n+     * @param decodedBody : format: [protocol://][username:password@][host:port]/[path]\n+     * @param parameters  :\n+     * @return URL\n+     */\n+    private static URL parseURLBody(String fullURLStr, String decodedBody, Map<String, String> parameters) {\n+        int starIdx = 0, endIdx = decodedBody.length();\n+        String protocol = null;\n+        int protoEndIdx = decodedBody.indexOf(\"://\");\n+        if (protoEndIdx >= 0) {\n+            if (protoEndIdx == 0) {\n+                throw new IllegalStateException(\"url missing protocol: \\\"\" + fullURLStr + \"\\\"\");\n+            }\n+            protocol = decodedBody.substring(0, protoEndIdx);", "originalCommit": "48b0c9de6e1dac941ed43b25708f5ddd4a86e91c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc1NjA5NQ==", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r395756095", "bodyText": "\u53ef\u4ee5\u4f7f\u7528\u7f13\u5b58\uff0c\u4f46\u662f\u9700\u8981\u591a\u7ef4\u62a4\u4e00\u4e2a\u7c7b\u4f3c\u4e8e Trie \u7684\u4ee3\u7801\uff0c\u8fd9\u5c31\u9700\u8981\u8003\u8651\u4ee3\u4ef7\u4e0e\u6536\u76ca\u4e86", "author": "LinShunKang", "createdAt": "2020-03-20T16:34:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY2MzE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc4OTg5OQ==", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r395789899", "bodyText": "\u5176\u5b9e\uff0c\u76f8\u8f83\u4e8e protocol\uff0cparamsMap \u91cc\u7684 key \u624d\u662f\u66f4\u9700\u8981\u4f18\u5316\u7684", "author": "LinShunKang", "createdAt": "2020-03-20T17:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY2MzE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk1OTU0Mw==", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r395959543", "bodyText": "\u5176\u5b9e\uff0c\u76f8\u8f83\u4e8e protocol\uff0cparamsMap \u91cc\u7684 key \u624d\u662f\u66f4\u9700\u8981\u4f18\u5316\u7684\n\n\u8fd9\u4e2a\u95ee\u9898\u4e5f\u53ef\u4ee5\u901a\u8fc7\u7f13\u5b58\u7684\u65b9\u5f0f\u89e3\u51b3\u3002\nparamsMap \u7684 key \u548c value \u53ef\u4ee5\u5206\u6210\u4e24\u79cd\uff1a\u53ef\u679a\u4e3e\u548c\u4e0d\u53ef\u679a\u4e3e\u3002\n\u53ef\u679a\u4e3e\u7684 kv  \u53ef\u4ee5\u4f7f\u7528\u9884\u5148\u751f\u6210\u7684\u9759\u6001\u8868 + \u7d22\u5f15\u5b58\u50a8\uff0c\u6bd4\u5982bool \u503c\uff0c\u9759\u6001\u8868\u5305\u542b {0,1}\uff0c\u5b83\u7684\u503c\u4e5f\u53ea\u9700\u8981\u4e00\u4e2a byte\n\u4e0d\u53ef\u679a\u4e3e\u7684 kv \u53ef\u4ee5\u7528\u52a8\u6001\u8868 + \u7d22\u5f15\u7684\u65b9\u5f0f\uff0c\u52a8\u6001\u8868\u662f\u4e00\u4e2a\u5168\u5c40 array \uff0c\u5305\u542b\u6240\u6709\u53ef\u80fd\u503c\u548c\u5bf9\u5e94\u7d22\u5f15\uff0cURL \u4e2d\u53ea\u5b58\u50a8\u7d22\u5f15\u503c\u3002\u8fd9\u79cd\u65b9\u5f0f\u53ef\u6700\u5927\u7a0b\u5ea6\u51cf\u5c11 URL \u7684\u9a7b\u7559\u5185\u5b58\u3002\n\u5728\u670d\u52a1\u6ce8\u518c\u53d1\u73b0\u573a\u666f\uff0c\u591a\u6b21\u63a8\u9001\u7684 URL \u5927\u90e8\u5206\u90fd\u662f\u76f8\u540c\u7684\uff0c\u53ef\u4ee5\u5f15\u5165 URL string -> URL \u5bf9\u8c61\u7684\u7f13\u5b58\u3002\u5728\u8fd9\u4e2a\u524d\u63d0\u4e0b\uff0cURL string-> URL \u5bf9\u8c61\u7684\u8f6c\u6362\u5927\u90e8\u5206\u90fd\u53ef\u4ee5\u8d70\u7f13\u5b58\uff0c\u4e0d\u9700\u8981\u91cd\u65b0\u89e3\u6790\u3002\u91cd\u65b0\u89e3\u6790\u65f6\uff0c\u4ece\u5b9e\u73b0\u4e0a\u770b\uff0c\u53ef\u4ee5\u4f7f\u7528 char[] \u5b57\u5178\u6811 / \u751f\u6210\u4e34\u65f6 String \u4e24\u79cd\u65b9\u5f0f\uff0c\u4e00\u822c\u6765\u8bf4\uff0c\u8fd9\u91cc\u751f\u6210\u7684\u4e34\u65f6 String \u6570\u91cf\u662f\u6709\u9650\u7684\uff0c\u4e0d\u4f1a\u6210\u4e3a\u5185\u5b58\u74f6\u9888\u3002\u53ef\u4ee5\u8003\u8651\u4e0b\u3002", "author": "guohao", "createdAt": "2020-03-21T04:12:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY2MzE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk2ODIzMg==", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r395968232", "bodyText": "\u5728\u6211\u770b\u6765\uff0c\u53ea\u9700\u8981\u7ef4\u62a4\u4e00\u4e2a Trie \u5373\u53ef\uff0cTrie \u91cc\u5b58\u653e\u6240\u6709\u89e3\u6790\u8fc7\u7684 Key \u548c  Value \u5373\u53ef\uff0c\u6bd5\u7adf\u5728 Dubbo \u7684\u573a\u666f\u91cc\u6240\u6709\u7684 Key \u548c Value \u662f\u6709\u9650\u7684\u548c\u56fa\u5b9a\u7684\uff1b\u8fd9\u6837\u6240\u6709 URL \u5bf9\u8c61\u7684 URL#parameters \u548c URL#methodParameters \u91cc\u7684 Key \u548c Value \u90fd\u662f\u6307\u5411 Trie \u91cc\u7684\u5b57\u7b26\u4e32", "author": "LinShunKang", "createdAt": "2020-03-21T06:51:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY2MzE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY5MjgyMQ==", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r395692821", "bodyText": "\u6309\u7167 [ipv6\u5730\u5740%zoneId]:port \u7684\u683c\u5f0f\n\u8fd9\u4e2a\u5206\u652f\u5e94\u8be5\u4e0d\u4f1a\u8d70\u5230\u5427", "author": "guohao", "createdAt": "2020-03-20T14:57:13Z", "path": "dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.common;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.dubbo.common.utils.StringUtils.EMPTY_STRING;\n+import static org.apache.dubbo.common.utils.StringUtils.decodeHexByte;\n+import static org.apache.dubbo.common.utils.Utf8Utils.decodeUtf8;\n+\n+public final class URLStrParser {\n+\n+    private static final char SPACE = 0x20;\n+\n+    private static final ThreadLocal<TempBuf> DECODE_TEMP_BUF = ThreadLocal.withInitial(() -> new TempBuf(1024));\n+\n+    private URLStrParser() {\n+        //empty\n+    }\n+\n+    /**\n+     * @param decodedURLStr : after {@link URL#decode} string\n+     *                      decodedURLStr format: protocol://username:password@host:port/path?k1=v1&k2=v2\n+     *                      [protocol://][username:password@][host:port]/[path][?k1=v1&k2=v2]\n+     */\n+    public static URL parseDecodedStr(String decodedURLStr) {\n+        Map<String, String> parameters = null;\n+        int pathEndIdx = decodedURLStr.indexOf('?');\n+        if (pathEndIdx >= 0) {\n+            parameters = parseDecodedParams(decodedURLStr, pathEndIdx + 1);\n+        } else {\n+            pathEndIdx = decodedURLStr.length();\n+        }\n+\n+        String decodedBody = decodedURLStr.substring(0, pathEndIdx);\n+        return parseURLBody(decodedURLStr, decodedBody, parameters);\n+    }\n+\n+    private static Map<String, String> parseDecodedParams(String str, int from) {\n+        int len = str.length();\n+        if (from >= len) {\n+            return Collections.emptyMap();\n+        }\n+\n+        TempBuf tempBuf = DECODE_TEMP_BUF.get();\n+        Map<String, String> params = new HashMap<>();\n+        int nameStart = from;\n+        int valueStart = -1;\n+        int i;\n+        for (i = from; i < len; i++) {\n+            char ch = str.charAt(i);\n+            switch (ch) {\n+                case '=':\n+                    if (nameStart == i) {\n+                        nameStart = i + 1;\n+                    } else if (valueStart < nameStart) {\n+                        valueStart = i + 1;\n+                    }\n+                    break;\n+                case ';':\n+                case '&':\n+                    addParam(str, false, nameStart, valueStart, i, params, tempBuf);\n+                    nameStart = i + 1;\n+                    break;\n+                default:\n+                    // continue\n+            }\n+        }\n+        addParam(str, false, nameStart, valueStart, i, params, tempBuf);\n+        return params;\n+    }\n+\n+    /**\n+     * @param fullURLStr  : fullURLString\n+     * @param decodedBody : format: [protocol://][username:password@][host:port]/[path]\n+     * @param parameters  :\n+     * @return URL\n+     */\n+    private static URL parseURLBody(String fullURLStr, String decodedBody, Map<String, String> parameters) {\n+        int starIdx = 0, endIdx = decodedBody.length();\n+        String protocol = null;\n+        int protoEndIdx = decodedBody.indexOf(\"://\");\n+        if (protoEndIdx >= 0) {\n+            if (protoEndIdx == 0) {\n+                throw new IllegalStateException(\"url missing protocol: \\\"\" + fullURLStr + \"\\\"\");\n+            }\n+            protocol = decodedBody.substring(0, protoEndIdx);\n+            starIdx = protoEndIdx + 3;\n+        } else {\n+            // case: file:/path/to/file.txt\n+            protoEndIdx = decodedBody.indexOf(\":/\");\n+            if (protoEndIdx >= 0) {\n+                if (protoEndIdx == 0) {\n+                    throw new IllegalStateException(\"url missing protocol: \\\"\" + fullURLStr + \"\\\"\");\n+                }\n+                protocol = decodedBody.substring(0, protoEndIdx);\n+                starIdx = protoEndIdx + 1;\n+            }\n+        }\n+\n+        String path = null;\n+        int pathStartIdx = indexOf(decodedBody, '/', starIdx, endIdx);\n+        if (pathStartIdx >= 0) {\n+            path = decodedBody.substring(pathStartIdx + 1);\n+            endIdx = pathStartIdx;\n+        }\n+\n+        String username = null;\n+        String password = null;\n+        int pwdEndIdx = lastIndexOf(decodedBody, '@', starIdx, endIdx);\n+        if (pwdEndIdx > 0) {\n+            int userNameEndIdx = indexOf(decodedBody, ':', starIdx, pwdEndIdx);\n+            username = decodedBody.substring(starIdx, userNameEndIdx);\n+            password = decodedBody.substring(userNameEndIdx + 1, pwdEndIdx);\n+            starIdx = pwdEndIdx + 1;\n+        }\n+\n+        String host = null;\n+        int port = 0;\n+        int hostEndIdx = lastIndexOf(decodedBody, ':', starIdx, endIdx);\n+        if (hostEndIdx > 0 && hostEndIdx < decodedBody.length() - 1) {\n+            if (lastIndexOf(decodedBody, '%', starIdx, endIdx) > hostEndIdx) {", "originalCommit": "48b0c9de6e1dac941ed43b25708f5ddd4a86e91c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcwMjk1Ng==", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r395702956", "bodyText": "\u770b\u4e86\u4e0b org.apache.dubbo.common.utils.NetUtils#normalizeV6Address \uff0c\u83b7\u53d6\u5730\u5740\u6ce8\u518c\u7684\u65f6\u5019\u4e5f\u6ca1\u52a0 [ ] \u3002\n\u5982\u679c\u6ce8\u518c\u65f6\u9ed8\u8ba4\u7ea6\u5b9a ipv6 \u90fd\u4e0d\u52a0 [] \uff0c\u5f53\u524d\u8fd9\u79cd\u6a21\u5f0f\u662f\u6ca1\u95ee\u9898\u7684\u3002\n\u4f46\u662f\u6309\u7167 https://tools.ietf.org/html/rfc3986#section-3.2.2 \uff0cipv6 \u7684 host \u662f\u8981\u52a0 [] \u7684\u3002\n\u5982\u679c\u52a0\u4e86[] \uff0cconnect \u7684\u65f6\u5019\u9700\u8981\u628a [] \u53bb\u6389\u3002\n\u53ef\u4ee5\u5355\u72ec\u5f00\u4e2a issue \u8ba8\u8bba\u4e0b\u8fd9\u4e2a\u95ee\u9898", "author": "guohao", "createdAt": "2020-03-20T15:12:22Z", "path": "dubbo-common/src/main/java/org/apache/dubbo/common/URLStrParser.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.common;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.dubbo.common.utils.StringUtils.EMPTY_STRING;\n+import static org.apache.dubbo.common.utils.StringUtils.decodeHexByte;\n+import static org.apache.dubbo.common.utils.Utf8Utils.decodeUtf8;\n+\n+public final class URLStrParser {\n+\n+    private static final char SPACE = 0x20;\n+\n+    private static final ThreadLocal<TempBuf> DECODE_TEMP_BUF = ThreadLocal.withInitial(() -> new TempBuf(1024));\n+\n+    private URLStrParser() {\n+        //empty\n+    }\n+\n+    /**\n+     * @param decodedURLStr : after {@link URL#decode} string\n+     *                      decodedURLStr format: protocol://username:password@host:port/path?k1=v1&k2=v2\n+     *                      [protocol://][username:password@][host:port]/[path][?k1=v1&k2=v2]\n+     */\n+    public static URL parseDecodedStr(String decodedURLStr) {\n+        Map<String, String> parameters = null;\n+        int pathEndIdx = decodedURLStr.indexOf('?');\n+        if (pathEndIdx >= 0) {\n+            parameters = parseDecodedParams(decodedURLStr, pathEndIdx + 1);\n+        } else {\n+            pathEndIdx = decodedURLStr.length();\n+        }\n+\n+        String decodedBody = decodedURLStr.substring(0, pathEndIdx);\n+        return parseURLBody(decodedURLStr, decodedBody, parameters);\n+    }\n+\n+    private static Map<String, String> parseDecodedParams(String str, int from) {\n+        int len = str.length();\n+        if (from >= len) {\n+            return Collections.emptyMap();\n+        }\n+\n+        TempBuf tempBuf = DECODE_TEMP_BUF.get();\n+        Map<String, String> params = new HashMap<>();\n+        int nameStart = from;\n+        int valueStart = -1;\n+        int i;\n+        for (i = from; i < len; i++) {\n+            char ch = str.charAt(i);\n+            switch (ch) {\n+                case '=':\n+                    if (nameStart == i) {\n+                        nameStart = i + 1;\n+                    } else if (valueStart < nameStart) {\n+                        valueStart = i + 1;\n+                    }\n+                    break;\n+                case ';':\n+                case '&':\n+                    addParam(str, false, nameStart, valueStart, i, params, tempBuf);\n+                    nameStart = i + 1;\n+                    break;\n+                default:\n+                    // continue\n+            }\n+        }\n+        addParam(str, false, nameStart, valueStart, i, params, tempBuf);\n+        return params;\n+    }\n+\n+    /**\n+     * @param fullURLStr  : fullURLString\n+     * @param decodedBody : format: [protocol://][username:password@][host:port]/[path]\n+     * @param parameters  :\n+     * @return URL\n+     */\n+    private static URL parseURLBody(String fullURLStr, String decodedBody, Map<String, String> parameters) {\n+        int starIdx = 0, endIdx = decodedBody.length();\n+        String protocol = null;\n+        int protoEndIdx = decodedBody.indexOf(\"://\");\n+        if (protoEndIdx >= 0) {\n+            if (protoEndIdx == 0) {\n+                throw new IllegalStateException(\"url missing protocol: \\\"\" + fullURLStr + \"\\\"\");\n+            }\n+            protocol = decodedBody.substring(0, protoEndIdx);\n+            starIdx = protoEndIdx + 3;\n+        } else {\n+            // case: file:/path/to/file.txt\n+            protoEndIdx = decodedBody.indexOf(\":/\");\n+            if (protoEndIdx >= 0) {\n+                if (protoEndIdx == 0) {\n+                    throw new IllegalStateException(\"url missing protocol: \\\"\" + fullURLStr + \"\\\"\");\n+                }\n+                protocol = decodedBody.substring(0, protoEndIdx);\n+                starIdx = protoEndIdx + 1;\n+            }\n+        }\n+\n+        String path = null;\n+        int pathStartIdx = indexOf(decodedBody, '/', starIdx, endIdx);\n+        if (pathStartIdx >= 0) {\n+            path = decodedBody.substring(pathStartIdx + 1);\n+            endIdx = pathStartIdx;\n+        }\n+\n+        String username = null;\n+        String password = null;\n+        int pwdEndIdx = lastIndexOf(decodedBody, '@', starIdx, endIdx);\n+        if (pwdEndIdx > 0) {\n+            int userNameEndIdx = indexOf(decodedBody, ':', starIdx, pwdEndIdx);\n+            username = decodedBody.substring(starIdx, userNameEndIdx);\n+            password = decodedBody.substring(userNameEndIdx + 1, pwdEndIdx);\n+            starIdx = pwdEndIdx + 1;\n+        }\n+\n+        String host = null;\n+        int port = 0;\n+        int hostEndIdx = lastIndexOf(decodedBody, ':', starIdx, endIdx);\n+        if (hostEndIdx > 0 && hostEndIdx < decodedBody.length() - 1) {\n+            if (lastIndexOf(decodedBody, '%', starIdx, endIdx) > hostEndIdx) {\n+                // ipv6 address with scope id\n+                // e.g. fe80:0:0:0:894:aeec:f37d:23e1%en0\n+                // see https://howdoesinternetwork.com/2013/ipv6-zone-id\n+                // ignore\n+            } else {\n+                port = Integer.parseInt(decodedBody.substring(hostEndIdx + 1, endIdx));\n+                endIdx = hostEndIdx;\n+            }\n+        }\n+\n+        if (endIdx > starIdx) {\n+            host = decodedBody.substring(starIdx, endIdx);", "originalCommit": "48b0c9de6e1dac941ed43b25708f5ddd4a86e91c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcxMzU0Mg==", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r402713542", "bodyText": "I agree we can discuss if we should take [] later", "author": "chickenlj", "createdAt": "2020-04-03T03:12:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcwMjk1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcyMDU0MA==", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r395720540", "bodyText": "128 \u5c31\u591f\u4e86\uff0c\u7528\u4e0d\u5230 65536", "author": "guohao", "createdAt": "2020-03-20T15:38:37Z", "path": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java", "diffHunk": "@@ -88,6 +91,33 @@\n \r\n     public static final String HYPHEN = valueOf(HYPHEN_CHAR);\r\n \r\n+    static {\r\n+        HEX2B = new byte[Character.MAX_VALUE + 1];\r", "originalCommit": "48b0c9de6e1dac941ed43b25708f5ddd4a86e91c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2NjA1NQ==", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r395766055", "bodyText": "char \u7684\u8303\u56f4\u662f [0, 65535]\n\n\u5982\u679c HEX2B \u5927\u5c0f\u4e3a 128\uff0c\u90a3\u4e48\u5728 StringUtils#decodeHexNibble(char) \u65b9\u6cd5\u4e2d\u5c31\u9700\u8981\u5224\u65ad\u5165\u53c2\u7684\u5927\u5c0f\u662f\u5426\u5728  128  \u4e4b\u5185\uff0c\u5982\u679c\u5728 128 \u4ee5\u5185\u5219\u8fd4\u56de HEX2B[c]\uff0c\u5982\u679c\u4e0d\u5728 128 \u4ee5\u5185\u5219\u8fd4\u56de\u9ed8\u8ba4\u503c -1\n\u5982\u679c HEX2B \u5927\u5c0f\u4e3a 65536\uff0c\u90a3\u4e48\u5728 StringUtils#decodeHexNibble(char) \u65b9\u6cd5\u4e2d\u5c31\u53ef\u4ee5\u76f4\u63a5\u8fd4\u56de HEX2B[c]\n\n\u8fd9\u4e2a\u5c31\u9700\u8981\u53d6\u820d\u4e86\u3002", "author": "LinShunKang", "createdAt": "2020-03-20T16:51:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcyMDU0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk1OTk1Nw==", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r395959957", "bodyText": "\u4ece\u7528\u6cd5\u4e0a\u770b input char \u5982\u679c > 128 \uff0cdecodeHexNibble \u8fd4\u56de -1 \u540e\u4f1a\u629b IllegalArgumentException\uff0c\u4e5f\u5c5e\u4e8e\u5f02\u5e38\u573a\u666f\uff0c\u5b9e\u9645\u5e94\u7528\u60c5\u51b5\u5e94\u8be5\u5f88\u5c11\u53d1\u751f\u3002\n\u52a0\u4e00\u4e2a if/else \u5927\u90e8\u5206\u60c5\u51b5\u53ef\u4ee5\u8d70\u5206\u652f\u9884\u6d4b\u4f18\u5316\u6389\u3002", "author": "guohao", "createdAt": "2020-03-21T04:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcyMDU0MA=="}], "type": "inlineReview"}, {"oid": "4676cb52eaeec60583cb0073508fb75dddb842c0", "url": "https://github.com/apache/dubbo/commit/4676cb52eaeec60583cb0073508fb75dddb842c0", "message": "perf: Reduce String and StringBuilder allocation", "committedDate": "2020-03-21T06:00:10Z", "type": "commit"}, {"oid": "4f4d728188e2c11283d87a98cefb3f904cf052a7", "url": "https://github.com/apache/dubbo/commit/4f4d728188e2c11283d87a98cefb3f904cf052a7", "message": "perf: Reduce StringUtils#HEX2B size to 128", "committedDate": "2020-03-21T07:33:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcxMzI4NA==", "url": "https://github.com/apache/dubbo/pull/5880#discussion_r402713284", "bodyText": "Please keep the original License header as it is.", "author": "chickenlj", "createdAt": "2020-04-03T03:11:27Z", "path": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/Utf8Utils.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+// Protocol Buffers - Google's data interchange format\n+// Copyright 2008 Google Inc.  All rights reserved.\n+// https://developers.google.com/protocol-buffers/\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+// notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+// copyright notice, this list of conditions and the following disclaimer\n+// in the documentation and/or other materials provided with the\n+// distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+// contributors may be used to endorse or promote products derived from\n+// this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+package org.apache.dubbo.common.utils;\n+\n+import static java.lang.Character.MIN_HIGH_SURROGATE;\n+import static java.lang.Character.MIN_LOW_SURROGATE;\n+import static java.lang.Character.MIN_SUPPLEMENTARY_CODE_POINT;\n+\n+/**\n+ * See original <a href=\n+ * \"https://github.com/protocolbuffers/protobuf/blob/master/java/core/src/main/java/com/google/protobuf/Utf8.java\"\n+ * >Utf8.java</a>\n+ */\n+public final class Utf8Utils {", "originalCommit": "4f4d728188e2c11283d87a98cefb3f904cf052a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5ce4f5d99abdcbddc07d379fefe38f24b315a69a", "url": "https://github.com/apache/dubbo/commit/5ce4f5d99abdcbddc07d379fefe38f24b315a69a", "message": "license: Remove Apache License from Utf8Utils", "committedDate": "2020-04-03T14:45:00Z", "type": "commit"}]}