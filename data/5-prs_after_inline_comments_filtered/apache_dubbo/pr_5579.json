{"pr_number": 5579, "pr_title": "Merge 3.x", "pr_createdAt": "2020-01-03T08:14:44Z", "pr_url": "https://github.com/apache/dubbo/pull/5579", "timeline": [{"oid": "6261f36a96e3e0f1a3a260f861f3817ef5e76969", "url": "https://github.com/apache/dubbo/commit/6261f36a96e3e0f1a3a260f861f3817ef5e76969", "message": "can fetch classloader from ConsumerModel, also support group in ConfigChangeEvent", "committedDate": "2019-11-01T03:00:04Z", "type": "commit"}, {"oid": "3886fa8ff51989f020e0418f83efb457295159f2", "url": "https://github.com/apache/dubbo/commit/3886fa8ff51989f020e0418f83efb457295159f2", "message": "can fetch classloader from ConsumerModel, also support group in ConfigChangeEvent", "committedDate": "2019-11-01T06:25:30Z", "type": "commit"}, {"oid": "3dedd37ab2fb2838e6930346e346438b3c23d870", "url": "https://github.com/apache/dubbo/commit/3dedd37ab2fb2838e6930346e346438b3c23d870", "message": "online and offline", "committedDate": "2019-11-04T05:44:46Z", "type": "commit"}, {"oid": "9facee3eaaf9cf1393aac3f0cc6899c638f5aebf", "url": "https://github.com/apache/dubbo/commit/9facee3eaaf9cf1393aac3f0cc6899c638f5aebf", "message": "init methodmodel no matter attribute is present or not", "committedDate": "2019-11-06T12:36:46Z", "type": "commit"}, {"oid": "a2c8facb3bd5fa67b3e960705dd95c4f7cab04aa", "url": "https://github.com/apache/dubbo/commit/a2c8facb3bd5fa67b3e960705dd95c4f7cab04aa", "message": "log warn msg in case of finding of duplicate configs so as not to interrupt startup process", "committedDate": "2019-11-14T12:36:37Z", "type": "commit"}, {"oid": "af72d04f5583a7d2641ae210fe077fb0347fd0ae", "url": "https://github.com/apache/dubbo/commit/af72d04f5583a7d2641ae210fe077fb0347fd0ae", "message": "correct timeout logic", "committedDate": "2019-11-15T07:19:57Z", "type": "commit"}, {"oid": "ae30724df2b72aa332983b0afa721a041bc1d5cb", "url": "https://github.com/apache/dubbo/commit/ae30724df2b72aa332983b0afa721a041bc1d5cb", "message": "don't load actual class when it's generic invocation", "committedDate": "2019-11-19T02:08:02Z", "type": "commit"}, {"oid": "3b8f3d454119564060d87e570caed9eb787fc96f", "url": "https://github.com/apache/dubbo/commit/3b8f3d454119564060d87e570caed9eb787fc96f", "message": "get method list from proxy target object", "committedDate": "2019-11-21T05:51:00Z", "type": "commit"}, {"oid": "2d51bf7276cd27d935b31800115e78c604e68e82", "url": "https://github.com/apache/dubbo/commit/2d51bf7276cd27d935b31800115e78c604e68e82", "message": "introduce loading strategy to have chance to change loader's behavior", "committedDate": "2019-11-26T09:32:47Z", "type": "commit"}, {"oid": "a7faeb4503aad3adcbe3f6d75c3b5001488acff7", "url": "https://github.com/apache/dubbo/commit/a7faeb4503aad3adcbe3f6d75c3b5001488acff7", "message": "Merge pull request #8 from chickenlj/loading-strategy\n\nintroduce loading strategy to have chance to change loader's behavior", "committedDate": "2019-11-27T06:13:07Z", "type": "commit"}, {"oid": "12b3fc483a2fc5a39c85f8da77931ec0b06944bf", "url": "https://github.com/apache/dubbo/commit/12b3fc483a2fc5a39c85f8da77931ec0b06944bf", "message": "avoid busy wait when executor is null", "committedDate": "2019-11-27T13:16:09Z", "type": "commit"}, {"oid": "a619be64d00bb85096c81f9a97c2acffb8922d1c", "url": "https://github.com/apache/dubbo/commit/a619be64d00bb85096c81f9a97c2acffb8922d1c", "message": "make asyncinfo not rely on method object", "committedDate": "2019-11-29T10:04:08Z", "type": "commit"}, {"oid": "0e79673bb1b1e66a0b045104477d8c33c0a44a42", "url": "https://github.com/apache/dubbo/commit/0e79673bb1b1e66a0b045104477d8c33c0a44a42", "message": "refactor ConfigInitializer", "committedDate": "2019-12-25T06:37:46Z", "type": "commit"}, {"oid": "fa6a6b2487191b660ccb561f6628e2feea07bb9b", "url": "https://github.com/apache/dubbo/commit/fa6a6b2487191b660ccb561f6628e2feea07bb9b", "message": "refactor configInitilizer and ConfigPostProcessor", "committedDate": "2020-01-03T03:07:24Z", "type": "commit"}, {"oid": "4376f9a2c9cdb4fa20d1bcabb6a9fcdd1230836a", "url": "https://github.com/apache/dubbo/commit/4376f9a2c9cdb4fa20d1bcabb6a9fcdd1230836a", "message": "merge master", "committedDate": "2020-01-03T07:21:59Z", "type": "commit"}, {"oid": "f8f63dc3d3834800b537070539ad5a055ea55401", "url": "https://github.com/apache/dubbo/commit/f8f63dc3d3834800b537070539ad5a055ea55401", "message": "merge master", "committedDate": "2020-01-03T07:29:14Z", "type": "commit"}, {"oid": "d27e60bc7284e37fa6aefd87a99c7f4e5b2b299f", "url": "https://github.com/apache/dubbo/commit/d27e60bc7284e37fa6aefd87a99c7f4e5b2b299f", "message": "merge master", "committedDate": "2020-01-03T07:32:41Z", "type": "commit"}, {"oid": "2e06581b8b9460c2d4dce17b446812465e7386e4", "url": "https://github.com/apache/dubbo/commit/2e06581b8b9460c2d4dce17b446812465e7386e4", "message": "merge master", "committedDate": "2020-01-03T08:13:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjczMTc0NA==", "url": "https://github.com/apache/dubbo/pull/5579#discussion_r362731744", "bodyText": "Why is this file completely formatted \uff1f", "author": "lovepoem", "createdAt": "2020-01-03T08:24:26Z", "path": "dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java", "diffHunk": "@@ -1,492 +1,497 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dubbo.config;\n-\n-import org.apache.dubbo.common.URL;\n-import org.apache.dubbo.common.Version;\n-import org.apache.dubbo.common.bytecode.Wrapper;\n-import org.apache.dubbo.common.extension.ExtensionLoader;\n-import org.apache.dubbo.common.logger.Logger;\n-import org.apache.dubbo.common.logger.LoggerFactory;\n-import org.apache.dubbo.common.utils.CollectionUtils;\n-import org.apache.dubbo.common.utils.ConfigUtils;\n-import org.apache.dubbo.common.utils.NetUtils;\n-import org.apache.dubbo.common.utils.StringUtils;\n-import org.apache.dubbo.common.utils.UrlUtils;\n-import org.apache.dubbo.config.annotation.Reference;\n-import org.apache.dubbo.config.bootstrap.DubboBootstrap;\n-import org.apache.dubbo.config.event.ReferenceConfigDestroyedEvent;\n-import org.apache.dubbo.config.event.ReferenceConfigInitializedEvent;\n-import org.apache.dubbo.config.utils.ConfigValidationUtils;\n-import org.apache.dubbo.event.Event;\n-import org.apache.dubbo.event.EventDispatcher;\n-import org.apache.dubbo.metadata.WritableMetadataService;\n-import org.apache.dubbo.rpc.Invoker;\n-import org.apache.dubbo.rpc.Protocol;\n-import org.apache.dubbo.rpc.ProxyFactory;\n-import org.apache.dubbo.rpc.cluster.Cluster;\n-import org.apache.dubbo.rpc.cluster.directory.StaticDirectory;\n-import org.apache.dubbo.rpc.cluster.support.ClusterUtils;\n-import org.apache.dubbo.rpc.cluster.support.registry.ZoneAwareCluster;\n-import org.apache.dubbo.rpc.model.ApplicationModel;\n-import org.apache.dubbo.rpc.model.AsyncMethodInfo;\n-import org.apache.dubbo.rpc.model.ConsumerModel;\n-import org.apache.dubbo.rpc.model.ServiceDescriptor;\n-import org.apache.dubbo.rpc.model.ServiceRepository;\n-import org.apache.dubbo.rpc.protocol.injvm.InjvmProtocol;\n-import org.apache.dubbo.rpc.service.GenericService;\n-import org.apache.dubbo.rpc.support.ProtocolUtils;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-\n-import static org.apache.dubbo.common.constants.CommonConstants.ANY_VALUE;\n-import static org.apache.dubbo.common.constants.CommonConstants.CLUSTER_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SEPARATOR;\n-import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER_SIDE;\n-import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_METADATA_STORAGE_TYPE;\n-import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.LOCALHOST_VALUE;\n-import static org.apache.dubbo.common.constants.CommonConstants.METADATA_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.METHODS_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.MONITOR_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.PROXY_CLASS_REF;\n-import static org.apache.dubbo.common.constants.CommonConstants.REVISION_KEY;\n-import static org.apache.dubbo.common.constants.CommonConstants.SEMICOLON_SPLIT_PATTERN;\n-import static org.apache.dubbo.common.constants.CommonConstants.SIDE_KEY;\n-import static org.apache.dubbo.common.utils.NetUtils.isInvalidLocalHost;\n-import static org.apache.dubbo.config.Constants.DUBBO_IP_TO_REGISTRY;\n-import static org.apache.dubbo.registry.Constants.CONSUMER_PROTOCOL;\n-import static org.apache.dubbo.registry.Constants.REGISTER_IP_KEY;\n-import static org.apache.dubbo.rpc.Constants.LOCAL_PROTOCOL;\n-import static org.apache.dubbo.rpc.cluster.Constants.REFER_KEY;\n-\n-/**\n- * Please avoid using this class for any new application,\n- * use {@link ReferenceConfigBase} instead.\n- */\n-public class ReferenceConfig<T> extends ReferenceConfigBase<T> {\n-\n-    public static final Logger logger = LoggerFactory.getLogger(ReferenceConfig.class);\n-\n-    /**\n-     * The {@link Protocol} implementation with adaptive functionality,it will be different in different scenarios.\n-     * A particular {@link Protocol} implementation is determined by the protocol attribute in the {@link URL}.\n-     * For example:\n-     *\n-     * <li>when the url is registry://224.5.6.7:1234/org.apache.dubbo.registry.RegistryService?application=dubbo-sample,\n-     * then the protocol is <b>RegistryProtocol</b></li>\n-     *\n-     * <li>when the url is dubbo://224.5.6.7:1234/org.apache.dubbo.config.api.DemoService?application=dubbo-sample, then\n-     * the protocol is <b>DubboProtocol</b></li>\n-     * <p>\n-     * Actually\uff0cwhen the {@link ExtensionLoader} init the {@link Protocol} instants,it will automatically wraps two\n-     * layers, and eventually will get a <b>ProtocolFilterWrapper</b> or <b>ProtocolListenerWrapper</b>\n-     */\n-    private static final Protocol REF_PROTOCOL = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();\n-\n-    /**\n-     * The {@link Cluster}'s implementation with adaptive functionality, and actually it will get a {@link Cluster}'s\n-     * specific implementation who is wrapped with <b>MockClusterInvoker</b>\n-     */\n-    private static final Cluster CLUSTER = ExtensionLoader.getExtensionLoader(Cluster.class).getAdaptiveExtension();\n-\n-    /**\n-     * A {@link ProxyFactory} implementation that will generate a reference service's proxy,the JavassistProxyFactory is\n-     * its default implementation\n-     */\n-    private static final ProxyFactory PROXY_FACTORY = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();\n-\n-    /**\n-     * The interface proxy reference\n-     */\n-    private transient volatile T ref;\n-\n-    /**\n-     * The invoker of the reference service\n-     */\n-    private transient volatile Invoker<?> invoker;\n-\n-    /**\n-     * The flag whether the ReferenceConfig has been initialized\n-     */\n-    private transient volatile boolean initialized;\n-\n-    /**\n-     * whether this ReferenceConfig has been destroyed\n-     */\n-    private transient volatile boolean destroyed;\n-\n-    private final ServiceRepository repository;\n-\n-    private DubboBootstrap bootstrap;\n-\n-    public ReferenceConfig() {\n-        super();\n-        this.repository = ApplicationModel.getServiceRepository();\n-    }\n-\n-    public ReferenceConfig(Reference reference) {\n-        super(reference);\n-        this.repository = ApplicationModel.getServiceRepository();\n-    }\n-\n-    public synchronized T get() {\n-        if (destroyed) {\n-            throw new IllegalStateException(\"The invoker of ReferenceConfig(\" + url + \") has already destroyed!\");\n-        }\n-        if (ref == null) {\n-            init();\n-        }\n-        return ref;\n-    }\n-\n-    public synchronized void destroy() {\n-        if (ref == null) {\n-            return;\n-        }\n-        if (destroyed) {\n-            return;\n-        }\n-        destroyed = true;\n-        try {\n-            invoker.destroy();\n-        } catch (Throwable t) {\n-            logger.warn(\"Unexpected error occured when destroy invoker of ReferenceConfig(\" + url + \").\", t);\n-        }\n-        invoker = null;\n-        ref = null;\n-\n-        // dispatch a ReferenceConfigDestroyedEvent since 2.7.4\n-        dispatch(new ReferenceConfigDestroyedEvent(this));\n-    }\n-\n-    public synchronized void init() {\n-        if (initialized) {\n-            return;\n-        }\n-\n-        if (bootstrap == null) {\n-            bootstrap = DubboBootstrap.getInstance();\n-            bootstrap.init();\n-        }\n-\n-        checkAndUpdateSubConfigs();\n-\n-        checkStubAndLocal(interfaceClass);\n-        ConfigValidationUtils.checkMock(interfaceClass, this);\n-\n-        Map<String, String> map = new HashMap<String, String>();\n-        map.put(SIDE_KEY, CONSUMER_SIDE);\n-\n-        ReferenceConfigBase.appendRuntimeParameters(map);\n-        if (!ProtocolUtils.isGeneric(generic)) {\n-            String revision = Version.getVersion(interfaceClass, version);\n-            if (revision != null && revision.length() > 0) {\n-                map.put(REVISION_KEY, revision);\n-            }\n-\n-            String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();\n-            if (methods.length == 0) {\n-                logger.warn(\"No method found in service interface \" + interfaceClass.getName());\n-                map.put(METHODS_KEY, ANY_VALUE);\n-            } else {\n-                map.put(METHODS_KEY, StringUtils.join(new HashSet<String>(Arrays.asList(methods)), COMMA_SEPARATOR));\n-            }\n-        }\n-        map.put(INTERFACE_KEY, interfaceName);\n-        AbstractConfig.appendParameters(map, getMetrics());\n-        AbstractConfig.appendParameters(map, getApplication());\n-        AbstractConfig.appendParameters(map, getModule());\n-        // remove 'default.' prefix for configs from ConsumerConfig\n-        // appendParameters(map, consumer, Constants.DEFAULT_KEY);\n-        AbstractConfig.appendParameters(map, consumer);\n-        AbstractConfig.appendParameters(map, this);\n-        Map<String, AsyncMethodInfo> attributes = null;\n-        if (CollectionUtils.isNotEmpty(getMethods())) {\n-            attributes = new HashMap<>();\n-            for (MethodConfig methodConfig : getMethods()) {\n-                AbstractConfig.appendParameters(map, methodConfig, methodConfig.getName());\n-                String retryKey = methodConfig.getName() + \".retry\";\n-                if (map.containsKey(retryKey)) {\n-                    String retryValue = map.remove(retryKey);\n-                    if (\"false\".equals(retryValue)) {\n-                        map.put(methodConfig.getName() + \".retries\", \"0\");\n-                    }\n-                }\n-                AsyncMethodInfo asyncMethodInfo = AbstractConfig.convertMethodConfig2AsyncInfo(methodConfig);\n-                if (asyncMethodInfo != null) {\n-//                    consumerModel.getMethodModel(methodConfig.getName()).addAttribute(ASYNC_KEY, asyncMethodInfo);\n-                    attributes.put(methodConfig.getName(), asyncMethodInfo);\n-                }\n-            }\n-        }\n-\n-        String hostToRegistry = ConfigUtils.getSystemProperty(DUBBO_IP_TO_REGISTRY);\n-        if (StringUtils.isEmpty(hostToRegistry)) {\n-            hostToRegistry = NetUtils.getLocalHost();\n-        } else if (isInvalidLocalHost(hostToRegistry)) {\n-            throw new IllegalArgumentException(\"Specified invalid registry ip from property:\" + DUBBO_IP_TO_REGISTRY + \", value:\" + hostToRegistry);\n-        }\n-        map.put(REGISTER_IP_KEY, hostToRegistry);\n-\n-        serviceMetadata.getAttachments().putAll(map);\n-\n-        ref = createProxy(map);\n-\n-        serviceMetadata.setTarget(ref);\n-        serviceMetadata.addAttribute(PROXY_CLASS_REF, ref);\n-        ConsumerModel consumerModel = repository.lookupReferredService(serviceMetadata.getServiceKey());\n-        consumerModel.setProxyObject(ref);\n-        consumerModel.init(attributes);\n-\n-        initialized = true;\n-\n-        // dispatch a ReferenceConfigInitializedEvent since 2.7.4\n-        dispatch(new ReferenceConfigInitializedEvent(this, invoker));\n-    }\n-\n-    @SuppressWarnings({\"unchecked\", \"rawtypes\", \"deprecation\"})\n-    private T createProxy(Map<String, String> map) {\n-        if (shouldJvmRefer(map)) {\n-            URL url = new URL(LOCAL_PROTOCOL, LOCALHOST_VALUE, 0, interfaceClass.getName()).addParameters(map);\n-            invoker = REF_PROTOCOL.refer(interfaceClass, url);\n-            if (logger.isInfoEnabled()) {\n-                logger.info(\"Using injvm service \" + interfaceClass.getName());\n-            }\n-        } else {\n-            urls.clear();\n-            if (url != null && url.length() > 0) { // user specified URL, could be peer-to-peer address, or register center's address.\n-                String[] us = SEMICOLON_SPLIT_PATTERN.split(url);\n-                if (us != null && us.length > 0) {\n-                    for (String u : us) {\n-                        URL url = URL.valueOf(u);\n-                        if (StringUtils.isEmpty(url.getPath())) {\n-                            url = url.setPath(interfaceName);\n-                        }\n-                        if (UrlUtils.isRegistry(url)) {\n-                            urls.add(url.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));\n-                        } else {\n-                            urls.add(ClusterUtils.mergeUrl(url, map));\n-                        }\n-                    }\n-                }\n-            } else { // assemble URL from register center's configuration\n-                // if protocols not injvm checkRegistry\n-                if (!LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol())) {\n-                    checkRegistry();\n-                    List<URL> us = ConfigValidationUtils.loadRegistries(this, false);\n-                    if (CollectionUtils.isNotEmpty(us)) {\n-                        for (URL u : us) {\n-                            URL monitorUrl = ConfigValidationUtils.loadMonitor(this, u);\n-                            if (monitorUrl != null) {\n-                                map.put(MONITOR_KEY, URL.encode(monitorUrl.toFullString()));\n-                            }\n-                            urls.add(u.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));\n-                        }\n-                    }\n-                    if (urls.isEmpty()) {\n-                        throw new IllegalStateException(\"No such any registry to reference \" + interfaceName + \" on the consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion() + \", please config <dubbo:registry address=\\\"...\\\" /> to your spring config.\");\n-                    }\n-                }\n-            }\n-\n-            if (urls.size() == 1) {\n-                invoker = REF_PROTOCOL.refer(interfaceClass, urls.get(0));\n-            } else {\n-                List<Invoker<?>> invokers = new ArrayList<Invoker<?>>();\n-                URL registryURL = null;\n-                for (URL url : urls) {\n-                    invokers.add(REF_PROTOCOL.refer(interfaceClass, url));\n-                    if (UrlUtils.isRegistry(url)) {\n-                        registryURL = url; // use last registry url\n-                    }\n-                }\n-                if (registryURL != null) { // registry url is available\n-                    // for multi-subscription scenario, use 'zone-aware' policy by default\n-                    URL u = registryURL.addParameterIfAbsent(CLUSTER_KEY, ZoneAwareCluster.NAME);\n-                    // The invoker wrap relation would be like: ZoneAwareClusterInvoker(StaticDirectory) -> FailoverClusterInvoker(RegistryDirectory, routing happens here) -> Invoker\n-                    invoker = CLUSTER.join(new StaticDirectory(u, invokers));\n-                } else { // not a registry url, must be direct invoke.\n-                    invoker = CLUSTER.join(new StaticDirectory(invokers));\n-                }\n-            }\n-        }\n-\n-        if (shouldCheck() && !invoker.isAvailable()) {\n-            throw new IllegalStateException(\"Failed to check the status of the service \"\n-                    + interfaceName\n-                    + \". No provider available for the service \"\n-                    + (group == null ? \"\" : group + \"/\")\n-                    + interfaceName +\n-                    (version == null ? \"\" : \":\" + version)\n-                    + \" from the url \"\n-                    + invoker.getUrl()\n-                    + \" to the consumer \"\n-                    + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion());\n-        }\n-        if (logger.isInfoEnabled()) {\n-            logger.info(\"Refer dubbo service \" + interfaceClass.getName() + \" from url \" + invoker.getUrl());\n-        }\n-        /**\n-         * @since 2.7.0\n-         * ServiceData Store\n-         */\n-        String metadata = map.get(METADATA_KEY);\n-        WritableMetadataService metadataService = WritableMetadataService.getExtension(metadata == null ? DEFAULT_METADATA_STORAGE_TYPE : metadata);\n-        if (metadataService != null) {\n-            URL consumerURL = new URL(CONSUMER_PROTOCOL, map.remove(REGISTER_IP_KEY), 0, map.get(INTERFACE_KEY), map);\n-            metadataService.publishServiceDefinition(consumerURL);\n-        }\n-        // create service proxy\n-        return (T) PROXY_FACTORY.getProxy(invoker);\n-    }\n-\n-    /**\n-     * This method should be called right after the creation of this class's instance, before any property in other config modules is used.\n-     * Check each config modules are created properly and override their properties if necessary.\n-     */\n-    public void checkAndUpdateSubConfigs() {\n-        if (StringUtils.isEmpty(interfaceName)) {\n-            throw new IllegalStateException(\"<dubbo:reference interface=\\\"\\\" /> interface not allow null!\");\n-        }\n-        completeCompoundConfigs(consumer);\n-        if (consumer != null) {\n-            if (StringUtils.isEmpty(registryIds)) {\n-                setRegistryIds(consumer.getRegistryIds());\n-            }\n-        }\n-        // get consumer's global configuration\n-        checkDefault();\n-        this.refresh();\n-        if (getGeneric() == null && getConsumer() != null) {\n-            setGeneric(getConsumer().getGeneric());\n-        }\n-        if (ProtocolUtils.isGeneric(generic)) {\n-            interfaceClass = GenericService.class;\n-        } else {\n-            try {\n-                interfaceClass = Class.forName(interfaceName, true, Thread.currentThread()\n-                        .getContextClassLoader());\n-            } catch (ClassNotFoundException e) {\n-                throw new IllegalStateException(e.getMessage(), e);\n-            }\n-            checkInterfaceAndMethods(interfaceClass, getMethods());\n-        }\n-\n-        //init serivceMetadata\n-        serviceMetadata.setVersion(version);\n-        serviceMetadata.setGroup(group);\n-        serviceMetadata.setDefaultGroup(group);\n-        serviceMetadata.setServiceType(getActualInterface());\n-        serviceMetadata.setServiceInterfaceName(interfaceName);\n-        // TODO, uncomment this line once service key is unified\n-        serviceMetadata.setServiceKey(URL.buildKey(interfaceName, group, version));\n-\n-        ServiceRepository repository = ApplicationModel.getServiceRepository();\n-        ServiceDescriptor serviceDescriptor = repository.registerService(interfaceClass);\n-        repository.registerConsumer(\n-                serviceMetadata.getServiceKey(),\n-                serviceDescriptor,\n-                this,\n-                null,\n-                serviceMetadata);\n-\n-        resolveFile();\n-        ConfigValidationUtils.validateReferenceConfig(this);\n-        appendParameters();\n-    }\n-\n-\n-    /**\n-     * Figure out should refer the service in the same JVM from configurations. The default behavior is true\n-     * 1. if injvm is specified, then use it\n-     * 2. then if a url is specified, then assume it's a remote call\n-     * 3. otherwise, check scope parameter\n-     * 4. if scope is not specified but the target service is provided in the same JVM, then prefer to make the local\n-     * call, which is the default behavior\n-     */\n-    protected boolean shouldJvmRefer(Map<String, String> map) {\n-        URL tmpUrl = new URL(\"temp\", \"localhost\", 0, map);\n-        boolean isJvmRefer;\n-        if (isInjvm() == null) {\n-            // if a url is specified, don't do local reference\n-            if (url != null && url.length() > 0) {\n-                isJvmRefer = false;\n-            } else {\n-                // by default, reference local service if there is\n-                isJvmRefer = InjvmProtocol.getInjvmProtocol().isInjvmRefer(tmpUrl);\n-            }\n-        } else {\n-            isJvmRefer = isInjvm();\n-        }\n-        return isJvmRefer;\n-    }\n-\n-    /**\n-     * Dispatch an {@link Event event}\n-     *\n-     * @param event an {@link Event event}\n-     * @since 2.7.5\n-     */\n-    protected void dispatch(Event event) {\n-        EventDispatcher.getDefaultExtension().dispatch(event);\n-    }\n-\n-    public DubboBootstrap getBootstrap() {\n-        return bootstrap;\n-    }\n-\n-    public void setBootstrap(DubboBootstrap bootstrap) {\n-        this.bootstrap = bootstrap;\n-    }\n-\n-    @SuppressWarnings(\"unused\")\n-    private final Object finalizerGuardian = new Object() {\n-        @Override\n-        protected void finalize() throws Throwable {\n-            super.finalize();\n-\n-            if (!ReferenceConfig.this.destroyed) {\n-                logger.warn(\"ReferenceConfig(\" + url + \") is not DESTROYED when FINALIZE\");\n-\n-                /* don't destroy for now\n-                try {\n-                    ReferenceConfig.this.destroy();\n-                } catch (Throwable t) {\n-                        logger.warn(\"Unexpected err when destroy invoker of ReferenceConfig(\" + url + \") in finalize method!\", t);\n-                }\n-                */\n-            }\n-        }\n-    };\n-\n-    public void appendParameters() {\n-        URL appendParametersUrl = URL.valueOf(\"appendParameters://\");\n-        List<AppendParametersComponent> appendParametersComponents = ExtensionLoader.getExtensionLoader(AppendParametersComponent.class).getActivateExtension(appendParametersUrl, (String[]) null);\n-        appendParametersComponents.forEach(component -> component.appendReferParameters(this));\n-    }\n-\n-    // just for test\n-    Invoker<?> getInvoker() {\n-        return invoker;\n-    }\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.dubbo.config;\r\n+\r\n+import org.apache.dubbo.common.URL;\r\n+import org.apache.dubbo.common.Version;\r\n+import org.apache.dubbo.common.bytecode.Wrapper;\r\n+import org.apache.dubbo.common.extension.ExtensionLoader;\r\n+import org.apache.dubbo.common.logger.Logger;\r\n+import org.apache.dubbo.common.logger.LoggerFactory;\r\n+import org.apache.dubbo.common.utils.CollectionUtils;\r\n+import org.apache.dubbo.common.utils.ConfigUtils;\r\n+import org.apache.dubbo.common.utils.NetUtils;\r\n+import org.apache.dubbo.common.utils.StringUtils;\r\n+import org.apache.dubbo.common.utils.UrlUtils;\r\n+import org.apache.dubbo.config.annotation.Reference;\r\n+import org.apache.dubbo.config.bootstrap.DubboBootstrap;\r\n+import org.apache.dubbo.config.event.ReferenceConfigDestroyedEvent;\r\n+import org.apache.dubbo.config.event.ReferenceConfigInitializedEvent;\r\n+import org.apache.dubbo.config.utils.ConfigValidationUtils;\r\n+import org.apache.dubbo.event.Event;\r\n+import org.apache.dubbo.event.EventDispatcher;\r\n+import org.apache.dubbo.metadata.WritableMetadataService;\r\n+import org.apache.dubbo.rpc.Invoker;\r\n+import org.apache.dubbo.rpc.Protocol;\r\n+import org.apache.dubbo.rpc.ProxyFactory;\r\n+import org.apache.dubbo.rpc.cluster.Cluster;\r\n+import org.apache.dubbo.rpc.cluster.directory.StaticDirectory;\r\n+import org.apache.dubbo.rpc.cluster.support.ClusterUtils;\r\n+import org.apache.dubbo.rpc.cluster.support.registry.ZoneAwareCluster;\r\n+import org.apache.dubbo.rpc.model.ApplicationModel;\r\n+import org.apache.dubbo.rpc.model.AsyncMethodInfo;\r\n+import org.apache.dubbo.rpc.model.ConsumerModel;\r\n+import org.apache.dubbo.rpc.model.ServiceDescriptor;\r\n+import org.apache.dubbo.rpc.model.ServiceRepository;\r\n+import org.apache.dubbo.rpc.protocol.injvm.InjvmProtocol;\r\n+import org.apache.dubbo.rpc.service.GenericService;\r\n+import org.apache.dubbo.rpc.support.ProtocolUtils;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+import static org.apache.dubbo.common.constants.CommonConstants.ANY_VALUE;\r\n+import static org.apache.dubbo.common.constants.CommonConstants.CLUSTER_KEY;\r\n+import static org.apache.dubbo.common.constants.CommonConstants.COMMA_SEPARATOR;\r\n+import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER_SIDE;\r\n+import static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_METADATA_STORAGE_TYPE;\r\n+import static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;\r\n+import static org.apache.dubbo.common.constants.CommonConstants.LOCALHOST_VALUE;\r\n+import static org.apache.dubbo.common.constants.CommonConstants.METADATA_KEY;\r\n+import static org.apache.dubbo.common.constants.CommonConstants.METHODS_KEY;\r\n+import static org.apache.dubbo.common.constants.CommonConstants.MONITOR_KEY;\r\n+import static org.apache.dubbo.common.constants.CommonConstants.PROXY_CLASS_REF;\r\n+import static org.apache.dubbo.common.constants.CommonConstants.REVISION_KEY;\r\n+import static org.apache.dubbo.common.constants.CommonConstants.SEMICOLON_SPLIT_PATTERN;\r\n+import static org.apache.dubbo.common.constants.CommonConstants.SIDE_KEY;\r\n+import static org.apache.dubbo.common.utils.NetUtils.isInvalidLocalHost;\r\n+import static org.apache.dubbo.config.Constants.DUBBO_IP_TO_REGISTRY;\r\n+import static org.apache.dubbo.registry.Constants.CONSUMER_PROTOCOL;\r\n+import static org.apache.dubbo.registry.Constants.REGISTER_IP_KEY;\r\n+import static org.apache.dubbo.rpc.Constants.LOCAL_PROTOCOL;\r\n+import static org.apache.dubbo.rpc.cluster.Constants.REFER_KEY;\r\n+\r\n+/**\r\n+ * Please avoid using this class for any new application,\r\n+ * use {@link ReferenceConfigBase} instead.\r\n+ */\r\n+public class ReferenceConfig<T> extends ReferenceConfigBase<T> {\r\n+\r\n+    public static final Logger logger = LoggerFactory.getLogger(ReferenceConfig.class);\r\n+\r\n+    /**\r\n+     * The {@link Protocol} implementation with adaptive functionality,it will be different in different scenarios.\r\n+     * A particular {@link Protocol} implementation is determined by the protocol attribute in the {@link URL}.\r\n+     * For example:\r\n+     *\r\n+     * <li>when the url is registry://224.5.6.7:1234/org.apache.dubbo.registry.RegistryService?application=dubbo-sample,\r\n+     * then the protocol is <b>RegistryProtocol</b></li>\r\n+     *\r\n+     * <li>when the url is dubbo://224.5.6.7:1234/org.apache.dubbo.config.api.DemoService?application=dubbo-sample, then\r\n+     * the protocol is <b>DubboProtocol</b></li>\r\n+     * <p>\r\n+     * Actually\uff0cwhen the {@link ExtensionLoader} init the {@link Protocol} instants,it will automatically wraps two\r\n+     * layers, and eventually will get a <b>ProtocolFilterWrapper</b> or <b>ProtocolListenerWrapper</b>\r\n+     */\r\n+    private static final Protocol REF_PROTOCOL = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();\r\n+\r\n+    /**\r\n+     * The {@link Cluster}'s implementation with adaptive functionality, and actually it will get a {@link Cluster}'s\r\n+     * specific implementation who is wrapped with <b>MockClusterInvoker</b>\r\n+     */\r\n+    private static final Cluster CLUSTER = ExtensionLoader.getExtensionLoader(Cluster.class).getAdaptiveExtension();\r\n+\r\n+    /**\r\n+     * A {@link ProxyFactory} implementation that will generate a reference service's proxy,the JavassistProxyFactory is\r\n+     * its default implementation\r\n+     */\r\n+    private static final ProxyFactory PROXY_FACTORY = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();\r\n+\r\n+    /**\r\n+     * The interface proxy reference\r\n+     */\r\n+    private transient volatile T ref;\r\n+\r\n+    /**\r\n+     * The invoker of the reference service\r\n+     */\r\n+    private transient volatile Invoker<?> invoker;\r\n+\r\n+    /**\r\n+     * The flag whether the ReferenceConfig has been initialized\r\n+     */\r\n+    private transient volatile boolean initialized;\r\n+\r\n+    /**\r\n+     * whether this ReferenceConfig has been destroyed\r\n+     */\r\n+    private transient volatile boolean destroyed;\r\n+\r\n+    private final ServiceRepository repository;\r\n+\r\n+    private DubboBootstrap bootstrap;\r\n+\r\n+    public ReferenceConfig() {\r\n+        super();\r\n+        this.repository = ApplicationModel.getServiceRepository();\r\n+    }\r\n+\r\n+    public ReferenceConfig(Reference reference) {\r\n+        super(reference);\r\n+        this.repository = ApplicationModel.getServiceRepository();\r\n+    }\r\n+\r\n+    public synchronized T get() {\r\n+        if (destroyed) {\r\n+            throw new IllegalStateException(\"The invoker of ReferenceConfig(\" + url + \") has already destroyed!\");\r\n+        }\r\n+        if (ref == null) {\r\n+            init();\r\n+        }\r\n+        return ref;\r\n+    }\r\n+\r\n+    public synchronized void destroy() {\r\n+        if (ref == null) {\r\n+            return;\r\n+        }\r\n+        if (destroyed) {\r\n+            return;\r\n+        }\r\n+        destroyed = true;\r\n+        try {\r\n+            invoker.destroy();\r\n+        } catch (Throwable t) {\r\n+            logger.warn(\"Unexpected error occured when destroy invoker of ReferenceConfig(\" + url + \").\", t);\r\n+        }\r\n+        invoker = null;\r\n+        ref = null;\r\n+\r\n+        // dispatch a ReferenceConfigDestroyedEvent since 2.7.4\r\n+        dispatch(new ReferenceConfigDestroyedEvent(this));\r\n+    }\r\n+\r\n+    public synchronized void init() {\r\n+        if (initialized) {\r\n+            return;\r\n+        }\r\n+\r\n+        if (bootstrap == null) {\r\n+            bootstrap = DubboBootstrap.getInstance();\r\n+            bootstrap.init();\r\n+        }\r\n+\r\n+        checkAndUpdateSubConfigs();\r\n+\r\n+        checkStubAndLocal(interfaceClass);\r\n+        ConfigValidationUtils.checkMock(interfaceClass, this);\r\n+\r\n+        Map<String, String> map = new HashMap<String, String>();\r\n+        map.put(SIDE_KEY, CONSUMER_SIDE);\r\n+\r\n+        ReferenceConfigBase.appendRuntimeParameters(map);\r\n+        if (!ProtocolUtils.isGeneric(generic)) {\r\n+            String revision = Version.getVersion(interfaceClass, version);\r\n+            if (revision != null && revision.length() > 0) {\r\n+                map.put(REVISION_KEY, revision);\r\n+            }\r\n+\r\n+            String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();\r\n+            if (methods.length == 0) {\r\n+                logger.warn(\"No method found in service interface \" + interfaceClass.getName());\r\n+                map.put(METHODS_KEY, ANY_VALUE);\r\n+            } else {\r\n+                map.put(METHODS_KEY, StringUtils.join(new HashSet<String>(Arrays.asList(methods)), COMMA_SEPARATOR));\r\n+            }\r\n+        }\r\n+        map.put(INTERFACE_KEY, interfaceName);\r\n+        AbstractConfig.appendParameters(map, getMetrics());\r\n+        AbstractConfig.appendParameters(map, getApplication());\r\n+        AbstractConfig.appendParameters(map, getModule());\r\n+        // remove 'default.' prefix for configs from ConsumerConfig\r\n+        // appendParameters(map, consumer, Constants.DEFAULT_KEY);\r\n+        AbstractConfig.appendParameters(map, consumer);\r\n+        AbstractConfig.appendParameters(map, this);\r\n+        Map<String, AsyncMethodInfo> attributes = null;\r\n+        if (CollectionUtils.isNotEmpty(getMethods())) {\r\n+            attributes = new HashMap<>();\r\n+            for (MethodConfig methodConfig : getMethods()) {\r\n+                AbstractConfig.appendParameters(map, methodConfig, methodConfig.getName());\r\n+                String retryKey = methodConfig.getName() + \".retry\";\r\n+                if (map.containsKey(retryKey)) {\r\n+                    String retryValue = map.remove(retryKey);\r\n+                    if (\"false\".equals(retryValue)) {\r\n+                        map.put(methodConfig.getName() + \".retries\", \"0\");\r\n+                    }\r\n+                }\r\n+                AsyncMethodInfo asyncMethodInfo = AbstractConfig.convertMethodConfig2AsyncInfo(methodConfig);\r\n+                if (asyncMethodInfo != null) {\r\n+//                    consumerModel.getMethodModel(methodConfig.getName()).addAttribute(ASYNC_KEY, asyncMethodInfo);\r\n+                    attributes.put(methodConfig.getName(), asyncMethodInfo);\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        String hostToRegistry = ConfigUtils.getSystemProperty(DUBBO_IP_TO_REGISTRY);\r\n+        if (StringUtils.isEmpty(hostToRegistry)) {\r\n+            hostToRegistry = NetUtils.getLocalHost();\r\n+        } else if (isInvalidLocalHost(hostToRegistry)) {\r\n+            throw new IllegalArgumentException(\"Specified invalid registry ip from property:\" + DUBBO_IP_TO_REGISTRY + \", value:\" + hostToRegistry);\r\n+        }\r\n+        map.put(REGISTER_IP_KEY, hostToRegistry);\r\n+\r\n+        serviceMetadata.getAttachments().putAll(map);\r\n+\r\n+        ref = createProxy(map);\r\n+\r\n+        serviceMetadata.setTarget(ref);\r\n+        serviceMetadata.addAttribute(PROXY_CLASS_REF, ref);\r\n+        ConsumerModel consumerModel = repository.lookupReferredService(serviceMetadata.getServiceKey());\r\n+        consumerModel.setProxyObject(ref);\r\n+        consumerModel.init(attributes);\r\n+\r\n+        initialized = true;\r\n+\r\n+        // dispatch a ReferenceConfigInitializedEvent since 2.7.4\r\n+        dispatch(new ReferenceConfigInitializedEvent(this, invoker));\r\n+    }\r\n+\r\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\", \"deprecation\"})\r\n+    private T createProxy(Map<String, String> map) {\r\n+        if (shouldJvmRefer(map)) {\r\n+            URL url = new URL(LOCAL_PROTOCOL, LOCALHOST_VALUE, 0, interfaceClass.getName()).addParameters(map);\r\n+            invoker = REF_PROTOCOL.refer(interfaceClass, url);\r\n+            if (logger.isInfoEnabled()) {\r\n+                logger.info(\"Using injvm service \" + interfaceClass.getName());\r\n+            }\r\n+        } else {\r\n+            urls.clear();\r\n+            if (url != null && url.length() > 0) { // user specified URL, could be peer-to-peer address, or register center's address.\r\n+                String[] us = SEMICOLON_SPLIT_PATTERN.split(url);\r\n+                if (us != null && us.length > 0) {\r\n+                    for (String u : us) {\r\n+                        URL url = URL.valueOf(u);\r\n+                        if (StringUtils.isEmpty(url.getPath())) {\r\n+                            url = url.setPath(interfaceName);\r\n+                        }\r\n+                        if (UrlUtils.isRegistry(url)) {\r\n+                            urls.add(url.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));\r\n+                        } else {\r\n+                            urls.add(ClusterUtils.mergeUrl(url, map));\r\n+                        }\r\n+                    }\r\n+                }\r\n+            } else { // assemble URL from register center's configuration\r\n+                // if protocols not injvm checkRegistry\r\n+                if (!LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol())) {\r\n+                    checkRegistry();\r\n+                    List<URL> us = ConfigValidationUtils.loadRegistries(this, false);\r\n+                    if (CollectionUtils.isNotEmpty(us)) {\r\n+                        for (URL u : us) {\r\n+                            URL monitorUrl = ConfigValidationUtils.loadMonitor(this, u);\r\n+                            if (monitorUrl != null) {\r\n+                                map.put(MONITOR_KEY, URL.encode(monitorUrl.toFullString()));\r\n+                            }\r\n+                            urls.add(u.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));\r\n+                        }\r\n+                    }\r\n+                    if (urls.isEmpty()) {\r\n+                        throw new IllegalStateException(\"No such any registry to reference \" + interfaceName + \" on the consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion() + \", please config <dubbo:registry address=\\\"...\\\" /> to your spring config.\");\r\n+                    }\r\n+                }\r\n+            }\r\n+\r\n+            if (urls.size() == 1) {\r\n+                invoker = REF_PROTOCOL.refer(interfaceClass, urls.get(0));\r\n+            } else {\r\n+                List<Invoker<?>> invokers = new ArrayList<Invoker<?>>();\r\n+                URL registryURL = null;\r\n+                for (URL url : urls) {\r\n+                    invokers.add(REF_PROTOCOL.refer(interfaceClass, url));\r\n+                    if (UrlUtils.isRegistry(url)) {\r\n+                        registryURL = url; // use last registry url\r\n+                    }\r\n+                }\r\n+                if (registryURL != null) { // registry url is available\r\n+                    // for multi-subscription scenario, use 'zone-aware' policy by default\r\n+                    URL u = registryURL.addParameterIfAbsent(CLUSTER_KEY, ZoneAwareCluster.NAME);\r\n+                    // The invoker wrap relation would be like: ZoneAwareClusterInvoker(StaticDirectory) -> FailoverClusterInvoker(RegistryDirectory, routing happens here) -> Invoker\r\n+                    invoker = CLUSTER.join(new StaticDirectory(u, invokers));\r\n+                } else { // not a registry url, must be direct invoke.\r\n+                    invoker = CLUSTER.join(new StaticDirectory(invokers));\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        if (shouldCheck() && !invoker.isAvailable()) {\r\n+            throw new IllegalStateException(\"Failed to check the status of the service \"\r\n+                    + interfaceName\r\n+                    + \". No provider available for the service \"\r\n+                    + (group == null ? \"\" : group + \"/\")\r\n+                    + interfaceName +\r\n+                    (version == null ? \"\" : \":\" + version)\r\n+                    + \" from the url \"\r\n+                    + invoker.getUrl()\r\n+                    + \" to the consumer \"\r\n+                    + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion());\r\n+        }\r\n+        if (logger.isInfoEnabled()) {\r\n+            logger.info(\"Refer dubbo service \" + interfaceClass.getName() + \" from url \" + invoker.getUrl());\r\n+        }\r\n+        /**\r\n+         * @since 2.7.0\r\n+         * ServiceData Store\r\n+         */\r\n+        String metadata = map.get(METADATA_KEY);\r\n+        WritableMetadataService metadataService = WritableMetadataService.getExtension(metadata == null ? DEFAULT_METADATA_STORAGE_TYPE : metadata);\r\n+        if (metadataService != null) {\r\n+            URL consumerURL = new URL(CONSUMER_PROTOCOL, map.remove(REGISTER_IP_KEY), 0, map.get(INTERFACE_KEY), map);\r\n+            metadataService.publishServiceDefinition(consumerURL);\r\n+        }\r\n+        // create service proxy\r\n+        return (T) PROXY_FACTORY.getProxy(invoker);\r\n+    }\r\n+\r\n+    /**\r", "originalCommit": "2e06581b8b9460c2d4dce17b446812465e7386e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "850d1b720a6bae0d31eca07ccf231c0f23feaa7d", "url": "https://github.com/apache/dubbo/commit/850d1b720a6bae0d31eca07ccf231c0f23feaa7d", "message": "refactor configPostProcessor and merge dubbo3", "committedDate": "2020-01-03T09:20:18Z", "type": "commit"}]}