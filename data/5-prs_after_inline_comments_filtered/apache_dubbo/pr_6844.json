{"pr_number": 6844, "pr_title": "[3.0] Feature/state router", "pr_createdAt": "2020-10-28T11:41:14Z", "pr_url": "https://github.com/apache/dubbo/pull/6844", "timeline": [{"oid": "c047d2c1f102d9380a65a29127d4ba1b387d6901", "url": "https://github.com/apache/dubbo/commit/c047d2c1f102d9380a65a29127d4ba1b387d6901", "message": "import stateTagRouter", "committedDate": "2020-10-28T12:18:46Z", "type": "forcePushed"}, {"oid": "7ff8971b27b483fec71ae7b2caaeefd5b0c8bf55", "url": "https://github.com/apache/dubbo/commit/7ff8971b27b483fec71ae7b2caaeefd5b0c8bf55", "message": "import stateTagRouter", "committedDate": "2020-10-28T12:27:15Z", "type": "forcePushed"}, {"oid": "9e4737615a92f525b2a6f89eba5912d91266e33d", "url": "https://github.com/apache/dubbo/commit/9e4737615a92f525b2a6f89eba5912d91266e33d", "message": "import stateTagRouter", "committedDate": "2020-10-29T02:33:57Z", "type": "forcePushed"}, {"oid": "ca1ad9cbd797075bd9c337834af91ba3c3244412", "url": "https://github.com/apache/dubbo/commit/ca1ad9cbd797075bd9c337834af91ba3c3244412", "message": "state router", "committedDate": "2021-04-27T07:21:45Z", "type": "commit"}, {"oid": "593026c0381fb38d6a606ce00737e53fc34a96be", "url": "https://github.com/apache/dubbo/commit/593026c0381fb38d6a606ce00737e53fc34a96be", "message": "fix router chain", "committedDate": "2021-04-28T09:12:05Z", "type": "commit"}, {"oid": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9", "url": "https://github.com/apache/dubbo/commit/578339260dc03b9bdf34ae7f80d2daa16f91ddb9", "message": "fix router chain", "committedDate": "2021-04-29T02:27:59Z", "type": "commit"}, {"oid": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9", "url": "https://github.com/apache/dubbo/commit/578339260dc03b9bdf34ae7f80d2daa16f91ddb9", "message": "fix router chain", "committedDate": "2021-04-29T02:27:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwNTY3NQ==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623605675", "bodyText": "pls comment in English", "author": "AlbumenJ", "createdAt": "2021-04-30T04:49:18Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -98,7 +167,30 @@ private void sort() {\n      * @return\n      */\n     public List<Invoker<T>> route(URL url, Invocation invocation) {\n-        List<Invoker<T>> finalInvokers = invokers;\n+\n+        AddrCache cache = this.cache.get();\n+        if (cache == null) {\n+            throw new RpcException(RpcException.ROUTER_CACHE_NOT_BUILD, \"Failed to invoke the method \"\n+                + invocation.getMethodName() + \" in the service \" + url.getServiceInterface()\n+                + \". address cache not build \"\n+                + \" on the consumer \" + NetUtils.getLocalHost()\n+                + \" using the dubbo version \" + Version.getVersion()\n+                + \".\");\n+        }\n+        BitList<Invoker<T>> finalBitListInvokers = new BitList<Invoker<T>>(invokers, false);\n+        for (StateRouter stateRouter : stateRouters) {\n+            if (stateRouter.isEnable()) {\n+                finalBitListInvokers = stateRouter.route(finalBitListInvokers, cache.getCache().get(stateRouter.getName()), url, invocation);\n+            }\n+        }\n+\n+        // FIXME \u770b\u4e00\u4e0b\u9ad8\u7248\u672c\u7684RoaringBitMap\uff0c\u662f\u5426\u6709\u5185\u7f6e\u51fd\u6570\u652f\u6301\u66f4\u9ad8\u6548\u7684\u904d\u5386", "originalCommit": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwNjE4NQ==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623606185", "bodyText": "is this executor necessary?", "author": "AlbumenJ", "createdAt": "2021-04-30T04:50:01Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -111,6 +203,96 @@ private void sort() {\n      */\n     public void setInvokers(List<Invoker<T>> invokers) {\n         this.invokers = (invokers == null ? Collections.emptyList() : invokers);\n+        stateRouters.forEach(router -> router.notify(this.invokers));\n         routers.forEach(router -> router.notify(this.invokers));\n+        loop(true);\n+    }\n+\n+    private void buildCache(boolean notify) {\n+        if (invokers == null || invokers.size() <= 0) {\n+            return;\n+        }\n+        AddrCache origin = cache.get();\n+        List copyInvokers = new ArrayList<>(this.invokers);\n+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());\n+        AddrCache newCache = new AddrCache();\n+        newCache.setInvokers((List)invokers);\n+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);\n+        for (StateRouter stateRouter : (List<StateRouter>)stateRouters) {\n+            if (stateRouter.isEnable()) {\n+                executorRepository.getPoolRouterExecutor().execute(new Runnable() {", "originalCommit": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwNjc3Mg==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623606772", "bodyText": "is this works? Just wrapped with RPCException and throw it would be better?", "author": "AlbumenJ", "createdAt": "2021-04-30T04:50:54Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -111,6 +203,96 @@ private void sort() {\n      */\n     public void setInvokers(List<Invoker<T>> invokers) {\n         this.invokers = (invokers == null ? Collections.emptyList() : invokers);\n+        stateRouters.forEach(router -> router.notify(this.invokers));\n         routers.forEach(router -> router.notify(this.invokers));\n+        loop(true);\n+    }\n+\n+    private void buildCache(boolean notify) {\n+        if (invokers == null || invokers.size() <= 0) {\n+            return;\n+        }\n+        AddrCache origin = cache.get();\n+        List copyInvokers = new ArrayList<>(this.invokers);\n+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());\n+        AddrCache newCache = new AddrCache();\n+        newCache.setInvokers((List)invokers);\n+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);\n+        for (StateRouter stateRouter : (List<StateRouter>)stateRouters) {\n+            if (stateRouter.isEnable()) {\n+                executorRepository.getPoolRouterExecutor().execute(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        RouterCache routerCache = null;\n+                        try {\n+                            routerCache = poolRouter(stateRouter, origin, copyInvokers, notify);\n+                            //file cache\n+                            newCache.getCache().put(stateRouter.getName(), routerCache);\n+                        } catch (Throwable t) {\n+                            poolSuccess.set(false);\n+                            logger.error(\"Failed to pool router: \" + stateRouter.getUrl() + \", cause: \" + t.getMessage(), t);\n+                        } finally {\n+                            cdl.countDown();\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+        try {\n+            cdl.await();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();", "originalCommit": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwNjk4NA==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623606984", "bodyText": "Please comment in English", "author": "AlbumenJ", "createdAt": "2021-04-30T04:51:12Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -111,6 +203,96 @@ private void sort() {\n      */\n     public void setInvokers(List<Invoker<T>> invokers) {\n         this.invokers = (invokers == null ? Collections.emptyList() : invokers);\n+        stateRouters.forEach(router -> router.notify(this.invokers));\n         routers.forEach(router -> router.notify(this.invokers));\n+        loop(true);\n+    }\n+\n+    private void buildCache(boolean notify) {\n+        if (invokers == null || invokers.size() <= 0) {\n+            return;\n+        }\n+        AddrCache origin = cache.get();\n+        List copyInvokers = new ArrayList<>(this.invokers);\n+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());\n+        AddrCache newCache = new AddrCache();\n+        newCache.setInvokers((List)invokers);\n+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);\n+        for (StateRouter stateRouter : (List<StateRouter>)stateRouters) {\n+            if (stateRouter.isEnable()) {\n+                executorRepository.getPoolRouterExecutor().execute(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        RouterCache routerCache = null;\n+                        try {\n+                            routerCache = poolRouter(stateRouter, origin, copyInvokers, notify);\n+                            //file cache\n+                            newCache.getCache().put(stateRouter.getName(), routerCache);\n+                        } catch (Throwable t) {\n+                            poolSuccess.set(false);\n+                            logger.error(\"Failed to pool router: \" + stateRouter.getUrl() + \", cause: \" + t.getMessage(), t);\n+                        } finally {\n+                            cdl.countDown();\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+        try {\n+            cdl.await();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+\n+        if (poolSuccess.get()) {\n+            this.cache.set(newCache);\n+        }\n+    }\n+\n+    private RouterCache poolRouter(StateRouter router, AddrCache orign, List<Invoker<T>> invokers, boolean notify) {\n+        String routerName = router.getName();\n+        RouterCache routerCache = null;\n+        if (isCacheMiss(orign, routerName) || router.shouldRePool() || notify) {\n+            return router.pool(invokers);\n+        } else {\n+            routerCache = orign.getCache().get(routerName);\n+        }\n+        if (routerCache == null) {\n+            return new RouterCache();\n+        }\n+        return routerCache;\n+    }\n+\n+    private boolean isCacheMiss(AddrCache cache, String routerName) {\n+        if (cache == null || cache.getCache() == null || cache.getInvokers() == null || cache.getCache().get(routerName) == null) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public void loop(boolean notify) {\n+        // 1\u3001\u591a\u4e2a\u670d\u52a1\u5e76\u884c\u6267\u884c buildCache", "originalCommit": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwNzgyMA==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623607820", "bodyText": "Try make this Runnable as a static class reference or lambda reference. Reduce inner class creation.", "author": "AlbumenJ", "createdAt": "2021-04-30T04:52:20Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -111,6 +203,96 @@ private void sort() {\n      */\n     public void setInvokers(List<Invoker<T>> invokers) {\n         this.invokers = (invokers == null ? Collections.emptyList() : invokers);\n+        stateRouters.forEach(router -> router.notify(this.invokers));\n         routers.forEach(router -> router.notify(this.invokers));\n+        loop(true);\n+    }\n+\n+    private void buildCache(boolean notify) {\n+        if (invokers == null || invokers.size() <= 0) {\n+            return;\n+        }\n+        AddrCache origin = cache.get();\n+        List copyInvokers = new ArrayList<>(this.invokers);\n+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());\n+        AddrCache newCache = new AddrCache();\n+        newCache.setInvokers((List)invokers);\n+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);\n+        for (StateRouter stateRouter : (List<StateRouter>)stateRouters) {\n+            if (stateRouter.isEnable()) {\n+                executorRepository.getPoolRouterExecutor().execute(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        RouterCache routerCache = null;\n+                        try {\n+                            routerCache = poolRouter(stateRouter, origin, copyInvokers, notify);\n+                            //file cache\n+                            newCache.getCache().put(stateRouter.getName(), routerCache);\n+                        } catch (Throwable t) {\n+                            poolSuccess.set(false);\n+                            logger.error(\"Failed to pool router: \" + stateRouter.getUrl() + \", cause: \" + t.getMessage(), t);\n+                        } finally {\n+                            cdl.countDown();\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+        try {\n+            cdl.await();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+\n+        if (poolSuccess.get()) {\n+            this.cache.set(newCache);\n+        }\n+    }\n+\n+    private RouterCache poolRouter(StateRouter router, AddrCache orign, List<Invoker<T>> invokers, boolean notify) {\n+        String routerName = router.getName();\n+        RouterCache routerCache = null;\n+        if (isCacheMiss(orign, routerName) || router.shouldRePool() || notify) {\n+            return router.pool(invokers);\n+        } else {\n+            routerCache = orign.getCache().get(routerName);\n+        }\n+        if (routerCache == null) {\n+            return new RouterCache();\n+        }\n+        return routerCache;\n+    }\n+\n+    private boolean isCacheMiss(AddrCache cache, String routerName) {\n+        if (cache == null || cache.getCache() == null || cache.getInvokers() == null || cache.getCache().get(routerName) == null) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public void loop(boolean notify) {\n+        // 1\u3001\u591a\u4e2a\u670d\u52a1\u5e76\u884c\u6267\u884c buildCache\n+        // 2\u3001notify true/false\n+        if (notify) {\n+            if (loopPermitNotify.tryAcquire()) {\n+                LOOP_THREAD_POOL.submit(new Runnable() {", "originalCommit": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwODEzMA==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623608130", "bodyText": "Please add Apache License header", "author": "AlbumenJ", "createdAt": "2021-04-30T04:52:47Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/AddrCache.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package org.apache.dubbo.rpc.cluster.router.state;", "originalCommit": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwODE2OQ==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623608169", "bodyText": "Please add Apache License header", "author": "AlbumenJ", "createdAt": "2021-04-30T04:52:50Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/BitList.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.apache.dubbo.rpc.cluster.router.state;", "originalCommit": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwODM3NA==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623608374", "bodyText": "Please add Apache License header", "author": "AlbumenJ", "createdAt": "2021-04-30T04:53:08Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/RouterCache.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package org.apache.dubbo.rpc.cluster.router.state;", "originalCommit": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwODQyOQ==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623608429", "bodyText": "Please add Apache License header", "author": "AlbumenJ", "createdAt": "2021-04-30T04:53:14Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/StateRouterFactory.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package org.apache.dubbo.rpc.cluster.router.state;", "originalCommit": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwODcxMw==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623608713", "bodyText": "Please comment in English", "author": "AlbumenJ", "createdAt": "2021-04-30T04:53:37Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagDynamicStateRouter.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.tag;\n+\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.config.configcenter.ConfigChangeType;\n+import org.apache.dubbo.common.config.configcenter.ConfigChangedEvent;\n+import org.apache.dubbo.common.config.configcenter.ConfigurationListener;\n+import org.apache.dubbo.common.config.configcenter.DynamicConfiguration;\n+import org.apache.dubbo.common.constants.CommonConstants;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n+import org.apache.dubbo.common.utils.NetUtils;\n+import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.cluster.RouterChain;\n+import org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter;\n+import org.apache.dubbo.rpc.cluster.router.state.BitList;\n+import org.apache.dubbo.rpc.cluster.router.state.RouterCache;\n+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRouterRule;\n+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRuleParser;\n+\n+import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_VALUE;\n+import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;\n+import static org.apache.dubbo.rpc.Constants.FORCE_USE_TAG;\n+\n+/**\n+ * TagRouter, \"application.tag-router\"\n+ */\n+public class TagDynamicStateRouter extends AbstractStateRouter implements ConfigurationListener {\n+    public static final String NAME = \"TAG_ROUTER\";\n+    private static final int TAG_ROUTER_DEFAULT_PRIORITY = 100;\n+    private static final Logger logger = LoggerFactory.getLogger(TagDynamicStateRouter.class);\n+    private static final String RULE_SUFFIX = \".tag-router\";\n+    private static final String NO_TAG = \"noTag\";\n+\n+    private TagRouterRule tagRouterRule;\n+    private String application;\n+\n+    public TagDynamicStateRouter(URL url, RouterChain chain) {\n+        super(url, chain);\n+        this.priority = TAG_ROUTER_DEFAULT_PRIORITY;\n+    }\n+\n+    @Override\n+    public synchronized void process(ConfigChangedEvent event) {\n+        setForce(true);\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Notification of tag rule, change type is: \" + event.getChangeType() + \", raw rule is:\\n \" +\n+                    event.getContent());\n+        }\n+\n+        try {\n+            if (event.getChangeType().equals(ConfigChangeType.DELETED)) {\n+                this.tagRouterRule = null;\n+            } else {\n+                this.tagRouterRule = TagRuleParser.parse(event.getContent());\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Failed to parse the raw tag router rule and it will not take effect, please check if the \" +\n+                    \"rule matches with the template, the raw rule is:\\n \", e);\n+        }\n+    }\n+\n+    @Override\n+    public URL getUrl() {\n+        return url;\n+    }\n+\n+    @Override\n+    public <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache cache, URL url,\n+        Invocation invocation) throws RpcException {\n+\n+\n+        final TagRouterRule tagRouterRuleCopy = (TagRouterRule)cache.getAddrMetadata();\n+\n+        String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :\n+            invocation.getAttachment(TAG_KEY);\n+\n+        ConcurrentHashMap<String, BitList<Invoker>> addrPool = cache.getAddrPool();\n+\n+        if (StringUtils.isEmpty(tag)) {\n+            return invokers.intersect((BitList)addrPool.get(NO_TAG), invokers.getUnmodifiableList());\n+        } else {\n+            BitList<Invoker> result = addrPool.get(tag);\n+\n+            if (CollectionUtils.isNotEmpty(result) || (tagRouterRuleCopy != null && tagRouterRuleCopy.isForce())\n+                || isForceUseTag(invocation)) {\n+                return invokers.intersect((BitList)result, invokers.getUnmodifiableList());\n+            } else {\n+                invocation.setAttachment(TAG_KEY, NO_TAG);\n+                return invokers;\n+            }\n+        }\n+    }\n+\n+    private boolean isForceUseTag(Invocation invocation) {\n+        return Boolean.valueOf(invocation.getAttachment(FORCE_USE_TAG, url.getParameter(FORCE_USE_TAG, \"false\")));\n+    }\n+\n+    @Override\n+    public boolean isRuntime() {\n+        return tagRouterRule != null && tagRouterRule.isRuntime();\n+    }\n+\n+    @Override\n+    public boolean isEnable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isForce() {\n+        return tagRouterRule != null && tagRouterRule.isForce();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"TagDynamic\";\n+    }\n+\n+    @Override\n+    public boolean shouldRePool() {\n+        return false;\n+    }\n+\n+    @Override\n+    public <T> RouterCache pool(List<Invoker<T>> invokers) {\n+\n+        RouterCache routerCache = new RouterCache();\n+        ConcurrentHashMap<String, BitList<Invoker<T>>> addrPool = new ConcurrentHashMap<>();\n+\n+        final TagRouterRule tagRouterRuleCopy = tagRouterRule;\n+\n+\n+        if (tagRouterRuleCopy == null || !tagRouterRuleCopy.isValid() || !tagRouterRuleCopy.isEnabled()) {\n+            return routerCache;\n+        }\n+\n+        List<String> tagNames = tagRouterRuleCopy.getTagNames();\n+        Map<String, List<String>> tagnameToAddresses = tagRouterRuleCopy.getTagnameToAddresses();\n+\n+        for (String tag : tagNames) {\n+            List<String> addresses = tagnameToAddresses.get(tag);\n+            BitList<Invoker<T>> list = new BitList<>(invokers, true);\n+            // \u5730\u5740\u4e3a\u7a7a\uff0c\u5219\u52a8\u6001\u8def\u7531\u4e0d\u751f\u6548\uff0c\u76f4\u63a5\u770b\u9759\u6001\u8def\u7531", "originalCommit": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzYwOTE2Nw==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r623609167", "bodyText": "try specify inital size", "author": "AlbumenJ", "createdAt": "2021-04-30T04:54:18Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagDynamicStateRouter.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.tag;\n+\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.config.configcenter.ConfigChangeType;\n+import org.apache.dubbo.common.config.configcenter.ConfigChangedEvent;\n+import org.apache.dubbo.common.config.configcenter.ConfigurationListener;\n+import org.apache.dubbo.common.config.configcenter.DynamicConfiguration;\n+import org.apache.dubbo.common.constants.CommonConstants;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n+import org.apache.dubbo.common.utils.NetUtils;\n+import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.cluster.RouterChain;\n+import org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter;\n+import org.apache.dubbo.rpc.cluster.router.state.BitList;\n+import org.apache.dubbo.rpc.cluster.router.state.RouterCache;\n+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRouterRule;\n+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRuleParser;\n+\n+import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_VALUE;\n+import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;\n+import static org.apache.dubbo.rpc.Constants.FORCE_USE_TAG;\n+\n+/**\n+ * TagRouter, \"application.tag-router\"\n+ */\n+public class TagDynamicStateRouter extends AbstractStateRouter implements ConfigurationListener {\n+    public static final String NAME = \"TAG_ROUTER\";\n+    private static final int TAG_ROUTER_DEFAULT_PRIORITY = 100;\n+    private static final Logger logger = LoggerFactory.getLogger(TagDynamicStateRouter.class);\n+    private static final String RULE_SUFFIX = \".tag-router\";\n+    private static final String NO_TAG = \"noTag\";\n+\n+    private TagRouterRule tagRouterRule;\n+    private String application;\n+\n+    public TagDynamicStateRouter(URL url, RouterChain chain) {\n+        super(url, chain);\n+        this.priority = TAG_ROUTER_DEFAULT_PRIORITY;\n+    }\n+\n+    @Override\n+    public synchronized void process(ConfigChangedEvent event) {\n+        setForce(true);\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Notification of tag rule, change type is: \" + event.getChangeType() + \", raw rule is:\\n \" +\n+                    event.getContent());\n+        }\n+\n+        try {\n+            if (event.getChangeType().equals(ConfigChangeType.DELETED)) {\n+                this.tagRouterRule = null;\n+            } else {\n+                this.tagRouterRule = TagRuleParser.parse(event.getContent());\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Failed to parse the raw tag router rule and it will not take effect, please check if the \" +\n+                    \"rule matches with the template, the raw rule is:\\n \", e);\n+        }\n+    }\n+\n+    @Override\n+    public URL getUrl() {\n+        return url;\n+    }\n+\n+    @Override\n+    public <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache cache, URL url,\n+        Invocation invocation) throws RpcException {\n+\n+\n+        final TagRouterRule tagRouterRuleCopy = (TagRouterRule)cache.getAddrMetadata();\n+\n+        String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :\n+            invocation.getAttachment(TAG_KEY);\n+\n+        ConcurrentHashMap<String, BitList<Invoker>> addrPool = cache.getAddrPool();\n+\n+        if (StringUtils.isEmpty(tag)) {\n+            return invokers.intersect((BitList)addrPool.get(NO_TAG), invokers.getUnmodifiableList());\n+        } else {\n+            BitList<Invoker> result = addrPool.get(tag);\n+\n+            if (CollectionUtils.isNotEmpty(result) || (tagRouterRuleCopy != null && tagRouterRuleCopy.isForce())\n+                || isForceUseTag(invocation)) {\n+                return invokers.intersect((BitList)result, invokers.getUnmodifiableList());\n+            } else {\n+                invocation.setAttachment(TAG_KEY, NO_TAG);\n+                return invokers;\n+            }\n+        }\n+    }\n+\n+    private boolean isForceUseTag(Invocation invocation) {\n+        return Boolean.valueOf(invocation.getAttachment(FORCE_USE_TAG, url.getParameter(FORCE_USE_TAG, \"false\")));\n+    }\n+\n+    @Override\n+    public boolean isRuntime() {\n+        return tagRouterRule != null && tagRouterRule.isRuntime();\n+    }\n+\n+    @Override\n+    public boolean isEnable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isForce() {\n+        return tagRouterRule != null && tagRouterRule.isForce();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"TagDynamic\";\n+    }\n+\n+    @Override\n+    public boolean shouldRePool() {\n+        return false;\n+    }\n+\n+    @Override\n+    public <T> RouterCache pool(List<Invoker<T>> invokers) {\n+\n+        RouterCache routerCache = new RouterCache();\n+        ConcurrentHashMap<String, BitList<Invoker<T>>> addrPool = new ConcurrentHashMap<>();", "originalCommit": "578339260dc03b9bdf34ae7f80d2daa16f91ddb9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9dfe5469c762d5f354aa9f9bf99325f4bba67e2b", "url": "https://github.com/apache/dubbo/commit/9dfe5469c762d5f354aa9f9bf99325f4bba67e2b", "message": "fix comment", "committedDate": "2021-05-11T07:58:52Z", "type": "commit"}, {"oid": "54f3970065ecc99e862811cdb851503e25207b5b", "url": "https://github.com/apache/dubbo/commit/54f3970065ecc99e862811cdb851503e25207b5b", "message": "fix comment", "committedDate": "2021-05-11T08:16:53Z", "type": "commit"}, {"oid": "90f2923d82438ac0be0336442ca03628e2054b56", "url": "https://github.com/apache/dubbo/commit/90f2923d82438ac0be0336442ca03628e2054b56", "message": "Merge remote-tracking branch 'origin/3.0' into staterouter-0427", "committedDate": "2021-05-11T08:36:19Z", "type": "commit"}, {"oid": "3d3c31f72b3eb970f4f2785951809c25b858aca3", "url": "https://github.com/apache/dubbo/commit/3d3c31f72b3eb970f4f2785951809c25b858aca3", "message": "format files", "committedDate": "2021-05-12T02:31:53Z", "type": "commit"}, {"oid": "b6239270334178742fe512cb4738d6b1b3e27fc7", "url": "https://github.com/apache/dubbo/commit/b6239270334178742fe512cb4738d6b1b3e27fc7", "message": "deal dependecy", "committedDate": "2021-05-12T02:49:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY4ODcxMw==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630688713", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final ExecutorRepository executorRepository = ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension();\n          \n          \n            \n                private static final ExecutorRepository REPO = ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension();", "author": "guohao", "createdAt": "2021-05-12T02:51:55Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -45,11 +69,27 @@\n     // instance will never delete or recreate.\n     private List<Router> builtinRouters = Collections.emptyList();\n \n+    private List<StateRouter> builtinStateRouters = Collections.emptyList();\n+    private List<StateRouter> stateRouters = Collections.emptyList();\n+    private final ExecutorRepository executorRepository = ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension();", "originalCommit": "90f2923d82438ac0be0336442ca03628e2054b56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY4ODg4Nw==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630688887", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final ExecutorService LOOP_THREAD_POOL;\n          \n          \n            \n                private final ExecutorService  loopPool;", "author": "guohao", "createdAt": "2021-05-12T02:52:32Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -45,11 +69,27 @@\n     // instance will never delete or recreate.\n     private List<Router> builtinRouters = Collections.emptyList();\n \n+    private List<StateRouter> builtinStateRouters = Collections.emptyList();\n+    private List<StateRouter> stateRouters = Collections.emptyList();\n+    private final ExecutorRepository executorRepository = ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension();\n+\n+    protected URL url;\n+\n+    protected AtomicReference<AddrCache> cache = new AtomicReference<>();\n+\n+    private Semaphore loopPermit = new Semaphore(1);\n+    private Semaphore loopPermitNotify = new Semaphore(1);\n+\n+    private final ExecutorService LOOP_THREAD_POOL;", "originalCommit": "90f2923d82438ac0be0336442ca03628e2054b56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY4OTAxMg==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630689012", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Semaphore loopPermit = new Semaphore(1);\n          \n          \n            \n                private final Semaphore loopPermit = new Semaphore(1);", "author": "guohao", "createdAt": "2021-05-12T02:52:57Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -45,11 +69,27 @@\n     // instance will never delete or recreate.\n     private List<Router> builtinRouters = Collections.emptyList();\n \n+    private List<StateRouter> builtinStateRouters = Collections.emptyList();\n+    private List<StateRouter> stateRouters = Collections.emptyList();\n+    private final ExecutorRepository executorRepository = ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension();\n+\n+    protected URL url;\n+\n+    protected AtomicReference<AddrCache> cache = new AtomicReference<>();\n+\n+    private Semaphore loopPermit = new Semaphore(1);", "originalCommit": "90f2923d82438ac0be0336442ca03628e2054b56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY4OTE4Ng==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630689186", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Semaphore loopPermitNotify = new Semaphore(1);\n          \n          \n            \n                private final Semaphore loopPermitNotify = new Semaphore(1);", "author": "guohao", "createdAt": "2021-05-12T02:53:31Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -45,11 +69,27 @@\n     // instance will never delete or recreate.\n     private List<Router> builtinRouters = Collections.emptyList();\n \n+    private List<StateRouter> builtinStateRouters = Collections.emptyList();\n+    private List<StateRouter> stateRouters = Collections.emptyList();\n+    private final ExecutorRepository executorRepository = ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension();\n+\n+    protected URL url;\n+\n+    protected AtomicReference<AddrCache> cache = new AtomicReference<>();\n+\n+    private Semaphore loopPermit = new Semaphore(1);\n+    private Semaphore loopPermitNotify = new Semaphore(1);", "originalCommit": "90f2923d82438ac0be0336442ca03628e2054b56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY4OTY4OA==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630689688", "bodyText": "unused method", "author": "guohao", "createdAt": "2021-05-12T02:55:12Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -70,6 +121,15 @@ public void initWithRouters(List<Router> builtinRouters) {\n         this.sort();\n     }\n \n+    public void initWithStateRouters(List<StateRouter> builtinRouters) {\n+        this.builtinStateRouters = builtinRouters;\n+        this.stateRouters = new ArrayList<>(builtinRouters);\n+    }\n+\n+    private void sortStateRouters() {", "originalCommit": "90f2923d82438ac0be0336442ca03628e2054b56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY4OTc2Mg==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630689762", "bodyText": "unused method", "author": "guohao", "createdAt": "2021-05-12T02:55:32Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -86,6 +146,13 @@ public void addRouters(List<Router> routers) {\n         this.routers = newRouters;\n     }\n \n+    public void addStateRouters(List<StateRouter> stateRouters) {", "originalCommit": "90f2923d82438ac0be0336442ca03628e2054b56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5MDg1NA==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630690854", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    while (iter.hasNext()) {\n          \n          \n            \n                    for(Invoker<T> invoker: finalBitListInvokers)", "author": "guohao", "createdAt": "2021-05-12T02:59:09Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -95,13 +157,35 @@ private void sort() {\n     }\n \n     /**\n-     *\n      * @param url\n      * @param invocation\n      * @return\n      */\n     public List<Invoker<T>> route(URL url, Invocation invocation) {\n-        List<Invoker<T>> finalInvokers = invokers;\n+\n+        AddrCache cache = this.cache.get();\n+        if (cache == null) {\n+            throw new RpcException(RpcException.ROUTER_CACHE_NOT_BUILD, \"Failed to invoke the method \"\n+                + invocation.getMethodName() + \" in the service \" + url.getServiceInterface()\n+                + \". address cache not build \"\n+                + \" on the consumer \" + NetUtils.getLocalHost()\n+                + \" using the dubbo version \" + Version.getVersion()\n+                + \".\");\n+        }\n+        BitList<Invoker<T>> finalBitListInvokers = new BitList<Invoker<T>>(invokers, false);\n+        for (StateRouter stateRouter : stateRouters) {\n+            if (stateRouter.isEnable()) {\n+                finalBitListInvokers = stateRouter.route(finalBitListInvokers,\n+                    cache.getCache().get(stateRouter.getName()), url, invocation);\n+            }\n+        }\n+\n+        List<Invoker<T>> finalInvokers = new ArrayList<>(finalBitListInvokers.size());\n+        Iterator<Invoker<T>> iter = finalBitListInvokers.iterator();\n+        while (iter.hasNext()) {", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5MDk0OA==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630690948", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<Invoker<T>> copyInvokers = new ArrayList<Invoker<T>>(this.invokers);\n          \n          \n            \n                    List<Invoker<T>> copyInvokers = new ArrayList<>(this.invokers);", "author": "guohao", "createdAt": "2021-05-12T02:59:31Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -114,7 +198,87 @@ private void sort() {\n      */\n     public void setInvokers(List<Invoker<T>> invokers) {\n         this.invokers = (invokers == null ? Collections.emptyList() : invokers);\n+        stateRouters.forEach(router -> router.notify(this.invokers));\n         routers.forEach(router -> router.notify(this.invokers));\n+        loop(true);\n+    }\n+\n+    private void buildCache(boolean notify) {\n+        if (invokers == null || invokers.size() <= 0) {\n+            return;\n+        }\n+        AddrCache origin = cache.get();\n+        List<Invoker<T>> copyInvokers = new ArrayList<Invoker<T>>(this.invokers);", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5MTc2OQ==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630691769", "bodyText": "unused var", "author": "guohao", "createdAt": "2021-05-12T03:02:16Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -114,7 +198,87 @@ private void sort() {\n      */\n     public void setInvokers(List<Invoker<T>> invokers) {\n         this.invokers = (invokers == null ? Collections.emptyList() : invokers);\n+        stateRouters.forEach(router -> router.notify(this.invokers));\n         routers.forEach(router -> router.notify(this.invokers));\n+        loop(true);\n+    }\n+\n+    private void buildCache(boolean notify) {\n+        if (invokers == null || invokers.size() <= 0) {\n+            return;\n+        }\n+        AddrCache origin = cache.get();\n+        List<Invoker<T>> copyInvokers = new ArrayList<Invoker<T>>(this.invokers);\n+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5MjA2Mg==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630692062", "bodyText": "remove this var", "author": "guohao", "createdAt": "2021-05-12T03:03:13Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -114,7 +198,87 @@ private void sort() {\n      */\n     public void setInvokers(List<Invoker<T>> invokers) {\n         this.invokers = (invokers == null ? Collections.emptyList() : invokers);\n+        stateRouters.forEach(router -> router.notify(this.invokers));\n         routers.forEach(router -> router.notify(this.invokers));\n+        loop(true);\n+    }\n+\n+    private void buildCache(boolean notify) {\n+        if (invokers == null || invokers.size() <= 0) {\n+            return;\n+        }\n+        AddrCache origin = cache.get();\n+        List<Invoker<T>> copyInvokers = new ArrayList<Invoker<T>>(this.invokers);\n+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());\n+        AddrCache newCache = new AddrCache();\n+        newCache.setInvokers((List)invokers);\n+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5MjcxOA==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630692718", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        RouterCache routerCache;\n          \n          \n            \n                      \n          \n          \n            \n                        try{\n          \n          \n            \n                          for(;;)\n          \n          \n            \n                          this.cache.set()\n          \n          \n            \n                          }catch{\n          \n          \n            \n                          }", "author": "guohao", "createdAt": "2021-05-12T03:05:32Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -114,7 +198,87 @@ private void sort() {\n      */\n     public void setInvokers(List<Invoker<T>> invokers) {\n         this.invokers = (invokers == null ? Collections.emptyList() : invokers);\n+        stateRouters.forEach(router -> router.notify(this.invokers));\n         routers.forEach(router -> router.notify(this.invokers));\n+        loop(true);\n+    }\n+\n+    private void buildCache(boolean notify) {\n+        if (invokers == null || invokers.size() <= 0) {\n+            return;\n+        }\n+        AddrCache origin = cache.get();\n+        List<Invoker<T>> copyInvokers = new ArrayList<Invoker<T>>(this.invokers);\n+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());\n+        AddrCache newCache = new AddrCache();\n+        newCache.setInvokers((List)invokers);\n+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);\n+        for (StateRouter stateRouter : stateRouters) {\n+            RouterCache routerCache;", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5MjgyMw==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630692823", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    RouterCache routerCache = null;\n          \n          \n            \n                    RouterCache routerCache ;", "author": "guohao", "createdAt": "2021-05-12T03:05:52Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -114,7 +198,87 @@ private void sort() {\n      */\n     public void setInvokers(List<Invoker<T>> invokers) {\n         this.invokers = (invokers == null ? Collections.emptyList() : invokers);\n+        stateRouters.forEach(router -> router.notify(this.invokers));\n         routers.forEach(router -> router.notify(this.invokers));\n+        loop(true);\n+    }\n+\n+    private void buildCache(boolean notify) {\n+        if (invokers == null || invokers.size() <= 0) {\n+            return;\n+        }\n+        AddrCache origin = cache.get();\n+        List<Invoker<T>> copyInvokers = new ArrayList<Invoker<T>>(this.invokers);\n+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());\n+        AddrCache newCache = new AddrCache();\n+        newCache.setInvokers((List)invokers);\n+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);\n+        for (StateRouter stateRouter : stateRouters) {\n+            RouterCache routerCache;\n+            try {\n+                routerCache = poolRouter(stateRouter, origin, copyInvokers, notify);\n+                //file cache\n+                newCache.getCache().put(stateRouter.getName(), routerCache);\n+            } catch (Throwable t) {\n+                poolSuccess.set(false);\n+                logger.error(\"Failed to pool router: \" + stateRouter.getUrl() + \", cause: \" + t.getMessage(), t);\n+            } finally {\n+                cdl.countDown();\n+            }\n+        }\n+\n+        if (poolSuccess.get()) {\n+            this.cache.set(newCache);\n+        }\n+    }\n+\n+    private RouterCache poolRouter(StateRouter router, AddrCache orign, List<Invoker<T>> invokers, boolean notify) {\n+        String routerName = router.getName();\n+        RouterCache routerCache = null;", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5Mjk1OA==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630692958", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (cache == null || cache.getCache() == null || cache.getInvokers() == null || cache.getCache().get(routerName)\n          \n          \n            \n                          return cache == null || cache.getCache() == null || cache.getInvokers() == null || \n          \n          \n            \n                            cache.getCache().get(routerName) == null;", "author": "guohao", "createdAt": "2021-05-12T03:06:28Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/RouterChain.java", "diffHunk": "@@ -114,7 +198,87 @@ private void sort() {\n      */\n     public void setInvokers(List<Invoker<T>> invokers) {\n         this.invokers = (invokers == null ? Collections.emptyList() : invokers);\n+        stateRouters.forEach(router -> router.notify(this.invokers));\n         routers.forEach(router -> router.notify(this.invokers));\n+        loop(true);\n+    }\n+\n+    private void buildCache(boolean notify) {\n+        if (invokers == null || invokers.size() <= 0) {\n+            return;\n+        }\n+        AddrCache origin = cache.get();\n+        List<Invoker<T>> copyInvokers = new ArrayList<Invoker<T>>(this.invokers);\n+        CountDownLatch cdl = new CountDownLatch(stateRouters.size());\n+        AddrCache newCache = new AddrCache();\n+        newCache.setInvokers((List)invokers);\n+        final AtomicBoolean poolSuccess = new AtomicBoolean(true);\n+        for (StateRouter stateRouter : stateRouters) {\n+            RouterCache routerCache;\n+            try {\n+                routerCache = poolRouter(stateRouter, origin, copyInvokers, notify);\n+                //file cache\n+                newCache.getCache().put(stateRouter.getName(), routerCache);\n+            } catch (Throwable t) {\n+                poolSuccess.set(false);\n+                logger.error(\"Failed to pool router: \" + stateRouter.getUrl() + \", cause: \" + t.getMessage(), t);\n+            } finally {\n+                cdl.countDown();\n+            }\n+        }\n+\n+        if (poolSuccess.get()) {\n+            this.cache.set(newCache);\n+        }\n+    }\n+\n+    private RouterCache poolRouter(StateRouter router, AddrCache orign, List<Invoker<T>> invokers, boolean notify) {\n+        String routerName = router.getName();\n+        RouterCache routerCache = null;\n+        if (isCacheMiss(orign, routerName) || router.shouldRePool() || notify) {\n+            return router.pool(invokers);\n+        } else {\n+            routerCache = orign.getCache().get(routerName);\n+        }\n+        if (routerCache == null) {\n+            return new RouterCache();\n+        }\n+        return routerCache;\n+    }\n+\n+    private boolean isCacheMiss(AddrCache cache, String routerName) {\n+        if (cache == null || cache.getCache() == null || cache.getInvokers() == null || cache.getCache().get(routerName)", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5MzYwNQ==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630693605", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public interface StateRouter extends Comparable<StateRouter> {\n          \n          \n            \n            public interface StateRouter<T> extends Comparable<StateRouter<T>>", "author": "guohao", "createdAt": "2021-05-12T03:08:34Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/StateRouter.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.dubbo.rpc.cluster.router.state;\r\n+\r\n+import java.util.List;\r\n+\r\n+import org.apache.dubbo.common.URL;\r\n+import org.apache.dubbo.rpc.Invocation;\r\n+import org.apache.dubbo.rpc.Invoker;\r\n+import org.apache.dubbo.rpc.RpcException;\r\n+import org.apache.dubbo.rpc.cluster.Directory;\r\n+\r\n+/**\r\n+ * Router. (SPI, Prototype, ThreadSafe)\r\n+ * <p>\r\n+ * <a href=\"http://en.wikipedia.org/wiki/Routing\">Routing</a>\r\n+ *\r\n+ * @see org.apache.dubbo.rpc.cluster.Cluster#join(Directory)\r\n+ * @see Directory#list(Invocation)\r\n+ */\r\n+public interface StateRouter extends Comparable<StateRouter> {\r", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5MzY3NQ==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630693675", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache cache, URL url, Invocation invocation)\n          \n          \n            \n            BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache cache, URL url, Invocation invocation)", "author": "guohao", "createdAt": "2021-05-12T03:08:48Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/StateRouter.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.dubbo.rpc.cluster.router.state;\r\n+\r\n+import java.util.List;\r\n+\r\n+import org.apache.dubbo.common.URL;\r\n+import org.apache.dubbo.rpc.Invocation;\r\n+import org.apache.dubbo.rpc.Invoker;\r\n+import org.apache.dubbo.rpc.RpcException;\r\n+import org.apache.dubbo.rpc.cluster.Directory;\r\n+\r\n+/**\r\n+ * Router. (SPI, Prototype, ThreadSafe)\r\n+ * <p>\r\n+ * <a href=\"http://en.wikipedia.org/wiki/Routing\">Routing</a>\r\n+ *\r\n+ * @see org.apache.dubbo.rpc.cluster.Cluster#join(Directory)\r\n+ * @see Directory#list(Invocation)\r\n+ */\r\n+public interface StateRouter extends Comparable<StateRouter> {\r\n+\r\n+    int DEFAULT_PRIORITY = Integer.MAX_VALUE;\r\n+\r\n+    /**\r\n+     * Get the router url.\r\n+     *\r\n+     * @return url\r\n+     */\r\n+    URL getUrl();\r\n+\r\n+    /**\r\n+     * Filter invokers with current routing rule and only return the invokers that comply with the rule.\r\n+     *\r\n+     * @param invokers   invoker list\r\n+     * @param url        refer url\r\n+     * @param invocation invocation\r\n+     * @return routed invokers\r\n+     * @throws RpcException\r\n+     */\r\n+    <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache cache, URL url, Invocation invocation)\r", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5Mzk0MQ==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630693941", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                <T> RouterCache pool(List<Invoker<T>> invokers);\n          \n          \n            \n                 RouterCache pool(List<Invoker<T>> invokers);", "author": "guohao", "createdAt": "2021-05-12T03:09:32Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/StateRouter.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.dubbo.rpc.cluster.router.state;\r\n+\r\n+import java.util.List;\r\n+\r\n+import org.apache.dubbo.common.URL;\r\n+import org.apache.dubbo.rpc.Invocation;\r\n+import org.apache.dubbo.rpc.Invoker;\r\n+import org.apache.dubbo.rpc.RpcException;\r\n+import org.apache.dubbo.rpc.cluster.Directory;\r\n+\r\n+/**\r\n+ * Router. (SPI, Prototype, ThreadSafe)\r\n+ * <p>\r\n+ * <a href=\"http://en.wikipedia.org/wiki/Routing\">Routing</a>\r\n+ *\r\n+ * @see org.apache.dubbo.rpc.cluster.Cluster#join(Directory)\r\n+ * @see Directory#list(Invocation)\r\n+ */\r\n+public interface StateRouter extends Comparable<StateRouter> {\r\n+\r\n+    int DEFAULT_PRIORITY = Integer.MAX_VALUE;\r\n+\r\n+    /**\r\n+     * Get the router url.\r\n+     *\r\n+     * @return url\r\n+     */\r\n+    URL getUrl();\r\n+\r\n+    /**\r\n+     * Filter invokers with current routing rule and only return the invokers that comply with the rule.\r\n+     *\r\n+     * @param invokers   invoker list\r\n+     * @param url        refer url\r\n+     * @param invocation invocation\r\n+     * @return routed invokers\r\n+     * @throws RpcException\r\n+     */\r\n+    <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache cache, URL url, Invocation invocation)\r\n+        throws\r\n+        RpcException;\r\n+\r\n+    default <T> void notify(List<Invoker<T>> invokers) {\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * To decide whether this router need to execute every time an RPC comes or should only execute when addresses or\r\n+     * rule change.\r\n+     *\r\n+     * @return true if the router need to execute every time.\r\n+     */\r\n+    boolean isRuntime();\r\n+\r\n+    boolean isEnable();\r\n+\r\n+    boolean isForce();\r\n+\r\n+    int getPriority();\r\n+\r\n+    @Override\r\n+    default int compareTo(StateRouter o) {\r\n+        if (o == null) {\r\n+            throw new IllegalArgumentException();\r\n+        }\r\n+        return Integer.compare(this.getPriority(), o.getPriority());\r\n+    }\r\n+\r\n+    String getName();\r\n+\r\n+    boolean shouldRePool();\r\n+\r\n+    <T> RouterCache pool(List<Invoker<T>> invokers);\r", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NDE0Ng==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630694146", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                StateRouter getRouter(URL url, RouterChain chain);\n          \n          \n            \n                   <T> StateRouter<T> getRouter(URL url, RouterChain<T> chain);", "author": "guohao", "createdAt": "2021-05-12T03:10:21Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/StateRouterFactory.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.state;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.extension.Adaptive;\n+import org.apache.dubbo.common.extension.SPI;\n+import org.apache.dubbo.rpc.cluster.RouterChain;\n+\n+@SPI\n+public interface StateRouterFactory {\n+    /**\n+     * Create router.\n+     * Since 2.7.0, most of the time, we will not use @Adaptive feature, so it's kept only for compatibility.\n+     *\n+     * @param url url\n+     * @return router instance\n+     */\n+    @Adaptive(\"protocol\")\n+    StateRouter getRouter(URL url, RouterChain chain);", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NDUzOQ==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630694539", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class RouterCache {\n          \n          \n            \n            RouterCache<T>", "author": "guohao", "createdAt": "2021-05-12T03:11:42Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/RouterCache.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.state;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.dubbo.rpc.Invoker;\n+\n+public class RouterCache {", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NTAwMw==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630695003", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void setAddrPool(\n          \n          \n            \n                   public void setAddrPool(ConcurrentHashMap<String, BitList<Invoker<T>>> addrPool) {", "author": "guohao", "createdAt": "2021-05-12T03:13:19Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/RouterCache.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.state;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.dubbo.rpc.Invoker;\n+\n+public class RouterCache {\n+    protected ConcurrentHashMap<String, BitList<Invoker>> addrPool = new ConcurrentHashMap<>();\n+    protected Object addrMetadata;\n+\n+    public ConcurrentHashMap<String, BitList<Invoker>> getAddrPool() {\n+        return addrPool;\n+    }\n+\n+    public void setAddrPool(", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NTQxMw==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630695413", "bodyText": "Use a constant empty map instead of creating a new one", "author": "guohao", "createdAt": "2021-05-12T03:14:47Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/RouterCache.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.state;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.dubbo.rpc.Invoker;\n+\n+public class RouterCache {\n+    protected ConcurrentHashMap<String, BitList<Invoker>> addrPool = new ConcurrentHashMap<>();", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NTQ5Ng==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630695496", "bodyText": "ConcurrentHashMap -> ConcurrentMap", "author": "guohao", "createdAt": "2021-05-12T03:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NTQxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NTY4NQ==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630695685", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    routerCache.setAddrPool((ConcurrentHashMap)addrPool);\n          \n          \n            \n                    routerCache.setAddrPool(addrPool);", "author": "guohao", "createdAt": "2021-05-12T03:15:47Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagDynamicStateRouter.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.tag;\n+\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.config.configcenter.ConfigChangeType;\n+import org.apache.dubbo.common.config.configcenter.ConfigChangedEvent;\n+import org.apache.dubbo.common.config.configcenter.ConfigurationListener;\n+import org.apache.dubbo.common.config.configcenter.DynamicConfiguration;\n+import org.apache.dubbo.common.constants.CommonConstants;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n+import org.apache.dubbo.common.utils.NetUtils;\n+import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.cluster.RouterChain;\n+import org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter;\n+import org.apache.dubbo.rpc.cluster.router.state.BitList;\n+import org.apache.dubbo.rpc.cluster.router.state.RouterCache;\n+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRouterRule;\n+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRuleParser;\n+\n+import static org.apache.dubbo.common.constants.CommonConstants.ANYHOST_VALUE;\n+import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;\n+import static org.apache.dubbo.rpc.Constants.FORCE_USE_TAG;\n+\n+/**\n+ * TagRouter, \"application.tag-router\"\n+ */\n+public class TagDynamicStateRouter extends AbstractStateRouter implements ConfigurationListener {\n+    public static final String NAME = \"TAG_ROUTER\";\n+    private static final int TAG_ROUTER_DEFAULT_PRIORITY = 100;\n+    private static final Logger logger = LoggerFactory.getLogger(TagDynamicStateRouter.class);\n+    private static final String RULE_SUFFIX = \".tag-router\";\n+    private static final String NO_TAG = \"noTag\";\n+\n+    private TagRouterRule tagRouterRule;\n+    private String application;\n+\n+    public TagDynamicStateRouter(URL url, RouterChain chain) {\n+        super(url, chain);\n+        this.priority = TAG_ROUTER_DEFAULT_PRIORITY;\n+    }\n+\n+    @Override\n+    public synchronized void process(ConfigChangedEvent event) {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Notification of tag rule, change type is: \" + event.getChangeType() + \", raw rule is:\\n \" +\n+                event.getContent());\n+        }\n+\n+        try {\n+            if (event.getChangeType().equals(ConfigChangeType.DELETED)) {\n+                this.tagRouterRule = null;\n+            } else {\n+                this.tagRouterRule = TagRuleParser.parse(event.getContent());\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Failed to parse the raw tag router rule and it will not take effect, please check if the \" +\n+                \"rule matches with the template, the raw rule is:\\n \", e);\n+        }\n+    }\n+\n+    @Override\n+    public URL getUrl() {\n+        return url;\n+    }\n+\n+    @Override\n+    public <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache cache, URL url,\n+        Invocation invocation) throws RpcException {\n+\n+\n+        final TagRouterRule tagRouterRuleCopy = (TagRouterRule)cache.getAddrMetadata();\n+\n+        String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :\n+            invocation.getAttachment(TAG_KEY);\n+\n+        ConcurrentHashMap<String, BitList<Invoker>> addrPool = cache.getAddrPool();\n+\n+        if (StringUtils.isEmpty(tag)) {\n+            return invokers.intersect((BitList)addrPool.get(NO_TAG), invokers.getUnmodifiableList());\n+        } else {\n+            BitList<Invoker> result = addrPool.get(tag);\n+\n+            if (CollectionUtils.isNotEmpty(result) || (tagRouterRuleCopy != null && tagRouterRuleCopy.isForce())\n+                || isForceUseTag(invocation)) {\n+                return invokers.intersect((BitList)result, invokers.getUnmodifiableList());\n+            } else {\n+                invocation.setAttachment(TAG_KEY, NO_TAG);\n+                return invokers;\n+            }\n+        }\n+    }\n+\n+    private boolean isForceUseTag(Invocation invocation) {\n+        return Boolean.valueOf(invocation.getAttachment(FORCE_USE_TAG, url.getParameter(FORCE_USE_TAG, \"false\")));\n+    }\n+\n+    @Override\n+    public boolean isRuntime() {\n+        return tagRouterRule != null && tagRouterRule.isRuntime();\n+    }\n+\n+    @Override\n+    public boolean isEnable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isForce() {\n+        return tagRouterRule != null && tagRouterRule.isForce();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"TagDynamic\";\n+    }\n+\n+    @Override\n+    public boolean shouldRePool() {\n+        return false;\n+    }\n+\n+    @Override\n+    public <T> RouterCache pool(List<Invoker<T>> invokers) {\n+\n+        RouterCache routerCache = new RouterCache();\n+        ConcurrentHashMap<String, BitList<Invoker<T>>> addrPool = new ConcurrentHashMap<>();\n+\n+        final TagRouterRule tagRouterRuleCopy = tagRouterRule;\n+\n+\n+        if (tagRouterRuleCopy == null || !tagRouterRuleCopy.isValid() || !tagRouterRuleCopy.isEnabled()) {\n+            return routerCache;\n+        }\n+\n+        List<String> tagNames = tagRouterRuleCopy.getTagNames();\n+        Map<String, List<String>> tagnameToAddresses = tagRouterRuleCopy.getTagnameToAddresses();\n+\n+        for (String tag : tagNames) {\n+            List<String> addresses = tagnameToAddresses.get(tag);\n+            BitList<Invoker<T>> list = new BitList<>(invokers, true);\n+\n+            if (CollectionUtils.isEmpty(addresses)) {\n+                list.addAll(invokers);\n+            } else {\n+                for (int index = 0; index < invokers.size(); index++) {\n+                    Invoker<T> invoker = invokers.get(index);\n+                    if (addressMatches(invoker.getUrl(), addresses)) {\n+                        list.addIndex(index);\n+                    }\n+                }\n+            }\n+\n+            addrPool.put(tag, list);\n+        }\n+\n+        List<String> addresses = tagRouterRuleCopy.getAddresses();\n+        BitList<Invoker<T>> noTagList = new BitList<>(invokers, true);\n+\n+        for (int index = 0; index < invokers.size(); index++) {\n+            Invoker<T> invoker = invokers.get(index);\n+            if (addressNotMatches(invoker.getUrl(), addresses)) {\n+                noTagList.addIndex(index);\n+            }\n+        }\n+        addrPool.put(NO_TAG, noTagList);\n+        routerCache.setAddrPool((ConcurrentHashMap)addrPool);", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NjA4NA==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630696084", "bodyText": "unused field", "author": "guohao", "createdAt": "2021-05-12T03:17:04Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagStaticStateRouter.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.tag;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n+import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.cluster.RouterChain;\n+import org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter;\n+import org.apache.dubbo.rpc.cluster.router.state.BitList;\n+import org.apache.dubbo.rpc.cluster.router.state.RouterCache;\n+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRouterRule;\n+import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;\n+\n+/**\n+ * TagRouter, \"application.tag-router\"\n+ */\n+public class TagStaticStateRouter extends AbstractStateRouter {\n+    public static final String NAME = \"TAG_ROUTER\";\n+    private static final int TAG_ROUTER_DEFAULT_PRIORITY = 100;\n+    private static final Logger logger = LoggerFactory.getLogger(TagStaticStateRouter.class);\n+    private static final String RULE_SUFFIX = \".tag-router\";", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NjA5Ng==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630696096", "bodyText": "unused field", "author": "guohao", "createdAt": "2021-05-12T03:17:09Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagStaticStateRouter.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.tag;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n+import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.cluster.RouterChain;\n+import org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter;\n+import org.apache.dubbo.rpc.cluster.router.state.BitList;\n+import org.apache.dubbo.rpc.cluster.router.state.RouterCache;\n+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRouterRule;\n+import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;\n+\n+/**\n+ * TagRouter, \"application.tag-router\"\n+ */\n+public class TagStaticStateRouter extends AbstractStateRouter {\n+    public static final String NAME = \"TAG_ROUTER\";\n+    private static final int TAG_ROUTER_DEFAULT_PRIORITY = 100;\n+    private static final Logger logger = LoggerFactory.getLogger(TagStaticStateRouter.class);", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NjE2MA==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630696160", "bodyText": "Fix what?", "author": "guohao", "createdAt": "2021-05-12T03:17:27Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagStaticStateRouter.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.tag;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n+import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.cluster.RouterChain;\n+import org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter;\n+import org.apache.dubbo.rpc.cluster.router.state.BitList;\n+import org.apache.dubbo.rpc.cluster.router.state.RouterCache;\n+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRouterRule;\n+import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;\n+\n+/**\n+ * TagRouter, \"application.tag-router\"\n+ */\n+public class TagStaticStateRouter extends AbstractStateRouter {\n+    public static final String NAME = \"TAG_ROUTER\";\n+    private static final int TAG_ROUTER_DEFAULT_PRIORITY = 100;\n+    private static final Logger logger = LoggerFactory.getLogger(TagStaticStateRouter.class);\n+    private static final String RULE_SUFFIX = \".tag-router\";\n+    private static final String NO_TAG = \"noTag\";\n+\n+    private TagRouterRule tagRouterRule;\n+\n+    public TagStaticStateRouter(URL url, RouterChain chain) {\n+        super(url, chain);\n+        this.priority = TAG_ROUTER_DEFAULT_PRIORITY;\n+    }\n+\n+    @Override\n+    public URL getUrl() {\n+        return url;\n+    }\n+\n+    @Override\n+    public <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache routerCache, URL url, Invocation invocation)\n+        throws RpcException {\n+\n+        String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :\n+            invocation.getAttachment(TAG_KEY);\n+        if (StringUtils.isEmpty(tag)) {\n+            tag = NO_TAG;\n+        }\n+\n+        ConcurrentHashMap<String, BitList<Invoker>> pool = routerCache.getAddrPool();\n+        BitList res = pool.get(tag);\n+        if (res == null) {\n+            return invokers;\n+        }\n+        return invokers.intersect((BitList)res, invokers.getUnmodifiableList());\n+    }\n+\n+    @Override\n+    protected List<String> getTags(URL url, Invocation invocation) {\n+        List<String> tags = new ArrayList<>();\n+        String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :\n+            invocation.getAttachment(TAG_KEY);\n+        if (StringUtils.isEmpty(tag)) {\n+            tag = NO_TAG;\n+        }\n+        tags.add(tag);\n+        return tags;\n+    }\n+\n+    @Override\n+    public boolean isRuntime() {\n+        return tagRouterRule != null && tagRouterRule.isRuntime();\n+    }\n+\n+    @Override\n+    public boolean isEnable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isForce() {\n+        // FIXME", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NjI1OA==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630696258", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    routerCache.setAddrPool((ConcurrentHashMap)addrPool);\n          \n          \n            \n                    routerCache.setAddrPool(addrPool);", "author": "guohao", "createdAt": "2021-05-12T03:17:43Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagStaticStateRouter.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.tag;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.logger.Logger;\n+import org.apache.dubbo.common.logger.LoggerFactory;\n+import org.apache.dubbo.common.utils.CollectionUtils;\n+import org.apache.dubbo.common.utils.StringUtils;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.cluster.RouterChain;\n+import org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter;\n+import org.apache.dubbo.rpc.cluster.router.state.BitList;\n+import org.apache.dubbo.rpc.cluster.router.state.RouterCache;\n+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRouterRule;\n+import static org.apache.dubbo.common.constants.CommonConstants.TAG_KEY;\n+\n+/**\n+ * TagRouter, \"application.tag-router\"\n+ */\n+public class TagStaticStateRouter extends AbstractStateRouter {\n+    public static final String NAME = \"TAG_ROUTER\";\n+    private static final int TAG_ROUTER_DEFAULT_PRIORITY = 100;\n+    private static final Logger logger = LoggerFactory.getLogger(TagStaticStateRouter.class);\n+    private static final String RULE_SUFFIX = \".tag-router\";\n+    private static final String NO_TAG = \"noTag\";\n+\n+    private TagRouterRule tagRouterRule;\n+\n+    public TagStaticStateRouter(URL url, RouterChain chain) {\n+        super(url, chain);\n+        this.priority = TAG_ROUTER_DEFAULT_PRIORITY;\n+    }\n+\n+    @Override\n+    public URL getUrl() {\n+        return url;\n+    }\n+\n+    @Override\n+    public <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache routerCache, URL url, Invocation invocation)\n+        throws RpcException {\n+\n+        String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :\n+            invocation.getAttachment(TAG_KEY);\n+        if (StringUtils.isEmpty(tag)) {\n+            tag = NO_TAG;\n+        }\n+\n+        ConcurrentHashMap<String, BitList<Invoker>> pool = routerCache.getAddrPool();\n+        BitList res = pool.get(tag);\n+        if (res == null) {\n+            return invokers;\n+        }\n+        return invokers.intersect((BitList)res, invokers.getUnmodifiableList());\n+    }\n+\n+    @Override\n+    protected List<String> getTags(URL url, Invocation invocation) {\n+        List<String> tags = new ArrayList<>();\n+        String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :\n+            invocation.getAttachment(TAG_KEY);\n+        if (StringUtils.isEmpty(tag)) {\n+            tag = NO_TAG;\n+        }\n+        tags.add(tag);\n+        return tags;\n+    }\n+\n+    @Override\n+    public boolean isRuntime() {\n+        return tagRouterRule != null && tagRouterRule.isRuntime();\n+    }\n+\n+    @Override\n+    public boolean isEnable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isForce() {\n+        // FIXME\n+        return false;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"TagStatic\";\n+    }\n+\n+    @Override\n+    public boolean shouldRePool() {\n+        return false;\n+    }\n+\n+    @Override\n+    public <T> RouterCache pool(List<Invoker<T>> invokers) {\n+\n+        RouterCache routerCache = new RouterCache();\n+        ConcurrentHashMap<String, BitList<Invoker<T>>> addrPool = new ConcurrentHashMap<>();\n+\n+        for (int index = 0; index < invokers.size(); index++) {\n+            Invoker<T> invoker = invokers.get(index);\n+            String tag = invoker.getUrl().getParameter(TAG_KEY);\n+            if (StringUtils.isEmpty(tag)) {\n+                BitList<Invoker<T>> noTagList = addrPool.putIfAbsent(NO_TAG, new BitList<>(invokers, true));\n+                if (noTagList == null) {\n+                    noTagList = addrPool.get(NO_TAG);\n+                }\n+                noTagList.addIndex(index);\n+            } else {\n+                BitList<Invoker<T>> list = addrPool.putIfAbsent(tag, new BitList<>(invokers, true));\n+                if (list == null) {\n+                    list = addrPool.get(tag);\n+                }\n+                list.addIndex(index);\n+            }\n+        }\n+\n+        routerCache.setAddrPool((ConcurrentHashMap)addrPool);", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5Njk2NA==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630696964", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class AddrCache {\n          \n          \n            \n            public class AddrCache<T> {", "author": "guohao", "createdAt": "2021-05-12T03:20:32Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/AddrCache.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.state;\n+\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.dubbo.rpc.Invoker;\n+\n+public class AddrCache {", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NzAyNg==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630697026", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected List<Invoker> invokers;\n          \n          \n            \n                   protected List<Invoker<T>> invokers;", "author": "guohao", "createdAt": "2021-05-12T03:20:49Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/AddrCache.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.state;\n+\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.dubbo.rpc.Invoker;\n+\n+public class AddrCache {\n+    protected List<Invoker> invokers;", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NzE0NA==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630697144", "bodyText": "Use constant empty map", "author": "guohao", "createdAt": "2021-05-12T03:21:09Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/AddrCache.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.state;\n+\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.dubbo.rpc.Invoker;\n+\n+public class AddrCache {\n+    protected List<Invoker> invokers;\n+    protected ConcurrentHashMap<String, RouterCache> cache = new ConcurrentHashMap<>();", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NzIzNw==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630697237", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void setCache(\n          \n          \n            \n                   public void setCache(ConcurrentHashMap<String, RouterCache> cache) {", "author": "guohao", "createdAt": "2021-05-12T03:21:28Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/AddrCache.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.state;\n+\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.dubbo.rpc.Invoker;\n+\n+public class AddrCache {\n+    protected List<Invoker> invokers;\n+    protected ConcurrentHashMap<String, RouterCache> cache = new ConcurrentHashMap<>();\n+\n+    public List<Invoker> getInvokers() {\n+        return invokers;\n+    }\n+\n+    public void setInvokers(List<Invoker> invokers) {\n+        this.invokers = invokers;\n+    }\n+\n+    public ConcurrentHashMap<String, RouterCache> getCache() {\n+        return cache;\n+    }\n+\n+    public void setCache(", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5NzU2OQ==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630697569", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return invokers == null || invokers.size() <= 0;\n          \n          \n            \n                    return invokers == null || invokers.isEmpty();", "author": "guohao", "createdAt": "2021-05-12T03:22:32Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/AbstractStateRouter.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.state;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.extension.ExtensionLoader;\n+import org.apache.dubbo.rpc.Invocation;\n+import org.apache.dubbo.rpc.Invoker;\n+import org.apache.dubbo.rpc.RpcException;\n+import org.apache.dubbo.rpc.cluster.RouterChain;\n+import org.apache.dubbo.rpc.cluster.governance.GovernanceRuleRepository;\n+\n+public abstract class AbstractStateRouter implements StateRouter {\n+    final protected RouterChain chain;\n+    protected int priority = DEFAULT_PRIORITY;\n+    protected boolean force = false;\n+    protected URL url;\n+    protected List<Invoker> invokers;\n+    protected AtomicReference<AddrCache> cache;\n+    protected GovernanceRuleRepository ruleRepository;\n+\n+    public AbstractStateRouter(URL url, RouterChain chain) {\n+        this.ruleRepository = ExtensionLoader.getExtensionLoader(GovernanceRuleRepository.class).getDefaultExtension();\n+        this.chain = chain;\n+        this.url = url;\n+    }\n+\n+    @Override\n+    public <T> void notify(List<Invoker<T>> invokers) {\n+        this.invokers = (List)invokers;\n+    }\n+\n+    @Override\n+    public URL getUrl() {\n+        return url;\n+    }\n+\n+    public void setUrl(URL url) {\n+        this.url = url;\n+    }\n+\n+    @Override\n+    public boolean isRuntime() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isForce() {\n+        return force;\n+    }\n+\n+    public void setForce(boolean force) {\n+        this.force = force;\n+    }\n+\n+    @Override\n+    public int getPriority() {\n+        return priority;\n+    }\n+\n+    public void setPriority(int priority) {\n+        this.priority = priority;\n+    }\n+\n+    @Override\n+    public <T> BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, RouterCache cache, URL url,\n+        Invocation invocation) throws RpcException {\n+\n+        List<String> tags = getTags(url, invocation);\n+\n+        if (tags == null) {\n+            return invokers;\n+        }\n+        for (String tag : tags) {\n+            BitList tagInvokers = cache.getAddrPool().get(tag);\n+            if (tagMatchFail(tagInvokers)) {\n+                continue;\n+            }\n+            return tagInvokers.intersect(invokers, invokers.getUnmodifiableList());\n+        }\n+\n+        return invokers;\n+    }\n+\n+    protected List<String> getTags(URL url, Invocation invocation) {\n+        return new ArrayList<String>();\n+    }\n+\n+    public <T> Boolean tagMatchFail(BitList<Invoker<T>> invokers) {\n+        return invokers == null || invokers.size() <= 0;", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDY5ODEyNA==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r630698124", "bodyText": "unused", "author": "guohao", "createdAt": "2021-05-12T03:24:35Z", "path": "dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/manager/DefaultExecutorRepository.java", "diffHunk": "@@ -16,20 +16,24 @@\n  */\n package org.apache.dubbo.common.threadpool.manager;\n \n-import org.apache.dubbo.common.URL;\n-import org.apache.dubbo.common.extension.ExtensionLoader;\n-import org.apache.dubbo.common.logger.Logger;\n-import org.apache.dubbo.common.logger.LoggerFactory;\n-import org.apache.dubbo.common.threadpool.ThreadPool;\n-import org.apache.dubbo.common.utils.NamedThreadFactory;\n-\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n+import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;", "originalCommit": "b6239270334178742fe512cb4738d6b1b3e27fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4959c23f3200044e4987315248826fa98ede53fb", "url": "https://github.com/apache/dubbo/commit/4959c23f3200044e4987315248826fa98ede53fb", "message": "fix comment", "committedDate": "2021-05-12T06:58:30Z", "type": "commit"}, {"oid": "b33bb702c28019230fe030f4228702943d4479f8", "url": "https://github.com/apache/dubbo/commit/b33bb702c28019230fe030f4228702943d4479f8", "message": "fix comment", "committedDate": "2021-05-12T07:21:39Z", "type": "commit"}, {"oid": "08852f75d1567883331314a25087cdfef62a1d93", "url": "https://github.com/apache/dubbo/commit/08852f75d1567883331314a25087cdfef62a1d93", "message": "fix", "committedDate": "2021-05-12T11:26:54Z", "type": "commit"}, {"oid": "f349c9d92775dfa035405cd76190e7035611e215", "url": "https://github.com/apache/dubbo/commit/f349c9d92775dfa035405cd76190e7035611e215", "message": "fix ut", "committedDate": "2021-05-13T08:02:18Z", "type": "commit"}, {"oid": "0c52c63828629bf6cda5c6f1c46df057f77e9f1e", "url": "https://github.com/apache/dubbo/commit/0c52c63828629bf6cda5c6f1c46df057f77e9f1e", "message": "fix ut", "committedDate": "2021-05-13T09:47:19Z", "type": "commit"}, {"oid": "70b36fb3b8f722a8f0a84681d2261e56530bac48", "url": "https://github.com/apache/dubbo/commit/70b36fb3b8f722a8f0a84681d2261e56530bac48", "message": "Merge remote-tracking branch 'origin/3.0' into feature/state-router", "committedDate": "2021-05-14T07:27:29Z", "type": "commit"}, {"oid": "c8e4e0983d241aeec277f2ec4f29e404a501205d", "url": "https://github.com/apache/dubbo/commit/c8e4e0983d241aeec277f2ec4f29e404a501205d", "message": "fix", "committedDate": "2021-05-14T08:38:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMjY0NzE3MA==", "url": "https://github.com/apache/dubbo/pull/6844#discussion_r632647170", "bodyText": "the NAME should be tag-static", "author": "AlbumenJ", "createdAt": "2021-05-14T16:25:16Z", "path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/TagStaticStateRouterFactory.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.rpc.cluster.router.tag;\n+\n+import org.apache.dubbo.common.URL;\n+import org.apache.dubbo.common.extension.Activate;\n+import org.apache.dubbo.rpc.cluster.RouterChain;\n+import org.apache.dubbo.rpc.cluster.router.state.CacheableStateRouterFactory;\n+import org.apache.dubbo.rpc.cluster.router.state.StateRouter;\n+\n+/**\n+ * Tag router factory\n+ */\n+@Activate(order = 100)\n+public class TagStaticStateRouterFactory extends CacheableStateRouterFactory {\n+\n+    public static final String NAME = \"tag-dynamic\";", "originalCommit": "c8e4e0983d241aeec277f2ec4f29e404a501205d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0165959ecddb25a3a2f69b560ad3bd6512125c4e", "url": "https://github.com/apache/dubbo/commit/0165959ecddb25a3a2f69b560ad3bd6512125c4e", "message": "fix comment", "committedDate": "2021-05-15T02:58:20Z", "type": "commit"}, {"oid": "5adf586cb0ed2f99157da2bcd68fe3da3283a3e8", "url": "https://github.com/apache/dubbo/commit/5adf586cb0ed2f99157da2bcd68fe3da3283a3e8", "message": "add code comments", "committedDate": "2021-05-16T08:59:15Z", "type": "commit"}, {"oid": "a793346395748a01bc243c0250043a0c0850640e", "url": "https://github.com/apache/dubbo/commit/a793346395748a01bc243c0250043a0c0850640e", "message": "add code comments", "committedDate": "2021-05-17T13:43:23Z", "type": "commit"}, {"oid": "07e140131c442c9c83bd3c8541ee214a784fbce5", "url": "https://github.com/apache/dubbo/commit/07e140131c442c9c83bd3c8541ee214a784fbce5", "message": "add code comments", "committedDate": "2021-05-17T13:48:41Z", "type": "commit"}, {"oid": "79a9131fea17d77f312cb5b34d1d74cf7b16022e", "url": "https://github.com/apache/dubbo/commit/79a9131fea17d77f312cb5b34d1d74cf7b16022e", "message": "add code comments", "committedDate": "2021-05-17T13:52:57Z", "type": "commit"}]}