{"pr_number": 688, "pr_title": "KOGITO-3055  Refactor Quarkus Extension", "pr_createdAt": "2020-08-10T15:42:24Z", "pr_url": "https://github.com/kiegroup/kogito-runtimes/pull/688", "timeline": [{"oid": "efa57f65b43726b41e914565b891f9f64b030556", "url": "https://github.com/kiegroup/kogito-runtimes/commit/efa57f65b43726b41e914565b891f9f64b030556", "message": "add another exclusion for coverage", "committedDate": "2020-08-10T13:41:13Z", "type": "forcePushed"}, {"oid": "cc44a618c07d1bf6cb192cc6d6c8eb8b70599e50", "url": "https://github.com/kiegroup/kogito-runtimes/commit/cc44a618c07d1bf6cb192cc6d6c8eb8b70599e50", "message": "use jars directly", "committedDate": "2020-08-12T07:58:50Z", "type": "forcePushed"}, {"oid": "5369fd7ffe817006136afb3075b1c61a42564c21", "url": "https://github.com/kiegroup/kogito-runtimes/commit/5369fd7ffe817006136afb3075b1c61a42564c21", "message": "use jars directly", "committedDate": "2020-08-12T12:36:09Z", "type": "forcePushed"}, {"oid": "53043bb8fd2f1e786010998158774530ece48ebc", "url": "https://github.com/kiegroup/kogito-runtimes/commit/53043bb8fd2f1e786010998158774530ece48ebc", "message": "KOGITO-3055 Refactor Quarkus Extension", "committedDate": "2020-08-13T13:20:22Z", "type": "commit"}, {"oid": "53043bb8fd2f1e786010998158774530ece48ebc", "url": "https://github.com/kiegroup/kogito-runtimes/commit/53043bb8fd2f1e786010998158774530ece48ebc", "message": "KOGITO-3055 Refactor Quarkus Extension", "committedDate": "2020-08-13T13:20:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk0NjMwMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/688#discussion_r469946301", "bodyText": "moved to its own class, instead of a static private class", "author": "evacchi", "createdAt": "2020-08-13T13:21:54Z", "path": "kogito-quarkus-extension/deployment/src/main/java/org/kie/kogito/quarkus/deployment/AppPaths.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package org.kie.kogito.quarkus.deployment;", "originalCommit": "53043bb8fd2f1e786010998158774530ece48ebc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b1f3ab372f581e669d8cee477bba8f44a9864f69", "url": "https://github.com/kiegroup/kogito-runtimes/commit/b1f3ab372f581e669d8cee477bba8f44a9864f69", "message": "copyright", "committedDate": "2020-08-13T13:31:18Z", "type": "commit"}, {"oid": "b1f3ab372f581e669d8cee477bba8f44a9864f69", "url": "https://github.com/kiegroup/kogito-runtimes/commit/b1f3ab372f581e669d8cee477bba8f44a9864f69", "message": "copyright", "committedDate": "2020-08-13T13:31:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk1MzgzNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/688#discussion_r469953835", "bodyText": ".sw.json, sw.yaml, etc. need the dot", "author": "evacchi", "createdAt": "2020-08-13T13:33:05Z", "path": "api/kogito-api/src/main/java/org/kie/api/io/ResourceType.java", "diffHunk": "@@ -83,9 +83,6 @@ public static ResourceType addResourceTypeToRegistry(final String resourceType,\n \n         CACHE.put( resourceType, resource );\n         resource.getAllExtensions().forEach( ext -> {\n-            if (ext.contains( \".\" )) {", "originalCommit": "b1f3ab372f581e669d8cee477bba8f44a9864f69", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk1NDA1Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/688#discussion_r469954052", "bodyText": "therefore, the simple lastIndexOf() check does not work", "author": "evacchi", "createdAt": "2020-08-13T13:33:22Z", "path": "api/kogito-api/src/main/java/org/kie/api/io/ResourceType.java", "diffHunk": "@@ -281,8 +286,10 @@ public static ResourceType getResourceType(final String resourceType) {\n     }\n \n     public static ResourceType determineResourceType(final String resourceName) {\n-        int dotPos = resourceName.lastIndexOf( '.' );\n-        return dotPos < 0 ? null : CACHE.get( resourceName.substring( dotPos ) );\n+        return CACHE.values().stream()", "originalCommit": "b1f3ab372f581e669d8cee477bba8f44a9864f69", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f6c09e13bac8f960d778f3ee45f8040c764ada72", "url": "https://github.com/kiegroup/kogito-runtimes/commit/f6c09e13bac8f960d778f3ee45f8040c764ada72", "message": "docs", "committedDate": "2020-08-13T13:59:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAxODUyNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/688#discussion_r470018526", "bodyText": "sorry for the stupid question, but what is the difference between this new CollectedResource and a Kie api Resource? Or to better frame the question, why this class is not a specialization of the Kie api Resource?", "author": "tarilabs", "createdAt": "2020-08-13T15:01:19Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/io/CollectedResource.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.io;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.drools.core.io.impl.ByteArrayResource;\n+import org.drools.core.io.impl.FileSystemResource;\n+import org.drools.core.io.internal.InternalResource;\n+import org.kie.api.io.Resource;\n+import org.kie.api.io.ResourceType;\n+\n+import static org.drools.core.util.IoUtils.readBytesFromInputStream;\n+import static org.kie.api.io.ResourceType.determineResourceType;\n+\n+/**\n+ * A (Path basePath, Resource resource) pair\n+ */\n+public class CollectedResource {\n+\n+    /**\n+     * Returns a collection of CollectedResource from the given paths.\n+     * If a path is a jar, then walks inside the jar.\n+     */\n+    public static Collection<CollectedResource> fromPaths(Path... paths) {\n+        Collection<CollectedResource> resources = new ArrayList<>();\n+\n+        for (Path path : paths) {\n+            if (path.toFile().isDirectory()) {\n+                Collection<CollectedResource> res = fromDirectory(path);\n+                resources.addAll(res);\n+            } else if (path.getFileName().toString().endsWith(\".jar\")) {\n+                Collection<CollectedResource> res = fromJarFile(path);\n+                resources.addAll(res);\n+            } else {\n+                throw new IllegalArgumentException(\"Expected directory or archive, file given: \" + path);\n+            }\n+        }\n+\n+        return resources;\n+    }\n+\n+    /**\n+     * Returns a collection of CollectedResource from the given jar file.\n+     */\n+    public static Collection<CollectedResource> fromJarFile(Path jarPath) {\n+        Collection<CollectedResource> resources = new ArrayList<>();\n+        try (ZipFile zipFile = new ZipFile(jarPath.toFile())) {\n+            Enumeration<? extends ZipEntry> entries = zipFile.entries();\n+            while (entries.hasMoreElements()) {\n+                ZipEntry entry = entries.nextElement();\n+                ResourceType resourceType = determineResourceType(entry.getName());\n+                if (resourceType != null) {\n+                    InternalResource resource = new ByteArrayResource(readBytesFromInputStream(zipFile.getInputStream(entry)));\n+                    resource.setResourceType(resourceType);\n+                    resource.setSourcePath(entry.getName());\n+                    CollectedResource collectedResource = new CollectedResource(jarPath, resource);\n+                    resources.add(collectedResource);\n+                }\n+            }\n+            return resources;\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    /**\n+     * Returns a collection of CollectedResource from the given directory.\n+     */\n+    public static Collection<CollectedResource> fromDirectory(Path path) {\n+        Collection<CollectedResource> resources = new ArrayList<>();\n+        try {\n+            Files.walk(path).map(Path::toFile)\n+                    .map(f -> new FileSystemResource(f).setResourceType(determineResourceType(f.getName())))\n+                    .map(f -> new CollectedResource(path, f))\n+                    .forEach(resources::add);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        return resources;\n+    }\n+\n+    private final Path basePath;\n+    private final Resource resource;\n+\n+    public CollectedResource(Path basePath, Resource resource) {\n+        this.basePath = basePath;\n+        this.resource = resource;", "originalCommit": "f6c09e13bac8f960d778f3ee45f8040c764ada72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAyNjE2OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/688#discussion_r470026168", "bodyText": "Try not to be misled by the name. I have used CollectedResource for lack of a better name; PairPathResource would be just as good, to me. it's a decorator so that it can be any Resource; I didn't extend Resource itself because I didn't think having a basePath would make sense all the time (and I wouldn't know what to return or do if it's null). If I had to specialize Resource, then I would have either to add the method to the superclass, or create a delegate of all its methods.\nThe reason I created this, is that I observed the pattern of pairing Resources/Models with a base Path from DMN and PMML and extracted it to a common class e.g. see parseDecisions(Path path, List<Resource> resources) https://github.com/kiegroup/submarine-runtimes/blob/53043bb8fd2f1e786010998158774530ece48ebc/kogito-codegen/src/main/java/org/kie/kogito/codegen/decision/DecisionCodegen.java#L135\nI figured that if the Resource alone were enough, then we wouldn't have both arguments.\nBTW I am open to suggestions; as I said, we can further refactor this anyway :)\nPS: this path may also be totally redundant: if that is true, then this refactor will help to spot that!", "author": "evacchi", "createdAt": "2020-08-13T15:12:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAxODUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzNDA2MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/688#discussion_r470034060", "bodyText": "I could not find a better name for this <Path, Resource> pair. feel free to propose a better one.", "author": "evacchi", "createdAt": "2020-08-13T15:23:05Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/io/CollectedResource.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.io;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.drools.core.io.impl.ByteArrayResource;\n+import org.drools.core.io.impl.FileSystemResource;\n+import org.drools.core.io.internal.InternalResource;\n+import org.kie.api.io.Resource;\n+import org.kie.api.io.ResourceType;\n+\n+import static org.drools.core.util.IoUtils.readBytesFromInputStream;\n+import static org.kie.api.io.ResourceType.determineResourceType;\n+\n+/**\n+ * A (Path basePath, Resource resource) pair\n+ */\n+public class CollectedResource {", "originalCommit": "f6c09e13bac8f960d778f3ee45f8040c764ada72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1Mjg2Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/688#discussion_r470052866", "bodyText": "I like this name.", "author": "ricardozanini", "createdAt": "2020-08-13T15:51:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzNDA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1MDMyMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/688#discussion_r470050320", "bodyText": "I think this is the same as PredictionCodegen.ofCollectedResource(CollectedResource.fromJar(...))\nWe could refactor these functions and annotate with @Deprecate", "author": "ricardozanini", "createdAt": "2020-08-13T15:47:23Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/prediction/PredictionCodegen.java", "diffHunk": "@@ -86,6 +88,14 @@ public PredictionCodegen(List<PMMLResource> resources) {\n         this.moduleGenerator = new PredictionContainerGenerator(applicationCanonicalName, resources);\n     }\n \n+    public static PredictionCodegen ofCollectedResources(Collection<CollectedResource> resources) {\n+        List<PMMLResource> dmnResources = resources.stream()\n+                .filter(r -> r.resource().getResourceType() == ResourceType.PMML)\n+                .flatMap(r -> parsePredictions(r.basePath(), Collections.singletonList(r.resource())).stream())\n+                .collect(toList());\n+        return ofPredictions(dmnResources);\n+    }\n+\n     public static PredictionCodegen ofJar(Path... jarPaths) throws IOException {", "originalCommit": "f6c09e13bac8f960d778f3ee45f8040c764ada72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1MzA1Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/688#discussion_r470053057", "bodyText": "maybe let's file a JIRA for that. There are definitely other pieces of code that we can drop", "author": "evacchi", "createdAt": "2020-08-13T15:51:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1MDMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1MDc2OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/688#discussion_r470050768", "bodyText": "Same here: ProcessCodegen.ofCollectedResource(CollectedResource.fromJar(...))", "author": "ricardozanini", "createdAt": "2020-08-13T15:48:00Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessCodegen.java", "diffHunk": "@@ -108,6 +111,24 @@\n     private ResourceGeneratorFactory resourceGeneratorFactory;\n     private String packageName;\n \n+    public static ProcessCodegen ofCollectedResources(Collection<CollectedResource> resources) {\n+        List<Process> processes = resources.stream()\n+                .map(CollectedResource::resource)\n+                .flatMap(resource -> {\n+                    if (SUPPORTED_BPMN_EXTENSIONS.stream().anyMatch(resource.getSourcePath()::endsWith)) {\n+                        return parseProcessFile(resource).stream();\n+                    } else {\n+                        return SUPPORTED_SW_EXTENSIONS.entrySet()\n+                                .stream()\n+                                .filter(e -> resource.getSourcePath().endsWith(e.getKey()))\n+                                .map(e -> parseWorkflowFile(resource, e.getValue()));\n+                    }\n+                })\n+                .collect(toList());\n+\n+        return ofProcesses(processes);\n+    }\n+\n     public static ProcessCodegen ofJar(Path... jarPaths) {", "originalCommit": "f6c09e13bac8f960d778f3ee45f8040c764ada72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1MTMzMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/688#discussion_r470051330", "bodyText": "Same here :D @Deprecate and CollectedResource new API.", "author": "ricardozanini", "createdAt": "2020-08-13T15:48:51Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/rules/IncrementalRuleCodegen.java", "diffHunk": "@@ -89,6 +90,14 @@\n \n public class IncrementalRuleCodegen extends AbstractGenerator {\n \n+    public static IncrementalRuleCodegen ofCollectedResources(Collection<CollectedResource> resources) {\n+        List<Resource> dmnResources = resources.stream()\n+                .map(CollectedResource::resource)\n+                .filter(IncrementalRuleCodegen::isSupportedResourceType)\n+                .collect(toList());\n+        return ofResources(dmnResources);\n+    }\n+\n     public static IncrementalRuleCodegen ofJar(Path... jarPaths) {", "originalCommit": "f6c09e13bac8f960d778f3ee45f8040c764ada72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI0MDE4Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/688#discussion_r472240186", "bodyText": "I suspect this wouldn't be completely correct since you're missing the case of the file ending with \".jar.original\" as covered by the AppPaths at line 133 ( https://github.com/kiegroup/kogito-runtimes/pull/688/files#diff-02ab48c8cb4aa88ed360c563c29777b1R133 ). More in general wouldn't be better to use the enumeration already defined there to avoid duplicating that logic?", "author": "mariofusco", "createdAt": "2020-08-18T14:28:49Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/io/CollectedResource.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.io;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.drools.core.io.impl.ByteArrayResource;\n+import org.drools.core.io.impl.FileSystemResource;\n+import org.drools.core.io.internal.InternalResource;\n+import org.kie.api.io.Resource;\n+import org.kie.api.io.ResourceType;\n+\n+import static org.drools.core.util.IoUtils.readBytesFromInputStream;\n+import static org.kie.api.io.ResourceType.determineResourceType;\n+\n+/**\n+ * A (Path basePath, Resource resource) pair\n+ */\n+public class CollectedResource {\n+\n+    /**\n+     * Returns a collection of CollectedResource from the given paths.\n+     * If a path is a jar, then walks inside the jar.\n+     */\n+    public static Collection<CollectedResource> fromPaths(Path... paths) {\n+        Collection<CollectedResource> resources = new ArrayList<>();\n+\n+        for (Path path : paths) {\n+            if (path.toFile().isDirectory()) {\n+                Collection<CollectedResource> res = fromDirectory(path);\n+                resources.addAll(res);\n+            } else if (path.getFileName().toString().endsWith(\".jar\")) {", "originalCommit": "f6c09e13bac8f960d778f3ee45f8040c764ada72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ3ODk4MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/688#discussion_r472478981", "bodyText": "This is one of the two jar related points I have added to this ticket\nhttps://issues.redhat.com/browse/KOGITO-3112\nFine for me to verify it (aka test uber-jar native mode with this code) during this PR but this means to wait Edoardo to be back.\nWhat do you prefer?", "author": "danielezonca", "createdAt": "2020-08-18T20:38:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI0MDE4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg1MTE4NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/688#discussion_r472851185", "bodyText": "I vote for merging this now and work out pending improvements throug JIRAs.\nI have some refactor to do while Edoardo is away and it colides with these changes, so please lets merge as soon as possible", "author": "fjtirado", "createdAt": "2020-08-19T08:21:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI0MDE4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4MDI5Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/688#discussion_r470080297", "bodyText": "Since these two statement only differ in class name, should it not better to have a private  method\nprivate void addChildrenClasses(Index index,\nClass<?> superClass,\nBuildProducer reflectiveClass) {\nindex.getAllKnownSubclasses(createDotName(superClass.getName()))\n.forEach(c -> reflectiveClass.produce(\nnew ReflectiveClassBuildItem(true,\ntrue,\nc.name().toString())));\n}?\nI suspect this wont be the last super class we will add there\nAnd to make the code shorter, I realize now (I did not include that in my fix, which proof the different state of mind between author and reviewer ;)) we can use import org.kie.kogito.services.event.AbstractProcessDataEvent, so you just have AbstractProcessDataEvent.class in the call to createSimple", "author": "fjtirado", "createdAt": "2020-08-13T16:35:19Z", "path": "kogito-quarkus-extension/deployment/src/main/java/org/kie/kogito/quarkus/deployment/KogitoAssetsProcessor.java", "diffHunk": "@@ -193,259 +386,96 @@ public RuntimeInitializedClassBuildItem runtimeInitializedClass() {\n         return new RuntimeInitializedClassBuildItem(ClassFieldAccessorFactory.class.getName());\n     }\n \n-    @BuildStep\n-    public void generateModel(ArchiveRootBuildItem root,\n-                              BuildProducer<GeneratedBeanBuildItem> generatedBeans,\n-                              CombinedIndexBuildItem combinedIndexBuildItem,\n-                              LaunchModeBuildItem launchMode,\n-                              LiveReloadBuildItem liveReload,\n-                              BuildProducer<NativeImageResourceBuildItem> resource,\n-                              BuildProducer<GeneratedResourceBuildItem> genResBI,\n-                              BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n-                              CurateOutcomeBuildItem curateOutcomeBuildItem) throws IOException, BootstrapDependencyProcessingException {\n+    private void writeJsonSchema(AppPaths appPaths, Index index) throws IOException {\n+        Path relativePath = JsonSchemaUtil.getJsonDir();\n+        Path targetClasses = appPaths.getFirstProjectPath().resolve(targetClassesDir);\n+        Collection<GeneratedFile> jsonFiles = getJsonSchemaFiles(targetClasses, index);\n+        Path jsonSchemaPath = targetClasses.resolve(relativePath);\n+        Files.createDirectories(jsonSchemaPath);\n \n-        if (liveReload.isLiveReload()) {\n-            return;\n-        }\n-\n-        AppPaths appPaths = new AppPaths(root.getPaths());\n-\n-        ApplicationGenerator appGen = createApplicationGenerator(appPaths, combinedIndexBuildItem);\n-        Collection<GeneratedFile> generatedFiles = appGen.generate();\n-\n-        Collection<GeneratedFile> javaFiles = generatedFiles.stream().filter( f -> f.relativePath().endsWith( \".java\" ) ).collect( Collectors.toCollection( ArrayList::new ));\n-        writeGeneratedFiles(appPaths, generatedFiles, resource, genResBI);\n-\n-        if (!javaFiles.isEmpty()) {\n-\n-            Indexer kogitoIndexer = new Indexer();\n-            Set<DotName> kogitoIndex = new HashSet<>();\n-\n-            MemoryFileSystem trgMfs = new MemoryFileSystem();\n-            CompilationResult result = compile(appPaths, trgMfs, curateOutcomeBuildItem.getEffectiveModel(), javaFiles, launchMode.getLaunchMode());\n-            register(appPaths, trgMfs, generatedBeans,\n-                     (className, data) -> generateBeanBuildItem( combinedIndexBuildItem, kogitoIndexer, kogitoIndex, className, data ),\n-                     launchMode.getLaunchMode(), result);\n-\n-\n-            Index index = kogitoIndexer.complete();\n-\n-            generatePersistenceInfo(appPaths, generatedBeans, CompositeIndex.create(combinedIndexBuildItem.getIndex(), index),\n-                                    launchMode, resource, curateOutcomeBuildItem);\n-\n-\n-            reflectiveClass.produce(\n-                    new ReflectiveClassBuildItem(true, true, \"org.kie.kogito.event.AbstractDataEvent\"));\n-            reflectiveClass.produce(\n-                    new ReflectiveClassBuildItem(true, true, \"org.kie.kogito.services.event.AbstractProcessDataEvent\"));\n-            reflectiveClass.produce(\n-                    new ReflectiveClassBuildItem(true, true, \"org.kie.kogito.services.event.ProcessInstanceDataEvent\"));\n-            reflectiveClass.produce(\n-                    new ReflectiveClassBuildItem(true, true, \"org.kie.kogito.services.event.VariableInstanceDataEvent\"));\n-            reflectiveClass.produce(\n-                    new ReflectiveClassBuildItem(true, true, \"org.kie.kogito.services.event.impl.ProcessInstanceEventBody\"));\n-            reflectiveClass.produce(\n-                    new ReflectiveClassBuildItem(true, true, \"org.kie.kogito.services.event.impl.NodeInstanceEventBody\"));\n-            reflectiveClass.produce(\n-                    new ReflectiveClassBuildItem(true, true, \"org.kie.kogito.services.event.impl.ProcessErrorEventBody\"));\n-            reflectiveClass.produce(\n-                    new ReflectiveClassBuildItem(true, true, \"org.kie.kogito.services.event.impl.VariableInstanceEventBody\"));\n-            reflectiveClass.produce(\n-                    new ReflectiveClassBuildItem(true, true, \"org.kie.kogito.services.event.UserTaskInstanceDataEvent\"));\n-            reflectiveClass.produce(\n-                    new ReflectiveClassBuildItem(true, true, \"org.kie.kogito.services.event.impl.UserTaskInstanceEventBody\"));\n-\n-            addChildrenClasses(index, org.kie.kogito.services.event.AbstractProcessDataEvent.class, reflectiveClass);\n-            // not sure there is any generated class directly inheriting from AbstractDataEvent, keeping just in case\n-            addChildrenClasses(index, org.kie.kogito.event.AbstractDataEvent.class, reflectiveClass);\n-            \n-            Collection<GeneratedFile> jsonFiles = getJsonSchemaFiles(index, trgMfs);\n-            Path relativePath = JsonSchemaUtil.getJsonDir();\n-            Path jsonSchemaPath = appPaths.getFirstProjectPath().resolve(\"target\").resolve(\"classes\").resolve(relativePath);\n-            Files.createDirectories(jsonSchemaPath);\n-\n-            for (GeneratedFile jsonFile : jsonFiles) {\n-                Files.write(jsonSchemaPath.resolve(jsonFile.relativePath()), jsonFile.contents());\n-                resource.produce(new NativeImageResourceBuildItem(relativePath.resolve(jsonFile.relativePath()).toString()));\n-            }\n+        for (GeneratedFile jsonFile : jsonFiles) {\n+            Files.write(jsonSchemaPath.resolve(jsonFile.relativePath()), jsonFile.contents());\n+            resource.produce(new NativeImageResourceBuildItem(relativePath.resolve(jsonFile.relativePath()).toString()));\n         }\n     }\n-    \n-    private void addChildrenClasses(Index index,\n-                                    Class<?> superClass,\n-                                    BuildProducer<ReflectiveClassBuildItem> reflectiveClass) {\n-        index.getAllKnownSubclasses(createDotName(superClass.getName()))\n-             .forEach(c -> reflectiveClass.produce(\n-                                                   new ReflectiveClassBuildItem(true,\n-                                                                                true,\n-                                                                                c.name().toString())));\n-    }\n \n-    private void writeGeneratedFiles(AppPaths appPaths, Collection<GeneratedFile> resourceFiles, BuildProducer<NativeImageResourceBuildItem> niResBI, BuildProducer<GeneratedResourceBuildItem> genResBI) {\n-        for (Path projectPath : appPaths.projectPaths) {\n-            String restResourcePath = projectPath.resolve( generatedCustomizableSourcesDir ).toString();\n-            String resourcePath = projectPath.resolve( generatedResourcesDir ).toString();\n-            String sourcePath = projectPath.resolve( generatedSourcesDir ).toString();\n-\n-            for (GeneratedFile f : resourceFiles) {\n-                try {\n-                    if ( f.getType() == GeneratedFile.Type.RESOURCE ) {\n-                        writeGeneratedFile( f, resourcePath );\n-                    } else if (f.getType() == GeneratedFile.Type.GENERATED_CP_RESOURCE) { // since quarkus-maven-plugin is later phase of maven-resources-plugin, need to manually late-provide the resource in the expected location for quarkus:dev phase --so not: writeGeneratedFile( f, resourcePath );\n-                        Path resolve = appPaths.getFirstProjectPath().resolve(\"target\").resolve(\"classes\").resolve(f.relativePath());\n-                        resolve.getParent().toFile().mkdirs();\n-                        Files.write(resolve, f.contents());\n-                        genResBI.produce(new GeneratedResourceBuildItem(f.relativePath(), f.contents()));\n-                        niResBI.produce(new NativeImageResourceBuildItem(f.relativePath()));\n-                    } else if (f.getType().isCustomizable()) {\n-                        writeGeneratedFile(f, restResourcePath);\n-                    } else {\n-                        writeGeneratedFile(f, sourcePath);\n-                    }\n-                } catch (IOException e) {\n-                    logger.warn(String.format(\"Could not write file '%s'\", f.toString()), e);\n-                }\n-            }\n-        }\n-    }\n+    private void registerDataEventsForReflection(Index index) {\n+        reflectiveClass.produce(\n+                new ReflectiveClassBuildItem(true, true, \"org.kie.kogito.event.AbstractDataEvent\"));\n+        reflectiveClass.produce(\n+                new ReflectiveClassBuildItem(true, true, \"org.kie.kogito.services.event.AbstractProcessDataEvent\"));\n+        reflectiveClass.produce(\n+                new ReflectiveClassBuildItem(true, true, \"org.kie.kogito.services.event.ProcessInstanceDataEvent\"));\n+        reflectiveClass.produce(\n+                new ReflectiveClassBuildItem(true, true, \"org.kie.kogito.services.event.VariableInstanceDataEvent\"));\n+        reflectiveClass.produce(\n+                new ReflectiveClassBuildItem(true, true, \"org.kie.kogito.services.event.impl.ProcessInstanceEventBody\"));\n+        reflectiveClass.produce(\n+                new ReflectiveClassBuildItem(true, true, \"org.kie.kogito.services.event.impl.NodeInstanceEventBody\"));\n+        reflectiveClass.produce(\n+                new ReflectiveClassBuildItem(true, true, \"org.kie.kogito.services.event.impl.ProcessErrorEventBody\"));\n+        reflectiveClass.produce(\n+                new ReflectiveClassBuildItem(true, true, \"org.kie.kogito.services.event.impl.VariableInstanceEventBody\"));\n+        reflectiveClass.produce(\n+                new ReflectiveClassBuildItem(true, true, \"org.kie.kogito.services.event.UserTaskInstanceDataEvent\"));\n+        reflectiveClass.produce(\n+                new ReflectiveClassBuildItem(true, true, \"org.kie.kogito.services.event.impl.UserTaskInstanceEventBody\"));\n+\n+        // not sure there is any generated class directly inheriting from AbstractDataEvent, keeping just in case\n+        index.getAllKnownSubclasses(DotName.createSimple(org.kie.kogito.event.AbstractDataEvent.class.getCanonicalName()))\n+                .forEach(c -> reflectiveClass.produce(\n+                        new ReflectiveClassBuildItem(true, true, c.name().toString())));\n+\n+        index.getAllKnownSubclasses(DotName.createSimple(org.kie.kogito.services.event.AbstractProcessDataEvent.class.getCanonicalName()))\n+                .forEach(c -> reflectiveClass.produce(\n+                        new ReflectiveClassBuildItem(true, true, c.name().toString())));", "originalCommit": "f6c09e13bac8f960d778f3ee45f8040c764ada72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg2MzM5Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/688#discussion_r472863393", "bodyText": "Done", "author": "danielezonca", "createdAt": "2020-08-19T08:41:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4MDI5Nw=="}], "type": "inlineReview"}, {"oid": "df902bce4813ff1cec3e944ed6e8e2db8b837a9e", "url": "https://github.com/kiegroup/kogito-runtimes/commit/df902bce4813ff1cec3e944ed6e8e2db8b837a9e", "message": "Update CollectedResource.java", "committedDate": "2020-08-19T08:25:00Z", "type": "commit"}, {"oid": "5015f1d5c47d550bdd732054f1cadc04a8d2533b", "url": "https://github.com/kiegroup/kogito-runtimes/commit/5015f1d5c47d550bdd732054f1cadc04a8d2533b", "message": "Update KogitoAssetsProcessor.java", "committedDate": "2020-08-19T08:40:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY1ODcyMg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/688#discussion_r475658722", "bodyText": "Just a side note, if there are more paths in the PathsCollection and only one of them is a JAR, then this flag is set for all paths, which may break the getPath() method as it will either treat all paths as jars or as classes paths. Maybe it doesn't cause any issues now, but it may in future... For sure it behaves differently, as without a JAR it will return src/main/resources directories, but with at least one JAR it will return JAR file paths and classes in target\\classes - i.e. just entries stored in the classesPaths list.", "author": "MarianMacik", "createdAt": "2020-08-24T14:35:57Z", "path": "kogito-quarkus-extension/deployment/src/main/java/org/kie/kogito/quarkus/deployment/AppPaths.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.quarkus.deployment;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import io.quarkus.bootstrap.model.PathsCollection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class AppPaths {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AppPaths.class);\n+\n+    final Set<Path> projectPaths = new LinkedHashSet<>();\n+    final List<Path> classesPaths = new ArrayList<>();\n+\n+    boolean isJar = false;\n+\n+    AppPaths(PathsCollection paths) {\n+        for (Path path : paths) {\n+            PathType pathType = getPathType(path);\n+            switch (pathType) {\n+                case CLASSES: {\n+                    classesPaths.add(path);\n+                    projectPaths.add(path.getParent().getParent());\n+                    break;\n+                }\n+                case TEST_CLASSES: {\n+                    projectPaths.add(path.getParent().getParent());\n+                    break;\n+                }\n+                case JAR: {\n+                    isJar = true;", "originalCommit": "5015f1d5c47d550bdd732054f1cadc04a8d2533b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY2NDM4Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/688#discussion_r475664387", "bodyText": "@MarianMacik\nI have created this ticket, I think it covers your question too https://issues.redhat.com/browse/KOGITO-3112\nWdyt?", "author": "danielezonca", "createdAt": "2020-08-24T14:44:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY1ODcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg0MDgwOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/688#discussion_r475840809", "bodyText": "Yes, thanks @danielezonca!", "author": "MarianMacik", "createdAt": "2020-08-24T19:21:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY1ODcyMg=="}], "type": "inlineReview"}]}