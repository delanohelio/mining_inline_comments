{"pr_number": 946, "pr_title": "KOGITO-3936: event-driven evaluation of decision models", "pr_createdAt": "2020-12-17T15:19:11Z", "pr_url": "https://github.com/kiegroup/kogito-runtimes/pull/946", "timeline": [{"oid": "0260e7b072e3db276c017e4d07ecb1186795e3cd", "url": "https://github.com/kiegroup/kogito-runtimes/commit/0260e7b072e3db276c017e4d07ecb1186795e3cd", "message": "KOGITO-3936: add event-driven-decisions addon skeleton pom structure", "committedDate": "2020-12-18T13:51:32Z", "type": "commit"}, {"oid": "7e9401adc181eeacf7328d1a9fb4f5409a1e1241", "url": "https://github.com/kiegroup/kogito-runtimes/commit/7e9401adc181eeacf7328d1a9fb4f5409a1e1241", "message": "KOGITO-3936: create cloudevents-utils module", "committedDate": "2020-12-18T13:51:32Z", "type": "commit"}, {"oid": "b024e1e0b6a21ef20515a9749b28e4ffa3b5ce85", "url": "https://github.com/kiegroup/kogito-runtimes/commit/b024e1e0b6a21ef20515a9749b28e4ffa3b5ce85", "message": "KOGITO-3936: first version", "committedDate": "2020-12-18T13:51:32Z", "type": "commit"}, {"oid": "21383ebf561bb7236501dc0d9dcf3d1d8e55fb6f", "url": "https://github.com/kiegroup/kogito-runtimes/commit/21383ebf561bb7236501dc0d9dcf3d1d8e55fb6f", "message": "KOGITO-3936: source + subject + executionId in response events", "committedDate": "2020-12-18T13:51:32Z", "type": "commit"}, {"oid": "f5dede3d2f2f07d36032bd1b0c9796758b3adaa3", "url": "https://github.com/kiegroup/kogito-runtimes/commit/f5dede3d2f2f07d36032bd1b0c9796758b3adaa3", "message": "KOGITO-3936: update POMs", "committedDate": "2020-12-18T13:51:32Z", "type": "commit"}, {"oid": "b8a9f6b20a98024d25d9be4f854ac9c44041fe27", "url": "https://github.com/kiegroup/kogito-runtimes/commit/b8a9f6b20a98024d25d9be4f854ac9c44041fe27", "message": "KOGITO-3936: remove test log messages", "committedDate": "2020-12-18T13:51:33Z", "type": "commit"}, {"oid": "d229e2e5e785800ac2160e8274d8eb987b8609ab", "url": "https://github.com/kiegroup/kogito-runtimes/commit/d229e2e5e785800ac2160e8274d8eb987b8609ab", "message": "KOGITO-3936: fix DecisionModels in EventDrivenDecisionController", "committedDate": "2020-12-18T14:07:29Z", "type": "commit"}, {"oid": "d229e2e5e785800ac2160e8274d8eb987b8609ab", "url": "https://github.com/kiegroup/kogito-runtimes/commit/d229e2e5e785800ac2160e8274d8eb987b8609ab", "message": "KOGITO-3936: fix DecisionModels in EventDrivenDecisionController", "committedDate": "2020-12-18T14:07:29Z", "type": "forcePushed"}, {"oid": "5a8416e03caffeb3d1a4ef2bc89118791665e318", "url": "https://github.com/kiegroup/kogito-runtimes/commit/5a8416e03caffeb3d1a4ef2bc89118791665e318", "message": "KOGITO-3936: add tests", "committedDate": "2020-12-20T23:37:02Z", "type": "commit"}, {"oid": "7f3fccdcc08e82635dde29decf91f402363d7040", "url": "https://github.com/kiegroup/kogito-runtimes/commit/7f3fccdcc08e82635dde29decf91f402363d7040", "message": "KOGITO-3936: fix code smells", "committedDate": "2020-12-21T07:52:28Z", "type": "commit"}, {"oid": "489192fa3b1e766c933a03823eb8ef20cbeb61b0", "url": "https://github.com/kiegroup/kogito-runtimes/commit/489192fa3b1e766c933a03823eb8ef20cbeb61b0", "message": "KOGITO-3936: improve tests", "committedDate": "2020-12-21T09:25:41Z", "type": "commit"}, {"oid": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "url": "https://github.com/kiegroup/kogito-runtimes/commit/3de94edeba04287d8dec2c9a88e5733541d06c8f", "message": "KOGITO-3936: merge branch master", "committedDate": "2021-01-05T13:58:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgzODYzNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r553838637", "bodyText": "is there a specific reason for this public overload that accepts an ObjectMapper?", "author": "r00ta", "createdAt": "2021-01-08T09:38:56Z", "path": "addons/cloudevents/cloudevents-utils/src/main/java/org/kie/kogito/cloudevents/CloudEventUtils.java", "diffHunk": "@@ -70,6 +82,19 @@\n         }\n     }\n \n+    public static <T> Optional<T> decodeData(CloudEvent event, Class<T> dataClass) {\n+        return decodeData(event, dataClass, Mapper.mapper());\n+    }\n+\n+    public static <T> Optional<T> decodeData(CloudEvent event, Class<T> dataClass, ObjectMapper mapper) {", "originalCommit": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTgyNzk0NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r555827944", "bodyText": "Good catch. No it was not used, probably a leftover of previous implementations. I will remove it \ud83d\udc4d", "author": "kostola", "createdAt": "2021-01-12T14:49:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgzODYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg0MTMyNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r553841326", "bodyText": "Are they tested?", "author": "r00ta", "createdAt": "2021-01-08T09:44:11Z", "path": "addons/cloudevents/cloudevents-utils/src/main/java/org/kie/kogito/cloudevents/CloudEventUtils.java", "diffHunk": "@@ -94,6 +119,35 @@\n                 });\n     }\n \n+    public static URI buildDecisionSource(String serviceUrl) {\n+        return buildDecisionSource(serviceUrl, null, null);\n+    }\n+\n+    public static URI buildDecisionSource(String serviceUrl, String decisionModelName) {\n+        return buildDecisionSource(serviceUrl, decisionModelName, null);\n+    }\n+\n+    public static URI buildDecisionSource(String serviceUrl, String decisionModelName, String decisionServiceName) {\n+        String modelChunk = Optional.ofNullable(decisionModelName)", "originalCommit": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTgyODE3MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r555828171", "bodyText": "No they weren't. I added the tests.", "author": "kostola", "createdAt": "2021-01-12T14:49:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg0MTMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg0MzgxNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r553843817", "bodyText": "what if we put the logic of \"valid request\" inside the class DecisionRequestEvent with a method isValid? It would be easier to extend/control/test", "author": "r00ta", "createdAt": "2021-01-08T09:48:41Z", "path": "addons/events/event-driven-decisions/event-driven-decisions-common/src/main/java/org/kie/kogito/eventdriven/decision/EventDrivenDecisionController.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.eventdriven.decision;\n+\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.cloudevents.CloudEvent;\n+import org.kie.dmn.api.core.DMNContext;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.cloudevents.CloudEventUtils;\n+import org.kie.kogito.conf.ConfigBean;\n+import org.kie.kogito.decision.DecisionExecutionIdUtils;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.decision.DecisionModels;\n+import org.kie.kogito.dmn.rest.DMNJSONUtils;\n+import org.kie.kogito.event.CloudEventEmitter;\n+import org.kie.kogito.event.CloudEventReceiver;\n+\n+import static org.kie.kogito.eventdriven.decision.DecisionRequestType.EVALUATE_ALL;\n+import static org.kie.kogito.eventdriven.decision.DecisionRequestType.EVALUATE_DECISION_SERVICE;\n+\n+public class EventDrivenDecisionController {\n+\n+    private static final String VALID_REQUEST_EVENT_TYPE = DecisionRequestEvent.class.getName();\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    private DecisionModels decisionModels;\n+    private ConfigBean config;\n+    private CloudEventEmitter eventEmitter;\n+    private CloudEventReceiver eventReceiver;\n+\n+    protected EventDrivenDecisionController() {\n+    }\n+\n+    protected EventDrivenDecisionController(Application application, ConfigBean config, CloudEventEmitter eventEmitter, CloudEventReceiver eventReceiver) {\n+        this.decisionModels = application.get(DecisionModels.class);\n+        this.config = config;\n+        this.eventEmitter = eventEmitter;\n+        this.eventReceiver = eventReceiver;\n+    }\n+\n+    protected void setup(Application application, ConfigBean config, CloudEventEmitter eventEmitter, CloudEventReceiver eventReceiver) {\n+        this.decisionModels = application.get(DecisionModels.class);\n+        this.config = config;\n+        this.eventEmitter = eventEmitter;\n+        this.eventReceiver = eventReceiver;\n+        setup();\n+    }\n+\n+    protected void setup() {\n+        eventReceiver.subscribe(this::handleEvent);\n+    }\n+\n+    void handleEvent(String event) {\n+        CloudEventUtils.decode(event)\n+                .filter(e -> VALID_REQUEST_EVENT_TYPE.equals(e.getType()))\n+                .ifPresent(this::handleRequest);\n+    }\n+\n+    private void handleRequest(CloudEvent event) {\n+        CloudEventUtils.decodeData(event, DecisionRequestEvent.class)\n+                .map(data -> new EvaluationContext(event, data))\n+                .map(this::processRequest)\n+                .flatMap(this::buildResponseCloudEvent)\n+                .flatMap(CloudEventUtils::encode)\n+                .ifPresent(eventEmitter::emit);\n+    }\n+\n+    private EvaluationContext processRequest(EvaluationContext ctx) {\n+        DecisionRequestEvent request = ctx.request;\n+\n+        DecisionRequestType type = getRequestType(request);\n+        ctx.requestType = type;\n+\n+        ctx.response = type == DecisionRequestType.INVALID\n+                ? new DecisionResponseEvent(DecisionResponseStatus.BAD_REQUEST, \"Malformed request event\")\n+                : getDecisionModel(request)\n+                        .map(model -> evaluateRequest(request, type, model))\n+                        .map(result -> buildDecisionResponseEventFromResult(request, result))\n+                        .orElseGet(() -> new DecisionResponseEvent(DecisionResponseStatus.NOT_FOUND, \"Model not found\"));\n+\n+        return ctx;\n+    }\n+\n+    private DecisionRequestType getRequestType(DecisionRequestEvent event) {\n+        if (event != null && event.getModelName() != null && event.getModelNamespace() != null && event.getInputContext() != null) {", "originalCommit": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQwMjEyOA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r556402128", "bodyText": "Good idea. Done \ud83d\udc4d", "author": "kostola", "createdAt": "2021-01-13T10:04:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg0MzgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg0NjQyMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r553846420", "bodyText": "Not sure if INVALID is really a type of a request. INVALID is used only in this private method\n    private EvaluationContext processRequest(EvaluationContext ctx) {\n        DecisionRequestEvent request = ctx.request;\n\n        DecisionRequestType type = getRequestType(request);  // returns INVALID if the req is INVALID\n        ctx.requestType = type;\n\n        ctx.response = type == DecisionRequestType.INVALID\n                ? new DecisionResponseEvent(DecisionResponseStatus.BAD_REQUEST, \"Malformed request event\")\n                : getDecisionModel(request)\n                        .map(model -> evaluateRequest(request, type, model))\n                        .map(result -> buildDecisionResponseEventFromResult(request, result))\n                        .orElseGet(() -> new DecisionResponseEvent(DecisionResponseStatus.NOT_FOUND, \"Model not found\"));\n\n        return ctx;\n    }\n\nAnd I think we could manage this case without adding this public enum", "author": "r00ta", "createdAt": "2021-01-08T09:53:42Z", "path": "addons/events/event-driven-decisions/event-driven-decisions-common/src/main/java/org/kie/kogito/eventdriven/decision/DecisionRequestType.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.eventdriven.decision;\n+\n+public enum DecisionRequestType {\n+    INVALID,", "originalCommit": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQ0MDQ2MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r556440460", "bodyText": "I refactored this method so that:\n\nthe DecisionRequestType enum is now a private inner class of EventDrivenDecisionController, since it's only used inside there (named RequestType).\nthe INVALID value is now replaced by a local boolean variable, since, as you correctly pointed out, semantically it is not a real type of request.", "author": "kostola", "createdAt": "2021-01-13T11:08:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg0NjQyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg1MTMxMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r553851313", "bodyText": "I might be wrong, but if you remove @JsonProperty(access = READ_ONLY) and create a public default constructor the issue should go away?", "author": "r00ta", "createdAt": "2021-01-08T10:03:24Z", "path": "addons/events/event-driven-decisions/event-driven-decisions-common/src/main/java/org/kie/kogito/eventdriven/decision/DecisionResponseEvent.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.eventdriven.decision;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import org.kie.kogito.dmn.rest.DMNResult;\n+\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_EMPTY;\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL;\n+import static com.fasterxml.jackson.annotation.JsonProperty.Access.READ_ONLY;\n+\n+public class DecisionResponseEvent {\n+\n+    private DecisionResponseStatus status;\n+\n+    @JsonInclude(NON_EMPTY)\n+    private String errorMessage;\n+\n+    @JsonInclude(NON_EMPTY)\n+    private String executionId;\n+\n+    @JsonProperty(access = READ_ONLY) // temporary fix of deserialization issues in tests\n+    @JsonInclude(NON_NULL)\n+    private DMNResult result;\n+\n+    private DecisionResponseEvent() {\n+    }", "originalCommit": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTgzNDQxMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r555834411", "bodyText": "Nope...apparently it doesn't work", "author": "kostola", "createdAt": "2021-01-12T14:57:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg1MTMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg1ODQzMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r553858431", "bodyText": "During the review I've realized that there is an implicit contract: if decisionServiceName is specified, only that decision service is evaluated, otherwise all the services are evaluated.\nI'm wondering if it's better to make it explicit, so that it's more clear to read, consume, and extend in the future. wdyt?", "author": "r00ta", "createdAt": "2021-01-08T10:17:59Z", "path": "addons/events/event-driven-decisions/event-driven-decisions-common/src/main/java/org/kie/kogito/eventdriven/decision/DecisionRequestEvent.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.eventdriven.decision;\n+\n+import java.util.Map;\n+\n+public class DecisionRequestEvent {\n+\n+    private String modelName;\n+    private String modelNamespace;\n+    private String decisionServiceName;\n+    private Map<String, Object> inputContext;\n+", "originalCommit": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQyMjYwNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r556422607", "bodyText": "Good point. What's your idea for making it explicit?", "author": "kostola", "createdAt": "2021-01-13T10:38:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg1ODQzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDk5MjY1MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r560992650", "bodyText": "Resolving this conversation because the new refactoring completely changed this part.", "author": "kostola", "createdAt": "2021-01-20T14:17:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg1ODQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg1OTY2MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r553859660", "bodyText": "I think it would be better to put the files under the resource folder and then read them here in the tests.", "author": "r00ta", "createdAt": "2021-01-08T10:20:34Z", "path": "addons/events/event-driven-decisions/event-driven-decisions-common/src/test/java/org/kie/kogito/eventdriven/decision/EventDrivenDecisionControllerTest.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.eventdriven.decision;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import io.cloudevents.CloudEvent;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.kie.dmn.api.core.DMNRuntime;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.cloudevents.CloudEventUtils;\n+import org.kie.kogito.conf.ConfigBean;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.decision.DecisionModels;\n+import org.kie.kogito.decision.DecisionTestUtils;\n+import org.kie.kogito.dmn.DmnDecisionModel;\n+import org.kie.kogito.event.CloudEventEmitter;\n+import org.kie.kogito.event.CloudEventReceiver;\n+import org.mockito.ArgumentCaptor;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.kogito.decision.DecisionTestUtils.DECISION_SERVICE_NODE_NAME;\n+import static org.kie.kogito.decision.DecisionTestUtils.MODEL_NAME;\n+import static org.kie.kogito.decision.DecisionTestUtils.MODEL_NAMESPACE;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.ArgumentMatchers.notNull;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.reset;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+class EventDrivenDecisionControllerTest {\n+\n+    private static final String CLOUDEVENT_OK_DATA_PLACEHOLDER = \"%%DATA_EVENT%%\";\n+    private static final String CLOUDEVENT_OK_ID = \"a89b61a2-5644-487a-8a86-144855c5dce8\";\n+    private static final String CLOUDEVENT_OK_SOURCE = \"SomeEventSource\";\n+    private static final String CLOUDEVENT_OK_TEMPLATE = \"\" +\n+            \"{\\n\" +\n+            \"    \\\"specversion\\\": \\\"1.0\\\",\\n\" +\n+            \"    \\\"id\\\": \\\"\" + CLOUDEVENT_OK_ID + \"\\\",\\n\" +\n+            \"    \\\"source\\\": \\\"\" + CLOUDEVENT_OK_SOURCE + \"\\\",\\n\" +\n+            \"    \\\"type\\\": \\\"org.kie.kogito.eventdriven.decision.DecisionRequestEvent\\\",\\n\" +\n+            \"    \\\"data\\\": \" + CLOUDEVENT_OK_DATA_PLACEHOLDER + \"\\n\" +\n+            \"}\";\n+\n+    private static final String CLOUDEVENT_IGNORED = \"\" +\n+            \"{\\n\" +\n+            \"    \\\"specversion\\\": \\\"1.0\\\",\\n\" +\n+            \"    \\\"id\\\": \\\"55c5dce8-5644-487a-8a86-1448a89b61a2\\\",\\n\" +\n+            \"    \\\"source\\\": \\\"SomeOtherEventSource\\\",\\n\" +\n+            \"    \\\"type\\\": \\\"com.example.SomeCloudEvent\\\",\\n\" +\n+            \"    \\\"data\\\": {}\\n\" +\n+            \"}\";\n+\n+    private static final List<String> DATA_EVENT_BAD_REQUEST = Stream.of(\n+            \"{}\",\n+            \"{\\\"modelName\\\": \\\"aName\\\"}\",\n+            \"{\\\"modelNamespace\\\": \\\"aNamespace\\\"}\",\n+            \"{\\\"inputContext\\\": {}}\",\n+            \"{\\\"modelName\\\": \\\"aName\\\",\\\"modelNamespace\\\": \\\"aNamespace\\\"}\",\n+            \"{\\\"modelName\\\": \\\"aName\\\",\\\"inputContext\\\": {}}\",\n+            \"{\\\"modelNamespace\\\": \\\"aNamespace\\\",\\\"inputContext\\\": {}}\"\n+    ).collect(Collectors.toList());\n+\n+    private static final String DATA_EVENT_NOT_FOUND = \"{\\\"modelName\\\": \\\"aName\\\",\\\"modelNamespace\\\": \\\"aNamespace\\\",\\\"inputContext\\\": {}}\";\n+\n+    private static final String DATA_EVENT_OK_EVALUATE_ALL = \"\" +", "originalCommit": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQyMzUyNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r556423526", "bodyText": "This is the good old question \ud83d\ude04\nI'd like to leave as it is at the moment because in another PR I got asked exactly the opposite \ud83d\ude05", "author": "kostola", "createdAt": "2021-01-13T10:39:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg1OTY2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTIzNzk2OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r555237968", "bodyText": "What about?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final String VALID_REQUEST_EVENT_TYPE = DecisionRequestEvent.class.getName();\n          \n          \n            \n                private static final String VALID_REQUEST_EVENT_TYPE = DecisionRequestEvent.class.getSimpleName();\n          \n      \n    \n    \n  \n\nI think it is enough without adding the package", "author": "danielezonca", "createdAt": "2021-01-11T18:00:38Z", "path": "addons/events/event-driven-decisions/event-driven-decisions-common/src/main/java/org/kie/kogito/eventdriven/decision/EventDrivenDecisionController.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.eventdriven.decision;\n+\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.cloudevents.CloudEvent;\n+import org.kie.dmn.api.core.DMNContext;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.cloudevents.CloudEventUtils;\n+import org.kie.kogito.conf.ConfigBean;\n+import org.kie.kogito.decision.DecisionExecutionIdUtils;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.decision.DecisionModels;\n+import org.kie.kogito.dmn.rest.DMNJSONUtils;\n+import org.kie.kogito.event.CloudEventEmitter;\n+import org.kie.kogito.event.CloudEventReceiver;\n+\n+import static org.kie.kogito.eventdriven.decision.DecisionRequestType.EVALUATE_ALL;\n+import static org.kie.kogito.eventdriven.decision.DecisionRequestType.EVALUATE_DECISION_SERVICE;\n+\n+public class EventDrivenDecisionController {\n+\n+    private static final String VALID_REQUEST_EVENT_TYPE = DecisionRequestEvent.class.getName();", "originalCommit": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQwMzgzNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r556403836", "bodyText": "I used getName with the whole package to be consistent with TraceEvents which do the same.\nI prefer being consistent over saving the length of the package in this specific event but if you prefer otherwise it's fine for me to change it.", "author": "kostola", "createdAt": "2021-01-13T10:07:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTIzNzk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDk5MzE0MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r560993141", "bodyText": "New event types use plain string instead of class full names.", "author": "kostola", "createdAt": "2021-01-20T14:17:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTIzNzk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTIzODU0Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r555238543", "bodyText": "@evacchi @ricardozanini\nHere we are using event type to decide if accept of skip the message. Do we agree in general?", "author": "danielezonca", "createdAt": "2021-01-11T18:01:40Z", "path": "addons/events/event-driven-decisions/event-driven-decisions-common/src/main/java/org/kie/kogito/eventdriven/decision/EventDrivenDecisionController.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.eventdriven.decision;\n+\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.cloudevents.CloudEvent;\n+import org.kie.dmn.api.core.DMNContext;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.cloudevents.CloudEventUtils;\n+import org.kie.kogito.conf.ConfigBean;\n+import org.kie.kogito.decision.DecisionExecutionIdUtils;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.decision.DecisionModels;\n+import org.kie.kogito.dmn.rest.DMNJSONUtils;\n+import org.kie.kogito.event.CloudEventEmitter;\n+import org.kie.kogito.event.CloudEventReceiver;\n+\n+import static org.kie.kogito.eventdriven.decision.DecisionRequestType.EVALUATE_ALL;\n+import static org.kie.kogito.eventdriven.decision.DecisionRequestType.EVALUATE_DECISION_SERVICE;\n+\n+public class EventDrivenDecisionController {\n+\n+    private static final String VALID_REQUEST_EVENT_TYPE = DecisionRequestEvent.class.getName();\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    private DecisionModels decisionModels;\n+    private ConfigBean config;\n+    private CloudEventEmitter eventEmitter;\n+    private CloudEventReceiver eventReceiver;\n+\n+    protected EventDrivenDecisionController() {\n+    }\n+\n+    protected EventDrivenDecisionController(Application application, ConfigBean config, CloudEventEmitter eventEmitter, CloudEventReceiver eventReceiver) {\n+        this.decisionModels = application.get(DecisionModels.class);\n+        this.config = config;\n+        this.eventEmitter = eventEmitter;\n+        this.eventReceiver = eventReceiver;\n+    }\n+\n+    protected void setup(Application application, ConfigBean config, CloudEventEmitter eventEmitter, CloudEventReceiver eventReceiver) {\n+        this.decisionModels = application.get(DecisionModels.class);\n+        this.config = config;\n+        this.eventEmitter = eventEmitter;\n+        this.eventReceiver = eventReceiver;\n+        setup();\n+    }\n+\n+    protected void setup() {\n+        eventReceiver.subscribe(this::handleEvent);\n+    }\n+\n+    void handleEvent(String event) {\n+        CloudEventUtils.decode(event)\n+                .filter(e -> VALID_REQUEST_EVENT_TYPE.equals(e.getType()))", "originalCommit": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI1MjI0Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r555252247", "bodyText": "That's the model we've decided to follow. But I think won't hurt adding an or condition to check for the event Source as well.", "author": "ricardozanini", "createdAt": "2021-01-11T18:26:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTIzODU0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQwNjMwOA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r556406308", "bodyText": "@danielezonca I did it this way because, as Ricardo said, it's the current way it works.\n@ricardozanini I assumed that any source can send events to trigger the executions as long as they're formatted correctly. If we want to filter by source we must discuss a logic to distinguish valid sources from invalid ones. Are there already some conventions about this?", "author": "kostola", "createdAt": "2021-01-13T10:11:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTIzODU0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjUwMDIwMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r556500201", "bodyText": "Sources are URI attribute, so I think we can start from there. But FWIW, I believe it's better to just open a follow up JIRA to filter by sources and have some discussions around it and how we are going to implement.\nFrom the Knative eventing perspective, we can always use filters to get these events into our platform, so we can cover some use cases until there.", "author": "ricardozanini", "createdAt": "2021-01-13T12:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTIzODU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTIzOTY1OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r555239659", "bodyText": "To be honest I have mixed feeling to use a json to encode the subject of the message. As far as I remember this is used to correlate input event to output event. Am I right?\n@evacchi @ricardozanini\nWdyt? Do you like to have a json string as subject?", "author": "danielezonca", "createdAt": "2021-01-11T18:03:30Z", "path": "addons/events/event-driven-decisions/event-driven-decisions-common/src/main/java/org/kie/kogito/eventdriven/decision/EventDrivenDecisionController.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.eventdriven.decision;\n+\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.cloudevents.CloudEvent;\n+import org.kie.dmn.api.core.DMNContext;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.cloudevents.CloudEventUtils;\n+import org.kie.kogito.conf.ConfigBean;\n+import org.kie.kogito.decision.DecisionExecutionIdUtils;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.decision.DecisionModels;\n+import org.kie.kogito.dmn.rest.DMNJSONUtils;\n+import org.kie.kogito.event.CloudEventEmitter;\n+import org.kie.kogito.event.CloudEventReceiver;\n+\n+import static org.kie.kogito.eventdriven.decision.DecisionRequestType.EVALUATE_ALL;\n+import static org.kie.kogito.eventdriven.decision.DecisionRequestType.EVALUATE_DECISION_SERVICE;\n+\n+public class EventDrivenDecisionController {\n+\n+    private static final String VALID_REQUEST_EVENT_TYPE = DecisionRequestEvent.class.getName();\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    private DecisionModels decisionModels;\n+    private ConfigBean config;\n+    private CloudEventEmitter eventEmitter;\n+    private CloudEventReceiver eventReceiver;\n+\n+    protected EventDrivenDecisionController() {\n+    }\n+\n+    protected EventDrivenDecisionController(Application application, ConfigBean config, CloudEventEmitter eventEmitter, CloudEventReceiver eventReceiver) {\n+        this.decisionModels = application.get(DecisionModels.class);\n+        this.config = config;\n+        this.eventEmitter = eventEmitter;\n+        this.eventReceiver = eventReceiver;\n+    }\n+\n+    protected void setup(Application application, ConfigBean config, CloudEventEmitter eventEmitter, CloudEventReceiver eventReceiver) {\n+        this.decisionModels = application.get(DecisionModels.class);\n+        this.config = config;\n+        this.eventEmitter = eventEmitter;\n+        this.eventReceiver = eventReceiver;\n+        setup();\n+    }\n+\n+    protected void setup() {\n+        eventReceiver.subscribe(this::handleEvent);\n+    }\n+\n+    void handleEvent(String event) {\n+        CloudEventUtils.decode(event)\n+                .filter(e -> VALID_REQUEST_EVENT_TYPE.equals(e.getType()))\n+                .ifPresent(this::handleRequest);\n+    }\n+\n+    private void handleRequest(CloudEvent event) {\n+        CloudEventUtils.decodeData(event, DecisionRequestEvent.class)\n+                .map(data -> new EvaluationContext(event, data))\n+                .map(this::processRequest)\n+                .flatMap(this::buildResponseCloudEvent)\n+                .flatMap(CloudEventUtils::encode)\n+                .ifPresent(eventEmitter::emit);\n+    }\n+\n+    private EvaluationContext processRequest(EvaluationContext ctx) {\n+        DecisionRequestEvent request = ctx.request;\n+\n+        DecisionRequestType type = getRequestType(request);\n+        ctx.requestType = type;\n+\n+        ctx.response = type == DecisionRequestType.INVALID\n+                ? new DecisionResponseEvent(DecisionResponseStatus.BAD_REQUEST, \"Malformed request event\")\n+                : getDecisionModel(request)\n+                        .map(model -> evaluateRequest(request, type, model))\n+                        .map(result -> buildDecisionResponseEventFromResult(request, result))\n+                        .orElseGet(() -> new DecisionResponseEvent(DecisionResponseStatus.NOT_FOUND, \"Model not found\"));\n+\n+        return ctx;\n+    }\n+\n+    private DecisionRequestType getRequestType(DecisionRequestEvent event) {\n+        if (event != null && event.getModelName() != null && event.getModelNamespace() != null && event.getInputContext() != null) {\n+            return event.getDecisionServiceName() == null\n+                    ? EVALUATE_ALL\n+                    : EVALUATE_DECISION_SERVICE;\n+        }\n+        return DecisionRequestType.INVALID;\n+    }\n+\n+    private Optional<DecisionModel> getDecisionModel(DecisionRequestEvent event) {\n+        try {\n+            return Optional.ofNullable(decisionModels.getDecisionModel(event.getModelNamespace(), event.getModelName()));\n+        } catch (IllegalStateException e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private DMNResult evaluateRequest(DecisionRequestEvent event, DecisionRequestType type, DecisionModel model) {\n+        DMNContext context = DMNJSONUtils.ctx(model, event.getInputContext());\n+        return type == EVALUATE_DECISION_SERVICE\n+                ? model.evaluateDecisionService(context, event.getDecisionServiceName())\n+                : model.evaluateAll(context);\n+    }\n+\n+    private DecisionResponseEvent buildDecisionResponseEventFromResult(DecisionRequestEvent event, DMNResult result) {\n+        String executionId = DecisionExecutionIdUtils.get(result.getContext());\n+        return new DecisionResponseEvent(\n+                executionId,\n+                new org.kie.kogito.dmn.rest.DMNResult(event.getModelNamespace(), event.getModelName(), result)\n+        );\n+    }\n+\n+    private Optional<CloudEvent> buildResponseCloudEvent(EvaluationContext ctx) {\n+        URI source = buildResponseCloudEventSource(ctx);\n+        String subject = buildResponseCloudEventSubject(ctx);\n+        return CloudEventUtils.build(UUID.randomUUID().toString(), source, subject, ctx.response, DecisionResponseEvent.class);\n+    }\n+\n+    private URI buildResponseCloudEventSource(EvaluationContext ctx) {\n+        if (ctx.requestType == EVALUATE_ALL) {\n+            return CloudEventUtils.buildDecisionSource(config.getServiceUrl(), ctx.request.getModelName());\n+        }\n+        if (ctx.requestType == EVALUATE_DECISION_SERVICE) {\n+            return CloudEventUtils.buildDecisionSource(config.getServiceUrl(), ctx.request.getModelName(), ctx.request.getDecisionServiceName());\n+        }\n+        return CloudEventUtils.buildDecisionSource(config.getServiceUrl());\n+    }\n+\n+    private String buildResponseCloudEventSubject(EvaluationContext ctx) {\n+        try {\n+            return MAPPER.writeValueAsString(", "originalCommit": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQzODMxNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r556438316", "bodyText": "IMO the subject should be the one received in the request event (if any). The subject can be understood as a correlation key and is usually generated by the producer.\nSubjects are attributes commonly used to create subscriptions or correlate multiple events.", "author": "ruromero", "createdAt": "2021-01-13T11:04:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTIzOTY1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDk5Mzg3MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r560993870", "bodyText": "The new version behaves exactly as @ruromero described about event subjects \ud83d\udc4d", "author": "kostola", "createdAt": "2021-01-20T14:18:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTIzOTY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTIzOTgyNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r555239825", "bodyText": "What about at least log the error?", "author": "danielezonca", "createdAt": "2021-01-11T18:03:47Z", "path": "addons/events/event-driven-decisions/event-driven-decisions-common/src/main/java/org/kie/kogito/eventdriven/decision/EventDrivenDecisionController.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.eventdriven.decision;\n+\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.cloudevents.CloudEvent;\n+import org.kie.dmn.api.core.DMNContext;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.cloudevents.CloudEventUtils;\n+import org.kie.kogito.conf.ConfigBean;\n+import org.kie.kogito.decision.DecisionExecutionIdUtils;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.decision.DecisionModels;\n+import org.kie.kogito.dmn.rest.DMNJSONUtils;\n+import org.kie.kogito.event.CloudEventEmitter;\n+import org.kie.kogito.event.CloudEventReceiver;\n+\n+import static org.kie.kogito.eventdriven.decision.DecisionRequestType.EVALUATE_ALL;\n+import static org.kie.kogito.eventdriven.decision.DecisionRequestType.EVALUATE_DECISION_SERVICE;\n+\n+public class EventDrivenDecisionController {\n+\n+    private static final String VALID_REQUEST_EVENT_TYPE = DecisionRequestEvent.class.getName();\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    private DecisionModels decisionModels;\n+    private ConfigBean config;\n+    private CloudEventEmitter eventEmitter;\n+    private CloudEventReceiver eventReceiver;\n+\n+    protected EventDrivenDecisionController() {\n+    }\n+\n+    protected EventDrivenDecisionController(Application application, ConfigBean config, CloudEventEmitter eventEmitter, CloudEventReceiver eventReceiver) {\n+        this.decisionModels = application.get(DecisionModels.class);\n+        this.config = config;\n+        this.eventEmitter = eventEmitter;\n+        this.eventReceiver = eventReceiver;\n+    }\n+\n+    protected void setup(Application application, ConfigBean config, CloudEventEmitter eventEmitter, CloudEventReceiver eventReceiver) {\n+        this.decisionModels = application.get(DecisionModels.class);\n+        this.config = config;\n+        this.eventEmitter = eventEmitter;\n+        this.eventReceiver = eventReceiver;\n+        setup();\n+    }\n+\n+    protected void setup() {\n+        eventReceiver.subscribe(this::handleEvent);\n+    }\n+\n+    void handleEvent(String event) {\n+        CloudEventUtils.decode(event)\n+                .filter(e -> VALID_REQUEST_EVENT_TYPE.equals(e.getType()))\n+                .ifPresent(this::handleRequest);\n+    }\n+\n+    private void handleRequest(CloudEvent event) {\n+        CloudEventUtils.decodeData(event, DecisionRequestEvent.class)\n+                .map(data -> new EvaluationContext(event, data))\n+                .map(this::processRequest)\n+                .flatMap(this::buildResponseCloudEvent)\n+                .flatMap(CloudEventUtils::encode)\n+                .ifPresent(eventEmitter::emit);\n+    }\n+\n+    private EvaluationContext processRequest(EvaluationContext ctx) {\n+        DecisionRequestEvent request = ctx.request;\n+\n+        DecisionRequestType type = getRequestType(request);\n+        ctx.requestType = type;\n+\n+        ctx.response = type == DecisionRequestType.INVALID\n+                ? new DecisionResponseEvent(DecisionResponseStatus.BAD_REQUEST, \"Malformed request event\")\n+                : getDecisionModel(request)\n+                        .map(model -> evaluateRequest(request, type, model))\n+                        .map(result -> buildDecisionResponseEventFromResult(request, result))\n+                        .orElseGet(() -> new DecisionResponseEvent(DecisionResponseStatus.NOT_FOUND, \"Model not found\"));\n+\n+        return ctx;\n+    }\n+\n+    private DecisionRequestType getRequestType(DecisionRequestEvent event) {\n+        if (event != null && event.getModelName() != null && event.getModelNamespace() != null && event.getInputContext() != null) {\n+            return event.getDecisionServiceName() == null\n+                    ? EVALUATE_ALL\n+                    : EVALUATE_DECISION_SERVICE;\n+        }\n+        return DecisionRequestType.INVALID;\n+    }\n+\n+    private Optional<DecisionModel> getDecisionModel(DecisionRequestEvent event) {\n+        try {\n+            return Optional.ofNullable(decisionModels.getDecisionModel(event.getModelNamespace(), event.getModelName()));\n+        } catch (IllegalStateException e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private DMNResult evaluateRequest(DecisionRequestEvent event, DecisionRequestType type, DecisionModel model) {\n+        DMNContext context = DMNJSONUtils.ctx(model, event.getInputContext());\n+        return type == EVALUATE_DECISION_SERVICE\n+                ? model.evaluateDecisionService(context, event.getDecisionServiceName())\n+                : model.evaluateAll(context);\n+    }\n+\n+    private DecisionResponseEvent buildDecisionResponseEventFromResult(DecisionRequestEvent event, DMNResult result) {\n+        String executionId = DecisionExecutionIdUtils.get(result.getContext());\n+        return new DecisionResponseEvent(\n+                executionId,\n+                new org.kie.kogito.dmn.rest.DMNResult(event.getModelNamespace(), event.getModelName(), result)\n+        );\n+    }\n+\n+    private Optional<CloudEvent> buildResponseCloudEvent(EvaluationContext ctx) {\n+        URI source = buildResponseCloudEventSource(ctx);\n+        String subject = buildResponseCloudEventSubject(ctx);\n+        return CloudEventUtils.build(UUID.randomUUID().toString(), source, subject, ctx.response, DecisionResponseEvent.class);\n+    }\n+\n+    private URI buildResponseCloudEventSource(EvaluationContext ctx) {\n+        if (ctx.requestType == EVALUATE_ALL) {\n+            return CloudEventUtils.buildDecisionSource(config.getServiceUrl(), ctx.request.getModelName());\n+        }\n+        if (ctx.requestType == EVALUATE_DECISION_SERVICE) {\n+            return CloudEventUtils.buildDecisionSource(config.getServiceUrl(), ctx.request.getModelName(), ctx.request.getDecisionServiceName());\n+        }\n+        return CloudEventUtils.buildDecisionSource(config.getServiceUrl());\n+    }\n+\n+    private String buildResponseCloudEventSubject(EvaluationContext ctx) {\n+        try {\n+            return MAPPER.writeValueAsString(\n+                    new DecisionResponseCloudEventSubject(\n+                            ctx.requestCloudEvent.getId(),\n+                            ctx.requestCloudEvent.getSource().toString()\n+                    )\n+            );\n+        } catch (JsonProcessingException e) {\n+            return null;", "originalCommit": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0MDkxOA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r555240918", "bodyText": "What about directly inject DecisionModels instead of Application?", "author": "danielezonca", "createdAt": "2021-01-11T18:05:50Z", "path": "addons/events/event-driven-decisions/event-driven-decisions-common/src/main/java/org/kie/kogito/eventdriven/decision/EventDrivenDecisionController.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.eventdriven.decision;\n+\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.cloudevents.CloudEvent;\n+import org.kie.dmn.api.core.DMNContext;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.cloudevents.CloudEventUtils;\n+import org.kie.kogito.conf.ConfigBean;\n+import org.kie.kogito.decision.DecisionExecutionIdUtils;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.decision.DecisionModels;\n+import org.kie.kogito.dmn.rest.DMNJSONUtils;\n+import org.kie.kogito.event.CloudEventEmitter;\n+import org.kie.kogito.event.CloudEventReceiver;\n+\n+import static org.kie.kogito.eventdriven.decision.DecisionRequestType.EVALUATE_ALL;\n+import static org.kie.kogito.eventdriven.decision.DecisionRequestType.EVALUATE_DECISION_SERVICE;\n+\n+public class EventDrivenDecisionController {\n+\n+    private static final String VALID_REQUEST_EVENT_TYPE = DecisionRequestEvent.class.getName();\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    private DecisionModels decisionModels;\n+    private ConfigBean config;\n+    private CloudEventEmitter eventEmitter;\n+    private CloudEventReceiver eventReceiver;\n+\n+    protected EventDrivenDecisionController() {\n+    }\n+\n+    protected EventDrivenDecisionController(Application application, ConfigBean config, CloudEventEmitter eventEmitter, CloudEventReceiver eventReceiver) {\n+        this.decisionModels = application.get(DecisionModels.class);", "originalCommit": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQwNjU0OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r556406549", "bodyText": "Good idea. Done \ud83d\udc4d", "author": "kostola", "createdAt": "2021-01-13T10:12:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0MDkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0MTA4Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r555241086", "bodyText": "Same as above", "author": "danielezonca", "createdAt": "2021-01-11T18:06:05Z", "path": "addons/events/event-driven-decisions/event-driven-decisions-common/src/main/java/org/kie/kogito/eventdriven/decision/EventDrivenDecisionController.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.eventdriven.decision;\n+\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.cloudevents.CloudEvent;\n+import org.kie.dmn.api.core.DMNContext;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.cloudevents.CloudEventUtils;\n+import org.kie.kogito.conf.ConfigBean;\n+import org.kie.kogito.decision.DecisionExecutionIdUtils;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.decision.DecisionModels;\n+import org.kie.kogito.dmn.rest.DMNJSONUtils;\n+import org.kie.kogito.event.CloudEventEmitter;\n+import org.kie.kogito.event.CloudEventReceiver;\n+\n+import static org.kie.kogito.eventdriven.decision.DecisionRequestType.EVALUATE_ALL;\n+import static org.kie.kogito.eventdriven.decision.DecisionRequestType.EVALUATE_DECISION_SERVICE;\n+\n+public class EventDrivenDecisionController {\n+\n+    private static final String VALID_REQUEST_EVENT_TYPE = DecisionRequestEvent.class.getName();\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    private DecisionModels decisionModels;\n+    private ConfigBean config;\n+    private CloudEventEmitter eventEmitter;\n+    private CloudEventReceiver eventReceiver;\n+\n+    protected EventDrivenDecisionController() {\n+    }\n+\n+    protected EventDrivenDecisionController(Application application, ConfigBean config, CloudEventEmitter eventEmitter, CloudEventReceiver eventReceiver) {\n+        this.decisionModels = application.get(DecisionModels.class);\n+        this.config = config;\n+        this.eventEmitter = eventEmitter;\n+        this.eventReceiver = eventReceiver;\n+    }\n+\n+    protected void setup(Application application, ConfigBean config, CloudEventEmitter eventEmitter, CloudEventReceiver eventReceiver) {\n+        this.decisionModels = application.get(DecisionModels.class);", "originalCommit": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQwNjY0MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r556406640", "bodyText": "Good idea. Done \ud83d\udc4d", "author": "kostola", "createdAt": "2021-01-13T10:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0MTA4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0MjY3Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r555242672", "bodyText": "Why Optional<CloudEvent>? After the evaluation we should be sure to emit the event", "author": "danielezonca", "createdAt": "2021-01-11T18:09:09Z", "path": "addons/events/event-driven-decisions/event-driven-decisions-common/src/main/java/org/kie/kogito/eventdriven/decision/EventDrivenDecisionController.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.eventdriven.decision;\n+\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.cloudevents.CloudEvent;\n+import org.kie.dmn.api.core.DMNContext;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.cloudevents.CloudEventUtils;\n+import org.kie.kogito.conf.ConfigBean;\n+import org.kie.kogito.decision.DecisionExecutionIdUtils;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.decision.DecisionModels;\n+import org.kie.kogito.dmn.rest.DMNJSONUtils;\n+import org.kie.kogito.event.CloudEventEmitter;\n+import org.kie.kogito.event.CloudEventReceiver;\n+\n+import static org.kie.kogito.eventdriven.decision.DecisionRequestType.EVALUATE_ALL;\n+import static org.kie.kogito.eventdriven.decision.DecisionRequestType.EVALUATE_DECISION_SERVICE;\n+\n+public class EventDrivenDecisionController {\n+\n+    private static final String VALID_REQUEST_EVENT_TYPE = DecisionRequestEvent.class.getName();\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    private DecisionModels decisionModels;\n+    private ConfigBean config;\n+    private CloudEventEmitter eventEmitter;\n+    private CloudEventReceiver eventReceiver;\n+\n+    protected EventDrivenDecisionController() {\n+    }\n+\n+    protected EventDrivenDecisionController(Application application, ConfigBean config, CloudEventEmitter eventEmitter, CloudEventReceiver eventReceiver) {\n+        this.decisionModels = application.get(DecisionModels.class);\n+        this.config = config;\n+        this.eventEmitter = eventEmitter;\n+        this.eventReceiver = eventReceiver;\n+    }\n+\n+    protected void setup(Application application, ConfigBean config, CloudEventEmitter eventEmitter, CloudEventReceiver eventReceiver) {\n+        this.decisionModels = application.get(DecisionModels.class);\n+        this.config = config;\n+        this.eventEmitter = eventEmitter;\n+        this.eventReceiver = eventReceiver;\n+        setup();\n+    }\n+\n+    protected void setup() {\n+        eventReceiver.subscribe(this::handleEvent);\n+    }\n+\n+    void handleEvent(String event) {\n+        CloudEventUtils.decode(event)\n+                .filter(e -> VALID_REQUEST_EVENT_TYPE.equals(e.getType()))\n+                .ifPresent(this::handleRequest);\n+    }\n+\n+    private void handleRequest(CloudEvent event) {\n+        CloudEventUtils.decodeData(event, DecisionRequestEvent.class)\n+                .map(data -> new EvaluationContext(event, data))\n+                .map(this::processRequest)\n+                .flatMap(this::buildResponseCloudEvent)\n+                .flatMap(CloudEventUtils::encode)\n+                .ifPresent(eventEmitter::emit);\n+    }\n+\n+    private EvaluationContext processRequest(EvaluationContext ctx) {\n+        DecisionRequestEvent request = ctx.request;\n+\n+        DecisionRequestType type = getRequestType(request);\n+        ctx.requestType = type;\n+\n+        ctx.response = type == DecisionRequestType.INVALID\n+                ? new DecisionResponseEvent(DecisionResponseStatus.BAD_REQUEST, \"Malformed request event\")\n+                : getDecisionModel(request)\n+                        .map(model -> evaluateRequest(request, type, model))\n+                        .map(result -> buildDecisionResponseEventFromResult(request, result))\n+                        .orElseGet(() -> new DecisionResponseEvent(DecisionResponseStatus.NOT_FOUND, \"Model not found\"));\n+\n+        return ctx;\n+    }\n+\n+    private DecisionRequestType getRequestType(DecisionRequestEvent event) {\n+        if (event != null && event.getModelName() != null && event.getModelNamespace() != null && event.getInputContext() != null) {\n+            return event.getDecisionServiceName() == null\n+                    ? EVALUATE_ALL\n+                    : EVALUATE_DECISION_SERVICE;\n+        }\n+        return DecisionRequestType.INVALID;\n+    }\n+\n+    private Optional<DecisionModel> getDecisionModel(DecisionRequestEvent event) {\n+        try {\n+            return Optional.ofNullable(decisionModels.getDecisionModel(event.getModelNamespace(), event.getModelName()));\n+        } catch (IllegalStateException e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private DMNResult evaluateRequest(DecisionRequestEvent event, DecisionRequestType type, DecisionModel model) {\n+        DMNContext context = DMNJSONUtils.ctx(model, event.getInputContext());\n+        return type == EVALUATE_DECISION_SERVICE\n+                ? model.evaluateDecisionService(context, event.getDecisionServiceName())\n+                : model.evaluateAll(context);\n+    }\n+\n+    private DecisionResponseEvent buildDecisionResponseEventFromResult(DecisionRequestEvent event, DMNResult result) {\n+        String executionId = DecisionExecutionIdUtils.get(result.getContext());\n+        return new DecisionResponseEvent(\n+                executionId,\n+                new org.kie.kogito.dmn.rest.DMNResult(event.getModelNamespace(), event.getModelName(), result)\n+        );\n+    }\n+\n+    private Optional<CloudEvent> buildResponseCloudEvent(EvaluationContext ctx) {", "originalCommit": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQ0NjA3Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r556446076", "bodyText": "At this point the response CloudEvent should be built always except for unexpected errors. In this case, with the same logic described in the first part of this comment, the CloudEventUtils::build method would log the message. Shall we add a dedicated log here?", "author": "kostola", "createdAt": "2021-01-13T11:18:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0MjY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0MzU2Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r555243562", "bodyText": "We should not lose messages especially after processing it. What about a log at least?\nBtw it should be nice to ack the request only if we are able to process it (probably this change requires a different PR). Wdyt?", "author": "danielezonca", "createdAt": "2021-01-11T18:10:49Z", "path": "addons/events/event-driven-decisions/event-driven-decisions-common/src/main/java/org/kie/kogito/eventdriven/decision/EventDrivenDecisionController.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.eventdriven.decision;\n+\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.cloudevents.CloudEvent;\n+import org.kie.dmn.api.core.DMNContext;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.cloudevents.CloudEventUtils;\n+import org.kie.kogito.conf.ConfigBean;\n+import org.kie.kogito.decision.DecisionExecutionIdUtils;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.decision.DecisionModels;\n+import org.kie.kogito.dmn.rest.DMNJSONUtils;\n+import org.kie.kogito.event.CloudEventEmitter;\n+import org.kie.kogito.event.CloudEventReceiver;\n+\n+import static org.kie.kogito.eventdriven.decision.DecisionRequestType.EVALUATE_ALL;\n+import static org.kie.kogito.eventdriven.decision.DecisionRequestType.EVALUATE_DECISION_SERVICE;\n+\n+public class EventDrivenDecisionController {\n+\n+    private static final String VALID_REQUEST_EVENT_TYPE = DecisionRequestEvent.class.getName();\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    private DecisionModels decisionModels;\n+    private ConfigBean config;\n+    private CloudEventEmitter eventEmitter;\n+    private CloudEventReceiver eventReceiver;\n+\n+    protected EventDrivenDecisionController() {\n+    }\n+\n+    protected EventDrivenDecisionController(Application application, ConfigBean config, CloudEventEmitter eventEmitter, CloudEventReceiver eventReceiver) {\n+        this.decisionModels = application.get(DecisionModels.class);\n+        this.config = config;\n+        this.eventEmitter = eventEmitter;\n+        this.eventReceiver = eventReceiver;\n+    }\n+\n+    protected void setup(Application application, ConfigBean config, CloudEventEmitter eventEmitter, CloudEventReceiver eventReceiver) {\n+        this.decisionModels = application.get(DecisionModels.class);\n+        this.config = config;\n+        this.eventEmitter = eventEmitter;\n+        this.eventReceiver = eventReceiver;\n+        setup();\n+    }\n+\n+    protected void setup() {\n+        eventReceiver.subscribe(this::handleEvent);\n+    }\n+\n+    void handleEvent(String event) {\n+        CloudEventUtils.decode(event)\n+                .filter(e -> VALID_REQUEST_EVENT_TYPE.equals(e.getType()))\n+                .ifPresent(this::handleRequest);\n+    }\n+\n+    private void handleRequest(CloudEvent event) {\n+        CloudEventUtils.decodeData(event, DecisionRequestEvent.class)\n+                .map(data -> new EvaluationContext(event, data))\n+                .map(this::processRequest)\n+                .flatMap(this::buildResponseCloudEvent)\n+                .flatMap(CloudEventUtils::encode)", "originalCommit": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQ0Mzg5Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r556443892", "bodyText": "What about a log at least\n\nThe CloudEventUtils::encode method already logs an error if it can't encode the data. Should we double log in case the logic in that class is changed?\n\nBtw it should be nice to ack the request only if we are able to process it\n\nYes I totally agree. Imho we should open a new PR to harden the error handling.", "author": "kostola", "createdAt": "2021-01-13T11:14:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0MzU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0NDY2MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r555244661", "bodyText": "You can inject DecisionModels directly", "author": "danielezonca", "createdAt": "2021-01-11T18:12:45Z", "path": "addons/events/event-driven-decisions/event-driven-decisions-quarkus-addon/src/main/java/org/kie/kogito/eventdriven/decision/QuarkusEventDrivenDecisionController.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.eventdriven.decision;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+\n+import io.quarkus.runtime.Startup;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.conf.ConfigBean;\n+import org.kie.kogito.event.CloudEventEmitter;\n+import org.kie.kogito.event.CloudEventReceiver;\n+\n+@Startup\n+public class QuarkusEventDrivenDecisionController extends EventDrivenDecisionController {\n+\n+    @Inject\n+    Application application;", "originalCommit": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQwNjcyOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r556406729", "bodyText": "Good idea. Done \ud83d\udc4d", "author": "kostola", "createdAt": "2021-01-13T10:12:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0NDY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0NjE2MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r555246160", "bodyText": "As far as I remember we got some problem in the past with @Startup bean because of uncompleted kafka initialization and we had to observe StartupEvent to solve (see here)\n@r00ta\nCan you please double check if I'm right?", "author": "danielezonca", "createdAt": "2021-01-11T18:15:19Z", "path": "addons/events/event-driven-decisions/event-driven-decisions-quarkus-addon/src/main/java/org/kie/kogito/eventdriven/decision/QuarkusEventDrivenDecisionController.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.eventdriven.decision;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+\n+import io.quarkus.runtime.Startup;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.conf.ConfigBean;\n+import org.kie.kogito.event.CloudEventEmitter;\n+import org.kie.kogito.event.CloudEventReceiver;\n+\n+@Startup", "originalCommit": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgxMjk5MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r559812990", "bodyText": "I had a look and it should be fine. Btw the issue I opened to Quarkus has been fixed in SmallRye Reactive Messaging 2.6.0  quarkusio/quarkus#12820 (I didn't check if we have the fix in the version we are using, but we should not have any issue here)", "author": "r00ta", "createdAt": "2021-01-18T22:05:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0NjE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDk5NDQ5MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r560994490", "bodyText": "Yes Kogito is now using Quarkus 1.11.0.Final, which contains SmallRye Reactive Messaging 2.7.0 \ud83d\udc4d", "author": "kostola", "createdAt": "2021-01-20T14:19:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0NjE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0NjcwOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r555246709", "bodyText": "You can inject DecisionModels directly", "author": "danielezonca", "createdAt": "2021-01-11T18:16:17Z", "path": "addons/events/event-driven-decisions/event-driven-decisions-springboot-addon/src/main/java/org/kie/kogito/eventdriven/decision/SpringBootEventDrivenDecisionController.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.eventdriven.decision;\n+\n+import javax.annotation.PostConstruct;\n+\n+import org.kie.kogito.Application;\n+import org.kie.kogito.conf.ConfigBean;\n+import org.kie.kogito.event.CloudEventEmitter;\n+import org.kie.kogito.event.CloudEventReceiver;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class SpringBootEventDrivenDecisionController extends EventDrivenDecisionController {\n+\n+    @Autowired\n+    public SpringBootEventDrivenDecisionController(Application application, ConfigBean config, CloudEventEmitter eventEmitter, CloudEventReceiver eventReceiver) {", "originalCommit": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQwNjc4Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r556406787", "bodyText": "Good idea. Done \ud83d\udc4d", "author": "kostola", "createdAt": "2021-01-13T10:12:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0NjcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDAwODY2OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r554008668", "bodyText": "Can you be more specific in the description of this exception.", "author": "jiripetrlik", "createdAt": "2021-01-08T15:25:08Z", "path": "addons/cloudevents/cloudevents-utils/src/main/java/org/kie/kogito/cloudevents/CloudEventUtils.java", "diffHunk": "@@ -102,8 +156,13 @@\n         public static ObjectMapper mapper() {\n             return OBJECT_MAPPER;\n         }\n+\n+        private Mapper() {\n+            throw new IllegalStateException(\"Utility class\");", "originalCommit": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQwNjg5MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r556406891", "bodyText": "Done \ud83d\udc4d", "author": "kostola", "createdAt": "2021-01-13T10:12:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDAwODY2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDAwODczNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r554008737", "bodyText": "Can you be more specific in the description of this exception.", "author": "jiripetrlik", "createdAt": "2021-01-08T15:25:16Z", "path": "addons/cloudevents/cloudevents-utils/src/main/java/org/kie/kogito/cloudevents/CloudEventUtils.java", "diffHunk": "@@ -102,8 +156,13 @@\n         public static ObjectMapper mapper() {\n             return OBJECT_MAPPER;\n         }\n+\n+        private Mapper() {\n+            throw new IllegalStateException(\"Utility class\");\n+        }\n     }\n \n     private CloudEventUtils() {\n+        throw new IllegalStateException(\"Utility class\");", "originalCommit": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQwNjk0MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r556406940", "bodyText": "Done \ud83d\udc4d", "author": "kostola", "createdAt": "2021-01-13T10:12:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDAwODczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTc2MjAyNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r555762026", "bodyText": "Can we log something here?", "author": "jiripetrlik", "createdAt": "2021-01-12T13:17:09Z", "path": "addons/events/event-driven-decisions/event-driven-decisions-common/src/main/java/org/kie/kogito/eventdriven/decision/EventDrivenDecisionController.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.eventdriven.decision;\n+\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.cloudevents.CloudEvent;\n+import org.kie.dmn.api.core.DMNContext;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.cloudevents.CloudEventUtils;\n+import org.kie.kogito.conf.ConfigBean;\n+import org.kie.kogito.decision.DecisionExecutionIdUtils;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.decision.DecisionModels;\n+import org.kie.kogito.dmn.rest.DMNJSONUtils;\n+import org.kie.kogito.event.CloudEventEmitter;\n+import org.kie.kogito.event.CloudEventReceiver;\n+\n+import static org.kie.kogito.eventdriven.decision.DecisionRequestType.EVALUATE_ALL;\n+import static org.kie.kogito.eventdriven.decision.DecisionRequestType.EVALUATE_DECISION_SERVICE;\n+\n+public class EventDrivenDecisionController {\n+\n+    private static final String VALID_REQUEST_EVENT_TYPE = DecisionRequestEvent.class.getName();\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    private DecisionModels decisionModels;\n+    private ConfigBean config;\n+    private CloudEventEmitter eventEmitter;\n+    private CloudEventReceiver eventReceiver;\n+\n+    protected EventDrivenDecisionController() {\n+    }\n+\n+    protected EventDrivenDecisionController(Application application, ConfigBean config, CloudEventEmitter eventEmitter, CloudEventReceiver eventReceiver) {\n+        this.decisionModels = application.get(DecisionModels.class);\n+        this.config = config;\n+        this.eventEmitter = eventEmitter;\n+        this.eventReceiver = eventReceiver;\n+    }\n+\n+    protected void setup(Application application, ConfigBean config, CloudEventEmitter eventEmitter, CloudEventReceiver eventReceiver) {\n+        this.decisionModels = application.get(DecisionModels.class);\n+        this.config = config;\n+        this.eventEmitter = eventEmitter;\n+        this.eventReceiver = eventReceiver;\n+        setup();\n+    }\n+\n+    protected void setup() {\n+        eventReceiver.subscribe(this::handleEvent);\n+    }\n+\n+    void handleEvent(String event) {\n+        CloudEventUtils.decode(event)\n+                .filter(e -> VALID_REQUEST_EVENT_TYPE.equals(e.getType()))\n+                .ifPresent(this::handleRequest);\n+    }\n+\n+    private void handleRequest(CloudEvent event) {\n+        CloudEventUtils.decodeData(event, DecisionRequestEvent.class)\n+                .map(data -> new EvaluationContext(event, data))\n+                .map(this::processRequest)\n+                .flatMap(this::buildResponseCloudEvent)\n+                .flatMap(CloudEventUtils::encode)\n+                .ifPresent(eventEmitter::emit);\n+    }\n+\n+    private EvaluationContext processRequest(EvaluationContext ctx) {\n+        DecisionRequestEvent request = ctx.request;\n+\n+        DecisionRequestType type = getRequestType(request);\n+        ctx.requestType = type;\n+\n+        ctx.response = type == DecisionRequestType.INVALID\n+                ? new DecisionResponseEvent(DecisionResponseStatus.BAD_REQUEST, \"Malformed request event\")\n+                : getDecisionModel(request)\n+                        .map(model -> evaluateRequest(request, type, model))\n+                        .map(result -> buildDecisionResponseEventFromResult(request, result))\n+                        .orElseGet(() -> new DecisionResponseEvent(DecisionResponseStatus.NOT_FOUND, \"Model not found\"));\n+\n+        return ctx;\n+    }\n+\n+    private DecisionRequestType getRequestType(DecisionRequestEvent event) {\n+        if (event != null && event.getModelName() != null && event.getModelNamespace() != null && event.getInputContext() != null) {\n+            return event.getDecisionServiceName() == null\n+                    ? EVALUATE_ALL\n+                    : EVALUATE_DECISION_SERVICE;\n+        }\n+        return DecisionRequestType.INVALID;\n+    }\n+\n+    private Optional<DecisionModel> getDecisionModel(DecisionRequestEvent event) {\n+        try {\n+            return Optional.ofNullable(decisionModels.getDecisionModel(event.getModelNamespace(), event.getModelName()));\n+        } catch (IllegalStateException e) {\n+            return Optional.empty();", "originalCommit": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTc2NTkyNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r555765926", "bodyText": "Is it intentional that this method has the same implementation as \"getEvaluateAllContextForError\"?", "author": "jiripetrlik", "createdAt": "2021-01-12T13:23:45Z", "path": "kogito-test-utils/src/main/java/org/kie/kogito/decision/DecisionTestUtils.java", "diffHunk": "@@ -62,55 +53,53 @@ public static DMNModel createDMNModel() {\n     }\n \n     public static Map<String, Object> getEvaluateAllContext() {\n-        return new HashMap<String, Object>() {{\n-            put(\"Driver\", getDriver(25, 10));\n-            put(\"Violation\", getViolation(\"speed\", 115, 100));\n-        }};\n+        HashMap<String, Object> map = new HashMap<>();\n+        map.put(\"Driver\", getDriver(25, 10));\n+        map.put(\"Violation\", getViolation(\"speed\", 115, 100));\n+        return map;\n     }\n \n     public static Map<String, Object> getEvaluateAllContextForWarning() {\n-        return new HashMap<String, Object>() {{\n-            put(\"Driver\", getDriver(25, 10));\n-            put(\"Violation\", getViolation(\"speed\", 95, 100));\n-        }};\n+        HashMap<String, Object> map = new HashMap<>();\n+        map.put(\"Driver\", getDriver(25, 10));\n+        map.put(\"Violation\", getViolation(\"speed\", 95, 100));\n+        return map;\n     }\n \n     public static Map<String, Object> getEvaluateAllContextForError() {\n-        return new HashMap<String, Object>() {{\n-            put(\"Violation\", getViolation(\"speed\", 115, 100));\n-        }};\n+        HashMap<String, Object> map = new HashMap<>();\n+        map.put(\"Violation\", getViolation(\"speed\", 115, 100));\n+        return map;\n     }\n \n     public static Map<String, Object> getEvaluateDecisionServiceContext() {", "originalCommit": "3de94edeba04287d8dec2c9a88e5733541d06c8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQwNzk5NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r556407995", "bodyText": "Yes because they're used in two different test cases and I'd like to let anyone who reads this code to clearly understand which input triggers the specific behavior. What do you think?", "author": "kostola", "createdAt": "2021-01-13T10:14:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTc2NTkyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTkxODIzMg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r561918232", "bodyText": "Resolving this after receiving your approval \ud83d\udc4d", "author": "kostola", "createdAt": "2021-01-21T14:22:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTc2NTkyNg=="}], "type": "inlineReview"}, {"oid": "a281c2ccce671ad1babee189c9334796a3067790", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a281c2ccce671ad1babee189c9334796a3067790", "message": "KOGITO-3936: improve CloudEventUtilsTest", "committedDate": "2021-01-12T14:48:31Z", "type": "commit"}, {"oid": "25ee677f58e3df9864868268fd98b8594860215e", "url": "https://github.com/kiegroup/kogito-runtimes/commit/25ee677f58e3df9864868268fd98b8594860215e", "message": "KOGITO-3936: fix mockito-inline in cloudevents-utils pom", "committedDate": "2021-01-13T08:28:11Z", "type": "commit"}, {"oid": "72b93a5af2895ab54ca28fef7a4694a69736246f", "url": "https://github.com/kiegroup/kogito-runtimes/commit/72b93a5af2895ab54ca28fef7a4694a69736246f", "message": "KOGITO-3936: add isValid method to DecisionRequestEvent", "committedDate": "2021-01-13T08:30:55Z", "type": "commit"}, {"oid": "2b66cf1601ee909f60dcc892a11d8bc1504977c9", "url": "https://github.com/kiegroup/kogito-runtimes/commit/2b66cf1601ee909f60dcc892a11d8bc1504977c9", "message": "KOGITO-3936: minor fix in CloudEventUtils", "committedDate": "2021-01-13T09:59:39Z", "type": "commit"}, {"oid": "719389303a41127d381dbc23f68022bc3bb3d640", "url": "https://github.com/kiegroup/kogito-runtimes/commit/719389303a41127d381dbc23f68022bc3bb3d640", "message": "KOGITO-3936: direct injection of DecisionModels bean", "committedDate": "2021-01-13T10:01:45Z", "type": "commit"}, {"oid": "303ab1071c5ad7600d2e809af920d68c2970ebcf", "url": "https://github.com/kiegroup/kogito-runtimes/commit/303ab1071c5ad7600d2e809af920d68c2970ebcf", "message": "KOGITO-3936: refactor EventDrivenDecisionController.processRequest and add logs", "committedDate": "2021-01-13T11:04:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU0NjU5MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r556546590", "bodyText": "Wouldn't it be better for management, tracing and monitoring purposes that the DMNResult is the object returned and any other attributes are added as CloudEvent metadata?\nIn case of error, the error message should be the event content itself as I assume the result will be empty.", "author": "ruromero", "createdAt": "2021-01-13T14:10:43Z", "path": "addons/events/event-driven-decisions/event-driven-decisions-common/src/main/java/org/kie/kogito/eventdriven/decision/DecisionResponseEvent.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.eventdriven.decision;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import org.kie.kogito.dmn.rest.DMNResult;\n+\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_EMPTY;\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL;\n+import static com.fasterxml.jackson.annotation.JsonProperty.Access.READ_ONLY;\n+\n+public class DecisionResponseEvent {", "originalCommit": "303ab1071c5ad7600d2e809af920d68c2970ebcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDk5NDg2NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r560994864", "bodyText": "The new version behaves like you described \ud83d\udc4d", "author": "kostola", "createdAt": "2021-01-20T14:19:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU0NjU5MA=="}], "type": "inlineReview"}, {"oid": "e3f984aff40529540e635148c62330c0a22742f4", "url": "https://github.com/kiegroup/kogito-runtimes/commit/e3f984aff40529540e635148c62330c0a22742f4", "message": "KOGITO-3936: clean event-driven-decisions-quarkus-addon/pom.xml", "committedDate": "2021-01-19T10:21:18Z", "type": "commit"}, {"oid": "3caa4fd48147af3d7f73ab6411614589d50f9c1d", "url": "https://github.com/kiegroup/kogito-runtimes/commit/3caa4fd48147af3d7f73ab6411614589d50f9c1d", "message": "KOGITO-3936: add cloudevents kogito extension", "committedDate": "2021-01-19T13:32:53Z", "type": "commit"}, {"oid": "c7ab1af7fc1a260ba08c2fbbab1db8f9629682b2", "url": "https://github.com/kiegroup/kogito-runtimes/commit/c7ab1af7fc1a260ba08c2fbbab1db8f9629682b2", "message": "KOGITO-3936: refactor cloudevent structure using kogito extension", "committedDate": "2021-01-20T10:06:15Z", "type": "commit"}, {"oid": "193a42a396ffab0620673e442132d1540686790c", "url": "https://github.com/kiegroup/kogito-runtimes/commit/193a42a396ffab0620673e442132d1540686790c", "message": "KOGITO-3936: merge branch master", "committedDate": "2021-01-20T10:08:13Z", "type": "commit"}, {"oid": "9bed958ef0c50fc4efcd1bd209e223d4c662c8b4", "url": "https://github.com/kiegroup/kogito-runtimes/commit/9bed958ef0c50fc4efcd1bd209e223d4c662c8b4", "message": "KOGITO-3936: return only dmn context by default for successful evaluations", "committedDate": "2021-01-20T10:22:56Z", "type": "commit"}, {"oid": "769880aafc9306901c7a1e0ac6a9993352e13b32", "url": "https://github.com/kiegroup/kogito-runtimes/commit/769880aafc9306901c7a1e0ac6a9993352e13b32", "message": "KOGITO-3936: fix CloudEventUtilsTest", "committedDate": "2021-01-20T11:04:42Z", "type": "commit"}, {"oid": "b8d0cf6514c2f84c01fbc688a2229545e45bad05", "url": "https://github.com/kiegroup/kogito-runtimes/commit/b8d0cf6514c2f84c01fbc688a2229545e45bad05", "message": "KOGITO-3936: reduce code smells", "committedDate": "2021-01-20T14:34:14Z", "type": "commit"}, {"oid": "dd23383d2021a80192a7395bd6851e4ad0269919", "url": "https://github.com/kiegroup/kogito-runtimes/commit/dd23383d2021a80192a7395bd6851e4ad0269919", "message": "KOGITO-3936: add kogitodmnfullresult and kogitodmnfilteredctx to Kogito extension", "committedDate": "2021-01-20T16:03:01Z", "type": "commit"}, {"oid": "1b70c08f146163d9e963b559ab9535f777f06b89", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1b70c08f146163d9e963b559ab9535f777f06b89", "message": "KOGITO-3936: use Boolean fields in Kogito extension", "committedDate": "2021-01-20T16:14:17Z", "type": "commit"}, {"oid": "a3f531ce2170983b8a7287e6cfbb4ac8f2e289a1", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a3f531ce2170983b8a7287e6cfbb4ac8f2e289a1", "message": "KOGITO-3936: support kogitodmnfullresult and kogitodmnfilteredctx in addon", "committedDate": "2021-01-20T16:59:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE0OTMwNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r561149305", "bodyText": "Can you use the opposite condition to fail fast instead of this \ud83c\udf84 ? :)", "author": "danielezonca", "createdAt": "2021-01-20T17:35:32Z", "path": "addons/events/event-driven-decisions/event-driven-decisions-common/src/test/java/org/kie/kogito/eventdriven/decision/EventDrivenDecisionControllerTest.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.eventdriven.decision;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.CloudEvent;\n+import io.cloudevents.core.provider.ExtensionProvider;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.kie.dmn.api.core.DMNRuntime;\n+import org.kie.kogito.cloudevents.CloudEventUtils;\n+import org.kie.kogito.cloudevents.extension.KogitoExtension;\n+import org.kie.kogito.conf.ConfigBean;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.decision.DecisionModels;\n+import org.kie.kogito.decision.DecisionTestUtils;\n+import org.kie.kogito.dmn.DmnDecisionModel;\n+import org.kie.kogito.event.CloudEventEmitter;\n+import org.kie.kogito.event.CloudEventReceiver;\n+import org.mockito.ArgumentCaptor;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.kogito.decision.DecisionTestUtils.DECISION_SERVICE_NODE_NAME;\n+import static org.kie.kogito.decision.DecisionTestUtils.MODEL_NAME;\n+import static org.kie.kogito.decision.DecisionTestUtils.MODEL_NAMESPACE;\n+import static org.kie.kogito.eventdriven.decision.EventDrivenDecisionController.REQUEST_EVENT_TYPE;\n+import static org.kie.kogito.eventdriven.decision.EventDrivenDecisionController.RESPONSE_ERROR_EVENT_TYPE;\n+import static org.kie.kogito.eventdriven.decision.EventDrivenDecisionController.RESPONSE_EVENT_TYPE;\n+import static org.kie.kogito.eventdriven.decision.EventDrivenDecisionController.RESPONSE_FULL_EVENT_TYPE;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.ArgumentMatchers.notNull;\n+import static org.mockito.Mockito.clearInvocations;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.reset;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+class EventDrivenDecisionControllerTest {\n+\n+    private static final String MODEL_NAME_PLACEHOLDER = \"%%MODEL_NAME%%\";\n+    private static final String MODEL_NAMESPACE_PLACEHOLDER = \"%%MODEL_NAMESPACE%%\";\n+    private static final String EVALUATE_DECISION_PLACEHOLDER = \"%%EVALUATE_DECISION%%\";\n+    private static final String FULL_RESULT_PLACEHOLDER = \"%%FULL_RESULT%%\";\n+    private static final String FILTERED_CTX_PLACEHOLDER = \"%%FILTERED_CTX%%\";\n+    private static final String DATA_PLACEHOLDER = \"%%DATA%%\";\n+\n+    private static final String CLOUDEVENT_ID = \"a89b61a2-5644-487a-8a86-144855c5dce8\";\n+    private static final String CLOUDEVENT_SOURCE = \"SomeEventSource\";\n+    private static final String CLOUDEVENT_SUBJECT = \"TheSubject\";\n+    private static final String CLOUDEVENT_TEMPLATE = \"\" +\n+            \"{\\n\" +\n+            \"    \\\"specversion\\\": \\\"1.0\\\",\\n\" +\n+            \"    \\\"id\\\": \\\"\" + CLOUDEVENT_ID + \"\\\",\\n\" +\n+            \"    \\\"source\\\": \\\"\" + CLOUDEVENT_SOURCE + \"\\\",\\n\" +\n+            \"    \\\"type\\\": \\\"\" + REQUEST_EVENT_TYPE + \"\\\",\\n\" +\n+            \"    \\\"subject\\\": \\\"\" + CLOUDEVENT_SUBJECT + \"\\\",\\n\" +\n+            \"    \\\"\" + KogitoExtension.KOGITO_DMN_MODEL_NAME + \"\\\": \" + MODEL_NAME_PLACEHOLDER + \",\\n\" +\n+            \"    \\\"\" + KogitoExtension.KOGITO_DMN_MODEL_NAMESPACE + \"\\\": \" + MODEL_NAMESPACE_PLACEHOLDER + \",\\n\" +\n+            \"    \\\"\" + KogitoExtension.KOGITO_DMN_EVALUATE_DECISION + \"\\\": \" + EVALUATE_DECISION_PLACEHOLDER + \",\\n\" +\n+            \"    \\\"\" + KogitoExtension.KOGITO_DMN_FULL_RESULT + \"\\\": \" + FULL_RESULT_PLACEHOLDER + \",\\n\" +\n+            \"    \\\"\" + KogitoExtension.KOGITO_DMN_FILTERED_CTX + \"\\\": \" + FILTERED_CTX_PLACEHOLDER + \",\\n\" +\n+            \"    \\\"data\\\": \" + DATA_PLACEHOLDER + \"\\n\" +\n+            \"}\";\n+\n+    private static final String CLOUDEVENT_IGNORED = \"\" +\n+            \"{\\n\" +\n+            \"    \\\"specversion\\\": \\\"1.0\\\",\\n\" +\n+            \"    \\\"id\\\": \\\"55c5dce8-5644-487a-8a86-1448a89b61a2\\\",\\n\" +\n+            \"    \\\"source\\\": \\\"SomeOtherEventSource\\\",\\n\" +\n+            \"    \\\"type\\\": \\\"SomeType\\\",\\n\" +\n+            \"    \\\"data\\\": {}\\n\" +\n+            \"}\";\n+\n+    private static final List<RequestData> REQUEST_DATA_BAD_REQUEST = Stream.of(\n+            new RequestData(null, null, null, null),\n+            new RequestData(\"aName\", null, null, null),\n+            new RequestData(null, \"aNamespace\", null, null),\n+            new RequestData(null, null, null, \"{}\"),\n+            new RequestData(\"aName\", \"aNamespace\", null, null),\n+            new RequestData(\"aName\", null, null, \"{}\"),\n+            new RequestData(null, \"aNamespace\", null, \"{}\")\n+    ).collect(Collectors.toList());\n+\n+    private static final RequestData REQUEST_DATA_MODEL_NOT_FOUND = new RequestData(\"aName\", \"aNamespace\", null, \"{}\");\n+\n+    private static final RequestData REQUEST_DATA_NULL_CONTEXT = new RequestData(MODEL_NAME, MODEL_NAMESPACE, null, null);\n+\n+    private static final RequestData REQUEST_DATA_EVALUATE_ALL = new RequestData(MODEL_NAME, MODEL_NAMESPACE, null, \"\" +\n+            \"{\\n\" +\n+            \"    \\\"Driver\\\": {\\n\" +\n+            \"        \\\"Age\\\": 25,\\n\" +\n+            \"        \\\"Points\\\": 13\\n\" +\n+            \"    },\\n\" +\n+            \"    \\\"Violation\\\": {\\n\" +\n+            \"        \\\"Type\\\": \\\"speed\\\",\\n\" +\n+            \"        \\\"Actual Speed\\\": 115,\\n\" +\n+            \"        \\\"Speed Limit\\\": 100\\n\" +\n+            \"    }\\n\" +\n+            \"}\"\n+    );\n+\n+    private static final RequestData REQUEST_DATA_EVALUATE_DECISION_SERVICE = new RequestData(MODEL_NAME, MODEL_NAMESPACE, DECISION_SERVICE_NODE_NAME, \"\" +\n+            \"{\\n\" +\n+            \"    \\\"Violation\\\": {\\n\" +\n+            \"        \\\"Type\\\": \\\"speed\\\",\\n\" +\n+            \"        \\\"Actual Speed\\\": 115,\\n\" +\n+            \"        \\\"Speed Limit\\\": 100\\n\" +\n+            \"    }\\n\" +\n+            \"}\"\n+    );\n+\n+    private static final String TEST_EXECUTION_ID = \"11ecbb6f-fb25-4597-88c8-ac7976efe078\";\n+\n+    private static DMNRuntime runtime;\n+\n+    private EventDrivenDecisionController controller;\n+    private CloudEventEmitter eventEmitterMock;\n+    private DecisionModel decisionModelSpy;\n+    private DecisionModels decisionModelsMock;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        ExtensionProvider.getInstance().registerExtension(KogitoExtension.class, KogitoExtension::new);\n+        runtime = DecisionTestUtils.createDMNRuntime();\n+    }\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        decisionModelsMock = mock(DecisionModels.class);\n+        eventEmitterMock = mock(CloudEventEmitter.class);\n+\n+        // by default there's no execution id supplier, if needed it will be overridden in the specific test\n+        mockDecisionModel();\n+\n+        controller = new EventDrivenDecisionController(decisionModelsMock, mock(ConfigBean.class), eventEmitterMock, mock(CloudEventReceiver.class));\n+    }\n+\n+    @Test\n+    void testSubscribe() {\n+        DecisionModels decisionModelsMock = mock(DecisionModels.class);\n+        ConfigBean configMock = mock(ConfigBean.class);\n+        CloudEventEmitter eventEmitterMock = mock(CloudEventEmitter.class);\n+        CloudEventReceiver eventReceiverMock = mock(CloudEventReceiver.class);\n+\n+        // option #1: parameters via constructor + parameterless setup\n+        EventDrivenDecisionController controller1 = new EventDrivenDecisionController(decisionModelsMock, configMock, eventEmitterMock, eventReceiverMock);\n+        controller1.setup();\n+        verify(eventReceiverMock).subscribe(any());\n+\n+        reset(eventReceiverMock);\n+\n+        // option #2: parameterless via constructor + parameters via setup (introduced for Quarkus CDI)\n+        EventDrivenDecisionController controller2 = new EventDrivenDecisionController();\n+        controller2.setup(decisionModelsMock, configMock, eventEmitterMock, eventReceiverMock);\n+        verify(eventReceiverMock).subscribe(any());\n+    }\n+\n+    @Test\n+    void testHandleEventWithMalformedInput() {\n+        controller.handleEvent(\"this-is-not-a-cloudevent\");\n+        verify(eventEmitterMock, never()).emit(any());\n+    }\n+\n+    @Test\n+    void testHandleEventWithIgnoredCloudEvent() {\n+        controller.handleEvent(CLOUDEVENT_IGNORED);\n+        verify(eventEmitterMock, never()).emit(any());\n+    }\n+\n+    @Test\n+    void testHandleEventWithValidCloudEventWithNullDataProducingBadRequest() {\n+        testAllErrorCloudEventEmittedCombinations(REQUEST_DATA_NULL_CONTEXT, DecisionResponseError.BAD_REQUEST);\n+    }\n+\n+    @Test\n+    void testHandleEventWithValidCloudEventProducingOkEvaluateAll() {\n+        testAllDefaultAndFullCloudEventEmittedCombinations(REQUEST_DATA_EVALUATE_ALL, (cloudEvent, kogitoExtension, responseEvent) -> {\n+            assertNull(kogitoExtension.getExecutionId());\n+            verify(decisionModelSpy).evaluateAll(notNull());\n+            verify(decisionModelSpy, never()).evaluateDecisionService(any(), any());\n+            clearInvocations(decisionModelSpy);\n+        });\n+    }\n+\n+    @Test\n+    void testHandleEventWithValidCloudEventWithExecutionIdProducingOkEvaluateAll() {\n+        mockDecisionModelWithExecutionIdSupplier();\n+        testAllDefaultAndFullCloudEventEmittedCombinations(REQUEST_DATA_EVALUATE_ALL, (cloudEvent, kogitoExtension, responseEvent) -> {\n+            assertEquals(TEST_EXECUTION_ID, kogitoExtension.getExecutionId());\n+            verify(decisionModelSpy).evaluateAll(notNull());\n+            verify(decisionModelSpy, never()).evaluateDecisionService(any(), any());\n+            clearInvocations(decisionModelSpy);\n+        });\n+    }\n+\n+    @Test\n+    void testHandleEventWithValidCloudEventProducingOkEvaluateDecisionService() {\n+        testAllDefaultAndFullCloudEventEmittedCombinations(REQUEST_DATA_EVALUATE_DECISION_SERVICE, (cloudEvent, kogitoExtension, responseEvent) -> {\n+            assertNull(kogitoExtension.getExecutionId());\n+            verify(decisionModelSpy, never()).evaluateAll(any());\n+            verify(decisionModelSpy).evaluateDecisionService(notNull(), notNull());\n+            clearInvocations(decisionModelSpy);\n+        });\n+    }\n+\n+    @Test\n+    void testHandleEventWithValidCloudEventWithExecutionIdProducingOkEvaluateDecisionService() {\n+        mockDecisionModelWithExecutionIdSupplier();\n+        testAllDefaultAndFullCloudEventEmittedCombinations(REQUEST_DATA_EVALUATE_DECISION_SERVICE, (cloudEvent, kogitoExtension, responseEvent) -> {\n+            assertEquals(TEST_EXECUTION_ID, kogitoExtension.getExecutionId());\n+            verify(decisionModelSpy, never()).evaluateAll(any());\n+            verify(decisionModelSpy).evaluateDecisionService(notNull(), notNull());\n+            clearInvocations(decisionModelSpy);\n+        });\n+    }\n+\n+    @Test\n+    void testHandleEventWithValidCloudEventProducingBadRequest() {\n+        for (RequestData badRequestData : REQUEST_DATA_BAD_REQUEST) {\n+            testAllErrorCloudEventEmittedCombinations(badRequestData, DecisionResponseError.BAD_REQUEST);\n+        }\n+    }\n+\n+    @Test\n+    void testHandleEventWithValidCloudEventWithExecutionIdProducingBadRequest() {\n+        mockDecisionModelWithExecutionIdSupplier();\n+        for (RequestData badRequestData : REQUEST_DATA_BAD_REQUEST) {\n+            testAllErrorCloudEventEmittedCombinations(badRequestData, DecisionResponseError.BAD_REQUEST);\n+        }\n+    }\n+\n+    @Test\n+    void testHandleEventWithValidCloudEventProducingNotFound() {\n+        testAllErrorCloudEventEmittedCombinations(REQUEST_DATA_MODEL_NOT_FOUND, DecisionResponseError.MODEL_NOT_FOUND);\n+    }\n+\n+    @Test\n+    void testHandleEventWithValidCloudEventWithExecutionIdProducingNotFound() {\n+        mockDecisionModelWithExecutionIdSupplier();\n+        testAllErrorCloudEventEmittedCombinations(REQUEST_DATA_MODEL_NOT_FOUND, DecisionResponseError.MODEL_NOT_FOUND);\n+    }\n+\n+    private void assertSubject(CloudEvent event) {\n+        assertNotNull(event.getSubject());\n+        assertEquals(CLOUDEVENT_SUBJECT, event.getSubject());\n+    }\n+\n+    private String cloudEventOkWith(RequestData requestData, Boolean fullResult, Boolean filteredCtx) {\n+        return CLOUDEVENT_TEMPLATE\n+                .replace(MODEL_NAME_PLACEHOLDER, format(requestData.getModelName()))\n+                .replace(MODEL_NAMESPACE_PLACEHOLDER, format(requestData.getModelNamespace()))\n+                .replace(EVALUATE_DECISION_PLACEHOLDER, format(requestData.getDecision()))\n+                .replace(FULL_RESULT_PLACEHOLDER, fullResult == null ? \"null\" : fullResult.toString())\n+                .replace(FILTERED_CTX_PLACEHOLDER, filteredCtx == null ? \"null\" : filteredCtx.toString())\n+                .replace(DATA_PLACEHOLDER, Optional.ofNullable(requestData.getData()).orElse(\"null\"));\n+    }\n+\n+    private String format(String input) {\n+        return Optional.ofNullable(input)\n+                .map(i -> \"\\\"\" + i + \"\\\"\")\n+                .orElse(\"null\");\n+    }\n+\n+    private void mockDecisionModel() {\n+        decisionModelSpy = spy(new DmnDecisionModel(runtime, MODEL_NAMESPACE, MODEL_NAME));\n+        when(decisionModelsMock.getDecisionModel(eq(MODEL_NAMESPACE), eq(DecisionTestUtils.MODEL_NAME))).thenReturn(decisionModelSpy);\n+    }\n+\n+    private void mockDecisionModelWithExecutionIdSupplier() {\n+        decisionModelSpy = spy(new DmnDecisionModel(runtime, MODEL_NAMESPACE, MODEL_NAME, () -> TEST_EXECUTION_ID));\n+        when(decisionModelsMock.getDecisionModel(eq(MODEL_NAMESPACE), eq(DecisionTestUtils.MODEL_NAME))).thenReturn(decisionModelSpy);\n+    }\n+\n+    private <T> void testCloudEventEmitted(RequestData requestData, Boolean fullResult, Boolean filteredCtx, Class<T> responseDataClass, String expectedType, TriConsumer<CloudEvent, KogitoExtension, T> callback) {\n+        try {\n+            ArgumentCaptor<String> eventCaptor = ArgumentCaptor.forClass(String.class);\n+\n+            controller.handleEvent(cloudEventOkWith(requestData, fullResult, filteredCtx));\n+\n+            verify(eventEmitterMock).emit(eventCaptor.capture());\n+            String emittedCloudEventJson = eventCaptor.getValue();\n+\n+            Optional<CloudEvent> optEmittedCloudEvent = CloudEventUtils.decode(emittedCloudEventJson);\n+            if (optEmittedCloudEvent.isPresent()) {\n+                CloudEvent emittedCloudEvent = optEmittedCloudEvent.get();\n+\n+                assertEquals(expectedType, emittedCloudEvent.getType());\n+\n+                KogitoExtension kogitoExtension = ExtensionProvider.getInstance()\n+                        .parseExtension(KogitoExtension.class, emittedCloudEvent);\n+\n+                if (kogitoExtension != null) {\n+                    assertEquals(requestData.getModelName(), kogitoExtension.getDmnModelName());\n+                    assertEquals(requestData.getModelNamespace(), kogitoExtension.getDmnModelNamespace());\n+                    assertEquals(requestData.getDecision(), kogitoExtension.getDmnEvaluateDecision());\n+\n+                    Optional<T> optResponseEvent = CloudEventUtils.decodeData(emittedCloudEvent, responseDataClass);\n+                    if (optResponseEvent.isPresent()) {\n+                        assertSubject(emittedCloudEvent);\n+                        if (callback != null) {\n+                            callback.accept(emittedCloudEvent, kogitoExtension, optResponseEvent.get());\n+                        }\n+                    } else {\n+                        fail(\"Can't decode emitted CloudEvent data of: \" + emittedCloudEventJson);\n+                    }\n+                } else {\n+                    fail(\"No Kogito extension in emitted CloudEvent: \" + emittedCloudEventJson);\n+                }\n+            } else {\n+                fail(\"Can't decode emitted CloudEvent\");\n+            }", "originalCommit": "a3f531ce2170983b8a7287e6cfbb4ac8f2e289a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTcwMjY5NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r561702695", "bodyText": "I did it only because you used the emoticon in the comment \ud83d\ude1d", "author": "kostola", "createdAt": "2021-01-21T08:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE0OTMwNQ=="}], "type": "inlineReview"}, {"oid": "ffafe6101c538efaabb2bfb9ff43f5b33ab410f8", "url": "https://github.com/kiegroup/kogito-runtimes/commit/ffafe6101c538efaabb2bfb9ff43f5b33ab410f8", "message": "KOGITO-3936: clean EventDrivenDecisionControllerTest", "committedDate": "2021-01-21T08:57:03Z", "type": "commit"}, {"oid": "ea4097805de11c04095d89995766cea52af91e17", "url": "https://github.com/kiegroup/kogito-runtimes/commit/ea4097805de11c04095d89995766cea52af91e17", "message": "KOGITO-3936: rename addon to kogito-event-driven-decisions", "committedDate": "2021-01-21T14:28:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjUwNDM0MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r562504340", "bodyText": "Is this a known bug or something new? If so, could you create a ticket for them and add the link here so that we fix it in the future?", "author": "r00ta", "createdAt": "2021-01-22T09:36:57Z", "path": "addons/cloudevents/cloudevents-utils/src/main/java/org/kie/kogito/cloudevents/extension/KogitoExtension.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ *  Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.cloudevents.extension;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+import io.cloudevents.CloudEventExtensions;\n+import io.cloudevents.Extension;\n+import io.cloudevents.core.extensions.impl.ExtensionUtils;\n+import io.cloudevents.core.provider.ExtensionProvider;\n+\n+public class KogitoExtension implements Extension {\n+\n+    public static final String KOGITO_EXECUTION_ID = \"kogitoexecutionid\";\n+    public static final String KOGITO_DMN_MODEL_NAME = \"kogitodmnmodelname\";\n+    public static final String KOGITO_DMN_MODEL_NAMESPACE = \"kogitodmnmodelnamespace\";\n+    public static final String KOGITO_DMN_EVALUATE_DECISION = \"kogitodmnevaldecision\";\n+    public static final String KOGITO_DMN_FULL_RESULT = \"kogitodmnfullresult\";\n+    public static final String KOGITO_DMN_FILTERED_CTX = \"kogitodmnfilteredctx\";\n+\n+    private static final Set<String> KEYS = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(\n+            KOGITO_EXECUTION_ID,\n+            KOGITO_DMN_MODEL_NAME,\n+            KOGITO_DMN_MODEL_NAMESPACE,\n+            KOGITO_DMN_EVALUATE_DECISION,\n+            KOGITO_DMN_FULL_RESULT,\n+            KOGITO_DMN_FILTERED_CTX\n+    )));\n+\n+    private String executionId;\n+    private String dmnModelName;\n+    private String dmnModelNamespace;\n+    private String dmnEvaluateDecision;\n+    private Boolean dmnFullResult;\n+    private Boolean dmnFilteredCtx;\n+\n+    public static void register() {\n+        ExtensionProvider.getInstance().registerExtension(KogitoExtension.class, KogitoExtension::new);\n+    }\n+\n+    @Override\n+    public void readFrom(CloudEventExtensions extensions) {\n+        readStringExtension(extensions, KOGITO_EXECUTION_ID, this::setExecutionId);\n+        readStringExtension(extensions, KOGITO_DMN_MODEL_NAME, this::setDmnModelName);\n+        readStringExtension(extensions, KOGITO_DMN_MODEL_NAMESPACE, this::setDmnModelNamespace);\n+        readStringExtension(extensions, KOGITO_DMN_EVALUATE_DECISION, this::setDmnEvaluateDecision);\n+        readBooleanExtension(extensions, KOGITO_DMN_FULL_RESULT, this::setDmnFullResult);\n+        readBooleanExtension(extensions, KOGITO_DMN_FILTERED_CTX, this::setDmnFilteredCtx);\n+    }\n+\n+    private static void readStringExtension(CloudEventExtensions extensions, String key, Consumer<String> consumer) {\n+        Optional.ofNullable(extensions.getExtension(key))\n+                // there seems to be a bug in the cloudevents sdk so that, when a extension attributes is null,", "originalCommit": "ea4097805de11c04095d89995766cea52af91e17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjU1Njg0Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/946#discussion_r562556846", "bodyText": "Yes I will do this today \ud83d\udc4d", "author": "kostola", "createdAt": "2021-01-22T11:04:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjUwNDM0MA=="}], "type": "inlineReview"}]}