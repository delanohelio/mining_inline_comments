{"pr_number": 537, "pr_title": "[KOGITO-2168] Implement Conditions for Milestones", "pr_createdAt": "2020-06-01T16:00:20Z", "pr_url": "https://github.com/kiegroup/kogito-runtimes/pull/537", "timeline": [{"oid": "f8da34386aa5a84bb6593aa79058778079d318e0", "url": "https://github.com/kiegroup/kogito-runtimes/commit/f8da34386aa5a84bb6593aa79058778079d318e0", "message": "[KOGITO-2168] Implemented conditions for Milestones\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-02T07:22:05Z", "type": "forcePushed"}, {"oid": "94377400c07ac62733b6c2e72a5a7d2a5addd40d", "url": "https://github.com/kiegroup/kogito-runtimes/commit/94377400c07ac62733b6c2e72a5a7d2a5addd40d", "message": "[KOGITO-2168] Implement conditions for Milestones\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-03T09:23:13Z", "type": "forcePushed"}, {"oid": "9ea08aafe0617605b53f9a3dc9dc532f8f5f8fc0", "url": "https://github.com/kiegroup/kogito-runtimes/commit/9ea08aafe0617605b53f9a3dc9dc532f8f5f8fc0", "message": "[KOGITO-2168] Implement conditions for Milestones\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-03T09:25:13Z", "type": "forcePushed"}, {"oid": "1b4926c544907c28b5d9a323118bbe9972b1f9db", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1b4926c544907c28b5d9a323118bbe9972b1f9db", "message": "[KOGITO-2168] Implement conditions for Milestones\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-03T09:31:07Z", "type": "forcePushed"}, {"oid": "f2741024e7a8f8c7f204503b1ceea4a7387c04a1", "url": "https://github.com/kiegroup/kogito-runtimes/commit/f2741024e7a8f8c7f204503b1ceea4a7387c04a1", "message": "[KOGITO-2168] Implement conditions for Milestones\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-03T09:38:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxNjExNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r434516117", "bodyText": "if this is a constraint expression why is it a string and not an expression?", "author": "evacchi", "createdAt": "2020-06-03T12:05:22Z", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/MilestoneNodeVisitor.java", "diffHunk": "@@ -37,13 +48,36 @@ protected String getNodeKey() {\n     @Override\n     public void visitNode(String factoryField, MilestoneNode node, BlockStmt body, VariableScope variableScope, ProcessMetaData metadata) {\n         body.addStatement(getAssignedFactoryMethod(factoryField, MilestoneNodeFactory.class, getNodeId(node), getNodeKey(), new LongLiteralExpr(node.getId())))\n-                .addStatement(getNameMethod(node, \"Milestone\"))\n-                .addStatement(getFactoryMethod(getNodeId(node), METHOD_CONSTRAINT, new StringLiteralExpr(StringEscapeUtils.escapeJava(node.getConstraint()))));\n+                .addStatement(getNameMethod(node, \"Milestone\"));\n+        if(node.getConstraint() != null && !node.getConstraint().trim().isEmpty()) {\n+            body.addStatement(getFactoryMethod(getNodeId(node), METHOD_CONSTRAINT, new StringLiteralExpr(StringEscapeUtils.escapeJava(node.getConstraint()))));", "originalCommit": "f2741024e7a8f8c7f204503b1ceea4a7387c04a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxNzU0NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r434517545", "bodyText": "not your code, but I am noticing that an exception is thrown after fail(); so, I believe it's actually never thrown. You can probably remove the throw?", "author": "evacchi", "createdAt": "2020-06-03T12:08:03Z", "path": "jbpm/jbpm-flow-builder/src/test/java/org/jbpm/test/util/AbstractBaseTest.java", "diffHunk": "@@ -46,7 +46,7 @@ public KieSession createKieSession(KiePackage... pkg) {\n         try { \n             return createKieSession(false, pkg);\n         } catch(Exception e ) { \n-            String msg = \"There's no reason fo an exception to be thrown here (because the kbase is not being serialized)!\";\n+            String msg = \"There's no reason for an exception to be thrown here (because the kbase is not being serialized)!\";\n             fail( msg );\n             throw new RuntimeException(msg, e);", "originalCommit": "f2741024e7a8f8c7f204503b1ceea4a7387c04a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxODEyOA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r434518128", "bodyText": "if there is a rule flow group is no longer used, do we still need this line?", "author": "evacchi", "createdAt": "2020-06-03T12:09:03Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/DynamicNodeInstance.java", "diffHunk": "@@ -79,9 +79,8 @@ public void internalTrigger(NodeInstance from, String type) {\n                 agenda.getRuleFlowGroup(ruleFlowGroup).setAutoDeactivate(false);\n                 agenda.activateRuleFlowGroup(ruleFlowGroup, getProcessInstance().getId(), getUniqueId());\n             }\n-            String rule =  \"RuleFlow-AdHocComplete-\" + getProcessInstance().getProcessId() + \"-\" + getDynamicNode().getUniqueId();\n             isActive = ((InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda())\n-                    .isRuleActiveInRuleFlowGroup(getRuleFlowGroupName(), rule, getProcessInstance().getId());\n+                    .isRuleActiveInRuleFlowGroup(getRuleFlowGroupName(), getActivationEventType(), getProcessInstance().getId());", "originalCommit": "f2741024e7a8f8c7f204503b1ceea4a7387c04a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "148c721391839a23b44f63f269c2682e664417d9", "url": "https://github.com/kiegroup/kogito-runtimes/commit/148c721391839a23b44f63f269c2682e664417d9", "message": "[KOGITO-2168] Remove tests\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-05T07:28:07Z", "type": "forcePushed"}, {"oid": "0f977170608dcb5f53296d8673928ac2b897eb41", "url": "https://github.com/kiegroup/kogito-runtimes/commit/0f977170608dcb5f53296d8673928ac2b897eb41", "message": "[KOGITO-2168] Remove tests\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-05T07:35:26Z", "type": "forcePushed"}, {"oid": "9247a78035bd43d0e0a253ede4d635d39acc7aa6", "url": "https://github.com/kiegroup/kogito-runtimes/commit/9247a78035bd43d0e0a253ede4d635d39acc7aa6", "message": "[KOGITO-2168] Add DynamicNode activation/completion conditions\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-08T19:56:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzMwNDk1OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437304959", "bodyText": "why not keep as Milestone?", "author": "cristianonicolai", "createdAt": "2020-06-09T10:25:25Z", "path": "api/kogito-api/src/main/java/org/kie/kogito/process/ProcessInstance.java", "diffHunk": "@@ -189,7 +189,7 @@\n      *\n      * @return All the process milestones with their current status\n      */\n-    Collection<Milestone> milestones();", "originalCommit": "9247a78035bd43d0e0a253ede4d635d39acc7aa6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQxNjExNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437416116", "bodyText": "reverting", "author": "ruromero", "createdAt": "2020-06-09T13:27:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzMwNDk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQwOTQ1MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437409451", "bodyText": "what about isActivated(ProcessContext context)?", "author": "tiagodolphine", "createdAt": "2020-06-09T13:18:27Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/DynamicNode.java", "diffHunk": "@@ -109,4 +119,22 @@ public String getActivationEventName() {\n         \n         return activationSignalName;\n     }\n+\n+    public DynamicNode setActivationExpression(Predicate<ProcessContext> activationPredicate) {\n+        this.activationPredicate = activationPredicate;\n+        return this;\n+    }\n+\n+    public DynamicNode setCompletionExpression(Predicate<ProcessContext> copmletionPredicate) {\n+        this.completionPredicate = copmletionPredicate;\n+        return this;\n+    }\n+\n+    public boolean testActivation(ProcessContext context) {", "originalCommit": "9247a78035bd43d0e0a253ede4d635d39acc7aa6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQwOTc4Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437409782", "bodyText": "what about  isCompleted(ProcessContext context)?", "author": "tiagodolphine", "createdAt": "2020-06-09T13:18:57Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/DynamicNode.java", "diffHunk": "@@ -109,4 +119,22 @@ public String getActivationEventName() {\n         \n         return activationSignalName;\n     }\n+\n+    public DynamicNode setActivationExpression(Predicate<ProcessContext> activationPredicate) {\n+        this.activationPredicate = activationPredicate;\n+        return this;\n+    }\n+\n+    public DynamicNode setCompletionExpression(Predicate<ProcessContext> copmletionPredicate) {\n+        this.completionPredicate = copmletionPredicate;\n+        return this;\n+    }\n+\n+    public boolean testActivation(ProcessContext context) {\n+        return activationPredicate == null || activationPredicate.test(context);\n+    }\n+\n+    public boolean testCompletion(ProcessContext context) {", "originalCommit": "9247a78035bd43d0e0a253ede4d635d39acc7aa6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQxOTU5OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437419599", "bodyText": "isConditionAchived? isConditionMatched? well no idea what would be a better name, just thinking the \"test\" prefix is strange...", "author": "tiagodolphine", "createdAt": "2020-06-09T13:33:00Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/MilestoneNode.java", "diffHunk": "@@ -16,71 +16,56 @@\n \n package org.jbpm.workflow.core.node;\n \n+import java.util.function.Predicate;\n+\n import org.kie.api.definition.process.Connection;\n-import org.jbpm.workflow.core.Constraint;\n-import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.kie.api.runtime.process.ProcessContext;\n+\n+import static org.jbpm.ruleflow.core.Metadata.UNIQUE_ID;\n \n /**\n  * Default implementation of a milestone node.\n- * \n  */\n public class MilestoneNode extends StateBasedNode implements Constrainable {\n \n-\tprivate static final long serialVersionUID = 510l;\n+    private static final long serialVersionUID = 510L;\n \n-\tprivate String constraint;\n-\tprivate String matchVariable;\n+    private Predicate<ProcessContext> conditionPredicate;\n \n-    public void addConstraint(ConnectionRef connection, Constraint constraint) {\n-    \tif (connection != null) {\n-    \t\tthrow new IllegalArgumentException(\n-\t\t\t\t\"A Milestone node only accepts one simple constraint\");\n-    \t}\n-        this.constraint = constraint.getConstraint();\n-    }\n-    \n-    public void setConstraint(String constraint){\n-        this.constraint = constraint;\n+    public void setCondition(Predicate<ProcessContext> conditionPredicate) {\n+        this.conditionPredicate = conditionPredicate;\n     }\n \n-    public String getConstraint(){\n-        return this.constraint;\n-    }    \n-    \n-    public String getMatchVariable() {\n-        return matchVariable;\n-    }\n-    \n-    public void setMatchVariable(String matchVariable) {\n-        this.matchVariable = matchVariable;\n+    public boolean testCondition(ProcessContext context) {", "originalCommit": "9247a78035bd43d0e0a253ede4d635d39acc7aa6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1NjMwOA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437856308", "bodyText": "+1", "author": "cristianonicolai", "createdAt": "2020-06-10T04:41:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQxOTU5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyNjY2Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437426667", "bodyText": "one option is to add a constructor to initialize this the field and keep the default as true.", "author": "tiagodolphine", "createdAt": "2020-06-09T13:41:56Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/CompositeNode.java", "diffHunk": "@@ -41,7 +38,7 @@\n     private Map<String, CompositeNode.NodeAndType> outConnectionMap = new HashMap<String, CompositeNode.NodeAndType>();\n \tprivate boolean cancelRemainingInstances = true;\n \n-\tprivate boolean autoComplete = true;\n+\tboolean autoComplete = true;", "originalCommit": "9247a78035bd43d0e0a253ede4d635d39acc7aa6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0MTY5MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437441690", "bodyText": "that is a mistake, indeed. I already reverted it", "author": "ruromero", "createdAt": "2020-06-09T13:56:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyNjY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyNzM2NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437427365", "bodyText": "one option is to use a constructor on the superclass.", "author": "tiagodolphine", "createdAt": "2020-06-09T13:42:35Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/DynamicNode.java", "diffHunk": "@@ -19,20 +19,30 @@\n import java.util.Arrays;\n import java.util.List;\n import java.util.function.Function;\n+import java.util.function.Predicate;\n import java.util.stream.Collectors;\n \n+import org.jbpm.ruleflow.core.Metadata;\n import org.jbpm.workflow.core.WorkflowProcess;\n import org.kie.api.definition.process.Node;\n+import org.kie.api.runtime.process.ProcessContext;\n \n+import static org.jbpm.ruleflow.core.Metadata.CUSTOM_AUTO_START;\n \n public class DynamicNode extends CompositeContextNode {\n \n \tprivate static final long serialVersionUID = 510l;\n \t\n \tprivate String activationExpression;\n \tprivate String completionExpression;\n+    private Predicate<ProcessContext> activationPredicate;\n+    private Predicate<ProcessContext> completionPredicate;\n \tprivate String language;\n-\t\t\t\n+\n+    public DynamicNode() {\n+        autoComplete = false;", "originalCommit": "9247a78035bd43d0e0a253ede4d635d39acc7aa6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNjA2Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437436063", "bodyText": "What about keeping the method getConstraint() and just returning the getMetadata(\"CONDITION\") on it, or change to getCondition(), just to simplify for callers, instead of doing the milestone.getMetadata(CONDITION)...", "author": "tiagodolphine", "createdAt": "2020-06-09T13:50:52Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/MilestoneNode.java", "diffHunk": "@@ -16,71 +16,56 @@\n \n package org.jbpm.workflow.core.node;\n \n+import java.util.function.Predicate;\n+\n import org.kie.api.definition.process.Connection;\n-import org.jbpm.workflow.core.Constraint;\n-import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.kie.api.runtime.process.ProcessContext;\n+\n+import static org.jbpm.ruleflow.core.Metadata.UNIQUE_ID;\n \n /**\n  * Default implementation of a milestone node.\n- * \n  */\n public class MilestoneNode extends StateBasedNode implements Constrainable {\n \n-\tprivate static final long serialVersionUID = 510l;\n+    private static final long serialVersionUID = 510L;\n \n-\tprivate String constraint;\n-\tprivate String matchVariable;\n+    private Predicate<ProcessContext> conditionPredicate;\n \n-    public void addConstraint(ConnectionRef connection, Constraint constraint) {\n-    \tif (connection != null) {\n-    \t\tthrow new IllegalArgumentException(\n-\t\t\t\t\"A Milestone node only accepts one simple constraint\");\n-    \t}\n-        this.constraint = constraint.getConstraint();\n-    }\n-    \n-    public void setConstraint(String constraint){\n-        this.constraint = constraint;\n+    public void setCondition(Predicate<ProcessContext> conditionPredicate) {\n+        this.conditionPredicate = conditionPredicate;\n     }\n \n-    public String getConstraint(){", "originalCommit": "9247a78035bd43d0e0a253ede4d635d39acc7aa6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NjkzNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437446934", "bodyText": "with what purpose?", "author": "ruromero", "createdAt": "2020-06-09T14:02:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNjA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ2ODM5Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437468392", "bodyText": "to make the usage better and simpler, in this way the callers don't need to know the value is gotten from the metadata and even the key to be used of the metadata that would be used to get the value...", "author": "tiagodolphine", "createdAt": "2020-06-09T14:30:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNjA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ3MjAyMg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437472022", "bodyText": "I mean, who needs to know about the condition? Do you think this should be exposed to the Milestone object? Same for the activation/completion conditions in the AdHocSubProcess", "author": "ruromero", "createdAt": "2020-06-09T14:34:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNjA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ3NjQ2Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437476463", "bodyText": "mmm if the condition value would be accessed outside the class I think it would be great, to simplify getting the information... otherwise yeah.. it does not make sense...", "author": "tiagodolphine", "createdAt": "2020-06-09T14:40:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNjA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2ODk0OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437868949", "bodyText": "@ruromero I think we're overusing the metadata for this, keeping a specific attribute and method I think is more clear unles there is a specific reason for this change. I would actually prefer to keep getContraint() and same for node.getActivationExpression() and node.getCompletionExpression()", "author": "cristianonicolai", "createdAt": "2020-06-10T05:30:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNjA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg5MDAyMg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437890022", "bodyText": "The purpose of keeping these expressions in the metadata is only to allow the nodeVisitor access so it can generate the lambdas. What I could do is to remove them in the visitors.\nWhy would they be needed further this point?", "author": "ruromero", "createdAt": "2020-06-10T06:35:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNjA2Mw=="}], "type": "inlineReview"}, {"oid": "19cae39940a1bf24deaaf43eb5b3325219e8c424", "url": "https://github.com/kiegroup/kogito-runtimes/commit/19cae39940a1bf24deaaf43eb5b3325219e8c424", "message": "[KOGITO-2168] Add DynamicNode activation/completion conditions\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-09T14:32:07Z", "type": "forcePushed"}, {"oid": "754914b60f6ae6838e0c2ba317c5f53334799612", "url": "https://github.com/kiegroup/kogito-runtimes/commit/754914b60f6ae6838e0c2ba317c5f53334799612", "message": "[KOGITO-2168] Add DynamicNode activation/completion conditions\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-09T15:28:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1NTY3MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437855670", "bodyText": "can we use a constant here?", "author": "cristianonicolai", "createdAt": "2020-06-10T04:38:55Z", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/xml/processes/DynamicNodeHandler.java", "diffHunk": "@@ -28,9 +33,24 @@ protected Node createNode() {\n     public Class<?> generateNodeFor() {\n         return DynamicNode.class;\n     }\n-    \n+\n     protected String getNodeName() {\n-    \treturn \"dynamic\";\n+        return \"dynamic\";\n     }\n \n+    @Override\n+    protected void handleNode(Node node, Element element, String uri, String localName, ExtensibleXmlParser parser) throws SAXException {\n+        super.handleNode(node, element, uri, localName, parser);\n+        DynamicNode dynamicNode = (DynamicNode) node;\n+        for (int i = 0; i < element.getChildNodes().getLength(); i++) {\n+            org.w3c.dom.Node n = element.getChildNodes().item(i);\n+            if (COMPLETION_CONDITION.equals(n.getNodeName())) {\n+                if (\"autocomplete\".equals(n.getTextContent())) {", "originalCommit": "754914b60f6ae6838e0c2ba317c5f53334799612", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1NzM2Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437857363", "bodyText": "@ruromero so why only when state is pending? can't milestone nodes get activated when the process is for instance in Active state?", "author": "cristianonicolai", "createdAt": "2020-06-10T04:45:58Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/DynamicNodeInstance.java", "diffHunk": "@@ -66,188 +55,103 @@ public void internalTrigger(NodeInstance from, String type) {\n         triggerTime = new Date();\n         triggerEvent(EVENT_NODE_ENTER);\n \n-    \t// if node instance was cancelled, abort\n-\t\tif (getNodeInstanceContainer().getNodeInstance(getId()) == null) {\n-\t\t\treturn;\n-\t\t}\n-        boolean isActive = false;\n-        // KOGITO-2168 Conditions not supported\n-        if(getProcessInstance().getKnowledgeRuntime().getAgenda() != null) {\n-            InternalAgenda agenda = (InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda();\n-            String ruleFlowGroup = getRuleFlowGroupName();\n-            if (ruleFlowGroup != null && !agenda.getRuleFlowGroup(ruleFlowGroup).isActive()) {\n-                agenda.getRuleFlowGroup(ruleFlowGroup).setAutoDeactivate(false);\n-                agenda.activateRuleFlowGroup(ruleFlowGroup, getProcessInstance().getId(), getUniqueId());\n-            }\n-            String rule =  \"RuleFlow-AdHocComplete-\" + getProcessInstance().getProcessId() + \"-\" + getDynamicNode().getUniqueId();\n-            isActive = ((InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda())\n-                    .isRuleActiveInRuleFlowGroup(getRuleFlowGroupName(), rule, getProcessInstance().getId());\n+        // if node instance was cancelled, abort\n+        if (getNodeInstanceContainer().getNodeInstance(getId()) == null) {\n+            return;\n         }\n-        if (isActive) {\n-            triggerCompleted();\n+        if (canActivate()) {\n+            triggerActivated();\n         } else {\n+            setState(ProcessInstance.STATE_PENDING);\n             addActivationListener();\n         }\n+    }\n \n-    \t// activate ad hoc fragments if they are marked as such\n+    private void triggerActivated() {\n+        setState(ProcessInstance.STATE_ACTIVE);\n+        // activate ad hoc fragments if they are marked as such\n         List<Node> autoStartNodes = getDynamicNode().getAutoStartNodes();\n-        autoStartNodes.forEach(austoStartNode -> triggerSelectedNode(austoStartNode, null));\n+        autoStartNodes.forEach(autoStartNode -> triggerSelectedNode(autoStartNode, null));\n     }\n \n-    @Override\n-    public void addEventListeners() {\n-        super.addEventListeners();\n-        addActivationListener();\n+    private boolean canActivate() {\n+        ProcessContext context = new ProcessContext(getProcessInstance().getKnowledgeRuntime())\n+                .setNodeInstance(this);\n+        return getDynamicNode().testActivation(context);\n     }\n \n-    @Override\n-    public void removeEventListeners() {\n-        super.removeEventListeners();\n-        getProcessInstance().getKnowledgeRuntime().removeEventListener(this);\n-        getProcessInstance().removeEventListener(getActivationEventType(), this, true);\n+    private boolean canComplete() {\n+        ProcessContext context = new ProcessContext(getProcessInstance().getKnowledgeRuntime())\n+                .setNodeInstance(this);\n+        return getNodeInstances(false).isEmpty() && getDynamicNode().testCompletion(context);\n     }\n-    \n+\n     private void addActivationListener() {\n-        getProcessInstance().getKnowledgeRuntime().addEventListener(this);\n-        getProcessInstance().addEventListener(getActivationEventType(), this, true);\n+        getProcessInstance().getKnowledgeRuntime().getProcessRuntime().addEventListener(ContextAwareEventListener.using(listener -> {\n+            if (canActivate() && getState() == ProcessInstance.STATE_PENDING) {", "originalCommit": "754914b60f6ae6838e0c2ba317c5f53334799612", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4MTQ3MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437881470", "bodyText": "It's the state of the node instance. As it is a CompositeNode, it has a state and the state constants used are the same as for the ProcessInstance.\nWhat I'm trying to do here is to set the state to pending when it is not ready to be activated to avoid triggering the inner nodes multiple times", "author": "ruromero", "createdAt": "2020-06-10T06:11:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1NzM2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyNzQyNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437927427", "bodyText": "hm, ok, that is strange to see the process state enum reused in here.", "author": "cristianonicolai", "createdAt": "2020-06-10T07:48:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1NzM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1ODYyNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437858624", "bodyText": "this means that if a process ends, the milestones that are activated will be left as is. Is that right?", "author": "cristianonicolai", "createdAt": "2020-06-10T04:51:05Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/DynamicNodeInstance.java", "diffHunk": "@@ -66,188 +55,103 @@ public void internalTrigger(NodeInstance from, String type) {\n         triggerTime = new Date();\n         triggerEvent(EVENT_NODE_ENTER);\n \n-    \t// if node instance was cancelled, abort\n-\t\tif (getNodeInstanceContainer().getNodeInstance(getId()) == null) {\n-\t\t\treturn;\n-\t\t}\n-        boolean isActive = false;\n-        // KOGITO-2168 Conditions not supported\n-        if(getProcessInstance().getKnowledgeRuntime().getAgenda() != null) {\n-            InternalAgenda agenda = (InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda();\n-            String ruleFlowGroup = getRuleFlowGroupName();\n-            if (ruleFlowGroup != null && !agenda.getRuleFlowGroup(ruleFlowGroup).isActive()) {\n-                agenda.getRuleFlowGroup(ruleFlowGroup).setAutoDeactivate(false);\n-                agenda.activateRuleFlowGroup(ruleFlowGroup, getProcessInstance().getId(), getUniqueId());\n-            }\n-            String rule =  \"RuleFlow-AdHocComplete-\" + getProcessInstance().getProcessId() + \"-\" + getDynamicNode().getUniqueId();\n-            isActive = ((InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda())\n-                    .isRuleActiveInRuleFlowGroup(getRuleFlowGroupName(), rule, getProcessInstance().getId());\n+        // if node instance was cancelled, abort\n+        if (getNodeInstanceContainer().getNodeInstance(getId()) == null) {\n+            return;\n         }\n-        if (isActive) {\n-            triggerCompleted();\n+        if (canActivate()) {\n+            triggerActivated();\n         } else {\n+            setState(ProcessInstance.STATE_PENDING);\n             addActivationListener();\n         }\n+    }\n \n-    \t// activate ad hoc fragments if they are marked as such\n+    private void triggerActivated() {\n+        setState(ProcessInstance.STATE_ACTIVE);\n+        // activate ad hoc fragments if they are marked as such\n         List<Node> autoStartNodes = getDynamicNode().getAutoStartNodes();\n-        autoStartNodes.forEach(austoStartNode -> triggerSelectedNode(austoStartNode, null));\n+        autoStartNodes.forEach(autoStartNode -> triggerSelectedNode(autoStartNode, null));\n     }\n \n-    @Override\n-    public void addEventListeners() {\n-        super.addEventListeners();\n-        addActivationListener();\n+    private boolean canActivate() {\n+        ProcessContext context = new ProcessContext(getProcessInstance().getKnowledgeRuntime())\n+                .setNodeInstance(this);\n+        return getDynamicNode().testActivation(context);\n     }\n \n-    @Override\n-    public void removeEventListeners() {\n-        super.removeEventListeners();\n-        getProcessInstance().getKnowledgeRuntime().removeEventListener(this);\n-        getProcessInstance().removeEventListener(getActivationEventType(), this, true);\n+    private boolean canComplete() {\n+        ProcessContext context = new ProcessContext(getProcessInstance().getKnowledgeRuntime())\n+                .setNodeInstance(this);\n+        return getNodeInstances(false).isEmpty() && getDynamicNode().testCompletion(context);\n     }\n-    \n+\n     private void addActivationListener() {\n-        getProcessInstance().getKnowledgeRuntime().addEventListener(this);\n-        getProcessInstance().addEventListener(getActivationEventType(), this, true);\n+        getProcessInstance().getKnowledgeRuntime().getProcessRuntime().addEventListener(ContextAwareEventListener.using(listener -> {\n+            if (canActivate() && getState() == ProcessInstance.STATE_PENDING) {\n+                triggerActivated();\n+                getProcessInstance().getKnowledgeRuntime().getProcessRuntime().removeEventListener(listener);\n+            }\n+        }));\n     }\n-    \n-    private String getActivationEventType() {\n-        return \"RuleFlow-AdHocComplete-\" + getProcessInstance().getProcessId()\n-            + \"-\" + getDynamicNode().getUniqueId();\n+\n+    private void addCompletionListener() {\n+        getProcessInstance().getKnowledgeRuntime()\n+                .getProcessRuntime()\n+                .addEventListener(ContextAwareEventListener.using(listener -> {\n+                    if (canComplete()) {", "originalCommit": "754914b60f6ae6838e0c2ba317c5f53334799612", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1OTIzNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437859236", "bodyText": "I think it actually makes sense to leave the old name method, is quite clear that it is specific about activation.", "author": "cristianonicolai", "createdAt": "2020-06-10T04:53:38Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java", "diffHunk": "@@ -53,112 +45,42 @@ public void internalTrigger(final NodeInstance from, String type) {\n             throw new IllegalArgumentException(\n                     \"A MilestoneNode only accepts default incoming connections!\");\n         }\n-        boolean isActive = true;\n-        // KOGITO-2168 Conditions not supported\n-        if(getProcessInstance().getKnowledgeRuntime().getAgenda() != null) {\n-            String rule = \"RuleFlow-Milestone-\" + getProcessInstance().getProcessId()\n-                    + \"-\" + getMilestoneNode().getUniqueId();\n-            isActive = ((InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda())\n-                    .isRuleActiveInRuleFlowGroup(\"DROOLS_SYSTEM\", rule, getProcessInstance().getId());\n-        }\n-        if (isActive) {\n+        if (isCompleted()) {\n             triggerCompleted();\n         } else {\n-            addActivationEventListener();\n+            addEventListener();\n         }\n     }\n \n+    private boolean isCompleted() {\n+        ProcessContext context = new ProcessContext(getProcessInstance().getKnowledgeRuntime())\n+                .setNodeInstance(this);\n+        return getMilestoneNode().testCondition(context);\n+    }\n+\n     @Override\n     public void addEventListeners() {\n         super.addEventListeners();\n-        addActivationEventListener();", "originalCommit": "754914b60f6ae6838e0c2ba317c5f53334799612", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4NDI4MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437884281", "bodyText": "This is actually about completion. The node is activated once the signal is received but it won't complete until the condition is met. I will rename it", "author": "ruromero", "createdAt": "2020-06-10T06:20:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1OTIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2Mjk3Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437862973", "bodyText": "@ruromero I think there is some inconsistency on how the events are handled here. See how the events used to be registered and remove. Is this intentional or should we reevaluate to use the same mechanism? For instance on line 79, the listener for getActivationEventType is never added, the the one add here is not removed.", "author": "cristianonicolai", "createdAt": "2020-06-10T05:08:50Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/MilestoneNodeInstance.java", "diffHunk": "@@ -53,112 +45,42 @@ public void internalTrigger(final NodeInstance from, String type) {\n             throw new IllegalArgumentException(\n                     \"A MilestoneNode only accepts default incoming connections!\");\n         }\n-        boolean isActive = true;\n-        // KOGITO-2168 Conditions not supported\n-        if(getProcessInstance().getKnowledgeRuntime().getAgenda() != null) {\n-            String rule = \"RuleFlow-Milestone-\" + getProcessInstance().getProcessId()\n-                    + \"-\" + getMilestoneNode().getUniqueId();\n-            isActive = ((InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda())\n-                    .isRuleActiveInRuleFlowGroup(\"DROOLS_SYSTEM\", rule, getProcessInstance().getId());\n-        }\n-        if (isActive) {\n+        if (isCompleted()) {\n             triggerCompleted();\n         } else {\n-            addActivationEventListener();\n+            addEventListener();\n         }\n     }\n \n+    private boolean isCompleted() {\n+        ProcessContext context = new ProcessContext(getProcessInstance().getKnowledgeRuntime())\n+                .setNodeInstance(this);\n+        return getMilestoneNode().testCondition(context);\n+    }\n+\n     @Override\n     public void addEventListeners() {\n         super.addEventListeners();\n-        addActivationEventListener();\n+        addEventListener();\n     }\n \n-    private void addActivationEventListener() {\n-        getProcessInstance().getKnowledgeRuntime().addEventListener(this);\n-        getProcessInstance().addEventListener(getActivationEventType(), this, true);\n+    private void addEventListener() {\n+        getProcessInstance().getKnowledgeRuntime().getProcessRuntime().addEventListener(ContextAwareEventListener.using(listener -> {", "originalCommit": "754914b60f6ae6838e0c2ba317c5f53334799612", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2Mzk1NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437863955", "bodyText": "maybe add an accessor method for the builder:\n    public static Builder builder(){ return new Builder(); }", "author": "cristianonicolai", "createdAt": "2020-06-10T05:12:21Z", "path": "api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java", "diffHunk": "@@ -18,40 +18,29 @@\n \n public class Milestone extends ItemDescription {\n \n-    private final String condition;\n-\n-    private Milestone(String id, String name, Status status, String condition) {\n+    private Milestone(String id, String name, Status status) {\n         super(id, name, status);\n-        this.condition = condition;\n-    }\n-\n-    public String getCondition() {\n-        return condition;\n     }\n \n     @Override\n     public String toString() {\n-        return \"Milestone{\" +\n-                \"condition='\" + condition + '\\'' +\n-                \", {\" + super.toString() + \"}\";\n+        return \"Milestone{\" + super.toString() + \"}\";\n     }", "originalCommit": "754914b60f6ae6838e0c2ba317c5f53334799612", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2NDA0OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437864048", "bodyText": "should this remain as private?", "author": "cristianonicolai", "createdAt": "2020-06-10T05:12:40Z", "path": "api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java", "diffHunk": "@@ -18,40 +18,29 @@\n \n public class Milestone extends ItemDescription {\n \n-    private final String condition;\n-\n-    private Milestone(String id, String name, Status status, String condition) {\n+    private Milestone(String id, String name, Status status) {\n         super(id, name, status);\n-        this.condition = condition;\n-    }\n-\n-    public String getCondition() {\n-        return condition;\n     }\n \n     @Override\n     public String toString() {\n-        return \"Milestone{\" +\n-                \"condition='\" + condition + '\\'' +\n-                \", {\" + super.toString() + \"}\";\n+        return \"Milestone{\" + super.toString() + \"}\";\n     }\n \n     public static class Builder {\n \n-        private String id;\n-        private String name;\n-        private Status status;\n-        private String condition;\n+        protected String id;", "originalCommit": "754914b60f6ae6838e0c2ba317c5f53334799612", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4ODc4Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437888786", "bodyText": "yes, reverted. It was a refactoring leftover", "author": "ruromero", "createdAt": "2020-06-10T06:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2NDA0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2NDQyMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437864421", "bodyText": "a builder constructor should be without parameter, then you could add a id or withId method.", "author": "cristianonicolai", "createdAt": "2020-06-10T05:13:52Z", "path": "api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java", "diffHunk": "@@ -18,40 +18,29 @@\n \n public class Milestone extends ItemDescription {\n \n-    private final String condition;\n-\n-    private Milestone(String id, String name, Status status, String condition) {\n+    private Milestone(String id, String name, Status status) {\n         super(id, name, status);\n-        this.condition = condition;\n-    }\n-\n-    public String getCondition() {\n-        return condition;\n     }\n \n     @Override\n     public String toString() {\n-        return \"Milestone{\" +\n-                \"condition='\" + condition + '\\'' +\n-                \", {\" + super.toString() + \"}\";\n+        return \"Milestone{\" + super.toString() + \"}\";\n     }\n \n     public static class Builder {\n \n-        private String id;\n-        private String name;\n-        private Status status;\n-        private String condition;\n+        protected String id;\n+        protected String name;\n+        protected Status status;\n \n         public Builder(String id) {", "originalCommit": "754914b60f6ae6838e0c2ba317c5f53334799612", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4NTA0OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437885049", "bodyText": "That means the id is mandatory. I prefer to keep it like this to make it more evident.", "author": "ruromero", "createdAt": "2020-06-10T06:22:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2NDQyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyNTA1NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437925054", "bodyText": "I guess that would be a not null check in the constructor then. A builder is just a facilitator to create the object IMHO.", "author": "cristianonicolai", "createdAt": "2020-06-10T07:44:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2NDQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2NjQyMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437866423", "bodyText": "I'm not sure why we need a builder that takes an instance with all the parameters, this feels more like a clone method.\nIn the tests, it seems that only the name is reused, so why not create a new builder instance, then withName, withStatus?", "author": "cristianonicolai", "createdAt": "2020-06-10T05:21:15Z", "path": "api/kogito-api/src/main/java/org/kie/kogito/process/flexible/Milestone.java", "diffHunk": "@@ -18,40 +18,29 @@\n \n public class Milestone extends ItemDescription {\n \n-    private final String condition;\n-\n-    private Milestone(String id, String name, Status status, String condition) {\n+    private Milestone(String id, String name, Status status) {\n         super(id, name, status);\n-        this.condition = condition;\n-    }\n-\n-    public String getCondition() {\n-        return condition;\n     }\n \n     @Override\n     public String toString() {\n-        return \"Milestone{\" +\n-                \"condition='\" + condition + '\\'' +\n-                \", {\" + super.toString() + \"}\";\n+        return \"Milestone{\" + super.toString() + \"}\";\n     }\n \n     public static class Builder {\n \n-        private String id;\n-        private String name;\n-        private Status status;\n-        private String condition;\n+        protected String id;\n+        protected String name;\n+        protected Status status;\n \n         public Builder(String id) {\n             this.id = id;\n         }\n \n-        public Builder(Milestone m) {\n-            this.id = m.getId();\n-            this.name = m.getName();\n-            this.status = m.getStatus();\n-            this.condition = m.getCondition();\n+        public Builder(ItemDescription i) {", "originalCommit": "754914b60f6ae6838e0c2ba317c5f53334799612", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4ODYwNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437888604", "bodyText": "removed", "author": "ruromero", "createdAt": "2020-06-10T06:31:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2NjQyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2NzQyMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r437867423", "bodyText": "missing assertMilestones(expected, processInstance.milestones()); ?", "author": "cristianonicolai", "createdAt": "2020-06-10T05:24:51Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/process/impl/MilestoneTest.java", "diffHunk": "@@ -75,20 +79,32 @@ void testSimpleMilestone() throws Exception {\n \n     @Test\n     void testConditionalMilestone() throws Exception {\n-        Application app = generateCodeProcessesOnly(\"cases/UserTaskCase.bpmn2\");\n+        Application app = generateCodeProcessesOnly(\"cases/milestones/ConditionalMilestone.bpmn\");\n         assertThat(app).isNotNull();\n \n-        Process<? extends Model> p = app.processes().processById(\"UserTaskCase\");\n-        ProcessInstance<?> processInstance = p.createInstance(p.createModel());\n+        Process<? extends Model> p = app.processes().processById(\"TestCase.ConditionalMilestone\");\n+        Model model = p.createModel();\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(\"favouriteColour\", \"orange\");\n+        model.fromMap(params);\n+        ProcessInstance<?> processInstance = p.createInstance(model);\n         assertState(processInstance, ProcessInstance.STATE_PENDING);\n \n-\n         Collection<Milestone> expected = new ArrayList<>();\n-        expected.add(new Milestone.Builder(\"\").withName(\"Milestone1\").withStatus(AVAILABLE).withCondition(\"\").build());\n-        expected.add(new Milestone.Builder(\"\").withName(\"Milestone2\").withStatus(AVAILABLE).withCondition(\"CaseData(data.get(\\\"dataComplete\\\") == true)\").build());\n+        expected.add(new Milestone.Builder(\"\").withName(\"Milestone\").withStatus(AVAILABLE).build());\n+        assertMilestones(expected, processInstance.milestones());\n+\n+        processInstance.start();\n+        assertState(processInstance, ProcessInstance.STATE_ACTIVE);\n \n-        Collection<Milestone> milestones = processInstance.milestones();\n-        assertMilestones(expected, milestones);\n+        expected = expected.stream().map(m -> new Milestone.Builder(m).withStatus(AVAILABLE).build()).collect(Collectors.toList());", "originalCommit": "754914b60f6ae6838e0c2ba317c5f53334799612", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8b2a05b84496497e6a472fcce5fbbf1097760c5c", "url": "https://github.com/kiegroup/kogito-runtimes/commit/8b2a05b84496497e6a472fcce5fbbf1097760c5c", "message": "[KOGITO-2168] Implement conditions for DynamicNodes and Milestones\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-15T06:14:45Z", "type": "forcePushed"}, {"oid": "9d1aff4d5edc36e07ea571e7dafd3cea27c5565e", "url": "https://github.com/kiegroup/kogito-runtimes/commit/9d1aff4d5edc36e07ea571e7dafd3cea27c5565e", "message": "[KOGITO-2168] Implement conditions for DynamicNodes and Milestones\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-15T07:18:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAwMTE0NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r440001145", "bodyText": "please remove unused import", "author": "cristianonicolai", "createdAt": "2020-06-15T08:10:16Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/StateBasedNodeInstance.java", "diffHunk": "@@ -46,6 +46,7 @@\n import org.jbpm.workflow.instance.impl.ExtendedNodeInstanceImpl;\n import org.jbpm.workflow.instance.impl.NodeInstanceResolverFactory;\n import org.jbpm.workflow.instance.impl.WorkflowProcessInstanceImpl;\n+import org.kie.api.event.process.ProcessEventListener;", "originalCommit": "9d1aff4d5edc36e07ea571e7dafd3cea27c5565e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAwNTg4MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/537#discussion_r440005880", "bodyText": "unused import", "author": "cristianonicolai", "createdAt": "2020-06-15T08:19:02Z", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/xml/processes/MilestoneNodeHandler.java", "diffHunk": "@@ -18,6 +18,7 @@\n \n import org.drools.compiler.compiler.xml.XmlDumper;\n import org.drools.core.xml.ExtensibleXmlParser;\n+import org.jbpm.ruleflow.core.Metadata;", "originalCommit": "9d1aff4d5edc36e07ea571e7dafd3cea27c5565e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8c0a05ef27da9509c88ba24a82c94bda1312e88b", "url": "https://github.com/kiegroup/kogito-runtimes/commit/8c0a05ef27da9509c88ba24a82c94bda1312e88b", "message": "[KOGITO-2168] Implement conditions for DynamicNodes and Milestones\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-15T08:30:56Z", "type": "forcePushed"}, {"oid": "6e6289ad498e1a8f56e7a58820ee1441a8b64858", "url": "https://github.com/kiegroup/kogito-runtimes/commit/6e6289ad498e1a8f56e7a58820ee1441a8b64858", "message": "[KOGITO-2168] Implement conditions for DynamicNodes and Milestones\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-15T10:04:37Z", "type": "forcePushed"}, {"oid": "a8ed8031e7845fab754c895bfad495c2cd0af894", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a8ed8031e7845fab754c895bfad495c2cd0af894", "message": "[KOGITO-2168] Implement conditions for DynamicNodes and Milestones\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-16T08:28:10Z", "type": "commit"}, {"oid": "a8ed8031e7845fab754c895bfad495c2cd0af894", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a8ed8031e7845fab754c895bfad495c2cd0af894", "message": "[KOGITO-2168] Implement conditions for DynamicNodes and Milestones\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-16T08:28:10Z", "type": "forcePushed"}, {"oid": "85d3f36869b1781caf8875f7af8e81a5b2052551", "url": "https://github.com/kiegroup/kogito-runtimes/commit/85d3f36869b1781caf8875f7af8e81a5b2052551", "message": "[KOGITO-2168] Remove some codesmells\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-06-16T09:54:30Z", "type": "commit"}]}