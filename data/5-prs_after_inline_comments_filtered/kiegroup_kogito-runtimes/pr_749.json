{"pr_number": 749, "pr_title": "[KOGITO-3221] Fix kogito-runtimes for MiningModel", "pr_createdAt": "2020-09-08T12:46:09Z", "pr_url": "https://github.com/kiegroup/kogito-runtimes/pull/749", "timeline": [{"oid": "435f2db2ac322bb6bf1ea112a6070b7c866f0134", "url": "https://github.com/kiegroup/kogito-runtimes/commit/435f2db2ac322bb6bf1ea112a6070b7c866f0134", "message": "[KOGITO-3221] Ignoring directory", "committedDate": "2020-09-08T07:47:12Z", "type": "commit"}, {"oid": "cc01a1b03768c95a3115a8dd8223805dac60d343", "url": "https://github.com/kiegroup/kogito-runtimes/commit/cc01a1b03768c95a3115a8dd8223805dac60d343", "message": "[KOGITO-3221] Managing nested models of PMML MiningModel", "committedDate": "2020-09-08T08:30:00Z", "type": "commit"}, {"oid": "9b65bf508b5f2f690ea6dff274077888a811522e", "url": "https://github.com/kiegroup/kogito-runtimes/commit/9b65bf508b5f2f690ea6dff274077888a811522e", "message": "Merge remote-tracking branch 'origin/master' into KOGITO-3221", "committedDate": "2020-09-08T08:30:13Z", "type": "commit"}, {"oid": "123e02121f82e11f2bcf2e97d53bb62e127cd7fd", "url": "https://github.com/kiegroup/kogito-runtimes/commit/123e02121f82e11f2bcf2e97d53bb62e127cd7fd", "message": "Merge remote-tracking branch 'origin/master' into KOGITO-3221\n\n# Conflicts:\n#\tdrools/drools-core-static/src/main/java/org/drools/statics/StaticServiceRegistry.java\n#\tkogito-codegen/src/main/java/org/kie/kogito/codegen/prediction/PredictionCodegen.java", "committedDate": "2020-09-09T14:30:53Z", "type": "commit"}, {"oid": "60cc81b6af98b9cde4e11f9fb12d80008b8d8d38", "url": "https://github.com/kiegroup/kogito-runtimes/commit/60cc81b6af98b9cde4e11f9fb12d80008b8d8d38", "message": "[KOGITO-3221] Merged master", "committedDate": "2020-09-09T14:32:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5MDcxMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486190710", "bodyText": "I would suggest to use some logger instead.", "author": "jiripetrlik", "createdAt": "2020-09-10T09:17:57Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/prediction/PredictionRuleMappersGeneratorTest.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package org.kie.kogito.codegen.prediction;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class PredictionRuleMappersGeneratorTest {\n+\n+    @Test\n+    void getPredictionRuleMapperSource() {\n+        final String predictionRuleMapper = \"PredictionRuleMapperImpl\";\n+        final String packageName = \"PACKAGE\";\n+        final List<String> generatedRuleMappers = IntStream.range(0, 4).mapToObj(index -> packageName + \".\" +\n+                \"subPack\" + index + \".\" + predictionRuleMapper).collect(Collectors.toList());\n+        String retrieved = PredictionRuleMappersGenerator.getPredictionRuleMappersSource(packageName,\n+                                                                                        generatedRuleMappers);\n+        assertNotNull(retrieved);\n+        String expected = String.format(\"package %s;\", packageName);\n+        assertTrue(retrieved.contains(expected));\n+        List<String> mod = generatedRuleMappers.stream().map(gen -> \"new \" + gen + \"()\").collect(Collectors.toList());\n+        expected = \"Arrays.asList(\" + String.join(\", \", mod) + \");\";\n+        assertTrue(retrieved.contains(expected));\n+        System.out.println(retrieved);", "originalCommit": "60cc81b6af98b9cde4e11f9fb12d80008b8d8d38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5OTY4Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486199686", "bodyText": "@jiripetrlik\nRemoved (leftover)", "author": "gitgabrio", "createdAt": "2020-09-10T09:32:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5MDcxMA=="}], "type": "inlineReview"}, {"oid": "1532ae6a0a71cacb790dd6fcb8aa9194cfe2d155", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1532ae6a0a71cacb790dd6fcb8aa9194cfe2d155", "message": "[KOGITO-3221] Fixed as per PR suggestion", "committedDate": "2020-09-10T09:30:24Z", "type": "commit"}, {"oid": "028b118d8ee2502486a0b689606e609c4c641205", "url": "https://github.com/kiegroup/kogito-runtimes/commit/028b118d8ee2502486a0b689606e609c4c641205", "message": "[KOGITO-3221] Fixed as per PR suggestion", "committedDate": "2020-09-10T09:32:00Z", "type": "commit"}, {"oid": "89cb14decb20502abd76fa08fb1a680f551d3b48", "url": "https://github.com/kiegroup/kogito-runtimes/commit/89cb14decb20502abd76fa08fb1a680f551d3b48", "message": "Merge remote-tracking branch 'origin/master' into KOGITO-3221\n\n# Conflicts:\n#\tdrools/kogito-pmml/src/test/java/org/kie/kogito/pmml/PmmlPredictionModelTest.java\n#\tkogito-build-parent/pom.xml", "committedDate": "2020-09-10T09:35:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyMzI5NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486623295", "bodyText": "What about catch ReflectiveOperationException so that we can simplify and cover all reflection related exceptions just with one?  Only ClassCastExpection will probably remain in addition", "author": "danielezonca", "createdAt": "2020-09-10T20:45:55Z", "path": "drools/kogito-pmml/src/main/java/org/kie/kogito/pmml/KieRuntimeFactoryBuilder.java", "diffHunk": "@@ -70,63 +73,65 @@ private KieRuntimeFactoryBuilder() {\n             final BiFunction<KnowledgeBuilderImpl, Resource, List<KiePMMLModel>> modelProducer) {\n         final Map<KieBase, KieRuntimeFactory> toReturn = new HashMap<>();\n         resources.forEach(resource -> {\n-            final String[] factoryClassNamePackageName = getFactoryClassNamePackageName(resource);\n             final KnowledgeBuilderImpl kbuilderImpl = createKnowledgeBuilderImpl(resource);\n             List<KiePMMLModel> toAdd = modelProducer.apply(kbuilderImpl, resource);\n             if (toAdd.isEmpty()) {\n                 throw new KiePMMLException(\"Failed to retrieve compiled models\");\n             }\n-            for (KiePMMLModel kiePMMLModel : toAdd) {\n-                InternalKnowledgePackage internalKnowledgePackage =\n-                        kbuilderImpl.getKnowledgeBase().getPackage(factoryClassNamePackageName[1]);\n-                if (internalKnowledgePackage == null) {\n-                    PackageDescr pkgDescr = new PackageDescr(kiePMMLModel.getKModulePackageName());\n-                    PackageRegistry pkgReg = kbuilderImpl.getOrCreatePackageRegistry(pkgDescr);\n-                    internalKnowledgePackage = pkgReg.getPackage();\n-                }\n-                PMMLPackage pmmlPkg =\n-                        internalKnowledgePackage.getResourceTypePackages().computeIfAbsent(\n-                                ResourceType.PMML,\n-                                rtp -> new PMMLPackageImpl());\n-                pmmlPkg.addAll(Collections.singletonList(kiePMMLModel));\n-            }\n+            addModels(kbuilderImpl, toAdd);\n             KieBase kieBase = kbuilderImpl.getKnowledgeBase();\n             toReturn.put(kieBase, KieRuntimeFactory.of(kieBase));\n         });\n         return toReturn;\n     }\n \n+    private static void addModels(final KnowledgeBuilderImpl kbuilderImpl, final List<KiePMMLModel> toAdd) {\n+        for (KiePMMLModel kiePMMLModel : toAdd) {\n+            PackageDescr pkgDescr = new PackageDescr(kiePMMLModel.getKModulePackageName());\n+            PackageRegistry pkgReg = kbuilderImpl.getOrCreatePackageRegistry(pkgDescr);\n+            InternalKnowledgePackage kpkgs = pkgReg.getPackage();\n+            PMMLPackage pmmlPkg =\n+                    kpkgs.getResourceTypePackages().computeIfAbsent(\n+                            ResourceType.PMML,\n+                            rtp -> new PMMLPackageImpl());\n+            pmmlPkg.addAll(Collections.singletonList(kiePMMLModel));\n+            if (kiePMMLModel instanceof HasNestedModels) {\n+                addModels(kbuilderImpl, ((HasNestedModels) kiePMMLModel).getNestedModels());\n+            }\n+        }\n+    }\n+\n     private static KnowledgeBuilderImpl createKnowledgeBuilderImpl(final Resource resource) {\n         KnowledgeBaseImpl defaultKnowledgeBase = new KnowledgeBaseImpl(\"PMML\", null);\n         KnowledgeBuilderImpl toReturn = new KnowledgeBuilderImpl(defaultKnowledgeBase);\n-        PredictionRuleMapper pmmlRuleMapper = loadPMMLRuleMapper(toReturn.getRootClassLoader(), resource);\n-        if (pmmlRuleMapper != null) {\n-            String ruleName = pmmlRuleMapper.getRuleName();\n-            Model model = loadModel(toReturn.getRootClassLoader(), ruleName);\n-            toReturn = new KnowledgeBuilderImpl(KieBaseBuilder.createKieBaseFromModel(model));\n+        List<PredictionRuleMapper> pmmlRuleMappers = loadPMMLRuleMappers(toReturn.getRootClassLoader(), resource);\n+        if (!pmmlRuleMappers.isEmpty()) {\n+            List<Model> models =\n+                    pmmlRuleMappers.stream()\n+                            .map(PredictionRuleMapper::getModel)\n+                            .collect(Collectors.toList());\n+            toReturn = new KnowledgeBuilderImpl(KieBaseBuilder.createKieBaseFromModel(models));\n         }\n         return toReturn;\n     }\n \n-    private static PredictionRuleMapper loadPMMLRuleMapper(final ClassLoader classLoader,\n-                                                           final Resource resource) {\n+    private static List<PredictionRuleMapper> loadPMMLRuleMappers(final ClassLoader classLoader,\n+                                                                  final Resource resource) {\n+        PredictionRuleMappers predictionRuleMappers = loadPMMLRuleMappersClass(classLoader, resource);\n+        return predictionRuleMappers.getPredictionRuleMappers();\n+    }\n+\n+    private static PredictionRuleMappers loadPMMLRuleMappersClass(final ClassLoader classLoader,\n+                                                                  final Resource resource) {\n         String[] classNamePackageName = getFactoryClassNamePackageName(resource);\n         String packageName = classNamePackageName[1];\n-        String fullPMMLRuleMapperClassName = packageName + \".PredictionRuleMapperImpl\";\n+        String fullPMMLRuleMappersClassName = packageName + \".PredictionRuleMappersImpl\";\n         try {\n-            return (PredictionRuleMapper) classLoader.loadClass(fullPMMLRuleMapperClassName).getDeclaredConstructor().newInstance();\n+            return (PredictionRuleMappers) classLoader.loadClass(fullPMMLRuleMappersClassName).getDeclaredConstructor().newInstance();\n         } catch (ClassNotFoundException | IllegalAccessException | InstantiationException | ClassCastException | NoSuchMethodException | InvocationTargetException e) {", "originalCommit": "89cb14decb20502abd76fa08fb1a680f551d3b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgyNTkyMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486825923", "bodyText": "@danielezonca\ndone", "author": "gitgabrio", "createdAt": "2020-09-11T07:27:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyMzI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyMzkyNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486623925", "bodyText": "Please add e to RuntimeException so that it will be possible to get the original clause", "author": "danielezonca", "createdAt": "2020-09-10T20:47:10Z", "path": "drools/kogito-pmml/src/main/java/org/kie/kogito/pmml/KieRuntimeFactoryBuilder.java", "diffHunk": "@@ -70,63 +73,65 @@ private KieRuntimeFactoryBuilder() {\n             final BiFunction<KnowledgeBuilderImpl, Resource, List<KiePMMLModel>> modelProducer) {\n         final Map<KieBase, KieRuntimeFactory> toReturn = new HashMap<>();\n         resources.forEach(resource -> {\n-            final String[] factoryClassNamePackageName = getFactoryClassNamePackageName(resource);\n             final KnowledgeBuilderImpl kbuilderImpl = createKnowledgeBuilderImpl(resource);\n             List<KiePMMLModel> toAdd = modelProducer.apply(kbuilderImpl, resource);\n             if (toAdd.isEmpty()) {\n                 throw new KiePMMLException(\"Failed to retrieve compiled models\");\n             }\n-            for (KiePMMLModel kiePMMLModel : toAdd) {\n-                InternalKnowledgePackage internalKnowledgePackage =\n-                        kbuilderImpl.getKnowledgeBase().getPackage(factoryClassNamePackageName[1]);\n-                if (internalKnowledgePackage == null) {\n-                    PackageDescr pkgDescr = new PackageDescr(kiePMMLModel.getKModulePackageName());\n-                    PackageRegistry pkgReg = kbuilderImpl.getOrCreatePackageRegistry(pkgDescr);\n-                    internalKnowledgePackage = pkgReg.getPackage();\n-                }\n-                PMMLPackage pmmlPkg =\n-                        internalKnowledgePackage.getResourceTypePackages().computeIfAbsent(\n-                                ResourceType.PMML,\n-                                rtp -> new PMMLPackageImpl());\n-                pmmlPkg.addAll(Collections.singletonList(kiePMMLModel));\n-            }\n+            addModels(kbuilderImpl, toAdd);\n             KieBase kieBase = kbuilderImpl.getKnowledgeBase();\n             toReturn.put(kieBase, KieRuntimeFactory.of(kieBase));\n         });\n         return toReturn;\n     }\n \n+    private static void addModels(final KnowledgeBuilderImpl kbuilderImpl, final List<KiePMMLModel> toAdd) {\n+        for (KiePMMLModel kiePMMLModel : toAdd) {\n+            PackageDescr pkgDescr = new PackageDescr(kiePMMLModel.getKModulePackageName());\n+            PackageRegistry pkgReg = kbuilderImpl.getOrCreatePackageRegistry(pkgDescr);\n+            InternalKnowledgePackage kpkgs = pkgReg.getPackage();\n+            PMMLPackage pmmlPkg =\n+                    kpkgs.getResourceTypePackages().computeIfAbsent(\n+                            ResourceType.PMML,\n+                            rtp -> new PMMLPackageImpl());\n+            pmmlPkg.addAll(Collections.singletonList(kiePMMLModel));\n+            if (kiePMMLModel instanceof HasNestedModels) {\n+                addModels(kbuilderImpl, ((HasNestedModels) kiePMMLModel).getNestedModels());\n+            }\n+        }\n+    }\n+\n     private static KnowledgeBuilderImpl createKnowledgeBuilderImpl(final Resource resource) {\n         KnowledgeBaseImpl defaultKnowledgeBase = new KnowledgeBaseImpl(\"PMML\", null);\n         KnowledgeBuilderImpl toReturn = new KnowledgeBuilderImpl(defaultKnowledgeBase);\n-        PredictionRuleMapper pmmlRuleMapper = loadPMMLRuleMapper(toReturn.getRootClassLoader(), resource);\n-        if (pmmlRuleMapper != null) {\n-            String ruleName = pmmlRuleMapper.getRuleName();\n-            Model model = loadModel(toReturn.getRootClassLoader(), ruleName);\n-            toReturn = new KnowledgeBuilderImpl(KieBaseBuilder.createKieBaseFromModel(model));\n+        List<PredictionRuleMapper> pmmlRuleMappers = loadPMMLRuleMappers(toReturn.getRootClassLoader(), resource);\n+        if (!pmmlRuleMappers.isEmpty()) {\n+            List<Model> models =\n+                    pmmlRuleMappers.stream()\n+                            .map(PredictionRuleMapper::getModel)\n+                            .collect(Collectors.toList());\n+            toReturn = new KnowledgeBuilderImpl(KieBaseBuilder.createKieBaseFromModel(models));\n         }\n         return toReturn;\n     }\n \n-    private static PredictionRuleMapper loadPMMLRuleMapper(final ClassLoader classLoader,\n-                                                           final Resource resource) {\n+    private static List<PredictionRuleMapper> loadPMMLRuleMappers(final ClassLoader classLoader,\n+                                                                  final Resource resource) {\n+        PredictionRuleMappers predictionRuleMappers = loadPMMLRuleMappersClass(classLoader, resource);\n+        return predictionRuleMappers.getPredictionRuleMappers();\n+    }\n+\n+    private static PredictionRuleMappers loadPMMLRuleMappersClass(final ClassLoader classLoader,\n+                                                                  final Resource resource) {\n         String[] classNamePackageName = getFactoryClassNamePackageName(resource);\n         String packageName = classNamePackageName[1];\n-        String fullPMMLRuleMapperClassName = packageName + \".PredictionRuleMapperImpl\";\n+        String fullPMMLRuleMappersClassName = packageName + \".PredictionRuleMappersImpl\";\n         try {\n-            return (PredictionRuleMapper) classLoader.loadClass(fullPMMLRuleMapperClassName).getDeclaredConstructor().newInstance();\n+            return (PredictionRuleMappers) classLoader.loadClass(fullPMMLRuleMappersClassName).getDeclaredConstructor().newInstance();\n         } catch (ClassNotFoundException | IllegalAccessException | InstantiationException | ClassCastException | NoSuchMethodException | InvocationTargetException e) {\n-            logger.info(String.format(\"%s class not found in rootClassLoader\", fullPMMLRuleMapperClassName));\n-            return null;\n+            throw new RuntimeException(String.format(\"%s class not found in rootClassLoader\",\n+                                                     fullPMMLRuleMappersClassName));", "originalCommit": "89cb14decb20502abd76fa08fb1a680f551d3b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgyNjA1Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486826052", "bodyText": "@danielezonca\ndone", "author": "gitgabrio", "createdAt": "2020-09-11T07:27:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyMzkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNDU4Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486624583", "bodyText": "Can you please review this change? The new predictionRuleMappers seems unused", "author": "danielezonca", "createdAt": "2020-09-10T20:48:36Z", "path": "drools/kogito-pmml/src/main/java/org/kie/kogito/pmml/PMMLKogito.java", "diffHunk": "@@ -52,7 +53,7 @@ private PMMLKogito() {\n      * Use {@link Application#predictionModels()} of Kogito API to programmatically access PMML assets and evaluate\n      * PMML decisions.\n      */\n-    public static Map<KieBase, KieRuntimeFactory> createKieRuntimeFactories(String... pmmlPaths) {\n+    public static Map<KieBase, KieRuntimeFactory> createKieRuntimeFactories(List<PredictionRuleMappers> predictionRuleMappers, String... pmmlPaths) {", "originalCommit": "89cb14decb20502abd76fa08fb1a680f551d3b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgzNTkzMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486835933", "bodyText": "@danielezonca\ndone", "author": "gitgabrio", "createdAt": "2020-09-11T07:47:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNDU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNDc3Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486624773", "bodyText": "Javadoc?", "author": "danielezonca", "createdAt": "2020-09-10T20:49:00Z", "path": "drools/kogito-pmml/src/main/java/org/kie/kogito/prediction/PredictionRuleMappers.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.prediction;\n+\n+import java.util.List;\n+\n+public interface PredictionRuleMappers {", "originalCommit": "89cb14decb20502abd76fa08fb1a680f551d3b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgzNTk2Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486835963", "bodyText": "@danielezonca\ndone", "author": "gitgabrio", "createdAt": "2020-09-11T07:47:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNDc3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNzA4OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486627089", "bodyText": "2020", "author": "danielezonca", "createdAt": "2020-09-10T20:53:30Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/prediction/PredictionRuleMappersGenerator.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.", "originalCommit": "89cb14decb20502abd76fa08fb1a680f551d3b48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6dce353b6ce514a46396c57d31cf3dc0dfbf14e7", "url": "https://github.com/kiegroup/kogito-runtimes/commit/6dce353b6ce514a46396c57d31cf3dc0dfbf14e7", "message": "[KOGITO-3221] Fixed as per PR suggestion", "committedDate": "2020-09-11T09:02:18Z", "type": "commit"}, {"oid": "a8039ecd36cafc2c211749a50d9cc8b66341ca04", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a8039ecd36cafc2c211749a50d9cc8b66341ca04", "message": "[KOGITO-3221] Fixing tests. Fixing PMMLRuleMappers retrieval management", "committedDate": "2020-09-11T10:04:28Z", "type": "commit"}, {"oid": "3c0caad94943959b654d64dd53a89a8f20b1683b", "url": "https://github.com/kiegroup/kogito-runtimes/commit/3c0caad94943959b654d64dd53a89a8f20b1683b", "message": "Merge remote-tracking branch 'origin/master' into KOGITO-3221", "committedDate": "2020-09-14T06:51:03Z", "type": "commit"}, {"oid": "c99c63347479cfb487ecf51d27c561c3f55be711", "url": "https://github.com/kiegroup/kogito-runtimes/commit/c99c63347479cfb487ecf51d27c561c3f55be711", "message": "Merge remote-tracking branch 'origin/master' into KOGITO-3221", "committedDate": "2020-09-15T07:04:29Z", "type": "commit"}, {"oid": "52ed49979dccd2b5be2002610a9ec21938722e3c", "url": "https://github.com/kiegroup/kogito-runtimes/commit/52ed49979dccd2b5be2002610a9ec21938722e3c", "message": "[KOGITO-3221] Merged with master. Updated DROOLS version to tag release", "committedDate": "2020-09-15T07:07:03Z", "type": "commit"}]}