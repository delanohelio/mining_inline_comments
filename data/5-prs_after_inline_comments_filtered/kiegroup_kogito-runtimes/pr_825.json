{"pr_number": 825, "pr_title": "KOGITO-3073 Kafka persistence addon", "pr_createdAt": "2020-10-14T06:32:00Z", "pr_url": "https://github.com/kiegroup/kogito-runtimes/pull/825", "timeline": [{"oid": "9a2fc4aedbe8ca5a65d1c1f76e10c675ac9aa167", "url": "https://github.com/kiegroup/kogito-runtimes/commit/9a2fc4aedbe8ca5a65d1c1f76e10c675ac9aa167", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2020-10-14T06:42:31Z", "type": "forcePushed"}, {"oid": "6d9939fc38d86843a5f4b78d3ad3926766b36c99", "url": "https://github.com/kiegroup/kogito-runtimes/commit/6d9939fc38d86843a5f4b78d3ad3926766b36c99", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2020-11-26T14:43:39Z", "type": "forcePushed"}, {"oid": "8affe25c07610759435303d251cfb993f73c0483", "url": "https://github.com/kiegroup/kogito-runtimes/commit/8affe25c07610759435303d251cfb993f73c0483", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-01-21T02:48:25Z", "type": "forcePushed"}, {"oid": "9e90fbc5bac886986406040e8b072a83c808e486", "url": "https://github.com/kiegroup/kogito-runtimes/commit/9e90fbc5bac886986406040e8b072a83c808e486", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-01-21T05:33:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE3MzY3Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562173672", "bodyText": "This method returns all the protos (+ list JSON) used by the operator to export them to data index so I think we should move this code outside single persistence types and bind it to the add-on that produce data index events.\nWdyt?\nSide note this change is in conflict with #967\n/cc @r00ta", "author": "danielezonca", "createdAt": "2021-01-21T20:23:51Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java", "diffHunk": "@@ -147,6 +144,46 @@ public String persistenceType() {\n             persistenceProviderClazz.addMember(templateNameField);\n             persistenceProviderClazz.addMember(templateNameMethod);\n         }\n+        \n+        return protobufBasedPersistence(persistenceProviderClazz);\n+    }\n+\n+    protected Collection<GeneratedFile> kafkaBasedPersistence() {\n+        ClassOrInterfaceDeclaration persistenceProviderClazz = new ClassOrInterfaceDeclaration()\n+                .setName(KOGITO_PROCESS_INSTANCE_FACTORY_IMPL)\n+                .setModifiers(Modifier.Keyword.PUBLIC)\n+                .addExtendedType(KOGITO_PROCESS_INSTANCE_FACTORY_PACKAGE);\n+\n+        if (context().hasDI()) {\n+            context().getDependencyInjectionAnnotator().withApplicationComponent(persistenceProviderClazz);\n+        }\n+\n+        Collection<GeneratedFile> generatedFiles = protobufBasedPersistence(persistenceProviderClazz);\n+\n+        CompilationUnit parsedClazzFile = parse(this.getClass().getResourceAsStream(\"/class-templates/persistence/KafkaStreamsTopologyProducerTemplate.java\"));\n+\n+        ClassOrInterfaceDeclaration producer = parsedClazzFile.getClassByName(\"KafkaStreamsTopologyProducer\").get();\n+        \n+        MethodCallExpr asListOfProcesses = new MethodCallExpr(new NameExpr(\"java.util.Arrays\"), \"asList\");\n+\n+        protoGenerator.getProcessIds().forEach(p -> asListOfProcesses.addArgument(new StringLiteralExpr(p)));\n+        producer.getFieldByName(\"processes\").get().getVariable(0).setInitializer(asListOfProcesses);\n+\n+        String clazzName = KOGITO_PROCESS_INSTANCE_PACKAGE + \".\" + producer.getName().asString();\n+        generatedFiles.add(new GeneratedFile(GeneratedFileType.SOURCE,\n+                                             clazzName.replace('.', '/') + \".java\",\n+                                             parsedClazzFile.toString()));\n+        return generatedFiles;\n+    }\n+    \n+    private Collection<GeneratedFile> protobufBasedPersistence(ClassOrInterfaceDeclaration persistenceProviderClazz){\n+        CompilationUnit compilationUnit = new CompilationUnit(KOGITO_PROCESS_INSTANCE_PACKAGE);\n+        compilationUnit.getTypes().add(persistenceProviderClazz);\n+\n+        Collection<GeneratedFile> generatedFiles = new ArrayList<>(protoGenerator.generateProtoFiles());", "originalCommit": "9e90fbc5bac886986406040e8b072a83c808e486", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjQzNjU2MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562436560", "bodyText": "@danielezonca agree I did a minor tweak now to have the proto always generated, and we review and further enhance later.", "author": "cristianonicolai", "createdAt": "2021-01-22T07:30:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE3MzY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDQxNDAwNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r564414004", "bodyText": "Hi, I was about to start working on #967 for the proto files. But since the changes are already in this PR I'll close it fyi", "author": "r00ta", "createdAt": "2021-01-26T10:41:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE3MzY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE4MzMzNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562183336", "bodyText": "I think you can use existing generatedAnnotation field", "author": "danielezonca", "createdAt": "2021-01-21T20:41:10Z", "path": "kogito-quarkus-extension/deployment/src/main/java/org/kie/kogito/quarkus/deployment/JandexProtoGenerator.java", "diffHunk": "@@ -102,6 +106,18 @@ public Proto generate(String messageComment, String fieldComment, String package\n         return parameters;\n     }\n \n+    @Override\n+    public Set<String> getProcessIds() {\n+        return modelClasses.stream().map(c -> {\n+            AnnotationInstance instance = c.classAnnotation(DotName.createSimple(Generated.class.getCanonicalName()));", "originalCommit": "9e90fbc5bac886986406040e8b072a83c808e486", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjQzNjEwNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562436105", "bodyText": "+1", "author": "cristianonicolai", "createdAt": "2021-01-22T07:29:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE4MzMzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE4NDIzNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562184235", "bodyText": "Can you please describe in the ticket what a kafka topology is and the relation with ktable?", "author": "danielezonca", "createdAt": "2021-01-21T20:42:56Z", "path": "kogito-codegen/src/main/resources/class-templates/persistence/KafkaStreamsTopologyProducerTemplate.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+\n+import org.apache.kafka.streams.Topology;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+\n+@ApplicationScoped\n+public class KafkaStreamsTopologyProducer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaStreamsTopologyProducer.class);\n+\n+    private List<String> processes = Arrays.asList();\n+\n+    @Produces\n+    public Topology buildTopology() {", "originalCommit": "9e90fbc5bac886986406040e8b072a83c808e486", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjQzNjA5NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562436094", "bodyText": "working on a doc for that", "author": "cristianonicolai", "createdAt": "2021-01-22T07:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE4NDIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYwODQ4Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562608483", "bodyText": "Great thanks \ud83d\udc4d", "author": "danielezonca", "createdAt": "2021-01-22T12:48:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE4NDIzNQ=="}], "type": "inlineReview"}, {"oid": "970d8591278df327a508211eea0fcdd42b826144", "url": "https://github.com/kiegroup/kogito-runtimes/commit/970d8591278df327a508211eea0fcdd42b826144", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-01-22T02:16:12Z", "type": "forcePushed"}, {"oid": "c4479ba8815eaa3ae202c0e66f7bdc53bfbb8f24", "url": "https://github.com/kiegroup/kogito-runtimes/commit/c4479ba8815eaa3ae202c0e66f7bdc53bfbb8f24", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-01-22T08:40:27Z", "type": "forcePushed"}, {"oid": "cfa5bdc0f3e20e0ce2334b5a9100652ffabda740", "url": "https://github.com/kiegroup/kogito-runtimes/commit/cfa5bdc0f3e20e0ce2334b5a9100652ffabda740", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-01-22T10:47:49Z", "type": "forcePushed"}, {"oid": "68c1854e5ed94fa96ad8296153f08f8f08da011e", "url": "https://github.com/kiegroup/kogito-runtimes/commit/68c1854e5ed94fa96ad8296153f08f8f08da011e", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-01-22T11:58:59Z", "type": "forcePushed"}, {"oid": "7cb3890af384c1abbb28fafa5622c7c794af5765", "url": "https://github.com/kiegroup/kogito-runtimes/commit/7cb3890af384c1abbb28fafa5622c7c794af5765", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-01T06:07:44Z", "type": "forcePushed"}, {"oid": "1f3cb4a037745998c7d3e05c24500971e812526a", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1f3cb4a037745998c7d3e05c24500971e812526a", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-02T02:05:02Z", "type": "forcePushed"}, {"oid": "0db2eff4fa7e3d22e0b148825bf995ffeeef8dd2", "url": "https://github.com/kiegroup/kogito-runtimes/commit/0db2eff4fa7e3d22e0b148825bf995ffeeef8dd2", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-02T04:30:44Z", "type": "forcePushed"}, {"oid": "72c4b39fec40aa5d1882ee3c89c59a613e434474", "url": "https://github.com/kiegroup/kogito-runtimes/commit/72c4b39fec40aa5d1882ee3c89c59a613e434474", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-02T11:34:12Z", "type": "forcePushed"}, {"oid": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-02T11:39:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg0NDAzMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r566844033", "bodyText": "If new KafkaProcessInstancesFactory() fails this could be null", "author": "danielezonca", "createdAt": "2021-01-29T14:05:59Z", "path": "addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.Topology;\n+import org.drools.core.io.impl.ClassPathResource;\n+import org.jbpm.process.instance.impl.Action;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Node;\n+import org.kie.api.definition.process.WorkflowProcess;\n+import org.kie.kogito.auth.IdentityProviders;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.persistence.KogitoProcessInstancesFactory;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.ProcessInstances;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.bpmn2.BpmnProcess;\n+import org.kie.kogito.process.bpmn2.BpmnVariables;\n+import org.kie.kogito.testcontainers.KogitoKafkaContainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testcontainers.junit.jupiter.Container;\n+import org.testcontainers.junit.jupiter.Testcontainers;\n+\n+import static java.util.Collections.singletonMap;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+import static org.kie.kogito.process.ProcessInstance.STATE_COMPLETED;\n+import static org.kie.kogito.process.ProcessInstance.STATE_ERROR;\n+\n+@Testcontainers\n+public class KafkaProcessInstancesIT {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstancesIT.class);\n+\n+    @Container\n+    KogitoKafkaContainer kafka = new KogitoKafkaContainer();\n+\n+    KafkaProcessInstancesFactory factory;\n+\n+    @BeforeEach\n+    void start() {\n+        factory = new KafkaProcessInstancesFactory();\n+        factory.setKafkaConfig(singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()));\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        factory.stop();", "originalCommit": "68c1854e5ed94fa96ad8296153f08f8f08da011e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNjc0OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571816748", "bodyText": "fixed", "author": "cristianonicolai", "createdAt": "2021-02-08T07:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg0NDAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg0NDg2MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r566844861", "bodyText": "Can you please clarify why this workaround? What about (in another PR of course) convert scripts to lambdas?", "author": "danielezonca", "createdAt": "2021-01-29T14:07:18Z", "path": "addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.Topology;\n+import org.drools.core.io.impl.ClassPathResource;\n+import org.jbpm.process.instance.impl.Action;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Node;\n+import org.kie.api.definition.process.WorkflowProcess;\n+import org.kie.kogito.auth.IdentityProviders;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.persistence.KogitoProcessInstancesFactory;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.ProcessInstances;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.bpmn2.BpmnProcess;\n+import org.kie.kogito.process.bpmn2.BpmnVariables;\n+import org.kie.kogito.testcontainers.KogitoKafkaContainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testcontainers.junit.jupiter.Container;\n+import org.testcontainers.junit.jupiter.Testcontainers;\n+\n+import static java.util.Collections.singletonMap;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+import static org.kie.kogito.process.ProcessInstance.STATE_COMPLETED;\n+import static org.kie.kogito.process.ProcessInstance.STATE_ERROR;\n+\n+@Testcontainers\n+public class KafkaProcessInstancesIT {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstancesIT.class);\n+\n+    @Container\n+    KogitoKafkaContainer kafka = new KogitoKafkaContainer();\n+\n+    KafkaProcessInstancesFactory factory;\n+\n+    @BeforeEach\n+    void start() {\n+        factory = new KafkaProcessInstancesFactory();\n+        factory.setKafkaConfig(singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()));\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        factory.stop();\n+        if (factory.getKafkaStreams() != null) {\n+            factory.getKafkaStreams().close();\n+        }\n+    }\n+\n+    @Test\n+    void testFindByIdReadMode() {\n+        BpmnProcess process = BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask-Script.bpmn2\")).get(0);\n+        // workaround as BpmnProcess does not compile the scripts but just reads the xml\n+        for (Node node : ((WorkflowProcess) process.process()).getNodes()) {\n+            if (node instanceof ActionNode) {\n+                DroolsAction a = ((ActionNode) node).getAction();\n+                a.setMetaData(\"Action\", (Action) kcontext -> {\n+                    System.out.println(\"The variable value is \" + kcontext.getVariable(\"s\") + \" about to call toString on it\");\n+                    kcontext.getVariable(\"s\").toString();\n+                });\n+            }\n+        }", "originalCommit": "68c1854e5ed94fa96ad8296153f08f8f08da011e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNjc2OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571816768", "bodyText": "its not needed anymore", "author": "cristianonicolai", "createdAt": "2021-02-08T07:00:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg0NDg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU4Njg2NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568586865", "bodyText": "Please use TemplatedGenerator\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    CompilationUnit parsedClazzFile = parse(this.getClass().getResourceAsStream(\"/class-templates/persistence/KafkaStreamsTopologyProducerJavaTemplate.java\"));\n          \n          \n            \n                    TemplatedGenerator generator = TemplatedGenerator.builder()\n          \n          \n            \n                                .withTemplateBasePath(\"/class-templates/persistence/\")\n          \n          \n            \n                                .withFallbackContext(JavaKogitoBuildContext.CONTEXT_NAME)\n          \n          \n            \n                                .build(context(), \"KafkaStreamsTopologyProducer\");\n          \n          \n            \n                    CompilationUnit parsedClazzFile = generator.compilationUnitOrThrow();", "author": "danielezonca", "createdAt": "2021-02-02T13:07:44Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java", "diffHunk": "@@ -147,6 +155,44 @@ public String persistenceType() {\n             persistenceProviderClazz.addMember(templateNameField);\n             persistenceProviderClazz.addMember(templateNameMethod);\n         }\n+        \n+        return protobufBasedPersistence(persistenceProviderClazz);\n+    }\n+\n+    protected Collection<GeneratedFile> kafkaBasedPersistence() {\n+        ClassOrInterfaceDeclaration persistenceProviderClazz = new ClassOrInterfaceDeclaration()\n+                .setName(KOGITO_PROCESS_INSTANCE_FACTORY_IMPL)\n+                .setModifiers(Modifier.Keyword.PUBLIC)\n+                .addExtendedType(KOGITO_PROCESS_INSTANCE_FACTORY_PACKAGE);\n+\n+        if (context().hasDI()) {\n+            context().getDependencyInjectionAnnotator().withApplicationComponent(persistenceProviderClazz);\n+        }\n+\n+        Collection<GeneratedFile> generatedFiles = protobufBasedPersistence(persistenceProviderClazz);\n+\n+        CompilationUnit parsedClazzFile = parse(this.getClass().getResourceAsStream(\"/class-templates/persistence/KafkaStreamsTopologyProducerJavaTemplate.java\"));", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNjgwOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571816809", "bodyText": "done", "author": "cristianonicolai", "createdAt": "2021-02-08T07:00:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU4Njg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU4OTk2OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568589969", "bodyText": "This class is a *JavaTemplate but it seems to be a Quarkus one (it uses CDI). I think we need also a *SpringTemplate", "author": "danielezonca", "createdAt": "2021-02-02T13:12:48Z", "path": "kogito-codegen/src/main/resources/class-templates/persistence/KafkaStreamsTopologyProducerJavaTemplate.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+\n+import org.apache.kafka.streams.Topology;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+\n+@ApplicationScoped\n+public class KafkaStreamsTopologyProducer {", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg5NTMyMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568895320", "bodyText": "and do we really need a template? or this could be a static class? I mean what is injected during codegen?", "author": "tiagodolphine", "createdAt": "2021-02-02T20:07:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU4OTk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNjg2Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571816867", "bodyText": "@danielezonca there is no support for spring at this stage, will need to be done later one if we think there is need to\n@tiagodolphine I needed to inject ( statically ) the process ids in order to create the topics needed for kafka. I cant inject @Process as it would cause a circle dependency, so decided to do a build time generation.", "author": "cristianonicolai", "createdAt": "2021-02-08T07:00:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU4OTk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU5MTE5Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568591196", "bodyText": "What about add checks on proto in this test too (like this)?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertThat(generatedFiles).hasSize(3);\n          \n          \n            \n                    assertThat(generatedFiles.stream().filter(gf -> gf.type().equals(ProtoGenerator.PROTO_TYPE)).count()).isEqualTo(2);\n          \n          \n            \n                    assertThat(generatedFiles.stream().filter(gf -> gf.type().equals(ProtoGenerator.PROTO_TYPE) && gf.relativePath().endsWith(\".json\")).count()).isEqualTo(1);\n          \n          \n            \n            \n          \n          \n            \n                    assertThat(generatedFiles).hasSize(3);", "author": "danielezonca", "createdAt": "2021-02-02T13:14:52Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/persistence/FileSystemPersistenceGeneratorTest.java", "diffHunk": "@@ -57,7 +57,7 @@ void test() {\n                 protoGenerator);\n         Collection<GeneratedFile> generatedFiles = persistenceGenerator.generate();\n \n-        assertThat(generatedFiles).hasSize(1);\n+        assertThat(generatedFiles).hasSize(3);", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNjkzNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571816935", "bodyText": "done, thanks", "author": "cristianonicolai", "createdAt": "2021-02-08T07:00:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU5MTE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg3ODE3Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568878173", "bodyText": "remove commented code?", "author": "tiagodolphine", "createdAt": "2021-02-02T19:38:02Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.kafka.KafkaProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstancesFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+\n+/**\n+ * This class must always have exact FQCN as <code>org.kie.kogito.persistence.KogitoProcessInstancesFactory</code>\n+ */\n+public abstract class KogitoProcessInstancesFactory implements ProcessInstancesFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KogitoProcessInstancesFactory.class);\n+\n+    Map<String, Object> kafkaConfig;\n+    KafkaStreams streams;\n+    List<KafkaProducer<String, byte[]>> producers = new ArrayList<>();\n+\n+    @Inject\n+    @Named(\"default-kafka-broker\")\n+    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n+        this.kafkaConfig = kafkaConfig;\n+    }\n+\n+    public KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+    }\n+\n+    @PreDestroy\n+    public void stop() {\n+        producers.forEach(p -> p.close());\n+    }\n+\n+    public KafkaProcessInstances createProcessInstances(Process<?> process) {\n+        try {\n+            LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n+            KafkaProducer<String, byte[]> producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n+            producers.add(producer);\n+            return new KafkaProcessInstances(process, topicName(process.id()), supplyStore(process), producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+        } catch (Exception ex) {\n+            ex.printStackTrace();\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    //Store can only be accessed after the Kafka Streams has started \n+    protected Supplier<ReadOnlyKeyValueStore<String, byte[]>> supplyStore(Process<?> process) {\n+//        ReadOnlyKeyValueStore<String, byte[]> store = null;", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNjk2Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571816962", "bodyText": "done", "author": "cristianonicolai", "createdAt": "2021-02-08T07:00:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg3ODE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4MDU0MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568880541", "bodyText": "what about using a listerner for the state? for example streams.setStateListener(....) in this way we can get rid of the Thread.sleep", "author": "tiagodolphine", "createdAt": "2021-02-02T19:42:00Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.kafka.KafkaProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstancesFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+\n+/**\n+ * This class must always have exact FQCN as <code>org.kie.kogito.persistence.KogitoProcessInstancesFactory</code>\n+ */\n+public abstract class KogitoProcessInstancesFactory implements ProcessInstancesFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KogitoProcessInstancesFactory.class);\n+\n+    Map<String, Object> kafkaConfig;\n+    KafkaStreams streams;\n+    List<KafkaProducer<String, byte[]>> producers = new ArrayList<>();\n+\n+    @Inject\n+    @Named(\"default-kafka-broker\")\n+    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n+        this.kafkaConfig = kafkaConfig;\n+    }\n+\n+    public KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+    }\n+\n+    @PreDestroy\n+    public void stop() {\n+        producers.forEach(p -> p.close());\n+    }\n+\n+    public KafkaProcessInstances createProcessInstances(Process<?> process) {\n+        try {\n+            LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n+            KafkaProducer<String, byte[]> producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n+            producers.add(producer);\n+            return new KafkaProcessInstances(process, topicName(process.id()), supplyStore(process), producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+        } catch (Exception ex) {\n+            ex.printStackTrace();\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    //Store can only be accessed after the Kafka Streams has started \n+    protected Supplier<ReadOnlyKeyValueStore<String, byte[]>> supplyStore(Process<?> process) {\n+//        ReadOnlyKeyValueStore<String, byte[]> store = null;\n+        return () -> {\n+//            if (store != null) {\n+//                return store;\n+//            }\n+            while (streams.state() == KafkaStreams.State.CREATED || streams.state() == KafkaStreams.State.REBALANCING) {", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNjk5NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571816994", "bodyText": "+1", "author": "cristianonicolai", "createdAt": "2021-02-08T07:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4MDU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4MDk1NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568880955", "bodyText": "log instead of printStackTrace would be bettter", "author": "tiagodolphine", "createdAt": "2021-02-02T19:42:43Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.kafka.KafkaProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstancesFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+\n+/**\n+ * This class must always have exact FQCN as <code>org.kie.kogito.persistence.KogitoProcessInstancesFactory</code>\n+ */\n+public abstract class KogitoProcessInstancesFactory implements ProcessInstancesFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KogitoProcessInstancesFactory.class);\n+\n+    Map<String, Object> kafkaConfig;\n+    KafkaStreams streams;\n+    List<KafkaProducer<String, byte[]>> producers = new ArrayList<>();\n+\n+    @Inject\n+    @Named(\"default-kafka-broker\")\n+    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n+        this.kafkaConfig = kafkaConfig;\n+    }\n+\n+    public KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+    }\n+\n+    @PreDestroy\n+    public void stop() {\n+        producers.forEach(p -> p.close());\n+    }\n+\n+    public KafkaProcessInstances createProcessInstances(Process<?> process) {\n+        try {\n+            LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n+            KafkaProducer<String, byte[]> producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n+            producers.add(producer);\n+            return new KafkaProcessInstances(process, topicName(process.id()), supplyStore(process), producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+        } catch (Exception ex) {\n+            ex.printStackTrace();", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNzAxMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571817011", "bodyText": "done", "author": "cristianonicolai", "createdAt": "2021-02-08T07:01:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4MDk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4OTgzNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568889834", "bodyText": "maybe using store.approximateNumEntries() would be better in this way it is not necessary to fetch all entries to sum, wdyt?", "author": "tiagodolphine", "createdAt": "2021-02-02T19:57:43Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.process.ProcessInstanceReadMode.MUTABLE;\n+\n+public class KafkaProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstances.class);\n+\n+    private Process<?> process;\n+    private KafkaProducer<String, byte[]> producer;\n+    private String topic;\n+    private ReadOnlyKeyValueStore<String, byte[]> store;\n+    private ProcessInstanceMarshaller marshaller;\n+\n+    public KafkaProcessInstances(Process<?> process, String topic, Supplier<ReadOnlyKeyValueStore<String, byte[]>> storeSupplier, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+        this.process = process;\n+        this.topic = topic;\n+        this.producer = producer;\n+        this.marshaller = new ProcessInstanceMarshaller(new ProtoStreamObjectMarshallingStrategy(proto, marshallers));\n+        this.store = storeSupplier.get();\n+    }\n+\n+    @Override\n+    public boolean exists(String id) {\n+        return store.get(id) != null;\n+    }\n+\n+    @Override\n+    public void create(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            if (store.get(id) != null) {\n+                throw new ProcessInstanceDuplicatedException(id);\n+            }\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to persist process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void update(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to update process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void remove(String id) {\n+        try {\n+            producer.send(new ProducerRecord<>(topic, id, null)).get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unable to remove process instance id: \" + id, e);\n+        }\n+    }\n+\n+    @Override\n+    public Optional<ProcessInstance> findById(String id, ProcessInstanceReadMode mode) {\n+        byte[] data = store.get(id);\n+        if (data == null) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(mode == MUTABLE ?\n+                                   marshaller.unmarshallProcessInstance(data, process) :\n+                                   marshaller.unmarshallReadOnlyProcessInstance(data, process)\n+        );\n+    }\n+\n+    @Override\n+    public Collection<ProcessInstance> values(ProcessInstanceReadMode mode) {\n+        final List<ProcessInstance> instances = new ArrayList<>();\n+        try (final KeyValueIterator<String, byte[]> iterator = store.all()) {\n+            while (iterator.hasNext()) {\n+                instances.add(mode == MUTABLE ?\n+                                      marshaller.unmarshallProcessInstance(iterator.next().value, process) :\n+                                      marshaller.unmarshallReadOnlyProcessInstance(iterator.next().value, process)\n+                );\n+            }\n+            return instances;\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unable to read process instances \", e);\n+        }\n+    }\n+\n+    @Override\n+    public Integer size() {\n+        int size = 0;\n+        try (final KeyValueIterator<String, byte[]> iterator = store.all()) {", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNzQxNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571817417", "bodyText": "I changed to use that, but isnt reliable, or it does get updated from time to time, so in order to use this way, I removed it from the tests.", "author": "cristianonicolai", "createdAt": "2021-02-08T07:02:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4OTgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg5MjQzNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568892436", "bodyText": "I already said that but every time I see all() it hurts me :P  at some point we need to revisit this values() method in runtimes, anyway just saying.", "author": "tiagodolphine", "createdAt": "2021-02-02T20:02:00Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.process.ProcessInstanceReadMode.MUTABLE;\n+\n+public class KafkaProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstances.class);\n+\n+    private Process<?> process;\n+    private KafkaProducer<String, byte[]> producer;\n+    private String topic;\n+    private ReadOnlyKeyValueStore<String, byte[]> store;\n+    private ProcessInstanceMarshaller marshaller;\n+\n+    public KafkaProcessInstances(Process<?> process, String topic, Supplier<ReadOnlyKeyValueStore<String, byte[]>> storeSupplier, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+        this.process = process;\n+        this.topic = topic;\n+        this.producer = producer;\n+        this.marshaller = new ProcessInstanceMarshaller(new ProtoStreamObjectMarshallingStrategy(proto, marshallers));\n+        this.store = storeSupplier.get();\n+    }\n+\n+    @Override\n+    public boolean exists(String id) {\n+        return store.get(id) != null;\n+    }\n+\n+    @Override\n+    public void create(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            if (store.get(id) != null) {\n+                throw new ProcessInstanceDuplicatedException(id);\n+            }\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to persist process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void update(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to update process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void remove(String id) {\n+        try {\n+            producer.send(new ProducerRecord<>(topic, id, null)).get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unable to remove process instance id: \" + id, e);\n+        }\n+    }\n+\n+    @Override\n+    public Optional<ProcessInstance> findById(String id, ProcessInstanceReadMode mode) {\n+        byte[] data = store.get(id);\n+        if (data == null) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(mode == MUTABLE ?\n+                                   marshaller.unmarshallProcessInstance(data, process) :\n+                                   marshaller.unmarshallReadOnlyProcessInstance(data, process)\n+        );\n+    }\n+\n+    @Override\n+    public Collection<ProcessInstance> values(ProcessInstanceReadMode mode) {\n+        final List<ProcessInstance> instances = new ArrayList<>();\n+        try (final KeyValueIterator<String, byte[]> iterator = store.all()) {", "originalCommit": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTgxNzY3Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r571817677", "bodyText": "+1, not happy about this either :) but its the same for all persistence types, should really be used for tests only", "author": "cristianonicolai", "createdAt": "2021-02-08T07:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg5MjQzNg=="}], "type": "inlineReview"}, {"oid": "633430c163438bed2b8989df88c4fcbc93e82871", "url": "https://github.com/kiegroup/kogito-runtimes/commit/633430c163438bed2b8989df88c4fcbc93e82871", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-03T03:58:22Z", "type": "forcePushed"}, {"oid": "6f22b0b4c948ecb83ec85f1f6ba8daa1b84b52cf", "url": "https://github.com/kiegroup/kogito-runtimes/commit/6f22b0b4c948ecb83ec85f1f6ba8daa1b84b52cf", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-04T01:01:28Z", "type": "forcePushed"}, {"oid": "ede1cb4064c89d1b2f4fc8577b0602d3e81348af", "url": "https://github.com/kiegroup/kogito-runtimes/commit/ede1cb4064c89d1b2f4fc8577b0602d3e81348af", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-04T08:33:25Z", "type": "forcePushed"}, {"oid": "9cecb263d0ebb610ae1d54509cb9561437d3e33e", "url": "https://github.com/kiegroup/kogito-runtimes/commit/9cecb263d0ebb610ae1d54509cb9561437d3e33e", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-04T09:18:08Z", "type": "forcePushed"}, {"oid": "27327e054b73b72e065a160fe42059ba4776df71", "url": "https://github.com/kiegroup/kogito-runtimes/commit/27327e054b73b72e065a160fe42059ba4776df71", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-05T06:09:56Z", "type": "forcePushed"}, {"oid": "eba1a010fed2d94fef88bef28ce3c3d498eb2d02", "url": "https://github.com/kiegroup/kogito-runtimes/commit/eba1a010fed2d94fef88bef28ce3c3d498eb2d02", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-05T07:35:25Z", "type": "forcePushed"}, {"oid": "494bee99defc436f1c88fb00356bb81095ac1865", "url": "https://github.com/kiegroup/kogito-runtimes/commit/494bee99defc436f1c88fb00356bb81095ac1865", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-08T03:47:19Z", "type": "forcePushed"}, {"oid": "29159a9f025be375f7d1dde948732c6b8951f6ff", "url": "https://github.com/kiegroup/kogito-runtimes/commit/29159a9f025be375f7d1dde948732c6b8951f6ff", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-08T07:40:32Z", "type": "forcePushed"}, {"oid": "8291208a7fdbc2b9e2c5c89702060eccd1181a82", "url": "https://github.com/kiegroup/kogito-runtimes/commit/8291208a7fdbc2b9e2c5c89702060eccd1181a82", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-08T11:55:10Z", "type": "forcePushed"}, {"oid": "95ffd75ab52b23dcfd4fc83df24f356547c3b9cf", "url": "https://github.com/kiegroup/kogito-runtimes/commit/95ffd75ab52b23dcfd4fc83df24f356547c3b9cf", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-08T11:56:08Z", "type": "forcePushed"}, {"oid": "c1b58ae3e223447875d6dde4127472a981e15fb0", "url": "https://github.com/kiegroup/kogito-runtimes/commit/c1b58ae3e223447875d6dde4127472a981e15fb0", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-08T15:17:25Z", "type": "forcePushed"}, {"oid": "04f611739e7cf099fd05e3b4aa3ecfd485e93318", "url": "https://github.com/kiegroup/kogito-runtimes/commit/04f611739e7cf099fd05e3b4aa3ecfd485e93318", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-08T15:24:58Z", "type": "forcePushed"}, {"oid": "0190a1a1283fb5ca6da0625d00ce0ed868dc1bf9", "url": "https://github.com/kiegroup/kogito-runtimes/commit/0190a1a1283fb5ca6da0625d00ce0ed868dc1bf9", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-09T05:37:29Z", "type": "forcePushed"}, {"oid": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "url": "https://github.com/kiegroup/kogito-runtimes/commit/8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-09T06:40:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc4MDA0Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572780046", "bodyText": "Can't this be called in parallel during injection and initialization of the process endpoints?", "author": "MarianMacik", "createdAt": "2021-02-09T10:46:56Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.kafka.KafkaProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstancesFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class must always have exact FQCN as <code>org.kie.kogito.persistence.KogitoProcessInstancesFactory</code>\n+ */\n+public abstract class KogitoProcessInstancesFactory implements ProcessInstancesFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KogitoProcessInstancesFactory.class);\n+\n+    Map<String, Object> kafkaConfig;\n+    KafkaStreams streams;\n+    List<KafkaProducer<String, byte[]>> producers = new ArrayList<>();\n+\n+    @Inject\n+    @Named(\"default-kafka-broker\")\n+    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n+        this.kafkaConfig = kafkaConfig;\n+    }\n+\n+    public KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+    }\n+\n+    @PreDestroy\n+    public void stop() {\n+        producers.forEach(KafkaProducer::close);\n+    }\n+\n+    public KafkaProcessInstances createProcessInstances(Process<?> process) {\n+        try {\n+            LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n+            KafkaProducer<String, byte[]> producer = getProducer();\n+            producers.add(producer);", "originalCommit": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQ4NDQ0NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573484445", "bodyText": "true, but I changed the logic now, the producer is not created here anymore.", "author": "cristianonicolai", "createdAt": "2021-02-10T06:45:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc4MDA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc5NDI4Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572794286", "bodyText": "This means that KafkaStreams can already be injected, but not started? So we have to wait in all store manipulation methods until it is running?", "author": "MarianMacik", "createdAt": "2021-02-09T11:06:25Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+import static org.kie.kogito.process.ProcessInstanceReadMode.MUTABLE;\n+\n+public class KafkaProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstances.class);\n+\n+    private Process<?> process;\n+    private KafkaProducer<String, byte[]> producer;\n+    private String topic;\n+    private ReadOnlyKeyValueStore<String, byte[]> store;\n+    private ProcessInstanceMarshaller marshaller;\n+    private KafkaStreams streams;\n+    private CountDownLatch latch = new CountDownLatch(1);\n+\n+    public KafkaProcessInstances(Process<?> process, KafkaStreams streams, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+        this.process = process;\n+        this.topic = topicName(process.id());\n+        this.producer = producer;\n+        this.streams = streams;\n+        this.streams.setStateListener((newState, oldState) -> {\n+            if (store == null && newState == KafkaStreams.State.RUNNING) {\n+                setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(process.id()), QueryableStoreTypes.keyValueStore())));\n+                latch.countDown();\n+            }\n+        });", "originalCommit": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQ4NDY4Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573484687", "bodyText": "yep, KafkaStream get injected but is in CREATED state, a store can only be retrieved once it is on RUNNING state.", "author": "cristianonicolai", "createdAt": "2021-02-10T06:46:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc5NDI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgwOTY1Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572809653", "bodyText": "Daniele said that this can happen, but I don't see how would new KafkaProcessInstancesFactory(); fail. Maybe in older code it could happen?", "author": "MarianMacik", "createdAt": "2021-02-09T11:30:33Z", "path": "addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.Topology;\n+import org.drools.core.io.impl.ClassPathResource;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.auth.IdentityProviders;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.persistence.KogitoProcessInstancesFactory;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.ProcessInstances;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.bpmn2.BpmnProcess;\n+import org.kie.kogito.process.bpmn2.BpmnVariables;\n+import org.kie.kogito.testcontainers.KogitoKafkaContainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testcontainers.junit.jupiter.Container;\n+import org.testcontainers.junit.jupiter.Testcontainers;\n+\n+import static java.util.Collections.singletonMap;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+import static org.kie.kogito.process.ProcessInstance.STATE_COMPLETED;\n+import static org.kie.kogito.process.ProcessInstance.STATE_ERROR;\n+\n+@Testcontainers\n+public class KafkaProcessInstancesIT {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstancesIT.class);\n+\n+    @Container\n+    KogitoKafkaContainer kafka = new KogitoKafkaContainer();\n+\n+    KafkaProcessInstancesFactory factory;\n+\n+    @BeforeEach\n+    void start() {\n+        factory = new KafkaProcessInstancesFactory();\n+        factory.setKafkaConfig(singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()));\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        if (factory != null) {", "originalCommit": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzIyOTcyNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573229727", "bodyText": "My comment was mainly for general stability and avoid problem in the future :)", "author": "danielezonca", "createdAt": "2021-02-09T20:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgwOTY1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQ4NDgyNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573484827", "bodyText": "yep, just more defensive style, just in case :)", "author": "cristianonicolai", "createdAt": "2021-02-10T06:46:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgwOTY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgxMjkwMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572812900", "bodyText": "Just curious, I have always thought that Kafka Streams also support producers and consumers, meaning it is the \"superset\" of the traditional Consumer/Producer API. Or this is just in case we receive something from Kafka and then want to push it again to Kafka (\"streams\")? Not sure about the clear distinction between Kafka Streams and Kafka here.", "author": "MarianMacik", "createdAt": "2021-02-09T11:35:57Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+import static org.kie.kogito.process.ProcessInstanceReadMode.MUTABLE;\n+\n+public class KafkaProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstances.class);\n+\n+    private Process<?> process;\n+    private KafkaProducer<String, byte[]> producer;\n+    private String topic;\n+    private ReadOnlyKeyValueStore<String, byte[]> store;\n+    private ProcessInstanceMarshaller marshaller;\n+    private KafkaStreams streams;\n+    private CountDownLatch latch = new CountDownLatch(1);\n+\n+    public KafkaProcessInstances(Process<?> process, KafkaStreams streams, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+        this.process = process;\n+        this.topic = topicName(process.id());\n+        this.producer = producer;\n+        this.streams = streams;", "originalCommit": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQ4NjE1NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573486154", "bodyText": "KafkaStreams is building a table ( key value store ) representation of the data ( process state ). The way it does it is key storing the latest value of certain message key as the current state. That means, I can read the current state of process from KafkaStreams table abstraction, but if I want to manipulate it ( delete/create/update ) the process, I need to send a message to a Kafka topic.\nSee https://docs.confluent.io/platform/current/streams/concepts.html#duality-of-streams-and-tables", "author": "cristianonicolai", "createdAt": "2021-02-10T06:50:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgxMjkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgxNTgyMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572815823", "bodyText": "Do all of these methods have to be package-private?", "author": "MarianMacik", "createdAt": "2021-02-09T11:40:46Z", "path": "addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.Topology;\n+import org.drools.core.io.impl.ClassPathResource;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.auth.IdentityProviders;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.persistence.KogitoProcessInstancesFactory;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.ProcessInstances;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.bpmn2.BpmnProcess;\n+import org.kie.kogito.process.bpmn2.BpmnVariables;\n+import org.kie.kogito.testcontainers.KogitoKafkaContainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testcontainers.junit.jupiter.Container;\n+import org.testcontainers.junit.jupiter.Testcontainers;\n+\n+import static java.util.Collections.singletonMap;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+import static org.kie.kogito.process.ProcessInstance.STATE_COMPLETED;\n+import static org.kie.kogito.process.ProcessInstance.STATE_ERROR;\n+\n+@Testcontainers\n+public class KafkaProcessInstancesIT {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstancesIT.class);\n+\n+    @Container\n+    KogitoKafkaContainer kafka = new KogitoKafkaContainer();\n+\n+    KafkaProcessInstancesFactory factory;\n+\n+    @BeforeEach\n+    void start() {\n+        factory = new KafkaProcessInstancesFactory();\n+        factory.setKafkaConfig(singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()));\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        if (factory != null) {\n+            factory.stop();\n+            if (factory.getKafkaStreams() != null) {\n+                factory.getKafkaStreams().close();\n+                factory.getKafkaStreams().cleanUp();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void testFindByIdReadMode() {\n+        BpmnProcess process = BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask-Script.bpmn2\")).get(0);\n+\n+        factory.setKafkaStreams(createStreams(process));\n+        process.setProcessInstancesFactory(factory);\n+        process.configure();\n+        factory.getKafkaStreams().start();\n+\n+        ProcessInstances<BpmnVariables> instances = process.instances();\n+        assertThat(instances.size()).isZero();\n+\n+        ProcessInstance<BpmnVariables> mutablePi = process.createInstance(BpmnVariables.create(singletonMap(\"var\", \"value\")));\n+\n+        mutablePi.start();\n+        assertThat(mutablePi.status()).isEqualTo(STATE_ERROR);\n+        assertThat(mutablePi.error()).hasValueSatisfying(error -> {\n+            assertThat(error.errorMessage()).endsWith(\"java.lang.NullPointerException - null\");\n+            assertThat(error.failedNodeId()).isEqualTo(\"ScriptTask_1\");\n+        });\n+        assertThat(mutablePi.variables().toMap()).containsExactly(entry(\"var\", \"value\"));\n+\n+        await().until(() -> instances.values().size() == 1);\n+        \n+        ProcessInstance<BpmnVariables> pi = instances.findById(mutablePi.id(), ProcessInstanceReadMode.READ_ONLY).get();\n+        assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> pi.abort());\n+\n+        ProcessInstance<BpmnVariables> readOnlyPi = instances.findById(mutablePi.id(), ProcessInstanceReadMode.READ_ONLY).get();\n+        assertThat(readOnlyPi.status()).isEqualTo(STATE_ERROR);\n+        assertThat(readOnlyPi.error()).hasValueSatisfying(error -> {\n+            assertThat(error.errorMessage()).endsWith(\"java.lang.NullPointerException - null\");\n+            assertThat(error.failedNodeId()).isEqualTo(\"ScriptTask_1\");\n+        });\n+        assertThat(readOnlyPi.variables().toMap()).containsExactly(entry(\"var\", \"value\"));\n+        assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> readOnlyPi.abort());\n+\n+        instances.findById(mutablePi.id()).get().abort();\n+        assertThat(instances.size()).isZero();\n+    }\n+\n+    @Test\n+    void testValuesReadMode() {\n+        BpmnProcess process = BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask.bpmn2\")).get(0);\n+        factory.setKafkaStreams(createStreams(process));\n+        process.setProcessInstancesFactory(factory);\n+        process.configure();\n+        factory.getKafkaStreams().start();\n+\n+        ProcessInstances<BpmnVariables> instances = process.instances();\n+        assertThat(instances.size()).isZero();\n+\n+        ProcessInstance<BpmnVariables> processInstance = process.createInstance(BpmnVariables.create(singletonMap(\"test\", \"test\")));\n+\n+        processInstance.start();\n+\n+        await().until(() -> instances.values().size() == 1);\n+\n+        ProcessInstance<BpmnVariables> pi = instances.values().stream().findFirst().get();\n+        assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> pi.abort());\n+        instances.values(ProcessInstanceReadMode.MUTABLE).stream().findFirst().get().abort();\n+        assertThat(instances.size()).isZero();\n+    }\n+\n+    @Test\n+    void testBasicFlow() {\n+        BpmnProcess process = BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask.bpmn2\")).get(0);\n+        factory.setKafkaStreams(createStreams(process));\n+        process.setProcessInstancesFactory(factory);\n+        process.configure();\n+        factory.getKafkaStreams().start();\n+\n+        ProcessInstances<BpmnVariables> instances = process.instances();\n+        assertThat(instances.size()).isZero();\n+        \n+        ProcessInstance<BpmnVariables> processInstance = process.createInstance(BpmnVariables.create(singletonMap(\"test\", \"test\")));\n+\n+        processInstance.start();\n+        assertEquals(STATE_ACTIVE, processInstance.status());\n+\n+        await().until(() -> instances.values().size() == 1);\n+\n+        SecurityPolicy asJohn = SecurityPolicy.of(IdentityProviders.of(\"john\"));\n+\n+        assertThat(instances.values().iterator().next().workItems(asJohn)).hasSize(1);\n+\n+        List<WorkItem> workItems = processInstance.workItems(asJohn);\n+        assertThat(workItems).hasSize(1);\n+        WorkItem workItem = workItems.get(0);\n+        assertEquals(\"john\", workItem.getParameters().get(\"ActorId\"));\n+        processInstance.completeWorkItem(workItem.getId(), null, asJohn);\n+        assertEquals(STATE_COMPLETED, processInstance.status());\n+        assertThat(instances.size()).isZero();\n+    }\n+\n+    KafkaStreams createStreams(Process process) {\n+        Topology topology = createTopologyForProcesses(Arrays.asList(process.id()));\n+        KafkaStreams streams = new KafkaStreams(topology, getStreamsConfig());\n+        streams.setUncaughtExceptionHandler((Thread thread, Throwable throwable) ->\n+                                                    LOGGER.error(\"Kafka persistence error: \" + throwable.getMessage(), throwable)\n+        );\n+        streams.cleanUp();\n+        return streams;\n+    }\n+\n+    Properties getStreamsConfig() {", "originalCommit": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQ4NjMzMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573486330", "bodyText": "not really, but this is just an IT test anyway, didn't see much of a need to do it differently", "author": "cristianonicolai", "createdAt": "2021-02-10T06:50:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgxNTgyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjg3NzY4MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572877680", "bodyText": "Isn't this already true because of the check at the beginning of the method?", "author": "MarianMacik", "createdAt": "2021-02-09T13:21:07Z", "path": "kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java", "diffHunk": "@@ -94,34 +99,39 @@ public PersistenceGenerator(KogitoBuildContext context, ProtoGenerator protoGene\n             return Collections.emptyList();\n         }\n \n-        switch (persistenceType()) {\n-            case INFINISPAN_PERSISTENCE_TYPE:\n-                return infinispanBasedPersistence();\n-            case FILESYSTEM_PERSISTENCE_TYPE:\n-                return fileSystemBasedPersistence();\n-            case MONGODB_PERSISTENCE_TYPE:\n-                return mongodbBasedPersistence();\n-            default:\n-                throw new IllegalArgumentException(\"Unknown persistenceType \" + persistenceType());\n+        Collection<GeneratedFile> generatedFiles = new ArrayList<>(protoGenerator.generateProtoFiles());\n+        \n+        if (context().getAddonsConfig().usePersistence()) {", "originalCommit": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQ4NzIzNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573487237", "bodyText": "true, that was a bad merge, fixed now", "author": "cristianonicolai", "createdAt": "2021-02-10T06:53:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjg3NzY4MA=="}], "type": "inlineReview"}, {"oid": "730a8254ba0855f4a904091a1306a0599df22613", "url": "https://github.com/kiegroup/kogito-runtimes/commit/730a8254ba0855f4a904091a1306a0599df22613", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-10T06:34:15Z", "type": "forcePushed"}, {"oid": "c4f2bcaed6f24d990d04abfe1908d1b98ae9ec1a", "url": "https://github.com/kiegroup/kogito-runtimes/commit/c4f2bcaed6f24d990d04abfe1908d1b98ae9ec1a", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-10T07:02:46Z", "type": "forcePushed"}, {"oid": "02cae2666d99b5e05a73e2c7b7feb001ed11f28f", "url": "https://github.com/kiegroup/kogito-runtimes/commit/02cae2666d99b5e05a73e2c7b7feb001ed11f28f", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-10T10:20:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzcyODc4OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573728789", "bodyText": "As I asked before, cannot this be called by multiple threads at the same time? Imagine having more processes and injecting them when the app starts. This calls this method then:\n\n  \n    \n      kogito-runtimes/jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcess.java\n    \n    \n        Lines 131 to 139\n      in\n      17154e1\n    \n    \n    \n    \n\n        \n          \n           public Process<T> configure() { \n        \n\n        \n          \n            \n        \n\n        \n          \n               registerListeners(); \n        \n\n        \n          \n               if (isProcessFactorySet()) { \n        \n\n        \n          \n                   this.instances = (MutableProcessInstances<T>) processInstancesFactory.createProcessInstances(this); \n        \n\n        \n          \n               } \n        \n\n        \n          \n            \n        \n\n        \n          \n               return this; \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nwhen the process is activated.\nNot sure if injection can happen in more threads, but if it can then we need to use concurrent collection here I think. Otherwise in case more than one process is activated at the same time, it won't work properly.", "author": "MarianMacik", "createdAt": "2021-02-10T13:33:32Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+\n+@ApplicationScoped\n+public class KafkaStreamsStateListener implements KafkaStreams.StateListener {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaStreamsStateListener.class);\n+\n+    private List<KafkaProcessInstances> instances = new ArrayList<>();\n+\n+    private KafkaStreams streams;\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+        this.streams.setStateListener(this);\n+    }\n+\n+    protected KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @PreDestroy\n+    public void close() {\n+        instances.clear();\n+    }\n+\n+    protected List<KafkaProcessInstances> getInstances() {\n+        return instances;\n+    }\n+\n+    @Override\n+    public void onChange(KafkaStreams.State newState, KafkaStreams.State oldState) {\n+        LOGGER.debug(\"Received change from KafkaStreams to new state: {}\", newState);\n+        if (newState == KafkaStreams.State.RUNNING) {\n+            instances.forEach(pi -> {\n+                LOGGER.info(\"Creating store for process: {}\", pi.getProcess().id());\n+                pi.setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(pi.getProcess().id()), QueryableStoreTypes.keyValueStore())));\n+            });\n+        }\n+    }\n+\n+    public void addProcessInstances(KafkaProcessInstances pi) {\n+        LOGGER.debug(\"Adding process instance into listener for process: {}\", pi.getProcess().id());\n+        instances.add(pi);", "originalCommit": "02cae2666d99b5e05a73e2c7b7feb001ed11f28f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI1MTQ3Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r574251472", "bodyText": "yep, makes sense. I changed the backing collection to support concurrent access now, thanks", "author": "cristianonicolai", "createdAt": "2021-02-11T04:57:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzcyODc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzczNTM5Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573735392", "bodyText": "What if KafkaStreams component is started earlier then all the KafkaProcessInstances are set up? Will it react also then? If not, we may permanently set state to running in the listener when we get that information and then set stores directly if the state is already running. That would mean, however, to sync it properly.", "author": "MarianMacik", "createdAt": "2021-02-10T13:43:03Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+\n+@ApplicationScoped\n+public class KafkaStreamsStateListener implements KafkaStreams.StateListener {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaStreamsStateListener.class);\n+\n+    private List<KafkaProcessInstances> instances = new ArrayList<>();\n+\n+    private KafkaStreams streams;\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+        this.streams.setStateListener(this);\n+    }\n+\n+    protected KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @PreDestroy\n+    public void close() {\n+        instances.clear();\n+    }\n+\n+    protected List<KafkaProcessInstances> getInstances() {\n+        return instances;\n+    }\n+\n+    @Override\n+    public void onChange(KafkaStreams.State newState, KafkaStreams.State oldState) {\n+        LOGGER.debug(\"Received change from KafkaStreams to new state: {}\", newState);\n+        if (newState == KafkaStreams.State.RUNNING) {\n+            instances.forEach(pi -> {\n+                LOGGER.info(\"Creating store for process: {}\", pi.getProcess().id());\n+                pi.setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(pi.getProcess().id()), QueryableStoreTypes.keyValueStore())));\n+            });", "originalCommit": "02cae2666d99b5e05a73e2c7b7feb001ed11f28f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI1MTI2Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r574251266", "bodyText": "from what I seen that shouldnt happen, but I added a check anyway so we should be covered now.", "author": "cristianonicolai", "createdAt": "2021-02-11T04:56:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzczNTM5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDQwMTgxNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r574401814", "bodyText": "In theory it can still happen if the addProcessInstances passes the check and the streams are not running, but then the listener is triggered before a hash map is updated. But I agree, that this probably should be sorted out on the Kafka Streams/Quarkus side that they should wait until dependency injection is established so any listeners can be triggered only after that. I think it is fine for now.", "author": "MarianMacik", "createdAt": "2021-02-11T10:44:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzczNTM5Mg=="}], "type": "inlineReview"}, {"oid": "c3aae5132acc313a6460afbfa28a8bb09057cc62", "url": "https://github.com/kiegroup/kogito-runtimes/commit/c3aae5132acc313a6460afbfa28a8bb09057cc62", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-11T04:54:42Z", "type": "forcePushed"}, {"oid": "1cb72ee9575ad444bba155bc7610f9eaf168bce7", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1cb72ee9575ad444bba155bc7610f9eaf168bce7", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-11T04:59:49Z", "type": "forcePushed"}, {"oid": "a4d5d4e49b5c167ede9e18de4a4384acd8d2455c", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a4d5d4e49b5c167ede9e18de4a4384acd8d2455c", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-11T05:43:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDgzMTY1MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r574831651", "bodyText": "This is just an approximation, do we use this value anywhere? We should make sure an approximation works", "author": "danielezonca", "createdAt": "2021-02-11T21:15:50Z", "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+import static org.kie.kogito.process.ProcessInstanceReadMode.MUTABLE;\n+\n+public class KafkaProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstances.class);\n+\n+    private Process<?> process;\n+    private KafkaProducer<String, byte[]> producer;\n+    private String topic;\n+    private ReadOnlyKeyValueStore<String, byte[]> store;\n+    private ProcessInstanceMarshaller marshaller;\n+    private CountDownLatch latch = new CountDownLatch(1);\n+\n+    public KafkaProcessInstances(Process<?> process, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+        this.process = process;\n+        this.topic = topicName(process.id());\n+        this.producer = producer;\n+        setMarshaller(new ProcessInstanceMarshaller(new ProtoStreamObjectMarshallingStrategy(proto, marshallers)));\n+    }\n+\n+    protected Process<?> getProcess() {\n+        return process;\n+    }\n+\n+    protected ReadOnlyKeyValueStore<String, byte[]> getStore() {\n+        if (store != null) {\n+            return store;\n+        }\n+\n+        return getStoreAwait();\n+    }\n+\n+    protected void setStore(ReadOnlyKeyValueStore<String, byte[]> store) {\n+        this.store = store;\n+        this.latch.countDown();\n+    }\n+\n+    private ReadOnlyKeyValueStore<String, byte[]> getStoreAwait() {\n+        try {\n+            if (latch.await(1, TimeUnit.MINUTES)) {\n+                if (store == null) {\n+                    throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id());\n+                } else {\n+                    return store;\n+                }\n+            } else {\n+                throw new RuntimeException(\"Timeout waiting to obtain Kafka Store for process: \" + process.id());\n+            }\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id(), e);\n+        }\n+    }\n+\n+    protected void setMarshaller(ProcessInstanceMarshaller marshaller) {\n+        this.marshaller = marshaller;\n+    }\n+\n+    @Override\n+    public boolean exists(String id) {\n+        return getStore().get(id) != null;\n+    }\n+\n+    @Override\n+    public void create(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            if (getStore().get(id) != null) {\n+                throw new ProcessInstanceDuplicatedException(id);\n+            }\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to persist process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void update(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to update process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void remove(String id) {\n+        try {\n+            producer.send(new ProducerRecord<>(topic, id, null)).get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unable to remove process instance id: \" + id, e);\n+        }\n+    }\n+\n+    @Override\n+    public Optional<ProcessInstance> findById(String id, ProcessInstanceReadMode mode) {\n+        byte[] data = getStore().get(id);\n+        if (data == null) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(mode == MUTABLE ?\n+                                   marshaller.unmarshallProcessInstance(data, process) :\n+                                   marshaller.unmarshallReadOnlyProcessInstance(data, process)\n+        );\n+    }\n+\n+    @Override\n+    public Collection<ProcessInstance> values(ProcessInstanceReadMode mode) {\n+        final List<ProcessInstance> instances = new ArrayList<>();\n+        try (final KeyValueIterator<String, byte[]> iterator = getStore().all()) {\n+            while (iterator.hasNext()) {\n+                instances.add(mode == MUTABLE ?\n+                                      marshaller.unmarshallProcessInstance(iterator.next().value, process) :\n+                                      marshaller.unmarshallReadOnlyProcessInstance(iterator.next().value, process)\n+                );\n+            }\n+            return instances;\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unable to read process instances \", e);\n+        }\n+    }\n+\n+    @Override\n+    public Integer size() {\n+        return (int) getStore().approximateNumEntries();", "originalCommit": "a4d5d4e49b5c167ede9e18de4a4384acd8d2455c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTE0MTgzMg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r575141832", "bodyText": "I added just to keep it somehow compatible with the other persistence impl. During my tests this is not reliable at all, or it doesn't update as frequently as it would need for a simple IT test. We will probably have to review this in the future, but size, values are methods used manly for tests.", "author": "cristianonicolai", "createdAt": "2021-02-12T10:57:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDgzMTY1MQ=="}], "type": "inlineReview"}, {"oid": "b9353cbdb6843b3584630fd4e77028e6c819a4bf", "url": "https://github.com/kiegroup/kogito-runtimes/commit/b9353cbdb6843b3584630fd4e77028e6c819a4bf", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-12T13:03:01Z", "type": "forcePushed"}, {"oid": "d5a0ac73bf080723dfd265f9b0862f1d0509e7a0", "url": "https://github.com/kiegroup/kogito-runtimes/commit/d5a0ac73bf080723dfd265f9b0862f1d0509e7a0", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-12T13:50:00Z", "type": "forcePushed"}, {"oid": "03463ae050215ce3761dae5e78eb8150c216d72e", "url": "https://github.com/kiegroup/kogito-runtimes/commit/03463ae050215ce3761dae5e78eb8150c216d72e", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-15T02:33:44Z", "type": "commit"}, {"oid": "03463ae050215ce3761dae5e78eb8150c216d72e", "url": "https://github.com/kiegroup/kogito-runtimes/commit/03463ae050215ce3761dae5e78eb8150c216d72e", "message": "KOGITO-3073 Kafka persistence addon", "committedDate": "2021-02-15T02:33:44Z", "type": "forcePushed"}]}