{"pr_number": 657, "pr_title": "KOGITO-2757 Application.java: Refactor Codegen", "pr_createdAt": "2020-07-28T10:16:43Z", "pr_url": "https://github.com/kiegroup/kogito-runtimes/pull/657", "timeline": [{"oid": "73105b3f95a5524ddff951ff2b49a2d676952653", "url": "https://github.com/kiegroup/kogito-runtimes/commit/73105b3f95a5524ddff951ff2b49a2d676952653", "message": "fix build", "committedDate": "2020-07-29T12:04:36Z", "type": "forcePushed"}, {"oid": "cb86a4dcda7390185f6c6aeac6e1cd734812cd0f", "url": "https://github.com/kiegroup/kogito-runtimes/commit/cb86a4dcda7390185f6c6aeac6e1cd734812cd0f", "message": "KOGITO-2757 Application.java: Refactor Codegen", "committedDate": "2020-07-29T14:22:29Z", "type": "commit"}, {"oid": "901decbc41febf26460a7cfa9d4ba75aa5721e65", "url": "https://github.com/kiegroup/kogito-runtimes/commit/901decbc41febf26460a7cfa9d4ba75aa5721e65", "message": "fix build", "committedDate": "2020-07-29T14:22:29Z", "type": "commit"}, {"oid": "a73b9f5b69517931336532d0ee22c925dfdade17", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a73b9f5b69517931336532d0ee22c925dfdade17", "message": "fix constructors", "committedDate": "2020-07-29T14:22:29Z", "type": "commit"}, {"oid": "c5a5408f901a9d5e1921ae46df11348757831d70", "url": "https://github.com/kiegroup/kogito-runtimes/commit/c5a5408f901a9d5e1921ae46df11348757831d70", "message": "addons", "committedDate": "2020-07-29T14:22:29Z", "type": "commit"}, {"oid": "e8d08c7e4f425621a8c6c898f3973a077c3588e3", "url": "https://github.com/kiegroup/kogito-runtimes/commit/e8d08c7e4f425621a8c6c898f3973a077c3588e3", "message": "rename StaticApplication to AbstractApplication", "committedDate": "2020-07-29T14:22:29Z", "type": "commit"}, {"oid": "e8d08c7e4f425621a8c6c898f3973a077c3588e3", "url": "https://github.com/kiegroup/kogito-runtimes/commit/e8d08c7e4f425621a8c6c898f3973a077c3588e3", "message": "rename StaticApplication to AbstractApplication", "committedDate": "2020-07-29T14:22:29Z", "type": "forcePushed"}, {"oid": "7a8dfffa42a7fce8620d76bc8d623d153154131a", "url": "https://github.com/kiegroup/kogito-runtimes/commit/7a8dfffa42a7fce8620d76bc8d623d153154131a", "message": "cleanup", "committedDate": "2020-07-29T14:50:11Z", "type": "commit"}, {"oid": "03923e38df2017e32da4cfcd703ad17d43ff24fd", "url": "https://github.com/kiegroup/kogito-runtimes/commit/03923e38df2017e32da4cfcd703ad17d43ff24fd", "message": "formatting", "committedDate": "2020-07-29T15:00:55Z", "type": "commit"}, {"oid": "e6abc1e0729c80f332c0fe2cf6c041898a1428d7", "url": "https://github.com/kiegroup/kogito-runtimes/commit/e6abc1e0729c80f332c0fe2cf6c041898a1428d7", "message": "fix conditional codegen", "committedDate": "2020-07-29T15:59:34Z", "type": "commit"}, {"oid": "af7a6ce89395dbf25122d90214d170a1f37b47c3", "url": "https://github.com/kiegroup/kogito-runtimes/commit/af7a6ce89395dbf25122d90214d170a1f37b47c3", "message": "cleanup", "committedDate": "2020-07-30T07:42:13Z", "type": "commit"}, {"oid": "0da4398b54f9772423bc586e157b5be3e68ea4fe", "url": "https://github.com/kiegroup/kogito-runtimes/commit/0da4398b54f9772423bc586e157b5be3e68ea4fe", "message": "align naming", "committedDate": "2020-07-30T08:01:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAxNDkxNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463014914", "bodyText": "What about document this feature in the README somewhere else?", "author": "danielezonca", "createdAt": "2020-07-30T13:56:44Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java", "diffHunk": "@@ -103,84 +108,72 @@ private String getFilePath(String className) {\n         return (this.packageName + \".\" + className).replace('.', '/') + \".java\";\n     }\n \n+    /**\n+     * @deprecated used only in tests?\n+     */\n+    @Deprecated\n     public void addFactoryMethods(Collection<MethodDeclaration> decls) {\n         factoryMethods.addAll(decls);\n     }\n \n     CompilationUnit compilationUnit() {\n         CompilationUnit compilationUnit =\n-                parse(this.getClass().getResourceAsStream(RESOURCE))\n-                        .setPackageDeclaration(packageName);\n+                templatedGenerator.compilationUnit()\n+                        .orElseThrow(() -> new IllegalArgumentException(\"Cannot find template for \" + APPLICATION_CLASS_NAME));\n \n         ClassOrInterfaceDeclaration cls = compilationUnit\n                 .findFirst(ClassOrInterfaceDeclaration.class)\n                 .orElseThrow(() -> new NoSuchElementException(\"Compilation unit doesn't contain a class or interface declaration!\"));\n \n-        VariableDeclarator eventPublishersDeclarator;\n-        FieldDeclaration eventPublishersFieldDeclaration = new FieldDeclaration();\n-\n-        FieldDeclaration kogitoServiceField = new FieldDeclaration().addVariable(new VariableDeclarator()\n-                                                                                .setType(new ClassOrInterfaceType(null, new SimpleName(Optional.class.getCanonicalName()), NodeList.nodeList(new ClassOrInterfaceType(null, String.class.getCanonicalName()))))\n-                                                                                .setName(\"kogitoService\"));\n-\n-        cls.addMember(eventPublishersFieldDeclaration);\n-        cls.addMember(kogitoServiceField);\n-        if (useInjection()) {\n-            annotator.withSingletonComponent(cls);\n-\n-            cls.findFirst(MethodDeclaration.class, md -> md.getNameAsString().equals(\"setup\")).\n-            orElseThrow(() -> new RuntimeException(\"setup method template not found\"))\n-            .addAnnotation(\"javax.annotation.PostConstruct\");\n-\n-            annotator.withOptionalInjection(eventPublishersFieldDeclaration);\n-            eventPublishersDeclarator = new VariableDeclarator(new ClassOrInterfaceType(null, new SimpleName(annotator.multiInstanceInjectionType()), NodeList.nodeList(new ClassOrInterfaceType(null, EventPublisher.class.getCanonicalName()))), \"eventPublishers\");\n-\n-            annotator.withConfigInjection(kogitoServiceField, \"kogito.service.url\");\n-        } else {\n-            eventPublishersDeclarator = new VariableDeclarator(new ClassOrInterfaceType(null, new SimpleName(List.class.getCanonicalName()), NodeList.nodeList(new ClassOrInterfaceType(null, EventPublisher.class.getCanonicalName()))), \"eventPublishers\");\n-            kogitoServiceField.getVariable(0).setInitializer(new MethodCallExpr(new NameExpr(Optional.class.getCanonicalName()), \"empty\"));\n-        }\n+        factoryMethods.forEach(cls::addMember);\n \n-        eventPublishersFieldDeclaration.addVariable(eventPublishersDeclarator);\n-\n-        FieldDeclaration configField = null;\n-        if (useInjection()) {\n-            configField = new FieldDeclaration()\n-                    .addVariable(new VariableDeclarator()\n-                                         .setType(Config.class.getCanonicalName())\n-                                         .setName(\"config\"));\n-            annotator.withInjection(configField);\n-        } else {\n-            configField = new FieldDeclaration()\n-                    .addModifier(Modifier.Keyword.PROTECTED)\n-                    .addVariable(new VariableDeclarator()\n-                            .setType(Config.class.getCanonicalName())\n-                            .setName(\"config\")\n-                            .setInitializer(configGenerator.newInstance()));\n-        }\n-        cls.addMember(configField);\n+        initializeSectionsExplicitly(cls);\n \n-        factoryMethods.forEach(cls::addMember);\n+        cls.getMembers().sort(new BodyDeclarationComparator());\n+        return compilationUnit;\n+    }\n \n-        Optional<BlockStmt> optSetupBody = cls\n-                .findFirst(MethodDeclaration.class, md -> md.getNameAsString().equals(\"setup\"))\n-                .flatMap(MethodDeclaration::getBody);\n+    private void initializeSectionsExplicitly(ClassOrInterfaceDeclaration cls) {\n         for (Generator generator : generators) {\n             ApplicationSection section = generator.section();\n-            if (section == null) {\n-                continue;\n+            if (section != null) {\n+                replaceSectionPlaceHolder(cls, section);\n             }\n-            cls.addMember(section.fieldDeclaration());\n-            cls.addMember(section.factoryMethod());\n-            optSetupBody.ifPresent(b -> section.setupStatements().forEach(b::addStatement));\n         }\n-        cls.getMembers().sort(new BodyDeclarationComparator());\n-        return compilationUnit;\n+    }\n+\n+    private void replaceSectionPlaceHolder(ClassOrInterfaceDeclaration cls, ApplicationSection section) {\n+        // look for an expression of the form: foo = ... /* $SectionName$ */ ;\n+        //      e.g.: this.processes = null /* $Processes$ */;\n+        // and replaces the entire expression with an initializer; e.g.:\n+        //      e.g.: this.processes = new Processes(this);", "originalCommit": "0da4398b54f9772423bc586e157b5be3e68ea4fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA1NjExMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463056113", "bodyText": "what do you mean? this is just a usage pattern in a private method where would you like to document it? maybe you mean adding it to #655 ?", "author": "evacchi", "createdAt": "2020-07-30T14:53:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAxNDkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEzNTk0OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463135948", "bodyText": "My bad, I considered this \"rewrite\" mechanism like a reusable feature for all TemplatedGenerator based classes but it is not :)", "author": "danielezonca", "createdAt": "2020-07-30T16:52:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAxNDkxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAxNTcwMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463015700", "bodyText": "Can you please create a ticket for that?", "author": "danielezonca", "createdAt": "2020-07-30T13:57:44Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/ApplicationGeneratorTest.java", "diffHunk": "@@ -49,6 +50,7 @@\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n+@Disabled(\"Review these tests as some are outdated\")", "originalCommit": "0da4398b54f9772423bc586e157b5be3e68ea4fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA1NzM2MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463057361", "bodyText": "Thanks, I actually forgot about this, I meant to re-enable before un-drafting. Will take a look now.", "author": "evacchi", "createdAt": "2020-07-30T14:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAxNTcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU4MDE2Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463580162", "bodyText": "In case it is still disabled, a JIRA would be beneficial here.", "author": "MarianMacik", "createdAt": "2020-07-31T12:26:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAxNTcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYyNDMxOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463624319", "bodyText": "I have restored that and removed old tests", "author": "evacchi", "createdAt": "2020-07-31T13:52:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAxNTcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA0MTUyMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463041523", "bodyText": "Is there any reason why TemplatedGenerator is used as class to extend in many cases and as delegate in others?", "author": "danielezonca", "createdAt": "2020-07-30T14:33:42Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/ConfigGenerator.java", "diffHunk": "@@ -76,6 +69,11 @@ public ConfigGenerator(String packageName) {\n         this.targetTypeName = \"ApplicationConfig\";\n         this.targetCanonicalName = this.packageName + \".\" + targetTypeName;\n         this.sourceFilePath = targetCanonicalName.replace('.', '/') + \".java\";\n+        this.templatedGenerator = new TemplatedGenerator(packageName,", "originalCommit": "0da4398b54f9772423bc586e157b5be3e68ea4fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA2MjY1OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463062659", "bodyText": "when it's \"more convenient\" it is extended; in this case it's used as a delegate as it would break the contract of some APIs (compilationUnit() returns an Option in TemplatedGenerator and here it doesn't). In other cases it's because the class is already extending another abstract class.\nThe delegate version is a little more error-prone, as you have to remember to call withDependencyInjection() explicitly.\nI think this generator will disappear at some point, if we get more strict about naming conventions, so I wouldn't care too much about the usage patterns, but we can make it a force delegate by making it final, if we really care. In that case I would open a new Jira. But I like that most classes can inherit for brevity.", "author": "evacchi", "createdAt": "2020-07-30T15:01:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA0MTUyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA0NDgxNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463044815", "bodyText": "To be removed? This override has been removed from DecisionContainerGenerator so I expect it can be removed here too", "author": "danielezonca", "createdAt": "2020-07-30T14:37:54Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/prediction/PredictionContainerGenerator.java", "diffHunk": "@@ -67,23 +60,6 @@ public ClassOrInterfaceDeclaration classDeclaration() {\n         return typeDeclaration;\n     }\n \n-    @Override\n-    public List<Statement> setupStatements() {\n-        return Collections.singletonList(\n-                new IfStmt(\n-                        new BinaryExpr(\n-                                new MethodCallExpr(new MethodCallExpr(null, \"config\"), \"prediction\"),\n-                                new NullLiteralExpr(),\n-                                BinaryExpr.Operator.NOT_EQUALS\n-                        ),\n-                        new BlockStmt().addStatement(new ExpressionStmt(new MethodCallExpr(\n-                                new NameExpr(\"predictionModels\"), \"init\", NodeList.nodeList(new ThisExpr())\n-                        ))),\n-                        null\n-                )\n-        );\n-    }\n-\n     @Override\n     protected boolean useApplication() {\n         return false;", "originalCommit": "0da4398b54f9772423bc586e157b5be3e68ea4fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA0NjM4Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463046383", "bodyText": "Can you please create a ticket to verify this?", "author": "danielezonca", "createdAt": "2020-07-30T14:40:06Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java", "diffHunk": "@@ -103,84 +108,72 @@ private String getFilePath(String className) {\n         return (this.packageName + \".\" + className).replace('.', '/') + \".java\";\n     }\n \n+    /**\n+     * @deprecated used only in tests?\n+     */\n+    @Deprecated", "originalCommit": "0da4398b54f9772423bc586e157b5be3e68ea4fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA1ODU2Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463058567", "bodyText": "I think I'll re-check and delete it altogether if it's not necessary", "author": "evacchi", "createdAt": "2020-07-30T14:56:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA0NjM4Mw=="}], "type": "inlineReview"}, {"oid": "271d5ef3ddedb42ab2a5e4efd38087960f00fd7c", "url": "https://github.com/kiegroup/kogito-runtimes/commit/271d5ef3ddedb42ab2a5e4efd38087960f00fd7c", "message": "remove old methods, and deprecated tests", "committedDate": "2020-07-30T15:26:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1MDM3Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463550373", "bodyText": "What does fae mean? Something like Found AssignExpr? Maybe the name could be more descriptive.", "author": "MarianMacik", "createdAt": "2020-07-31T11:11:30Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java", "diffHunk": "@@ -103,84 +108,54 @@ private String getFilePath(String className) {\n         return (this.packageName + \".\" + className).replace('.', '/') + \".java\";\n     }\n \n-    public void addFactoryMethods(Collection<MethodDeclaration> decls) {\n-        factoryMethods.addAll(decls);\n-    }\n-\n     CompilationUnit compilationUnit() {\n         CompilationUnit compilationUnit =\n-                parse(this.getClass().getResourceAsStream(RESOURCE))\n-                        .setPackageDeclaration(packageName);\n+                templatedGenerator.compilationUnit()\n+                        .orElseThrow(() -> new IllegalArgumentException(\"Cannot find template for \" + APPLICATION_CLASS_NAME));\n \n         ClassOrInterfaceDeclaration cls = compilationUnit\n                 .findFirst(ClassOrInterfaceDeclaration.class)\n                 .orElseThrow(() -> new NoSuchElementException(\"Compilation unit doesn't contain a class or interface declaration!\"));\n \n-        VariableDeclarator eventPublishersDeclarator;\n-        FieldDeclaration eventPublishersFieldDeclaration = new FieldDeclaration();\n-\n-        FieldDeclaration kogitoServiceField = new FieldDeclaration().addVariable(new VariableDeclarator()\n-                                                                                .setType(new ClassOrInterfaceType(null, new SimpleName(Optional.class.getCanonicalName()), NodeList.nodeList(new ClassOrInterfaceType(null, String.class.getCanonicalName()))))\n-                                                                                .setName(\"kogitoService\"));\n-\n-        cls.addMember(eventPublishersFieldDeclaration);\n-        cls.addMember(kogitoServiceField);\n-        if (useInjection()) {\n-            annotator.withSingletonComponent(cls);\n-\n-            cls.findFirst(MethodDeclaration.class, md -> md.getNameAsString().equals(\"setup\")).\n-            orElseThrow(() -> new RuntimeException(\"setup method template not found\"))\n-            .addAnnotation(\"javax.annotation.PostConstruct\");\n-\n-            annotator.withOptionalInjection(eventPublishersFieldDeclaration);\n-            eventPublishersDeclarator = new VariableDeclarator(new ClassOrInterfaceType(null, new SimpleName(annotator.multiInstanceInjectionType()), NodeList.nodeList(new ClassOrInterfaceType(null, EventPublisher.class.getCanonicalName()))), \"eventPublishers\");\n-\n-            annotator.withConfigInjection(kogitoServiceField, \"kogito.service.url\");\n-        } else {\n-            eventPublishersDeclarator = new VariableDeclarator(new ClassOrInterfaceType(null, new SimpleName(List.class.getCanonicalName()), NodeList.nodeList(new ClassOrInterfaceType(null, EventPublisher.class.getCanonicalName()))), \"eventPublishers\");\n-            kogitoServiceField.getVariable(0).setInitializer(new MethodCallExpr(new NameExpr(Optional.class.getCanonicalName()), \"empty\"));\n-        }\n+        factoryMethods.forEach(cls::addMember);\n \n-        eventPublishersFieldDeclaration.addVariable(eventPublishersDeclarator);\n-\n-        FieldDeclaration configField = null;\n-        if (useInjection()) {\n-            configField = new FieldDeclaration()\n-                    .addVariable(new VariableDeclarator()\n-                                         .setType(Config.class.getCanonicalName())\n-                                         .setName(\"config\"));\n-            annotator.withInjection(configField);\n-        } else {\n-            configField = new FieldDeclaration()\n-                    .addModifier(Modifier.Keyword.PROTECTED)\n-                    .addVariable(new VariableDeclarator()\n-                            .setType(Config.class.getCanonicalName())\n-                            .setName(\"config\")\n-                            .setInitializer(configGenerator.newInstance()));\n-        }\n-        cls.addMember(configField);\n+        initializeSectionsExplicitly(cls);\n \n-        factoryMethods.forEach(cls::addMember);\n+        cls.getMembers().sort(new BodyDeclarationComparator());\n+        return compilationUnit;\n+    }\n \n-        Optional<BlockStmt> optSetupBody = cls\n-                .findFirst(MethodDeclaration.class, md -> md.getNameAsString().equals(\"setup\"))\n-                .flatMap(MethodDeclaration::getBody);\n+    private void initializeSectionsExplicitly(ClassOrInterfaceDeclaration cls) {\n         for (Generator generator : generators) {\n             ApplicationSection section = generator.section();\n-            if (section == null) {\n-                continue;\n+            if (section != null) {\n+                replaceSectionPlaceHolder(cls, section);\n             }\n-            cls.addMember(section.fieldDeclaration());\n-            cls.addMember(section.factoryMethod());\n-            optSetupBody.ifPresent(b -> section.setupStatements().forEach(b::addStatement));\n         }\n-        cls.getMembers().sort(new BodyDeclarationComparator());\n-        return compilationUnit;\n+    }\n+\n+    private void replaceSectionPlaceHolder(ClassOrInterfaceDeclaration cls, ApplicationSection section) {\n+        // look for an expression of the form: foo = ... /* $SectionName$ */ ;\n+        //      e.g.: this.processes = null /* $Processes$ */;\n+        // and replaces the entire expression with an initializer; e.g.:\n+        //      e.g.: this.processes = new Processes(this);\n+\n+        Optional<AssignExpr> fae = cls.findFirst(", "originalCommit": "271d5ef3ddedb42ab2a5e4efd38087960f00fd7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYyNDc4NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463624784", "bodyText": "it was a FieldAccessExpression before :P good point.", "author": "evacchi", "createdAt": "2020-07-31T13:53:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1MDM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1MTQ4NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463551485", "bodyText": "Maybe this TemplatedGenerator could also be extracted into its own type as with ConfigBeanGenerator? As those resource files URLs are not needed in this class, just in the TemplatedGenerator itself.", "author": "MarianMacik", "createdAt": "2020-07-31T11:14:44Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/ApplicationGenerator.java", "diffHunk": "@@ -89,6 +87,13 @@ public ApplicationGenerator(String packageName, File targetDirectory) {\n         this.targetDirectory = targetDirectory;\n         this.factoryMethods = new ArrayList<>();\n         this.configGenerator = new ConfigGenerator(packageName);\n+\n+        this.templatedGenerator = new TemplatedGenerator(\n+                packageName,\n+                APPLICATION_CLASS_NAME,\n+                RESOURCE_CDI,\n+                RESOURCE_SPRING,\n+                RESOURCE_DEFAULT);", "originalCommit": "271d5ef3ddedb42ab2a5e4efd38087960f00fd7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYyNjc1NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463626755", "bodyText": "it's just used as a delegate instead of inheriting. But you have a point, let me see.", "author": "evacchi", "createdAt": "2020-07-31T13:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1MTQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1ODM1MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463558350", "bodyText": "This implies that first we have to call compilationUnit(). Wouldn't it be better for selectResource() to have the return value and call it also here and in compilationUnit every time? It would be less stateless...", "author": "MarianMacik", "createdAt": "2020-07-31T11:33:02Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/TemplatedGenerator.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen;\n+\n+import java.text.MessageFormat;\n+import java.util.Optional;\n+\n+import javax.lang.model.SourceVersion;\n+\n+import com.github.javaparser.ParseProblemException;\n+import com.github.javaparser.ast.CompilationUnit;\n+import org.kie.kogito.codegen.di.CDIDependencyInjectionAnnotator;\n+import org.kie.kogito.codegen.di.DependencyInjectionAnnotator;\n+import org.kie.kogito.codegen.di.SpringDependencyInjectionAnnotator;\n+\n+import static com.github.javaparser.StaticJavaParser.parse;\n+\n+public class TemplatedGenerator {\n+\n+    private final String packageName;\n+    private final String sourceFilePath;\n+\n+    private final String resourceCdi;\n+    private final String resourceSpring;\n+    private final String resourceDefault;\n+\n+    private DependencyInjectionAnnotator annotator;\n+    private String targetTypeName;\n+    private String selectedResource;\n+\n+    public TemplatedGenerator(\n+            String packageName,\n+            String targetTypeName,\n+            String resourceCdi,\n+            String resourceSpring,\n+            String resourceDefault) {\n+        if (packageName == null) {\n+            throw new IllegalArgumentException(\"Package name cannot be undefined (null), please specify a package name!\");\n+        }\n+        if (!SourceVersion.isName(packageName)) {\n+            throw new IllegalArgumentException(\n+                    MessageFormat.format(\n+                            \"Package name \\\"{0}\\\" is not valid. It should be a valid Java package name.\", packageName));\n+        }\n+\n+        this.packageName = packageName;\n+        this.targetTypeName = targetTypeName;\n+        String targetCanonicalName = this.packageName + \".\" + this.targetTypeName;\n+        this.sourceFilePath = targetCanonicalName.replace('.', '/') + \".java\";\n+        this.resourceCdi = resourceCdi;\n+        this.resourceSpring = resourceSpring;\n+        this.resourceDefault = resourceDefault;\n+    }\n+\n+    public TemplatedGenerator(\n+            String packageName,\n+            String targetTypeName,\n+            String resourceCdi,\n+            String resourceSpring) {\n+        this(packageName,\n+             targetTypeName,\n+             resourceCdi,\n+             resourceSpring,\n+             null);\n+    }\n+\n+    public String generatedFilePath() {\n+        return sourceFilePath;\n+    }\n+\n+    public String templatePath() {\n+        return selectedResource;", "originalCommit": "271d5ef3ddedb42ab2a5e4efd38087960f00fd7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYyNTI5MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463625291", "bodyText": "correct. I thought about adding selectResource() here too, I can do that", "author": "evacchi", "createdAt": "2020-07-31T13:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1ODM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc3NTMzOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463775339", "bodyText": "So we don't want selectResource() to return the selected resource as the return value? Then we wouldn't need the selectedResource field at all. As we will always call selectResource() anyway.", "author": "MarianMacik", "createdAt": "2020-07-31T18:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1ODM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIzNDQzOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r464234439", "bodyText": "done. Don't love it, I actually intended the selection to be cached (but of course I was not really doing it), but we can optimize later, and indeed the code is clearer this way", "author": "evacchi", "createdAt": "2020-08-03T07:16:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1ODM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1OTAwMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463559000", "bodyText": "Same here, maybe a separate type as with ConfigBeanGenerator would be cleaner?", "author": "MarianMacik", "createdAt": "2020-07-31T11:34:43Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessContainerGenerator.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.BodyDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NullLiteralExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import org.kie.kogito.codegen.AbstractApplicationSection;\n+import org.kie.kogito.codegen.InvalidTemplateException;\n+import org.kie.kogito.codegen.TemplatedGenerator;\n+import org.kie.kogito.codegen.di.DependencyInjectionAnnotator;\n+import org.kie.kogito.process.Processes;\n+\n+public class ProcessContainerGenerator extends AbstractApplicationSection {\n+\n+    private static final String RESOURCE = \"/class-templates/ProcessContainerTemplate.java\";\n+    private static final String RESOURCE_CDI = \"/class-templates/CdiProcessContainerTemplate.java\";\n+    private static final String RESOURCE_SPRING = \"/class-templates/SpringProcessContainerTemplate.java\";\n+    public static final String SECTION_CLASS_NAME = \"Processes\";\n+\n+    private final String packageName;\n+    private final List<ProcessGenerator> processes;\n+    private final List<BodyDeclaration<?>> factoryMethods;\n+\n+    private DependencyInjectionAnnotator annotator;\n+\n+    private BlockStmt byProcessIdBody = new BlockStmt();\n+    private BlockStmt processesBody = new BlockStmt();\n+    private final TemplatedGenerator templatedGenerator;\n+\n+    public ProcessContainerGenerator(String packageName) {\n+        super(SECTION_CLASS_NAME, \"processes\", Processes.class);\n+        this.packageName = packageName;\n+        this.processes = new ArrayList<>();\n+        this.factoryMethods = new ArrayList<>();\n+\n+        this.templatedGenerator = new TemplatedGenerator(\n+                packageName,\n+                SECTION_CLASS_NAME,\n+                RESOURCE_CDI,\n+                RESOURCE_SPRING,\n+                RESOURCE);", "originalCommit": "271d5ef3ddedb42ab2a5e4efd38087960f00fd7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU3MTA1MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463571051", "bodyText": "Maybe a check that only one Processes bean is present wouldn't be bad, or?", "author": "MarianMacik", "createdAt": "2020-07-31T12:04:56Z", "path": "kogito-codegen/src/main/resources/class-templates/SpringApplicationTemplate.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package $Package$;\n+\n+import org.kie.kogito.Config;\n+import org.kie.kogito.StaticApplication;\n+import org.kie.kogito.process.Processes;\n+\n+@org.springframework.stereotype.Component\n+@org.springframework.web.context.annotation.ApplicationScope\n+public class Application extends StaticApplication {\n+\n+    @org.springframework.beans.factory.annotation.Autowired()\n+    public Application(\n+            Config config,\n+            java.util.Collection<Processes> processes/*,\n+            java.util.Collection<RuleUnits> ruleUnits,\n+            java.util.Collection<DecisionModels> decisionModels,\n+            java.util.Collection<PredictionModels> predictionModels,\n+            */) {\n+        this.config = config;\n+        this.processes = orNull(processes);\n+        this.ruleUnits = null /* $RuleUnits$ */;\n+        this.decisionModels = null /* $DecisionModels$ */;\n+        this.predictionModels = null /* $PredictionModels$ */;\n+\n+        if (config().process() != null) {\n+            unitOfWorkManager().eventManager().setAddons(config().addons());\n+        }\n+    }\n+\n+    private static <T> T orNull(java.util.Collection<T> collection) {\n+        if (collection.isEmpty()) {\n+            return null;\n+        } else {\n+            return collection.iterator().next();", "originalCommit": "271d5ef3ddedb42ab2a5e4efd38087960f00fd7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYyNTg5Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/657#discussion_r463625892", "bodyText": "sure let's do that", "author": "evacchi", "createdAt": "2020-07-31T13:55:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU3MTA1MQ=="}], "type": "inlineReview"}, {"oid": "d747f7af4a2501d8d9def03d380c5114465c7ed9", "url": "https://github.com/kiegroup/kogito-runtimes/commit/d747f7af4a2501d8d9def03d380c5114465c7ed9", "message": "address comments, further refactoring and cleanup", "committedDate": "2020-07-31T15:34:55Z", "type": "commit"}, {"oid": "4faf0a2609fc311b78239eb484c94dfbdb30726e", "url": "https://github.com/kiegroup/kogito-runtimes/commit/4faf0a2609fc311b78239eb484c94dfbdb30726e", "message": "always select resource", "committedDate": "2020-08-03T07:16:10Z", "type": "commit"}]}