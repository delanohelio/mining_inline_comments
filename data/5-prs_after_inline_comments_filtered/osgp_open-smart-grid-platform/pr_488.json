{"pr_number": 488, "pr_title": "Slim 2597 implement secret management extra functionality", "pr_createdAt": "2020-11-04T13:52:24Z", "pr_url": "https://github.com/OSGP/open-smart-grid-platform/pull/488", "timeline": [{"oid": "035112fefcfc8342a79d75325e4fb4b4fc635f87", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/035112fefcfc8342a79d75325e4fb4b4fc635f87", "message": "SLIM-2597 test code clean up", "committedDate": "2020-12-17T11:27:26Z", "type": "commit"}, {"oid": "54415b355ab731a255e86daa3108ddd3d57d9d6c", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/54415b355ab731a255e86daa3108ddd3d57d9d6c", "message": "SLIM-2597 code clean up", "committedDate": "2020-12-17T11:31:01Z", "type": "commit"}, {"oid": "77906104eaccc566de1c9e4091a0fb08e03bd2b7", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/77906104eaccc566de1c9e4091a0fb08e03bd2b7", "message": "Undo test tags", "committedDate": "2020-12-17T13:14:36Z", "type": "commit"}, {"oid": "93739d0cd252e9d56a4fcbc2908b2c457ac67845", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/93739d0cd252e9d56a4fcbc2908b2c457ac67845", "message": "SLIM-2587 fix broken test", "committedDate": "2020-12-17T14:42:37Z", "type": "commit"}, {"oid": "d3072088aedad42009113269a9509862cf39cecc", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/d3072088aedad42009113269a9509862cf39cecc", "message": "SLIM-2587 input keys improved", "committedDate": "2020-12-17T15:22:02Z", "type": "commit"}, {"oid": "735c42a57a48983e5d621e508c18943b0246f71c", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/735c42a57a48983e5d621e508c18943b0246f71c", "message": "Merge branch 'SLIM-2597-Implement-secret-management-extra-functionality' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-12-17T15:22:51Z", "type": "commit"}, {"oid": "4857ba651380eb139f48391b0876d4fe45d56b9a", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/4857ba651380eb139f48391b0876d4fe45d56b9a", "message": "SLIM-2597 added TODO wrt security", "committedDate": "2020-12-18T09:52:27Z", "type": "commit"}, {"oid": "83b4e7b18f798a744a972a22fd69b71acf8c678e", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/83b4e7b18f798a744a972a22fd69b71acf8c678e", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-12-18T09:53:13Z", "type": "commit"}, {"oid": "e19c718bf3a033a39eabdefa238082c2d781870a", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/e19c718bf3a033a39eabdefa238082c2d781870a", "message": "SLIM-2587 added logging to analyse failing tests", "committedDate": "2020-12-19T13:34:54Z", "type": "commit"}, {"oid": "bb87ab899d5c1ec57832d289da05b64c8b901458", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/bb87ab899d5c1ec57832d289da05b64c8b901458", "message": "SLIM-2587 added TODO", "committedDate": "2020-12-19T13:35:51Z", "type": "commit"}, {"oid": "630e03d00a3c9ba7677ac7da3885b00c701d4763", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/630e03d00a3c9ba7677ac7da3885b00c701d4763", "message": "SLIM-2587 added logging & TODO", "committedDate": "2020-12-19T16:15:16Z", "type": "commit"}, {"oid": "7bc98c38b0abff8d26a35d709b1d419cbadb5e60", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/7bc98c38b0abff8d26a35d709b1d419cbadb5e60", "message": "SLIM-2587 disabled failing tests; unknown how they should work", "committedDate": "2021-01-04T18:03:35Z", "type": "commit"}, {"oid": "99de4328b87ddc101ed14ca9cd2e3c925f904d74", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/99de4328b87ddc101ed14ca9cd2e3c925f904d74", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2021-01-05T07:27:48Z", "type": "commit"}, {"oid": "cd5ad6ed3167fdb988b6a49db8c56aa1cde92861", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/cd5ad6ed3167fdb988b6a49db8c56aa1cde92861", "message": "Run firmware tests only", "committedDate": "2021-01-05T15:28:06Z", "type": "commit"}, {"oid": "d712696f0f74a243edbad2942620bcca2372cd25", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/d712696f0f74a243edbad2942620bcca2372cd25", "message": "Remove test tag and enable firmware tests", "committedDate": "2021-01-07T07:59:48Z", "type": "commit"}, {"oid": "189c1b50ffd41bcec7a8ab4752a5bca8b4e2594d", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/189c1b50ffd41bcec7a8ab4752a5bca8b4e2594d", "message": "Fixed retry of update firmware file", "committedDate": "2021-01-07T11:19:34Z", "type": "commit"}, {"oid": "490b36668dd70e129bc187bdf1b45a5dcd94ac53", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/490b36668dd70e129bc187bdf1b45a5dcd94ac53", "message": "Merge branch 'SLIM-2597-Implement-secret-management-extra-functionality' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2021-01-07T11:29:40Z", "type": "commit"}, {"oid": "82675e5d4f21cb61f4cf92e6b31445595c424a73", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/82675e5d4f21cb61f4cf92e6b31445595c424a73", "message": "Fix asserting fault message", "committedDate": "2021-01-07T14:44:58Z", "type": "commit"}, {"oid": "9949e261418959bfc6a3635533e00fca3f04ccc8", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/9949e261418959bfc6a3635533e00fca3f04ccc8", "message": "SLIM-2597 changes resulting from PR review comments", "committedDate": "2021-01-14T09:37:02Z", "type": "commit"}, {"oid": "c59382be537c9b4601ef9f14d2e8a750db1e5332", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/c59382be537c9b4601ef9f14d2e8a750db1e5332", "message": "Revert \"SLIM-2587 fix cucumber tests; changed exception handling\"\n\nThis reverts commit 6fc837b9", "committedDate": "2021-01-14T09:43:09Z", "type": "commit"}, {"oid": "2ad102dc23f1887d7e8309251500ff3e4ce8b28f", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/2ad102dc23f1887d7e8309251500ff3e4ce8b28f", "message": "SLIM-2597 changes resulting from PR review comments", "committedDate": "2021-01-14T11:16:53Z", "type": "commit"}, {"oid": "e260d934aeddc2fb082d9418a2ffd1b51aa9e993", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/e260d934aeddc2fb082d9418a2ffd1b51aa9e993", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2021-01-14T11:17:34Z", "type": "commit"}, {"oid": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "message": "Merge branch 'development' into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2021-01-15T06:25:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODExMTEyNw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558111127", "bodyText": "Why are these constants commented out?\nIf they are not needed anymore, they should just be removed.", "author": "bvdzwet", "createdAt": "2021-01-15T09:22:19Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/PlatformSmartmeteringKeys.java", "diffHunk": "@@ -76,12 +76,12 @@\n \n     // Default keys for security_key\n     public static final String DLMS_DEVICE_ID = \"DlmsDeviceId\";\n-    public static final String SECURITY_KEY_A = \"SecurityKeyAuthentication\";\n+    /*public static final String SECURITY_KEY_A = \"SecurityKeyAuthentication\";\n     public static final String SECURITY_KEY_E = \"SecurityKeyEncryption\";\n     public static final String SECURITY_KEY_M = \"SecurityKeyMaster\";\n     public static final String SECURITY_TYPE_A = \"SecurityKeyTypeAuthentication\";\n     public static final String SECURITY_TYPE_E = \"SecurityKeyTypeEncryption\";\n-    public static final String SECURITY_TYPE_M = \"SecurityKeyTypeMaster\";\n+    public static final String SECURITY_TYPE_M = \"SecurityKeyTypeMaster\";*/", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE4MDk2Mw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558180963", "bodyText": "Copyright for new files should no longer mention Smart Society Services B.V. (use Alliander N.V. instead).", "author": "bvdzwet", "createdAt": "2021-01-15T10:07:16Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/config/SecretManagementPersistenceConfig.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE5MjU5NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558192594", "bodyText": "If there is no longer any use for these commented lines, they should be removed,", "author": "bvdzwet", "createdAt": "2021-01-15T10:15:35Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/glue/steps/database/device/DlmsDeviceSteps.java", "diffHunk": "@@ -89,6 +112,53 @@\n     @Autowired\n     private DeviceFirmwareModuleSteps deviceFirmwareModuleSteps;\n \n+    @Autowired\n+    private DbEncryptedSecretRepository encryptedSecretRepository;\n+\n+    @Autowired\n+    private DbEncryptionKeyRepository encryptionKeyRepository;\n+\n+    /*private final SecretBuilder authenticationSecurityKeyBuilder = new SecretBuilder()\n+            .setSecurityKeyType(SecurityKeyType.E_METER_AUTHENTICATION)\n+            .setKey(PlatformSmartmeteringDefaults.SECURITY_KEY_A_DB);\n+    private final SecretBuilder encryptionSecurityKeyBuilder = new SecretBuilder()\n+            .setSecurityKeyType(SecurityKeyType.E_METER_ENCRYPTION)\n+            .setKey(PlatformSmartmeteringDefaults.SECURITY_KEY_E_DB);\n+    private final SecretBuilder masterSecurityKeyBuilder = new SecretBuilder()\n+            .setSecurityKeyType(SecurityKeyType.E_METER_MASTER).setKey(PlatformSmartmeteringDefaults.SECURITY_KEY_M_DB);\n+    private final SecretBuilder passwordBuilder = new SecretBuilder().setSecurityKeyType(SecurityKeyType.PASSWORD)\n+                                                                     .setKey(PlatformSmartmeteringDefaults.PASSWORD);\n+    private final SecretBuilder mbusEncryptionSecurityKeyBuilder = new SecretBuilder()\n+            .setSecurityKeyType(SecurityKeyType.G_METER_ENCRYPTION)\n+            .setKey(PlatformSmartmeteringDefaults.SECURITY_KEY_G_ENCRYPTION);\n+    private final SecretBuilder mbusMasterSecurityKeyBuilder = new SecretBuilder()\n+            .setSecurityKeyType(SecurityKeyType.G_METER_MASTER)\n+            .setKey(PlatformSmartmeteringDefaults.SECURITY_KEY_G_MASTER);*/", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE5NjIyOQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558196229", "bodyText": "Missing a final modifier according to the coding conventions.", "author": "bvdzwet", "createdAt": "2021-01-15T10:18:08Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/glue/steps/database/device/DlmsDeviceSteps.java", "diffHunk": "@@ -378,13 +447,18 @@ private DlmsDevice findExistingDlmsDevice(final String deviceIdentification) {\n         return dlmsDevice;\n     }\n \n-    private SecurityKey findExistingSecurityKey(final DlmsDevice dlmsDevice, final SecurityKeyType keyType,\n+    private DbEncryptedSecret findExistingSecurityKey(final DlmsDevice dlmsDevice, final SecretType secretType,\n             final String keyDescription) {\n-        final SecurityKey securityKey = dlmsDevice.getValidSecurityKey(keyType);\n-        assertThat(securityKey)\n+        List<DbEncryptedSecret> validSecrets = this.encryptedSecretRepository", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE5NjYxOQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558196619", "bodyText": "Missing a final modifier according to the coding conventions.", "author": "bvdzwet", "createdAt": "2021-01-15T10:18:23Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/glue/steps/database/device/DlmsDeviceSteps.java", "diffHunk": "@@ -378,13 +447,18 @@ private DlmsDevice findExistingDlmsDevice(final String deviceIdentification) {\n         return dlmsDevice;\n     }\n \n-    private SecurityKey findExistingSecurityKey(final DlmsDevice dlmsDevice, final SecurityKeyType keyType,\n+    private DbEncryptedSecret findExistingSecurityKey(final DlmsDevice dlmsDevice, final SecretType secretType,\n             final String keyDescription) {\n-        final SecurityKey securityKey = dlmsDevice.getValidSecurityKey(keyType);\n-        assertThat(securityKey)\n+        List<DbEncryptedSecret> validSecrets = this.encryptedSecretRepository\n+                .findSecrets(dlmsDevice.getDeviceIdentification(), secretType, SecretStatus.ACTIVE);\n+        assertThat(validSecrets.size()).isEqualTo(1)\n+                                       .as(\"Device %s should have 1 active secret of type %s, but found %s\",\n+                                               dlmsDevice.getDeviceIdentification(), secretType, validSecrets.size());\n+        DbEncryptedSecret secret = validSecrets.get(0);", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE5NzQ4Nw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558197487", "bodyText": "Missing a final modifier according to the coding conventions.", "author": "bvdzwet", "createdAt": "2021-01-15T10:19:00Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/glue/steps/database/device/DlmsDeviceSteps.java", "diffHunk": "@@ -446,56 +520,80 @@ private void createDlmsDeviceInProtocolAdapterDatabase(final Map<String, String>\n         final ProtocolInfo protocolInfo = this.getProtocolInfo(inputSettings);\n \n         final DlmsDeviceBuilder dlmsDeviceBuilder = new DlmsDeviceBuilder().setProtocolName(protocolInfo);\n-        /*\n-         * Enable the necessary security key builders in the DLMS device builder\n-         * before calling withSettings. This allows the withSettings to be\n-         * called transitively on the enabled security key builders inside the\n-         * DLMS device builder.\n-         */\n+        final DlmsDevice dlmsDevice = dlmsDeviceBuilder.withSettings(inputSettings).build();\n+        this.dlmsDeviceRepository.save(dlmsDevice);\n+\n+        this.createDlmsDeviceInSecretManagementDatabase(dlmsDevice, inputSettings);\n+    }\n+\n+    private void createDlmsDeviceInSecretManagementDatabase(final DlmsDevice dlmsDevice,\n+            final Map<String, String> inputSettings) {\n         final String deviceType = inputSettings.getOrDefault(PlatformSmartmeteringKeys.DEVICE_TYPE, SMART_METER_E);\n+        final List<SecretBuilder> secretBuilders = new ArrayList<>();\n         if (inputSettings.containsKey(PlatformSmartmeteringKeys.LLS1_ACTIVE) && \"true\"\n                 .equals(inputSettings.get(PlatformSmartmeteringKeys.LLS1_ACTIVE))) {\n-            dlmsDeviceBuilder.getPasswordBuilder().enable();\n+            secretBuilders.add(this.getAppropriateSecretBuilder(PlatformSmartmeteringKeys.PASSWORD, inputSettings));\n         } else if (this.isGasSmartMeter(deviceType)) {\n-            dlmsDeviceBuilder.getMbusMasterSecurityKeyBuilder().enable();\n+            secretBuilders.add(this.getAppropriateSecretBuilder(MBUS_DEFAULT_KEY, inputSettings));\n             /*\n              * Don't insert a default value for the M-Bus User key. So only\n              * enable the builder if an M-Bus User key is explicitly configured\n              * in the step data.\n              */\n-            if (inputSettings.containsKey(PlatformSmartmeteringKeys.MBUS_USER_KEY)) {\n-                dlmsDeviceBuilder.getMbusEncryptionSecurityKeyBuilder().enable();\n+            if (inputSettings.containsKey(MBUS_USER_KEY)) {\n+                secretBuilders.add(this.getAppropriateSecretBuilder(MBUS_USER_KEY, inputSettings));\n             }\n         } else if (this.isESmartMeter(deviceType)) {\n-            dlmsDeviceBuilder.getEncryptionSecurityKeyBuilder().enable();\n-            dlmsDeviceBuilder.getMasterSecurityKeyBuilder().enable();\n-            dlmsDeviceBuilder.getAuthenticationSecurityKeyBuilder().enable();\n+            secretBuilders.add(this\n+                    .getAppropriateSecretBuilder(PlatformSmartmeteringKeys.KEY_DEVICE_ENCRYPTIONKEY, inputSettings));\n+            secretBuilders.add(this\n+                    .getAppropriateSecretBuilder(PlatformSmartmeteringKeys.KEY_DEVICE_MASTERKEY, inputSettings));\n+            secretBuilders.add(this.getAppropriateSecretBuilder(PlatformSmartmeteringKeys.KEY_DEVICE_AUTHENTICATIONKEY,\n+                    inputSettings));\n         }\n+        final DbEncryptionKeyReference encryptionKeyRef = this.encryptionKeyRepository\n+                .findByTypeAndValid(EncryptionProviderType.JRE, new Date()).iterator().next();\n+        secretBuilders.stream()\n+                      .filter(Objects::nonNull)\n+                      .map(SecretBuilder::build)\n+                      .map(key -> this.setSecretDefaultProperties(dlmsDevice.getDeviceIdentification(), encryptionKeyRef, key))\n+                      .forEach(this.encryptedSecretRepository::save);\n+    }\n \n-        final DlmsDevice dlmsDevice = dlmsDeviceBuilder.withSettings(inputSettings).build();\n-        this.dlmsDeviceRepository.save(dlmsDevice);\n+    private SecretBuilder getDefaultSecretBuilder(SecurityKeyType keyType) {\n+        return this.defaultSecretBuilders.stream().filter(sb -> sb.getSecurityKeyType().equals(keyType)).findFirst()\n+                                         .orElseThrow(() -> new IllegalArgumentException(\n+                                                 String.format(\"Unknown secret builder requested for type %s\",\n+                                                         keyType)));\n+    }\n \n-        if (!Base.hasConnection()) {\n-            Base.open(DatabaseConnectionParameters.getDriver(), String.format(\"jdbc:postgresql://%s:%s/%s\", DatabaseConnectionParameters.getHost(), DatabaseConnectionParameters.getPort(), DatabaseConnectionParameters.getDatabase()),\n-                    DatabaseConnectionParameters.getUser(), DatabaseConnectionParameters.getPassword());\n+    private SecretBuilder getAppropriateSecretBuilder(final String keyTypeInputName,\n+            final Map<String, String> inputSettings) {\n+        SecurityKeyType keyType = this.securityKeyTypesByInputName.get(keyTypeInputName);", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIwMjY2NQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558202665", "bodyText": "Use new HashMap<>() instead of a raw type HashMap.", "author": "bvdzwet", "createdAt": "2021-01-15T10:23:01Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/glue/steps/database/device/DlmsDeviceSteps.java", "diffHunk": "@@ -89,6 +112,53 @@\n     @Autowired\n     private DeviceFirmwareModuleSteps deviceFirmwareModuleSteps;\n \n+    @Autowired\n+    private DbEncryptedSecretRepository encryptedSecretRepository;\n+\n+    @Autowired\n+    private DbEncryptionKeyRepository encryptionKeyRepository;\n+\n+    /*private final SecretBuilder authenticationSecurityKeyBuilder = new SecretBuilder()\n+            .setSecurityKeyType(SecurityKeyType.E_METER_AUTHENTICATION)\n+            .setKey(PlatformSmartmeteringDefaults.SECURITY_KEY_A_DB);\n+    private final SecretBuilder encryptionSecurityKeyBuilder = new SecretBuilder()\n+            .setSecurityKeyType(SecurityKeyType.E_METER_ENCRYPTION)\n+            .setKey(PlatformSmartmeteringDefaults.SECURITY_KEY_E_DB);\n+    private final SecretBuilder masterSecurityKeyBuilder = new SecretBuilder()\n+            .setSecurityKeyType(SecurityKeyType.E_METER_MASTER).setKey(PlatformSmartmeteringDefaults.SECURITY_KEY_M_DB);\n+    private final SecretBuilder passwordBuilder = new SecretBuilder().setSecurityKeyType(SecurityKeyType.PASSWORD)\n+                                                                     .setKey(PlatformSmartmeteringDefaults.PASSWORD);\n+    private final SecretBuilder mbusEncryptionSecurityKeyBuilder = new SecretBuilder()\n+            .setSecurityKeyType(SecurityKeyType.G_METER_ENCRYPTION)\n+            .setKey(PlatformSmartmeteringDefaults.SECURITY_KEY_G_ENCRYPTION);\n+    private final SecretBuilder mbusMasterSecurityKeyBuilder = new SecretBuilder()\n+            .setSecurityKeyType(SecurityKeyType.G_METER_MASTER)\n+            .setKey(PlatformSmartmeteringDefaults.SECURITY_KEY_G_MASTER);*/\n+\n+    private final Map<String, SecurityKeyType> securityKeyTypesByInputName = new HashMap();", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIxMjg3NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558212874", "bodyText": "The code where now was used has been removed, leaving this as an unused local variable.\nIf it has no purpose any longer, it should be removed.", "author": "bvdzwet", "createdAt": "2021-01-15T10:30:06Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/glue/steps/database/device/DlmsDeviceSteps.java", "diffHunk": "@@ -323,23 +394,21 @@ public void aValidMbusUserKeyIsStored(final Map<String, String> settings) {\n         final DlmsDevice dlmsDevice = this.dlmsDeviceRepository.findByDeviceIdentification(deviceIdentification);\n         assertThat(dlmsDevice).as(deviceDescription + \" must be in the protocol database\").isNotNull();\n \n-        final List<SecurityKey> securityKeys = dlmsDevice.getSecurityKeys();\n+        final List<DbEncryptedSecret> securityKeys = this.findAllSecretsForDevice(deviceIdentification);\n \n         int numberOfMbusDefaultKeys = 0;\n         int numberOfMbusUserKeys = 0;\n         int numberOfValidMbusUserKeys = 0;\n \n         final Date now = new Date();", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyNDQ3Nw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558224477", "bodyText": "If the commented out method is no longer needed, it should be removed.", "author": "bvdzwet", "createdAt": "2021-01-15T10:45:13Z", "path": "integration-tests/cucumber-tests-platform/src/test/java/org/opensmartgridplatform/cucumber/platform/glue/steps/ws/GenericResponseSteps.java", "diffHunk": "@@ -30,81 +33,111 @@\n  */\n public abstract class GenericResponseSteps {\n \n-    private static String faultCode;\n-    private static String faultString;\n-\n     /**\n      * Verify the soap fault in the ScenarioContext.Current().get(Keys.RESPONSE)\n      *\n-     * @param expectedResult\n-     *            The list with expected result.\n+     * @param expected\n+     *         The list with expected result.\n      */\n-    public static void verifySoapFault(final Map<String, String> expectedResult) {\n+    public static void verifySoapFault(final Map<String, String> expected) {\n         final SoapFaultClientException soapFault = (SoapFaultClientException) ScenarioContext.current()\n-                .get(PlatformKeys.RESPONSE);\n-\n-        final QName qNameFaultCode = soapFault.getFaultCode();\n-        faultCode = qNameFaultCode.getPrefix() + \":\" + qNameFaultCode.getLocalPart();\n-        faultString = soapFault.getFaultStringOrReason();\n-\n-        final Object faultDetailValuesByElement = SoapFaultHelper.getFaultDetailValuesByElement(soapFault);\n-\n-        assertFaultDetails(expectedResult, faultDetailValuesByElement);\n+                                                                                             .get(PlatformKeys.RESPONSE);\n+        assertThat(soapFault).isNotNull();\n+        assertFaultCodeAndString(expected, soapFault);\n+        final Object actualObj = SoapFaultHelper.getFaultDetailValuesByElement(soapFault);\n+        if (actualObj instanceof EnumMap) {\n+            @SuppressWarnings(\"unchecked\") final Map<FaultDetailElement, String> actual = (Map<FaultDetailElement,\n+                    String>) actualObj;\n+            assertFaultDetailMap(expected, actual);\n+        } else if (actualObj instanceof ArrayList) {\n+            assertFaultDetailList(expected, actualObj);\n+        }\n     }\n \n-    private static void assertFaultDetails(final Map<String, String> expected, final Object actualObj) {\n+    private static void assertFaultCodeAndString(Map<String, String> expected, SoapFaultClientException soapFault) {\n+        final QName qNameFaultCode = soapFault.getFaultCode();\n+        String faultCode = qNameFaultCode.getPrefix() + \":\" + qNameFaultCode.getLocalPart();\n+        String faultString = soapFault.getFaultStringOrReason();\n \n         if (expected.containsKey(PlatformKeys.KEY_FAULTCODE)) {\n             assertThat(faultCode).isEqualTo(getString(expected, PlatformKeys.KEY_FAULTCODE));\n         }\n         if (expected.containsKey(PlatformKeys.KEY_FAULTSTRING)) {\n             assertThat(faultString).isEqualTo(getString(expected, PlatformKeys.KEY_FAULTSTRING));\n         }\n+    }\n \n-        if (actualObj instanceof EnumMap) {\n-            @SuppressWarnings(\"unchecked\")\n-            final Map<FaultDetailElement, String> actual = (Map<FaultDetailElement, String>) actualObj;\n-            for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n-                final String localName = expectedEntry.getKey();\n-                final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n-                if (faultDetailElement == null) {\n-                    /*\n-                     * Specified response parameter is not a FaultDetailElement\n-                     * (e.g. DeviceIdentification), skip it for the assertions.\n-                     */\n-                    continue;\n-                }\n+    private static void assertFaultDetailList(Map<String, String> expected, Object actualObj) {\n+        int externCounter = 0;\n+        for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n+            final String localName = expectedEntry.getKey();\n+            final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n+            if (faultDetailElement == null) {\n+                /*\n+                 * Specified response parameter is not a FaultDetailElement\n+                 * (e.g. DeviceIdentification), skip it for the assertions.\n+                 */\n+                continue;\n+            }\n \n-                final String expectedValue = expectedEntry.getValue();\n-                final String actualValue = actual.get(faultDetailElement);\n+            if (expectedEntry.getValue().contains(\";\")) {\n+                int internCounter = 0;\n+                for (final String temp : expectedEntry.getValue().split(\";\")) {\n+                    assertExpectedAndActualValues(localName, temp, actualObj, internCounter);\n+                    internCounter++;\n+                }\n+            } else {\n+                assertExpectedAndActualValues(localName, expectedEntry, actualObj, externCounter);\n+                externCounter++;\n+            }\n+        }\n+    }\n \n-                assertThat(actualValue).as(localName).isEqualTo(expectedValue);\n+    /*private static void assertFaultDetailMap(Map<String, String> expected, Map<FaultDetailElement, String> actual) {\n+        for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n+            final String localName = expectedEntry.getKey();\n+            final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n+            if (faultDetailElement == null) {\n+                /*\n+                 * Specified response parameter is not a FaultDetailElement\n+                 * (e.g. DeviceIdentification), skip it for the assertions.\n+                 *\n+                continue;\n             }\n-        } else if (actualObj instanceof ArrayList) {\n-            int externCounter = 0;\n-            for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n-                final String localName = expectedEntry.getKey();\n-                final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n-                if (faultDetailElement == null) {\n-                    /*\n-                     * Specified response parameter is not a FaultDetailElement\n-                     * (e.g. DeviceIdentification), skip it for the assertions.\n-                     */\n-                    continue;\n-                }\n \n-                if (expectedEntry.getValue().contains(\";\")) {\n-                    int internCounter = 0;\n-                    for (final String temp : expectedEntry.getValue().split(\";\")) {\n-                        assertExpectedAndActualValues(localName, temp, actualObj, internCounter);\n-                        internCounter++;\n-                    }\n-                } else {\n-                    assertExpectedAndActualValues(localName, expectedEntry, actualObj, externCounter);\n-                    externCounter++;\n-                }\n+            final String expectedValue = expectedEntry.getValue();\n+            final String actualValue = actual.get(faultDetailElement);\n+\n+            assertThat(actualValue).as(localName + \"; all actual values: \" + actual.toString())\n+                                   .isEqualTo(expectedValue);\n+        }\n+    }*/", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyNTMzNA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558225334", "bodyText": "Missing final modifiers on parameters.", "author": "bvdzwet", "createdAt": "2021-01-15T10:46:45Z", "path": "integration-tests/cucumber-tests-platform/src/test/java/org/opensmartgridplatform/cucumber/platform/glue/steps/ws/GenericResponseSteps.java", "diffHunk": "@@ -30,81 +33,111 @@\n  */\n public abstract class GenericResponseSteps {\n \n-    private static String faultCode;\n-    private static String faultString;\n-\n     /**\n      * Verify the soap fault in the ScenarioContext.Current().get(Keys.RESPONSE)\n      *\n-     * @param expectedResult\n-     *            The list with expected result.\n+     * @param expected\n+     *         The list with expected result.\n      */\n-    public static void verifySoapFault(final Map<String, String> expectedResult) {\n+    public static void verifySoapFault(final Map<String, String> expected) {\n         final SoapFaultClientException soapFault = (SoapFaultClientException) ScenarioContext.current()\n-                .get(PlatformKeys.RESPONSE);\n-\n-        final QName qNameFaultCode = soapFault.getFaultCode();\n-        faultCode = qNameFaultCode.getPrefix() + \":\" + qNameFaultCode.getLocalPart();\n-        faultString = soapFault.getFaultStringOrReason();\n-\n-        final Object faultDetailValuesByElement = SoapFaultHelper.getFaultDetailValuesByElement(soapFault);\n-\n-        assertFaultDetails(expectedResult, faultDetailValuesByElement);\n+                                                                                             .get(PlatformKeys.RESPONSE);\n+        assertThat(soapFault).isNotNull();\n+        assertFaultCodeAndString(expected, soapFault);\n+        final Object actualObj = SoapFaultHelper.getFaultDetailValuesByElement(soapFault);\n+        if (actualObj instanceof EnumMap) {\n+            @SuppressWarnings(\"unchecked\") final Map<FaultDetailElement, String> actual = (Map<FaultDetailElement,\n+                    String>) actualObj;\n+            assertFaultDetailMap(expected, actual);\n+        } else if (actualObj instanceof ArrayList) {\n+            assertFaultDetailList(expected, actualObj);\n+        }\n     }\n \n-    private static void assertFaultDetails(final Map<String, String> expected, final Object actualObj) {\n+    private static void assertFaultCodeAndString(Map<String, String> expected, SoapFaultClientException soapFault) {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyNTQxMA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558225410", "bodyText": "Missing final modifiers on parameters.", "author": "bvdzwet", "createdAt": "2021-01-15T10:46:56Z", "path": "integration-tests/cucumber-tests-platform/src/test/java/org/opensmartgridplatform/cucumber/platform/glue/steps/ws/GenericResponseSteps.java", "diffHunk": "@@ -30,81 +33,111 @@\n  */\n public abstract class GenericResponseSteps {\n \n-    private static String faultCode;\n-    private static String faultString;\n-\n     /**\n      * Verify the soap fault in the ScenarioContext.Current().get(Keys.RESPONSE)\n      *\n-     * @param expectedResult\n-     *            The list with expected result.\n+     * @param expected\n+     *         The list with expected result.\n      */\n-    public static void verifySoapFault(final Map<String, String> expectedResult) {\n+    public static void verifySoapFault(final Map<String, String> expected) {\n         final SoapFaultClientException soapFault = (SoapFaultClientException) ScenarioContext.current()\n-                .get(PlatformKeys.RESPONSE);\n-\n-        final QName qNameFaultCode = soapFault.getFaultCode();\n-        faultCode = qNameFaultCode.getPrefix() + \":\" + qNameFaultCode.getLocalPart();\n-        faultString = soapFault.getFaultStringOrReason();\n-\n-        final Object faultDetailValuesByElement = SoapFaultHelper.getFaultDetailValuesByElement(soapFault);\n-\n-        assertFaultDetails(expectedResult, faultDetailValuesByElement);\n+                                                                                             .get(PlatformKeys.RESPONSE);\n+        assertThat(soapFault).isNotNull();\n+        assertFaultCodeAndString(expected, soapFault);\n+        final Object actualObj = SoapFaultHelper.getFaultDetailValuesByElement(soapFault);\n+        if (actualObj instanceof EnumMap) {\n+            @SuppressWarnings(\"unchecked\") final Map<FaultDetailElement, String> actual = (Map<FaultDetailElement,\n+                    String>) actualObj;\n+            assertFaultDetailMap(expected, actual);\n+        } else if (actualObj instanceof ArrayList) {\n+            assertFaultDetailList(expected, actualObj);\n+        }\n     }\n \n-    private static void assertFaultDetails(final Map<String, String> expected, final Object actualObj) {\n+    private static void assertFaultCodeAndString(Map<String, String> expected, SoapFaultClientException soapFault) {\n+        final QName qNameFaultCode = soapFault.getFaultCode();\n+        String faultCode = qNameFaultCode.getPrefix() + \":\" + qNameFaultCode.getLocalPart();\n+        String faultString = soapFault.getFaultStringOrReason();\n \n         if (expected.containsKey(PlatformKeys.KEY_FAULTCODE)) {\n             assertThat(faultCode).isEqualTo(getString(expected, PlatformKeys.KEY_FAULTCODE));\n         }\n         if (expected.containsKey(PlatformKeys.KEY_FAULTSTRING)) {\n             assertThat(faultString).isEqualTo(getString(expected, PlatformKeys.KEY_FAULTSTRING));\n         }\n+    }\n \n-        if (actualObj instanceof EnumMap) {\n-            @SuppressWarnings(\"unchecked\")\n-            final Map<FaultDetailElement, String> actual = (Map<FaultDetailElement, String>) actualObj;\n-            for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n-                final String localName = expectedEntry.getKey();\n-                final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n-                if (faultDetailElement == null) {\n-                    /*\n-                     * Specified response parameter is not a FaultDetailElement\n-                     * (e.g. DeviceIdentification), skip it for the assertions.\n-                     */\n-                    continue;\n-                }\n+    private static void assertFaultDetailList(Map<String, String> expected, Object actualObj) {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyNTU0NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558225544", "bodyText": "Missing final modifiers on parameters.", "author": "bvdzwet", "createdAt": "2021-01-15T10:47:11Z", "path": "integration-tests/cucumber-tests-platform/src/test/java/org/opensmartgridplatform/cucumber/platform/glue/steps/ws/GenericResponseSteps.java", "diffHunk": "@@ -30,81 +33,111 @@\n  */\n public abstract class GenericResponseSteps {\n \n-    private static String faultCode;\n-    private static String faultString;\n-\n     /**\n      * Verify the soap fault in the ScenarioContext.Current().get(Keys.RESPONSE)\n      *\n-     * @param expectedResult\n-     *            The list with expected result.\n+     * @param expected\n+     *         The list with expected result.\n      */\n-    public static void verifySoapFault(final Map<String, String> expectedResult) {\n+    public static void verifySoapFault(final Map<String, String> expected) {\n         final SoapFaultClientException soapFault = (SoapFaultClientException) ScenarioContext.current()\n-                .get(PlatformKeys.RESPONSE);\n-\n-        final QName qNameFaultCode = soapFault.getFaultCode();\n-        faultCode = qNameFaultCode.getPrefix() + \":\" + qNameFaultCode.getLocalPart();\n-        faultString = soapFault.getFaultStringOrReason();\n-\n-        final Object faultDetailValuesByElement = SoapFaultHelper.getFaultDetailValuesByElement(soapFault);\n-\n-        assertFaultDetails(expectedResult, faultDetailValuesByElement);\n+                                                                                             .get(PlatformKeys.RESPONSE);\n+        assertThat(soapFault).isNotNull();\n+        assertFaultCodeAndString(expected, soapFault);\n+        final Object actualObj = SoapFaultHelper.getFaultDetailValuesByElement(soapFault);\n+        if (actualObj instanceof EnumMap) {\n+            @SuppressWarnings(\"unchecked\") final Map<FaultDetailElement, String> actual = (Map<FaultDetailElement,\n+                    String>) actualObj;\n+            assertFaultDetailMap(expected, actual);\n+        } else if (actualObj instanceof ArrayList) {\n+            assertFaultDetailList(expected, actualObj);\n+        }\n     }\n \n-    private static void assertFaultDetails(final Map<String, String> expected, final Object actualObj) {\n+    private static void assertFaultCodeAndString(Map<String, String> expected, SoapFaultClientException soapFault) {\n+        final QName qNameFaultCode = soapFault.getFaultCode();\n+        String faultCode = qNameFaultCode.getPrefix() + \":\" + qNameFaultCode.getLocalPart();\n+        String faultString = soapFault.getFaultStringOrReason();\n \n         if (expected.containsKey(PlatformKeys.KEY_FAULTCODE)) {\n             assertThat(faultCode).isEqualTo(getString(expected, PlatformKeys.KEY_FAULTCODE));\n         }\n         if (expected.containsKey(PlatformKeys.KEY_FAULTSTRING)) {\n             assertThat(faultString).isEqualTo(getString(expected, PlatformKeys.KEY_FAULTSTRING));\n         }\n+    }\n \n-        if (actualObj instanceof EnumMap) {\n-            @SuppressWarnings(\"unchecked\")\n-            final Map<FaultDetailElement, String> actual = (Map<FaultDetailElement, String>) actualObj;\n-            for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n-                final String localName = expectedEntry.getKey();\n-                final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n-                if (faultDetailElement == null) {\n-                    /*\n-                     * Specified response parameter is not a FaultDetailElement\n-                     * (e.g. DeviceIdentification), skip it for the assertions.\n-                     */\n-                    continue;\n-                }\n+    private static void assertFaultDetailList(Map<String, String> expected, Object actualObj) {\n+        int externCounter = 0;\n+        for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n+            final String localName = expectedEntry.getKey();\n+            final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n+            if (faultDetailElement == null) {\n+                /*\n+                 * Specified response parameter is not a FaultDetailElement\n+                 * (e.g. DeviceIdentification), skip it for the assertions.\n+                 */\n+                continue;\n+            }\n \n-                final String expectedValue = expectedEntry.getValue();\n-                final String actualValue = actual.get(faultDetailElement);\n+            if (expectedEntry.getValue().contains(\";\")) {\n+                int internCounter = 0;\n+                for (final String temp : expectedEntry.getValue().split(\";\")) {\n+                    assertExpectedAndActualValues(localName, temp, actualObj, internCounter);\n+                    internCounter++;\n+                }\n+            } else {\n+                assertExpectedAndActualValues(localName, expectedEntry, actualObj, externCounter);\n+                externCounter++;\n+            }\n+        }\n+    }\n \n-                assertThat(actualValue).as(localName).isEqualTo(expectedValue);\n+    /*private static void assertFaultDetailMap(Map<String, String> expected, Map<FaultDetailElement, String> actual) {\n+        for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n+            final String localName = expectedEntry.getKey();\n+            final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n+            if (faultDetailElement == null) {\n+                /*\n+                 * Specified response parameter is not a FaultDetailElement\n+                 * (e.g. DeviceIdentification), skip it for the assertions.\n+                 *\n+                continue;\n             }\n-        } else if (actualObj instanceof ArrayList) {\n-            int externCounter = 0;\n-            for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n-                final String localName = expectedEntry.getKey();\n-                final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n-                if (faultDetailElement == null) {\n-                    /*\n-                     * Specified response parameter is not a FaultDetailElement\n-                     * (e.g. DeviceIdentification), skip it for the assertions.\n-                     */\n-                    continue;\n-                }\n \n-                if (expectedEntry.getValue().contains(\";\")) {\n-                    int internCounter = 0;\n-                    for (final String temp : expectedEntry.getValue().split(\";\")) {\n-                        assertExpectedAndActualValues(localName, temp, actualObj, internCounter);\n-                        internCounter++;\n-                    }\n-                } else {\n-                    assertExpectedAndActualValues(localName, expectedEntry, actualObj, externCounter);\n-                    externCounter++;\n-                }\n+            final String expectedValue = expectedEntry.getValue();\n+            final String actualValue = actual.get(faultDetailElement);\n+\n+            assertThat(actualValue).as(localName + \"; all actual values: \" + actual.toString())\n+                                   .isEqualTo(expectedValue);\n+        }\n+    }*/\n+\n+    private static void assertFaultDetailMap(Map<String, String> expected, Map<FaultDetailElement, String> actual) {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyNjEwMQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558226101", "bodyText": "Missing final modifier on entry.", "author": "bvdzwet", "createdAt": "2021-01-15T10:48:01Z", "path": "integration-tests/cucumber-tests-platform/src/test/java/org/opensmartgridplatform/cucumber/platform/glue/steps/ws/GenericResponseSteps.java", "diffHunk": "@@ -30,81 +33,111 @@\n  */\n public abstract class GenericResponseSteps {\n \n-    private static String faultCode;\n-    private static String faultString;\n-\n     /**\n      * Verify the soap fault in the ScenarioContext.Current().get(Keys.RESPONSE)\n      *\n-     * @param expectedResult\n-     *            The list with expected result.\n+     * @param expected\n+     *         The list with expected result.\n      */\n-    public static void verifySoapFault(final Map<String, String> expectedResult) {\n+    public static void verifySoapFault(final Map<String, String> expected) {\n         final SoapFaultClientException soapFault = (SoapFaultClientException) ScenarioContext.current()\n-                .get(PlatformKeys.RESPONSE);\n-\n-        final QName qNameFaultCode = soapFault.getFaultCode();\n-        faultCode = qNameFaultCode.getPrefix() + \":\" + qNameFaultCode.getLocalPart();\n-        faultString = soapFault.getFaultStringOrReason();\n-\n-        final Object faultDetailValuesByElement = SoapFaultHelper.getFaultDetailValuesByElement(soapFault);\n-\n-        assertFaultDetails(expectedResult, faultDetailValuesByElement);\n+                                                                                             .get(PlatformKeys.RESPONSE);\n+        assertThat(soapFault).isNotNull();\n+        assertFaultCodeAndString(expected, soapFault);\n+        final Object actualObj = SoapFaultHelper.getFaultDetailValuesByElement(soapFault);\n+        if (actualObj instanceof EnumMap) {\n+            @SuppressWarnings(\"unchecked\") final Map<FaultDetailElement, String> actual = (Map<FaultDetailElement,\n+                    String>) actualObj;\n+            assertFaultDetailMap(expected, actual);\n+        } else if (actualObj instanceof ArrayList) {\n+            assertFaultDetailList(expected, actualObj);\n+        }\n     }\n \n-    private static void assertFaultDetails(final Map<String, String> expected, final Object actualObj) {\n+    private static void assertFaultCodeAndString(Map<String, String> expected, SoapFaultClientException soapFault) {\n+        final QName qNameFaultCode = soapFault.getFaultCode();\n+        String faultCode = qNameFaultCode.getPrefix() + \":\" + qNameFaultCode.getLocalPart();\n+        String faultString = soapFault.getFaultStringOrReason();\n \n         if (expected.containsKey(PlatformKeys.KEY_FAULTCODE)) {\n             assertThat(faultCode).isEqualTo(getString(expected, PlatformKeys.KEY_FAULTCODE));\n         }\n         if (expected.containsKey(PlatformKeys.KEY_FAULTSTRING)) {\n             assertThat(faultString).isEqualTo(getString(expected, PlatformKeys.KEY_FAULTSTRING));\n         }\n+    }\n \n-        if (actualObj instanceof EnumMap) {\n-            @SuppressWarnings(\"unchecked\")\n-            final Map<FaultDetailElement, String> actual = (Map<FaultDetailElement, String>) actualObj;\n-            for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n-                final String localName = expectedEntry.getKey();\n-                final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n-                if (faultDetailElement == null) {\n-                    /*\n-                     * Specified response parameter is not a FaultDetailElement\n-                     * (e.g. DeviceIdentification), skip it for the assertions.\n-                     */\n-                    continue;\n-                }\n+    private static void assertFaultDetailList(Map<String, String> expected, Object actualObj) {\n+        int externCounter = 0;\n+        for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n+            final String localName = expectedEntry.getKey();\n+            final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n+            if (faultDetailElement == null) {\n+                /*\n+                 * Specified response parameter is not a FaultDetailElement\n+                 * (e.g. DeviceIdentification), skip it for the assertions.\n+                 */\n+                continue;\n+            }\n \n-                final String expectedValue = expectedEntry.getValue();\n-                final String actualValue = actual.get(faultDetailElement);\n+            if (expectedEntry.getValue().contains(\";\")) {\n+                int internCounter = 0;\n+                for (final String temp : expectedEntry.getValue().split(\";\")) {\n+                    assertExpectedAndActualValues(localName, temp, actualObj, internCounter);\n+                    internCounter++;\n+                }\n+            } else {\n+                assertExpectedAndActualValues(localName, expectedEntry, actualObj, externCounter);\n+                externCounter++;\n+            }\n+        }\n+    }\n \n-                assertThat(actualValue).as(localName).isEqualTo(expectedValue);\n+    /*private static void assertFaultDetailMap(Map<String, String> expected, Map<FaultDetailElement, String> actual) {\n+        for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n+            final String localName = expectedEntry.getKey();\n+            final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n+            if (faultDetailElement == null) {\n+                /*\n+                 * Specified response parameter is not a FaultDetailElement\n+                 * (e.g. DeviceIdentification), skip it for the assertions.\n+                 *\n+                continue;\n             }\n-        } else if (actualObj instanceof ArrayList) {\n-            int externCounter = 0;\n-            for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n-                final String localName = expectedEntry.getKey();\n-                final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n-                if (faultDetailElement == null) {\n-                    /*\n-                     * Specified response parameter is not a FaultDetailElement\n-                     * (e.g. DeviceIdentification), skip it for the assertions.\n-                     */\n-                    continue;\n-                }\n \n-                if (expectedEntry.getValue().contains(\";\")) {\n-                    int internCounter = 0;\n-                    for (final String temp : expectedEntry.getValue().split(\";\")) {\n-                        assertExpectedAndActualValues(localName, temp, actualObj, internCounter);\n-                        internCounter++;\n-                    }\n-                } else {\n-                    assertExpectedAndActualValues(localName, expectedEntry, actualObj, externCounter);\n-                    externCounter++;\n-                }\n+            final String expectedValue = expectedEntry.getValue();\n+            final String actualValue = actual.get(faultDetailElement);\n+\n+            assertThat(actualValue).as(localName + \"; all actual values: \" + actual.toString())\n+                                   .isEqualTo(expectedValue);\n+        }\n+    }*/\n+\n+    private static void assertFaultDetailMap(Map<String, String> expected, Map<FaultDetailElement, String> actual) {\n+        final Map<String,String> actualByName = new HashMap<>();\n+        for(Map.Entry<FaultDetailElement,String> entry: actual.entrySet()) {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyNjc4MA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558226780", "bodyText": "Missing space after for.", "author": "bvdzwet", "createdAt": "2021-01-15T10:49:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyNjEwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyNjIwMQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558226201", "bodyText": "Missing final modifier on entry.", "author": "bvdzwet", "createdAt": "2021-01-15T10:48:13Z", "path": "integration-tests/cucumber-tests-platform/src/test/java/org/opensmartgridplatform/cucumber/platform/glue/steps/ws/GenericResponseSteps.java", "diffHunk": "@@ -30,81 +33,111 @@\n  */\n public abstract class GenericResponseSteps {\n \n-    private static String faultCode;\n-    private static String faultString;\n-\n     /**\n      * Verify the soap fault in the ScenarioContext.Current().get(Keys.RESPONSE)\n      *\n-     * @param expectedResult\n-     *            The list with expected result.\n+     * @param expected\n+     *         The list with expected result.\n      */\n-    public static void verifySoapFault(final Map<String, String> expectedResult) {\n+    public static void verifySoapFault(final Map<String, String> expected) {\n         final SoapFaultClientException soapFault = (SoapFaultClientException) ScenarioContext.current()\n-                .get(PlatformKeys.RESPONSE);\n-\n-        final QName qNameFaultCode = soapFault.getFaultCode();\n-        faultCode = qNameFaultCode.getPrefix() + \":\" + qNameFaultCode.getLocalPart();\n-        faultString = soapFault.getFaultStringOrReason();\n-\n-        final Object faultDetailValuesByElement = SoapFaultHelper.getFaultDetailValuesByElement(soapFault);\n-\n-        assertFaultDetails(expectedResult, faultDetailValuesByElement);\n+                                                                                             .get(PlatformKeys.RESPONSE);\n+        assertThat(soapFault).isNotNull();\n+        assertFaultCodeAndString(expected, soapFault);\n+        final Object actualObj = SoapFaultHelper.getFaultDetailValuesByElement(soapFault);\n+        if (actualObj instanceof EnumMap) {\n+            @SuppressWarnings(\"unchecked\") final Map<FaultDetailElement, String> actual = (Map<FaultDetailElement,\n+                    String>) actualObj;\n+            assertFaultDetailMap(expected, actual);\n+        } else if (actualObj instanceof ArrayList) {\n+            assertFaultDetailList(expected, actualObj);\n+        }\n     }\n \n-    private static void assertFaultDetails(final Map<String, String> expected, final Object actualObj) {\n+    private static void assertFaultCodeAndString(Map<String, String> expected, SoapFaultClientException soapFault) {\n+        final QName qNameFaultCode = soapFault.getFaultCode();\n+        String faultCode = qNameFaultCode.getPrefix() + \":\" + qNameFaultCode.getLocalPart();\n+        String faultString = soapFault.getFaultStringOrReason();\n \n         if (expected.containsKey(PlatformKeys.KEY_FAULTCODE)) {\n             assertThat(faultCode).isEqualTo(getString(expected, PlatformKeys.KEY_FAULTCODE));\n         }\n         if (expected.containsKey(PlatformKeys.KEY_FAULTSTRING)) {\n             assertThat(faultString).isEqualTo(getString(expected, PlatformKeys.KEY_FAULTSTRING));\n         }\n+    }\n \n-        if (actualObj instanceof EnumMap) {\n-            @SuppressWarnings(\"unchecked\")\n-            final Map<FaultDetailElement, String> actual = (Map<FaultDetailElement, String>) actualObj;\n-            for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n-                final String localName = expectedEntry.getKey();\n-                final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n-                if (faultDetailElement == null) {\n-                    /*\n-                     * Specified response parameter is not a FaultDetailElement\n-                     * (e.g. DeviceIdentification), skip it for the assertions.\n-                     */\n-                    continue;\n-                }\n+    private static void assertFaultDetailList(Map<String, String> expected, Object actualObj) {\n+        int externCounter = 0;\n+        for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n+            final String localName = expectedEntry.getKey();\n+            final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n+            if (faultDetailElement == null) {\n+                /*\n+                 * Specified response parameter is not a FaultDetailElement\n+                 * (e.g. DeviceIdentification), skip it for the assertions.\n+                 */\n+                continue;\n+            }\n \n-                final String expectedValue = expectedEntry.getValue();\n-                final String actualValue = actual.get(faultDetailElement);\n+            if (expectedEntry.getValue().contains(\";\")) {\n+                int internCounter = 0;\n+                for (final String temp : expectedEntry.getValue().split(\";\")) {\n+                    assertExpectedAndActualValues(localName, temp, actualObj, internCounter);\n+                    internCounter++;\n+                }\n+            } else {\n+                assertExpectedAndActualValues(localName, expectedEntry, actualObj, externCounter);\n+                externCounter++;\n+            }\n+        }\n+    }\n \n-                assertThat(actualValue).as(localName).isEqualTo(expectedValue);\n+    /*private static void assertFaultDetailMap(Map<String, String> expected, Map<FaultDetailElement, String> actual) {\n+        for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n+            final String localName = expectedEntry.getKey();\n+            final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n+            if (faultDetailElement == null) {\n+                /*\n+                 * Specified response parameter is not a FaultDetailElement\n+                 * (e.g. DeviceIdentification), skip it for the assertions.\n+                 *\n+                continue;\n             }\n-        } else if (actualObj instanceof ArrayList) {\n-            int externCounter = 0;\n-            for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n-                final String localName = expectedEntry.getKey();\n-                final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n-                if (faultDetailElement == null) {\n-                    /*\n-                     * Specified response parameter is not a FaultDetailElement\n-                     * (e.g. DeviceIdentification), skip it for the assertions.\n-                     */\n-                    continue;\n-                }\n \n-                if (expectedEntry.getValue().contains(\";\")) {\n-                    int internCounter = 0;\n-                    for (final String temp : expectedEntry.getValue().split(\";\")) {\n-                        assertExpectedAndActualValues(localName, temp, actualObj, internCounter);\n-                        internCounter++;\n-                    }\n-                } else {\n-                    assertExpectedAndActualValues(localName, expectedEntry, actualObj, externCounter);\n-                    externCounter++;\n-                }\n+            final String expectedValue = expectedEntry.getValue();\n+            final String actualValue = actual.get(faultDetailElement);\n+\n+            assertThat(actualValue).as(localName + \"; all actual values: \" + actual.toString())\n+                                   .isEqualTo(expectedValue);\n+        }\n+    }*/\n+\n+    private static void assertFaultDetailMap(Map<String, String> expected, Map<FaultDetailElement, String> actual) {\n+        final Map<String,String> actualByName = new HashMap<>();\n+        for(Map.Entry<FaultDetailElement,String> entry: actual.entrySet()) {\n+            actualByName.put(entry.getKey().getLocalName(),entry.getValue());\n+        }\n+        final Map<String,String> expectedFaults = new HashMap<>();\n+        for(Map.Entry<String,String> entry: expected.entrySet()) {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyNjgzNg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558226836", "bodyText": "Missing space after for.", "author": "bvdzwet", "createdAt": "2021-01-15T10:49:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyNjIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyNzQyNQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558227425", "bodyText": "Missing final modifier on local variables.", "author": "bvdzwet", "createdAt": "2021-01-15T10:50:22Z", "path": "integration-tests/cucumber-tests-platform/src/test/java/org/opensmartgridplatform/cucumber/platform/glue/steps/ws/GenericResponseSteps.java", "diffHunk": "@@ -30,81 +33,111 @@\n  */\n public abstract class GenericResponseSteps {\n \n-    private static String faultCode;\n-    private static String faultString;\n-\n     /**\n      * Verify the soap fault in the ScenarioContext.Current().get(Keys.RESPONSE)\n      *\n-     * @param expectedResult\n-     *            The list with expected result.\n+     * @param expected\n+     *         The list with expected result.\n      */\n-    public static void verifySoapFault(final Map<String, String> expectedResult) {\n+    public static void verifySoapFault(final Map<String, String> expected) {\n         final SoapFaultClientException soapFault = (SoapFaultClientException) ScenarioContext.current()\n-                .get(PlatformKeys.RESPONSE);\n-\n-        final QName qNameFaultCode = soapFault.getFaultCode();\n-        faultCode = qNameFaultCode.getPrefix() + \":\" + qNameFaultCode.getLocalPart();\n-        faultString = soapFault.getFaultStringOrReason();\n-\n-        final Object faultDetailValuesByElement = SoapFaultHelper.getFaultDetailValuesByElement(soapFault);\n-\n-        assertFaultDetails(expectedResult, faultDetailValuesByElement);\n+                                                                                             .get(PlatformKeys.RESPONSE);\n+        assertThat(soapFault).isNotNull();\n+        assertFaultCodeAndString(expected, soapFault);\n+        final Object actualObj = SoapFaultHelper.getFaultDetailValuesByElement(soapFault);\n+        if (actualObj instanceof EnumMap) {\n+            @SuppressWarnings(\"unchecked\") final Map<FaultDetailElement, String> actual = (Map<FaultDetailElement,\n+                    String>) actualObj;\n+            assertFaultDetailMap(expected, actual);\n+        } else if (actualObj instanceof ArrayList) {\n+            assertFaultDetailList(expected, actualObj);\n+        }\n     }\n \n-    private static void assertFaultDetails(final Map<String, String> expected, final Object actualObj) {\n+    private static void assertFaultCodeAndString(Map<String, String> expected, SoapFaultClientException soapFault) {\n+        final QName qNameFaultCode = soapFault.getFaultCode();\n+        String faultCode = qNameFaultCode.getPrefix() + \":\" + qNameFaultCode.getLocalPart();\n+        String faultString = soapFault.getFaultStringOrReason();", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyODMwOQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558228309", "bodyText": "Missing space after //.", "author": "bvdzwet", "createdAt": "2021-01-15T10:52:11Z", "path": "integration-tests/cucumber-tests-platform/src/test/java/org/opensmartgridplatform/cucumber/platform/glue/steps/ws/GenericResponseSteps.java", "diffHunk": "@@ -30,81 +33,111 @@\n  */\n public abstract class GenericResponseSteps {\n \n-    private static String faultCode;\n-    private static String faultString;\n-\n     /**\n      * Verify the soap fault in the ScenarioContext.Current().get(Keys.RESPONSE)\n      *\n-     * @param expectedResult\n-     *            The list with expected result.\n+     * @param expected\n+     *         The list with expected result.\n      */\n-    public static void verifySoapFault(final Map<String, String> expectedResult) {\n+    public static void verifySoapFault(final Map<String, String> expected) {\n         final SoapFaultClientException soapFault = (SoapFaultClientException) ScenarioContext.current()\n-                .get(PlatformKeys.RESPONSE);\n-\n-        final QName qNameFaultCode = soapFault.getFaultCode();\n-        faultCode = qNameFaultCode.getPrefix() + \":\" + qNameFaultCode.getLocalPart();\n-        faultString = soapFault.getFaultStringOrReason();\n-\n-        final Object faultDetailValuesByElement = SoapFaultHelper.getFaultDetailValuesByElement(soapFault);\n-\n-        assertFaultDetails(expectedResult, faultDetailValuesByElement);\n+                                                                                             .get(PlatformKeys.RESPONSE);\n+        assertThat(soapFault).isNotNull();\n+        assertFaultCodeAndString(expected, soapFault);\n+        final Object actualObj = SoapFaultHelper.getFaultDetailValuesByElement(soapFault);\n+        if (actualObj instanceof EnumMap) {\n+            @SuppressWarnings(\"unchecked\") final Map<FaultDetailElement, String> actual = (Map<FaultDetailElement,\n+                    String>) actualObj;\n+            assertFaultDetailMap(expected, actual);\n+        } else if (actualObj instanceof ArrayList) {\n+            assertFaultDetailList(expected, actualObj);\n+        }\n     }\n \n-    private static void assertFaultDetails(final Map<String, String> expected, final Object actualObj) {\n+    private static void assertFaultCodeAndString(Map<String, String> expected, SoapFaultClientException soapFault) {\n+        final QName qNameFaultCode = soapFault.getFaultCode();\n+        String faultCode = qNameFaultCode.getPrefix() + \":\" + qNameFaultCode.getLocalPart();\n+        String faultString = soapFault.getFaultStringOrReason();\n \n         if (expected.containsKey(PlatformKeys.KEY_FAULTCODE)) {\n             assertThat(faultCode).isEqualTo(getString(expected, PlatformKeys.KEY_FAULTCODE));\n         }\n         if (expected.containsKey(PlatformKeys.KEY_FAULTSTRING)) {\n             assertThat(faultString).isEqualTo(getString(expected, PlatformKeys.KEY_FAULTSTRING));\n         }\n+    }\n \n-        if (actualObj instanceof EnumMap) {\n-            @SuppressWarnings(\"unchecked\")\n-            final Map<FaultDetailElement, String> actual = (Map<FaultDetailElement, String>) actualObj;\n-            for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n-                final String localName = expectedEntry.getKey();\n-                final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n-                if (faultDetailElement == null) {\n-                    /*\n-                     * Specified response parameter is not a FaultDetailElement\n-                     * (e.g. DeviceIdentification), skip it for the assertions.\n-                     */\n-                    continue;\n-                }\n+    private static void assertFaultDetailList(Map<String, String> expected, Object actualObj) {\n+        int externCounter = 0;\n+        for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n+            final String localName = expectedEntry.getKey();\n+            final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n+            if (faultDetailElement == null) {\n+                /*\n+                 * Specified response parameter is not a FaultDetailElement\n+                 * (e.g. DeviceIdentification), skip it for the assertions.\n+                 */\n+                continue;\n+            }\n \n-                final String expectedValue = expectedEntry.getValue();\n-                final String actualValue = actual.get(faultDetailElement);\n+            if (expectedEntry.getValue().contains(\";\")) {\n+                int internCounter = 0;\n+                for (final String temp : expectedEntry.getValue().split(\";\")) {\n+                    assertExpectedAndActualValues(localName, temp, actualObj, internCounter);\n+                    internCounter++;\n+                }\n+            } else {\n+                assertExpectedAndActualValues(localName, expectedEntry, actualObj, externCounter);\n+                externCounter++;\n+            }\n+        }\n+    }\n \n-                assertThat(actualValue).as(localName).isEqualTo(expectedValue);\n+    /*private static void assertFaultDetailMap(Map<String, String> expected, Map<FaultDetailElement, String> actual) {\n+        for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n+            final String localName = expectedEntry.getKey();\n+            final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n+            if (faultDetailElement == null) {\n+                /*\n+                 * Specified response parameter is not a FaultDetailElement\n+                 * (e.g. DeviceIdentification), skip it for the assertions.\n+                 *\n+                continue;\n             }\n-        } else if (actualObj instanceof ArrayList) {\n-            int externCounter = 0;\n-            for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n-                final String localName = expectedEntry.getKey();\n-                final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n-                if (faultDetailElement == null) {\n-                    /*\n-                     * Specified response parameter is not a FaultDetailElement\n-                     * (e.g. DeviceIdentification), skip it for the assertions.\n-                     */\n-                    continue;\n-                }\n \n-                if (expectedEntry.getValue().contains(\";\")) {\n-                    int internCounter = 0;\n-                    for (final String temp : expectedEntry.getValue().split(\";\")) {\n-                        assertExpectedAndActualValues(localName, temp, actualObj, internCounter);\n-                        internCounter++;\n-                    }\n-                } else {\n-                    assertExpectedAndActualValues(localName, expectedEntry, actualObj, externCounter);\n-                    externCounter++;\n-                }\n+            final String expectedValue = expectedEntry.getValue();\n+            final String actualValue = actual.get(faultDetailElement);\n+\n+            assertThat(actualValue).as(localName + \"; all actual values: \" + actual.toString())\n+                                   .isEqualTo(expectedValue);\n+        }\n+    }*/\n+\n+    private static void assertFaultDetailMap(Map<String, String> expected, Map<FaultDetailElement, String> actual) {\n+        final Map<String,String> actualByName = new HashMap<>();\n+        for(Map.Entry<FaultDetailElement,String> entry: actual.entrySet()) {\n+            actualByName.put(entry.getKey().getLocalName(),entry.getValue());\n+        }\n+        final Map<String,String> expectedFaults = new HashMap<>();\n+        for(Map.Entry<String,String> entry: expected.entrySet()) {\n+            if(FaultDetailElement.forLocalName(entry.getKey())!=null) {\n+                expectedFaults.put(entry.getKey(),entry.getValue());\n             }\n         }\n+        SoftAssertions soft = new SoftAssertions();\n+        soft.assertThat(actualByName.keySet()).as(\"Actual fault fields\").containsAll(expectedFaults.keySet());\n+        if(!actualByName.keySet().containsAll(expectedFaults.keySet())) {\n+            //Not all expected fields are there: fail with message containing full response", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyODgwMA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558228800", "bodyText": "Missing space after for, missing space after comma, missing space before and after the colon and missing a final modifier on expectedEntry.", "author": "bvdzwet", "createdAt": "2021-01-15T10:53:10Z", "path": "integration-tests/cucumber-tests-platform/src/test/java/org/opensmartgridplatform/cucumber/platform/glue/steps/ws/GenericResponseSteps.java", "diffHunk": "@@ -30,81 +33,111 @@\n  */\n public abstract class GenericResponseSteps {\n \n-    private static String faultCode;\n-    private static String faultString;\n-\n     /**\n      * Verify the soap fault in the ScenarioContext.Current().get(Keys.RESPONSE)\n      *\n-     * @param expectedResult\n-     *            The list with expected result.\n+     * @param expected\n+     *         The list with expected result.\n      */\n-    public static void verifySoapFault(final Map<String, String> expectedResult) {\n+    public static void verifySoapFault(final Map<String, String> expected) {\n         final SoapFaultClientException soapFault = (SoapFaultClientException) ScenarioContext.current()\n-                .get(PlatformKeys.RESPONSE);\n-\n-        final QName qNameFaultCode = soapFault.getFaultCode();\n-        faultCode = qNameFaultCode.getPrefix() + \":\" + qNameFaultCode.getLocalPart();\n-        faultString = soapFault.getFaultStringOrReason();\n-\n-        final Object faultDetailValuesByElement = SoapFaultHelper.getFaultDetailValuesByElement(soapFault);\n-\n-        assertFaultDetails(expectedResult, faultDetailValuesByElement);\n+                                                                                             .get(PlatformKeys.RESPONSE);\n+        assertThat(soapFault).isNotNull();\n+        assertFaultCodeAndString(expected, soapFault);\n+        final Object actualObj = SoapFaultHelper.getFaultDetailValuesByElement(soapFault);\n+        if (actualObj instanceof EnumMap) {\n+            @SuppressWarnings(\"unchecked\") final Map<FaultDetailElement, String> actual = (Map<FaultDetailElement,\n+                    String>) actualObj;\n+            assertFaultDetailMap(expected, actual);\n+        } else if (actualObj instanceof ArrayList) {\n+            assertFaultDetailList(expected, actualObj);\n+        }\n     }\n \n-    private static void assertFaultDetails(final Map<String, String> expected, final Object actualObj) {\n+    private static void assertFaultCodeAndString(Map<String, String> expected, SoapFaultClientException soapFault) {\n+        final QName qNameFaultCode = soapFault.getFaultCode();\n+        String faultCode = qNameFaultCode.getPrefix() + \":\" + qNameFaultCode.getLocalPart();\n+        String faultString = soapFault.getFaultStringOrReason();\n \n         if (expected.containsKey(PlatformKeys.KEY_FAULTCODE)) {\n             assertThat(faultCode).isEqualTo(getString(expected, PlatformKeys.KEY_FAULTCODE));\n         }\n         if (expected.containsKey(PlatformKeys.KEY_FAULTSTRING)) {\n             assertThat(faultString).isEqualTo(getString(expected, PlatformKeys.KEY_FAULTSTRING));\n         }\n+    }\n \n-        if (actualObj instanceof EnumMap) {\n-            @SuppressWarnings(\"unchecked\")\n-            final Map<FaultDetailElement, String> actual = (Map<FaultDetailElement, String>) actualObj;\n-            for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n-                final String localName = expectedEntry.getKey();\n-                final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n-                if (faultDetailElement == null) {\n-                    /*\n-                     * Specified response parameter is not a FaultDetailElement\n-                     * (e.g. DeviceIdentification), skip it for the assertions.\n-                     */\n-                    continue;\n-                }\n+    private static void assertFaultDetailList(Map<String, String> expected, Object actualObj) {\n+        int externCounter = 0;\n+        for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n+            final String localName = expectedEntry.getKey();\n+            final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n+            if (faultDetailElement == null) {\n+                /*\n+                 * Specified response parameter is not a FaultDetailElement\n+                 * (e.g. DeviceIdentification), skip it for the assertions.\n+                 */\n+                continue;\n+            }\n \n-                final String expectedValue = expectedEntry.getValue();\n-                final String actualValue = actual.get(faultDetailElement);\n+            if (expectedEntry.getValue().contains(\";\")) {\n+                int internCounter = 0;\n+                for (final String temp : expectedEntry.getValue().split(\";\")) {\n+                    assertExpectedAndActualValues(localName, temp, actualObj, internCounter);\n+                    internCounter++;\n+                }\n+            } else {\n+                assertExpectedAndActualValues(localName, expectedEntry, actualObj, externCounter);\n+                externCounter++;\n+            }\n+        }\n+    }\n \n-                assertThat(actualValue).as(localName).isEqualTo(expectedValue);\n+    /*private static void assertFaultDetailMap(Map<String, String> expected, Map<FaultDetailElement, String> actual) {\n+        for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n+            final String localName = expectedEntry.getKey();\n+            final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n+            if (faultDetailElement == null) {\n+                /*\n+                 * Specified response parameter is not a FaultDetailElement\n+                 * (e.g. DeviceIdentification), skip it for the assertions.\n+                 *\n+                continue;\n             }\n-        } else if (actualObj instanceof ArrayList) {\n-            int externCounter = 0;\n-            for (final Map.Entry<String, String> expectedEntry : expected.entrySet()) {\n-                final String localName = expectedEntry.getKey();\n-                final FaultDetailElement faultDetailElement = FaultDetailElement.forLocalName(localName);\n-                if (faultDetailElement == null) {\n-                    /*\n-                     * Specified response parameter is not a FaultDetailElement\n-                     * (e.g. DeviceIdentification), skip it for the assertions.\n-                     */\n-                    continue;\n-                }\n \n-                if (expectedEntry.getValue().contains(\";\")) {\n-                    int internCounter = 0;\n-                    for (final String temp : expectedEntry.getValue().split(\";\")) {\n-                        assertExpectedAndActualValues(localName, temp, actualObj, internCounter);\n-                        internCounter++;\n-                    }\n-                } else {\n-                    assertExpectedAndActualValues(localName, expectedEntry, actualObj, externCounter);\n-                    externCounter++;\n-                }\n+            final String expectedValue = expectedEntry.getValue();\n+            final String actualValue = actual.get(faultDetailElement);\n+\n+            assertThat(actualValue).as(localName + \"; all actual values: \" + actual.toString())\n+                                   .isEqualTo(expectedValue);\n+        }\n+    }*/\n+\n+    private static void assertFaultDetailMap(Map<String, String> expected, Map<FaultDetailElement, String> actual) {\n+        final Map<String,String> actualByName = new HashMap<>();\n+        for(Map.Entry<FaultDetailElement,String> entry: actual.entrySet()) {\n+            actualByName.put(entry.getKey().getLocalName(),entry.getValue());\n+        }\n+        final Map<String,String> expectedFaults = new HashMap<>();\n+        for(Map.Entry<String,String> entry: expected.entrySet()) {\n+            if(FaultDetailElement.forLocalName(entry.getKey())!=null) {\n+                expectedFaults.put(entry.getKey(),entry.getValue());\n             }\n         }\n+        SoftAssertions soft = new SoftAssertions();\n+        soft.assertThat(actualByName.keySet()).as(\"Actual fault fields\").containsAll(expectedFaults.keySet());\n+        if(!actualByName.keySet().containsAll(expectedFaults.keySet())) {\n+            //Not all expected fields are there: fail with message containing full response\n+            soft.fail(\"Not all expected fields are present; expectedFaults=%s, actualFaultDetailElements=%s\",\n+                    expectedFaults,\n+                    actual);\n+        }\n+        for(Map.Entry<String,String> expectedEntry:expectedFaults.entrySet()) {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIzMTgyNw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558231827", "bodyText": "According to the code formatting guidelines, a new line is to be inserted after an annotation on a local variable.", "author": "bvdzwet", "createdAt": "2021-01-15T10:58:42Z", "path": "integration-tests/cucumber-tests-platform/src/test/java/org/opensmartgridplatform/cucumber/platform/glue/steps/ws/GenericResponseSteps.java", "diffHunk": "@@ -118,8 +151,7 @@ private static void assertExpectedAndActualValues(final String localName, final\n             final Object actual, final int counter) {\n \n         final Pattern pattern = Pattern.compile(\"('.+\\\\d+:.+')\", Pattern.CASE_INSENSITIVE);\n-        @SuppressWarnings(\"unchecked\")\n-        final String actualValue = ((List<String>) actual).get(counter);\n+        @SuppressWarnings(\"unchecked\") final String actualValue = ((List<String>) actual).get(counter);", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI2NzQwMw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558267403", "bodyText": "If this expectation is not used it should be removed instead of commented out.\nComments in several places in this file are missing a space after //.", "author": "bvdzwet", "createdAt": "2021-01-15T12:12:32Z", "path": "osgp/platform/osgp-secret-management/src/integration-test/java/org/opensmartgridplatform/secretmanagement/application/SoapServiceSecretManagementIT.java", "diffHunk": "@@ -139,7 +159,61 @@ public void storeSecretsRequest() {\n     }\n \n     @Test\n-    public void getSecretsRequest_noSecretTypes() {\n+    public void storeSecretsRequestAlreadyNewSecretPresent() throws IOException {\n+\n+        /**\n+         * Note that the output depends, besides the value of the keys, also on both the db key and the soap key.\n+         */\n+        assertThat(this.secretRepository.count()).isEqualTo(2);\n+\n+        final Resource storeRequest = new ClassPathResource(\"test-requests/storeSecrets.xml\");\n+        final Resource expectedStoreResponse = new ClassPathResource(\"test-responses/storeSecrets.xml\");\n+        //Store secrets\n+        this.mockWebServiceClient.sendRequest(withPayload(storeRequest)).andExpect(ResponseMatchers.noFault())\n+                                 .andExpect(ResponseMatchers.payload(expectedStoreResponse));\n+        //Store secrets again, while previously stored secret still have status NEW\n+        final String errorMessage = \"Expected 0 new secrets of type E_METER_AUTHENTICATION_KEY for device E0000000000000000, but 1 new secret(s) present\";\n+        this.mockWebServiceClient.sendRequest(withPayload(storeRequest))\n+                                 .andExpect(ResponseMatchers.serverOrReceiverFault(errorMessage));\n+    }\n+\n+    @Test\n+    public void activateSecretsRequest() throws IOException {\n+\n+        /**\n+         * Note that the output depends, besides the value of the keys, also on both the db key and the soap key.\n+         */\n+        assertThat(this.secretRepository.count()).isEqualTo(2);\n+\n+        final Resource storeRequest = new ClassPathResource(\"test-requests/storeSecrets.xml\");\n+        final Resource activateRequest = new ClassPathResource(\"test-requests/activateSecrets.xml\");\n+        final Resource expectedStoreResponse = new ClassPathResource(\"test-responses/storeSecrets.xml\");\n+        final Resource expectedActivateResponse = new ClassPathResource(\"test-responses/activateSecrets.xml\");\n+        //Store secrets\n+        this.mockWebServiceClient.sendRequest(withPayload(storeRequest)).andExpect(ResponseMatchers.noFault())\n+                                 .andExpect(ResponseMatchers.payload(expectedStoreResponse));\n+        this.mockWebServiceClient.sendRequest(withPayload(activateRequest))\n+                                 .andExpect(ResponseMatchers.noFault())\n+                                 .andExpect(ResponseMatchers.payload(expectedActivateResponse));\n+    }\n+\n+    @Test\n+    public void activateSecretsRequestNoNewSecret() throws IOException {\n+\n+        /**\n+         * Note that the output depends, besides the value of the keys, also on both the db key and the soap key.\n+         */\n+        assertThat(this.secretRepository.count()).isEqualTo(2);\n+\n+        final Resource activateRequest = new ClassPathResource(\"test-requests/activateSecrets.xml\");\n+        //Store secrets\n+        this.mockWebServiceClient.sendRequest(withPayload(activateRequest))\n+                                 //.andExpect((request, response) -> response.writeTo(System.out));", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI2ODA0Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558268042", "bodyText": "Missing final modifier on local variable generateAndStoreRequest.", "author": "bvdzwet", "createdAt": "2021-01-15T12:14:04Z", "path": "osgp/platform/osgp-secret-management/src/integration-test/java/org/opensmartgridplatform/secretmanagement/application/SoapServiceSecretManagementIT.java", "diffHunk": "@@ -167,33 +241,35 @@ public void setSecretsRequest_noSecrets() {\n         final Resource request = new ClassPathResource(\"test-requests/invalidStoreSecrets.xml\");\n \n         try {\n-            this.mockWebServiceClient.sendRequest(withPayload(request)).andExpect(\n-                    ResponseMatchers.serverOrReceiverFault(\"Missing input: typed secrets\"));\n+            this.mockWebServiceClient.sendRequest(withPayload(request))\n+                                     .andExpect(ResponseMatchers.serverOrReceiverFault(\"Missing input: typed secrets\"));\n         } catch (final Exception exc) {\n             Assertions.fail(\"Error\", exc);\n         }\n     }\n \n     @Test\n-    public void setSecretsRequest_identicalSecrets() throws IOException {\n-\n-        /**\n-         * Note that the output depends, besides the value of the keys, also on both the db key and the soap key.\n-         */\n-        assertThat(this.secretRepository.count()).isEqualTo(2);\n+    public void generateAndStoreSecrets() throws IOException {\n+        Resource generateAndStoreRequest = new ClassPathResource(\"test-requests/generateAndStoreSecrets.xml\");", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI2ODQwMA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558268400", "bodyText": "Missing a space after the comma and before ->.", "author": "bvdzwet", "createdAt": "2021-01-15T12:15:00Z", "path": "osgp/platform/osgp-secret-management/src/integration-test/java/org/opensmartgridplatform/secretmanagement/application/SoapServiceSecretManagementIT.java", "diffHunk": "@@ -167,33 +241,35 @@ public void setSecretsRequest_noSecrets() {\n         final Resource request = new ClassPathResource(\"test-requests/invalidStoreSecrets.xml\");\n \n         try {\n-            this.mockWebServiceClient.sendRequest(withPayload(request)).andExpect(\n-                    ResponseMatchers.serverOrReceiverFault(\"Missing input: typed secrets\"));\n+            this.mockWebServiceClient.sendRequest(withPayload(request))\n+                                     .andExpect(ResponseMatchers.serverOrReceiverFault(\"Missing input: typed secrets\"));\n         } catch (final Exception exc) {\n             Assertions.fail(\"Error\", exc);\n         }\n     }\n \n     @Test\n-    public void setSecretsRequest_identicalSecrets() throws IOException {\n-\n-        /**\n-         * Note that the output depends, besides the value of the keys, also on both the db key and the soap key.\n-         */\n-        assertThat(this.secretRepository.count()).isEqualTo(2);\n+    public void generateAndStoreSecrets() throws IOException {\n+        Resource generateAndStoreRequest = new ClassPathResource(\"test-requests/generateAndStoreSecrets.xml\");\n+        this.mockWebServiceClient.sendRequest(withPayload(generateAndStoreRequest))\n+                .andExpect(ResponseMatchers.noFault())\n+                .andExpect((request,response)-> {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI2ODY0MA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558268640", "bodyText": "Missing a final modifier on local variable outputStream.", "author": "bvdzwet", "createdAt": "2021-01-15T12:15:35Z", "path": "osgp/platform/osgp-secret-management/src/integration-test/java/org/opensmartgridplatform/secretmanagement/application/SoapServiceSecretManagementIT.java", "diffHunk": "@@ -167,33 +241,35 @@ public void setSecretsRequest_noSecrets() {\n         final Resource request = new ClassPathResource(\"test-requests/invalidStoreSecrets.xml\");\n \n         try {\n-            this.mockWebServiceClient.sendRequest(withPayload(request)).andExpect(\n-                    ResponseMatchers.serverOrReceiverFault(\"Missing input: typed secrets\"));\n+            this.mockWebServiceClient.sendRequest(withPayload(request))\n+                                     .andExpect(ResponseMatchers.serverOrReceiverFault(\"Missing input: typed secrets\"));\n         } catch (final Exception exc) {\n             Assertions.fail(\"Error\", exc);\n         }\n     }\n \n     @Test\n-    public void setSecretsRequest_identicalSecrets() throws IOException {\n-\n-        /**\n-         * Note that the output depends, besides the value of the keys, also on both the db key and the soap key.\n-         */\n-        assertThat(this.secretRepository.count()).isEqualTo(2);\n+    public void generateAndStoreSecrets() throws IOException {\n+        Resource generateAndStoreRequest = new ClassPathResource(\"test-requests/generateAndStoreSecrets.xml\");\n+        this.mockWebServiceClient.sendRequest(withPayload(generateAndStoreRequest))\n+                .andExpect(ResponseMatchers.noFault())\n+                .andExpect((request,response)-> {\n+                    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI2OTE3MA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558269170", "bodyText": "Missing a final modifier on local variable generateAndStoreRequest.", "author": "bvdzwet", "createdAt": "2021-01-15T12:16:46Z", "path": "osgp/platform/osgp-secret-management/src/integration-test/java/org/opensmartgridplatform/secretmanagement/application/SoapServiceSecretManagementIT.java", "diffHunk": "@@ -167,33 +241,35 @@ public void setSecretsRequest_noSecrets() {\n         final Resource request = new ClassPathResource(\"test-requests/invalidStoreSecrets.xml\");\n \n         try {\n-            this.mockWebServiceClient.sendRequest(withPayload(request)).andExpect(\n-                    ResponseMatchers.serverOrReceiverFault(\"Missing input: typed secrets\"));\n+            this.mockWebServiceClient.sendRequest(withPayload(request))\n+                                     .andExpect(ResponseMatchers.serverOrReceiverFault(\"Missing input: typed secrets\"));\n         } catch (final Exception exc) {\n             Assertions.fail(\"Error\", exc);\n         }\n     }\n \n     @Test\n-    public void setSecretsRequest_identicalSecrets() throws IOException {\n-\n-        /**\n-         * Note that the output depends, besides the value of the keys, also on both the db key and the soap key.\n-         */\n-        assertThat(this.secretRepository.count()).isEqualTo(2);\n+    public void generateAndStoreSecrets() throws IOException {\n+        Resource generateAndStoreRequest = new ClassPathResource(\"test-requests/generateAndStoreSecrets.xml\");\n+        this.mockWebServiceClient.sendRequest(withPayload(generateAndStoreRequest))\n+                .andExpect(ResponseMatchers.noFault())\n+                .andExpect((request,response)-> {\n+                    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+                    response.writeTo(outputStream);\n+                    assertThat(outputStream.toString()).contains(\"Result>OK\");\n+                });\n+    }\n \n-        final Resource request = new ClassPathResource(\"test-requests/storeSecrets.xml\");\n-        final Resource expectedResponse = new ClassPathResource(\"test-responses/storeSecrets.xml\");\n+    @Test\n+    public void generateAndStoreSecretsAlreadyNewSecretPresent() throws IOException {\n         //Store secrets\n-        this.mockWebServiceClient.sendRequest(withPayload(request)).andExpect(ResponseMatchers.noFault()).andExpect(\n-                ResponseMatchers.payload(expectedResponse));\n-        //Store identical secrets again\n-        final String errorMessage = \"Secret is identical to current secret (\" + DEVICE_IDENTIFICATION + \", \"\n-                + \"E_METER_AUTHENTICATION_KEY)\";\n-        this.mockWebServiceClient.sendRequest(withPayload(request)).andExpect(\n-                ResponseMatchers.serverOrReceiverFault(errorMessage));\n+        final Resource storeRequest = new ClassPathResource(\"test-requests/storeSecrets.xml\");\n+        this.mockWebServiceClient.sendRequest(withPayload(storeRequest)).andExpect(ResponseMatchers.noFault());\n+        //Generate and store secret: this should result in a fault message\n+        Resource generateAndStoreRequest = new ClassPathResource(\"test-requests/generateAndStoreSecrets.xml\");", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI3NjAxNw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558276017", "bodyText": "According to the code formatting conventions annotations on methods are to be followed by a new line.", "author": "bvdzwet", "createdAt": "2021-01-15T12:30:53Z", "path": "osgp/platform/osgp-secret-management/src/integration-test/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepositoryIT.java", "diffHunk": "@@ -41,18 +43,32 @@ public void persistTestData() {\n         final DbEncryptedSecret instance = new DbEncryptedSecret();\n         instance.setDeviceIdentification(DEVICE_IDENTIFICATION);\n         instance.setSecretType(SecretType.E_METER_AUTHENTICATION_KEY);\n+        instance.setSecretStatus(SecretStatus.ACTIVE);\n         instance.setEncodedSecret(HexUtils.toHexString(\"$3cr3t\".getBytes()));\n         instance.setEncryptionKeyReference(encryptionKey);\n         instance.setCreationTime(new Date());\n         this.dbEncryptedSecret = this.entityManager.persist(instance);\n         this.entityManager.flush();\n     }\n \n-    @Test\n-    public void findIdOfValidMostRecent() {\n+    @Test void testSetup() {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI4NDM3OQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558284379", "bodyText": "Missing final modifier on local variable rsaEncryptionProvider (and several other variables in this source file).", "author": "bvdzwet", "createdAt": "2021-01-15T12:47:40Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java", "diffHunk": "@@ -44,51 +45,41 @@\n \n     @Bean(\"DefaultEncryptionDelegate\")\n     public DefaultEncryptionDelegate getEncryptionDelegate() {\n-        return new DefaultEncryptionDelegate(getDefaultEncryptionProviders());\n+        return new DefaultEncryptionDelegate(this.getDefaultEncryptionProviders());\n     }\n \n-    @Bean\n-    public List<EncryptionProvider> getDefaultEncryptionProviders() {\n-\n+    private List<EncryptionProvider> getDefaultEncryptionProviders() {\n         List<EncryptionProvider> encryptionProviderList = new ArrayList<>();\n \n         try {\n             JreEncryptionProvider jreEncryptionProvider = new JreEncryptionProvider(\n                     this.jreEncryptionKeyResource.getFile());\n-\n             encryptionProviderList.add(jreEncryptionProvider);\n \n-            RsaEncryptionProvider rsaEncryptionProvider = new RsaEncryptionProvider();\n-\n-            this.soapPrivateKeyResource.ifPresent(res-> {\n-                try {\n-                    rsaEncryptionProvider.setPrivateKeyStore(res.getFile());\n-                }\n-                catch (IOException e) {\n-                    throw new IllegalStateException(\"Could not load private key resource.\", e);\n-                }\n-            });\n-\n-            this.soapPublicKeyResource.ifPresent(res-> {\n-                try {\n-                    rsaEncryptionProvider.setPublicKeyStore(res.getFile());\n-                }\n-                catch (IOException e) {\n-                    throw new IllegalStateException(\"Could not load public key resource.\", e);\n-                }\n-            });\n-\n-            encryptionProviderList.add(rsaEncryptionProvider);\n-\n             if (this.hsmKeystoreResource.isPresent()) {\n                 HsmEncryptionProvider hsmEncryptionProvider = new HsmEncryptionProvider(\n                         this.hsmKeystoreResource.get().getFile());\n                 encryptionProviderList.add(hsmEncryptionProvider);\n             }\n \n             return encryptionProviderList;\n+        } catch (IOException | EncrypterException e) {\n+            throw new IllegalStateException(\"Error creating default encryption providers\", e);\n+        }\n+    }\n \n-        } catch (IOException e) {\n+    @Bean\n+    public RsaEncrypter getSoapEncrypter() {\n+        try {\n+            RsaEncrypter rsaEncryptionProvider = new RsaEncrypter();", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI4NDg1NQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558284855", "bodyText": "Missing space after if. Here and once more in the next few lines.", "author": "bvdzwet", "createdAt": "2021-01-15T12:48:31Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java", "diffHunk": "@@ -44,51 +45,41 @@\n \n     @Bean(\"DefaultEncryptionDelegate\")\n     public DefaultEncryptionDelegate getEncryptionDelegate() {\n-        return new DefaultEncryptionDelegate(getDefaultEncryptionProviders());\n+        return new DefaultEncryptionDelegate(this.getDefaultEncryptionProviders());\n     }\n \n-    @Bean\n-    public List<EncryptionProvider> getDefaultEncryptionProviders() {\n-\n+    private List<EncryptionProvider> getDefaultEncryptionProviders() {\n         List<EncryptionProvider> encryptionProviderList = new ArrayList<>();\n \n         try {\n             JreEncryptionProvider jreEncryptionProvider = new JreEncryptionProvider(\n                     this.jreEncryptionKeyResource.getFile());\n-\n             encryptionProviderList.add(jreEncryptionProvider);\n \n-            RsaEncryptionProvider rsaEncryptionProvider = new RsaEncryptionProvider();\n-\n-            this.soapPrivateKeyResource.ifPresent(res-> {\n-                try {\n-                    rsaEncryptionProvider.setPrivateKeyStore(res.getFile());\n-                }\n-                catch (IOException e) {\n-                    throw new IllegalStateException(\"Could not load private key resource.\", e);\n-                }\n-            });\n-\n-            this.soapPublicKeyResource.ifPresent(res-> {\n-                try {\n-                    rsaEncryptionProvider.setPublicKeyStore(res.getFile());\n-                }\n-                catch (IOException e) {\n-                    throw new IllegalStateException(\"Could not load public key resource.\", e);\n-                }\n-            });\n-\n-            encryptionProviderList.add(rsaEncryptionProvider);\n-\n             if (this.hsmKeystoreResource.isPresent()) {\n                 HsmEncryptionProvider hsmEncryptionProvider = new HsmEncryptionProvider(\n                         this.hsmKeystoreResource.get().getFile());\n                 encryptionProviderList.add(hsmEncryptionProvider);\n             }\n \n             return encryptionProviderList;\n+        } catch (IOException | EncrypterException e) {\n+            throw new IllegalStateException(\"Error creating default encryption providers\", e);\n+        }\n+    }\n \n-        } catch (IOException e) {\n+    @Bean\n+    public RsaEncrypter getSoapEncrypter() {\n+        try {\n+            RsaEncrypter rsaEncryptionProvider = new RsaEncrypter();\n+            if(this.soapPrivateKeyResource.isPresent()) {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI4NjI5OA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558286298", "bodyText": "Copyright on new files should refer to Alliander N.V. instead of Smart Society Services B.V.", "author": "bvdzwet", "createdAt": "2021-01-15T12:51:30Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/SecretStatus.java", "diffHunk": "@@ -0,0 +1,13 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI4OTQ1OQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558289459", "bodyText": "If you prefer it this way, you can leave it as is, but the block makes me think: why not:\nthis.secretType = Objects.requireNonNull(secretType, \"Secret type can not be NULL\");?", "author": "bvdzwet", "createdAt": "2021-01-15T12:57:41Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java", "diffHunk": "@@ -8,29 +8,30 @@\n  */\n package org.opensmartgridplatform.secretmanagement.application.domain;\n \n+import java.util.Arrays;\n+\n+import lombok.Getter;\n+\n /**\n  * TypedSecret stores a secret (not necessarily an encrypted secret), along with it's type.\n  */\n+@Getter\n public class TypedSecret {\n-    private SecretType secretType;\n-    private String secret;\n-\n-    public String getSecret() {\n-        return this.secret;\n-    }\n-\n-    public SecretType getSecretType() {\n-        return this.secretType;\n-    }\n-\n-    public void setSecret(final String secret) {\n-        this.secret = secret;\n+    private final SecretType secretType;\n+    private final byte[] secret;\n+\n+    public TypedSecret(final byte[] secret, final SecretType secretType) {\n+        this.secret = secret == null ? null : Arrays.copyOf(secret, secret.length);\n+        if (secretType != null) {\n+            this.secretType = secretType;\n+        } else {\n+            throw new IllegalArgumentException(\"Secret type can not be NULL\");\n+        }", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAwODI4Nw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r560008287", "bodyText": "I left it this way, because Object.requireNonNull throws a NPE instead of an IAE.", "author": "jandik", "createdAt": "2021-01-19T08:53:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI4OTQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMwNjY2Nw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558306667", "bodyText": "Missing final modifier on local variable typedSecretList.", "author": "bvdzwet", "createdAt": "2021-01-15T13:29:42Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java", "diffHunk": "@@ -37,86 +45,153 @@\n @Slf4j\n public class SecretManagementEndpoint {\n \n-    private static final String NAMESPACE_URI = \"http://www.opensmartgridplatform\"\n-            + \".org/schemas/security/secretmanagement\";\n+    private static final String NAMESPACE_URI =\n+            \"http://www.opensmartgridplatform.org/schemas/security/secretmanagement\";\n+    private static final String STR_MISSING_SECRET_TYPES = \"Missing input: secret types\";\n+    private static final String STR_MISSING_TYPED_SECRETS = \"Missing input: typed secrets\";\n \n     private final SecretManagementService secretManagementService;\n     private final SoapEndpointDataTypeConverter converter;\n \n-    public SecretManagementEndpoint(SecretManagementService secretManagementService,\n-                                    SoapEndpointDataTypeConverter converter) {\n+    public SecretManagementEndpoint(final SecretManagementService secretManagementService,\n+            final SoapEndpointDataTypeConverter converter) {\n         this.secretManagementService = secretManagementService;\n         this.converter = converter;\n     }\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n     @ResponsePayload\n-    public GetSecretsResponse getSecretsRequest(@RequestPayload GetSecretsRequest request) throws OsgpException {\n-\n+    public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request) throws OsgpException {\n         log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-\n         if (log.isDebugEnabled()) {\n-            log.debug(getSecretsRequestToString(request));\n+            log.debug(this.requestToString(request));\n         }\n-\n-        GetSecretsResponse response = new GetSecretsResponse();\n-\n-        SecretTypes soapSecretTypes = request.getSecretTypes();\n-\n+        final GetSecretsResponse response = new GetSecretsResponse();\n+        final SecretTypes soapSecretTypes = request.getSecretTypes();\n         if (soapSecretTypes == null) {\n-            throw new TechnicalException(\"Missing input: secret types\");\n+            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n         }\n-\n-        List<SecretType> secretTypeList = converter.convertToSecretTypes(soapSecretTypes);\n-        List<TypedSecret> typedSecrets = secretManagementService.retrieveSecrets(request.getDeviceId(),\n+        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveSecrets(request.getDeviceId(),\n                 secretTypeList);\n-\n-        TypedSecrets soapTypedSecrets = converter.convertToSoapTypedSecrets(typedSecrets);\n-\n+        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n         response.setTypedSecrets(soapTypedSecrets);\n         response.setResult(OsgpResultType.OK);\n+        return response;\n+    }\n \n-        log.trace(response.toString());\n-\n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getNewSecretsRequest\")\n+    @ResponsePayload\n+    public GetNewSecretsResponse getNewSecretsRequest(@RequestPayload final GetNewSecretsRequest request) throws OsgpException {\n+        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+        if (log.isDebugEnabled()) {\n+            log.debug(this.requestToString(request));\n+        }\n+        final GetNewSecretsResponse response = new GetNewSecretsResponse();\n+        final SecretTypes soapSecretTypes = request.getSecretTypes();\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n+        }\n+        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveNewSecrets(request.getDeviceId(),\n+                secretTypeList);\n+        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n+        response.setTypedSecrets(soapTypedSecrets);\n+        response.setResult(OsgpResultType.OK);\n         return response;\n     }\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n     @ResponsePayload\n-    public StoreSecretsResponse storeSecretsRequest(@RequestPayload StoreSecretsRequest request) throws OsgpException {\n-\n+    public StoreSecretsResponse storeSecretsRequest(@RequestPayload final StoreSecretsRequest request)\n+            throws OsgpException {\n         log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n-        log.trace(request.toString());\n-\n-        StoreSecretsResponse response = new StoreSecretsResponse();\n-\n-        TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n-\n+        if (log.isDebugEnabled()) {\n+            log.debug(this.requestToString(request));\n+        }\n+        final StoreSecretsResponse response = new StoreSecretsResponse();\n+        final TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n         if (soapTypedSecrets == null) {\n-            throw new TechnicalException(\"Missing input: typed secrets\");\n+            throw new TechnicalException(STR_MISSING_TYPED_SECRETS);\n         }\n-\n-        List<TypedSecret> typedSecretList = converter.convertToTypedSecrets(request.getTypedSecrets());\n-\n-        secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n-\n+        final List<TypedSecret> typedSecretList = this.converter.convertToTypedSecrets(soapTypedSecrets);\n+        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n         response.setResult(OsgpResultType.OK);\n+        return response;\n+    }\n \n-        log.trace(response.toString());\n-\n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"generateAndStoreSecretsRequest\")\n+    @ResponsePayload\n+    public GenerateAndStoreSecretsResponse generateAndStoreSecretsRequest(\n+            @RequestPayload final GenerateAndStoreSecretsRequest request) throws OsgpException {\n+        log.info(\"Handling incoming SOAP request 'generateAndStoreSecretsRequest' for device {}\",\n+                request.getDeviceId());\n+        if (log.isDebugEnabled()) {\n+            log.debug(this.requestToString(request));\n+        }\n+        final GenerateAndStoreSecretsResponse response = new GenerateAndStoreSecretsResponse();\n+        final SecretTypes soapSecretTypes = request.getSecretTypes();\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n+        }\n+        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+        List<TypedSecret> typedSecretList = this.secretManagementService.generateAndStoreSecrets(request.getDeviceId(),", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMwNzE3OA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558307178", "bodyText": "Missing final modifier on local variable logFormat.", "author": "bvdzwet", "createdAt": "2021-01-15T13:30:32Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java", "diffHunk": "@@ -37,86 +45,153 @@\n @Slf4j\n public class SecretManagementEndpoint {\n \n-    private static final String NAMESPACE_URI = \"http://www.opensmartgridplatform\"\n-            + \".org/schemas/security/secretmanagement\";\n+    private static final String NAMESPACE_URI =\n+            \"http://www.opensmartgridplatform.org/schemas/security/secretmanagement\";\n+    private static final String STR_MISSING_SECRET_TYPES = \"Missing input: secret types\";\n+    private static final String STR_MISSING_TYPED_SECRETS = \"Missing input: typed secrets\";\n \n     private final SecretManagementService secretManagementService;\n     private final SoapEndpointDataTypeConverter converter;\n \n-    public SecretManagementEndpoint(SecretManagementService secretManagementService,\n-                                    SoapEndpointDataTypeConverter converter) {\n+    public SecretManagementEndpoint(final SecretManagementService secretManagementService,\n+            final SoapEndpointDataTypeConverter converter) {\n         this.secretManagementService = secretManagementService;\n         this.converter = converter;\n     }\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n     @ResponsePayload\n-    public GetSecretsResponse getSecretsRequest(@RequestPayload GetSecretsRequest request) throws OsgpException {\n-\n+    public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request) throws OsgpException {\n         log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-\n         if (log.isDebugEnabled()) {\n-            log.debug(getSecretsRequestToString(request));\n+            log.debug(this.requestToString(request));\n         }\n-\n-        GetSecretsResponse response = new GetSecretsResponse();\n-\n-        SecretTypes soapSecretTypes = request.getSecretTypes();\n-\n+        final GetSecretsResponse response = new GetSecretsResponse();\n+        final SecretTypes soapSecretTypes = request.getSecretTypes();\n         if (soapSecretTypes == null) {\n-            throw new TechnicalException(\"Missing input: secret types\");\n+            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n         }\n-\n-        List<SecretType> secretTypeList = converter.convertToSecretTypes(soapSecretTypes);\n-        List<TypedSecret> typedSecrets = secretManagementService.retrieveSecrets(request.getDeviceId(),\n+        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveSecrets(request.getDeviceId(),\n                 secretTypeList);\n-\n-        TypedSecrets soapTypedSecrets = converter.convertToSoapTypedSecrets(typedSecrets);\n-\n+        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n         response.setTypedSecrets(soapTypedSecrets);\n         response.setResult(OsgpResultType.OK);\n+        return response;\n+    }\n \n-        log.trace(response.toString());\n-\n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getNewSecretsRequest\")\n+    @ResponsePayload\n+    public GetNewSecretsResponse getNewSecretsRequest(@RequestPayload final GetNewSecretsRequest request) throws OsgpException {\n+        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+        if (log.isDebugEnabled()) {\n+            log.debug(this.requestToString(request));\n+        }\n+        final GetNewSecretsResponse response = new GetNewSecretsResponse();\n+        final SecretTypes soapSecretTypes = request.getSecretTypes();\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n+        }\n+        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveNewSecrets(request.getDeviceId(),\n+                secretTypeList);\n+        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n+        response.setTypedSecrets(soapTypedSecrets);\n+        response.setResult(OsgpResultType.OK);\n         return response;\n     }\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n     @ResponsePayload\n-    public StoreSecretsResponse storeSecretsRequest(@RequestPayload StoreSecretsRequest request) throws OsgpException {\n-\n+    public StoreSecretsResponse storeSecretsRequest(@RequestPayload final StoreSecretsRequest request)\n+            throws OsgpException {\n         log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n-        log.trace(request.toString());\n-\n-        StoreSecretsResponse response = new StoreSecretsResponse();\n-\n-        TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n-\n+        if (log.isDebugEnabled()) {\n+            log.debug(this.requestToString(request));\n+        }\n+        final StoreSecretsResponse response = new StoreSecretsResponse();\n+        final TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n         if (soapTypedSecrets == null) {\n-            throw new TechnicalException(\"Missing input: typed secrets\");\n+            throw new TechnicalException(STR_MISSING_TYPED_SECRETS);\n         }\n-\n-        List<TypedSecret> typedSecretList = converter.convertToTypedSecrets(request.getTypedSecrets());\n-\n-        secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n-\n+        final List<TypedSecret> typedSecretList = this.converter.convertToTypedSecrets(soapTypedSecrets);\n+        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n         response.setResult(OsgpResultType.OK);\n+        return response;\n+    }\n \n-        log.trace(response.toString());\n-\n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"generateAndStoreSecretsRequest\")\n+    @ResponsePayload\n+    public GenerateAndStoreSecretsResponse generateAndStoreSecretsRequest(\n+            @RequestPayload final GenerateAndStoreSecretsRequest request) throws OsgpException {\n+        log.info(\"Handling incoming SOAP request 'generateAndStoreSecretsRequest' for device {}\",\n+                request.getDeviceId());\n+        if (log.isDebugEnabled()) {\n+            log.debug(this.requestToString(request));\n+        }\n+        final GenerateAndStoreSecretsResponse response = new GenerateAndStoreSecretsResponse();\n+        final SecretTypes soapSecretTypes = request.getSecretTypes();\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n+        }\n+        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+        List<TypedSecret> typedSecretList = this.secretManagementService.generateAndStoreSecrets(request.getDeviceId(),\n+                secretTypeList);\n+        response.setResult(OsgpResultType.OK);\n+        response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n         return response;\n     }\n \n-    private String getSecretsRequestToString(GetSecretsRequest request) {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    private <T> String requestToString(final T request) {\n+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         try {\n-            JAXBContext ctx = JAXBContext.newInstance(GetSecretsRequest.class);\n-            Marshaller marshaller = ctx.createMarshaller();\n+            final JAXBContext ctx = JAXBContext.newInstance(request.getClass());\n+            final Marshaller marshaller = ctx.createMarshaller();\n             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n             marshaller.marshal(request, baos);\n-        } catch (JAXBException e) {\n-            log.error(\"Could not serialize GetSecretsRequest\", e);\n+        } catch (final JAXBException e) {\n+            String logFormat = \"Could not serialize request of type %s\";", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMwOTU0MQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558309541", "bodyText": "Missing final modifier on parameters.", "author": "bvdzwet", "createdAt": "2021-01-15T13:35:10Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java", "diffHunk": "@@ -10,22 +10,33 @@\n \n import javax.xml.namespace.QName;\n \n+import lombok.extern.slf4j.Slf4j;\n import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n import org.springframework.ws.soap.SoapFault;\n import org.springframework.ws.soap.SoapFaultDetail;\n import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n \n+@Slf4j\n public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExceptionResolver {\n \n     private static final QName MESSAGE = new QName(\"Message\");\n     private static final QName COMPONENT = new QName(\"Component\");\n \n     @Override\n     protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMwOTc1Mw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558309753", "bodyText": "Missing space after if.", "author": "bvdzwet", "createdAt": "2021-01-15T13:35:29Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java", "diffHunk": "@@ -10,22 +10,33 @@\n \n import javax.xml.namespace.QName;\n \n+import lombok.extern.slf4j.Slf4j;\n import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n import org.springframework.ws.soap.SoapFault;\n import org.springframework.ws.soap.SoapFaultDetail;\n import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n \n+@Slf4j\n public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExceptionResolver {\n \n     private static final QName MESSAGE = new QName(\"Message\");\n     private static final QName COMPONENT = new QName(\"Component\");\n \n     @Override\n     protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n+        log.error(\"Exception occured during SOAP request processing\", ex);\n         SoapFaultDetail detail = fault.addFaultDetail();\n+        if(ex instanceof ExceptionWrapper) {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMxMDEzNg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558310136", "bodyText": "Missing final modifier on local variable detail.", "author": "bvdzwet", "createdAt": "2021-01-15T13:36:08Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java", "diffHunk": "@@ -10,22 +10,33 @@\n \n import javax.xml.namespace.QName;\n \n+import lombok.extern.slf4j.Slf4j;\n import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n import org.springframework.ws.soap.SoapFault;\n import org.springframework.ws.soap.SoapFaultDetail;\n import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n \n+@Slf4j\n public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExceptionResolver {\n \n     private static final QName MESSAGE = new QName(\"Message\");\n     private static final QName COMPONENT = new QName(\"Component\");\n \n     @Override\n     protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n+        log.error(\"Exception occured during SOAP request processing\", ex);\n         SoapFaultDetail detail = fault.addFaultDetail();", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMxMTMwMg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558311302", "bodyText": "Copyright on new files should mention Alliander N.V. instead of Smart Society Services B.V.", "author": "bvdzwet", "createdAt": "2021-01-15T13:38:12Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/ExceptionWrapper.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMxMTcyMQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558311721", "bodyText": "Missing final modifier on parameter.", "author": "bvdzwet", "createdAt": "2021-01-15T13:38:57Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/ExceptionWrapper.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.exception;\n+\n+/**\n+ * Unchecked exception that wraps another (checked) exception.\n+ * Can be used to handle checked exception in streams.\n+ */\n+public class ExceptionWrapper extends RuntimeException {\n+    private static final long serialVersionUID = -1239332310446200862L;\n+\n+    public ExceptionWrapper(Exception exc) {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMxNTMzNg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558315336", "bodyText": "Missing final modifier on parameter rsaEncrypter (and on parameters or local variables in several other parts of this source file).", "author": "bvdzwet", "createdAt": "2021-01-15T13:45:16Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java", "diffHunk": "@@ -18,146 +23,319 @@\n import org.apache.tomcat.util.buf.HexUtils;\n import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretStatus;\n import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.exception.ExceptionWrapper;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.exceptionhandling.ComponentType;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalExceptionType;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n import org.springframework.beans.factory.annotation.Qualifier;\n-import org.springframework.data.domain.Page;\n-import org.springframework.data.domain.Pageable;\n import org.springframework.stereotype.Service;\n \n+/**\n+ * Service that manages secrets (store, retrieve, activate, generate).\n+ * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n+ * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n+ * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n+ * database corruption as a result of partially succeeded batch results.\n+ *\n+ * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n+ * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n+ * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n+ * by reencrypting the AES-encrypted secrets to RSA.\n+ */\n @Service\n public class SecretManagementService {\n+    //Internal datastructure to keep track of (intermediate) secret details\n+    private static class EncryptedTypedSecret {\n+        byte[] encryptedSecret;\n+        SecretType type;\n+        String encryptionKeyReference;  //NULL when RSA\n+        EncryptionProviderType encryptionProviderType;  //NULL when RSA\n+\n+        private EncryptedTypedSecret(SecretType type) {\n+            this.type = type;\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type) {\n+            this(secret, type, null, null);\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type, String encryptionKeyReference,\n+                EncryptionProviderType encryptionProviderType) {\n+            if (secret == null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+            } else if (type == null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+            }\n+            this.encryptedSecret = secret;\n+            this.type = type;\n+            this.encryptionKeyReference = encryptionKeyReference;\n+            this.encryptionProviderType = encryptionProviderType;\n+        }\n+\n+        private boolean hasNullSecret() {\n+            return this.encryptedSecret == null;\n+        }\n+\n+        private TypedSecret toTypedSecret() {\n+            return new TypedSecret(this.encryptedSecret, this.type);\n+        }\n+\n+        private static EncryptedTypedSecret getNullInstance(SecretType type) {\n+            return new EncryptedTypedSecret(type);\n+        }\n+\n+        private static EncryptedTypedSecret fromDbEncryptedSecret(DbEncryptedSecret dbEncryptedSecret)\n+                throws FunctionalException {\n+            byte[] aesEncrypted;\n+            try {\n+                aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            } catch (IllegalArgumentException iae) {\n+                throw new FunctionalException(FunctionalExceptionType.INVALID_KEY_FORMAT,\n+                        ComponentType.SECRET_MANAGEMENT, iae);\n+            }\n+            String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+            EncryptionProviderType providerType = dbEncryptedSecret.getEncryptionKeyReference()\n+                                                                   .getEncryptionProviderType();\n+            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference,\n+                    providerType);\n+        }\n+    }\n+\n     private final EncryptionDelegate encryptionDelegate;\n     private final EncryptionProviderType encryptionProviderType;\n     private final DbEncryptedSecretRepository secretRepository;\n     private final DbEncryptionKeyRepository keyRepository;\n+    private final RsaEncrypter rsaEncrypter;\n \n     public SecretManagementService(\n             @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n             final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository) {\n+            final DbEncryptionKeyRepository keyRepository, RsaEncrypter rsaEncrypter) {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMzMTc1Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558331752", "bodyText": "Copyright on new files should be for Alliander N.V. instead of Smart Society Services B.V.", "author": "bvdzwet", "createdAt": "2021-01-15T14:12:27Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/EncryptionHelperService.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM0NDg1Mw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558344853", "bodyText": "Putting the comma on a new line is not according to the formatting conventions.", "author": "bvdzwet", "createdAt": "2021-01-15T14:33:04Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/FirmwareService.java", "diffHunk": "@@ -73,12 +73,13 @@ public boolean isFirmwareFileAvailable(final String firmwareIdentification) {\n         return this.firmwareRepository.isAvailable(firmwareIdentification);\n     }\n \n-    private UpdateFirmwareResponseDto executeFirmwareUpdate(final DlmsConnectionManager conn, final DlmsDevice device,\n-            final String firmwareIdentification) throws OsgpException {\n+    private UpdateFirmwareResponseDto executeFirmwareUpdate(final DlmsConnectionManager conn, final DlmsDevice device\n+            , final String firmwareIdentification) throws OsgpException {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM0Njk1Mw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558346953", "bodyText": "Missing final modifier on a number of local variables.", "author": "bvdzwet", "createdAt": "2021-01-15T14:36:24Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java", "diffHunk": "@@ -52,59 +66,65 @@\n     @Autowired\n     private CoupleMbusDeviceByChannelCommandExecutor coupleMbusDeviceByChannelCommandExecutor;\n \n-    // === ADD METER ===\n     public void addMeter(final SmartMeteringDeviceDto smartMeteringDevice) throws FunctionalException {\n-        this.reEncryptKeys(smartMeteringDevice);\n+        if (smartMeteringDevice.getDeviceIdentification() == null) {\n+            throw new FunctionalException(FunctionalExceptionType.VALIDATION_ERROR, ComponentType.PROTOCOL_DLMS,\n+                    new IllegalArgumentException(\"Provided device does not contain device identification\"));\n+        }\n+        this.storeAndActivateKeys(smartMeteringDevice);\n         final DlmsDevice dlmsDevice = this.installationMapper.map(smartMeteringDevice, DlmsDevice.class);\n         this.dlmsDeviceRepository.save(dlmsDevice);\n     }\n \n-    private void reEncryptKeys(final SmartMeteringDeviceDto smartMeteringDevice) throws FunctionalException {\n-        this.reEncryptMasterKey(smartMeteringDevice);\n-        this.reEncryptAuthenticationKey(smartMeteringDevice);\n-        this.reEncryptEncryptionKey(smartMeteringDevice);\n-        this.reEncryptMbusDefaultKey(smartMeteringDevice);\n-    }\n-\n-    private void reEncryptMasterKey(final SmartMeteringDeviceDto smartMeteringDevice) throws FunctionalException {\n-        if (ArrayUtils.isEmpty(smartMeteringDevice.getMasterKey())) {\n-            return;\n+    private void storeAndActivateKeys(final SmartMeteringDeviceDto deviceDto) throws FunctionalException {\n+        Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM0Nzc1NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558347754", "bodyText": "Missing final modifier on parameters.", "author": "bvdzwet", "createdAt": "2021-01-15T14:37:34Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java", "diffHunk": "@@ -52,59 +66,65 @@\n     @Autowired\n     private CoupleMbusDeviceByChannelCommandExecutor coupleMbusDeviceByChannelCommandExecutor;\n \n-    // === ADD METER ===\n     public void addMeter(final SmartMeteringDeviceDto smartMeteringDevice) throws FunctionalException {\n-        this.reEncryptKeys(smartMeteringDevice);\n+        if (smartMeteringDevice.getDeviceIdentification() == null) {\n+            throw new FunctionalException(FunctionalExceptionType.VALIDATION_ERROR, ComponentType.PROTOCOL_DLMS,\n+                    new IllegalArgumentException(\"Provided device does not contain device identification\"));\n+        }\n+        this.storeAndActivateKeys(smartMeteringDevice);\n         final DlmsDevice dlmsDevice = this.installationMapper.map(smartMeteringDevice, DlmsDevice.class);\n         this.dlmsDeviceRepository.save(dlmsDevice);\n     }\n \n-    private void reEncryptKeys(final SmartMeteringDeviceDto smartMeteringDevice) throws FunctionalException {\n-        this.reEncryptMasterKey(smartMeteringDevice);\n-        this.reEncryptAuthenticationKey(smartMeteringDevice);\n-        this.reEncryptEncryptionKey(smartMeteringDevice);\n-        this.reEncryptMbusDefaultKey(smartMeteringDevice);\n-    }\n-\n-    private void reEncryptMasterKey(final SmartMeteringDeviceDto smartMeteringDevice) throws FunctionalException {\n-        if (ArrayUtils.isEmpty(smartMeteringDevice.getMasterKey())) {\n-            return;\n+    private void storeAndActivateKeys(final SmartMeteringDeviceDto deviceDto) throws FunctionalException {\n+        Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n+        List<SecurityKeyType> keyTypesToStore = this.determineKeyTypesToStore(deviceDto);\n+        for (SecurityKeyType keyType : keyTypesToStore) {\n+            byte[] key = this.getKeyFromDeviceDto(deviceDto, keyType);\n+            if (key != null && ArrayUtils.isNotEmpty(key)) {\n+                keysByType.put(keyType, this.encryptionService.rsaDecrypt(key));\n+            } else {\n+                Exception rootCause = new NoSuchElementException(keyType.name());\n+                throw new FunctionalException(FunctionalExceptionType.KEY_NOT_PRESENT, ComponentType.PROTOCOL_DLMS,\n+                        rootCause);\n+            }\n         }\n-        final byte[] reEncryptedMasterKey = this.securityKeyService\n-                .reEncryptKey(smartMeteringDevice.getMasterKey(), SecurityKeyType.E_METER_MASTER);\n-        smartMeteringDevice.setMasterKey(reEncryptedMasterKey);\n+        this.secretManagementService.storeNewKeys(deviceDto.getDeviceIdentification(), keysByType);\n+        this.secretManagementService.activateNewKeys(deviceDto.getDeviceIdentification(), keyTypesToStore);\n     }\n \n-    private void reEncryptAuthenticationKey(final SmartMeteringDeviceDto smartMeteringDevice)\n+    private List<SecurityKeyType> determineKeyTypesToStore(SmartMeteringDeviceDto deviceDto)\n             throws FunctionalException {\n-\n-        if (ArrayUtils.isEmpty(smartMeteringDevice.getAuthenticationKey())) {\n-            return;\n+        if (this.getKeyFromDeviceDto(deviceDto, G_METER_MASTER) != null) {\n+            //device is a G-Meter\n+            if (this.getKeyFromDeviceDto(deviceDto, E_METER_MASTER) != null\n+                    || this.getKeyFromDeviceDto(deviceDto, E_METER_AUTHENTICATION) != null\n+                    || this.getKeyFromDeviceDto(deviceDto, E_METER_ENCRYPTION) != null) {\n+                String msg = \"Provided device is considered a G-Meter (G_METER_MASTER is set)\"\n+                        + \", but contains E-Meter keys as well\";\n+                throw new FunctionalException(FunctionalExceptionType.VALIDATION_ERROR, ComponentType.PROTOCOL_DLMS,\n+                        new IllegalArgumentException(msg));\n+            }\n+            return Arrays.asList(G_METER_MASTER);\n+        } else {\n+            //device is an E-meter\n+            return Arrays.asList(E_METER_MASTER, E_METER_AUTHENTICATION, E_METER_ENCRYPTION);\n         }\n-        final byte[] reEncryptedAuthenticationKey = this.securityKeyService\n-                .reEncryptKey(smartMeteringDevice.getAuthenticationKey(), SecurityKeyType.E_METER_AUTHENTICATION);\n-        smartMeteringDevice.setAuthenticationKey(reEncryptedAuthenticationKey);\n     }\n \n-    private void reEncryptEncryptionKey(final SmartMeteringDeviceDto smartMeteringDevice) throws FunctionalException {\n-\n-        if (ArrayUtils.isEmpty(smartMeteringDevice.getGlobalEncryptionUnicastKey())) {\n-            return;\n+    private byte[] getKeyFromDeviceDto(SmartMeteringDeviceDto deviceDto, SecurityKeyType keyType) {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM0OTgxNw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558349817", "bodyText": "No need to check against null, as this is handled by ArrayUtils.isNotEmpty as well.", "author": "bvdzwet", "createdAt": "2021-01-15T14:40:32Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java", "diffHunk": "@@ -52,59 +66,65 @@\n     @Autowired\n     private CoupleMbusDeviceByChannelCommandExecutor coupleMbusDeviceByChannelCommandExecutor;\n \n-    // === ADD METER ===\n     public void addMeter(final SmartMeteringDeviceDto smartMeteringDevice) throws FunctionalException {\n-        this.reEncryptKeys(smartMeteringDevice);\n+        if (smartMeteringDevice.getDeviceIdentification() == null) {\n+            throw new FunctionalException(FunctionalExceptionType.VALIDATION_ERROR, ComponentType.PROTOCOL_DLMS,\n+                    new IllegalArgumentException(\"Provided device does not contain device identification\"));\n+        }\n+        this.storeAndActivateKeys(smartMeteringDevice);\n         final DlmsDevice dlmsDevice = this.installationMapper.map(smartMeteringDevice, DlmsDevice.class);\n         this.dlmsDeviceRepository.save(dlmsDevice);\n     }\n \n-    private void reEncryptKeys(final SmartMeteringDeviceDto smartMeteringDevice) throws FunctionalException {\n-        this.reEncryptMasterKey(smartMeteringDevice);\n-        this.reEncryptAuthenticationKey(smartMeteringDevice);\n-        this.reEncryptEncryptionKey(smartMeteringDevice);\n-        this.reEncryptMbusDefaultKey(smartMeteringDevice);\n-    }\n-\n-    private void reEncryptMasterKey(final SmartMeteringDeviceDto smartMeteringDevice) throws FunctionalException {\n-        if (ArrayUtils.isEmpty(smartMeteringDevice.getMasterKey())) {\n-            return;\n+    private void storeAndActivateKeys(final SmartMeteringDeviceDto deviceDto) throws FunctionalException {\n+        Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n+        List<SecurityKeyType> keyTypesToStore = this.determineKeyTypesToStore(deviceDto);\n+        for (SecurityKeyType keyType : keyTypesToStore) {\n+            byte[] key = this.getKeyFromDeviceDto(deviceDto, keyType);\n+            if (key != null && ArrayUtils.isNotEmpty(key)) {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM1MTg4MQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558351881", "bodyText": "Missing final modifier on constructor arguments.", "author": "bvdzwet", "createdAt": "2021-01-15T14:43:47Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java", "diffHunk": "@@ -1,181 +1,360 @@\n /**\n  * Copyright 2016 Smart Society Services B.V.\n  *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License.  You may obtain a copy of the License at\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n  *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n+ * http://www.apache.org/licenses/LICENSE-2.0\n  */\n package org.opensmartgridplatform.adapter.protocol.dlms.application.services;\n \n+import static java.util.stream.Collectors.toList;\n+\n+import java.util.Arrays;\n+import java.util.EnumMap;\n import java.util.List;\n-import java.util.Optional;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n \n-import lombok.extern.slf4j.Slf4j;\n import org.apache.commons.codec.binary.Hex;\n-import org.apache.commons.lang3.NotImplementedException;\n import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.SecretManagementClient;\n-import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n-import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n-import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n-import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n-import org.opensmartgridplatform.shared.security.EncryptedSecret;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n-import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.ActivateSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GenerateAndStoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GenerateAndStoreSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetNewSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetNewSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.HasNewSecretRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.HasNewSecretResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.OsgpResultType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Service;\n \n @Service\n-@Slf4j\n-public class SecretManagementService implements SecurityKeyService {\n+/**\n+ * Service for storing, activating and retrieving device keys.\n+ * Also performs RSA encryption/decryption operations for SOAP messaging purposes.\n+ */\n+public class SecretManagementService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncryptionProvider rsaEncryptionProvider;\n+    private final RsaEncrypter soapRsaEncrypter;\n     private final SecretManagementClient secretManagementClient;\n \n-    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider,\n-            SecretManagementClient secretManagementClient) {\n-        this.rsaEncryptionProvider = rsaEncryptionProvider;\n+\n+    public SecretManagementService(RsaEncrypter soapRsaEncrypter, SecretManagementClient secretManagementClient) {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM1NDU2OQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558354569", "bodyText": "Missing final modifier on method parameters, here and in other methods in this class. Also missing final modifiers in several places on local variables.", "author": "bvdzwet", "createdAt": "2021-01-15T14:47:46Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java", "diffHunk": "@@ -1,181 +1,360 @@\n /**\n  * Copyright 2016 Smart Society Services B.V.\n  *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License.  You may obtain a copy of the License at\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n  *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n+ * http://www.apache.org/licenses/LICENSE-2.0\n  */\n package org.opensmartgridplatform.adapter.protocol.dlms.application.services;\n \n+import static java.util.stream.Collectors.toList;\n+\n+import java.util.Arrays;\n+import java.util.EnumMap;\n import java.util.List;\n-import java.util.Optional;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n \n-import lombok.extern.slf4j.Slf4j;\n import org.apache.commons.codec.binary.Hex;\n-import org.apache.commons.lang3.NotImplementedException;\n import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.SecretManagementClient;\n-import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n-import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n-import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n-import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n-import org.opensmartgridplatform.shared.security.EncryptedSecret;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n-import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.ActivateSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GenerateAndStoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GenerateAndStoreSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetNewSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetNewSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.HasNewSecretRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.HasNewSecretResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.OsgpResultType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Service;\n \n @Service\n-@Slf4j\n-public class SecretManagementService implements SecurityKeyService {\n+/**\n+ * Service for storing, activating and retrieving device keys.\n+ * Also performs RSA encryption/decryption operations for SOAP messaging purposes.\n+ */\n+public class SecretManagementService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncryptionProvider rsaEncryptionProvider;\n+    private final RsaEncrypter soapRsaEncrypter;\n     private final SecretManagementClient secretManagementClient;\n \n-    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider,\n-            SecretManagementClient secretManagementClient) {\n-        this.rsaEncryptionProvider = rsaEncryptionProvider;\n+\n+    public SecretManagementService(RsaEncrypter soapRsaEncrypter, SecretManagementClient secretManagementClient) {\n+        this.soapRsaEncrypter = soapRsaEncrypter;\n         this.secretManagementClient = secretManagementClient;\n     }\n \n-    @Override\n-    public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n-        throw new NotImplementedException();\n+    /**\n+     * Retrieve an active key of a certain type for a specified device\n+     *\n+     * @param deviceIdentification\n+     *         the device identification string of the device\n+     * @param keyType\n+     *         the requested key type\n+     *\n+     * @return the key or NULL if not present\n+     */\n+    public byte[] getKey(String deviceIdentification, SecurityKeyType keyType) {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM3NTE3MQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558375171", "bodyText": "Missing final modifier on parameter.", "author": "bvdzwet", "createdAt": "2021-01-15T15:18:40Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/GenerateAndReplaceKeyCommandExecutor.java", "diffHunk": "@@ -54,16 +60,17 @@ public ActionResponseDto executeBundleAction(final DlmsConnectionManager conn, f\n     public ActionResponseDto execute(final DlmsConnectionManager conn, final DlmsDevice device,\n             final ActionRequestDto actionRequestDto) throws OsgpException {\n         LOGGER.info(\"Generate new keys for device {}\", device.getDeviceIdentification());\n-        final SetKeysRequestDto setKeysRequest = this.generateSetKeysRequest();\n+        final SetKeysRequestDto setKeysRequest = this.generateSetKeysRequest(device.getDeviceIdentification());\n         return this.replaceKeyCommandExecutor.executeBundleAction(conn, device, setKeysRequest);\n     }\n \n-    private SetKeysRequestDto generateSetKeysRequest() throws FunctionalException {\n+    private SetKeysRequestDto generateSetKeysRequest(String deviceIdentification) throws FunctionalException {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM4NjM5OA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558386398", "bodyText": "Missing final modifier on parameters.", "author": "bvdzwet", "createdAt": "2021-01-15T15:35:43Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetEncryptionKeyExchangeOnGMeterCommandExecutor.java", "diffHunk": "@@ -133,29 +114,90 @@ public MethodResultCode execute(final DlmsConnectionManager conn, final DlmsDevi\n         }\n     }\n \n-    private void checkMethodResultCode(final MethodResult methodResultCode, final String methodParameterName)\n-            throws ProtocolAdapterException {\n+    private MethodResult setEncryptionKey(DlmsConnectionManager conn, int channel, byte[] encryptionKey)", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM4NjcyOA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558386728", "bodyText": "Missing final modifier on parameters.", "author": "bvdzwet", "createdAt": "2021-01-15T15:36:11Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetEncryptionKeyExchangeOnGMeterCommandExecutor.java", "diffHunk": "@@ -133,29 +114,90 @@ public MethodResultCode execute(final DlmsConnectionManager conn, final DlmsDevi\n         }\n     }\n \n-    private void checkMethodResultCode(final MethodResult methodResultCode, final String methodParameterName)\n-            throws ProtocolAdapterException {\n+    private MethodResult setEncryptionKey(DlmsConnectionManager conn, int channel, byte[] encryptionKey)\n+            throws IOException {\n+        final MethodParameter methodSetEncryptionKey = this\n+                .getSetEncryptionKeyMethodParameter(OBIS_HASHMAP.get(channel), encryptionKey);\n+        conn.getDlmsMessageListener().setDescription(\"SetEncryptionKeyExchangeOnGMeter for channel \" + channel\n+                + \", call M-Bus Setup set_encryption_key method: \" + JdlmsObjectToStringUtil\n+                .describeMethod(methodSetEncryptionKey));\n+        return conn.getConnection().action(methodSetEncryptionKey);\n+    }\n+\n+    private MethodResult transferKey(DlmsConnectionManager conn, String mbusDeviceIdentification, int channel,\n+            byte[] encryptionKey) throws ProtocolAdapterException, IOException {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM4Njk5Nw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558386997", "bodyText": "Missing final modifier on parameters.", "author": "bvdzwet", "createdAt": "2021-01-15T15:36:34Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetEncryptionKeyExchangeOnGMeterCommandExecutor.java", "diffHunk": "@@ -133,29 +114,90 @@ public MethodResultCode execute(final DlmsConnectionManager conn, final DlmsDevi\n         }\n     }\n \n-    private void checkMethodResultCode(final MethodResult methodResultCode, final String methodParameterName)\n-            throws ProtocolAdapterException {\n+    private MethodResult setEncryptionKey(DlmsConnectionManager conn, int channel, byte[] encryptionKey)\n+            throws IOException {\n+        final MethodParameter methodSetEncryptionKey = this\n+                .getSetEncryptionKeyMethodParameter(OBIS_HASHMAP.get(channel), encryptionKey);\n+        conn.getDlmsMessageListener().setDescription(\"SetEncryptionKeyExchangeOnGMeter for channel \" + channel\n+                + \", call M-Bus Setup set_encryption_key method: \" + JdlmsObjectToStringUtil\n+                .describeMethod(methodSetEncryptionKey));\n+        return conn.getConnection().action(methodSetEncryptionKey);\n+    }\n+\n+    private MethodResult transferKey(DlmsConnectionManager conn, String mbusDeviceIdentification, int channel,\n+            byte[] encryptionKey) throws ProtocolAdapterException, IOException {\n+        final MethodParameter methodTransferKey = this\n+                .getTransferKeyMethodParameter(mbusDeviceIdentification, channel, encryptionKey);\n+        conn.getDlmsMessageListener().setDescription(\n+                \"SetEncryptionKeyExchangeOnGMeter for channel \" + channel + \", call M-Bus Setup transfer_key method: \"\n+                        + JdlmsObjectToStringUtil.describeMethod(methodTransferKey));\n+\n+        return conn.getConnection().action(methodTransferKey);\n+    }\n+\n+    private MethodParameter getTransferKeyMethodParameter(String mbusDeviceIdentification, int channel,\n+            byte[] gMeterUserKey) throws ProtocolAdapterException {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM4NzQ0OQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558387449", "bodyText": "Missing final modifier on local variable mbusDevice.", "author": "bvdzwet", "createdAt": "2021-01-15T15:37:15Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetEncryptionKeyExchangeOnGMeterCommandExecutor.java", "diffHunk": "@@ -133,29 +114,90 @@ public MethodResultCode execute(final DlmsConnectionManager conn, final DlmsDevi\n         }\n     }\n \n-    private void checkMethodResultCode(final MethodResult methodResultCode, final String methodParameterName)\n-            throws ProtocolAdapterException {\n+    private MethodResult setEncryptionKey(DlmsConnectionManager conn, int channel, byte[] encryptionKey)\n+            throws IOException {\n+        final MethodParameter methodSetEncryptionKey = this\n+                .getSetEncryptionKeyMethodParameter(OBIS_HASHMAP.get(channel), encryptionKey);\n+        conn.getDlmsMessageListener().setDescription(\"SetEncryptionKeyExchangeOnGMeter for channel \" + channel\n+                + \", call M-Bus Setup set_encryption_key method: \" + JdlmsObjectToStringUtil\n+                .describeMethod(methodSetEncryptionKey));\n+        return conn.getConnection().action(methodSetEncryptionKey);\n+    }\n+\n+    private MethodResult transferKey(DlmsConnectionManager conn, String mbusDeviceIdentification, int channel,\n+            byte[] encryptionKey) throws ProtocolAdapterException, IOException {\n+        final MethodParameter methodTransferKey = this\n+                .getTransferKeyMethodParameter(mbusDeviceIdentification, channel, encryptionKey);\n+        conn.getDlmsMessageListener().setDescription(\n+                \"SetEncryptionKeyExchangeOnGMeter for channel \" + channel + \", call M-Bus Setup transfer_key method: \"\n+                        + JdlmsObjectToStringUtil.describeMethod(methodTransferKey));\n+\n+        return conn.getConnection().action(methodTransferKey);\n+    }\n+\n+    private MethodParameter getTransferKeyMethodParameter(String mbusDeviceIdentification, int channel,\n+            byte[] gMeterUserKey) throws ProtocolAdapterException {\n+        DlmsDevice mbusDevice = this.dlmsDeviceRepository.findByDeviceIdentification(mbusDeviceIdentification);", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM4Nzg1OQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558387859", "bodyText": "Missing final modifier on obisCode.", "author": "bvdzwet", "createdAt": "2021-01-15T15:37:51Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetEncryptionKeyExchangeOnGMeterCommandExecutor.java", "diffHunk": "@@ -133,29 +114,90 @@ public MethodResultCode execute(final DlmsConnectionManager conn, final DlmsDevi\n         }\n     }\n \n-    private void checkMethodResultCode(final MethodResult methodResultCode, final String methodParameterName)\n-            throws ProtocolAdapterException {\n+    private MethodResult setEncryptionKey(DlmsConnectionManager conn, int channel, byte[] encryptionKey)\n+            throws IOException {\n+        final MethodParameter methodSetEncryptionKey = this\n+                .getSetEncryptionKeyMethodParameter(OBIS_HASHMAP.get(channel), encryptionKey);\n+        conn.getDlmsMessageListener().setDescription(\"SetEncryptionKeyExchangeOnGMeter for channel \" + channel\n+                + \", call M-Bus Setup set_encryption_key method: \" + JdlmsObjectToStringUtil\n+                .describeMethod(methodSetEncryptionKey));\n+        return conn.getConnection().action(methodSetEncryptionKey);\n+    }\n+\n+    private MethodResult transferKey(DlmsConnectionManager conn, String mbusDeviceIdentification, int channel,\n+            byte[] encryptionKey) throws ProtocolAdapterException, IOException {\n+        final MethodParameter methodTransferKey = this\n+                .getTransferKeyMethodParameter(mbusDeviceIdentification, channel, encryptionKey);\n+        conn.getDlmsMessageListener().setDescription(\n+                \"SetEncryptionKeyExchangeOnGMeter for channel \" + channel + \", call M-Bus Setup transfer_key method: \"\n+                        + JdlmsObjectToStringUtil.describeMethod(methodTransferKey));\n+\n+        return conn.getConnection().action(methodTransferKey);\n+    }\n+\n+    private MethodParameter getTransferKeyMethodParameter(String mbusDeviceIdentification, int channel,\n+            byte[] gMeterUserKey) throws ProtocolAdapterException {\n+        DlmsDevice mbusDevice = this.dlmsDeviceRepository.findByDeviceIdentification(mbusDeviceIdentification);\n+        if (mbusDevice == null) {\n+            throw new ProtocolAdapterException(\"Unknown M-Bus device: \" + mbusDeviceIdentification);\n+        }\n+        final byte[] mbusDefaultKey = this.secretManagementService.getKey(mbusDeviceIdentification, G_METER_MASTER);\n+        final byte[] encryptedUserKey = this.encryptMbusUserKey(mbusDefaultKey, gMeterUserKey);\n+        final DataObject methodParameter = DataObject.newOctetStringData(encryptedUserKey);\n+        final MBusClientMethod method = MBusClientMethod.TRANSFER_KEY;\n+        return new MethodParameter(method.getInterfaceClass().id(), OBIS_HASHMAP.get(channel), method.getMethodId(),\n+                methodParameter);\n+    }\n+\n+    private void checkMethodResultCode(final MethodResult methodResultCode, final String methodParameterName,\n+            ObisCode obisCode) throws ProtocolAdapterException {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM5MTY0Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558391642", "bodyText": "Missing final modifier on constructor argument.", "author": "bvdzwet", "createdAt": "2021-01-15T15:43:41Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/entities/SecurityKeyType.java", "diffHunk": "@@ -1,35 +1,56 @@\n /**\n  * Copyright 2015 Smart Society Services B.V.\n  *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License.  You may obtain a copy of the License at\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n  *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n+ * http://www.apache.org/licenses/LICENSE-2.0\n  */\n package org.opensmartgridplatform.adapter.protocol.dlms.domain.entities;\n \n+import java.util.Arrays;\n+\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n+\n public enum SecurityKeyType {\n     /**\n      * DLMS master key (Key Encryption Key)\n      */\n-    E_METER_MASTER,\n+    E_METER_MASTER(SecretType.E_METER_MASTER_KEY),\n     /**\n      * DLMS authentication key\n      */\n-    E_METER_AUTHENTICATION,\n+    E_METER_AUTHENTICATION(SecretType.E_METER_AUTHENTICATION_KEY),\n     /**\n      * DLMS global unicast encryption key\n      */\n-    E_METER_ENCRYPTION,\n+    E_METER_ENCRYPTION(SecretType.E_METER_ENCRYPTION_KEY_UNICAST),\n     /**\n      * M-Bus Default key\n      */\n-    G_METER_MASTER,\n+    G_METER_MASTER(SecretType.G_METER_MASTER_KEY),\n     /**\n      * M-Bus User key\n      */\n-    G_METER_ENCRYPTION,\n+    G_METER_ENCRYPTION(SecretType.G_METER_ENCRYPTION_KEY),\n     /**\n      * Password (e.g. used as DLMS Low Level Security secret)\n      */\n-    PASSWORD\n+    PASSWORD(SecretType.PPP_PASSWORD);\n+\n+    private final SecretType secretType;\n+\n+    SecurityKeyType(SecretType secretType) {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM5MTgxMg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558391812", "bodyText": "Missing final modifier on parameter.", "author": "bvdzwet", "createdAt": "2021-01-15T15:44:00Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/entities/SecurityKeyType.java", "diffHunk": "@@ -1,35 +1,56 @@\n /**\n  * Copyright 2015 Smart Society Services B.V.\n  *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License.  You may obtain a copy of the License at\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n  *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n+ * http://www.apache.org/licenses/LICENSE-2.0\n  */\n package org.opensmartgridplatform.adapter.protocol.dlms.domain.entities;\n \n+import java.util.Arrays;\n+\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n+\n public enum SecurityKeyType {\n     /**\n      * DLMS master key (Key Encryption Key)\n      */\n-    E_METER_MASTER,\n+    E_METER_MASTER(SecretType.E_METER_MASTER_KEY),\n     /**\n      * DLMS authentication key\n      */\n-    E_METER_AUTHENTICATION,\n+    E_METER_AUTHENTICATION(SecretType.E_METER_AUTHENTICATION_KEY),\n     /**\n      * DLMS global unicast encryption key\n      */\n-    E_METER_ENCRYPTION,\n+    E_METER_ENCRYPTION(SecretType.E_METER_ENCRYPTION_KEY_UNICAST),\n     /**\n      * M-Bus Default key\n      */\n-    G_METER_MASTER,\n+    G_METER_MASTER(SecretType.G_METER_MASTER_KEY),\n     /**\n      * M-Bus User key\n      */\n-    G_METER_ENCRYPTION,\n+    G_METER_ENCRYPTION(SecretType.G_METER_ENCRYPTION_KEY),\n     /**\n      * Password (e.g. used as DLMS Low Level Security secret)\n      */\n-    PASSWORD\n+    PASSWORD(SecretType.PPP_PASSWORD);\n+\n+    private final SecretType secretType;\n+\n+    SecurityKeyType(SecretType secretType) {\n+        this.secretType = secretType;\n+    }\n+\n+    public SecretType toSecretType() {\n+        return this.secretType;\n+    }\n+\n+    public static SecurityKeyType fromSecretType(SecretType secretType) {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM5NDk5NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558394994", "bodyText": "Like Jenkins says. Don't leave in unused imports.", "author": "bvdzwet", "createdAt": "2021-01-15T15:48:46Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/infra/messaging/responses/from/core/processors/GetFirmwareFileResponseMessageProcessor.java", "diffHunk": "@@ -9,6 +9,7 @@\n package org.opensmartgridplatform.adapter.protocol.dlms.infra.messaging.responses.from.core.processors;\n \n import java.io.Serializable;\n+import java.util.Optional;", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM5OTc2NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558399764", "bodyText": "This file is missing a required license header.", "author": "bvdzwet", "createdAt": "2021-01-15T15:56:09Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/test/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationServiceTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.services;", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQwMDgxNQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558400815", "bodyText": "Missing final modifier on local variable deviceDto (and several others in this class).", "author": "bvdzwet", "createdAt": "2021-01-15T15:57:42Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/test/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationServiceTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.services;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.opensmartgridplatform.adapter.protocol.dlms.application.mapping.InstallationMapper;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.repositories.DlmsDeviceRepository;\n+import org.opensmartgridplatform.dto.valueobjects.smartmetering.SmartMeteringDeviceDto;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class InstallationServiceTest {\n+    @InjectMocks\n+    InstallationService testService;\n+\n+    @Mock\n+    SecretManagementService secretManagementService;\n+\n+    @Mock\n+    DlmsDeviceRepository dlmsDeviceRepository;\n+    @Mock\n+    InstallationMapper installationMapper;\n+    @Mock\n+    EncryptionHelperService encryptionHelperService;\n+\n+    @Test\n+    void addEMeter() throws FunctionalException {\n+        // GIVEN\n+        SmartMeteringDeviceDto deviceDto = new SmartMeteringDeviceDto();", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQwMTYxMw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558401613", "bodyText": "Using underscores in method names goes against the naming conventions that are in use. (The same goes for some other methods following this one.)", "author": "bvdzwet", "createdAt": "2021-01-15T15:58:54Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/test/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationServiceTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.services;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.opensmartgridplatform.adapter.protocol.dlms.application.mapping.InstallationMapper;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.repositories.DlmsDeviceRepository;\n+import org.opensmartgridplatform.dto.valueobjects.smartmetering.SmartMeteringDeviceDto;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class InstallationServiceTest {\n+    @InjectMocks\n+    InstallationService testService;\n+\n+    @Mock\n+    SecretManagementService secretManagementService;\n+\n+    @Mock\n+    DlmsDeviceRepository dlmsDeviceRepository;\n+    @Mock\n+    InstallationMapper installationMapper;\n+    @Mock\n+    EncryptionHelperService encryptionHelperService;\n+\n+    @Test\n+    void addEMeter() throws FunctionalException {\n+        // GIVEN\n+        SmartMeteringDeviceDto deviceDto = new SmartMeteringDeviceDto();\n+        deviceDto.setDeviceIdentification(\"Test\");\n+        deviceDto.setMasterKey(new byte[16]);\n+        deviceDto.setAuthenticationKey(new byte[16]);\n+        deviceDto.setGlobalEncryptionUnicastKey(new byte[16]);\n+        DlmsDevice dlmsDevice = new DlmsDevice();\n+        when(this.installationMapper.map(deviceDto, DlmsDevice.class)).thenReturn(dlmsDevice);\n+        when(this.dlmsDeviceRepository.save(dlmsDevice)).thenReturn(dlmsDevice);\n+        when(this.encryptionHelperService.rsaDecrypt(any())).thenReturn(new byte[16]);\n+        // WHEN\n+        this.testService.addMeter(deviceDto);\n+        //THEN\n+        verify(this.secretManagementService, times(1)).storeNewKeys(any(), any());\n+        verify(this.secretManagementService, times(1)).activateNewKeys(any(), any());\n+    }\n+\n+    @Test\n+    void addGMeter() throws FunctionalException {\n+        // GIVEN\n+        SmartMeteringDeviceDto deviceDto = new SmartMeteringDeviceDto();\n+        deviceDto.setDeviceIdentification(\"Test\");\n+        deviceDto.setMbusDefaultKey(new byte[16]);\n+        DlmsDevice dlmsDevice = new DlmsDevice();\n+        when(this.installationMapper.map(deviceDto, DlmsDevice.class)).thenReturn(dlmsDevice);\n+        when(this.dlmsDeviceRepository.save(dlmsDevice)).thenReturn(dlmsDevice);\n+        when(this.encryptionHelperService.rsaDecrypt(any())).thenReturn(new byte[16]);\n+        // WHEN\n+        this.testService.addMeter(deviceDto);\n+        //THEN\n+        verify(this.secretManagementService, times(1)).storeNewKeys(any(), any());\n+        verify(this.secretManagementService, times(1)).activateNewKeys(any(), any());\n+    }\n+\n+    @Test\n+    void addMeter_noKeys() {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQwMjYyMg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558402622", "bodyText": "Copyright for new files should be for Alliander N.V. instead of Smart Society Services B.V.", "author": "bvdzwet", "createdAt": "2021-01-15T16:00:27Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/test/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementServiceTest.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQwNjQ5MQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558406491", "bodyText": "If the message in the TODO still applies, change the length back to a maximum of 40,\nAnyway, the TODO should not be left in the code.", "author": "bvdzwet", "createdAt": "2021-01-15T16:06:45Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/infra/jms/ResponseMessage.java", "diffHunk": "@@ -58,7 +58,8 @@ private String serializableToString(final Serializable dataObject) {\n             return \"\";\n         } else {\n             final String stringValue = dataObject.toString();\n-            return stringValue.substring(0, Math.min(stringValue.length(), 40));\n+            //TODO temp change; reset to 40\n+            return stringValue.substring(0, Math.min(stringValue.length(), 128));", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQwNzcwMg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558407702", "bodyText": "Missing final modifier on parameter.", "author": "bvdzwet", "createdAt": "2021-01-15T16:08:35Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java", "diffHunk": "@@ -20,24 +21,41 @@\n @Component\n public class DefaultEncryptionDelegate implements EncryptionDelegate {\n \n-    private static final String ERROR_NO_PROVIDER = \"Could not find a provider\";\n-    private final List<EncryptionProvider> providers;\n+    private static final String ERROR_NO_PROVIDER = \"Could not find a provider of type %s; available providers are %s\";\n+    private final EnumMap<EncryptionProviderType, EncryptionProvider> encryptionProviders;\n \n     public DefaultEncryptionDelegate(final List<EncryptionProvider> encryptionProviders) {\n-        this.providers = encryptionProviders;\n+        this.encryptionProviders = new EnumMap<>(EncryptionProviderType.class);\n+        encryptionProviders.stream().forEach(p -> this.encryptionProviders.put(p.getType(), p));\n+    }\n+\n+    private EncryptionProvider getEncryptionProvider(EncryptionProviderType type) {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQwODAyNQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558408025", "bodyText": "Missing final modifier on parameter.", "author": "bvdzwet", "createdAt": "2021-01-15T16:09:04Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java", "diffHunk": "@@ -20,24 +21,41 @@\n @Component\n public class DefaultEncryptionDelegate implements EncryptionDelegate {\n \n-    private static final String ERROR_NO_PROVIDER = \"Could not find a provider\";\n-    private final List<EncryptionProvider> providers;\n+    private static final String ERROR_NO_PROVIDER = \"Could not find a provider of type %s; available providers are %s\";\n+    private final EnumMap<EncryptionProviderType, EncryptionProvider> encryptionProviders;\n \n     public DefaultEncryptionDelegate(final List<EncryptionProvider> encryptionProviders) {\n-        this.providers = encryptionProviders;\n+        this.encryptionProviders = new EnumMap<>(EncryptionProviderType.class);\n+        encryptionProviders.stream().forEach(p -> this.encryptionProviders.put(p.getType(), p));\n+    }\n+\n+    private EncryptionProvider getEncryptionProvider(EncryptionProviderType type) {\n+        if (!this.encryptionProviders.containsKey(type)) {\n+            throw new EncrypterException(String.format(ERROR_NO_PROVIDER, type, this.encryptionProviders));\n+        }\n+        return this.encryptionProviders.get(type);\n+    }\n+\n+    @Override\n+    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final byte[] secret,\n+            final String keyReference) {\n+        return this.getEncryptionProvider(encryptionProviderType).encrypt(secret, keyReference);\n+    }\n+\n+    @Override\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+        return this.getEncryptionProvider(secret.getType()).decrypt(secret, keyReference);\n     }\n \n     @Override\n-    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final Secret secret,\n+    public byte[] generateAes128BitsSecret(final EncryptionProviderType encryptionProviderType,\n             final String keyReference) {\n-        return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n-                () -> new EncrypterException(ERROR_NO_PROVIDER)).encrypt(secret, keyReference);\n+        return this.getEncryptionProvider(encryptionProviderType).generateAes128BitsSecret(keyReference);\n     }\n \n     @Override\n-    public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n-        return this.providers.stream().filter(ep -> ep.getType().equals(secret.getType())).findFirst().orElseThrow(\n-                () -> new EncrypterException(ERROR_NO_PROVIDER)).decrypt(secret, keyReference);\n+    public int getSecretByteLength(EncryptionProviderType encryptionProviderType) {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQxMzQyMQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558413421", "bodyText": "Missing final modifier on parameter (same for some other methods in this class).", "author": "bvdzwet", "createdAt": "2021-01-15T16:17:56Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java", "diffHunk": "@@ -72,16 +78,34 @@ public String getFormat() {\n \n             @Override\n             public byte[] getEncoded() {\n-                return key;\n+                return JreEncryptionProvider.this.key;\n             }\n         };\n     }\n \n+    @Override\n     protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n         return new IvParameterSpec(IV);\n     }\n \n+    @Override\n+    public byte[] generateAes128BitsSecret(String keyReference) {", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQxMzk2Ng==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558413966", "bodyText": "Missing final modifier on local variable keyGenerator (and exc a few lines down).", "author": "bvdzwet", "createdAt": "2021-01-15T16:18:48Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java", "diffHunk": "@@ -72,16 +78,34 @@ public String getFormat() {\n \n             @Override\n             public byte[] getEncoded() {\n-                return key;\n+                return JreEncryptionProvider.this.key;\n             }\n         };\n     }\n \n+    @Override\n     protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n         return new IvParameterSpec(IV);\n     }\n \n+    @Override\n+    public byte[] generateAes128BitsSecret(String keyReference) {\n+        try {\n+            KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");", "originalCommit": "afa64e391130bf2bb23e3cdb70e67cd2ca2a2d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "message": "SLIM-2597 changes resulting from PR review comments", "committedDate": "2021-01-19T09:34:10Z", "type": "commit"}, {"oid": "c4a35f2b30f2487b5988d5a87cdfeddc94a51588", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/c4a35f2b30f2487b5988d5a87cdfeddc94a51588", "message": "Merge branch 'SLIM-2597-Implement-secret-management-extra-functionality' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2021-01-19T09:34:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA0NDk4MQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r560044981", "bodyText": "\"Alliander N.V.\" does not look quite right in this copyright statement (\"Alliander.V.\").", "author": "bvdzwet", "createdAt": "2021-01-19T09:47:29Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/config/SecretManagementPersistenceConfig.java", "diffHunk": "@@ -1,5 +1,5 @@\n /**\n- * Copyright 2020 Smart Society Services B.V.\n+ * Copyright 2020 Alliander.V.", "originalCommit": "c4a35f2b30f2487b5988d5a87cdfeddc94a51588", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA1Mjk0NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r560052944", "bodyText": "Sloppy formatting, the start of the class definition should not be on the same line as closing the javadoc.", "author": "bvdzwet", "createdAt": "2021-01-19T09:58:45Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java", "diffHunk": "@@ -45,15 +45,13 @@\n /**\n  * Service for storing, activating and retrieving device keys.\n  * Also performs RSA encryption/decryption operations for SOAP messaging purposes.\n- */\n-public class SecretManagementService {\n+ */ public class SecretManagementService {", "originalCommit": "c4a35f2b30f2487b5988d5a87cdfeddc94a51588", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a1bcfc807770a29b9f6ad27fc53937a1e42c731c", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/a1bcfc807770a29b9f6ad27fc53937a1e42c731c", "message": "SLIM-2597 changes resulting from PR review comments", "committedDate": "2021-01-19T10:59:51Z", "type": "commit"}, {"oid": "3d3b7013f5cab8f90b335382a83ae97db9ddcee8", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/3d3b7013f5cab8f90b335382a83ae97db9ddcee8", "message": "SLIM-2587 improved logging", "committedDate": "2020-11-04T15:41:35Z", "type": "commit"}, {"oid": "918fa0af77d5209a90afe2feda26a10b508d10f2", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/918fa0af77d5209a90afe2feda26a10b508d10f2", "message": "SLIM-2587 improved error message", "committedDate": "2020-11-04T15:42:03Z", "type": "commit"}, {"oid": "94e8fdb6efcd05bbb8d54938605b56fffd520ab5", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/94e8fdb6efcd05bbb8d54938605b56fffd520ab5", "message": "SLIM-2587 added error logging", "committedDate": "2020-11-04T15:47:58Z", "type": "commit"}, {"oid": "42823c4945121a2839af295d4f80e9d9564778d1", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/42823c4945121a2839af295d4f80e9d9564778d1", "message": "SLIM-2587 use JRE instead of the default HSM encryption", "committedDate": "2020-11-04T18:22:35Z", "type": "commit"}, {"oid": "6db7b0fb9bcd3f8060e1f1816edd1e6170c4b0d1", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/6db7b0fb9bcd3f8060e1f1816edd1e6170c4b0d1", "message": "SLIM-2597 set JRE as default encryption provider", "committedDate": "2020-11-05T09:25:47Z", "type": "commit"}, {"oid": "64b54011b8588d69659eaa5cee0058582f1b2731", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/64b54011b8588d69659eaa5cee0058582f1b2731", "message": "SLIM-2597 removed redundant JRE encryption provider setting (didnt work anyway)", "committedDate": "2020-11-05T09:27:29Z", "type": "commit"}, {"oid": "bcfad416ca6509c48ff18755b6fa6833bf317bf0", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/bcfad416ca6509c48ff18755b6fa6833bf317bf0", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-11-05T13:10:46Z", "type": "commit"}, {"oid": "975268fd83ee7af5c0f2cd3a1989e4fd2f53026c", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/975268fd83ee7af5c0f2cd3a1989e4fd2f53026c", "message": "SLIM-2597 changed JRE to HSM (test failures)", "committedDate": "2020-11-05T13:13:04Z", "type": "commit"}, {"oid": "afe60f35e2c1840347f6ed483fa544010ef0958c", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/afe60f35e2c1840347f6ed483fa544010ef0958c", "message": "SLIM-2597 changed HSM to JRE (test failures)", "committedDate": "2020-11-05T13:49:13Z", "type": "commit"}, {"oid": "305cc31d1cc35f95922f11b53f044f80db44163d", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/305cc31d1cc35f95922f11b53f044f80db44163d", "message": "Dummy commit to trigger PR build", "committedDate": "2020-11-05T15:26:23Z", "type": "commit"}, {"oid": "ff0cc472bc4c4b6229b2534222a922db11a90910", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/ff0cc472bc4c4b6229b2534222a922db11a90910", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-11-09T08:09:34Z", "type": "commit"}, {"oid": "f983bb61cec6314755904220be15949705393022", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/f983bb61cec6314755904220be15949705393022", "message": "SLIM-2597 fixed incorrect tag", "committedDate": "2020-11-09T08:10:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk2NTM5MQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r519965391", "bodyText": "Do not forget to remove this deprecated code someday.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-09T16:53:25Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/repositories/DlmsSecurityKeyRepository.java", "diffHunk": "@@ -17,15 +17,22 @@\n import org.springframework.data.repository.query.Param;\n import org.springframework.stereotype.Repository;\n \n+/**\n+ * @deprecated with the introduction of secret-management, the security_key table has become obsolete.\n+ */\n+@Deprecated\n @Repository\n public interface DlmsSecurityKeyRepository extends JpaRepository<SecurityKey, Long> {\n \n+    @Deprecated\n     @Query(\"SELECT s FROM SecurityKey s JOIN FETCH s.dlmsDevice WHERE s.securityKeyType = (:securityKeyType)\")\n     public List<SecurityKey> findBySecurityKeyType(@Param(\"securityKeyType\") SecurityKeyType securityKeyType);\n \n+    @Deprecated\n     SecurityKey findByDlmsDeviceAndSecurityKeyTypeAndValidToIsNull(DlmsDevice dlmsDevice,", "originalCommit": "f983bb61cec6314755904220be15949705393022", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk2NTQxNQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r519965415", "bodyText": "Do not forget to remove this deprecated code someday.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-09T16:53:26Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/repositories/DlmsSecurityKeyRepository.java", "diffHunk": "@@ -17,15 +17,22 @@\n import org.springframework.data.repository.query.Param;\n import org.springframework.stereotype.Repository;\n \n+/**\n+ * @deprecated with the introduction of secret-management, the security_key table has become obsolete.\n+ */\n+@Deprecated\n @Repository\n public interface DlmsSecurityKeyRepository extends JpaRepository<SecurityKey, Long> {\n \n+    @Deprecated\n     @Query(\"SELECT s FROM SecurityKey s JOIN FETCH s.dlmsDevice WHERE s.securityKeyType = (:securityKeyType)\")\n     public List<SecurityKey> findBySecurityKeyType(@Param(\"securityKeyType\") SecurityKeyType securityKeyType);\n \n+    @Deprecated\n     SecurityKey findByDlmsDeviceAndSecurityKeyTypeAndValidToIsNull(DlmsDevice dlmsDevice,\n             SecurityKeyType securityKeyType);\n \n+    @Deprecated\n     SecurityKey findByDlmsDeviceAndSecurityKeyTypeAndValidToNotNull(DlmsDevice dlmsDevice,", "originalCommit": "f983bb61cec6314755904220be15949705393022", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk2NTQ0Ng==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r519965446", "bodyText": "Do not forget to remove this deprecated code someday.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-09T16:53:27Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/repositories/DlmsSecurityKeyRepository.java", "diffHunk": "@@ -17,15 +17,22 @@\n import org.springframework.data.repository.query.Param;\n import org.springframework.stereotype.Repository;\n \n+/**\n+ * @deprecated with the introduction of secret-management, the security_key table has become obsolete.\n+ */\n+@Deprecated\n @Repository\n public interface DlmsSecurityKeyRepository extends JpaRepository<SecurityKey, Long> {\n \n+    @Deprecated\n     @Query(\"SELECT s FROM SecurityKey s JOIN FETCH s.dlmsDevice WHERE s.securityKeyType = (:securityKeyType)\")\n     public List<SecurityKey> findBySecurityKeyType(@Param(\"securityKeyType\") SecurityKeyType securityKeyType);", "originalCommit": "f983bb61cec6314755904220be15949705393022", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b66ad7da974da5fb9e814d3d24b293b6cb899084", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/b66ad7da974da5fb9e814d3d24b293b6cb899084", "message": "SLIM-2597 code cleanup", "committedDate": "2020-11-10T07:08:01Z", "type": "commit"}, {"oid": "d272878352ed7957f583fbca632370cf4b204c7f", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/d272878352ed7957f583fbca632370cf4b204c7f", "message": "SLIM-2597 code cleanup", "committedDate": "2020-11-10T07:12:07Z", "type": "commit"}, {"oid": "b1662d898a9b29b6a5212068b65d4b215b7c0ab3", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/b1662d898a9b29b6a5212068b65d4b215b7c0ab3", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-11-10T07:12:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0MzQxOQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r520343419", "bodyText": "Complete the task associated to this TODO comment.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-10T07:27:14Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/threads/RecoverKeyProcess.java", "diffHunk": "@@ -76,24 +84,35 @@ public void run() {\n         LOGGER.info(\"Attempting key recovery for device {}\", this.deviceIdentification);\n \n         try {\n-            this.initDevice();\n+            this.findDevice();\n         } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception: {}\", e);\n+            LOGGER.error(\"Could not find device\", e);\n+            //TODO why try to find device if you don't do anything with the result?!?", "originalCommit": "b1662d898a9b29b6a5212068b65d4b215b7c0ab3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg0MzM1Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527843352", "bodyText": "Not good to leave TODOs in the code. Either figure out and resolve the issues, or if they are not pressing, manage them through the backlog. (Same for the other TODOs.)", "author": "bvdzwet", "createdAt": "2020-11-20T17:21:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0MzQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0MzQyNA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r520343424", "bodyText": "Complete the task associated to this TODO comment.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-10T07:27:15Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/threads/RecoverKeyProcess.java", "diffHunk": "@@ -76,24 +84,35 @@ public void run() {\n         LOGGER.info(\"Attempting key recovery for device {}\", this.deviceIdentification);\n \n         try {\n-            this.initDevice();\n+            this.findDevice();\n         } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception: {}\", e);\n+            LOGGER.error(\"Could not find device\", e);\n+            //TODO why try to find device if you don't do anything with the result?!?\n+            //TODO return?", "originalCommit": "b1662d898a9b29b6a5212068b65d4b215b7c0ab3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "93a9527b698926992fd4447604722a49fe9b5565", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/93a9527b698926992fd4447604722a49fe9b5565", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-11-10T11:16:01Z", "type": "commit"}, {"oid": "ed5aa1c7d34a5094e1197f505d2e6d6943df0344", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/ed5aa1c7d34a5094e1197f505d2e6d6943df0344", "message": "SLIM-2585 improved error handling", "committedDate": "2020-11-10T16:43:07Z", "type": "commit"}, {"oid": "459d42c689d20eec51a0cb22b0cac6580dd9a2f2", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/459d42c689d20eec51a0cb22b0cac6580dd9a2f2", "message": "SLIM-2597 property comment wrt HSM usage", "committedDate": "2020-11-10T17:18:06Z", "type": "commit"}, {"oid": "b6c41ea4cb431e3ffb2acf2e0c517f58e6245702", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/b6c41ea4cb431e3ffb2acf2e0c517f58e6245702", "message": "SLIM-2597 added provisional Javadoc", "committedDate": "2020-11-10T17:58:03Z", "type": "commit"}, {"oid": "2a4ed743d13ec75712a311d49ea6cb59eed724f6", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/2a4ed743d13ec75712a311d49ea6cb59eed724f6", "message": "SLIM-2597 improved error handling, javadoc", "committedDate": "2020-11-10T20:01:40Z", "type": "commit"}, {"oid": "a82e16479eec8a242c4d770860c397e82470f3e2", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/a82e16479eec8a242c4d770860c397e82470f3e2", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-11-10T20:06:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg1MDI4OA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r520850288", "bodyText": "Return an empty array instead of null.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-10T20:21:27Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java", "diffHunk": "@@ -1,181 +1,294 @@\n /**\n  * Copyright 2016 Smart Society Services B.V.\n  *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License.  You may obtain a copy of the License at\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n  *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n+ * http://www.apache.org/licenses/LICENSE-2.0\n  */\n package org.opensmartgridplatform.adapter.protocol.dlms.application.services;\n \n+import static java.util.stream.Collectors.toList;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n import java.util.List;\n-import java.util.Optional;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n import lombok.extern.slf4j.Slf4j;\n import org.apache.commons.codec.binary.Hex;\n-import org.apache.commons.lang3.NotImplementedException;\n import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.SecretManagementClient;\n-import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n-import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.exceptionhandling.ComponentType;\n import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n-import org.opensmartgridplatform.shared.security.EncryptedSecret;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n-import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalExceptionType;\n+import org.opensmartgridplatform.shared.security.EncryptionService;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n+import org.opensmartgridplatform.shared.security.RsaEncryptionService;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.ActivateSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GenerateAndStoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GenerateAndStoreSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetNewSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetNewSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.HasNewSecretRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.HasNewSecretResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.OsgpResultType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n @Service\n @Slf4j\n public class SecretManagementService implements SecurityKeyService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncryptionProvider rsaEncryptionProvider;\n+    private final RsaEncrypter soapRsaEncrypter;\n     private final SecretManagementClient secretManagementClient;\n \n-    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider,\n-            SecretManagementClient secretManagementClient) {\n-        this.rsaEncryptionProvider = rsaEncryptionProvider;\n+    @Autowired\n+    private RsaEncryptionService rsaEncryptionService;\n+\n+    @Autowired\n+    private EncryptionService aesEncryptionService;\n+\n+    public SecretManagementService(RsaEncrypter soapRsaEncrypter, SecretManagementClient secretManagementClient) {\n+        this.soapRsaEncrypter = soapRsaEncrypter;\n         this.secretManagementClient = secretManagementClient;\n     }\n \n     @Override\n-    public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n-        throw new NotImplementedException();\n+    public byte[] rsaDecrypt(final byte[] externallyEncryptedKey) throws FunctionalException {\n+        try {\n+            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during decryption\", e);\n+            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n+        }\n     }\n \n     @Override\n-    public byte[] decryptKey(byte[] encryptedKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public byte[] getKey(String deviceIdentification, SecurityKeyType keyType) {\n+        LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n+        return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n     }\n \n     @Override\n-    public byte[] encryptKey(byte[] plainKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n+        GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n+        GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+        this.validateGetResponse(keyTypes, response);\n+        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n     }\n \n     @Override\n-    public byte[] getDlmsMasterKey(String deviceIdentification) {\n-        throw new NotImplementedException();\n+    public byte[] getNewKey(String deviceIdentification, SecurityKeyType keyType) {\n+        LOGGER.info(\"Retrieving new {} for device {}\", keyType.name(), deviceIdentification);\n+        return this.getNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n     }\n \n     @Override\n-    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n-\n-        try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-\n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-\n-            log.trace(\"DlmsAuthenticationKey for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n-\n-            return decryptedKey;\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving authentication key\", e);\n-        }\n+    public Map<SecurityKeyType, byte[]> getNewKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n+        GetNewSecretsRequest request = this.createGetNewSecretsRequest(deviceIdentification, keyTypes);\n+        GetNewSecretsResponse response = this.secretManagementClient.getNewSecretsRequest(request);\n+        this.validateGetNewResponse(keyTypes, response);\n+        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n     }\n \n-    @Override\n-    public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n-\n-        try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n+    private void validateGetResponse(List<SecurityKeyType> keyTypes, GetSecretsResponse response) {\n+        this.validateOsgpResultAndTypedSecrets(response.getResult(), response.getTechnicalFault(),\n+                response.getTypedSecrets(), keyTypes.size());\n+    }\n \n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n+    private void validateGetNewResponse(List<SecurityKeyType> keyTypes, GetNewSecretsResponse response) {\n+        this.validateOsgpResultAndTypedSecrets(response.getResult(), response.getTechnicalFault(),\n+                response.getTypedSecrets(), keyTypes.size());\n+    }\n \n-            log.trace(\"DlmsGlobalUnicastEncryptionKey for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n+    private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(List<TypedSecret> soapSecrets) {\n+        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n+        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts,false);\n+        return soapSecrets.stream().collect(Collectors.toMap(convertType, convertSecret));\n+    }\n \n-            return decryptedKey;\n+    private GetSecretsRequest createGetSecretsRequest(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n+        GetSecretsRequest request = new GetSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+        return request;\n+    }\n \n-        } catch (Exception e) {\n-            LOGGER.error(\"Error while retrieving encryption key\", e);\n-        }\n-        return new byte[0];\n+    private GetNewSecretsRequest createGetNewSecretsRequest(String deviceIdentification,\n+            List<SecurityKeyType> keyTypes) {\n+        GetNewSecretsRequest request = new GetNewSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+        return request;\n     }\n \n     @Override\n-    public byte[] getMbusDefaultKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] key) {\n+        Map<SecurityKeyType, byte[]> keysByType = new HashMap<>();\n+        keysByType.put(keyType, key);\n+        this.storeNewKeys(deviceIdentification, keysByType);\n     }\n \n     @Override\n-    public byte[] getMbusUserKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+    public void storeNewKeys(String deviceIdentification, Map<SecurityKeyType, byte[]> keysByType) {\n+        this.validateKeys(keysByType);\n+        TypedSecrets typedSecrets = new TypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+        for (SecurityKeyType type : keysByType.keySet()) {\n+            TypedSecret ts = new TypedSecret();\n+            ts.setType(type.toSecretType());\n+            ts.setSecret(this.encryptSoapSecret(keysByType.get(type),true));\n+            typedSecretList.add(ts);\n+        }\n+        StoreSecretsRequest request = this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n+        this.secretManagementClient.storeSecretsRequest(request);\n     }\n \n-    @Override\n-    public byte[] getDlmsPassword(String deviceIdentification) {\n-        throw new NotImplementedException();\n+    private void validateKeys(Map<SecurityKeyType, byte[]> keysByType) {\n+        long nrNulls = keysByType.values().stream().filter(key -> key == null).count();\n+        if (nrNulls > 0) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Provided %s keys, %s of which were NULL\", keysByType.size(), nrNulls));\n+        }\n     }\n \n-    @Override\n-    public DlmsDevice storeNewKey(DlmsDevice device, byte[] encryptedKey, SecurityKeyType keyType) {\n-        throw new NotImplementedException();\n+    private StoreSecretsRequest createStoreSecretsRequest(String deviceIdentification, TypedSecrets typedSecrets) {\n+        StoreSecretsRequest request = new StoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setTypedSecrets(typedSecrets);\n+        return request;\n     }\n \n     @Override\n-    public DlmsDevice validateNewKey(DlmsDevice device, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        this.activateNewKeys(deviceIdentification, Arrays.asList(keyType));\n     }\n \n     @Override\n-    public byte[] generateKey() {\n-        throw new NotImplementedException();\n+    public void activateNewKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n+        ActivateSecretsRequest request = new ActivateSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        keyTypes.forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+        this.secretManagementClient.activateSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateAndEncryptKey() {\n-        throw new NotImplementedException();\n+    public boolean hasNewSecretOfType(String deviceIdentification, SecurityKeyType keyType) {\n+        HasNewSecretRequest request = new HasNewSecretRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretType(keyType.toSecretType());\n+        HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n+        return response.isHasNewSecret();\n     }\n \n     @Override\n-    public byte[] encryptMbusUserKey(byte[] mbusDefaultKey, byte[] mbusUserKey) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public byte[] generate128BitsKeyAndStoreAsNewKey(String deviceIdentification, SecurityKeyType keyType) {\n+        return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n     }\n \n-    private Optional<TypedSecret> getTypedSecretFromSoapResponse(GetSecretsResponse response, SecretType secretType) {\n+    /**\n+     * Generates a new key that can be used as DLMS master key, authentication\n+     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n+     * <p>\n+     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n+     * device, but can be generated for use in tests or with simulated devices.\n+     *\n+     * @return a new 128bits key, unencrypted.\n+     */\n+    @Override\n+    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n+            List<SecurityKeyType> keyTypes) {\n+        SecretTypes secretTypes = new SecretTypes();\n+        GenerateAndStoreSecretsRequest request = this\n+                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n+\n+        GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n         TypedSecrets typedSecrets = response.getTypedSecrets();\n         List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        return typedSecretList.stream().filter(typedSecret -> typedSecret.getType() == secretType).findFirst();\n+        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+        return this.convertSoapSecretsToSecretMapByType(typedSecrets.getTypedSecret());\n     }\n \n-    private GetSecretsRequest getSoapRequestForKey(String deviceIdentification, SecretType secretType) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n+    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n+            SecretTypes secretTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n         request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(secretType);\n+        request.setSecretTypes(secretTypes);\n         return request;\n     }\n \n-    private byte[] decryptSoapSecret(String deviceIdentification, TypedSecret typedSecret) {\n+    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n+            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n+        this.validateOsgpResultAndTypedSecrets(response.getResult(), response.getTechnicalFault(),\n+                response.getTypedSecrets(), keyTypes.size());\n+        typedSecretList.forEach(ts -> {\n+            if (ts.getSecret() == null) {\n+                throw new IllegalStateException(String.format(\"Generated a NULL key (key_type=%s)\", ts.getType()));\n+            }\n+        });\n+    }\n+\n+    private void validateOsgpResultAndTypedSecrets(OsgpResultType result, Object fault, TypedSecrets typedSecrets,\n+            int expectedNrKeys) {\n+        if (!OsgpResultType.OK.equals(result)) {\n+            throw new IllegalStateException(\"Could not generate and store keys in secret-mgmt: \" + fault.toString());\n+        } else if (typedSecrets == null || typedSecrets.getTypedSecret() == null) {\n+            throw new IllegalStateException(\"No secrets in response\");\n+        } else if (expectedNrKeys != typedSecrets.getTypedSecret().size()) {\n+            throw new IllegalStateException(\n+                    String.format(\"Unexpected number of secrets in response: expected %s but \" + \"found %s\",\n+                            expectedNrKeys, typedSecrets.getTypedSecret().size()));\n+        }\n+    }\n+\n+    private byte[] decryptSoapSecret(TypedSecret typedSecret, boolean exceptionOnNull) {\n+        boolean nullValue = typedSecret.getSecret() == null || typedSecret.getSecret().isEmpty();\n+        if (exceptionOnNull && nullValue) {\n+            throw new IllegalArgumentException(\"Cannot decrypt NULL value\");\n+        } else if (!exceptionOnNull && nullValue) {\n+            return null;", "originalCommit": "a82e16479eec8a242c4d770860c397e82470f3e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0b71d5dfa9a1c93b030d83e373039b88b888127e", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/0b71d5dfa9a1c93b030d83e373039b88b888127e", "message": "SLIM-2597 added encryption keys to RSA encrypters", "committedDate": "2020-11-11T11:27:25Z", "type": "commit"}, {"oid": "9a33011b574726fee795cc5a11512c7c89c1e3cd", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/9a33011b574726fee795cc5a11512c7c89c1e3cd", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-11-11T11:27:45Z", "type": "commit"}, {"oid": "c33ad69f7e3f63dd03257feb264d209ee40a9063", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/c33ad69f7e3f63dd03257feb264d209ee40a9063", "message": "SLIM-2587 fix cucumber tests", "committedDate": "2020-11-11T13:38:36Z", "type": "commit"}, {"oid": "d6ab4840746253027635d8e1dd62c47376b64599", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/d6ab4840746253027635d8e1dd62c47376b64599", "message": "SLIM-2587 fix cucumber tests", "committedDate": "2020-11-11T15:28:36Z", "type": "commit"}, {"oid": "fe0089dac7cf66db3a9383f1198100cf4ef33395", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/fe0089dac7cf66db3a9383f1198100cf4ef33395", "message": "SLIM-2587 fix cucumber tests", "committedDate": "2020-11-12T13:47:45Z", "type": "commit"}, {"oid": "49f25859cbd9ad221945a8f5c0d285c1e95b3038", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/49f25859cbd9ad221945a8f5c0d285c1e95b3038", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-11-12T13:47:58Z", "type": "commit"}, {"oid": "5f57b867c7858cfcc02435b4182dffd4da6288c3", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/5f57b867c7858cfcc02435b4182dffd4da6288c3", "message": "SLIM-2597 fixed compilation failure", "committedDate": "2020-11-12T14:06:15Z", "type": "commit"}, {"oid": "b558cfa5038f6196739fa5c96f7518a4f26f81fa", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/b558cfa5038f6196739fa5c96f7518a4f26f81fa", "message": "SLIM-2597 fixed compilation failure", "committedDate": "2020-11-12T14:07:29Z", "type": "commit"}, {"oid": "878b5be6f9404cebdfed8e17c6d8c75dc12a382f", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/878b5be6f9404cebdfed8e17c6d8c75dc12a382f", "message": "SLIM-2597 fixed compilation failure", "committedDate": "2020-11-12T14:42:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE2NzA2OQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r522167069", "bodyText": "This block of commented-out lines of code should be removed.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-12T14:54:42Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java", "diffHunk": "@@ -38,144 +47,230 @@\n public class SecretManagementService implements SecurityKeyService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncryptionProvider rsaEncryptionProvider;\n+    private final RsaEncrypter soapRsaEncrypter;\n     private final SecretManagementClient secretManagementClient;\n \n-    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider,\n-            SecretManagementClient secretManagementClient) {\n-        this.rsaEncryptionProvider = rsaEncryptionProvider;\n+\n+    //@Autowired\n+    //private EncryptionService aesEncryptionService;", "originalCommit": "878b5be6f9404cebdfed8e17c6d8c75dc12a382f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3ba399636f400d309698aedf9b6d99c97b05b6fd", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/3ba399636f400d309698aedf9b6d99c97b05b6fd", "message": "Removed interface SecurityKeyService; replaced with SecretMgmtService", "committedDate": "2020-11-13T15:17:42Z", "type": "commit"}, {"oid": "dd16270414d364dc9e82609ef9fd4e9cde2be8df", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/dd16270414d364dc9e82609ef9fd4e9cde2be8df", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-11-13T15:22:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyODEyNA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r523028124", "bodyText": "This block of commented-out lines of code should be removed.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-13T15:35:24Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java", "diffHunk": "@@ -35,147 +44,318 @@\n \n @Service\n @Slf4j\n-public class SecretManagementService implements SecurityKeyService {\n+/**\n+ * Service for storing, activating and retrieving device keys.\n+ * Also performs RSA encryption/decryption operations for SOAP messaging purposes.\n+ */\n+public class SecretManagementService { //implements SecurityKeyService {", "originalCommit": "dd16270414d364dc9e82609ef9fd4e9cde2be8df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyODEzNw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r523028137", "bodyText": "Remove the declaration of thrown exception 'org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException', as it cannot be thrown from method's body.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-13T15:35:25Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java", "diffHunk": "@@ -35,147 +44,318 @@\n \n @Service\n @Slf4j\n-public class SecretManagementService implements SecurityKeyService {\n+/**\n+ * Service for storing, activating and retrieving device keys.\n+ * Also performs RSA encryption/decryption operations for SOAP messaging purposes.\n+ */\n+public class SecretManagementService { //implements SecurityKeyService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncryptionProvider rsaEncryptionProvider;\n+    private final RsaEncrypter soapRsaEncrypter;\n     private final SecretManagementClient secretManagementClient;\n \n-    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider,\n-            SecretManagementClient secretManagementClient) {\n-        this.rsaEncryptionProvider = rsaEncryptionProvider;\n+\n+    //@Autowired\n+    //private EncryptionService aesEncryptionService;\n+\n+    public SecretManagementService(RsaEncrypter soapRsaEncrypter, SecretManagementClient secretManagementClient) {\n+        this.soapRsaEncrypter = soapRsaEncrypter;\n         this.secretManagementClient = secretManagementClient;\n     }\n \n-    @Override\n-    public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n-        throw new NotImplementedException();\n+    /**\n+     * Retrieve an active key of a certain type for a specified device\n+     *\n+     * @param deviceIdentification\n+     *         the device identification string of the device\n+     * @param keyType\n+     *         the requested key type\n+     *\n+     * @return the key or NULL if not present\n+     */\n+    //@Override\n+    public byte[] getKey(String deviceIdentification, SecurityKeyType keyType) {\n+        LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n+        return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n     }\n \n-    @Override\n-    public byte[] decryptKey(byte[] encryptedKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    /**\n+     * Retrieves the active keys of requested types for a specified device\n+     *\n+     * @param deviceIdentification\n+     *         the device identification string of the device\n+     * @param keyTypes\n+     *         the requested key types\n+     *\n+     * @return the requested keys in a map by key type, with value NULL if not present\n+     */\n+    //@Override\n+    public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n+        GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n+        GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+        this.validateGetResponse(keyTypes, response);\n+        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n     }\n \n-    @Override\n-    public byte[] encryptKey(byte[] plainKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    /**\n+     * Retrieve a new (not yet activated) key of a certain type for a specified device\n+     *\n+     * @param deviceIdentification\n+     *         the device identification string of the device\n+     * @param keyType\n+     *         the requested key type\n+     *\n+     * @return the key or NULL if not present\n+     */\n+    //@Override\n+    public byte[] getNewKey(String deviceIdentification, SecurityKeyType keyType) {\n+        LOGGER.info(\"Retrieving new {} for device {}\", keyType.name(), deviceIdentification);\n+        return this.getNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n     }\n \n-    @Override\n-    public byte[] getDlmsMasterKey(String deviceIdentification) {\n-        throw new NotImplementedException();\n+    /**\n+     * Retrieves the new (not yet activated) keys of requested types for a specified device\n+     *\n+     * @param deviceIdentification\n+     *         the device identification string of the device\n+     * @param keyTypes\n+     *         the requested key types\n+     *\n+     * @return the requested keys in a map by key type, with value NULL if not present\n+     */\n+    //@Override\n+    public Map<SecurityKeyType, byte[]> getNewKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n+        GetNewSecretsRequest request = this.createGetNewSecretsRequest(deviceIdentification, keyTypes);\n+        GetNewSecretsResponse response = this.secretManagementClient.getNewSecretsRequest(request);\n+        this.validateGetNewResponse(keyTypes, response);\n+        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n     }\n \n-    @Override\n-    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n-\n-        try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-\n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-\n-            log.trace(\"DlmsAuthenticationKey for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n-\n-            return decryptedKey;\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving authentication key\", e);\n-        }\n+    private void validateGetResponse(List<SecurityKeyType> keyTypes, GetSecretsResponse response) {\n+        this.validateOsgpResultAndTypedSecrets(response.getResult(), response.getTechnicalFault(),\n+                response.getTypedSecrets(), keyTypes.size());\n     }\n \n-    @Override\n-    public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n-\n-        try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-\n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n+    private void validateGetNewResponse(List<SecurityKeyType> keyTypes, GetNewSecretsResponse response) {\n+        this.validateOsgpResultAndTypedSecrets(response.getResult(), response.getTechnicalFault(),\n+                response.getTypedSecrets(), keyTypes.size());\n+    }\n \n-            log.trace(\"DlmsGlobalUnicastEncryptionKey for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n+    private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(List<TypedSecret> soapSecrets) {\n+        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n+        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts,false);\n+        return soapSecrets.stream().collect(Collectors.toMap(convertType, convertSecret));\n+    }\n \n-            return decryptedKey;\n+    private GetSecretsRequest createGetSecretsRequest(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n+        GetSecretsRequest request = new GetSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+        return request;\n+    }\n \n-        } catch (Exception e) {\n-            LOGGER.error(\"Error while retrieving encryption key\", e);\n-        }\n-        return new byte[0];\n+    private GetNewSecretsRequest createGetNewSecretsRequest(String deviceIdentification,\n+            List<SecurityKeyType> keyTypes) {\n+        GetNewSecretsRequest request = new GetNewSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+        return request;\n     }\n \n-    @Override\n-    public byte[] getMbusDefaultKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+    /**\n+     * Store new key\n+     * <p>\n+     * A new key is a security key with a device which status NEW.\n+     * This status is used when the new key is known, but not yet set on the device.\n+     * <p>\n+     * <strong>CAUTION:</strong> Only call this method when a successful\n+     * connection with the device has been set up (that is: a valid\n+     * communication key that works is known), and you are sure any existing new\n+     * key data that is not activated yet (for instance a new key stored earlier in an\n+     * attempt to replace the communication key that got aborted).<br>\n+     * <p>\n+     * The moment the new key is known to be transferred to the device, make\n+     * sure to activate it by calling\n+     * {@link #activateNewKey(String, SecurityKeyType)}.\n+     *\n+     * @param deviceIdentification\n+     *         DLMS device id\n+     * @param key\n+     *         key to store, unencrypted\n+     * @param keyType\n+     *         type of key\n+     *\n+     * @see #activateNewKey(String, SecurityKeyType)\n+     */\n+    //@Override\n+    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] key) {\n+        Map<SecurityKeyType, byte[]> keysByType = new HashMap<>();\n+        keysByType.put(keyType, key);\n+        this.storeNewKeys(deviceIdentification, keysByType);\n     }\n \n-    @Override\n-    public byte[] getMbusUserKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+    //@Override\n+    public void storeNewKeys(String deviceIdentification, Map<SecurityKeyType, byte[]> keysByType) {\n+        this.validateKeys(keysByType);\n+        TypedSecrets typedSecrets = new TypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+        for (SecurityKeyType type : keysByType.keySet()) {\n+            TypedSecret ts = new TypedSecret();\n+            ts.setType(type.toSecretType());\n+            ts.setSecret(this.encryptSoapSecret(keysByType.get(type),true));\n+            typedSecretList.add(ts);\n+        }\n+        StoreSecretsRequest request = this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n+        this.secretManagementClient.storeSecretsRequest(request);\n     }\n \n-    @Override\n-    public byte[] getDlmsPassword(String deviceIdentification) {\n-        throw new NotImplementedException();\n+    private void validateKeys(Map<SecurityKeyType, byte[]> keysByType) {\n+        long nrNulls = keysByType.values().stream().filter(key -> key == null).count();\n+        if (nrNulls > 0) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Provided %s keys, %s of which were NULL\", keysByType.size(), nrNulls));\n+        }\n     }\n \n-    @Override\n-    public DlmsDevice storeNewKey(DlmsDevice device, byte[] encryptedKey, SecurityKeyType keyType) {\n-        throw new NotImplementedException();\n+    private StoreSecretsRequest createStoreSecretsRequest(String deviceIdentification, TypedSecrets typedSecrets) {\n+        StoreSecretsRequest request = new StoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setTypedSecrets(typedSecrets);\n+        return request;\n     }\n \n-    @Override\n-    public DlmsDevice validateNewKey(DlmsDevice device, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    /**\n+     * Updates the state of a new key from 'new' to 'active'\n+     * <p>\n+     * This method should be called to activate a new key stored with\n+     * {@link #storeNewKeys(String, Map)} after it has\n+     * been confirmed to be set on the device.\n+     *\n+     * @param deviceIdentification\n+     *         DLMS device id\n+     * @param keyType\n+     *         type of key\n+     *\n+     * @throws ProtocolAdapterException\n+     *         if no new key is stored with the given device\n+     * @see #storeNewKeys(String, Map)\n+     */\n+    //@Override\n+    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {", "originalCommit": "dd16270414d364dc9e82609ef9fd4e9cde2be8df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8ba12210b740a8fa2ab40ca897b6716f96162146", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/8ba12210b740a8fa2ab40ca897b6716f96162146", "message": "SLIM-2587 fixed bean name conflict", "committedDate": "2020-11-16T07:14:43Z", "type": "commit"}, {"oid": "ddc0dffb4e6cb889735275097244a70776e0deb0", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/ddc0dffb4e6cb889735275097244a70776e0deb0", "message": "SLIM-2587 added printout to analyze failing test", "committedDate": "2020-11-16T10:21:50Z", "type": "commit"}, {"oid": "ceff5d80dbffaac27cd7ff81f282efa87282f0dc", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/ceff5d80dbffaac27cd7ff81f282efa87282f0dc", "message": "SLIM-2587 added logging for debug tests", "committedDate": "2020-11-16T11:57:02Z", "type": "commit"}, {"oid": "6c5b3d8cd58bdf3dc5c8f6839ae5d680cf2fd5a6", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/6c5b3d8cd58bdf3dc5c8f6839ae5d680cf2fd5a6", "message": "SLIM-2587 fix cucumber tests", "committedDate": "2020-11-16T14:00:51Z", "type": "commit"}, {"oid": "a06f460a9af3645abfccae0403a2667b8022b945", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/a06f460a9af3645abfccae0403a2667b8022b945", "message": "SLIM-2587 fixed nasty bug (known bug regarding null-values in Map: https://bugs.openjdk.java.net/browse/JDK-8148463)", "committedDate": "2020-11-16T21:22:36Z", "type": "commit"}, {"oid": "0c2e10197290934452622ce8a27940c9300e3e83", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/0c2e10197290934452622ce8a27940c9300e3e83", "message": "SLIM-2587 improved secret mgmt error handling (for cucumber test case)", "committedDate": "2020-11-16T21:29:06Z", "type": "commit"}, {"oid": "6fc837b99ad040e7541184578507c278b5e481e4", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/6fc837b99ad040e7541184578507c278b5e481e4", "message": "SLIM-2587 fix cucumber tests; changed exception handling", "committedDate": "2020-11-17T15:08:51Z", "type": "commit"}, {"oid": "fa5eaeeec0fa66351d4fe864a102eb123fc8188a", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/fa5eaeeec0fa66351d4fe864a102eb123fc8188a", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-11-17T15:09:04Z", "type": "commit"}, {"oid": "b825972fc7d5c8e6eb317ad49f00107625125fe7", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/b825972fc7d5c8e6eb317ad49f00107625125fe7", "message": "SLIM-2587 fix cucumber tests; changed exception handling", "committedDate": "2020-11-17T15:18:26Z", "type": "commit"}, {"oid": "ca3c7e3a6251ce698a8be8870b879bc1cd637ec4", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/ca3c7e3a6251ce698a8be8870b879bc1cd637ec4", "message": "SLIM-2597 SonarQube issues resolved", "committedDate": "2020-11-18T10:02:02Z", "type": "commit"}, {"oid": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/40a643c8f5949e8f16de9c95013137600b4b1f2e", "message": "SLIM-2597 fix SonarQube issues", "committedDate": "2020-11-18T11:29:08Z", "type": "commit"}, {"oid": "cd1ca8a8fb41916cc60c748b61b562f8a92e7d3d", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/cd1ca8a8fb41916cc60c748b61b562f8a92e7d3d", "message": "SLIM-2587 removed temporary test annotations", "committedDate": "2020-11-18T12:58:13Z", "type": "commit"}, {"oid": "048b6f6b8a4ca16133e9032189cab1047c2e8bb7", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/048b6f6b8a4ca16133e9032189cab1047c2e8bb7", "message": "SLIM-2587 renamed cucumber method to conform to secret mgmt", "committedDate": "2020-11-18T13:05:15Z", "type": "commit"}, {"oid": "80447a64fa038d241a2ddacc72b1ce785321cc50", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/80447a64fa038d241a2ddacc72b1ce785321cc50", "message": "SLIM-2587 code clean-up", "committedDate": "2020-11-18T13:05:52Z", "type": "commit"}, {"oid": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "message": "SLIM-2597 Code improvement/SonarQube", "committedDate": "2020-11-19T07:55:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjY1ODU3NQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r526658575", "bodyText": "Remove if not needed.", "author": "carlogeenen", "createdAt": "2020-11-19T07:57:07Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/glue/steps/database/device/DlmsDeviceSteps.java", "diffHunk": "@@ -99,7 +134,7 @@ public void aDlmsDevice(final Map<String, String> inputSettings) {\n         this.createDeviceAuthorisationInCoreDatabase(device);\n \n         this.createDlmsDeviceInProtocolAdapterDatabase(inputSettings);\n-        this.createDlmsDeviceInSecretManagementDatabase(inputSettings);\n+        //this.createDlmsDeviceInSecretManagementDatabase(inputSettings);", "originalCommit": "80447a64fa038d241a2ddacc72b1ce785321cc50", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk1NzY5OA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r526957698", "bodyText": "Remove this line.", "author": "carlogeenen", "createdAt": "2020-11-19T15:04:49Z", "path": "osgp/platform/osgp-secret-management/src/integration-test/java/org/opensmartgridplatform/secretmanagement/application/SoapServiceSecretManagementIT.java", "diffHunk": "@@ -93,25 +94,45 @@ public void setupTest() {\n     }\n \n     @Test\n-    public void getSecretsRequest() {\n+    public void getSecretsRequest() throws IOException {\n \n         /**\n          * Note that the output depends, besides the value of the keys, also on both the db key and the soap key.\n          */\n         assertThat(this.secretRepository.count()).isEqualTo(2);\n         final Resource request = new ClassPathResource(\"test-requests/getSecrets.xml\");\n-        final Resource expectedResponse = new ClassPathResource(\"test-responses/getSecrets.xml\");\n+        this.mockWebServiceClient.sendRequest(withPayload(request))\n+                                     .andExpect((request2, response) -> {\n+                final OutputStream outStream = new ByteArrayOutputStream();\n+                response.writeTo(outStream);\n+                final String outputString = outStream.toString();\n+                assertThat(outputString.contains(\"<ns2:Result>OK</ns2:Result>\")).isTrue();\n+                assertThat(outputString.contains(\"E_METER_AUTHENTICATION\")).isTrue();\n+                assertThat(outputString.contains(\"E_METER_ENCRYPTION_KEY_UNICAST\")).isTrue();\n+\n+            });\n+    }\n+\n+    @Test\n+    public void getSecretsRequest_noStoredSecretType() {\n+\n+        /**\n+         * Note that the output depends, besides the value of the keys, also on both the db key and the soap key.\n+         */\n+        assertThat(this.secretRepository.count()).isEqualTo(2);\n+        final Resource request = new ClassPathResource(\"test-requests/getSecrets_noStoredSecretType.xml\");\n         try {\n-           this.mockWebServiceClient.sendRequest(withPayload(request)).andExpect(\n-                   (request2, response) -> {\n-                       OutputStream outStream = new ByteArrayOutputStream();\n-                       response.writeTo(outStream);\n-                       String outputString = outStream.toString();\n-                       assertThat(outputString.contains(\"<ns2:Result>OK</ns2:Result>\")).isTrue();\n-                       assertThat(outputString.contains(\"E_METER_AUTHENTICATION\")).isTrue();\n-                       assertThat(outputString.contains(\"E_METER_ENCRYPTION_KEY_UNICAST\")).isTrue();\n-\n-                   });\n+            this.mockWebServiceClient.sendRequest(withPayload(request))\n+                                     .andExpect((request2, response) -> {\n+                final OutputStream outStream = new ByteArrayOutputStream();\n+                response.writeTo(outStream);\n+                final String outputString = outStream.toString();\n+                //System.out.println(outputString);", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2MTEzNg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r526761136", "bodyText": "This source file is missing the required license header.", "author": "bvdzwet", "createdAt": "2020-11-19T10:42:02Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/config/SecretManagementPersistenceConfig.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package org.opensmartgridplatform.cucumber.platform.smartmetering.config;", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc3MzY5MQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r526773691", "bodyText": "Missing final modifier according to the code conventions.", "author": "bvdzwet", "createdAt": "2020-11-19T11:01:35Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/database/DlmsDatabase.java", "diffHunk": "@@ -69,24 +74,28 @@ private void insertDefaultData() {\n      */\n     @Transactional(transactionManager = \"txMgrDlms\")\n     public void prepareDatabaseForScenario() {\n-\n-        this.dlmsDSecurityKeyRepo.deleteAllInBatch();\n         this.dlmsDeviceRepo.deleteAllInBatch();\n         this.responseDataRepo.deleteAllInBatch();\n         this.responseUrlDataRepo.deleteAllInBatch();\n \n-        if (!Base.hasConnection()) {\n-            Base.open(DatabaseConnectionParameters.getDriver(), String.format(\"jdbc:postgresql://%s:%s/%s\", DatabaseConnectionParameters.getHost(), DatabaseConnectionParameters.getPort(), DatabaseConnectionParameters.getDatabase()),\n-                    DatabaseConnectionParameters.getUser(), DatabaseConnectionParameters.getPassword());\n-        }\n-        Base.exec(\"DELETE FROM public.encrypted_secret;\");\n-        Base.exec(\"DELETE FROM public.encryption_key_reference;\");\n-        Base.exec(\"insert into public.encryption_key_reference (id, reference, encryption_provider_type, valid_from, valid_to, creation_time, modification_time, modified_by, version)\" +\n-                \"values (1, 1, 'JRE', '2019-06-17 09:25:46.000000', '2021-06-18 09:26:09.000000', '2019-06-18 09:26:23.000000', '2019-06-18 09:26:25.000000', 1, 1);\");\n-\n-        Base.close();\n+        this.secretRepository.deleteAllInBatch();\n+        this.encryptionKeyRepository.deleteAllInBatch();\n+        DbEncryptionKeyReference jreEncryptionKey = this.getJreEncryptionKey(new Date());", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc3MzgxNw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r526773817", "bodyText": "Missing final modifier according to the code conventions.", "author": "bvdzwet", "createdAt": "2020-11-19T11:01:48Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/database/DlmsDatabase.java", "diffHunk": "@@ -69,24 +74,28 @@ private void insertDefaultData() {\n      */\n     @Transactional(transactionManager = \"txMgrDlms\")\n     public void prepareDatabaseForScenario() {\n-\n-        this.dlmsDSecurityKeyRepo.deleteAllInBatch();\n         this.dlmsDeviceRepo.deleteAllInBatch();\n         this.responseDataRepo.deleteAllInBatch();\n         this.responseUrlDataRepo.deleteAllInBatch();\n \n-        if (!Base.hasConnection()) {\n-            Base.open(DatabaseConnectionParameters.getDriver(), String.format(\"jdbc:postgresql://%s:%s/%s\", DatabaseConnectionParameters.getHost(), DatabaseConnectionParameters.getPort(), DatabaseConnectionParameters.getDatabase()),\n-                    DatabaseConnectionParameters.getUser(), DatabaseConnectionParameters.getPassword());\n-        }\n-        Base.exec(\"DELETE FROM public.encrypted_secret;\");\n-        Base.exec(\"DELETE FROM public.encryption_key_reference;\");\n-        Base.exec(\"insert into public.encryption_key_reference (id, reference, encryption_provider_type, valid_from, valid_to, creation_time, modification_time, modified_by, version)\" +\n-                \"values (1, 1, 'JRE', '2019-06-17 09:25:46.000000', '2021-06-18 09:26:09.000000', '2019-06-18 09:26:23.000000', '2019-06-18 09:26:25.000000', 1, 1);\");\n-\n-        Base.close();\n+        this.secretRepository.deleteAllInBatch();\n+        this.encryptionKeyRepository.deleteAllInBatch();\n+        DbEncryptionKeyReference jreEncryptionKey = this.getJreEncryptionKey(new Date());\n+        this.encryptionKeyRepository.save(jreEncryptionKey);\n \n         this.insertDefaultData();\n     }\n \n+    private DbEncryptionKeyReference getJreEncryptionKey(Date now) {\n+        DbEncryptionKeyReference jreEncryptionKey = new DbEncryptionKeyReference();", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc3NjcyMQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r526776721", "bodyText": "Missing empty line to separate the following method,", "author": "bvdzwet", "createdAt": "2020-11-19T11:06:40Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/glue/steps/database/device/DlmsDeviceSteps.java", "diffHunk": "@@ -89,7 +103,28 @@\n     @Autowired\n     private DeviceFirmwareModuleSteps deviceFirmwareModuleSteps;\n \n+    @Autowired\n+    private DbEncryptedSecretRepository encryptedSecretRepository;\n \n+    @Autowired\n+    private DbEncryptionKeyRepository encryptionKeyRepository;\n+\n+    private final SecurityKeyBuilder authenticationSecurityKeyBuilder = new SecurityKeyBuilder()\n+            .setSecurityKeyType(SecurityKeyType.E_METER_AUTHENTICATION)\n+            .setKey(PlatformSmartmeteringDefaults.SECURITY_KEY_A_DB);\n+    private final SecurityKeyBuilder encryptionSecurityKeyBuilder = new SecurityKeyBuilder()\n+            .setSecurityKeyType(SecurityKeyType.E_METER_ENCRYPTION)\n+            .setKey(PlatformSmartmeteringDefaults.SECURITY_KEY_E_DB);\n+    private final SecurityKeyBuilder masterSecurityKeyBuilder = new SecurityKeyBuilder()\n+            .setSecurityKeyType(SecurityKeyType.E_METER_MASTER).setKey(PlatformSmartmeteringDefaults.SECURITY_KEY_M_DB);\n+    private final SecurityKeyBuilder passwordBuilder = new SecurityKeyBuilder()\n+            .setSecurityKeyType(SecurityKeyType.PASSWORD).setKey(PlatformSmartmeteringDefaults.PASSWORD);\n+    private final SecurityKeyBuilder mbusEncryptionSecurityKeyBuilder = new SecurityKeyBuilder()\n+            .setSecurityKeyType(SecurityKeyType.G_METER_ENCRYPTION)\n+            .setKey(PlatformSmartmeteringDefaults.SECURITY_KEY_G_ENCRYPTION);\n+    private final SecurityKeyBuilder mbusMasterSecurityKeyBuilder = new SecurityKeyBuilder()\n+            .setSecurityKeyType(SecurityKeyType.G_METER_MASTER)\n+            .setKey(PlatformSmartmeteringDefaults.SECURITY_KEY_G_MASTER);", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc3NzI0OA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r526777248", "bodyText": "Missing final modifier according to the coding conventions.", "author": "bvdzwet", "createdAt": "2020-11-19T11:07:38Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/glue/steps/database/device/DlmsDeviceSteps.java", "diffHunk": "@@ -212,16 +246,14 @@ public void theNewKeysAreStoredInTheOsgpAdapterProtocolDlmsDatabaseSecurityKeyTa\n         assertThat(numberOfEncryptionKeys > 1).as(\"Number of encryption keys > 1\").isTrue();\n     }\n \n-    @Then(\"^the keys are not changed in the osgp_adapter_protocol_dlms database security_key table$\")\n+    @Then(\"^the keys are not changed in the secret_management database encrypted_secret table$\")\n     public void theKeysAreNotChangedInTheOsgpAdapterProtocolDlmsDatabaseSecurityKeyTable() {\n         final String keyDeviceIdentification = PlatformSmartmeteringKeys.DEVICE_IDENTIFICATION;\n         final String deviceIdentification = (String) ScenarioContext.current().get(keyDeviceIdentification);\n         assertThat(deviceIdentification)\n                 .as(\"Device identification must be in the scenario context for key \" + keyDeviceIdentification)\n                 .isNotNull();\n-\n-        final DlmsDevice dlmsDevice = this.findExistingDlmsDevice(deviceIdentification);\n-        final List<SecurityKey> securityKeys = dlmsDevice.getSecurityKeys();\n+        List<DbEncryptedSecret> securityKeys = this.findAllSecretsForDevice(deviceIdentification);", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc3ODYzOA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r526778638", "bodyText": "Missing final modifier according to the code conventions.", "author": "bvdzwet", "createdAt": "2020-11-19T11:09:59Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/glue/steps/database/device/DlmsDeviceSteps.java", "diffHunk": "@@ -232,29 +264,35 @@ public void theKeysAreNotChangedInTheOsgpAdapterProtocolDlmsDatabaseSecurityKeyT\n         int numberOfAuthenticationKeys = 0;\n         int numberOfEncryptionKeys = 0;\n \n-        for (final SecurityKey securityKey : securityKeys) {\n-            switch (securityKey.getSecurityKeyType()) {\n-            case E_METER_MASTER:\n+        for (final DbEncryptedSecret securityKey : securityKeys) {\n+            switch (securityKey.getSecretType()) {\n+            case E_METER_MASTER_KEY:\n                 numberOfMasterKeys += 1;\n                 break;\n-            case E_METER_AUTHENTICATION:\n+            case E_METER_AUTHENTICATION_KEY:\n                 numberOfAuthenticationKeys += 1;\n                 break;\n-            case E_METER_ENCRYPTION:\n+            case E_METER_ENCRYPTION_KEY_UNICAST:\n                 numberOfEncryptionKeys += 1;\n                 break;\n             default:\n                 // other keys are not counted\n             }\n-            assertThat(securityKey.getValidTo())\n-                    .as(\"security key \" + securityKey.getSecurityKeyType() + \" valid to date\").isNull();\n+            assertThat(securityKey.getSecretStatus()).as(\"security key \" + securityKey.getSecretType() + \" is active\")\n+                                                     .isEqualTo(SecretStatus.ACTIVE);\n         }\n \n         assertThat(numberOfMasterKeys).as(\"Number of master keys\").isEqualTo(1);\n         assertThat(numberOfAuthenticationKeys).as(\"Number of authentication keys\").isEqualTo(1);\n         assertThat(numberOfEncryptionKeys).as(\"Number of encryption keys\").isEqualTo(1);\n     }\n \n+    private List<DbEncryptedSecret> findAllSecretsForDevice(String deviceIdentification) {\n+        DbEncryptedSecret searchByIdExample = new DbEncryptedSecret();", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc4MDcwOA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r526780708", "bodyText": "Missing final modifiers according to the coding conventions.", "author": "bvdzwet", "createdAt": "2020-11-19T11:13:24Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/glue/steps/database/device/DlmsDeviceSteps.java", "diffHunk": "@@ -446,55 +487,61 @@ private void createDlmsDeviceInProtocolAdapterDatabase(final Map<String, String>\n         final ProtocolInfo protocolInfo = this.getProtocolInfo(inputSettings);\n \n         final DlmsDeviceBuilder dlmsDeviceBuilder = new DlmsDeviceBuilder().setProtocolName(protocolInfo);\n-        /*\n-         * Enable the necessary security key builders in the DLMS device builder\n-         * before calling withSettings. This allows the withSettings to be\n-         * called transitively on the enabled security key builders inside the\n-         * DLMS device builder.\n-         */\n+        final DlmsDevice dlmsDevice = dlmsDeviceBuilder.withSettings(inputSettings).build();\n+        this.dlmsDeviceRepository.save(dlmsDevice);\n+\n+        this.createDlmsDeviceInSecretManagementDatabase(dlmsDevice, inputSettings);\n+    }\n+\n+    private void createDlmsDeviceInSecretManagementDatabase(DlmsDevice dlmsDevice, Map<String,String> inputSettings) {", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg3ODYyMg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r526878622", "bodyText": "Missing final modifier according to the coding conventions.", "author": "bvdzwet", "createdAt": "2020-11-19T13:27:18Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/glue/steps/database/device/DlmsDeviceSteps.java", "diffHunk": "@@ -446,55 +487,61 @@ private void createDlmsDeviceInProtocolAdapterDatabase(final Map<String, String>\n         final ProtocolInfo protocolInfo = this.getProtocolInfo(inputSettings);\n \n         final DlmsDeviceBuilder dlmsDeviceBuilder = new DlmsDeviceBuilder().setProtocolName(protocolInfo);\n-        /*\n-         * Enable the necessary security key builders in the DLMS device builder\n-         * before calling withSettings. This allows the withSettings to be\n-         * called transitively on the enabled security key builders inside the\n-         * DLMS device builder.\n-         */\n+        final DlmsDevice dlmsDevice = dlmsDeviceBuilder.withSettings(inputSettings).build();\n+        this.dlmsDeviceRepository.save(dlmsDevice);\n+\n+        this.createDlmsDeviceInSecretManagementDatabase(dlmsDevice, inputSettings);\n+    }\n+\n+    private void createDlmsDeviceInSecretManagementDatabase(DlmsDevice dlmsDevice, Map<String,String> inputSettings) {\n         final String deviceType = inputSettings.getOrDefault(PlatformSmartmeteringKeys.DEVICE_TYPE, SMART_METER_E);\n-        if (inputSettings.containsKey(PlatformSmartmeteringKeys.LLS1_ACTIVE) && \"true\"\n-                .equals(inputSettings.get(PlatformSmartmeteringKeys.LLS1_ACTIVE))) {\n-            dlmsDeviceBuilder.getPasswordBuilder().enable();\n+        List<SecurityKeyBuilder> secretBuilders = new ArrayList<>();", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg4MzA0NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r526883044", "bodyText": "We shouldn't just leave TODOs in the code. Issues should either be resolved before finishing work on the feature, or should be managed through the backlog process if they don't need immediate attention to get a story done.", "author": "bvdzwet", "createdAt": "2020-11-19T13:31:25Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/glue/steps/database/device/DlmsDeviceSteps.java", "diffHunk": "@@ -446,55 +487,61 @@ private void createDlmsDeviceInProtocolAdapterDatabase(final Map<String, String>\n         final ProtocolInfo protocolInfo = this.getProtocolInfo(inputSettings);\n \n         final DlmsDeviceBuilder dlmsDeviceBuilder = new DlmsDeviceBuilder().setProtocolName(protocolInfo);\n-        /*\n-         * Enable the necessary security key builders in the DLMS device builder\n-         * before calling withSettings. This allows the withSettings to be\n-         * called transitively on the enabled security key builders inside the\n-         * DLMS device builder.\n-         */\n+        final DlmsDevice dlmsDevice = dlmsDeviceBuilder.withSettings(inputSettings).build();\n+        this.dlmsDeviceRepository.save(dlmsDevice);\n+\n+        this.createDlmsDeviceInSecretManagementDatabase(dlmsDevice, inputSettings);\n+    }\n+\n+    private void createDlmsDeviceInSecretManagementDatabase(DlmsDevice dlmsDevice, Map<String,String> inputSettings) {\n         final String deviceType = inputSettings.getOrDefault(PlatformSmartmeteringKeys.DEVICE_TYPE, SMART_METER_E);\n-        if (inputSettings.containsKey(PlatformSmartmeteringKeys.LLS1_ACTIVE) && \"true\"\n-                .equals(inputSettings.get(PlatformSmartmeteringKeys.LLS1_ACTIVE))) {\n-            dlmsDeviceBuilder.getPasswordBuilder().enable();\n+        List<SecurityKeyBuilder> secretBuilders = new ArrayList<>();\n+        if (inputSettings.containsKey(PlatformSmartmeteringKeys.LLS1_ACTIVE) &&\n+                \"true\".equals(inputSettings.get(PlatformSmartmeteringKeys.LLS1_ACTIVE))) {\n+            secretBuilders.add(this.passwordBuilder);\n         } else if (this.isGasSmartMeter(deviceType)) {\n-            dlmsDeviceBuilder.getMbusMasterSecurityKeyBuilder().enable();\n+            secretBuilders.add(this.mbusMasterSecurityKeyBuilder);\n             /*\n              * Don't insert a default value for the M-Bus User key. So only\n              * enable the builder if an M-Bus User key is explicitly configured\n              * in the step data.\n              */\n             if (inputSettings.containsKey(PlatformSmartmeteringKeys.MBUS_USER_KEY)) {\n-                dlmsDeviceBuilder.getMbusEncryptionSecurityKeyBuilder().enable();\n+                secretBuilders.add(this.mbusEncryptionSecurityKeyBuilder);\n             }\n         } else if (this.isESmartMeter(deviceType)) {\n-            dlmsDeviceBuilder.getEncryptionSecurityKeyBuilder().enable();\n-            dlmsDeviceBuilder.getMasterSecurityKeyBuilder().enable();\n-            dlmsDeviceBuilder.getAuthenticationSecurityKeyBuilder().enable();\n-        }\n-\n-        final DlmsDevice dlmsDevice = dlmsDeviceBuilder.withSettings(inputSettings).build();\n-        this.dlmsDeviceRepository.save(dlmsDevice);\n-\n-        if (!Base.hasConnection()) {\n-            Base.open(DatabaseConnectionParameters.getDriver(), String.format(\"jdbc:postgresql://%s:%s/%s\", DatabaseConnectionParameters.getHost(), DatabaseConnectionParameters.getPort(), DatabaseConnectionParameters.getDatabase()),\n-                    DatabaseConnectionParameters.getUser(), DatabaseConnectionParameters.getPassword());\n+            //TODO improve code to use provided parameters in general (also for other types)", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg4NDAwNQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r526884005", "bodyText": "Missing space between if and the opening brace according to the code conventions.", "author": "bvdzwet", "createdAt": "2020-11-19T13:32:05Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/glue/steps/database/device/DlmsDeviceSteps.java", "diffHunk": "@@ -446,55 +487,61 @@ private void createDlmsDeviceInProtocolAdapterDatabase(final Map<String, String>\n         final ProtocolInfo protocolInfo = this.getProtocolInfo(inputSettings);\n \n         final DlmsDeviceBuilder dlmsDeviceBuilder = new DlmsDeviceBuilder().setProtocolName(protocolInfo);\n-        /*\n-         * Enable the necessary security key builders in the DLMS device builder\n-         * before calling withSettings. This allows the withSettings to be\n-         * called transitively on the enabled security key builders inside the\n-         * DLMS device builder.\n-         */\n+        final DlmsDevice dlmsDevice = dlmsDeviceBuilder.withSettings(inputSettings).build();\n+        this.dlmsDeviceRepository.save(dlmsDevice);\n+\n+        this.createDlmsDeviceInSecretManagementDatabase(dlmsDevice, inputSettings);\n+    }\n+\n+    private void createDlmsDeviceInSecretManagementDatabase(DlmsDevice dlmsDevice, Map<String,String> inputSettings) {\n         final String deviceType = inputSettings.getOrDefault(PlatformSmartmeteringKeys.DEVICE_TYPE, SMART_METER_E);\n-        if (inputSettings.containsKey(PlatformSmartmeteringKeys.LLS1_ACTIVE) && \"true\"\n-                .equals(inputSettings.get(PlatformSmartmeteringKeys.LLS1_ACTIVE))) {\n-            dlmsDeviceBuilder.getPasswordBuilder().enable();\n+        List<SecurityKeyBuilder> secretBuilders = new ArrayList<>();\n+        if (inputSettings.containsKey(PlatformSmartmeteringKeys.LLS1_ACTIVE) &&\n+                \"true\".equals(inputSettings.get(PlatformSmartmeteringKeys.LLS1_ACTIVE))) {\n+            secretBuilders.add(this.passwordBuilder);\n         } else if (this.isGasSmartMeter(deviceType)) {\n-            dlmsDeviceBuilder.getMbusMasterSecurityKeyBuilder().enable();\n+            secretBuilders.add(this.mbusMasterSecurityKeyBuilder);\n             /*\n              * Don't insert a default value for the M-Bus User key. So only\n              * enable the builder if an M-Bus User key is explicitly configured\n              * in the step data.\n              */\n             if (inputSettings.containsKey(PlatformSmartmeteringKeys.MBUS_USER_KEY)) {\n-                dlmsDeviceBuilder.getMbusEncryptionSecurityKeyBuilder().enable();\n+                secretBuilders.add(this.mbusEncryptionSecurityKeyBuilder);\n             }\n         } else if (this.isESmartMeter(deviceType)) {\n-            dlmsDeviceBuilder.getEncryptionSecurityKeyBuilder().enable();\n-            dlmsDeviceBuilder.getMasterSecurityKeyBuilder().enable();\n-            dlmsDeviceBuilder.getAuthenticationSecurityKeyBuilder().enable();\n-        }\n-\n-        final DlmsDevice dlmsDevice = dlmsDeviceBuilder.withSettings(inputSettings).build();\n-        this.dlmsDeviceRepository.save(dlmsDevice);\n-\n-        if (!Base.hasConnection()) {\n-            Base.open(DatabaseConnectionParameters.getDriver(), String.format(\"jdbc:postgresql://%s:%s/%s\", DatabaseConnectionParameters.getHost(), DatabaseConnectionParameters.getPort(), DatabaseConnectionParameters.getDatabase()),\n-                    DatabaseConnectionParameters.getUser(), DatabaseConnectionParameters.getPassword());\n+            //TODO improve code to use provided parameters in general (also for other types)\n+            if(inputSettings.containsKey(PlatformSmartmeteringKeys.SECURITY_KEY_E)) {", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg4NTA4MA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r526885080", "bodyText": "Missing final modifier according to the code formatting conventions.", "author": "bvdzwet", "createdAt": "2020-11-19T13:32:47Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/glue/steps/database/device/DlmsDeviceSteps.java", "diffHunk": "@@ -446,55 +487,61 @@ private void createDlmsDeviceInProtocolAdapterDatabase(final Map<String, String>\n         final ProtocolInfo protocolInfo = this.getProtocolInfo(inputSettings);\n \n         final DlmsDeviceBuilder dlmsDeviceBuilder = new DlmsDeviceBuilder().setProtocolName(protocolInfo);\n-        /*\n-         * Enable the necessary security key builders in the DLMS device builder\n-         * before calling withSettings. This allows the withSettings to be\n-         * called transitively on the enabled security key builders inside the\n-         * DLMS device builder.\n-         */\n+        final DlmsDevice dlmsDevice = dlmsDeviceBuilder.withSettings(inputSettings).build();\n+        this.dlmsDeviceRepository.save(dlmsDevice);\n+\n+        this.createDlmsDeviceInSecretManagementDatabase(dlmsDevice, inputSettings);\n+    }\n+\n+    private void createDlmsDeviceInSecretManagementDatabase(DlmsDevice dlmsDevice, Map<String,String> inputSettings) {\n         final String deviceType = inputSettings.getOrDefault(PlatformSmartmeteringKeys.DEVICE_TYPE, SMART_METER_E);\n-        if (inputSettings.containsKey(PlatformSmartmeteringKeys.LLS1_ACTIVE) && \"true\"\n-                .equals(inputSettings.get(PlatformSmartmeteringKeys.LLS1_ACTIVE))) {\n-            dlmsDeviceBuilder.getPasswordBuilder().enable();\n+        List<SecurityKeyBuilder> secretBuilders = new ArrayList<>();\n+        if (inputSettings.containsKey(PlatformSmartmeteringKeys.LLS1_ACTIVE) &&\n+                \"true\".equals(inputSettings.get(PlatformSmartmeteringKeys.LLS1_ACTIVE))) {\n+            secretBuilders.add(this.passwordBuilder);\n         } else if (this.isGasSmartMeter(deviceType)) {\n-            dlmsDeviceBuilder.getMbusMasterSecurityKeyBuilder().enable();\n+            secretBuilders.add(this.mbusMasterSecurityKeyBuilder);\n             /*\n              * Don't insert a default value for the M-Bus User key. So only\n              * enable the builder if an M-Bus User key is explicitly configured\n              * in the step data.\n              */\n             if (inputSettings.containsKey(PlatformSmartmeteringKeys.MBUS_USER_KEY)) {\n-                dlmsDeviceBuilder.getMbusEncryptionSecurityKeyBuilder().enable();\n+                secretBuilders.add(this.mbusEncryptionSecurityKeyBuilder);\n             }\n         } else if (this.isESmartMeter(deviceType)) {\n-            dlmsDeviceBuilder.getEncryptionSecurityKeyBuilder().enable();\n-            dlmsDeviceBuilder.getMasterSecurityKeyBuilder().enable();\n-            dlmsDeviceBuilder.getAuthenticationSecurityKeyBuilder().enable();\n-        }\n-\n-        final DlmsDevice dlmsDevice = dlmsDeviceBuilder.withSettings(inputSettings).build();\n-        this.dlmsDeviceRepository.save(dlmsDevice);\n-\n-        if (!Base.hasConnection()) {\n-            Base.open(DatabaseConnectionParameters.getDriver(), String.format(\"jdbc:postgresql://%s:%s/%s\", DatabaseConnectionParameters.getHost(), DatabaseConnectionParameters.getPort(), DatabaseConnectionParameters.getDatabase()),\n-                    DatabaseConnectionParameters.getUser(), DatabaseConnectionParameters.getPassword());\n+            //TODO improve code to use provided parameters in general (also for other types)\n+            if(inputSettings.containsKey(PlatformSmartmeteringKeys.SECURITY_KEY_E)) {\n+                String inputEncryptionKey = inputSettings.get(PlatformSmartmeteringKeys.SECURITY_KEY_E);", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg4NTUxMg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r526885512", "bodyText": "Missing space between if and the opening brace and around != according to the code conventions.", "author": "bvdzwet", "createdAt": "2020-11-19T13:33:05Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/glue/steps/database/device/DlmsDeviceSteps.java", "diffHunk": "@@ -446,55 +487,61 @@ private void createDlmsDeviceInProtocolAdapterDatabase(final Map<String, String>\n         final ProtocolInfo protocolInfo = this.getProtocolInfo(inputSettings);\n \n         final DlmsDeviceBuilder dlmsDeviceBuilder = new DlmsDeviceBuilder().setProtocolName(protocolInfo);\n-        /*\n-         * Enable the necessary security key builders in the DLMS device builder\n-         * before calling withSettings. This allows the withSettings to be\n-         * called transitively on the enabled security key builders inside the\n-         * DLMS device builder.\n-         */\n+        final DlmsDevice dlmsDevice = dlmsDeviceBuilder.withSettings(inputSettings).build();\n+        this.dlmsDeviceRepository.save(dlmsDevice);\n+\n+        this.createDlmsDeviceInSecretManagementDatabase(dlmsDevice, inputSettings);\n+    }\n+\n+    private void createDlmsDeviceInSecretManagementDatabase(DlmsDevice dlmsDevice, Map<String,String> inputSettings) {\n         final String deviceType = inputSettings.getOrDefault(PlatformSmartmeteringKeys.DEVICE_TYPE, SMART_METER_E);\n-        if (inputSettings.containsKey(PlatformSmartmeteringKeys.LLS1_ACTIVE) && \"true\"\n-                .equals(inputSettings.get(PlatformSmartmeteringKeys.LLS1_ACTIVE))) {\n-            dlmsDeviceBuilder.getPasswordBuilder().enable();\n+        List<SecurityKeyBuilder> secretBuilders = new ArrayList<>();\n+        if (inputSettings.containsKey(PlatformSmartmeteringKeys.LLS1_ACTIVE) &&\n+                \"true\".equals(inputSettings.get(PlatformSmartmeteringKeys.LLS1_ACTIVE))) {\n+            secretBuilders.add(this.passwordBuilder);\n         } else if (this.isGasSmartMeter(deviceType)) {\n-            dlmsDeviceBuilder.getMbusMasterSecurityKeyBuilder().enable();\n+            secretBuilders.add(this.mbusMasterSecurityKeyBuilder);\n             /*\n              * Don't insert a default value for the M-Bus User key. So only\n              * enable the builder if an M-Bus User key is explicitly configured\n              * in the step data.\n              */\n             if (inputSettings.containsKey(PlatformSmartmeteringKeys.MBUS_USER_KEY)) {\n-                dlmsDeviceBuilder.getMbusEncryptionSecurityKeyBuilder().enable();\n+                secretBuilders.add(this.mbusEncryptionSecurityKeyBuilder);\n             }\n         } else if (this.isESmartMeter(deviceType)) {\n-            dlmsDeviceBuilder.getEncryptionSecurityKeyBuilder().enable();\n-            dlmsDeviceBuilder.getMasterSecurityKeyBuilder().enable();\n-            dlmsDeviceBuilder.getAuthenticationSecurityKeyBuilder().enable();\n-        }\n-\n-        final DlmsDevice dlmsDevice = dlmsDeviceBuilder.withSettings(inputSettings).build();\n-        this.dlmsDeviceRepository.save(dlmsDevice);\n-\n-        if (!Base.hasConnection()) {\n-            Base.open(DatabaseConnectionParameters.getDriver(), String.format(\"jdbc:postgresql://%s:%s/%s\", DatabaseConnectionParameters.getHost(), DatabaseConnectionParameters.getPort(), DatabaseConnectionParameters.getDatabase()),\n-                    DatabaseConnectionParameters.getUser(), DatabaseConnectionParameters.getPassword());\n+            //TODO improve code to use provided parameters in general (also for other types)\n+            if(inputSettings.containsKey(PlatformSmartmeteringKeys.SECURITY_KEY_E)) {\n+                String inputEncryptionKey = inputSettings.get(PlatformSmartmeteringKeys.SECURITY_KEY_E);\n+                if(inputEncryptionKey!=null && !inputEncryptionKey.trim().isEmpty()) {", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg4NzA1NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r526887054", "bodyText": "Missing final modifier according to the code formatting conventions.", "author": "bvdzwet", "createdAt": "2020-11-19T13:34:12Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/glue/steps/database/device/DlmsDeviceSteps.java", "diffHunk": "@@ -446,55 +487,61 @@ private void createDlmsDeviceInProtocolAdapterDatabase(final Map<String, String>\n         final ProtocolInfo protocolInfo = this.getProtocolInfo(inputSettings);\n \n         final DlmsDeviceBuilder dlmsDeviceBuilder = new DlmsDeviceBuilder().setProtocolName(protocolInfo);\n-        /*\n-         * Enable the necessary security key builders in the DLMS device builder\n-         * before calling withSettings. This allows the withSettings to be\n-         * called transitively on the enabled security key builders inside the\n-         * DLMS device builder.\n-         */\n+        final DlmsDevice dlmsDevice = dlmsDeviceBuilder.withSettings(inputSettings).build();\n+        this.dlmsDeviceRepository.save(dlmsDevice);\n+\n+        this.createDlmsDeviceInSecretManagementDatabase(dlmsDevice, inputSettings);\n+    }\n+\n+    private void createDlmsDeviceInSecretManagementDatabase(DlmsDevice dlmsDevice, Map<String,String> inputSettings) {\n         final String deviceType = inputSettings.getOrDefault(PlatformSmartmeteringKeys.DEVICE_TYPE, SMART_METER_E);\n-        if (inputSettings.containsKey(PlatformSmartmeteringKeys.LLS1_ACTIVE) && \"true\"\n-                .equals(inputSettings.get(PlatformSmartmeteringKeys.LLS1_ACTIVE))) {\n-            dlmsDeviceBuilder.getPasswordBuilder().enable();\n+        List<SecurityKeyBuilder> secretBuilders = new ArrayList<>();\n+        if (inputSettings.containsKey(PlatformSmartmeteringKeys.LLS1_ACTIVE) &&\n+                \"true\".equals(inputSettings.get(PlatformSmartmeteringKeys.LLS1_ACTIVE))) {\n+            secretBuilders.add(this.passwordBuilder);\n         } else if (this.isGasSmartMeter(deviceType)) {\n-            dlmsDeviceBuilder.getMbusMasterSecurityKeyBuilder().enable();\n+            secretBuilders.add(this.mbusMasterSecurityKeyBuilder);\n             /*\n              * Don't insert a default value for the M-Bus User key. So only\n              * enable the builder if an M-Bus User key is explicitly configured\n              * in the step data.\n              */\n             if (inputSettings.containsKey(PlatformSmartmeteringKeys.MBUS_USER_KEY)) {\n-                dlmsDeviceBuilder.getMbusEncryptionSecurityKeyBuilder().enable();\n+                secretBuilders.add(this.mbusEncryptionSecurityKeyBuilder);\n             }\n         } else if (this.isESmartMeter(deviceType)) {\n-            dlmsDeviceBuilder.getEncryptionSecurityKeyBuilder().enable();\n-            dlmsDeviceBuilder.getMasterSecurityKeyBuilder().enable();\n-            dlmsDeviceBuilder.getAuthenticationSecurityKeyBuilder().enable();\n-        }\n-\n-        final DlmsDevice dlmsDevice = dlmsDeviceBuilder.withSettings(inputSettings).build();\n-        this.dlmsDeviceRepository.save(dlmsDevice);\n-\n-        if (!Base.hasConnection()) {\n-            Base.open(DatabaseConnectionParameters.getDriver(), String.format(\"jdbc:postgresql://%s:%s/%s\", DatabaseConnectionParameters.getHost(), DatabaseConnectionParameters.getPort(), DatabaseConnectionParameters.getDatabase()),\n-                    DatabaseConnectionParameters.getUser(), DatabaseConnectionParameters.getPassword());\n+            //TODO improve code to use provided parameters in general (also for other types)\n+            if(inputSettings.containsKey(PlatformSmartmeteringKeys.SECURITY_KEY_E)) {\n+                String inputEncryptionKey = inputSettings.get(PlatformSmartmeteringKeys.SECURITY_KEY_E);\n+                if(inputEncryptionKey!=null && !inputEncryptionKey.trim().isEmpty()) {\n+                    secretBuilders.add(new SecurityKeyBuilder()\n+                            .setSecurityKeyType(SecurityKeyType.E_METER_ENCRYPTION)\n+                            .setKey(inputEncryptionKey));\n+                }\n+            } else {\n+                secretBuilders.add(this.encryptionSecurityKeyBuilder);\n+            }\n+            secretBuilders.add(this.masterSecurityKeyBuilder);\n+            secretBuilders.add(this.authenticationSecurityKeyBuilder);\n         }\n-\n-\n-        Base.exec(\"INSERT INTO encrypted_secret (device_identification,secret_type,encoded_secret,creation_time,encryption_key_reference_id)\" +\n-                \"VALUES ('TEST1024000000001', 'E_METER_AUTHENTICATION_KEY', 'c19fe80a22a0f6c5cdaad0826c4d204f23694ded08d811b66e9b845d9f2157d2', NOW(), (SELECT id FROM public.encryption_key_reference where encryption_provider_type = 'JRE')),\" +\n-                \"('TEST1024000000001', 'E_METER_ENCRYPTION_KEY_UNICAST', '867424ac75b6d53c89276d304608321f0a1f6e401f453f84adf3477c7ee1623c', NOW(), (SELECT id FROM public.encryption_key_reference where encryption_provider_type = 'JRE')),\" +\n-                \"('TEST1024000000001', 'E_METER_MASTER_KEY', '55dc88791e6c8f6aff4c8be7714fb8d2ae3d02693ec474593acd3523ee032638', NOW(), (SELECT id FROM public.encryption_key_reference where encryption_provider_type = 'JRE'));\");\n-\n-        Base.exec(\"INSERT INTO encrypted_secret (device_identification,secret_type,encoded_secret,creation_time,encryption_key_reference_id)\" +\n-                \"VALUES ('TEST1027000000001', 'E_METER_AUTHENTICATION_KEY', 'c19fe80a22a0f6c5cdaad0826c4d204f23694ded08d811b66e9b845d9f2157d2', NOW(), (SELECT id FROM public.encryption_key_reference where encryption_provider_type = 'JRE')),\" +\n-                \"('TEST1027000000001', 'E_METER_ENCRYPTION_KEY_UNICAST', '867424ac75b6d53c89276d304608321f0a1f6e401f453f84adf3477c7ee1623c', NOW(), (SELECT id FROM public.encryption_key_reference where encryption_provider_type = 'JRE')),\" +\n-                \"('TEST1027000000001', 'E_METER_MASTER_KEY', '55dc88791e6c8f6aff4c8be7714fb8d2ae3d02693ec474593acd3523ee032638', NOW(), (SELECT id FROM public.encryption_key_reference where encryption_provider_type = 'JRE'));\");\n-\n-        Base.close();\n+        DbEncryptionKeyReference encryptionKeyRef = this.encryptionKeyRepository", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg4NzY4Nw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r526887687", "bodyText": "Missing final modifiers according to the code formatting conventions.", "author": "bvdzwet", "createdAt": "2020-11-19T13:34:38Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/glue/steps/database/device/DlmsDeviceSteps.java", "diffHunk": "@@ -446,55 +487,61 @@ private void createDlmsDeviceInProtocolAdapterDatabase(final Map<String, String>\n         final ProtocolInfo protocolInfo = this.getProtocolInfo(inputSettings);\n \n         final DlmsDeviceBuilder dlmsDeviceBuilder = new DlmsDeviceBuilder().setProtocolName(protocolInfo);\n-        /*\n-         * Enable the necessary security key builders in the DLMS device builder\n-         * before calling withSettings. This allows the withSettings to be\n-         * called transitively on the enabled security key builders inside the\n-         * DLMS device builder.\n-         */\n+        final DlmsDevice dlmsDevice = dlmsDeviceBuilder.withSettings(inputSettings).build();\n+        this.dlmsDeviceRepository.save(dlmsDevice);\n+\n+        this.createDlmsDeviceInSecretManagementDatabase(dlmsDevice, inputSettings);\n+    }\n+\n+    private void createDlmsDeviceInSecretManagementDatabase(DlmsDevice dlmsDevice, Map<String,String> inputSettings) {\n         final String deviceType = inputSettings.getOrDefault(PlatformSmartmeteringKeys.DEVICE_TYPE, SMART_METER_E);\n-        if (inputSettings.containsKey(PlatformSmartmeteringKeys.LLS1_ACTIVE) && \"true\"\n-                .equals(inputSettings.get(PlatformSmartmeteringKeys.LLS1_ACTIVE))) {\n-            dlmsDeviceBuilder.getPasswordBuilder().enable();\n+        List<SecurityKeyBuilder> secretBuilders = new ArrayList<>();\n+        if (inputSettings.containsKey(PlatformSmartmeteringKeys.LLS1_ACTIVE) &&\n+                \"true\".equals(inputSettings.get(PlatformSmartmeteringKeys.LLS1_ACTIVE))) {\n+            secretBuilders.add(this.passwordBuilder);\n         } else if (this.isGasSmartMeter(deviceType)) {\n-            dlmsDeviceBuilder.getMbusMasterSecurityKeyBuilder().enable();\n+            secretBuilders.add(this.mbusMasterSecurityKeyBuilder);\n             /*\n              * Don't insert a default value for the M-Bus User key. So only\n              * enable the builder if an M-Bus User key is explicitly configured\n              * in the step data.\n              */\n             if (inputSettings.containsKey(PlatformSmartmeteringKeys.MBUS_USER_KEY)) {\n-                dlmsDeviceBuilder.getMbusEncryptionSecurityKeyBuilder().enable();\n+                secretBuilders.add(this.mbusEncryptionSecurityKeyBuilder);\n             }\n         } else if (this.isESmartMeter(deviceType)) {\n-            dlmsDeviceBuilder.getEncryptionSecurityKeyBuilder().enable();\n-            dlmsDeviceBuilder.getMasterSecurityKeyBuilder().enable();\n-            dlmsDeviceBuilder.getAuthenticationSecurityKeyBuilder().enable();\n-        }\n-\n-        final DlmsDevice dlmsDevice = dlmsDeviceBuilder.withSettings(inputSettings).build();\n-        this.dlmsDeviceRepository.save(dlmsDevice);\n-\n-        if (!Base.hasConnection()) {\n-            Base.open(DatabaseConnectionParameters.getDriver(), String.format(\"jdbc:postgresql://%s:%s/%s\", DatabaseConnectionParameters.getHost(), DatabaseConnectionParameters.getPort(), DatabaseConnectionParameters.getDatabase()),\n-                    DatabaseConnectionParameters.getUser(), DatabaseConnectionParameters.getPassword());\n+            //TODO improve code to use provided parameters in general (also for other types)\n+            if(inputSettings.containsKey(PlatformSmartmeteringKeys.SECURITY_KEY_E)) {\n+                String inputEncryptionKey = inputSettings.get(PlatformSmartmeteringKeys.SECURITY_KEY_E);\n+                if(inputEncryptionKey!=null && !inputEncryptionKey.trim().isEmpty()) {\n+                    secretBuilders.add(new SecurityKeyBuilder()\n+                            .setSecurityKeyType(SecurityKeyType.E_METER_ENCRYPTION)\n+                            .setKey(inputEncryptionKey));\n+                }\n+            } else {\n+                secretBuilders.add(this.encryptionSecurityKeyBuilder);\n+            }\n+            secretBuilders.add(this.masterSecurityKeyBuilder);\n+            secretBuilders.add(this.authenticationSecurityKeyBuilder);\n         }\n-\n-\n-        Base.exec(\"INSERT INTO encrypted_secret (device_identification,secret_type,encoded_secret,creation_time,encryption_key_reference_id)\" +\n-                \"VALUES ('TEST1024000000001', 'E_METER_AUTHENTICATION_KEY', 'c19fe80a22a0f6c5cdaad0826c4d204f23694ded08d811b66e9b845d9f2157d2', NOW(), (SELECT id FROM public.encryption_key_reference where encryption_provider_type = 'JRE')),\" +\n-                \"('TEST1024000000001', 'E_METER_ENCRYPTION_KEY_UNICAST', '867424ac75b6d53c89276d304608321f0a1f6e401f453f84adf3477c7ee1623c', NOW(), (SELECT id FROM public.encryption_key_reference where encryption_provider_type = 'JRE')),\" +\n-                \"('TEST1024000000001', 'E_METER_MASTER_KEY', '55dc88791e6c8f6aff4c8be7714fb8d2ae3d02693ec474593acd3523ee032638', NOW(), (SELECT id FROM public.encryption_key_reference where encryption_provider_type = 'JRE'));\");\n-\n-        Base.exec(\"INSERT INTO encrypted_secret (device_identification,secret_type,encoded_secret,creation_time,encryption_key_reference_id)\" +\n-                \"VALUES ('TEST1027000000001', 'E_METER_AUTHENTICATION_KEY', 'c19fe80a22a0f6c5cdaad0826c4d204f23694ded08d811b66e9b845d9f2157d2', NOW(), (SELECT id FROM public.encryption_key_reference where encryption_provider_type = 'JRE')),\" +\n-                \"('TEST1027000000001', 'E_METER_ENCRYPTION_KEY_UNICAST', '867424ac75b6d53c89276d304608321f0a1f6e401f453f84adf3477c7ee1623c', NOW(), (SELECT id FROM public.encryption_key_reference where encryption_provider_type = 'JRE')),\" +\n-                \"('TEST1027000000001', 'E_METER_MASTER_KEY', '55dc88791e6c8f6aff4c8be7714fb8d2ae3d02693ec474593acd3523ee032638', NOW(), (SELECT id FROM public.encryption_key_reference where encryption_provider_type = 'JRE'));\");\n-\n-        Base.close();\n+        DbEncryptionKeyReference encryptionKeyRef = this.encryptionKeyRepository\n+                .findByTypeAndValid(EncryptionProviderType.JRE, new Date()).iterator().next();\n+        secretBuilders.stream()\n+                      .map(SecurityKeyBuilder::build)\n+                      .map(key -> this.createSecretFromKey(dlmsDevice.getDeviceIdentification(), encryptionKeyRef, key))\n+                      .forEach(this.encryptedSecretRepository::save);\n     }\n \n-    private void createDlmsDeviceInSecretManagementDatabase(final Map<String, String> inputSettings) {\n+    private DbEncryptedSecret createSecretFromKey(String deviceIdentification,\n+            DbEncryptionKeyReference encryptionKeyRef, SecurityKey key) {", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk1MzY1MA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r526953650", "bodyText": "Missing final modifier according to the code conventions.", "author": "bvdzwet", "createdAt": "2020-11-19T14:59:38Z", "path": "integration-tests/cucumber-tests-platform-smartmetering/src/test/java/org/opensmartgridplatform/cucumber/platform/smartmetering/glue/steps/ws/smartmetering/smartmeteringmonitoring/ActualMeterReadsSteps.java", "diffHunk": "@@ -56,7 +56,8 @@ public void theGetActualMeterReadsRequestGeneratingAnErrorIsReceived(final Map<S\n         assertThat(actualMeterReadsAsyncRequest).as(\"ActualMeterReadsAsyncRequest should not be null\").isNotNull();\n \n         try {\n-            this.responseClient.getResponse(actualMeterReadsAsyncRequest);\n+            ActualMeterReadsResponse response = this.responseClient.getResponse(actualMeterReadsAsyncRequest);", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAwNzU5Ng==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527007596", "bodyText": "This looks like something that may have been helpful during development of the tests, but we shouldn't leave commented code. (There are some more lines like this one in this class.)", "author": "bvdzwet", "createdAt": "2020-11-19T16:07:03Z", "path": "osgp/platform/osgp-secret-management/src/integration-test/java/org/opensmartgridplatform/secretmanagement/application/SoapServiceSecretManagementIT.java", "diffHunk": "@@ -138,6 +159,61 @@ public void storeSecretsRequest() {\n         assertThat(this.secretRepository.count()).isEqualTo(4);\n     }\n \n+    @Test\n+    public void storeSecretsRequest_alreadyNewSecretPresent() throws IOException {\n+\n+        /**\n+         * Note that the output depends, besides the value of the keys, also on both the db key and the soap key.\n+         */\n+        assertThat(this.secretRepository.count()).isEqualTo(2);\n+\n+        final Resource storeRequest = new ClassPathResource(\"test-requests/storeSecrets.xml\");\n+        final Resource expectedStoreResponse = new ClassPathResource(\"test-responses/storeSecrets.xml\");\n+        //Store secrets\n+        this.mockWebServiceClient.sendRequest(withPayload(storeRequest)).andExpect(ResponseMatchers.noFault())\n+                                 .andExpect(ResponseMatchers.payload(expectedStoreResponse));\n+        //Store secrets again, while previously stored secret still have status NEW\n+        final String errorMessage = \"Expected 0 new secrets of type E_METER_AUTHENTICATION_KEY for device E0000000000000000, but 1 new secret(s) present\";\n+        this.mockWebServiceClient.sendRequest(withPayload(storeRequest))\n+                                 .andExpect(ResponseMatchers.serverOrReceiverFault(errorMessage));\n+    }\n+\n+    @Test\n+    public void activateSecretsRequest() throws IOException {\n+\n+        /**\n+         * Note that the output depends, besides the value of the keys, also on both the db key and the soap key.\n+         */\n+        assertThat(this.secretRepository.count()).isEqualTo(2);\n+\n+        final Resource storeRequest = new ClassPathResource(\"test-requests/storeSecrets.xml\");\n+        final Resource activateRequest = new ClassPathResource(\"test-requests/activateSecrets.xml\");\n+        final Resource expectedStoreResponse = new ClassPathResource(\"test-responses/storeSecrets.xml\");\n+        final Resource expectedActivateResponse = new ClassPathResource(\"test-responses/activateSecrets.xml\");\n+        //Store secrets\n+        this.mockWebServiceClient.sendRequest(withPayload(storeRequest)).andExpect(ResponseMatchers.noFault())\n+                                 .andExpect(ResponseMatchers.payload(expectedStoreResponse));\n+        this.mockWebServiceClient.sendRequest(withPayload(activateRequest))\n+                                 //.andExpect((request, response) -> response.writeTo(System.out))", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAxNzE5Ng==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527017196", "bodyText": "Annotation and method on the same line is not according to the formatting conventions.", "author": "bvdzwet", "createdAt": "2020-11-19T16:19:56Z", "path": "osgp/platform/osgp-secret-management/src/integration-test/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepositoryIT.java", "diffHunk": "@@ -49,10 +52,20 @@ public void persistTestData() {\n     }\n \n     @Test\n-    public void findIdOfValidMostRecent() {\n+    public void getSecretCount() {\n         assertThat(this.repository.count()).isEqualTo(1);\n-        final Long id = this.repository.findIdOfValidMostRecent(this.dbEncryptedSecret.getDeviceIdentification(),\n-                this.dbEncryptedSecret.getSecretType().name(), new Date());\n-        assertThat(id).isEqualTo(this.dbEncryptedSecret.getId());\n+        final Integer activeCount = this.repository.getSecretCount(this.dbEncryptedSecret.getDeviceIdentification(),\n+                this.dbEncryptedSecret.getSecretType(), SecretStatus.ACTIVE);\n+        assertThat(activeCount).isEqualTo(1);\n     }\n+\n+    @Test void findSecrets() {", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyNzEzNw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527027137", "bodyText": "I see this a number of times, and think it looks odd.\nWhat you would expect in a unit test is that you set up an initial state, then act on the subject under test and then perform assertions.\nAsserting on the initial setup should not be necessary, as it is entirely under control, and not something that needs to be tested.\nAny reason it needs the repeated verification I might be missing?", "author": "bvdzwet", "createdAt": "2020-11-19T16:33:12Z", "path": "osgp/platform/osgp-secret-management/src/integration-test/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepositoryIT.java", "diffHunk": "@@ -49,10 +52,20 @@ public void persistTestData() {\n     }\n \n     @Test\n-    public void findIdOfValidMostRecent() {\n+    public void getSecretCount() {\n         assertThat(this.repository.count()).isEqualTo(1);\n-        final Long id = this.repository.findIdOfValidMostRecent(this.dbEncryptedSecret.getDeviceIdentification(),\n-                this.dbEncryptedSecret.getSecretType().name(), new Date());\n-        assertThat(id).isEqualTo(this.dbEncryptedSecret.getId());\n+        final Integer activeCount = this.repository.getSecretCount(this.dbEncryptedSecret.getDeviceIdentification(),\n+                this.dbEncryptedSecret.getSecretType(), SecretStatus.ACTIVE);\n+        assertThat(activeCount).isEqualTo(1);\n     }\n+\n+    @Test void findSecrets() {\n+        assertThat(this.repository.count()).isEqualTo(1);", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQyNzE2MA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r530427160", "bodyText": "I did this to ensure proper behaviour of all tests. If someone adds a test-method and changes the @BeforeEach-method, he can break tests by e.g. adding an extra record. This assertion makes sure that this is determined when it happens. Might be a bit overkill, but that was the idea behind it.", "author": "jandik", "createdAt": "2020-11-25T14:46:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyNzEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAzNDQyNQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527034425", "bodyText": "This is not wrong, and you can leave it as is if you like it, but I would usually go for the \"higher level assertions\" (for lack of a better description) where available.\nFor instance assertThat(secretsList).hasSize(1); would do the same, with a bit nicer (in my opinion at least) default failure messages.\nThis is just one example, I have seen others like assertThat(text.contains(\"contents\")).isTrue() where you could use assertThat(text)\".contains(\"contents\").\nI might rephrase that as not using the AbstractIntegerAssert or a BooleanAssert, when you start from an object that has \"its own\" assert, like the ListAssert or the StringAssert, as the latter have a richer API and clearer default messages (including, I thought a nicer way to deal with null values should they ever occur).", "author": "bvdzwet", "createdAt": "2020-11-19T16:42:50Z", "path": "osgp/platform/osgp-secret-management/src/integration-test/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepositoryIT.java", "diffHunk": "@@ -49,10 +52,20 @@ public void persistTestData() {\n     }\n \n     @Test\n-    public void findIdOfValidMostRecent() {\n+    public void getSecretCount() {\n         assertThat(this.repository.count()).isEqualTo(1);\n-        final Long id = this.repository.findIdOfValidMostRecent(this.dbEncryptedSecret.getDeviceIdentification(),\n-                this.dbEncryptedSecret.getSecretType().name(), new Date());\n-        assertThat(id).isEqualTo(this.dbEncryptedSecret.getId());\n+        final Integer activeCount = this.repository.getSecretCount(this.dbEncryptedSecret.getDeviceIdentification(),\n+                this.dbEncryptedSecret.getSecretType(), SecretStatus.ACTIVE);\n+        assertThat(activeCount).isEqualTo(1);\n     }\n+\n+    @Test void findSecrets() {\n+        assertThat(this.repository.count()).isEqualTo(1);\n+        final List<DbEncryptedSecret> secretsList =\n+                this.repository.findSecrets(this.dbEncryptedSecret.getDeviceIdentification(),\n+                this.dbEncryptedSecret.getSecretType(), SecretStatus.ACTIVE);\n+        assertThat(secretsList.size()).isEqualTo(1);", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQyNzc1Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r530427752", "bodyText": "Agreed.", "author": "jandik", "createdAt": "2020-11-25T14:47:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAzNDQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAzOTg3Mw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527039873", "bodyText": "I see this has been done earlier, but I don't think we ever used underscores in test method names in the GXF code base, making it look inconsistent if it is adopted in some classes.", "author": "bvdzwet", "createdAt": "2020-11-19T16:49:48Z", "path": "osgp/platform/osgp-secret-management/src/integration-test/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptionKeyRepositoryIT.java", "diffHunk": "@@ -54,10 +53,10 @@ public void persistTestData() {\n \n     @Test\n     public void find_noValidTo() {", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQyOTYwNQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r530429605", "bodyText": "I think I've seen it done by more members of team Houston, with the idea to clearly point out what you're testing: 'methodName_testCaseName'\nI find this convention quite convenient, but if you insist on consistency I can change it.", "author": "jandik", "createdAt": "2020-11-25T14:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAzOTg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA1MTE1Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527051152", "bodyText": "This source file is missing a required license header.", "author": "bvdzwet", "createdAt": "2020-11-19T17:04:23Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/SecretStatus.java", "diffHunk": "@@ -0,0 +1,5 @@\n+package org.opensmartgridplatform.secretmanagement.application.domain;", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA1ODQzNA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527058434", "bodyText": "I am not entirely sure what is needed here and how far you would go to keep this safe, but given there are only getters it looks like the intention is that the internals are not to be modified.\nDid you consider cloning/copying the secret (setting it in the constructor, and returning it from the getter) and requiring secretType to be non-null?\n(Even if not needed immediately in the long run you may run into cases where you had made your utility data types unmodifiable.)", "author": "bvdzwet", "createdAt": "2020-11-19T17:14:05Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java", "diffHunk": "@@ -8,29 +8,20 @@\n  */\n package org.opensmartgridplatform.secretmanagement.application.domain;\n \n+import lombok.Getter;\n+\n /**\n  * TypedSecret stores a secret (not necessarily an encrypted secret), along with it's type.\n  */\n+@Getter\n public class TypedSecret {\n-    private SecretType secretType;\n-    private String secret;\n-\n-    public String getSecret() {\n-        return this.secret;\n-    }\n-\n-    public SecretType getSecretType() {\n-        return this.secretType;\n-    }\n+    private final SecretType secretType;\n+    private final byte[] secret;\n \n-    public void setSecret(final String secret) {\n+    public TypedSecret(final byte[] secret, final SecretType secretType) {", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA2MjE1MA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527062150", "bodyText": "You could argue about how nice it looked before, but splitting a string in two like this, when on a single line, looks even worse to me.", "author": "bvdzwet", "createdAt": "2020-11-19T17:19:21Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java", "diffHunk": "@@ -37,86 +45,158 @@\n @Slf4j\n public class SecretManagementEndpoint {\n \n-    private static final String NAMESPACE_URI = \"http://www.opensmartgridplatform\"\n-            + \".org/schemas/security/secretmanagement\";\n+    private static final String NAMESPACE_URI =\n+            \"http://www.opensmartgridplatform\" + \".org/schemas/security/secretmanagement\";", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQzNDQ2OQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r530434469", "bodyText": "Agreed, damn auto-formatting screwing up String literals.", "author": "jandik", "createdAt": "2020-11-25T14:56:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA2MjE1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU4ODExNw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527588117", "bodyText": "I was a bit surprised to see this, and I see it apparently gets checked from a test with an invalid request.\nMy surprise comes from the expectation that all our web services are configured with a PayloadValidatingInterceptor.\nI then looked at the WebServiceConfig for osgp-secret-management and I see it is set up differently in a number of ways then the earlier web services that are part of the GXF code base,\nTo keep maintenance across the GXF code base, and in different deployment scenarios simpler I would expect a more similar set up as with the earlier existing web services.", "author": "bvdzwet", "createdAt": "2020-11-20T10:13:04Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java", "diffHunk": "@@ -37,86 +45,158 @@\n @Slf4j\n public class SecretManagementEndpoint {\n \n-    private static final String NAMESPACE_URI = \"http://www.opensmartgridplatform\"\n-            + \".org/schemas/security/secretmanagement\";\n+    private static final String NAMESPACE_URI =\n+            \"http://www.opensmartgridplatform\" + \".org/schemas/security/secretmanagement\";\n+    private static final String STR_MISSING_SECRET_TYPES = \"Missing input: secret types\";\n+    private static final String STR_MISSING_TYPED_SECRETS = \"Missing input: typed secrets\";\n \n     private final SecretManagementService secretManagementService;\n     private final SoapEndpointDataTypeConverter converter;\n \n-    public SecretManagementEndpoint(SecretManagementService secretManagementService,\n-                                    SoapEndpointDataTypeConverter converter) {\n+    public SecretManagementEndpoint(final SecretManagementService secretManagementService,\n+            final SoapEndpointDataTypeConverter converter) {\n         this.secretManagementService = secretManagementService;\n         this.converter = converter;\n     }\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n     @ResponsePayload\n-    public GetSecretsResponse getSecretsRequest(@RequestPayload GetSecretsRequest request) throws OsgpException {\n-\n+    public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request) throws OsgpException {\n         log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-\n         if (log.isDebugEnabled()) {\n-            log.debug(getSecretsRequestToString(request));\n+            log.debug(this.requestToString(request));\n         }\n-\n-        GetSecretsResponse response = new GetSecretsResponse();\n-\n-        SecretTypes soapSecretTypes = request.getSecretTypes();\n-\n+        final GetSecretsResponse response = new GetSecretsResponse();\n+        final SecretTypes soapSecretTypes = request.getSecretTypes();\n         if (soapSecretTypes == null) {\n-            throw new TechnicalException(\"Missing input: secret types\");\n+            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n         }\n-\n-        List<SecretType> secretTypeList = converter.convertToSecretTypes(soapSecretTypes);\n-        List<TypedSecret> typedSecrets = secretManagementService.retrieveSecrets(request.getDeviceId(),\n+        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveSecrets(request.getDeviceId(),\n                 secretTypeList);\n-\n-        TypedSecrets soapTypedSecrets = converter.convertToSoapTypedSecrets(typedSecrets);\n-\n+        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n         response.setTypedSecrets(soapTypedSecrets);\n         response.setResult(OsgpResultType.OK);\n-\n         log.trace(response.toString());\n+        return response;\n+    }\n \n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getNewSecretsRequest\")\n+    @ResponsePayload\n+    public GetNewSecretsResponse getNewSecretsRequest(@RequestPayload final GetNewSecretsRequest request) throws OsgpException {\n+        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+        if (log.isDebugEnabled()) {\n+            log.debug(this.requestToString(request));\n+        }\n+        final GetNewSecretsResponse response = new GetNewSecretsResponse();\n+        final SecretTypes soapSecretTypes = request.getSecretTypes();\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(STR_MISSING_SECRET_TYPES);", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQzNjA3NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r530436074", "bodyText": "I did not change this, it was already set up in this way. Anyhow, makes sense to do this according to the other services. Not sure if I can do this within this story. If not, I'll create a Jira issue for it.", "author": "jandik", "createdAt": "2020-11-25T14:58:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU4ODExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYwMDQyMA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527600420", "bodyText": "According to our logging guidelines debug would be the lowest level.\nWith regards to logging SOAP messages, I believe before the SecretManagementEndpoint we pretty consistently would be able to switch this on or off by configuration (using boolean property soap.message.logging.enabled and/or soap.message.printing.enabled) used with the WebServiceMonitorInterceptor.", "author": "bvdzwet", "createdAt": "2020-11-20T10:34:15Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java", "diffHunk": "@@ -37,86 +45,158 @@\n @Slf4j\n public class SecretManagementEndpoint {\n \n-    private static final String NAMESPACE_URI = \"http://www.opensmartgridplatform\"\n-            + \".org/schemas/security/secretmanagement\";\n+    private static final String NAMESPACE_URI =\n+            \"http://www.opensmartgridplatform\" + \".org/schemas/security/secretmanagement\";\n+    private static final String STR_MISSING_SECRET_TYPES = \"Missing input: secret types\";\n+    private static final String STR_MISSING_TYPED_SECRETS = \"Missing input: typed secrets\";\n \n     private final SecretManagementService secretManagementService;\n     private final SoapEndpointDataTypeConverter converter;\n \n-    public SecretManagementEndpoint(SecretManagementService secretManagementService,\n-                                    SoapEndpointDataTypeConverter converter) {\n+    public SecretManagementEndpoint(final SecretManagementService secretManagementService,\n+            final SoapEndpointDataTypeConverter converter) {\n         this.secretManagementService = secretManagementService;\n         this.converter = converter;\n     }\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n     @ResponsePayload\n-    public GetSecretsResponse getSecretsRequest(@RequestPayload GetSecretsRequest request) throws OsgpException {\n-\n+    public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request) throws OsgpException {\n         log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-\n         if (log.isDebugEnabled()) {\n-            log.debug(getSecretsRequestToString(request));\n+            log.debug(this.requestToString(request));\n         }\n-\n-        GetSecretsResponse response = new GetSecretsResponse();\n-\n-        SecretTypes soapSecretTypes = request.getSecretTypes();\n-\n+        final GetSecretsResponse response = new GetSecretsResponse();\n+        final SecretTypes soapSecretTypes = request.getSecretTypes();\n         if (soapSecretTypes == null) {\n-            throw new TechnicalException(\"Missing input: secret types\");\n+            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n         }\n-\n-        List<SecretType> secretTypeList = converter.convertToSecretTypes(soapSecretTypes);\n-        List<TypedSecret> typedSecrets = secretManagementService.retrieveSecrets(request.getDeviceId(),\n+        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveSecrets(request.getDeviceId(),\n                 secretTypeList);\n-\n-        TypedSecrets soapTypedSecrets = converter.convertToSoapTypedSecrets(typedSecrets);\n-\n+        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n         response.setTypedSecrets(soapTypedSecrets);\n         response.setResult(OsgpResultType.OK);\n-\n         log.trace(response.toString());\n+        return response;\n+    }\n \n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getNewSecretsRequest\")\n+    @ResponsePayload\n+    public GetNewSecretsResponse getNewSecretsRequest(@RequestPayload final GetNewSecretsRequest request) throws OsgpException {\n+        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+        if (log.isDebugEnabled()) {\n+            log.debug(this.requestToString(request));\n+        }\n+        final GetNewSecretsResponse response = new GetNewSecretsResponse();\n+        final SecretTypes soapSecretTypes = request.getSecretTypes();\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n+        }\n+        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveNewSecrets(request.getDeviceId(),\n+                secretTypeList);\n+        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n+        response.setTypedSecrets(soapTypedSecrets);\n+        response.setResult(OsgpResultType.OK);\n+        log.trace(response.toString());", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYwODMxMg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527608312", "bodyText": "Beside my earlier comment that we would normally log requests and responses by use of a configurable interceptor (in which case this requestToString is not needed), I think the error message can be misleading for exceptions with any other request than the GetSecretsRequest (and there are some in this class).", "author": "bvdzwet", "createdAt": "2020-11-20T10:47:34Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java", "diffHunk": "@@ -37,86 +45,158 @@\n @Slf4j\n public class SecretManagementEndpoint {\n \n-    private static final String NAMESPACE_URI = \"http://www.opensmartgridplatform\"\n-            + \".org/schemas/security/secretmanagement\";\n+    private static final String NAMESPACE_URI =\n+            \"http://www.opensmartgridplatform\" + \".org/schemas/security/secretmanagement\";\n+    private static final String STR_MISSING_SECRET_TYPES = \"Missing input: secret types\";\n+    private static final String STR_MISSING_TYPED_SECRETS = \"Missing input: typed secrets\";\n \n     private final SecretManagementService secretManagementService;\n     private final SoapEndpointDataTypeConverter converter;\n \n-    public SecretManagementEndpoint(SecretManagementService secretManagementService,\n-                                    SoapEndpointDataTypeConverter converter) {\n+    public SecretManagementEndpoint(final SecretManagementService secretManagementService,\n+            final SoapEndpointDataTypeConverter converter) {\n         this.secretManagementService = secretManagementService;\n         this.converter = converter;\n     }\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n     @ResponsePayload\n-    public GetSecretsResponse getSecretsRequest(@RequestPayload GetSecretsRequest request) throws OsgpException {\n-\n+    public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request) throws OsgpException {\n         log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-\n         if (log.isDebugEnabled()) {\n-            log.debug(getSecretsRequestToString(request));\n+            log.debug(this.requestToString(request));\n         }\n-\n-        GetSecretsResponse response = new GetSecretsResponse();\n-\n-        SecretTypes soapSecretTypes = request.getSecretTypes();\n-\n+        final GetSecretsResponse response = new GetSecretsResponse();\n+        final SecretTypes soapSecretTypes = request.getSecretTypes();\n         if (soapSecretTypes == null) {\n-            throw new TechnicalException(\"Missing input: secret types\");\n+            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n         }\n-\n-        List<SecretType> secretTypeList = converter.convertToSecretTypes(soapSecretTypes);\n-        List<TypedSecret> typedSecrets = secretManagementService.retrieveSecrets(request.getDeviceId(),\n+        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveSecrets(request.getDeviceId(),\n                 secretTypeList);\n-\n-        TypedSecrets soapTypedSecrets = converter.convertToSoapTypedSecrets(typedSecrets);\n-\n+        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n         response.setTypedSecrets(soapTypedSecrets);\n         response.setResult(OsgpResultType.OK);\n-\n         log.trace(response.toString());\n+        return response;\n+    }\n \n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getNewSecretsRequest\")\n+    @ResponsePayload\n+    public GetNewSecretsResponse getNewSecretsRequest(@RequestPayload final GetNewSecretsRequest request) throws OsgpException {\n+        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+        if (log.isDebugEnabled()) {\n+            log.debug(this.requestToString(request));\n+        }\n+        final GetNewSecretsResponse response = new GetNewSecretsResponse();\n+        final SecretTypes soapSecretTypes = request.getSecretTypes();\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n+        }\n+        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveNewSecrets(request.getDeviceId(),\n+                secretTypeList);\n+        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n+        response.setTypedSecrets(soapTypedSecrets);\n+        response.setResult(OsgpResultType.OK);\n+        log.trace(response.toString());\n         return response;\n     }\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n     @ResponsePayload\n-    public StoreSecretsResponse storeSecretsRequest(@RequestPayload StoreSecretsRequest request) throws OsgpException {\n-\n+    public StoreSecretsResponse storeSecretsRequest(@RequestPayload final StoreSecretsRequest request)\n+            throws OsgpException {\n         log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n-        log.trace(request.toString());\n-\n-        StoreSecretsResponse response = new StoreSecretsResponse();\n-\n-        TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n-\n+        if (log.isDebugEnabled()) {\n+            log.debug(this.requestToString(request));\n+        }\n+        final StoreSecretsResponse response = new StoreSecretsResponse();\n+        final TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n         if (soapTypedSecrets == null) {\n-            throw new TechnicalException(\"Missing input: typed secrets\");\n+            throw new TechnicalException(STR_MISSING_TYPED_SECRETS);\n         }\n-\n-        List<TypedSecret> typedSecretList = converter.convertToTypedSecrets(request.getTypedSecrets());\n-\n-        secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n-\n+        final List<TypedSecret> typedSecretList = this.converter.convertToTypedSecrets(soapTypedSecrets);\n+        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n         response.setResult(OsgpResultType.OK);\n-\n         log.trace(response.toString());\n+        return response;\n+    }\n \n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"generateAndStoreSecretsRequest\")\n+    @ResponsePayload\n+    public GenerateAndStoreSecretsResponse generateAndStoreSecretsRequest(\n+            @RequestPayload final GenerateAndStoreSecretsRequest request) throws OsgpException {\n+        log.info(\"Handling incoming SOAP request 'generateAndStoreSecretsRequest' for device {}\",\n+                request.getDeviceId());\n+        if (log.isDebugEnabled()) {\n+            log.debug(this.requestToString(request));\n+        }\n+        final GenerateAndStoreSecretsResponse response = new GenerateAndStoreSecretsResponse();\n+        final SecretTypes soapSecretTypes = request.getSecretTypes();\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n+        }\n+        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+        List<TypedSecret> typedSecretList = this.secretManagementService.generateAndStoreSecrets(request.getDeviceId(),\n+                secretTypeList);\n+        response.setResult(OsgpResultType.OK);\n+        response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n+        log.trace(response.toString());\n         return response;\n     }\n \n-    private String getSecretsRequestToString(GetSecretsRequest request) {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    private <T> String requestToString(final T request) {\n+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         try {\n-            JAXBContext ctx = JAXBContext.newInstance(GetSecretsRequest.class);\n-            Marshaller marshaller = ctx.createMarshaller();\n+            final JAXBContext ctx = JAXBContext.newInstance(request.getClass());\n+            final Marshaller marshaller = ctx.createMarshaller();\n             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n             marshaller.marshal(request, baos);\n-        } catch (JAXBException e) {\n+        } catch (final JAXBException e) {\n             log.error(\"Could not serialize GetSecretsRequest\", e);", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYxNDU1NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527614554", "bodyText": "This class is missing a required license header.", "author": "bvdzwet", "createdAt": "2020-11-20T10:59:26Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/ExceptionWrapper.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package org.opensmartgridplatform.secretmanagement.application.exception;", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYxNzg2Nw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527617867", "bodyText": "I might be confused, but would a return be appropriate after this call to customizeFault with the wrapped exception?", "author": "bvdzwet", "createdAt": "2020-11-20T11:05:23Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java", "diffHunk": "@@ -10,22 +10,31 @@\n \n import javax.xml.namespace.QName;\n \n+import lombok.extern.slf4j.Slf4j;\n import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n import org.springframework.ws.soap.SoapFault;\n import org.springframework.ws.soap.SoapFaultDetail;\n import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n \n+@Slf4j\n public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExceptionResolver {\n \n     private static final QName MESSAGE = new QName(\"Message\");\n     private static final QName COMPONENT = new QName(\"Component\");\n \n     @Override\n     protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n+        log.error(\"Exception occured during SOAP request processing\", ex);\n         SoapFaultDetail detail = fault.addFaultDetail();\n-\n+        if(ex instanceof ExceptionWrapper) {\n+            this.customizeFault(endpoint, (Exception) ex.getCause(), fault);", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg1NjI2MQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r530856261", "bodyText": "Agreed", "author": "jandik", "createdAt": "2020-11-26T08:38:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYxNzg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY2NDczMg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527664732", "bodyText": "This functional exception type looks fitting for the current SecretType values that all seem related to DLMS, and the current use of the SecretManagementService in the smart metering domain,\nI did however think this service is intended to be used not only for smart metering in the future. It isn't \"positioned\" in the code base as something DLMS specific anyway.\nMaybe a more neutral INVALID_KEY_FORMAT, or a specification of FunctionalException in a type that includes for instance the SecretType is better suited.", "author": "bvdzwet", "createdAt": "2020-11-20T12:39:25Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java", "diffHunk": "@@ -18,146 +23,318 @@\n import org.apache.tomcat.util.buf.HexUtils;\n import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretStatus;\n import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.exception.ExceptionWrapper;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.exceptionhandling.ComponentType;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalExceptionType;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n import org.springframework.beans.factory.annotation.Qualifier;\n-import org.springframework.data.domain.Page;\n-import org.springframework.data.domain.Pageable;\n import org.springframework.stereotype.Service;\n \n+/**\n+ * Service that manages secrets (store, retrieve, activate, generate).\n+ * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n+ * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n+ * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n+ * database corruption as a result of partially succeeded batch results.\n+ *\n+ * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n+ * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n+ * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n+ * by reencrypting the AES-encrypted secrets to RSA.\n+ */\n @Service\n public class SecretManagementService {\n+    //Internal datastructure to keep track of (intermediate) secret details\n+    private static class EncryptedTypedSecret {\n+        byte[] encryptedSecret;\n+        SecretType type;\n+        String encryptionKeyReference;  //NULL when RSA\n+        EncryptionProviderType encryptionProviderType;  //NULL when RSA\n+\n+        private EncryptedTypedSecret(SecretType type) {\n+            this.type = type;\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type) {\n+            this(secret, type, null, null);\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type, String encryptionKeyReference,\n+                EncryptionProviderType encryptionProviderType) {\n+            if (secret == null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+            } else if (type == null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+            }\n+            this.encryptedSecret = secret;\n+            this.type = type;\n+            this.encryptionKeyReference = encryptionKeyReference;\n+            this.encryptionProviderType = encryptionProviderType;\n+        }\n+\n+        private boolean hasNullSecret() {\n+            return this.encryptedSecret == null;\n+        }\n+\n+        private TypedSecret toTypedSecret() {\n+            return new TypedSecret(this.encryptedSecret, this.type);\n+        }\n+\n+        private static EncryptedTypedSecret getNullInstance(SecretType type) {\n+            return new EncryptedTypedSecret(type);\n+        }\n+\n+        private static EncryptedTypedSecret fromDbEncryptedSecret(DbEncryptedSecret dbEncryptedSecret)\n+                throws FunctionalException {\n+            byte[] aesEncrypted;\n+            try {\n+                aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            } catch (IllegalArgumentException iae) {\n+                throw new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg1NzYwNQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r530857605", "bodyText": "Agreed", "author": "jandik", "createdAt": "2020-11-26T08:41:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY2NDczMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY3Mjk3NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527672974", "bodyText": "This log message looks fine, but I noticed that the encryptionProviderType is included in the exception message for when keyRefs is empty, but not when there are multiple keyRefs.", "author": "bvdzwet", "createdAt": "2020-11-20T12:56:01Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java", "diffHunk": "@@ -18,146 +23,318 @@\n import org.apache.tomcat.util.buf.HexUtils;\n import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretStatus;\n import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.exception.ExceptionWrapper;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.exceptionhandling.ComponentType;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalExceptionType;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n import org.springframework.beans.factory.annotation.Qualifier;\n-import org.springframework.data.domain.Page;\n-import org.springframework.data.domain.Pageable;\n import org.springframework.stereotype.Service;\n \n+/**\n+ * Service that manages secrets (store, retrieve, activate, generate).\n+ * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n+ * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n+ * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n+ * database corruption as a result of partially succeeded batch results.\n+ *\n+ * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n+ * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n+ * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n+ * by reencrypting the AES-encrypted secrets to RSA.\n+ */\n @Service\n public class SecretManagementService {\n+    //Internal datastructure to keep track of (intermediate) secret details\n+    private static class EncryptedTypedSecret {\n+        byte[] encryptedSecret;\n+        SecretType type;\n+        String encryptionKeyReference;  //NULL when RSA\n+        EncryptionProviderType encryptionProviderType;  //NULL when RSA\n+\n+        private EncryptedTypedSecret(SecretType type) {\n+            this.type = type;\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type) {\n+            this(secret, type, null, null);\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type, String encryptionKeyReference,\n+                EncryptionProviderType encryptionProviderType) {\n+            if (secret == null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+            } else if (type == null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+            }\n+            this.encryptedSecret = secret;\n+            this.type = type;\n+            this.encryptionKeyReference = encryptionKeyReference;\n+            this.encryptionProviderType = encryptionProviderType;\n+        }\n+\n+        private boolean hasNullSecret() {\n+            return this.encryptedSecret == null;\n+        }\n+\n+        private TypedSecret toTypedSecret() {\n+            return new TypedSecret(this.encryptedSecret, this.type);\n+        }\n+\n+        private static EncryptedTypedSecret getNullInstance(SecretType type) {\n+            return new EncryptedTypedSecret(type);\n+        }\n+\n+        private static EncryptedTypedSecret fromDbEncryptedSecret(DbEncryptedSecret dbEncryptedSecret)\n+                throws FunctionalException {\n+            byte[] aesEncrypted;\n+            try {\n+                aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            } catch (IllegalArgumentException iae) {\n+                throw new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+                        ComponentType.SECRET_MANAGEMENT, iae);\n+            }\n+            String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+            EncryptionProviderType providerType = dbEncryptedSecret.getEncryptionKeyReference()\n+                                                                   .getEncryptionProviderType();\n+            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference,\n+                    providerType);\n+        }\n+    }\n+\n     private final EncryptionDelegate encryptionDelegate;\n     private final EncryptionProviderType encryptionProviderType;\n     private final DbEncryptedSecretRepository secretRepository;\n     private final DbEncryptionKeyRepository keyRepository;\n+    private final RsaEncrypter rsaEncrypter;\n \n     public SecretManagementService(\n             @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n             final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository) {\n+            final DbEncryptionKeyRepository keyRepository, RsaEncrypter rsaEncrypter) {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n         this.encryptionProviderType = encryptionProviderType;\n         this.secretRepository = secretRepository;\n         this.keyRepository = keyRepository;\n+        this.rsaEncrypter = rsaEncrypter;\n     }\n \n-    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        //@formatter:off\n-        secrets.stream()\n-                .map(t -> this.validateSecret(deviceIdentification, t))\n-                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n-                .forEach(this.secretRepository::save);\n-        //@formatter:on\n-    }\n-\n-    private DbEncryptionKeyReference getKey() {\n+    private DbEncryptionKeyReference getCurrentKey() {\n         final Date now = new Date();\n-        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(now,\n-                this.encryptionProviderType, Pageable.unpaged());\n-        if (keyRefsPage.getSize() > 1) {\n+        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n+                .findByTypeAndValid(this.encryptionProviderType, now);\n+        if (keyRefs.size() > 1) {\n             throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        } else if (keyRefs.isEmpty()) {\n+            throw new NoSuchElementException(\n+                    \"No encryption key of type \" + this.encryptionProviderType + \" found that is valid at \" + now);", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg2Mzg5MQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r530863891", "bodyText": "Agreed", "author": "jandik", "createdAt": "2020-11-26T08:51:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY3Mjk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcxMzEyOA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527713128", "bodyText": "I have seen this use of Optional a number of times, and I think it is really not a nice way to use Optional.\nThe combination of isPresent and get works with respect to safe-guarding in that you won't run into the exception get would throw if the optional is empty.\nI personally don't mind seeing null appear in the code (especially if it is kept internal in some method).\nI think I would go with:\nfinal DbEncryptedSecret currentSecret = this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE).orElse(null);\nThen replace the isPresent by  != null, and avoid having both an Optional<Something> and a Something as variables.\nI am aware this may be considered opinionated, so you can use your own judgement and leave it as is, if you are not convinced.", "author": "bvdzwet", "createdAt": "2020-11-20T14:07:44Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java", "diffHunk": "@@ -18,146 +23,318 @@\n import org.apache.tomcat.util.buf.HexUtils;\n import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretStatus;\n import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.exception.ExceptionWrapper;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.exceptionhandling.ComponentType;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalExceptionType;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n import org.springframework.beans.factory.annotation.Qualifier;\n-import org.springframework.data.domain.Page;\n-import org.springframework.data.domain.Pageable;\n import org.springframework.stereotype.Service;\n \n+/**\n+ * Service that manages secrets (store, retrieve, activate, generate).\n+ * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n+ * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n+ * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n+ * database corruption as a result of partially succeeded batch results.\n+ *\n+ * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n+ * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n+ * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n+ * by reencrypting the AES-encrypted secrets to RSA.\n+ */\n @Service\n public class SecretManagementService {\n+    //Internal datastructure to keep track of (intermediate) secret details\n+    private static class EncryptedTypedSecret {\n+        byte[] encryptedSecret;\n+        SecretType type;\n+        String encryptionKeyReference;  //NULL when RSA\n+        EncryptionProviderType encryptionProviderType;  //NULL when RSA\n+\n+        private EncryptedTypedSecret(SecretType type) {\n+            this.type = type;\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type) {\n+            this(secret, type, null, null);\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type, String encryptionKeyReference,\n+                EncryptionProviderType encryptionProviderType) {\n+            if (secret == null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+            } else if (type == null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+            }\n+            this.encryptedSecret = secret;\n+            this.type = type;\n+            this.encryptionKeyReference = encryptionKeyReference;\n+            this.encryptionProviderType = encryptionProviderType;\n+        }\n+\n+        private boolean hasNullSecret() {\n+            return this.encryptedSecret == null;\n+        }\n+\n+        private TypedSecret toTypedSecret() {\n+            return new TypedSecret(this.encryptedSecret, this.type);\n+        }\n+\n+        private static EncryptedTypedSecret getNullInstance(SecretType type) {\n+            return new EncryptedTypedSecret(type);\n+        }\n+\n+        private static EncryptedTypedSecret fromDbEncryptedSecret(DbEncryptedSecret dbEncryptedSecret)\n+                throws FunctionalException {\n+            byte[] aesEncrypted;\n+            try {\n+                aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            } catch (IllegalArgumentException iae) {\n+                throw new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+                        ComponentType.SECRET_MANAGEMENT, iae);\n+            }\n+            String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+            EncryptionProviderType providerType = dbEncryptedSecret.getEncryptionKeyReference()\n+                                                                   .getEncryptionProviderType();\n+            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference,\n+                    providerType);\n+        }\n+    }\n+\n     private final EncryptionDelegate encryptionDelegate;\n     private final EncryptionProviderType encryptionProviderType;\n     private final DbEncryptedSecretRepository secretRepository;\n     private final DbEncryptionKeyRepository keyRepository;\n+    private final RsaEncrypter rsaEncrypter;\n \n     public SecretManagementService(\n             @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n             final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository) {\n+            final DbEncryptionKeyRepository keyRepository, RsaEncrypter rsaEncrypter) {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n         this.encryptionProviderType = encryptionProviderType;\n         this.secretRepository = secretRepository;\n         this.keyRepository = keyRepository;\n+        this.rsaEncrypter = rsaEncrypter;\n     }\n \n-    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        //@formatter:off\n-        secrets.stream()\n-                .map(t -> this.validateSecret(deviceIdentification, t))\n-                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n-                .forEach(this.secretRepository::save);\n-        //@formatter:on\n-    }\n-\n-    private DbEncryptionKeyReference getKey() {\n+    private DbEncryptionKeyReference getCurrentKey() {\n         final Date now = new Date();\n-        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(now,\n-                this.encryptionProviderType, Pageable.unpaged());\n-        if (keyRefsPage.getSize() > 1) {\n+        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n+                .findByTypeAndValid(this.encryptionProviderType, now);\n+        if (keyRefs.size() > 1) {\n             throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        } else if (keyRefs.isEmpty()) {\n+            throw new NoSuchElementException(\n+                    \"No encryption key of type \" + this.encryptionProviderType + \" found that is valid at \" + now);\n         }\n-        return keyRefsPage.stream().findFirst().orElseThrow(\n-                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+        return keyRefs.get(0);\n     }\n \n-    private TypedSecret validateSecret(final String deviceIdentification, final TypedSecret secret) {\n-        if (secret.getSecret() == null) {\n-            throw new IllegalArgumentException(\"No secret string set\");\n-        } else if (secret.getSecretType() == null) {\n-            throw new IllegalArgumentException(\"No secret type set\");\n-        } else if (this.isIdenticalToCurrent(deviceIdentification, secret)) {\n-            throw new IllegalArgumentException(\n-                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n-                            secret.getSecretType().name()));\n+    private DbEncryptionKeyReference getKeyByReference(String reference) {\n+        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n+    }\n+\n+    private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n+        if (secret.hasNullSecret()) {\n+            FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n+            throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n         }\n         return secret;\n     }\n \n-    private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n-        final Optional<TypedSecret> current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n-        return current.isPresent() && current.get().getSecret().equals(secret.getSecret());\n+    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n+            final DbEncryptionKeyReference keyReference) {\n+        final Date now = new Date();\n+        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+        dbEncryptedSecret.setSecretType(secret.type);\n+        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+        dbEncryptedSecret.setCreationTime(now);\n+        return dbEncryptedSecret;\n     }\n \n-    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n-                                              final DbEncryptionKeyReference keyReference) {\n-        final String secretString = typedSecret.getSecret();\n-        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n-        final Secret secret = new Secret(secretBytes);\n-        try {\n-            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n-            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-            dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-            dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n-            dbEncryptedSecret.setSecretType(typedSecret.getSecretType());\n-            dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-            dbEncryptedSecret.setCreationTime(new Date());\n-            return dbEncryptedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not create encrypted secret\", exc);\n-        }\n+    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n     }\n \n-    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+    public List<TypedSecret> retrieveNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+    }\n+\n+    private List<TypedSecret> doRetrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes,\n+            SecretStatus status) {\n+        return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream().map(this::reencryptAes2Rsa)\n+                   .map(EncryptedTypedSecret::toTypedSecret).collect(Collectors.toList());\n+    }\n+\n+    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n+            final List<SecretType> secretTypes, SecretStatus status) {\n         try {\n-            //@formatter:off\n-            return secretTypes.stream()\n-                    .map(secretType -> this.retrieveSecret(deviceIdentification, secretType))\n-                    .map(Optional::get)\n-                    .collect(Collectors.toList());\n-            //@formatter:on\n+            return secretTypes.stream().map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n+                              .collect(Collectors.toList());\n         } catch (final Exception exc) {\n             throw new IllegalStateException(\n-                    String.format(\"Something went wrong retrieving secrets for device %s\", deviceIdentification), exc);\n+                    String.format(\"Something went wrong retrieving secrets for device %s: %s\", deviceIdentification,\n+                            exc.toString()), exc);\n         }\n     }\n \n-    public Optional<TypedSecret> retrieveSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Date now = new Date();\n-        final Long secretId = this.secretRepository.findIdOfValidMostRecent(deviceIdentification, secretType.name(),\n-                now);\n-        if (secretId == null) {\n+    private EncryptedTypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType,\n+            SecretStatus status) {\n+        final Optional<DbEncryptedSecret> optional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n+        if (optional.isPresent()) {\n+            try {\n+                return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n+            } catch (FunctionalException e) {\n+                throw new ExceptionWrapper(e);\n+            }\n+        } else {\n+            return EncryptedTypedSecret.getNullInstance(secretType);\n+        }\n+    }\n+\n+    private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n+            final SecretType secretType, final SecretStatus secretStatus) {\n+        final List<DbEncryptedSecret> secretsList = this.secretRepository\n+                .findSecrets(deviceIdentification, secretType, secretStatus);\n+        boolean onlySingleSecretAllowed =\n+                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n+        if (secretsList.isEmpty()) {\n             return Optional.empty();\n+        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n+            throw new IllegalStateException(\n+                    String.format(msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n         }\n-        final TypedSecret typedSecret = this.getTypedSecret(this.secretRepository.findById(secretId));\n-        return Optional.of(typedSecret);\n+        return Optional.of(secretsList.iterator().next());\n     }\n \n-    private TypedSecret getTypedSecret(final Optional<DbEncryptedSecret> dbEncryptedSecret) {\n-        if (dbEncryptedSecret.isPresent()) {\n-            final DbEncryptedSecret secret = dbEncryptedSecret.get();\n-            final DbEncryptionKeyReference keyReference = secret.getEncryptionKeyReference();\n-            if (keyReference == null) {\n-                throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n-            }\n-            final byte[] secretBytes = HexUtils.fromHexString(secret.getEncodedSecret());\n-            final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n-                    secretBytes);\n-            return this.createTypedSecret(secret, keyReference, encryptedSecret);\n-        } else {    //Should never happen because of stream mapping in retrieveSecrets()\n-            throw new IllegalStateException(\"Could not create typed secret for NULL secret\");\n+    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n+        secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n+        List<EncryptedTypedSecret> aesSecrets = secrets.stream().map(ts -> new EncryptedTypedSecret(ts.getSecret(),\n+                ts.getSecretType())).map(this::reencryptRsa2Aes).collect(toList());\n+        this.storeAesSecrets(deviceIdentification, aesSecrets);\n+    }\n+\n+    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n+        secrets.stream().map(this::validateAndReturnNewSecret).map(ets -> this\n+                .createDbEncrypted(deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n+               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+    }\n+\n+    public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n+        secretTypes.stream().map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+                   .flatMap(Collection::stream).collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+    }\n+\n+    public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n+        return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n+    }\n+\n+    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n+            final SecretType secretType) {\n+        List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+        final Optional<DbEncryptedSecret> activeSecretOptional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+        if (activeSecretOptional.isPresent()) {\n+            final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n+            currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n+            updatedSecrets.add(currentSecret);\n+        }", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg2ODc4Mw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r530868783", "bodyText": "I agree with you in general, but in this case I think it is fine: because the retrieval of the optional and the use of the optional are in the same method, close together, I think is all the same.", "author": "jandik", "createdAt": "2020-11-26T08:59:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcxMzEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcyOTgyNA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527729824", "bodyText": "I think this used to be of type RsaEncryptionProvider. It might be cleaner to also update the name to rsaEncrypter.", "author": "bvdzwet", "createdAt": "2020-11-20T14:30:32Z", "path": "osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java", "diffHunk": "@@ -56,49 +56,63 @@\n     private DbEncryptedSecretRepository secretRepository;\n     @Mock\n     private DbEncryptionKeyRepository keyRepository;\n+    @Mock\n+    private RsaEncrypter rsaEncryptionProvider;", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzczMTMxMQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527731311", "bodyText": "It seems this line is not necessary, leave it out rather than as commented code.\nThere are some more lines and even a complete test in this class, for which the same goes.", "author": "bvdzwet", "createdAt": "2020-11-20T14:32:55Z", "path": "osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java", "diffHunk": "@@ -56,49 +56,63 @@\n     private DbEncryptedSecretRepository secretRepository;\n     @Mock\n     private DbEncryptionKeyRepository keyRepository;\n+    @Mock\n+    private RsaEncrypter rsaEncryptionProvider;\n \n     @BeforeEach\n     public void setHsmEncryption() {\n-        this.service = new SecretManagementService(this.encryptionDelegate, EncryptionProviderType.HSM,\n-                this.secretRepository, this.keyRepository);\n+        this.service = new SecretManagementService(this.encryptionDelegate, ENCRYPTION_PROVIDER_TYPE,\n+                this.secretRepository, this.keyRepository, this.rsaEncryptionProvider);\n     }\n \n     @Test\n     public void retrieveSecrets() throws Exception {\n         //GIVEN\n         final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n+        keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n+        keyReference.setReference(\"1\");\n         final DbEncryptedSecret secret = new DbEncryptedSecret();\n         secret.setSecretType(SecretType.E_METER_MASTER_KEY);\n         secret.setEncryptionKeyReference(keyReference);\n-        final Secret decryptedSecret = new Secret(\"secret\".getBytes());\n+        secret.setEncodedSecret(\"ABCDEF01234567890123456789ABCDEF\");\n+        final List<DbEncryptedSecret> secretList = Arrays.asList(secret);\n+        final byte[] decryptedSecret = \"secret0000000001\".getBytes();\n+        final byte[] rsaSecret = \"1000000000terces\".getBytes();\n \n         //WHEN\n-        when(this.secretRepository.findIdOfValidMostRecent(any(), any(), any())).thenReturn(1L);\n-        when(this.secretRepository.findById(any())).thenReturn(Optional.of(secret));\n+        when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n+                .thenReturn(secretList);\n         when(this.encryptionDelegate.decrypt(any(), any())).thenReturn(decryptedSecret);\n-        final List<TypedSecret> typedSecrets = this.service.retrieveSecrets(SOME_DEVICE,\n-                Arrays.asList(SecretType.E_METER_MASTER_KEY));\n+        when(this.rsaEncryptionProvider.encrypt(any())).thenReturn(rsaSecret);\n+        //when(this.encryptionDelegate.getSecretByteLength(any())).thenReturn(16);", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzczNzM3Ng==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527737376", "bodyText": "This leads to an ugly type safety warning.\nOne way to get rid of that would be to create the argument captor(s) as fields with the @Captor annotation.", "author": "bvdzwet", "createdAt": "2020-11-20T14:42:12Z", "path": "osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java", "diffHunk": "@@ -108,42 +122,50 @@ public void retrieveSecrets_decryptionError() {\n     @Test\n     public void retrieveSecrets_secretWithoutKey() {\n         final DbEncryptedSecret secret = new DbEncryptedSecret();\n-        when(this.secretRepository.findIdOfValidMostRecent(any(), any(), any())).thenReturn(1L);\n-        when(this.secretRepository.findById(1L)).thenReturn(Optional.of(secret));\n+        final List<DbEncryptedSecret> secretList = Arrays.asList(secret);\n+        when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n+                .thenReturn(secretList);\n         assertThatIllegalStateException().isThrownBy(\n                 () -> this.service.retrieveSecrets(\"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY)));\n     }\n \n     @Test\n     public void retrieveSecrets_noSecrets() {\n-        when(this.secretRepository.findIdOfValidMostRecent(any(), any(), any())).thenReturn(null);\n-        assertThatIllegalStateException().isThrownBy(\n-                () -> this.service.retrieveSecrets(\"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY)));\n+        List<SecretType> secretTypes = Arrays.asList(SecretType.E_METER_MASTER_KEY);\n+        List<TypedSecret> result = this.service.retrieveSecrets(\"SOME_DEVICE\", secretTypes);\n+        assertThat(result).isNotNull();\n+        assertThat(result.size()).isEqualTo(secretTypes.size());\n+        assertThat(result.get(0)).isNotNull();\n+        assertThat(result.get(0).getSecretType()).isEqualTo(SecretType.E_METER_MASTER_KEY);\n+        assertThat(result.get(0).getSecret()).isNull();\n     }\n \n     @Test\n     public void storeSecrets() throws Exception {\n         //GIVEN\n-        final TypedSecret typedSecret = new TypedSecret();\n-        typedSecret.setSecretType(SecretType.E_METER_MASTER_KEY);\n-        typedSecret.setSecret(HexUtils.toHexString(\"$3cr3t\".getBytes()));\n+        final TypedSecret typedSecret = new TypedSecret(\"rsaSecret00000001\".getBytes(), SecretType.E_METER_MASTER_KEY);\n         final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n-        keyReference.setEncryptionProviderType(EncryptionProviderType.JRE);\n-        keyReference.setReference(\"keyReferenceString\");\n-        final EncryptedSecret encryptedSecret = new EncryptedSecret(EncryptionProviderType.JRE, \"$3cr3t\".getBytes());\n-        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+        keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n+        keyReference.setReference(\"1\");\n+        final EncryptedSecret encryptedSecret = new EncryptedSecret(ENCRYPTION_PROVIDER_TYPE,\n+                \"aesSecret0000001\".getBytes());\n \n         //WHEN\n-        when(this.secretRepository.findIdOfValidMostRecent(any(), any(), any())).thenReturn(null);\n-        when(this.keyRepository.findByTypeAndValid(any(), any(), any())).thenReturn(\n-                new PageImpl<>(Arrays.asList(keyReference)));\n+        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n+                .thenReturn(0);\n+        when(this.keyRepository.findByTypeAndValid(any(), any())).thenReturn(Arrays.asList(keyReference));\n+        when(this.keyRepository.findByTypeAndReference(ENCRYPTION_PROVIDER_TYPE, \"1\")).thenReturn(keyReference);\n         when(this.encryptionDelegate.encrypt(any(), any(), anyString())).thenReturn(encryptedSecret);\n+        //when(this.encryptionDelegate.getSecretByteLength(any())).thenReturn(16);\n         this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret));\n         //THEN\n-        final ArgumentCaptor<DbEncryptedSecret> secretArgumentCaptor = ArgumentCaptor.forClass(DbEncryptedSecret.class);\n-        verify(this.secretRepository).save(secretArgumentCaptor.capture());\n-        final DbEncryptedSecret savedSecret = secretArgumentCaptor.getValue();\n-        assertThat(savedSecret).isNotNull();\n+        final ArgumentCaptor<List<DbEncryptedSecret>> secretListArgumentCaptor =\n+                ArgumentCaptor.forClass(List.class);", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzczODg4OQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527738889", "bodyText": "It looks like this line can be removed, encryptedSecret is not used.", "author": "bvdzwet", "createdAt": "2020-11-20T14:44:39Z", "path": "osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java", "diffHunk": "@@ -152,19 +174,22 @@ public void storeSecrets() throws Exception {\n     }\n \n     @Test\n-    public void storeSecrets_secretNull() {\n+    public void storeSecrets_newKeyAlreadyStored() throws Exception {\n         //GIVEN\n-        final TypedSecret typedSecret = new TypedSecret();\n-        typedSecret.setSecretType(SecretType.E_METER_MASTER_KEY);\n+        final TypedSecret typedSecret = new TypedSecret(new byte[16], SecretType.E_METER_MASTER_KEY);\n+        final EncryptedSecret encryptedSecret = new EncryptedSecret(ENCRYPTION_PROVIDER_TYPE, \"aesSecret\".getBytes());", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc0MjUxMw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527742513", "bodyText": "Is this necessary? The exception from storeSecrets appears to be checked in assertThatIllegalSteteException below.\nThe empty catch block looks like a red flag. I would otherwise expect some comment the exception is expected and a fail after the method call in the try-block.", "author": "bvdzwet", "createdAt": "2020-11-20T14:50:09Z", "path": "osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java", "diffHunk": "@@ -173,78 +198,67 @@ public void storeSecrets_secretTypeNull() {\n         keyReference.setEncryptionProviderType(EncryptionProviderType.JRE);\n         keyReference.setReference(\"keyReferenceString\");\n         //THEN\n-        assertThatIllegalArgumentException().isThrownBy(\n-                () -> this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret)));\n-    }\n+        assertThatIllegalArgumentException()\n+                .isThrownBy(() -> this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret)));\n+    }*/\n \n     @Test\n     public void storeSecrets_noKey() {\n         //GIVEN\n-        final TypedSecret typedSecret = new TypedSecret();\n-        typedSecret.setSecretType(SecretType.E_METER_MASTER_KEY);\n-        typedSecret.setSecret(HexUtils.toHexString(\"$3cr3t\".getBytes()));\n+        final TypedSecret typedSecret = new TypedSecret(\"$3cr3t\".getBytes(), SecretType.E_METER_MASTER_KEY);\n         //WHEN\n-        when(this.secretRepository.findIdOfValidMostRecent(any(), any(), any())).thenReturn(null);\n-        when(this.keyRepository.findByTypeAndValid(any(), any(), any())).thenReturn(Page.empty());\n+        when(this.keyRepository.findByTypeAndValid(any(), any())).thenReturn(Arrays.asList());\n         //THEN\n-        assertThatExceptionOfType(NoSuchElementException.class).isThrownBy(\n-                () -> this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret)));\n+        assertThatExceptionOfType(NoSuchElementException.class)\n+                .isThrownBy(() -> this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret)));\n \n     }\n \n     @Test\n     public void storeSecrets_multipleKeys() {\n         //GIVEN\n-        final TypedSecret typedSecret = new TypedSecret();\n-        typedSecret.setSecretType(SecretType.E_METER_MASTER_KEY);\n-        typedSecret.setSecret(HexUtils.toHexString(\"$3cr3t\".getBytes()));\n+        final TypedSecret typedSecret = new TypedSecret(\"$3cr3t\".getBytes(), SecretType.E_METER_MASTER_KEY);\n         //WHEN\n-        when(this.secretRepository.findIdOfValidMostRecent(any(), any(), any())).thenReturn(null);\n-        when(this.keyRepository.findByTypeAndValid(any(), any(), any())).thenReturn(\n-                new PageImpl<>(Arrays.asList(new DbEncryptionKeyReference(), new DbEncryptionKeyReference())));\n+        when(this.keyRepository.findByTypeAndValid(any(), any()))\n+                .thenReturn(Arrays.asList(new DbEncryptionKeyReference(), new DbEncryptionKeyReference()));\n         //THEN\n         try {\n             this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret));\n         } catch (final Exception exc) {\n \n         }", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkxMzYzOA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r532913638", "bodyText": "Agreed, try/catch was redundant.", "author": "jandik", "createdAt": "2020-11-30T21:25:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc0MjUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc4NzQzMQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527787431", "bodyText": "It looks like the name still reflects the old type, might be nicer to rename it.", "author": "bvdzwet", "createdAt": "2020-11-20T15:57:05Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java", "diffHunk": "@@ -97,44 +100,46 @@ public HttpsUrlConnectionMessageSender httpsUrlConnectionMessageSender() throws\n     @Bean\n     public KeyStoreFactoryBean trustStore() {\n         KeyStoreFactoryBean keyStoreFactoryBean = new KeyStoreFactoryBean();\n-        keyStoreFactoryBean.setLocation(trustStore);\n-        keyStoreFactoryBean.setPassword(trustStorePassword);\n+        keyStoreFactoryBean.setLocation(this.trustStore);\n+        keyStoreFactoryBean.setPassword(this.trustStorePassword);\n \n         return keyStoreFactoryBean;\n     }\n \n     @Bean\n     public TrustManagersFactoryBean trustManagersFactoryBean() {\n         TrustManagersFactoryBean trustManagersFactoryBean = new TrustManagersFactoryBean();\n-        trustManagersFactoryBean.setKeyStore(trustStore().getObject());\n+        trustManagersFactoryBean.setKeyStore(this.trustStore().getObject());\n \n         return trustManagersFactoryBean;\n     }\n \n     @Bean\n     public KeyStoreFactoryBean keyStore() {\n         KeyStoreFactoryBean keyStoreFactoryBean = new KeyStoreFactoryBean();\n-        keyStoreFactoryBean.setLocation(keyStore);\n-        keyStoreFactoryBean.setPassword(keyStorePassword);\n+        keyStoreFactoryBean.setLocation(this.keyStore);\n+        keyStoreFactoryBean.setPassword(this.keyStorePassword);\n \n         return keyStoreFactoryBean;\n     }\n \n     @Bean\n     public KeyManagersFactoryBean keyManagersFactoryBean() {\n         KeyManagersFactoryBean keyManagersFactoryBean = new KeyManagersFactoryBean();\n-        keyManagersFactoryBean.setKeyStore(keyStore().getObject());\n-        keyManagersFactoryBean.setPassword(keyPassword);\n+        keyManagersFactoryBean.setKeyStore(this.keyStore().getObject());\n+        keyManagersFactoryBean.setPassword(this.keyPassword);\n         return keyManagersFactoryBean;\n     }\n \n     @Bean\n-    public RsaEncryptionProvider rsaEncryptionProvider() {\n+    public RsaEncrypter rsaEncryptionProvider() {", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc5MTMwMw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527791303", "bodyText": "This file is missing a required license header.", "author": "bvdzwet", "createdAt": "2020-11-20T16:03:04Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/EncryptionHelperService.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.services;", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgwNTA0Mw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527805043", "bodyText": "Shouldn't this be if (ArrayUtils.isNotEmpty(deviceDto.getMasterKey())) { keysByType.put(E_METER_MASTER,this.encryptionService.rsaDecrypt(deviceDto.getMasterKey())); }?\nSimilar for the other security key types.\nIt looks like things could go wrong, since I don't think it is safe to assume all these keys are present.", "author": "bvdzwet", "createdAt": "2020-11-20T16:24:05Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java", "diffHunk": "@@ -52,59 +60,19 @@\n     @Autowired\n     private CoupleMbusDeviceByChannelCommandExecutor coupleMbusDeviceByChannelCommandExecutor;\n \n-    // === ADD METER ===\n     public void addMeter(final SmartMeteringDeviceDto smartMeteringDevice) throws FunctionalException {\n-        this.reEncryptKeys(smartMeteringDevice);\n+        this.storeNewKeys(smartMeteringDevice);\n         final DlmsDevice dlmsDevice = this.installationMapper.map(smartMeteringDevice, DlmsDevice.class);\n         this.dlmsDeviceRepository.save(dlmsDevice);\n     }\n \n-    private void reEncryptKeys(final SmartMeteringDeviceDto smartMeteringDevice) throws FunctionalException {\n-        this.reEncryptMasterKey(smartMeteringDevice);\n-        this.reEncryptAuthenticationKey(smartMeteringDevice);\n-        this.reEncryptEncryptionKey(smartMeteringDevice);\n-        this.reEncryptMbusDefaultKey(smartMeteringDevice);\n-    }\n-\n-    private void reEncryptMasterKey(final SmartMeteringDeviceDto smartMeteringDevice) throws FunctionalException {\n-        if (ArrayUtils.isEmpty(smartMeteringDevice.getMasterKey())) {\n-            return;\n-        }\n-        final byte[] reEncryptedMasterKey = this.securityKeyService\n-                .reEncryptKey(smartMeteringDevice.getMasterKey(), SecurityKeyType.E_METER_MASTER);\n-        smartMeteringDevice.setMasterKey(reEncryptedMasterKey);\n-    }\n-\n-    private void reEncryptAuthenticationKey(final SmartMeteringDeviceDto smartMeteringDevice)\n-            throws FunctionalException {\n-\n-        if (ArrayUtils.isEmpty(smartMeteringDevice.getAuthenticationKey())) {\n-            return;\n-        }\n-        final byte[] reEncryptedAuthenticationKey = this.securityKeyService\n-                .reEncryptKey(smartMeteringDevice.getAuthenticationKey(), SecurityKeyType.E_METER_AUTHENTICATION);\n-        smartMeteringDevice.setAuthenticationKey(reEncryptedAuthenticationKey);\n-    }\n-\n-    private void reEncryptEncryptionKey(final SmartMeteringDeviceDto smartMeteringDevice) throws FunctionalException {\n-\n-        if (ArrayUtils.isEmpty(smartMeteringDevice.getGlobalEncryptionUnicastKey())) {\n-            return;\n-        }\n-        final byte[] reEncryptedEncryptionKey = this.securityKeyService\n-                .reEncryptKey(smartMeteringDevice.getGlobalEncryptionUnicastKey(), SecurityKeyType.E_METER_ENCRYPTION);\n-        smartMeteringDevice.setGlobalEncryptionUnicastKey(reEncryptedEncryptionKey);\n-    }\n-\n-    private void reEncryptMbusDefaultKey(final SmartMeteringDeviceDto smartMeteringDevice) throws FunctionalException {\n-\n-        if (ArrayUtils.isEmpty(smartMeteringDevice.getMbusDefaultKey())) {\n-            return;\n-        }\n-\n-        final byte[] reEncryptedMbusDefaultKey = this.securityKeyService\n-                .reEncryptKey(smartMeteringDevice.getMbusDefaultKey(), SecurityKeyType.G_METER_MASTER);\n-        smartMeteringDevice.setMbusDefaultKey(reEncryptedMbusDefaultKey);\n+    private void storeNewKeys(final SmartMeteringDeviceDto deviceDto) throws FunctionalException {\n+        Map<SecurityKeyType,byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n+        keysByType.put(E_METER_MASTER,this.encryptionService.rsaDecrypt(deviceDto.getMasterKey()));", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkyNjQ0Mw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r532926443", "bodyText": "Agreed.", "author": "jandik", "createdAt": "2020-11-30T21:50:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgwNTA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgwOTEwNg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527809106", "bodyText": "I think either the @Slf4j annotation or the static LOGGER are acceptable, but I don't see any use for this annotation if logging is done using the LOGGER.", "author": "bvdzwet", "createdAt": "2020-11-20T16:30:04Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java", "diffHunk": "@@ -35,147 +44,306 @@\n \n @Service\n @Slf4j", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkyNzM0NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r532927344", "bodyText": "I didn't change this, but I agree: removed @slf4j", "author": "jandik", "createdAt": "2020-11-30T21:52:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgwOTEwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgzMTc1Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527831752", "bodyText": "Looking at the comment by Jenkins below, the ProtocolAdapterException is not actually thrown here (anymore).\nLeaving the throws clause in the javadoc and declaration appears to be only misleading.", "author": "bvdzwet", "createdAt": "2020-11-20T17:03:03Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java", "diffHunk": "@@ -35,147 +44,306 @@\n \n @Service\n @Slf4j\n-public class SecretManagementService implements SecurityKeyService {\n+/**\n+ * Service for storing, activating and retrieving device keys.\n+ * Also performs RSA encryption/decryption operations for SOAP messaging purposes.\n+ */\n+public class SecretManagementService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncryptionProvider rsaEncryptionProvider;\n+    private final RsaEncrypter soapRsaEncrypter;\n     private final SecretManagementClient secretManagementClient;\n \n-    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider,\n-            SecretManagementClient secretManagementClient) {\n-        this.rsaEncryptionProvider = rsaEncryptionProvider;\n+\n+    public SecretManagementService(RsaEncrypter soapRsaEncrypter, SecretManagementClient secretManagementClient) {\n+        this.soapRsaEncrypter = soapRsaEncrypter;\n         this.secretManagementClient = secretManagementClient;\n     }\n \n-    @Override\n-    public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n-        throw new NotImplementedException();\n+    /**\n+     * Retrieve an active key of a certain type for a specified device\n+     *\n+     * @param deviceIdentification\n+     *         the device identification string of the device\n+     * @param keyType\n+     *         the requested key type\n+     *\n+     * @return the key or NULL if not present\n+     */\n+    public byte[] getKey(String deviceIdentification, SecurityKeyType keyType) {\n+        LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n+        return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n     }\n \n-    @Override\n-    public byte[] decryptKey(byte[] encryptedKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    /**\n+     * Retrieves the active keys of requested types for a specified device\n+     *\n+     * @param deviceIdentification\n+     *         the device identification string of the device\n+     * @param keyTypes\n+     *         the requested key types\n+     *\n+     * @return the requested keys in a map by key type, with value NULL if not present\n+     */\n+    public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n+        GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n+        GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+        this.validateGetResponse(keyTypes, response);\n+        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n     }\n \n-    @Override\n-    public byte[] encryptKey(byte[] plainKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    /**\n+     * Retrieve a new (not yet activated) key of a certain type for a specified device\n+     *\n+     * @param deviceIdentification\n+     *         the device identification string of the device\n+     * @param keyType\n+     *         the requested key type\n+     *\n+     * @return the key or NULL if not present\n+     */\n+    public byte[] getNewKey(String deviceIdentification, SecurityKeyType keyType) {\n+        LOGGER.info(\"Retrieving new {} for device {}\", keyType.name(), deviceIdentification);\n+        return this.getNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n     }\n \n-    @Override\n-    public byte[] getDlmsMasterKey(String deviceIdentification) {\n-        throw new NotImplementedException();\n+    /**\n+     * Retrieves the new (not yet activated) keys of requested types for a specified device\n+     *\n+     * @param deviceIdentification\n+     *         the device identification string of the device\n+     * @param keyTypes\n+     *         the requested key types\n+     *\n+     * @return the requested keys in a map by key type, with value NULL if not present\n+     */\n+    public Map<SecurityKeyType, byte[]> getNewKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n+        GetNewSecretsRequest request = this.createGetNewSecretsRequest(deviceIdentification, keyTypes);\n+        GetNewSecretsResponse response = this.secretManagementClient.getNewSecretsRequest(request);\n+        this.validateGetNewResponse(keyTypes, response);\n+        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n     }\n \n-    @Override\n-    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n-\n-        try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-\n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-\n-            log.trace(\"DlmsAuthenticationKey for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n-\n-            return decryptedKey;\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving authentication key\", e);\n-        }\n+    private void validateGetResponse(List<SecurityKeyType> keyTypes, GetSecretsResponse response) {\n+        this.validateOsgpResultAndTypedSecrets(response.getResult(), response.getTechnicalFault(),\n+                response.getTypedSecrets(), keyTypes.size());\n     }\n \n-    @Override\n-    public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n-\n-        try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-\n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n+    private void validateGetNewResponse(List<SecurityKeyType> keyTypes, GetNewSecretsResponse response) {\n+        this.validateOsgpResultAndTypedSecrets(response.getResult(), response.getTechnicalFault(),\n+                response.getTypedSecrets(), keyTypes.size());\n+    }\n \n-            log.trace(\"DlmsGlobalUnicastEncryptionKey for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n+    private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(List<TypedSecret> soapSecrets) {\n+        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n+        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts,false);\n+        Map<SecurityKeyType,byte[]> decryptedKeysByType = new EnumMap<>(SecurityKeyType.class);\n+        soapSecrets.forEach(ts->decryptedKeysByType.put(convertType.apply(ts),convertSecret.apply(ts)));\n+        return decryptedKeysByType;\n+    }\n \n-            return decryptedKey;\n+    private GetSecretsRequest createGetSecretsRequest(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n+        GetSecretsRequest request = new GetSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+        return request;\n+    }\n \n-        } catch (Exception e) {\n-            LOGGER.error(\"Error while retrieving encryption key\", e);\n-        }\n-        return new byte[0];\n+    private GetNewSecretsRequest createGetNewSecretsRequest(String deviceIdentification,\n+            List<SecurityKeyType> keyTypes) {\n+        GetNewSecretsRequest request = new GetNewSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+        return request;\n     }\n \n-    @Override\n-    public byte[] getMbusDefaultKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+    /**\n+     * Store new key\n+     * <p>\n+     * A new key is a security key with a device which status NEW.\n+     * This status is used when the new key is known, but not yet set on the device.\n+     * <p>\n+     * <strong>CAUTION:</strong> Only call this method when a successful\n+     * connection with the device has been set up (that is: a valid\n+     * communication key that works is known), and you are sure any existing new\n+     * key data that is not activated yet (for instance a new key stored earlier in an\n+     * attempt to replace the communication key that got aborted).<br>\n+     * <p>\n+     * The moment the new key is known to be transferred to the device, make\n+     * sure to activate it by calling\n+     * {@link #activateNewKey(String, SecurityKeyType)}.\n+     *\n+     * @param deviceIdentification\n+     *         DLMS device id\n+     * @param key\n+     *         key to store, unencrypted\n+     * @param keyType\n+     *         type of key\n+     *\n+     * @see #activateNewKey(String, SecurityKeyType)\n+     */\n+    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] key) {\n+        Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n+        keysByType.put(keyType, key);\n+        this.storeNewKeys(deviceIdentification, keysByType);\n     }\n \n-    @Override\n-    public byte[] getMbusUserKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+    public void storeNewKeys(String deviceIdentification, Map<SecurityKeyType, byte[]> keysByType) {\n+        this.validateKeys(keysByType);\n+        TypedSecrets typedSecrets = new TypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+        for (Map.Entry<SecurityKeyType,byte[]> entry : keysByType.entrySet()) {\n+            TypedSecret ts = new TypedSecret();\n+            ts.setType(entry.getKey().toSecretType());\n+            ts.setSecret(this.encryptSoapSecret(entry.getValue(),true));\n+            typedSecretList.add(ts);\n+        }\n+        StoreSecretsRequest request = this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n+        this.secretManagementClient.storeSecretsRequest(request);\n     }\n \n-    @Override\n-    public byte[] getDlmsPassword(String deviceIdentification) {\n-        throw new NotImplementedException();\n+    private void validateKeys(Map<SecurityKeyType, byte[]> keysByType) {\n+        long nrNulls = keysByType.values().stream().filter(Objects::isNull).count();\n+        if (nrNulls > 0) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Provided %s keys, %s of which were NULL\", keysByType.size(), nrNulls));\n+        }\n     }\n \n-    @Override\n-    public DlmsDevice storeNewKey(DlmsDevice device, byte[] encryptedKey, SecurityKeyType keyType) {\n-        throw new NotImplementedException();\n+    private StoreSecretsRequest createStoreSecretsRequest(String deviceIdentification, TypedSecrets typedSecrets) {\n+        StoreSecretsRequest request = new StoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setTypedSecrets(typedSecrets);\n+        return request;\n     }\n \n-    @Override\n-    public DlmsDevice validateNewKey(DlmsDevice device, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    /**\n+     * Updates the state of a new key from 'new' to 'active'\n+     * <p>\n+     * This method should be called to activate a new key stored with\n+     * {@link #storeNewKeys(String, Map)} after it has\n+     * been confirmed to be set on the device.\n+     *\n+     * @param deviceIdentification\n+     *         DLMS device id\n+     * @param keyType\n+     *         type of key\n+     *\n+     * @throws ProtocolAdapterException", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgzNTgwNA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527835804", "bodyText": "I am not sure whether fault could be null here or not, but as a general safety precaution I think it is almost always better (unless you would want the NullPointerException, which seems unlikely) to not include .toString() when you concatenate any object with a String as its String representation will be appended anyway if the object is not null.", "author": "bvdzwet", "createdAt": "2020-11-20T17:09:53Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java", "diffHunk": "@@ -35,147 +44,306 @@\n \n @Service\n @Slf4j\n-public class SecretManagementService implements SecurityKeyService {\n+/**\n+ * Service for storing, activating and retrieving device keys.\n+ * Also performs RSA encryption/decryption operations for SOAP messaging purposes.\n+ */\n+public class SecretManagementService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncryptionProvider rsaEncryptionProvider;\n+    private final RsaEncrypter soapRsaEncrypter;\n     private final SecretManagementClient secretManagementClient;\n \n-    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider,\n-            SecretManagementClient secretManagementClient) {\n-        this.rsaEncryptionProvider = rsaEncryptionProvider;\n+\n+    public SecretManagementService(RsaEncrypter soapRsaEncrypter, SecretManagementClient secretManagementClient) {\n+        this.soapRsaEncrypter = soapRsaEncrypter;\n         this.secretManagementClient = secretManagementClient;\n     }\n \n-    @Override\n-    public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n-        throw new NotImplementedException();\n+    /**\n+     * Retrieve an active key of a certain type for a specified device\n+     *\n+     * @param deviceIdentification\n+     *         the device identification string of the device\n+     * @param keyType\n+     *         the requested key type\n+     *\n+     * @return the key or NULL if not present\n+     */\n+    public byte[] getKey(String deviceIdentification, SecurityKeyType keyType) {\n+        LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n+        return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n     }\n \n-    @Override\n-    public byte[] decryptKey(byte[] encryptedKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    /**\n+     * Retrieves the active keys of requested types for a specified device\n+     *\n+     * @param deviceIdentification\n+     *         the device identification string of the device\n+     * @param keyTypes\n+     *         the requested key types\n+     *\n+     * @return the requested keys in a map by key type, with value NULL if not present\n+     */\n+    public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n+        GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n+        GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+        this.validateGetResponse(keyTypes, response);\n+        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n     }\n \n-    @Override\n-    public byte[] encryptKey(byte[] plainKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    /**\n+     * Retrieve a new (not yet activated) key of a certain type for a specified device\n+     *\n+     * @param deviceIdentification\n+     *         the device identification string of the device\n+     * @param keyType\n+     *         the requested key type\n+     *\n+     * @return the key or NULL if not present\n+     */\n+    public byte[] getNewKey(String deviceIdentification, SecurityKeyType keyType) {\n+        LOGGER.info(\"Retrieving new {} for device {}\", keyType.name(), deviceIdentification);\n+        return this.getNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n     }\n \n-    @Override\n-    public byte[] getDlmsMasterKey(String deviceIdentification) {\n-        throw new NotImplementedException();\n+    /**\n+     * Retrieves the new (not yet activated) keys of requested types for a specified device\n+     *\n+     * @param deviceIdentification\n+     *         the device identification string of the device\n+     * @param keyTypes\n+     *         the requested key types\n+     *\n+     * @return the requested keys in a map by key type, with value NULL if not present\n+     */\n+    public Map<SecurityKeyType, byte[]> getNewKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n+        GetNewSecretsRequest request = this.createGetNewSecretsRequest(deviceIdentification, keyTypes);\n+        GetNewSecretsResponse response = this.secretManagementClient.getNewSecretsRequest(request);\n+        this.validateGetNewResponse(keyTypes, response);\n+        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n     }\n \n-    @Override\n-    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n-\n-        try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-\n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-\n-            log.trace(\"DlmsAuthenticationKey for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n-\n-            return decryptedKey;\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving authentication key\", e);\n-        }\n+    private void validateGetResponse(List<SecurityKeyType> keyTypes, GetSecretsResponse response) {\n+        this.validateOsgpResultAndTypedSecrets(response.getResult(), response.getTechnicalFault(),\n+                response.getTypedSecrets(), keyTypes.size());\n     }\n \n-    @Override\n-    public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n-\n-        try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-\n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n+    private void validateGetNewResponse(List<SecurityKeyType> keyTypes, GetNewSecretsResponse response) {\n+        this.validateOsgpResultAndTypedSecrets(response.getResult(), response.getTechnicalFault(),\n+                response.getTypedSecrets(), keyTypes.size());\n+    }\n \n-            log.trace(\"DlmsGlobalUnicastEncryptionKey for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n+    private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(List<TypedSecret> soapSecrets) {\n+        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n+        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts,false);\n+        Map<SecurityKeyType,byte[]> decryptedKeysByType = new EnumMap<>(SecurityKeyType.class);\n+        soapSecrets.forEach(ts->decryptedKeysByType.put(convertType.apply(ts),convertSecret.apply(ts)));\n+        return decryptedKeysByType;\n+    }\n \n-            return decryptedKey;\n+    private GetSecretsRequest createGetSecretsRequest(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n+        GetSecretsRequest request = new GetSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+        return request;\n+    }\n \n-        } catch (Exception e) {\n-            LOGGER.error(\"Error while retrieving encryption key\", e);\n-        }\n-        return new byte[0];\n+    private GetNewSecretsRequest createGetNewSecretsRequest(String deviceIdentification,\n+            List<SecurityKeyType> keyTypes) {\n+        GetNewSecretsRequest request = new GetNewSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+        return request;\n     }\n \n-    @Override\n-    public byte[] getMbusDefaultKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+    /**\n+     * Store new key\n+     * <p>\n+     * A new key is a security key with a device which status NEW.\n+     * This status is used when the new key is known, but not yet set on the device.\n+     * <p>\n+     * <strong>CAUTION:</strong> Only call this method when a successful\n+     * connection with the device has been set up (that is: a valid\n+     * communication key that works is known), and you are sure any existing new\n+     * key data that is not activated yet (for instance a new key stored earlier in an\n+     * attempt to replace the communication key that got aborted).<br>\n+     * <p>\n+     * The moment the new key is known to be transferred to the device, make\n+     * sure to activate it by calling\n+     * {@link #activateNewKey(String, SecurityKeyType)}.\n+     *\n+     * @param deviceIdentification\n+     *         DLMS device id\n+     * @param key\n+     *         key to store, unencrypted\n+     * @param keyType\n+     *         type of key\n+     *\n+     * @see #activateNewKey(String, SecurityKeyType)\n+     */\n+    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] key) {\n+        Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n+        keysByType.put(keyType, key);\n+        this.storeNewKeys(deviceIdentification, keysByType);\n     }\n \n-    @Override\n-    public byte[] getMbusUserKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+    public void storeNewKeys(String deviceIdentification, Map<SecurityKeyType, byte[]> keysByType) {\n+        this.validateKeys(keysByType);\n+        TypedSecrets typedSecrets = new TypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+        for (Map.Entry<SecurityKeyType,byte[]> entry : keysByType.entrySet()) {\n+            TypedSecret ts = new TypedSecret();\n+            ts.setType(entry.getKey().toSecretType());\n+            ts.setSecret(this.encryptSoapSecret(entry.getValue(),true));\n+            typedSecretList.add(ts);\n+        }\n+        StoreSecretsRequest request = this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n+        this.secretManagementClient.storeSecretsRequest(request);\n     }\n \n-    @Override\n-    public byte[] getDlmsPassword(String deviceIdentification) {\n-        throw new NotImplementedException();\n+    private void validateKeys(Map<SecurityKeyType, byte[]> keysByType) {\n+        long nrNulls = keysByType.values().stream().filter(Objects::isNull).count();\n+        if (nrNulls > 0) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Provided %s keys, %s of which were NULL\", keysByType.size(), nrNulls));\n+        }\n     }\n \n-    @Override\n-    public DlmsDevice storeNewKey(DlmsDevice device, byte[] encryptedKey, SecurityKeyType keyType) {\n-        throw new NotImplementedException();\n+    private StoreSecretsRequest createStoreSecretsRequest(String deviceIdentification, TypedSecrets typedSecrets) {\n+        StoreSecretsRequest request = new StoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setTypedSecrets(typedSecrets);\n+        return request;\n     }\n \n-    @Override\n-    public DlmsDevice validateNewKey(DlmsDevice device, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    /**\n+     * Updates the state of a new key from 'new' to 'active'\n+     * <p>\n+     * This method should be called to activate a new key stored with\n+     * {@link #storeNewKeys(String, Map)} after it has\n+     * been confirmed to be set on the device.\n+     *\n+     * @param deviceIdentification\n+     *         DLMS device id\n+     * @param keyType\n+     *         type of key\n+     *\n+     * @throws ProtocolAdapterException\n+     *         if no new key is stored with the given device\n+     * @see #storeNewKeys(String, Map)\n+     */\n+    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        this.activateNewKeys(deviceIdentification, Arrays.asList(keyType));\n     }\n \n-    @Override\n-    public byte[] generateKey() {\n-        throw new NotImplementedException();\n+    public void activateNewKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n+        ActivateSecretsRequest request = new ActivateSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        keyTypes.forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+        this.secretManagementClient.activateSecretsRequest(request);\n     }\n \n-    @Override\n-    public byte[] generateAndEncryptKey() {\n-        throw new NotImplementedException();\n+    public boolean hasNewSecretOfType(String deviceIdentification, SecurityKeyType keyType) {\n+        HasNewSecretRequest request = new HasNewSecretRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretType(keyType.toSecretType());\n+        HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n+        return response.isHasNewSecret();\n     }\n \n-    @Override\n-    public byte[] encryptMbusUserKey(byte[] mbusDefaultKey, byte[] mbusUserKey) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public byte[] generate128BitsKeyAndStoreAsNewKey(String deviceIdentification, SecurityKeyType keyType) {\n+        return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n     }\n \n-    private Optional<TypedSecret> getTypedSecretFromSoapResponse(GetSecretsResponse response, SecretType secretType) {\n+    /**\n+     * Generates a new key that can be used as DLMS master key, authentication\n+     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n+     * <p>\n+     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n+     * device, but can be generated for use in tests or with simulated devices.\n+     *\n+     * @return a new 128bits key, unencrypted.\n+     */\n+    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n+            List<SecurityKeyType> keyTypes) {\n+        SecretTypes secretTypes = new SecretTypes();\n+        GenerateAndStoreSecretsRequest request = this\n+                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n+\n+        GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n         TypedSecrets typedSecrets = response.getTypedSecrets();\n         List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        return typedSecretList.stream().filter(typedSecret -> typedSecret.getType() == secretType).findFirst();\n+        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+        return this.convertSoapSecretsToSecretMapByType(typedSecrets.getTypedSecret());\n     }\n \n-    private GetSecretsRequest getSoapRequestForKey(String deviceIdentification, SecretType secretType) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n+    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n+            SecretTypes secretTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n         request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(secretType);\n+        request.setSecretTypes(secretTypes);\n         return request;\n     }\n \n-    private byte[] decryptSoapSecret(String deviceIdentification, TypedSecret typedSecret) {\n+    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n+            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n+        this.validateOsgpResultAndTypedSecrets(response.getResult(), response.getTechnicalFault(),\n+                response.getTypedSecrets(), keyTypes.size());\n+        typedSecretList.forEach(ts -> {\n+            if (ts.getSecret() == null) {\n+                throw new IllegalStateException(String.format(\"Generated a NULL key (key_type=%s)\", ts.getType()));\n+            }\n+        });\n+    }\n+\n+    private void validateOsgpResultAndTypedSecrets(OsgpResultType result, Object fault, TypedSecrets typedSecrets,\n+            int expectedNrKeys) {\n+        if (!OsgpResultType.OK.equals(result)) {\n+            throw new IllegalStateException(\"Could not generate and store keys in secret-mgmt: \" + fault.toString());", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgzNjg3Ng==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527836876", "bodyText": "It looks really odd and unnecessary to concatenate two String literals like this on a single line.", "author": "bvdzwet", "createdAt": "2020-11-20T17:11:40Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java", "diffHunk": "@@ -35,147 +44,306 @@\n \n @Service\n @Slf4j\n-public class SecretManagementService implements SecurityKeyService {\n+/**\n+ * Service for storing, activating and retrieving device keys.\n+ * Also performs RSA encryption/decryption operations for SOAP messaging purposes.\n+ */\n+public class SecretManagementService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncryptionProvider rsaEncryptionProvider;\n+    private final RsaEncrypter soapRsaEncrypter;\n     private final SecretManagementClient secretManagementClient;\n \n-    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider,\n-            SecretManagementClient secretManagementClient) {\n-        this.rsaEncryptionProvider = rsaEncryptionProvider;\n+\n+    public SecretManagementService(RsaEncrypter soapRsaEncrypter, SecretManagementClient secretManagementClient) {\n+        this.soapRsaEncrypter = soapRsaEncrypter;\n         this.secretManagementClient = secretManagementClient;\n     }\n \n-    @Override\n-    public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n-        throw new NotImplementedException();\n+    /**\n+     * Retrieve an active key of a certain type for a specified device\n+     *\n+     * @param deviceIdentification\n+     *         the device identification string of the device\n+     * @param keyType\n+     *         the requested key type\n+     *\n+     * @return the key or NULL if not present\n+     */\n+    public byte[] getKey(String deviceIdentification, SecurityKeyType keyType) {\n+        LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n+        return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n     }\n \n-    @Override\n-    public byte[] decryptKey(byte[] encryptedKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    /**\n+     * Retrieves the active keys of requested types for a specified device\n+     *\n+     * @param deviceIdentification\n+     *         the device identification string of the device\n+     * @param keyTypes\n+     *         the requested key types\n+     *\n+     * @return the requested keys in a map by key type, with value NULL if not present\n+     */\n+    public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n+        GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n+        GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+        this.validateGetResponse(keyTypes, response);\n+        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n     }\n \n-    @Override\n-    public byte[] encryptKey(byte[] plainKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    /**\n+     * Retrieve a new (not yet activated) key of a certain type for a specified device\n+     *\n+     * @param deviceIdentification\n+     *         the device identification string of the device\n+     * @param keyType\n+     *         the requested key type\n+     *\n+     * @return the key or NULL if not present\n+     */\n+    public byte[] getNewKey(String deviceIdentification, SecurityKeyType keyType) {\n+        LOGGER.info(\"Retrieving new {} for device {}\", keyType.name(), deviceIdentification);\n+        return this.getNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n     }\n \n-    @Override\n-    public byte[] getDlmsMasterKey(String deviceIdentification) {\n-        throw new NotImplementedException();\n+    /**\n+     * Retrieves the new (not yet activated) keys of requested types for a specified device\n+     *\n+     * @param deviceIdentification\n+     *         the device identification string of the device\n+     * @param keyTypes\n+     *         the requested key types\n+     *\n+     * @return the requested keys in a map by key type, with value NULL if not present\n+     */\n+    public Map<SecurityKeyType, byte[]> getNewKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n+        GetNewSecretsRequest request = this.createGetNewSecretsRequest(deviceIdentification, keyTypes);\n+        GetNewSecretsResponse response = this.secretManagementClient.getNewSecretsRequest(request);\n+        this.validateGetNewResponse(keyTypes, response);\n+        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n     }\n \n-    @Override\n-    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n-\n-        try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-\n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-\n-            log.trace(\"DlmsAuthenticationKey for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n-\n-            return decryptedKey;\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving authentication key\", e);\n-        }\n+    private void validateGetResponse(List<SecurityKeyType> keyTypes, GetSecretsResponse response) {\n+        this.validateOsgpResultAndTypedSecrets(response.getResult(), response.getTechnicalFault(),\n+                response.getTypedSecrets(), keyTypes.size());\n     }\n \n-    @Override\n-    public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n-\n-        try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-\n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n+    private void validateGetNewResponse(List<SecurityKeyType> keyTypes, GetNewSecretsResponse response) {\n+        this.validateOsgpResultAndTypedSecrets(response.getResult(), response.getTechnicalFault(),\n+                response.getTypedSecrets(), keyTypes.size());\n+    }\n \n-            log.trace(\"DlmsGlobalUnicastEncryptionKey for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n+    private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(List<TypedSecret> soapSecrets) {\n+        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n+        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts,false);\n+        Map<SecurityKeyType,byte[]> decryptedKeysByType = new EnumMap<>(SecurityKeyType.class);\n+        soapSecrets.forEach(ts->decryptedKeysByType.put(convertType.apply(ts),convertSecret.apply(ts)));\n+        return decryptedKeysByType;\n+    }\n \n-            return decryptedKey;\n+    private GetSecretsRequest createGetSecretsRequest(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n+        GetSecretsRequest request = new GetSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+        return request;\n+    }\n \n-        } catch (Exception e) {\n-            LOGGER.error(\"Error while retrieving encryption key\", e);\n-        }\n-        return new byte[0];\n+    private GetNewSecretsRequest createGetNewSecretsRequest(String deviceIdentification,\n+            List<SecurityKeyType> keyTypes) {\n+        GetNewSecretsRequest request = new GetNewSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+        return request;\n     }\n \n-    @Override\n-    public byte[] getMbusDefaultKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+    /**\n+     * Store new key\n+     * <p>\n+     * A new key is a security key with a device which status NEW.\n+     * This status is used when the new key is known, but not yet set on the device.\n+     * <p>\n+     * <strong>CAUTION:</strong> Only call this method when a successful\n+     * connection with the device has been set up (that is: a valid\n+     * communication key that works is known), and you are sure any existing new\n+     * key data that is not activated yet (for instance a new key stored earlier in an\n+     * attempt to replace the communication key that got aborted).<br>\n+     * <p>\n+     * The moment the new key is known to be transferred to the device, make\n+     * sure to activate it by calling\n+     * {@link #activateNewKey(String, SecurityKeyType)}.\n+     *\n+     * @param deviceIdentification\n+     *         DLMS device id\n+     * @param key\n+     *         key to store, unencrypted\n+     * @param keyType\n+     *         type of key\n+     *\n+     * @see #activateNewKey(String, SecurityKeyType)\n+     */\n+    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] key) {\n+        Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n+        keysByType.put(keyType, key);\n+        this.storeNewKeys(deviceIdentification, keysByType);\n     }\n \n-    @Override\n-    public byte[] getMbusUserKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+    public void storeNewKeys(String deviceIdentification, Map<SecurityKeyType, byte[]> keysByType) {\n+        this.validateKeys(keysByType);\n+        TypedSecrets typedSecrets = new TypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+        for (Map.Entry<SecurityKeyType,byte[]> entry : keysByType.entrySet()) {\n+            TypedSecret ts = new TypedSecret();\n+            ts.setType(entry.getKey().toSecretType());\n+            ts.setSecret(this.encryptSoapSecret(entry.getValue(),true));\n+            typedSecretList.add(ts);\n+        }\n+        StoreSecretsRequest request = this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n+        this.secretManagementClient.storeSecretsRequest(request);\n     }\n \n-    @Override\n-    public byte[] getDlmsPassword(String deviceIdentification) {\n-        throw new NotImplementedException();\n+    private void validateKeys(Map<SecurityKeyType, byte[]> keysByType) {\n+        long nrNulls = keysByType.values().stream().filter(Objects::isNull).count();\n+        if (nrNulls > 0) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Provided %s keys, %s of which were NULL\", keysByType.size(), nrNulls));\n+        }\n     }\n \n-    @Override\n-    public DlmsDevice storeNewKey(DlmsDevice device, byte[] encryptedKey, SecurityKeyType keyType) {\n-        throw new NotImplementedException();\n+    private StoreSecretsRequest createStoreSecretsRequest(String deviceIdentification, TypedSecrets typedSecrets) {\n+        StoreSecretsRequest request = new StoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setTypedSecrets(typedSecrets);\n+        return request;\n     }\n \n-    @Override\n-    public DlmsDevice validateNewKey(DlmsDevice device, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    /**\n+     * Updates the state of a new key from 'new' to 'active'\n+     * <p>\n+     * This method should be called to activate a new key stored with\n+     * {@link #storeNewKeys(String, Map)} after it has\n+     * been confirmed to be set on the device.\n+     *\n+     * @param deviceIdentification\n+     *         DLMS device id\n+     * @param keyType\n+     *         type of key\n+     *\n+     * @throws ProtocolAdapterException\n+     *         if no new key is stored with the given device\n+     * @see #storeNewKeys(String, Map)\n+     */\n+    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        this.activateNewKeys(deviceIdentification, Arrays.asList(keyType));\n     }\n \n-    @Override\n-    public byte[] generateKey() {\n-        throw new NotImplementedException();\n+    public void activateNewKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n+        ActivateSecretsRequest request = new ActivateSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        keyTypes.forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+        this.secretManagementClient.activateSecretsRequest(request);\n     }\n \n-    @Override\n-    public byte[] generateAndEncryptKey() {\n-        throw new NotImplementedException();\n+    public boolean hasNewSecretOfType(String deviceIdentification, SecurityKeyType keyType) {\n+        HasNewSecretRequest request = new HasNewSecretRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretType(keyType.toSecretType());\n+        HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n+        return response.isHasNewSecret();\n     }\n \n-    @Override\n-    public byte[] encryptMbusUserKey(byte[] mbusDefaultKey, byte[] mbusUserKey) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public byte[] generate128BitsKeyAndStoreAsNewKey(String deviceIdentification, SecurityKeyType keyType) {\n+        return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n     }\n \n-    private Optional<TypedSecret> getTypedSecretFromSoapResponse(GetSecretsResponse response, SecretType secretType) {\n+    /**\n+     * Generates a new key that can be used as DLMS master key, authentication\n+     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n+     * <p>\n+     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n+     * device, but can be generated for use in tests or with simulated devices.\n+     *\n+     * @return a new 128bits key, unencrypted.\n+     */\n+    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n+            List<SecurityKeyType> keyTypes) {\n+        SecretTypes secretTypes = new SecretTypes();\n+        GenerateAndStoreSecretsRequest request = this\n+                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n+\n+        GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n         TypedSecrets typedSecrets = response.getTypedSecrets();\n         List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        return typedSecretList.stream().filter(typedSecret -> typedSecret.getType() == secretType).findFirst();\n+        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+        return this.convertSoapSecretsToSecretMapByType(typedSecrets.getTypedSecret());\n     }\n \n-    private GetSecretsRequest getSoapRequestForKey(String deviceIdentification, SecretType secretType) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n+    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n+            SecretTypes secretTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n         request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(secretType);\n+        request.setSecretTypes(secretTypes);\n         return request;\n     }\n \n-    private byte[] decryptSoapSecret(String deviceIdentification, TypedSecret typedSecret) {\n+    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n+            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n+        this.validateOsgpResultAndTypedSecrets(response.getResult(), response.getTechnicalFault(),\n+                response.getTypedSecrets(), keyTypes.size());\n+        typedSecretList.forEach(ts -> {\n+            if (ts.getSecret() == null) {\n+                throw new IllegalStateException(String.format(\"Generated a NULL key (key_type=%s)\", ts.getType()));\n+            }\n+        });\n+    }\n+\n+    private void validateOsgpResultAndTypedSecrets(OsgpResultType result, Object fault, TypedSecrets typedSecrets,\n+            int expectedNrKeys) {\n+        if (!OsgpResultType.OK.equals(result)) {\n+            throw new IllegalStateException(\"Could not generate and store keys in secret-mgmt: \" + fault.toString());\n+        } else if (typedSecrets == null || typedSecrets.getTypedSecret() == null) {\n+            throw new IllegalStateException(\"No secrets in response\");\n+        } else if (expectedNrKeys != typedSecrets.getTypedSecret().size()) {\n+            throw new IllegalStateException(\n+                    String.format(\"Unexpected number of secrets in response: expected %s but \" + \"found %s\",", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkzMDA3Ng==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r532930076", "bodyText": "Autoformat FTW? :-(", "author": "jandik", "createdAt": "2020-11-30T21:57:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgzNjg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg0MTA2Nw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r527841067", "bodyText": "Is there any rationale behind auto-wiring the secretManagementService as a field when the other dependencies are set through the constructor?", "author": "bvdzwet", "createdAt": "2020-11-20T17:18:36Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/threads/RecoverKeyProcess.java", "diffHunk": "@@ -51,11 +56,12 @@\n \n     private String ipAddress;\n \n-    public RecoverKeyProcess(final DomainHelperService domainHelperService,\n-            final DlmsDeviceRepository dlmsDeviceRepository, final int responseTimeout, final int logicalDeviceAddress,\n-            final DlmsDeviceAssociation deviceAssociation) {\n+    @Autowired\n+    private SecretManagementService secretManagementService;", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkzNDIzMA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r532934230", "bodyText": "No intentional rationale. But after inspecting it, it seems correct te me: the other dependencies are set in DlmsConfig and I think that is the wrong place to wire it. So looks okay to me.", "author": "jandik", "createdAt": "2020-11-30T22:06:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg0MTA2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU1NTc0Nw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r528555747", "bodyText": "It looks like the reEncryptedAuthenticationKey and reEncryptedEncryptionKey have names that are no longer correct with these changes, as they appear to contain the authentication key and encryption key (without any re-encryption).", "author": "bvdzwet", "createdAt": "2020-11-23T09:11:08Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/ReplaceKeyCommandExecutor.java", "diffHunk": "@@ -101,58 +109,62 @@ public ActionResponseDto executeBundleAction(final DlmsConnectionManager conn, f\n         LOGGER.info(\"Keys set on device :{}\", device.getDeviceIdentification());\n \n         SetKeysRequestDto setKeysRequestDto = (SetKeysRequestDto) actionRequestDto;\n+\n         if (!setKeysRequestDto.isGeneratedKeys()) {\n-            setKeysRequestDto = this.reEncryptKeys((SetKeysRequestDto) actionRequestDto);\n+            setKeysRequestDto = this.decryptRsaKeys((SetKeysRequestDto) actionRequestDto);\n         }\n+        //if keys are generated, then they are unencrypted by the GenerateAndReplaceKeyCommandExecutor\n \n         final DlmsDevice devicePostSave = this.execute(conn, device, ReplaceKeyCommandExecutor\n                 .wrap(setKeysRequestDto.getAuthenticationKey(), KeyId.AUTHENTICATION_KEY,\n-                        SecurityKeyType.E_METER_AUTHENTICATION));\n+                        SecurityKeyType.E_METER_AUTHENTICATION, setKeysRequestDto.isGeneratedKeys()));\n \n         this.execute(conn, devicePostSave, ReplaceKeyCommandExecutor\n                 .wrap(setKeysRequestDto.getEncryptionKey(), KeyId.GLOBAL_UNICAST_ENCRYPTION_KEY,\n-                        SecurityKeyType.E_METER_ENCRYPTION));\n+                        SecurityKeyType.E_METER_ENCRYPTION, setKeysRequestDto.isGeneratedKeys()));\n \n         return new ActionResponseDto(REPLACE_KEYS + device.getDeviceIdentification() + WAS_SUCCESFULL);\n     }\n \n-    private SetKeysRequestDto reEncryptKeys(final SetKeysRequestDto setKeysRequestDto) throws FunctionalException {\n-        final byte[] reEncryptedAuthenticationKey = this.securityKeyService\n-                .reEncryptKey(setKeysRequestDto.getAuthenticationKey(), SecurityKeyType.E_METER_AUTHENTICATION);\n-        final byte[] reEncryptedEncryptionKey = this.securityKeyService\n-                .reEncryptKey(setKeysRequestDto.getEncryptionKey(), SecurityKeyType.E_METER_ENCRYPTION);\n+    private SetKeysRequestDto decryptRsaKeys(final SetKeysRequestDto setKeysRequestDto) throws FunctionalException {\n+        final byte[] reEncryptedAuthenticationKey =\n+                this.encryptionService.rsaDecrypt(setKeysRequestDto.getAuthenticationKey());\n+        final byte[] reEncryptedEncryptionKey = this.encryptionService.rsaDecrypt(setKeysRequestDto.getEncryptionKey());", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkzNzY0NQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r532937645", "bodyText": "Agreed, renamed", "author": "jandik", "createdAt": "2020-11-30T22:13:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU1NTc0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU4NDcxMw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r528584713", "bodyText": "This is the only point where methodResultCode is initialized, and it seems unclear why it is split from the declaration at the start of the method,\nPerhaps nicer to remove the variable and just return the value from the action like in transferKey.", "author": "bvdzwet", "createdAt": "2020-11-23T09:58:56Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetEncryptionKeyExchangeOnGMeterCommandExecutor.java", "diffHunk": "@@ -82,80 +94,115 @@ public MethodResultCode execute(final DlmsConnectionManager conn, final DlmsDevi\n \n             final String mbusDeviceIdentification = gMeterInfo.getDeviceIdentification();\n             final int channel = gMeterInfo.getChannel();\n-            DlmsDevice mbusDevice = this.dlmsDeviceRepository.findByDeviceIdentification(mbusDeviceIdentification);\n-            if (mbusDevice == null) {\n-                throw new ProtocolAdapterException(\"Unknown M-Bus device: \" + mbusDeviceIdentification);\n-            }\n-\n-            final byte[] mbusUserKey = this.securityKeyService.generateKey();\n-            final byte[] mbusDefaultKey = this.securityKeyService\n-                    .getMbusDefaultKey(gMeterInfo.getDeviceIdentification());\n-\n-            final SecurityKeyType mbusUserKeyType = SecurityKeyType.G_METER_ENCRYPTION;\n-            final byte[] encryptedUserKey = this.securityKeyService.encryptKey(mbusUserKey, mbusUserKeyType);\n-            mbusDevice = this.securityKeyService.storeNewKey(mbusDevice, encryptedUserKey, mbusUserKeyType);\n-\n             final ObisCode obisCode = OBIS_HASHMAP.get(channel);\n+            final byte[] gMeterEncryptionKey = this.secretManagementService\n+                    .generate128BitsKeyAndStoreAsNewKey(mbusDeviceIdentification, G_METER_ENCRYPTION);\n \n-            final MethodParameter methodTransferKey = this.getTransferKeyToMBusMethodParameter(obisCode, mbusDefaultKey,\n-                    mbusUserKey);\n-\n-            conn.getDlmsMessageListener()\n-                    .setDescription(\"SetEncryptionKeyExchangeOnGMeter for channel \" + channel\n-                            + \", call M-Bus Setup transfer_key method: \"\n-                            + JdlmsObjectToStringUtil.describeMethod(methodTransferKey));\n-\n-            MethodResult methodResultCode = conn.getConnection().action(methodTransferKey);\n-            this.checkMethodResultCode(methodResultCode, \"M-Bus Setup transfer_key\");\n-            LOGGER.info(\"Successfully invoked M-Bus Setup transfer_key method: class_id {} obis_code {}\", CLASS_ID,\n-                    obisCode);\n-\n-            conn.getDlmsMessageListener()\n-                    .setDescription(\"SetEncryptionKeyExchangeOnGMeter for channel \" + gMeterInfo.getChannel()\n-                            + \", call M-Bus Setup set_encryption_key method: \"\n-                            + JdlmsObjectToStringUtil.describeMethod(methodTransferKey));\n+            MethodResult methodResultCode = this\n+                    .transferKey(conn, mbusDeviceIdentification, channel, gMeterEncryptionKey);\n+            this.checkMethodResultCode(methodResultCode, \"M-Bus Setup transfer_key\", obisCode);\n \n-            final MethodParameter methodSetEncryptionKey = this.getSetEncryptionKeyMethodParameter(obisCode,\n-                    mbusUserKey);\n-            methodResultCode = conn.getConnection().action(methodSetEncryptionKey);\n-            this.checkMethodResultCode(methodResultCode, \"M-Bus Setup set_encryption_key\");\n-            LOGGER.info(\"Successfully invoked M-Bus Setup set_encryption_key method: class_id {} obis_code {}\",\n-                    CLASS_ID, obisCode);\n-\n-            this.securityKeyService.validateNewKey(mbusDevice, mbusUserKeyType);\n+            methodResultCode = this.setEncryptionKey(conn, channel, gMeterEncryptionKey);\n+            this.checkMethodResultCode(methodResultCode, \"M-Bus Setup set_encryption_key\", obisCode);\n \n+            this.secretManagementService.activateNewKey(mbusDeviceIdentification, G_METER_ENCRYPTION);\n             return MethodResultCode.SUCCESS;\n         } catch (final IOException e) {\n             throw new ConnectionException(e);\n         } catch (final EncrypterException e) {\n             throw new ProtocolAdapterException(\n                     \"Unexpected exception during decryption of security keys, reason = \" + e.getMessage(), e);\n+        } catch (final FunctionalException e) {\n+            throw new ProtocolAdapterException(\"Unexpected exception: \" + e.toString(), e);\n         }\n     }\n \n-    private void checkMethodResultCode(final MethodResult methodResultCode, final String methodParameterName)\n-            throws ProtocolAdapterException {\n+    private MethodResult setEncryptionKey(DlmsConnectionManager conn, int channel, byte[] encryptionKey)\n+            throws IOException {\n+        MethodResult methodResultCode;\n+        final MethodParameter methodSetEncryptionKey = this\n+                .getSetEncryptionKeyMethodParameter(OBIS_HASHMAP.get(channel), encryptionKey);\n+        conn.getDlmsMessageListener().setDescription(\"SetEncryptionKeyExchangeOnGMeter for channel \" + channel\n+                + \", call M-Bus Setup set_encryption_key method: \" + JdlmsObjectToStringUtil\n+                .describeMethod(methodSetEncryptionKey));\n+        methodResultCode = conn.getConnection().action(methodSetEncryptionKey);\n+        return methodResultCode;", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkzODczMA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r532938730", "bodyText": "Agreed", "author": "jandik", "createdAt": "2020-11-30T22:15:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU4NDcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwMDExMA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r528600110", "bodyText": "I think we already have dependencies that offer Pair classes.\nOther than that it looks a bit more involved than necessary to take this route with pairs.\nIf you would have to use an extra data structure some kind of bi-directional map seems to have semantics that more naturally reflect the one-to-one relation than a list of pairs.\nWouldn't the code be shorter and simpler though, if the SecretType would be stored in a field with the SecurityKeyType enum?\nThe only thing that is still needed would be the static method to determine the SecurityKeyType for a given SecretType. Here you could just iterate/stream over the enum values returning the first with matching SecretType.", "author": "bvdzwet", "createdAt": "2020-11-23T10:24:30Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/entities/SecurityKeyType.java", "diffHunk": "@@ -31,5 +38,58 @@\n     /**\n      * Password (e.g. used as DLMS Low Level Security secret)\n      */\n-    PASSWORD\n+    PASSWORD;\n+\n+    private static class Pair<A,B> {", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMzMTgzNA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r533331834", "bodyText": "Yeah, don't know how I missed that one. Probly overthinking it. Improved this with use of field with secret type.", "author": "jandik", "createdAt": "2020-12-01T11:18:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwMDExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYxNjA2Nw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r528616067", "bodyText": "This used to catch errors involving the key encryption or decryption.\nWith the implementation of the secretManagementService I didn't think that the EncrypterException gets thrown anymore.\nFor the logic in this block to work, I suspect that the secretManagementService would have to throw EncrypterException on key encryption/decryption errors, instead of IllegalStateException it throws now.\nI am not sure if catching IllegalStateException here would be an appropriate alternative, but at first sight I'd be hesitant to do that since it may be thrown for other issues than key encryption/decryption.", "author": "bvdzwet", "createdAt": "2020-11-23T10:51:57Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Hls5Connector.java", "diffHunk": "@@ -94,12 +97,14 @@ protected void setSecurity(final DlmsDevice device, final TcpConnectionBuilder t\n         final byte[] dlmsAuthenticationKey;\n         final byte[] dlmsEncryptionKey;\n         try {\n-            dlmsAuthenticationKey = this.securityKeyService.getDlmsAuthenticationKey(deviceIdentification);\n-            dlmsEncryptionKey = this.securityKeyService.getDlmsGlobalUnicastEncryptionKey(deviceIdentification);\n+            Map<SecurityKeyType, byte[]> encryptedKeys = this.secretManagementService\n+                    .getKeys(deviceIdentification, Arrays.asList(E_METER_AUTHENTICATION, E_METER_ENCRYPTION));\n+            dlmsAuthenticationKey = encryptedKeys.get(E_METER_AUTHENTICATION);\n+            dlmsEncryptionKey = encryptedKeys.get(E_METER_ENCRYPTION);\n         } catch (final EncrypterException e) {", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYxNzkwOQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r528617909", "bodyText": "Any particular reason to want to include the original encryption related exception as cause of the functional exception? It is already logged by the logger statement before.", "author": "bvdzwet", "createdAt": "2020-11-23T10:55:15Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Hls5Connector.java", "diffHunk": "@@ -94,12 +97,14 @@ protected void setSecurity(final DlmsDevice device, final TcpConnectionBuilder t\n         final byte[] dlmsAuthenticationKey;\n         final byte[] dlmsEncryptionKey;\n         try {\n-            dlmsAuthenticationKey = this.securityKeyService.getDlmsAuthenticationKey(deviceIdentification);\n-            dlmsEncryptionKey = this.securityKeyService.getDlmsGlobalUnicastEncryptionKey(deviceIdentification);\n+            Map<SecurityKeyType, byte[]> encryptedKeys = this.secretManagementService\n+                    .getKeys(deviceIdentification, Arrays.asList(E_METER_AUTHENTICATION, E_METER_ENCRYPTION));\n+            dlmsAuthenticationKey = encryptedKeys.get(E_METER_AUTHENTICATION);\n+            dlmsEncryptionKey = encryptedKeys.get(E_METER_ENCRYPTION);\n         } catch (final EncrypterException e) {\n             LOGGER.error(\"Error determining DLMS communication key setting up HLS5 connection\", e);\n             throw new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_ENCRYPTION,\n-                    ComponentType.PROTOCOL_DLMS);\n+                    ComponentType.PROTOCOL_DLMS, e);", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY1ODM5OA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r528658398", "bodyText": "It looks like nothing changed in this class, other than some opinionated restructuring of code that looked perfectly OK.\nThis only leads to bigger diffs in pull request and the next person may decide to change it back.", "author": "bvdzwet", "createdAt": "2020-11-23T12:10:43Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/exceptions/OsgpExceptionConverter.java", "diffHunk": "@@ -41,19 +41,18 @@\n      */\n     public OsgpException ensureOsgpOrTechnicalException(final Exception e) {\n \n-        final boolean osgpExceptionNotSupportedByShared = e instanceof ImageTransferException\n-                || e instanceof ProtocolAdapterException;\n+        final boolean osgpExceptionNotSupportedByShared =\n+                e instanceof ImageTransferException || e instanceof ProtocolAdapterException;\n \n         if (e instanceof OsgpException && !osgpExceptionNotSupportedByShared) {\n             return (OsgpException) e;\n-        }\n-        if (e instanceof ConnectionException) {\n+        } else if (e instanceof ConnectionException) {\n             return new FunctionalException(FunctionalExceptionType.CONNECTION_ERROR, ComponentType.PROTOCOL_DLMS,\n                     new OsgpException(ComponentType.PROTOCOL_DLMS, e.getMessage()));\n+        } else {\n+            return new TechnicalException(ComponentType.PROTOCOL_DLMS,\n+                    \"Unexpected exception while handling protocol request/response message\",\n+                    new OsgpException(ComponentType.PROTOCOL_DLMS, e.getMessage()));\n         }\n-\n-        return new TechnicalException(ComponentType.PROTOCOL_DLMS,\n-                \"Unexpected exception while handling protocol request/response message\",\n-                new OsgpException(ComponentType.PROTOCOL_DLMS, e.getMessage()));", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM0MDM0NQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r533340345", "bodyText": "It is opinionated, that's true. That's where coding guidelines can help. Personally, I prefer always explicitly putting every if/else case in a block except for a happy path. This is not the case here, hence my change, but I admit this is debatable.", "author": "jandik", "createdAt": "2020-12-01T11:33:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY1ODM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY2NTY2OA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r528665668", "bodyText": "This file is missing a required license header.", "author": "bvdzwet", "createdAt": "2020-11-23T12:23:38Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/test/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementServiceTest.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.services;", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY2NjcxOA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r528666718", "bodyText": "The value of AES_SECRET is not used. It looks like it should be removed.", "author": "bvdzwet", "createdAt": "2020-11-23T12:25:35Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/test/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementServiceTest.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.services;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.commons.codec.binary.Hex;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.SecretManagementClient;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n+import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.ActivateSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GenerateAndStoreSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.HasNewSecretResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.OsgpResultType;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class SecretManagementServiceTest {\n+    @InjectMocks\n+    SecretManagementService testService;\n+\n+    @Mock\n+    SecretManagementClient secretManagementClient;\n+    @Mock\n+    RsaEncrypter rsaEncrypter;\n+\n+    private static final String DEVICE_IDENTIFICATION = \"E000123456789\";\n+    private static final SecurityKeyType KEY_TYPE = SecurityKeyType.E_METER_ENCRYPTION;\n+    private static final byte[] UNENCRYPTED_SECRET = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\n+    private static final byte[] AES_SECRET = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY3MzIxNg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r528673216", "bodyText": "With the change of the type it would look nicer if the bean name was altered accordingly.", "author": "bvdzwet", "createdAt": "2020-11-23T12:37:45Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/test/java/org/opensmartgridplatform/adapter/protocol/dlms/infra/messaging/MessagingTestConfiguration.java", "diffHunk": "@@ -133,8 +133,8 @@ public MonitoringService monitoringService() {\n     }\n \n     @Bean\n-    public SecurityKeyService securityKeyService() {\n-        return Mockito.mock(SecurityKeyService.class);\n+    public SecretManagementService securityKeyService() {", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODcwNzE1OA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r528707158", "bodyText": "Wouldn't it be simpler (and conceptually more fitting) if the encryption providers were in a map of EncryptionProviderType to EncryptionProvider? (If there is only ever to be one provider per type, the map reflects that a little better.)", "author": "bvdzwet", "createdAt": "2020-11-23T13:36:09Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java", "diffHunk": "@@ -20,24 +20,39 @@\n @Component\n public class DefaultEncryptionDelegate implements EncryptionDelegate {\n \n-    private static final String ERROR_NO_PROVIDER = \"Could not find a provider\";\n+    private static final String ERROR_NO_PROVIDER = \"Could not find a provider of type %s; available providers are %s\";\n     private final List<EncryptionProvider> providers;\n \n     public DefaultEncryptionDelegate(final List<EncryptionProvider> encryptionProviders) {\n         this.providers = encryptionProviders;\n     }\n \n+    private EncryptionProvider getEncryptionProvider(EncryptionProviderType type) {\n+        return this.providers.stream().filter(provider -> provider.getType().equals(type)).findFirst()\n+                             .orElseThrow(() -> new EncrypterException(String.format(ERROR_NO_PROVIDER, type,\n+                                     this.providers)));", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM1MzE1NQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r533353155", "bodyText": "Yes, it would. Changed this.", "author": "jandik", "createdAt": "2020-12-01T11:56:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODcwNzE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODcxMDQ5OQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r528710499", "bodyText": "Copyright for new classes should mention Alliander N.V. instead of Smart Society Services B.V.", "author": "bvdzwet", "createdAt": "2020-11-23T13:41:34Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/RsaEncrypter.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODcxMzE4Nw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r528713187", "bodyText": "Any reason this task has not been completed? We shouldn't keep open work in TODOs in the code, if something is left out of scope it could be managed through the backlog.", "author": "bvdzwet", "createdAt": "2020-11-23T13:45:48Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/RsaEncrypter.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.shared.security;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Arrays;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+\n+//TODO merge with RsaEncryptionService; it is almost the same except for different configuration\n+//  refactor it to 1 single configurable class with 2 instances with different configurations", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODcxNTY0NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r528715644", "bodyText": "This comment does not look like it is appropriate for the GXF code base.\nA comment (not in Dutch) that the suppression is for the good cooperation with other components in the runtime might be better.", "author": "bvdzwet", "createdAt": "2020-11-23T13:49:48Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/RsaEncrypter.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.shared.security;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Arrays;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+\n+//TODO merge with RsaEncryptionService; it is almost the same except for different configuration\n+//  refactor it to 1 single configurable class with 2 instances with different configurations\n+public class RsaEncrypter {\n+    private static final int BLOCK_SIZE = 16;\n+    private static final String ALG = \"RSA\";\n+    private static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n+\n+    private Key publicKey;\n+    private Key privateKey;\n+\n+    public void setPrivateKeyStore(File privateKeyStoreFile) {\n+        try {\n+            byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n+            PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n+            this.privateKey = KeyFactory.getInstance(ALG).generatePrivate(privateKeySpec);\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            throw new EncrypterException(\"Could not get cipher\", e);\n+        }\n+    }\n+\n+    public void setPublicKeyStore(File publicKeyStoreFile) {\n+        try {\n+            byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n+            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n+            this.publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            throw new EncrypterException(\"Could not set public keystore\", e);\n+        }\n+    }\n+\n+    //Afgestemd met Paul Houtman: totdat Netinium is uitgefaseerd moeten we compatibel blijven", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODcxNjgzNg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r528716836", "bodyText": "Would it make sense to try and get rid of the warning by placing the algorithm metadata in configurable properties?", "author": "bvdzwet", "createdAt": "2020-11-23T13:51:42Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/RsaEncrypter.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.shared.security;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Arrays;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+\n+//TODO merge with RsaEncryptionService; it is almost the same except for different configuration\n+//  refactor it to 1 single configurable class with 2 instances with different configurations\n+public class RsaEncrypter {\n+    private static final int BLOCK_SIZE = 16;\n+    private static final String ALG = \"RSA\";\n+    private static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n+\n+    private Key publicKey;\n+    private Key privateKey;\n+\n+    public void setPrivateKeyStore(File privateKeyStoreFile) {\n+        try {\n+            byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n+            PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n+            this.privateKey = KeyFactory.getInstance(ALG).generatePrivate(privateKeySpec);\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            throw new EncrypterException(\"Could not get cipher\", e);\n+        }\n+    }\n+\n+    public void setPublicKeyStore(File publicKeyStoreFile) {\n+        try {\n+            byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n+            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n+            this.publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            throw new EncrypterException(\"Could not set public keystore\", e);\n+        }\n+    }\n+\n+    //Afgestemd met Paul Houtman: totdat Netinium is uitgefaseerd moeten we compatibel blijven\n+    @SuppressWarnings(\"squid:S5542\")\n+    protected Cipher getCipher() {\n+        try {\n+            return Cipher.getInstance(ALGORITHM);", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODcyODk1Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r528728952", "bodyText": "Try to avoid adding files with only irrelevant formatting changes in a pull request.", "author": "bvdzwet", "createdAt": "2020-11-23T14:10:34Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/RsaEncryptionService.java", "diffHunk": "@@ -34,13 +34,12 @@\n import javax.crypto.NoSuchPaddingException;\n \n import org.apache.commons.lang3.StringUtils;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Value;\n import org.springframework.stereotype.Component;\n \n-import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc2ODA0OQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r528768049", "bodyText": "What does this do, and why does it do this?\nThe code looks sketchy and raises questions. If this does what it is supposed to do, it might be good to add a few explanatory comments.\nIf the decryptedSecret has more than 16 bytes, it drops the last 16 bytes (if this should match KEY_LENGTH it would be better to use the constant in both cases, and not have the constant in one place and a literal 16 in the other).\nWhat should be the result?\nSomething that has exactly KEY_LENGHT bytes, at most KEY_LENGTH bytes, or whatever comes in stripping the last 16 bytes.\nThis reminds me a bit of other code where the first number of bytes are left out if they are all zeros, but looks somewhat different.", "author": "bvdzwet", "createdAt": "2020-11-23T15:04:18Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java", "diffHunk": "@@ -45,63 +45,73 @@\n \n     private final KeyStore keyStore;\n \n-    public HsmEncryptionProvider(File keyStoreFile) {\n+    public HsmEncryptionProvider(final File keyStoreFile) {\n         try {\n             super.setKeyFile(keyStoreFile);\n             this.keyStore = KeyStore.getInstance(TYPE, PROVIDER);\n-            FileInputStream fIn = new FileInputStream(keyStoreFile);\n+            final FileInputStream fIn = new FileInputStream(keyStoreFile);\n             this.keyStore.load(fIn, null);\n-        } catch (CertificateException | NoSuchAlgorithmException | NoSuchProviderException | IOException | KeyStoreException e) {\n+        } catch (final CertificateException | NoSuchAlgorithmException | NoSuchProviderException | IOException | KeyStoreException e) {\n             throw new EncrypterException(\"Could not read keystore\", e);\n         }\n     }\n \n-    public Secret decrypt(EncryptedSecret secret, String keyReference) {\n-\n-        Secret decryptedSecret = super.decrypt(secret, keyReference);\n-\n-        byte[] decryptedSecretBytes = decryptedSecret.getSecret();\n-\n-        if (decryptedSecretBytes.length > KEY_LENGTH) {\n-\n-            byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecretBytes, 0,\n-                    decryptedSecretBytes.length-16);\n-\n-            LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecretBytes) + \" to \" +\n+    @Override\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+        byte[] decryptedSecret = super.decrypt(secret, keyReference);\n+        if (decryptedSecret.length > KEY_LENGTH) {\n+            final byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecret, 0,\n+                    decryptedSecret.length-16);", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc4MTEyMA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r528781120", "bodyText": "It would be simpler to leave out the try catch block. If the exception occurs the test doesn't succeed, and this doesn't seem to offer much useful for the added code.", "author": "bvdzwet", "createdAt": "2020-11-23T15:21:42Z", "path": "osgp/shared/shared/src/test/java/org/opensmartgridplatform/shared/security/RsaEncryptionServiceTest.java", "diffHunk": "@@ -80,20 +95,24 @@ private void assertDecryptionOfKey(final RsaEncryptionService rsaEncryptionServi\n         final byte[] expected = Files.readAllBytes(Paths.get(keyPath));\n         final byte[] actual = rsaEncryptionService.decrypt(Hex.decodeHex(encryptedHexString.toCharArray()));\n         assertThat(Hex.encodeHexString(actual)).withFailMessage(\"decrypted \" + keyType)\n-                .isEqualTo(Hex.encodeHexString(expected));\n+                                               .isEqualTo(Hex.encodeHexString(expected));\n     }\n \n     @Test\n     public void testEncryptDecryptReturnsInput() {\n-        final KeyPair freshKeyPair = RsaEncryptionService.createKeyPair(KEYSIZE);\n-        final RsaEncryptionService rsaEncryptionService = new RsaEncryptionService(freshKeyPair);\n-        final byte[] input = this.createRandomInput();\n-        final byte[] encrypted = rsaEncryptionService.encrypt(input);\n-        final byte[] decrypted = rsaEncryptionService.decrypt(encrypted);\n-        assertThat(decrypted).withFailMessage(\"decrypted bytes after encryption\").isEqualTo(input);\n+        try {\n+            final KeyPair freshKeyPair = RsaEncryptionService.createKeyPair(KEYSIZE);\n+            final RsaEncryptionService rsaEncryptionService = new RsaEncryptionService(freshKeyPair);\n+            final byte[] input = this.createRandomInput();\n+            final byte[] encrypted = rsaEncryptionService.encrypt(input);\n+            final byte[] decrypted = rsaEncryptionService.decrypt(encrypted);\n+            assertThat(decrypted).withFailMessage(\"decrypted bytes after encryption\").isEqualTo(input);\n+        } catch (EncrypterException ee) {\n+            fail(\"Encryption failure\", ee);\n+        }", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc4NDM3Nw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r528784377", "bodyText": "In test code, where an exception is just another test failure, it might be simpler not to do to much bookkeeping about specific exceptions, and just throw Exception if any checked exceptions are involved.\nThat being said, I don't see where createNewKeysForTests is used. So it may be better to just remove the method.", "author": "bvdzwet", "createdAt": "2020-11-23T15:26:02Z", "path": "osgp/shared/shared/src/test/java/org/opensmartgridplatform/shared/security/RsaEncryptionServiceTest.java", "diffHunk": "@@ -107,7 +126,7 @@ private RsaEncryptionService createRsaEncryptionServiceFromStoredKeys() {\n         return randomBytes;\n     }\n \n-    public static void createNewKeysForTests() throws IOException {\n+    public static void createNewKeysForTests() throws IOException, EncrypterException {", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM4MDIzMQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r529380231", "bodyText": "Dropping the security keys from DlmsDevice is in line with the intentions behind using the secret management service.\nAs there no longer is a use for SecurityKey in the platform It looks like the SecurityKey entity and the security_key table should be removed, and not left around without a purpose.", "author": "bvdzwet", "createdAt": "2020-11-24T09:56:42Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/entities/DlmsDevice.java", "diffHunk": "@@ -56,9 +50,6 @@\n     @Column\n     private boolean hls5Active;\n \n-    @OneToMany(mappedBy = \"dlmsDevice\", fetch = FetchType.EAGER, cascade = { CascadeType.ALL }, orphanRemoval = true)\n-    private final List<SecurityKey> securityKeys = new ArrayList<>();", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMxNjMzNg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r533316336", "bodyText": "Agreed.", "author": "jandik", "createdAt": "2020-12-01T10:51:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM4MDIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAwMjY5Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r531002692", "bodyText": "Why not throw new RecoverKeyException(e);", "author": "harrymiddelburgetall", "createdAt": "2020-11-26T12:41:08Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/threads/RecoverKeyProcess.java", "diffHunk": "@@ -76,24 +82,35 @@ public void run() {\n         LOGGER.info(\"Attempting key recovery for device {}\", this.deviceIdentification);\n \n         try {\n-            this.initDevice();\n+            this.findDevice();\n         } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception: {}\", e);\n+            LOGGER.error(\"Could not find device\", e);\n+            //TODO why try to find device if you don't do anything with the result?!?\n+            //TODO return?\n         }\n-        if (!this.device.hasNewSecurityKey()) {\n+\n+        if (!this.secretManagementService.hasNewSecretOfType(this.deviceIdentification, E_METER_AUTHENTICATION)) {\n+            LOGGER.warn(\"Could not recover keys: device has no new authorisation key registered in secret-mgmt module\");\n             return;\n         }\n \n-        if (this.canConnect()) {\n-            this.promoteInvalidKey();\n+        if (this.canConnectUsingNewKeys()) {\n+            List<SecurityKeyType> keyTypesToActivate=Arrays.asList(E_METER_ENCRYPTION,E_METER_AUTHENTICATION);\n+            try {\n+                this.secretManagementService.activateNewKeys(this.deviceIdentification, keyTypesToActivate);\n+            } catch (Exception e) {\n+                throw new RecoverKeyException(e.getMessage(), e);", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkzNTM0OA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r532935348", "bodyText": "Agreed.", "author": "jandik", "createdAt": "2020-11-30T22:08:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAwMjY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAwMjc3MQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r531002771", "bodyText": "Why not throw new RecoverKeyException(e);", "author": "harrymiddelburgetall", "createdAt": "2020-11-26T12:41:15Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/threads/RecoverKeyProcess.java", "diffHunk": "@@ -76,24 +82,35 @@ public void run() {\n         LOGGER.info(\"Attempting key recovery for device {}\", this.deviceIdentification);\n \n         try {\n-            this.initDevice();\n+            this.findDevice();\n         } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception: {}\", e);\n+            LOGGER.error(\"Could not find device\", e);\n+            //TODO why try to find device if you don't do anything with the result?!?\n+            //TODO return?\n         }\n-        if (!this.device.hasNewSecurityKey()) {\n+\n+        if (!this.secretManagementService.hasNewSecretOfType(this.deviceIdentification, E_METER_AUTHENTICATION)) {\n+            LOGGER.warn(\"Could not recover keys: device has no new authorisation key registered in secret-mgmt module\");\n             return;\n         }\n \n-        if (this.canConnect()) {\n-            this.promoteInvalidKey();\n+        if (this.canConnectUsingNewKeys()) {\n+            List<SecurityKeyType> keyTypesToActivate=Arrays.asList(E_METER_ENCRYPTION,E_METER_AUTHENTICATION);\n+            try {\n+                this.secretManagementService.activateNewKeys(this.deviceIdentification, keyTypesToActivate);\n+            } catch (Exception e) {\n+                throw new RecoverKeyException(e.getMessage(), e);\n+            }\n+        } else {\n+            LOGGER.warn(\"Could not recover keys: could not connect to device using new keys\");\n+            //TODO try to connect using 'old' keys? send key change to device again?\n         }\n     }\n \n-    private void initDevice() throws OsgpException {\n+    private void findDevice() throws OsgpException {\n         try {\n             this.device = this.domainHelperService.findDlmsDevice(this.deviceIdentification, this.ipAddress);\n-        } catch (final ProtocolAdapterException e) {\n-            // Thread can not recover from these exceptions.\n+        } catch (final ProtocolAdapterException e) { // Thread can not recover from these exceptions.\n             throw new RecoverKeyException(e.getMessage(), e);", "originalCommit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bfedad64e14235b17f44beb4508815276cbcf275", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/bfedad64e14235b17f44beb4508815276cbcf275", "message": "SLIM-2597 processed review remarks", "committedDate": "2020-12-01T13:08:25Z", "type": "commit"}, {"oid": "48ae8ea87115de2a97af424ecec27732f0e0c999", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/48ae8ea87115de2a97af424ecec27732f0e0c999", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality\n\n\u0001 Conflicts:\n\u0001\trunTestsAtRemoteServer.sh", "committedDate": "2020-12-01T13:14:22Z", "type": "commit"}, {"oid": "6dab2be33753d3a19661892ee347469def7f8bb2", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/6dab2be33753d3a19661892ee347469def7f8bb2", "message": "SLIM-2597 fix build/cucumber test", "committedDate": "2020-12-01T15:51:13Z", "type": "commit"}, {"oid": "9025667f1c451899e491a2d097a1154266dff7ba", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/9025667f1c451899e491a2d097a1154266dff7ba", "message": "SLIM-2587 added logging/output to analyse cucumber test bug", "committedDate": "2020-12-01T18:18:34Z", "type": "commit"}, {"oid": "e5f184ab1366f525a8cf1ab0cd3867b256292737", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/e5f184ab1366f525a8cf1ab0cd3867b256292737", "message": "SLIM-2597 fixed bug wrt NULL or invalid keys", "committedDate": "2020-12-01T21:28:10Z", "type": "commit"}, {"oid": "45c04662bfa4a2608f8d643cb5673215943b51d3", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/45c04662bfa4a2608f8d643cb5673215943b51d3", "message": "SLIM-2587 improved assertion output wrt response fields", "committedDate": "2020-12-01T21:28:59Z", "type": "commit"}, {"oid": "38a6e2a7a6f00fd8631e683179b3a8eac56428e3", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/38a6e2a7a6f00fd8631e683179b3a8eac56428e3", "message": "SLIM-2587 improved assertion output wrt response fields", "committedDate": "2020-12-02T08:54:03Z", "type": "commit"}, {"oid": "e81c674c79265f1b574770520d01bd0eb9b07fc7", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/e81c674c79265f1b574770520d01bd0eb9b07fc7", "message": "SLIM-2587 improved assertion output wrt response fields", "committedDate": "2020-12-02T09:58:23Z", "type": "commit"}, {"oid": "d93132e4b4ffc218e10b2694eb8f1afdac8fb6d1", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/d93132e4b4ffc218e10b2694eb8f1afdac8fb6d1", "message": "SLIM-2587 improved assertion output wrt response fields", "committedDate": "2020-12-02T10:50:02Z", "type": "commit"}, {"oid": "83657b857a2d1ebbab7152e842d382b7a75b322c", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/83657b857a2d1ebbab7152e842d382b7a75b322c", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality\n\n\u0001 Conflicts:\n\u0001\tosgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/RsaEncryptionService.java", "committedDate": "2020-12-02T13:37:43Z", "type": "commit"}, {"oid": "6e73b6e80060205c3ab620e718931f2a38c9f603", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/6e73b6e80060205c3ab620e718931f2a38c9f603", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-12-08T10:49:28Z", "type": "commit"}, {"oid": "8320d83198695eaf810cf28eb0a92836fb589a13", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/8320d83198695eaf810cf28eb0a92836fb589a13", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-12-09T16:28:32Z", "type": "commit"}, {"oid": "109af69ad2526b4c97ad054b992f5b197077add1", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/109af69ad2526b4c97ad054b992f5b197077add1", "message": "SLIM-2587 enabled add device test", "committedDate": "2020-12-10T14:55:38Z", "type": "commit"}, {"oid": "eaf773ac3d1ec0a6430e12862bfef7b2f345a2fd", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/eaf773ac3d1ec0a6430e12862bfef7b2f345a2fd", "message": "SLIM-2587 enabled add gas device test", "committedDate": "2020-12-10T14:56:10Z", "type": "commit"}, {"oid": "24ac953b16cddcc4dd116f676ed1f4803a4e5121", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/24ac953b16cddcc4dd116f676ed1f4803a4e5121", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-12-10T14:56:49Z", "type": "commit"}, {"oid": "982756531963acd3e79b9f5821194a5b6affbc35", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/982756531963acd3e79b9f5821194a5b6affbc35", "message": "SLIM-2587 test platform improvements wrt key settings", "committedDate": "2020-12-11T13:16:13Z", "type": "commit"}, {"oid": "0e427d7ebd6d7bdea0faab4a491546812e429de5", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/0e427d7ebd6d7bdea0faab4a491546812e429de5", "message": "SLIM-2587 test platform improvements wrt key types", "committedDate": "2020-12-11T15:28:31Z", "type": "commit"}, {"oid": "483677736f6718d3c200d8153214bb5fbe1f4e53", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/483677736f6718d3c200d8153214bb5fbe1f4e53", "message": "SLIM-2587 test platform bug fix", "committedDate": "2020-12-14T07:23:49Z", "type": "commit"}, {"oid": "76cb1fe27377aacb057c0a77afe3f28cd941f298", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/76cb1fe27377aacb057c0a77afe3f28cd941f298", "message": "SLIM-2587 test platform bug fix", "committedDate": "2020-12-14T09:45:50Z", "type": "commit"}, {"oid": "d0113f7c7fbb9612ef8bf624f2cf9eef3a2ace21", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/d0113f7c7fbb9612ef8bf624f2cf9eef3a2ace21", "message": "SLIM-2587 test platform bug fix", "committedDate": "2020-12-14T10:47:10Z", "type": "commit"}, {"oid": "0ccf8f2273dbe57f64705abd612ce7ca1fd4de68", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/0ccf8f2273dbe57f64705abd612ce7ca1fd4de68", "message": "SLIM-2597 improved error message", "committedDate": "2020-12-14T12:19:43Z", "type": "commit"}, {"oid": "8b677d681ab95cb0619419ac044c3e665ff1ebdd", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/8b677d681ab95cb0619419ac044c3e665ff1ebdd", "message": "SLIM-2597 installation service bugfix", "committedDate": "2020-12-14T12:43:40Z", "type": "commit"}, {"oid": "32badbb6d9c94f26993b6967fd52d641d7c9fd5a", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/32badbb6d9c94f26993b6967fd52d641d7c9fd5a", "message": "SLIM-2597 installation service bugfix", "committedDate": "2020-12-14T14:35:21Z", "type": "commit"}, {"oid": "8983461b09e71c7e2b323a7eef43c1d2e98b8742", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/8983461b09e71c7e2b323a7eef43c1d2e98b8742", "message": "SLIM-2597 improved error handling", "committedDate": "2020-12-15T07:42:05Z", "type": "commit"}, {"oid": "f996f53ea2f83f13156f3ec51cd36dccedb551e0", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/f996f53ea2f83f13156f3ec51cd36dccedb551e0", "message": "SLIM-2597 improved error handling", "committedDate": "2020-12-15T09:32:50Z", "type": "commit"}, {"oid": "30f08ec2022ff2e1360a9adb382a0843977d1661", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/30f08ec2022ff2e1360a9adb382a0843977d1661", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-12-16T13:54:23Z", "type": "commit"}, {"oid": "522519a07ab5da9dff70d5a19d03241d52043a97", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/522519a07ab5da9dff70d5a19d03241d52043a97", "message": "Test only add meter", "committedDate": "2020-12-17T08:33:03Z", "type": "commit"}, {"oid": "ee07b18fb34cda88d8e134059b2e2527c3dc5e84", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/ee07b18fb34cda88d8e134059b2e2527c3dc5e84", "message": "SLIM-2597 changed loggings that don't show up in logs", "committedDate": "2020-12-17T09:14:18Z", "type": "commit"}, {"oid": "b94f259fc83c653d17bfa98c14f60356d26f1e78", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/b94f259fc83c653d17bfa98c14f60356d26f1e78", "message": "SLIM-2597 bugfix: installation requires key activation as well", "committedDate": "2020-12-17T09:16:28Z", "type": "commit"}, {"oid": "a2adb63fdc7a5eb4f25047a961cf59f1c7d81d6a", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/a2adb63fdc7a5eb4f25047a961cf59f1c7d81d6a", "message": "Merge branch 'SLIM-2597-Implement-secret-management-extra-functionality' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-12-17T09:25:42Z", "type": "commit"}, {"oid": "ed128b6bf5a68ecdd98c65149f175c6c3d792431", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/ed128b6bf5a68ecdd98c65149f175c6c3d792431", "message": "SLIM-2597 added error handling code & unit tests for addMeter()", "committedDate": "2020-12-17T11:04:42Z", "type": "commit"}, {"oid": "0d7cb134736f870215e2f64a9a78712e51104f21", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/0d7cb134736f870215e2f64a9a78712e51104f21", "message": "SLIM-2597 reverted to correct test implementation", "committedDate": "2020-12-17T11:05:31Z", "type": "commit"}, {"oid": "ab6611331362f40ab0a0d0717a9a89a6cc179590", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/ab6611331362f40ab0a0d0717a9a89a6cc179590", "message": "Revert \"SLIM-2597 reverted to correct test implementation\"\n\nThis reverts commit 0d7cb134", "committedDate": "2020-12-17T11:14:35Z", "type": "commit"}, {"oid": "aad83a4ff3f419b46c058aa98a7c772f25e4a329", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/aad83a4ff3f419b46c058aa98a7c772f25e4a329", "message": "SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-08-10T16:52:03Z", "type": "commit"}, {"oid": "92505bd596c560b37d39c92ee06ef86cae743efe", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/92505bd596c560b37d39c92ee06ef86cae743efe", "message": "SLIM-2585-improve-Secret-Management-related-exeption-handling", "committedDate": "2020-08-11T12:50:25Z", "type": "commit"}, {"oid": "29332318c26597d383f0866d6fcb516519277d71", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/29332318c26597d383f0866d6fcb516519277d71", "message": "SLIM-2585-improve-Secret-Management-related-exeption-handling", "committedDate": "2020-08-18T08:50:07Z", "type": "commit"}, {"oid": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "message": "SLIM-2597 initial code for 2-stage secret updates (store & activate)", "committedDate": "2020-09-16T12:18:47Z", "type": "commit"}, {"oid": "e328835a21e6c66c94deee1559e102203c8a73af", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/e328835a21e6c66c94deee1559e102203c8a73af", "message": "SLIM-2597 fixed compilation errors for tests (test failures not fixed yet)", "committedDate": "2020-09-16T12:58:24Z", "type": "commit"}, {"oid": "62dccb5a1a2ffb23e109c11a803c8573927651f1", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/62dccb5a1a2ffb23e109c11a803c8573927651f1", "message": "SLIM-2597 reverted to old WSDL design (multiple secret types per call) and added 'generateAndStoreSecrets'", "committedDate": "2020-09-16T13:46:38Z", "type": "commit"}, {"oid": "3036acd028ad8099c3b8f6af2df1c2f67d76b8ef", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/3036acd028ad8099c3b8f6af2df1c2f67d76b8ef", "message": "reverted multi-typed soap operations, added 'hasNewKey'-operation (compiles correctly, but most tests fail)", "committedDate": "2020-09-17T13:02:57Z", "type": "commit"}, {"oid": "94e63058d388392b7bf2745d334a0bae21f61ea3", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/94e63058d388392b7bf2745d334a0bae21f61ea3", "message": "fixed all broken tests", "committedDate": "2020-09-21T12:49:50Z", "type": "commit"}, {"oid": "2159e9a08463bd3a0175cc18eb0487988b3f1769", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/2159e9a08463bd3a0175cc18eb0487988b3f1769", "message": "added testcases for new functionality (status, activate, hasNewSecret)", "committedDate": "2020-09-21T15:08:49Z", "type": "commit"}, {"oid": "8af13299b158a50968b5da23c237809b0d7cce88", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/8af13299b158a50968b5da23c237809b0d7cce88", "message": "SLIM-2597 added secrets to response of generateAndStoreSecrets", "committedDate": "2020-09-22T10:51:53Z", "type": "commit"}, {"oid": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "message": "SLIM-2597-protocol-adapter-now-uses-secret-management-for-all-its-functions", "committedDate": "2020-09-22T17:19:17Z", "type": "commit"}, {"oid": "ddff301afd3f5b8376b0aadce3a4187dd140efcf", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/ddff301afd3f5b8376b0aadce3a4187dd140efcf", "message": "SLIM-2597-protocol-adapter-now-uses-secret-management-for-all-its-functions", "committedDate": "2020-09-23T10:39:31Z", "type": "commit"}, {"oid": "59202c61ba4037d507e82f130d68cb775a657e27", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/59202c61ba4037d507e82f130d68cb775a657e27", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-09-23T11:20:00Z", "type": "commit"}, {"oid": "96e99e9e3693f7e695e0851a4f430b4d73dda8b5", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/96e99e9e3693f7e695e0851a4f430b4d73dda8b5", "message": "SLIM-2597-temp-fix-for-cucumbertests", "committedDate": "2020-09-23T14:37:04Z", "type": "commit"}, {"oid": "91dbb37ef8c1efcda98e1ca80f3f96f5c9da6232", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/91dbb37ef8c1efcda98e1ca80f3f96f5c9da6232", "message": "SLIM-2597-protocol-adapter-now-uses-secret-management-for-all-its-functions", "committedDate": "2020-09-24T10:28:18Z", "type": "commit"}, {"oid": "d764519eca7476c2fbd4216c6733fc6f55a6d30e", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/d764519eca7476c2fbd4216c6733fc6f55a6d30e", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-09-24T15:49:22Z", "type": "commit"}, {"oid": "2ca96e32057ac2e9652cadef08dbd2632722b501", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/2ca96e32057ac2e9652cadef08dbd2632722b501", "message": "SLIM-2597: added IT testcases", "committedDate": "2020-09-28T07:30:32Z", "type": "commit"}, {"oid": "dc3978657a033f506fc2ad076e1daa6ffc14b8a6", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/dc3978657a033f506fc2ad076e1daa6ffc14b8a6", "message": "SLIM-2597: setup for secret generation", "committedDate": "2020-09-28T07:45:02Z", "type": "commit"}, {"oid": "212af20585d65ae4da3d321b7ccdaa46fb275bc0", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/212af20585d65ae4da3d321b7ccdaa46fb275bc0", "message": "Merge branch 'SLIM-2597-Implement-secret-management-extra-functionality' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality\n\n\u0001 Conflicts:\n\u0001\tosgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptionDelegate.java", "committedDate": "2020-09-28T07:46:01Z", "type": "commit"}, {"oid": "d5d0bccd0f9312ee2b21a345358604b4e2ed687b", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/d5d0bccd0f9312ee2b21a345358604b4e2ed687b", "message": "SLIM-2597-protocol-adapter-now-uses-secret-management-for-all-its-functions", "committedDate": "2020-09-30T09:37:00Z", "type": "commit"}, {"oid": "48f94738f3140d957048fe261b4be5bda3e90ddf", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/48f94738f3140d957048fe261b4be5bda3e90ddf", "message": "Added encrypted in-memory secrets to service; separated RsaEncrypter from encryption provider; added test cases, IT cases", "committedDate": "2020-10-06T16:21:27Z", "type": "commit"}, {"oid": "888761601c8492b82a72285caf413011ab3b99e0", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/888761601c8492b82a72285caf413011ab3b99e0", "message": "Changes resulting from changes in shared/osgp-ws-secret-mgmt", "committedDate": "2020-10-06T16:28:19Z", "type": "commit"}, {"oid": "ea6c152c680d716f568d143d70c1910a4b05e062", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/ea6c152c680d716f568d143d70c1910a4b05e062", "message": "Merge branch 'SLIM-2597-Implement-secret-management-extra-functionality' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-10-06T16:28:46Z", "type": "commit"}, {"oid": "28e35f8e83330afe62c76944ea1fb88f3ff1f464", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/28e35f8e83330afe62c76944ea1fb88f3ff1f464", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-10-06T16:30:27Z", "type": "commit"}, {"oid": "6c67f96b5b0a0172f606d7683ca2c3a887e21bb2", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/6c67f96b5b0a0172f606d7683ca2c3a887e21bb2", "message": "Added Flyway script for added column 'secret_status'", "committedDate": "2020-10-12T16:47:00Z", "type": "commit"}, {"oid": "db4ef46ae5ce0bac840ce7df1675cc1e247fc807", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/db4ef46ae5ce0bac840ce7df1675cc1e247fc807", "message": "SLIM-2597 code cleanup", "committedDate": "2020-10-16T10:30:47Z", "type": "commit"}, {"oid": "bb5fbeecd6d0fed2caede8f97c43e419da411417", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/bb5fbeecd6d0fed2caede8f97c43e419da411417", "message": "SLIM-2597: first implementation (encryption as-is, to be refactored potentially)", "committedDate": "2020-10-16T19:24:02Z", "type": "commit"}, {"oid": "6fe6e1159a28f42690818e72df8fbb76f52d0852", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/6fe6e1159a28f42690818e72df8fbb76f52d0852", "message": "SLIM-2597: fix incorrect encryption, added service test", "committedDate": "2020-10-18T20:37:00Z", "type": "commit"}, {"oid": "6346b40c0d3d35a610b3a02e4454a09f1f99fec1", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/6346b40c0d3d35a610b3a02e4454a09f1f99fec1", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-10-18T20:37:28Z", "type": "commit"}, {"oid": "98ba0b2395d33ee42fac88ec89d30f5bd13e3b0f", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/98ba0b2395d33ee42fac88ec89d30f5bd13e3b0f", "message": "SLIM-2597 fixed SQL errors (column secret_status NULL)", "committedDate": "2020-10-19T09:15:39Z", "type": "commit"}, {"oid": "e8648491d7a5109066b2d7645731ba368ad74018", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/e8648491d7a5109066b2d7645731ba368ad74018", "message": "SLIM-2597: added unit test cases", "committedDate": "2020-10-21T08:57:51Z", "type": "commit"}, {"oid": "fbdb92d61e267dcd963e7490941e8b628efeb594", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/fbdb92d61e267dcd963e7490941e8b628efeb594", "message": "SLIM-2597: add SOAP message 'getNewKeys' for recovery process", "committedDate": "2020-10-21T08:59:48Z", "type": "commit"}, {"oid": "1fd78bc33793803364144e6a3e31f5f26677b99e", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/1fd78bc33793803364144e6a3e31f5f26677b99e", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-10-21T09:00:12Z", "type": "commit"}, {"oid": "2c04c4112f30f97ad747702a8bfb9b96da670249", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/2c04c4112f30f97ad747702a8bfb9b96da670249", "message": "code cleanup & logging improvement", "committedDate": "2020-10-21T12:59:24Z", "type": "commit"}, {"oid": "0851dea794b4ff75f7c452b02ad8078960868128", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/0851dea794b4ff75f7c452b02ad8078960868128", "message": "code cleanup", "committedDate": "2020-10-21T13:00:15Z", "type": "commit"}, {"oid": "4907e8e319e25c4244e13387cf346c816ff1037a", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/4907e8e319e25c4244e13387cf346c816ff1037a", "message": "improved cucumber tests, logging and exception handling", "committedDate": "2020-10-21T15:05:31Z", "type": "commit"}, {"oid": "57613962e0d46b3e399591f7814d3b9733ac1078", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/57613962e0d46b3e399591f7814d3b9733ac1078", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality\n\n\u0001 Conflicts:\n\u0001\tosgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetEncryptionKeyExchangeOnGMeterCommandExecutor.java", "committedDate": "2020-10-21T15:25:12Z", "type": "commit"}, {"oid": "1bfc9d37938969b827ee32c6f16610e78c38383d", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/1bfc9d37938969b827ee32c6f16610e78c38383d", "message": "SLIM-2597: merge changes", "committedDate": "2020-10-21T16:51:11Z", "type": "commit"}, {"oid": "77db23365fdc5b1664d8ffe71738aa767bafc797", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/77db23365fdc5b1664d8ffe71738aa767bafc797", "message": "SLIM-2597: nasty little bug fix", "committedDate": "2020-10-21T17:40:59Z", "type": "commit"}, {"oid": "237bb59786e42bb10cb13fe1db647701066a0c4e", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/237bb59786e42bb10cb13fe1db647701066a0c4e", "message": "Added secret mgt config (for use of repositories)", "committedDate": "2020-10-22T10:33:33Z", "type": "commit"}, {"oid": "0a5b622d5c0afe81f4c75a9c587fb5738c64164b", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/0a5b622d5c0afe81f4c75a9c587fb5738c64164b", "message": "replaced use of converter with direct enum-creation", "committedDate": "2020-10-22T10:36:17Z", "type": "commit"}, {"oid": "a8ab85c2c5476b13b7a216541122824cbbb5b819", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/a8ab85c2c5476b13b7a216541122824cbbb5b819", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-10-22T10:36:37Z", "type": "commit"}, {"oid": "65a69440fabc91d6908570455790bdc5a7078ec0", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/65a69440fabc91d6908570455790bdc5a7078ec0", "message": "fixed DB name", "committedDate": "2020-10-22T11:55:21Z", "type": "commit"}, {"oid": "8013d13a5dfe19ab804b6f53a4e48da9ad06c263", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/8013d13a5dfe19ab804b6f53a4e48da9ad06c263", "message": "Smart Meter E keys reencrypted to match length 64", "committedDate": "2020-10-22T12:19:14Z", "type": "commit"}, {"oid": "16a1c6501243c9241cf88552f04b8cbb7f264d98", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/16a1c6501243c9241cf88552f04b8cbb7f264d98", "message": "Merge branch 'SLIM-2597-Implement-secret-management-extra-functionality' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-10-22T12:19:58Z", "type": "commit"}, {"oid": "ee6b8246b480cb333ca63832ab8eb99a06068e46", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/ee6b8246b480cb333ca63832ab8eb99a06068e46", "message": "Adapt G-meter keys too", "committedDate": "2020-10-22T12:32:02Z", "type": "commit"}, {"oid": "1b865ba81923b501555a4ee23eb72b06eed7eb19", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/1b865ba81923b501555a4ee23eb72b06eed7eb19", "message": "improved error message", "committedDate": "2020-10-22T15:18:39Z", "type": "commit"}, {"oid": "ef2a8ff094bb9f7cd59bf8499abd827686cb2fad", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/ef2a8ff094bb9f7cd59bf8499abd827686cb2fad", "message": "Merge branch 'SLIM-2597-Implement-secret-management-extra-functionality' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-10-22T15:19:12Z", "type": "commit"}, {"oid": "4a2eeeb3e53f54a335b40ce78e50e63c10797299", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/4a2eeeb3e53f54a335b40ce78e50e63c10797299", "message": "build logging change. DO NOT PUSH!", "committedDate": "2020-10-27T09:25:05Z", "type": "commit"}, {"oid": "14c3d03cbc2cccf854198d2563e8b4a3844841e6", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/14c3d03cbc2cccf854198d2563e8b4a3844841e6", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-10-27T10:38:11Z", "type": "commit"}, {"oid": "01a127db11f6325ea226a93261f43e86b3d15173", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/01a127db11f6325ea226a93261f43e86b3d15173", "message": "SLIM-2597 improved exception message", "committedDate": "2020-10-27T13:31:05Z", "type": "commit"}, {"oid": "1f6b7a3e53450fb63a0a876780e866f721a27948", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/1f6b7a3e53450fb63a0a876780e866f721a27948", "message": "SLIM-2597 improved properties comments", "committedDate": "2020-10-27T13:33:03Z", "type": "commit"}, {"oid": "334989708907a36471c81051b86994dd059499aa", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/334989708907a36471c81051b86994dd059499aa", "message": "SLIM-2597 set provider from HSM to JRE; DO NOT MERGE!?", "committedDate": "2020-10-27T14:05:26Z", "type": "commit"}, {"oid": "45e9f6f96c5ec51fb3e18fc9f5303406d50296ac", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/45e9f6f96c5ec51fb3e18fc9f5303406d50296ac", "message": "SLIM-2597 bugfix (use secret's provider type instead of configured); reset configured provider type to HSM", "committedDate": "2020-10-27T16:17:55Z", "type": "commit"}, {"oid": "04d6eb0acfd61f742c7ce81ed9807bcf241aeeff", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/04d6eb0acfd61f742c7ce81ed9807bcf241aeeff", "message": "SLIM-2597 code refactor/improvement", "committedDate": "2020-10-27T17:49:38Z", "type": "commit"}, {"oid": "5fb986aeef60c16267bbb67f82dba53e9900dd7a", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/5fb986aeef60c16267bbb67f82dba53e9900dd7a", "message": "SLIM-2597 truncate logs instead of deleting", "committedDate": "2020-10-28T11:52:58Z", "type": "commit"}, {"oid": "21c8f94655cbb0db9a7ee6117b9f1c19dd187846", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/21c8f94655cbb0db9a7ee6117b9f1c19dd187846", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-10-28T14:56:33Z", "type": "commit"}, {"oid": "4da941b4462a0a11a1d7460db11b953893d229fd", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/4da941b4462a0a11a1d7460db11b953893d229fd", "message": "SLIM-2587 removed @Skip for tests related to key mgmt", "committedDate": "2020-10-29T16:12:40Z", "type": "commit"}, {"oid": "e8ed9a3a3fbc04d7e59041addb83a3bd2ae51df2", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/e8ed9a3a3fbc04d7e59041addb83a3bd2ae51df2", "message": "SLIM-2587 refactored cucumber setup to work in line with secret-mgmt", "committedDate": "2020-10-29T16:13:36Z", "type": "commit"}, {"oid": "b8338f8aa89408f4a6c2ef078eb9ba6628de950f", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/b8338f8aa89408f4a6c2ef078eb9ba6628de950f", "message": "SLIM-2597 marked repository as deprecated because of new secret-mgmt", "committedDate": "2020-10-29T16:16:20Z", "type": "commit"}, {"oid": "c9ea277445bdc9957e464173410df6954861e2a2", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/c9ea277445bdc9957e464173410df6954861e2a2", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-10-29T16:16:53Z", "type": "commit"}, {"oid": "5956b27832177d33e79d219c5f684c1b34800258", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/5956b27832177d33e79d219c5f684c1b34800258", "message": "SLIM-2587 fix cucumber tests", "committedDate": "2020-11-02T12:44:30Z", "type": "commit"}, {"oid": "36485d9ddd252985dd1814afda3ba6508cbdef6e", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/36485d9ddd252985dd1814afda3ba6508cbdef6e", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-11-02T12:44:52Z", "type": "commit"}, {"oid": "76145a0fbfbae2dba2433ee1ef5cc8414caadd73", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/76145a0fbfbae2dba2433ee1ef5cc8414caadd73", "message": "SLIM-2587 fix cucumber tests", "committedDate": "2020-11-03T12:51:13Z", "type": "commit"}, {"oid": "ab3598e94224f4b5de09234566e0171da96abe61", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/ab3598e94224f4b5de09234566e0171da96abe61", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-11-03T12:51:36Z", "type": "commit"}, {"oid": "4998f91d8e08c85eb498881c6533bc18bc4f30da", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/4998f91d8e08c85eb498881c6533bc18bc4f30da", "message": "SLIM-2587 fix cucumber tests", "committedDate": "2020-11-03T15:14:23Z", "type": "commit"}, {"oid": "70fb3e5753894714808e82b4e3f1c13ca0b14515", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/70fb3e5753894714808e82b4e3f1c13ca0b14515", "message": "SLIM-2587 fix cucumber tests", "committedDate": "2020-11-04T12:53:01Z", "type": "commit"}, {"oid": "7700e511023784c381d9d8a3885b9b603e8d5436", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/7700e511023784c381d9d8a3885b9b603e8d5436", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2597-Implement-secret-management-extra-functionality", "committedDate": "2020-11-04T12:53:22Z", "type": "commit"}, {"oid": "479cdf1629b54dd22785264aafc3cb7fea27cd71", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/479cdf1629b54dd22785264aafc3cb7fea27cd71", "message": "SLIM-2587 fixed unsupported error (unmodifiable list)", "committedDate": "2020-11-04T13:47:09Z", "type": "commit"}, {"oid": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/d6b0e667f6214c5a1511a5ef114ce190fb948125", "message": "SLIM-2587 changed custom test annotation", "committedDate": "2020-11-04T13:49:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2Njc5Ng==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517366796", "bodyText": "Remove the literal \"false\" boolean value.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:24Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java", "diffHunk": "@@ -83,11 +83,11 @@ public HttpsUrlConnectionMessageSender httpsUrlConnectionMessageSender() throws\n         HttpsUrlConnectionMessageSender httpsUrlConnectionMessageSender =\n                 new HttpsUrlConnectionMessageSender();\n         // set the trust store(s)\n-        httpsUrlConnectionMessageSender.setTrustManagers(trustManagersFactoryBean().getObject());\n+        httpsUrlConnectionMessageSender.setTrustManagers(this.trustManagersFactoryBean().getObject());\n         // set the key store(s)\n-        httpsUrlConnectionMessageSender.setKeyManagers(keyManagersFactoryBean().getObject());\n+        httpsUrlConnectionMessageSender.setKeyManagers(this.keyManagersFactoryBean().getObject());\n \n-        if (Boolean.parseBoolean(useHostNameVerifier) == false) {\n+        if (Boolean.parseBoolean(this.useHostNameVerifier) == false) {", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NjgxMg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517366812", "bodyText": "This block of commented-out lines of code should be removed.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:25Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/ReplaceKeyCommandExecutor.java", "diffHunk": "@@ -101,58 +107,65 @@ public ActionResponseDto executeBundleAction(final DlmsConnectionManager conn, f\n         LOGGER.info(\"Keys set on device :{}\", device.getDeviceIdentification());\n \n         SetKeysRequestDto setKeysRequestDto = (SetKeysRequestDto) actionRequestDto;\n+\n         if (!setKeysRequestDto.isGeneratedKeys()) {\n-            setKeysRequestDto = this.reEncryptKeys((SetKeysRequestDto) actionRequestDto);\n-        }\n+            //decrypt using RSA\n+            setKeysRequestDto = this.decryptRsaKeys((SetKeysRequestDto) actionRequestDto);\n+        } //else\n+        //if isGeneratedKeys() == true, then:\n+        // generated keys are unencrypted by the GenerateAndReplaceKeyCommandExecutor\n \n         final DlmsDevice devicePostSave = this.execute(conn, device, ReplaceKeyCommandExecutor\n                 .wrap(setKeysRequestDto.getAuthenticationKey(), KeyId.AUTHENTICATION_KEY,\n-                        SecurityKeyType.E_METER_AUTHENTICATION));\n+                        SecurityKeyType.E_METER_AUTHENTICATION, setKeysRequestDto.isGeneratedKeys()));\n \n         this.execute(conn, devicePostSave, ReplaceKeyCommandExecutor\n                 .wrap(setKeysRequestDto.getEncryptionKey(), KeyId.GLOBAL_UNICAST_ENCRYPTION_KEY,\n-                        SecurityKeyType.E_METER_ENCRYPTION));\n+                        SecurityKeyType.E_METER_ENCRYPTION, setKeysRequestDto.isGeneratedKeys()));\n \n         return new ActionResponseDto(REPLACE_KEYS + device.getDeviceIdentification() + WAS_SUCCESFULL);\n     }\n \n-    private SetKeysRequestDto reEncryptKeys(final SetKeysRequestDto setKeysRequestDto) throws FunctionalException {\n+    private SetKeysRequestDto decryptRsaKeys(final SetKeysRequestDto setKeysRequestDto) throws FunctionalException {\n         final byte[] reEncryptedAuthenticationKey = this.securityKeyService\n-                .reEncryptKey(setKeysRequestDto.getAuthenticationKey(), SecurityKeyType.E_METER_AUTHENTICATION);\n+                .rsaDecrypt(setKeysRequestDto.getAuthenticationKey());\n         final byte[] reEncryptedEncryptionKey = this.securityKeyService\n-                .reEncryptKey(setKeysRequestDto.getEncryptionKey(), SecurityKeyType.E_METER_ENCRYPTION);\n+                .rsaDecrypt(setKeysRequestDto.getEncryptionKey());\n \n         return new SetKeysRequestDto(reEncryptedAuthenticationKey, reEncryptedEncryptionKey);\n     }\n \n     @Override\n     public DlmsDevice execute(final DlmsConnectionManager conn, final DlmsDevice device,\n-            final ReplaceKeyCommandExecutor.KeyWrapper keyWrapper) throws OsgpException {\n+            final ReplaceKeyCommandExecutor.ReplaceKeyInput keyWrapper) throws OsgpException {\n+\n+        if (!keyWrapper.isGenerated()) {\n+            this.securityKeyService.storeNewKey(device.getDeviceIdentification(), keyWrapper.getSecurityKeyType(),\n+                    keyWrapper.getBytes());\n+        }\n \n-        final DlmsDevice devicePostSave = this.securityKeyService\n-                .storeNewKey(device, keyWrapper.getBytes(), keyWrapper.getSecurityKeyType());\n-        this.sendToDevice(conn, devicePostSave, keyWrapper);\n-        return this.securityKeyService.validateNewKey(devicePostSave, keyWrapper.getSecurityKeyType());\n+        this.sendToDevice(conn, device.getDeviceIdentification(), keyWrapper);\n+        this.securityKeyService.activateNewKey(device.getDeviceIdentification(), keyWrapper.getSecurityKeyType());\n+        return device;\n     }\n \n     /**\n      * Send the key to the device.\n      *\n      * @param conn\n      *         jDLMS connection.\n-     * @param device\n-     *         Device instance\n+     * @param deviceIdentification\n+     *         Device identification\n      * @param keyWrapper\n      *         Key data\n      */\n-    private void sendToDevice(final DlmsConnectionManager conn, final DlmsDevice device,\n-            final ReplaceKeyCommandExecutor.KeyWrapper keyWrapper) throws ProtocolAdapterException {\n+    private void sendToDevice(final DlmsConnectionManager conn, String deviceIdentification,\n+            final ReplaceKeyCommandExecutor.ReplaceKeyInput keyWrapper) throws ProtocolAdapterException {\n \n         try {\n-            final byte[] decryptedKey = this.securityKeyService\n-                    .decryptKey(keyWrapper.getBytes(), keyWrapper.securityKeyType);\n+            final byte[] decryptedKey = keyWrapper.getBytes(); //this.securityKeyService.aesDecryptKey(keyWrapper.getBytes());", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NjgyOA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517366828", "bodyText": "Remove the declaration of thrown exception 'org.opensmartgridplatform.shared.exceptionhandling.EncrypterException' which is a runtime exception.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:26Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/RsaEncrypter.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.shared.security;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Arrays;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+\n+//TODO merge with RsaEncryptionService; it is almost the same except for different configuration\n+//  refactor it to 1 single configurable class with 2 instances with different configurations\n+public class RsaEncrypter {\n+    private static final int BLOCK_SIZE = 16;\n+    private static final String ALG = \"RSA\";\n+    private static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n+\n+    private Key publicKey;\n+    private Key privateKey;\n+\n+    public void setPrivateKeyStore(File privateKeyStoreFile) throws EncrypterException {", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NjgzOQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517366839", "bodyText": "Complete the task associated to this TODO comment.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:27Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/RsaEncrypter.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.shared.security;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Arrays;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+\n+//TODO merge with RsaEncryptionService; it is almost the same except for different configuration", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQwOTM2OQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r558409369", "bodyText": "TODO comments should not be left in the code, For tasks to be completed outside of the scope of the story, a backlog item should be created.", "author": "bvdzwet", "createdAt": "2021-01-15T16:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NjgzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2Njg1Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517366852", "bodyText": "Immediately return this expression instead of assigning it to the temporary variable \"rsa\".", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:28Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/RsaEncrypter.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.shared.security;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Arrays;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+\n+//TODO merge with RsaEncryptionService; it is almost the same except for different configuration\n+//  refactor it to 1 single configurable class with 2 instances with different configurations\n+public class RsaEncrypter {\n+    private static final int BLOCK_SIZE = 16;\n+    private static final String ALG = \"RSA\";\n+    private static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n+\n+    private Key publicKey;\n+    private Key privateKey;\n+\n+    public void setPrivateKeyStore(File privateKeyStoreFile) throws EncrypterException {\n+        try {\n+            byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n+            PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n+            this.privateKey = KeyFactory.getInstance(ALG).generatePrivate(privateKeySpec);\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            throw new EncrypterException(\"Could not get cipher\", e);\n+        }\n+    }\n+\n+    public void setPublicKeyStore(File publicKeyStoreFile) {\n+        try {\n+            byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n+            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n+            this.publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            throw new EncrypterException(\"Could not set public keystore\", e);\n+        }\n+    }\n+\n+    protected Cipher getCipher() {\n+        try {\n+            return Cipher.getInstance(ALGORITHM);\n+        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {\n+            throw new EncrypterException(\"Could not get cipher\", e);\n+        }\n+    }\n+\n+    protected Key getSecretEncryptionKey(int cipherMode) {\n+        return cipherMode == Cipher.ENCRYPT_MODE ? this.publicKey : this.privateKey;\n+    }\n+\n+    public byte[] encrypt(final byte[] secret) {\n+        if(secret==null) {\n+            throw new IllegalArgumentException(\"Can not encrypt NULL value\");\n+        }\n+        try {\n+            final Cipher cipher = this.getCipher();\n+            cipher.init(Cipher.ENCRYPT_MODE, this.getSecretEncryptionKey(Cipher.ENCRYPT_MODE));\n+            byte[] rsa = cipher.doFinal(secret);", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NjkzMg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517366932", "bodyText": "Call \"Optional#isPresent()\" before accessing the value.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:33Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java", "diffHunk": "@@ -18,146 +23,296 @@\n import org.apache.tomcat.util.buf.HexUtils;\n import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretStatus;\n import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n import org.springframework.beans.factory.annotation.Qualifier;\n-import org.springframework.data.domain.Page;\n-import org.springframework.data.domain.Pageable;\n import org.springframework.stereotype.Service;\n \n+/**\n+ * Service that manages secrets (store, retrieve, activate, generate).\n+ * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n+ * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n+ * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n+ * database corruption as a result of partially succeeded batch results.\n+ *\n+ * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n+ * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n+ * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n+ * by reencrypting the AES-encrypted secrets to RSA.\n+ */\n @Service\n public class SecretManagementService {\n+    //Internal datastructure to keep track of (intermediate) secret details\n+    private static class EncryptedTypedSecret {\n+        byte[] encryptedSecret;\n+        SecretType type;\n+        String encryptionKeyReference;  //NULL when RSA\n+        EncryptionProviderType encryptionProviderType;  //NULL when RSA\n+\n+        private EncryptedTypedSecret(SecretType type) {\n+            this.type = type;\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type) {\n+            this(secret, type, null, null);\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type, String encryptionKeyReference,\n+                EncryptionProviderType encryptionProviderType) {\n+            if (secret == null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+            } else if (type == null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+            }\n+            this.encryptedSecret = secret;\n+            this.type = type;\n+            this.encryptionKeyReference = encryptionKeyReference;\n+            this.encryptionProviderType = encryptionProviderType;\n+        }\n+\n+        private boolean hasNullSecret() {\n+            return this.encryptedSecret == null;\n+        }\n+\n+        private TypedSecret toTypedSecret() {\n+            return new TypedSecret(this.encryptedSecret, this.type);\n+        }\n+\n+        private static EncryptedTypedSecret getNullInstance(SecretType type) {\n+            return new EncryptedTypedSecret(type);\n+        }\n+\n+        private static EncryptedTypedSecret fromDbEncryptedSecret(DbEncryptedSecret dbEncryptedSecret) {\n+            byte[] aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+            EncryptionProviderType providerType = dbEncryptedSecret.getEncryptionKeyReference()\n+                                                                   .getEncryptionProviderType();\n+            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference,\n+                    providerType);\n+        }\n+    }\n+\n     private final EncryptionDelegate encryptionDelegate;\n     private final EncryptionProviderType encryptionProviderType;\n     private final DbEncryptedSecretRepository secretRepository;\n     private final DbEncryptionKeyRepository keyRepository;\n+    private final RsaEncrypter rsaEncrypter;\n \n     public SecretManagementService(\n             @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n             final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository) {\n+            final DbEncryptionKeyRepository keyRepository, RsaEncrypter rsaEncrypter) {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n         this.encryptionProviderType = encryptionProviderType;\n         this.secretRepository = secretRepository;\n         this.keyRepository = keyRepository;\n+        this.rsaEncrypter = rsaEncrypter;\n     }\n \n-    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        //@formatter:off\n-        secrets.stream()\n-                .map(t -> this.validateSecret(deviceIdentification, t))\n-                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n-                .forEach(this.secretRepository::save);\n-        //@formatter:on\n-    }\n-\n-    private DbEncryptionKeyReference getKey() {\n+    private DbEncryptionKeyReference getCurrentKey() {\n         final Date now = new Date();\n-        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(now,\n-                this.encryptionProviderType, Pageable.unpaged());\n-        if (keyRefsPage.getSize() > 1) {\n+        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n+                .findByTypeAndValid(this.encryptionProviderType, now);\n+        if (keyRefs.size() > 1) {\n             throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        } else if (keyRefs.size() == 0) {\n+            throw new NoSuchElementException(\"No encryption key found that is valid at \" + now);\n         }\n-        return keyRefsPage.stream().findFirst().orElseThrow(\n-                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+        return keyRefs.get(0);\n     }\n \n-    private TypedSecret validateSecret(final String deviceIdentification, final TypedSecret secret) {\n-        if (secret.getSecret() == null) {\n+    private DbEncryptionKeyReference getKeyByReference(String reference) {\n+        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n+    }\n+\n+    private EncryptedTypedSecret validateNewSecret(final String deviceIdentification,\n+            final EncryptedTypedSecret secret) {\n+        this.checkNrNewSecretsOfType(deviceIdentification, secret.type, 0);\n+        if (secret.hasNullSecret()) {\n             throw new IllegalArgumentException(\"No secret string set\");\n-        } else if (secret.getSecretType() == null) {\n-            throw new IllegalArgumentException(\"No secret type set\");\n-        } else if (this.isIdenticalToCurrent(deviceIdentification, secret)) {\n-            throw new IllegalArgumentException(\n-                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n-                            secret.getSecretType().name()));\n         }\n         return secret;\n     }\n \n-    private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n-        final Optional<TypedSecret> current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n-        return current.isPresent() && current.get().getSecret().equals(secret.getSecret());\n+    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n+            final DbEncryptionKeyReference keyReference) {\n+        final Date now = new Date();\n+        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+        dbEncryptedSecret.setSecretType(secret.type);\n+        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+        dbEncryptedSecret.setCreationTime(now);\n+        return dbEncryptedSecret;\n     }\n \n-    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n-                                              final DbEncryptionKeyReference keyReference) {\n-        final String secretString = typedSecret.getSecret();\n-        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n-        final Secret secret = new Secret(secretBytes);\n-        try {\n-            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n-            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-            dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-            dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n-            dbEncryptedSecret.setSecretType(typedSecret.getSecretType());\n-            dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-            dbEncryptedSecret.setCreationTime(new Date());\n-            return dbEncryptedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not create encrypted secret\", exc);\n-        }\n+    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n     }\n \n-    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+    public List<TypedSecret> retrieveNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+    }\n+\n+    private List<TypedSecret> doRetrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes,\n+            SecretStatus status) {\n+        return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream().map(this::reencryptAes2Rsa)\n+                   .map(EncryptedTypedSecret::toTypedSecret).collect(Collectors.toList());\n+    }\n+\n+    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n+            final List<SecretType> secretTypes, SecretStatus status) {\n         try {\n-            //@formatter:off\n-            return secretTypes.stream()\n-                    .map(secretType -> this.retrieveSecret(deviceIdentification, secretType))\n-                    .map(Optional::get)\n-                    .collect(Collectors.toList());\n-            //@formatter:on\n+            return secretTypes.stream().map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n+                              .collect(Collectors.toList());\n         } catch (final Exception exc) {\n             throw new IllegalStateException(\n-                    String.format(\"Something went wrong retrieving secrets for device %s\", deviceIdentification), exc);\n+                    String.format(\"Something went wrong retrieving secrets for device %s: %s\", deviceIdentification,\n+                            exc.toString()), exc);\n         }\n     }\n \n-    public Optional<TypedSecret> retrieveSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Date now = new Date();\n-        final Long secretId = this.secretRepository.findIdOfValidMostRecent(deviceIdentification, secretType.name(),\n-                now);\n-        if (secretId == null) {\n+    private EncryptedTypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType,\n+            SecretStatus status) {\n+        final Optional<DbEncryptedSecret> optional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n+        if (optional.isPresent()) {\n+            return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n+        } else {\n+            return EncryptedTypedSecret.getNullInstance(secretType);\n+        }\n+    }\n+\n+    private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n+            final SecretType secretType, final SecretStatus secretStatus) {\n+        final List<DbEncryptedSecret> secretsList = this.secretRepository\n+                .findSecrets(deviceIdentification, secretType, secretStatus);\n+        boolean onlySingleSecretAllowed =\n+                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n+        if (secretsList.size() == 0) {\n             return Optional.empty();\n+        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n+            throw new IllegalStateException(\n+                    String.format(msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n         }\n-        final TypedSecret typedSecret = this.getTypedSecret(this.secretRepository.findById(secretId));\n-        return Optional.of(typedSecret);\n+        return Optional.of(secretsList.iterator().next());\n     }\n \n-    private TypedSecret getTypedSecret(final Optional<DbEncryptedSecret> dbEncryptedSecret) {\n-        if (dbEncryptedSecret.isPresent()) {\n-            final DbEncryptedSecret secret = dbEncryptedSecret.get();\n-            final DbEncryptionKeyReference keyReference = secret.getEncryptionKeyReference();\n-            if (keyReference == null) {\n-                throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n-            }\n-            final byte[] secretBytes = HexUtils.fromHexString(secret.getEncodedSecret());\n-            final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n-                    secretBytes);\n-            return this.createTypedSecret(secret, keyReference, encryptedSecret);\n-        } else {    //Should never happen because of stream mapping in retrieveSecrets()\n-            throw new IllegalStateException(\"Could not create typed secret for NULL secret\");\n+    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n+        List<EncryptedTypedSecret> aesSecrets = secrets.stream().map(ts -> new EncryptedTypedSecret(ts.getSecret(),\n+                ts.getSecretType())).map(this::reencryptRsa2Aes).collect(toList());\n+        this.storeAesSecrets(deviceIdentification, aesSecrets);\n+    }\n+\n+    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n+        secrets.stream().map(ets -> this.validateNewSecret(deviceIdentification, ets)).map(ets -> this\n+                .createDbEncrypted(deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n+               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+    }\n+\n+    public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n+        secretTypes.stream().map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+                   .flatMap(Collection::stream).collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+    }\n+\n+    public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n+        return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n+    }\n+\n+    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n+            final SecretType secretType) {\n+        List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+        final Optional<DbEncryptedSecret> activeSecretOptional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+        if (activeSecretOptional.isPresent()) {\n+            final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n+            currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n+            updatedSecrets.add(currentSecret);\n+        }\n+        final DbEncryptedSecret newSecret = this", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2Njk1Mw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517366953", "bodyText": "Use isEmpty() to check whether the collection is empty or not.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:34Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java", "diffHunk": "@@ -18,146 +23,296 @@\n import org.apache.tomcat.util.buf.HexUtils;\n import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretStatus;\n import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n import org.springframework.beans.factory.annotation.Qualifier;\n-import org.springframework.data.domain.Page;\n-import org.springframework.data.domain.Pageable;\n import org.springframework.stereotype.Service;\n \n+/**\n+ * Service that manages secrets (store, retrieve, activate, generate).\n+ * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n+ * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n+ * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n+ * database corruption as a result of partially succeeded batch results.\n+ *\n+ * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n+ * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n+ * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n+ * by reencrypting the AES-encrypted secrets to RSA.\n+ */\n @Service\n public class SecretManagementService {\n+    //Internal datastructure to keep track of (intermediate) secret details\n+    private static class EncryptedTypedSecret {\n+        byte[] encryptedSecret;\n+        SecretType type;\n+        String encryptionKeyReference;  //NULL when RSA\n+        EncryptionProviderType encryptionProviderType;  //NULL when RSA\n+\n+        private EncryptedTypedSecret(SecretType type) {\n+            this.type = type;\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type) {\n+            this(secret, type, null, null);\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type, String encryptionKeyReference,\n+                EncryptionProviderType encryptionProviderType) {\n+            if (secret == null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+            } else if (type == null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+            }\n+            this.encryptedSecret = secret;\n+            this.type = type;\n+            this.encryptionKeyReference = encryptionKeyReference;\n+            this.encryptionProviderType = encryptionProviderType;\n+        }\n+\n+        private boolean hasNullSecret() {\n+            return this.encryptedSecret == null;\n+        }\n+\n+        private TypedSecret toTypedSecret() {\n+            return new TypedSecret(this.encryptedSecret, this.type);\n+        }\n+\n+        private static EncryptedTypedSecret getNullInstance(SecretType type) {\n+            return new EncryptedTypedSecret(type);\n+        }\n+\n+        private static EncryptedTypedSecret fromDbEncryptedSecret(DbEncryptedSecret dbEncryptedSecret) {\n+            byte[] aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+            EncryptionProviderType providerType = dbEncryptedSecret.getEncryptionKeyReference()\n+                                                                   .getEncryptionProviderType();\n+            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference,\n+                    providerType);\n+        }\n+    }\n+\n     private final EncryptionDelegate encryptionDelegate;\n     private final EncryptionProviderType encryptionProviderType;\n     private final DbEncryptedSecretRepository secretRepository;\n     private final DbEncryptionKeyRepository keyRepository;\n+    private final RsaEncrypter rsaEncrypter;\n \n     public SecretManagementService(\n             @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n             final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository) {\n+            final DbEncryptionKeyRepository keyRepository, RsaEncrypter rsaEncrypter) {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n         this.encryptionProviderType = encryptionProviderType;\n         this.secretRepository = secretRepository;\n         this.keyRepository = keyRepository;\n+        this.rsaEncrypter = rsaEncrypter;\n     }\n \n-    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        //@formatter:off\n-        secrets.stream()\n-                .map(t -> this.validateSecret(deviceIdentification, t))\n-                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n-                .forEach(this.secretRepository::save);\n-        //@formatter:on\n-    }\n-\n-    private DbEncryptionKeyReference getKey() {\n+    private DbEncryptionKeyReference getCurrentKey() {\n         final Date now = new Date();\n-        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(now,\n-                this.encryptionProviderType, Pageable.unpaged());\n-        if (keyRefsPage.getSize() > 1) {\n+        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n+                .findByTypeAndValid(this.encryptionProviderType, now);\n+        if (keyRefs.size() > 1) {\n             throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        } else if (keyRefs.size() == 0) {\n+            throw new NoSuchElementException(\"No encryption key found that is valid at \" + now);\n         }\n-        return keyRefsPage.stream().findFirst().orElseThrow(\n-                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+        return keyRefs.get(0);\n     }\n \n-    private TypedSecret validateSecret(final String deviceIdentification, final TypedSecret secret) {\n-        if (secret.getSecret() == null) {\n+    private DbEncryptionKeyReference getKeyByReference(String reference) {\n+        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n+    }\n+\n+    private EncryptedTypedSecret validateNewSecret(final String deviceIdentification,\n+            final EncryptedTypedSecret secret) {\n+        this.checkNrNewSecretsOfType(deviceIdentification, secret.type, 0);\n+        if (secret.hasNullSecret()) {\n             throw new IllegalArgumentException(\"No secret string set\");\n-        } else if (secret.getSecretType() == null) {\n-            throw new IllegalArgumentException(\"No secret type set\");\n-        } else if (this.isIdenticalToCurrent(deviceIdentification, secret)) {\n-            throw new IllegalArgumentException(\n-                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n-                            secret.getSecretType().name()));\n         }\n         return secret;\n     }\n \n-    private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n-        final Optional<TypedSecret> current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n-        return current.isPresent() && current.get().getSecret().equals(secret.getSecret());\n+    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n+            final DbEncryptionKeyReference keyReference) {\n+        final Date now = new Date();\n+        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+        dbEncryptedSecret.setSecretType(secret.type);\n+        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+        dbEncryptedSecret.setCreationTime(now);\n+        return dbEncryptedSecret;\n     }\n \n-    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n-                                              final DbEncryptionKeyReference keyReference) {\n-        final String secretString = typedSecret.getSecret();\n-        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n-        final Secret secret = new Secret(secretBytes);\n-        try {\n-            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n-            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-            dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-            dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n-            dbEncryptedSecret.setSecretType(typedSecret.getSecretType());\n-            dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-            dbEncryptedSecret.setCreationTime(new Date());\n-            return dbEncryptedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not create encrypted secret\", exc);\n-        }\n+    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n     }\n \n-    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+    public List<TypedSecret> retrieveNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+    }\n+\n+    private List<TypedSecret> doRetrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes,\n+            SecretStatus status) {\n+        return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream().map(this::reencryptAes2Rsa)\n+                   .map(EncryptedTypedSecret::toTypedSecret).collect(Collectors.toList());\n+    }\n+\n+    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n+            final List<SecretType> secretTypes, SecretStatus status) {\n         try {\n-            //@formatter:off\n-            return secretTypes.stream()\n-                    .map(secretType -> this.retrieveSecret(deviceIdentification, secretType))\n-                    .map(Optional::get)\n-                    .collect(Collectors.toList());\n-            //@formatter:on\n+            return secretTypes.stream().map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n+                              .collect(Collectors.toList());\n         } catch (final Exception exc) {\n             throw new IllegalStateException(\n-                    String.format(\"Something went wrong retrieving secrets for device %s\", deviceIdentification), exc);\n+                    String.format(\"Something went wrong retrieving secrets for device %s: %s\", deviceIdentification,\n+                            exc.toString()), exc);\n         }\n     }\n \n-    public Optional<TypedSecret> retrieveSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Date now = new Date();\n-        final Long secretId = this.secretRepository.findIdOfValidMostRecent(deviceIdentification, secretType.name(),\n-                now);\n-        if (secretId == null) {\n+    private EncryptedTypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType,\n+            SecretStatus status) {\n+        final Optional<DbEncryptedSecret> optional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n+        if (optional.isPresent()) {\n+            return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n+        } else {\n+            return EncryptedTypedSecret.getNullInstance(secretType);\n+        }\n+    }\n+\n+    private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n+            final SecretType secretType, final SecretStatus secretStatus) {\n+        final List<DbEncryptedSecret> secretsList = this.secretRepository\n+                .findSecrets(deviceIdentification, secretType, secretStatus);\n+        boolean onlySingleSecretAllowed =\n+                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n+        if (secretsList.size() == 0) {", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2Njk2MA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517366960", "bodyText": "Use isEmpty() to check whether the collection is empty or not.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:35Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java", "diffHunk": "@@ -18,146 +23,296 @@\n import org.apache.tomcat.util.buf.HexUtils;\n import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretStatus;\n import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n import org.springframework.beans.factory.annotation.Qualifier;\n-import org.springframework.data.domain.Page;\n-import org.springframework.data.domain.Pageable;\n import org.springframework.stereotype.Service;\n \n+/**\n+ * Service that manages secrets (store, retrieve, activate, generate).\n+ * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n+ * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n+ * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n+ * database corruption as a result of partially succeeded batch results.\n+ *\n+ * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n+ * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n+ * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n+ * by reencrypting the AES-encrypted secrets to RSA.\n+ */\n @Service\n public class SecretManagementService {\n+    //Internal datastructure to keep track of (intermediate) secret details\n+    private static class EncryptedTypedSecret {\n+        byte[] encryptedSecret;\n+        SecretType type;\n+        String encryptionKeyReference;  //NULL when RSA\n+        EncryptionProviderType encryptionProviderType;  //NULL when RSA\n+\n+        private EncryptedTypedSecret(SecretType type) {\n+            this.type = type;\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type) {\n+            this(secret, type, null, null);\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type, String encryptionKeyReference,\n+                EncryptionProviderType encryptionProviderType) {\n+            if (secret == null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+            } else if (type == null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+            }\n+            this.encryptedSecret = secret;\n+            this.type = type;\n+            this.encryptionKeyReference = encryptionKeyReference;\n+            this.encryptionProviderType = encryptionProviderType;\n+        }\n+\n+        private boolean hasNullSecret() {\n+            return this.encryptedSecret == null;\n+        }\n+\n+        private TypedSecret toTypedSecret() {\n+            return new TypedSecret(this.encryptedSecret, this.type);\n+        }\n+\n+        private static EncryptedTypedSecret getNullInstance(SecretType type) {\n+            return new EncryptedTypedSecret(type);\n+        }\n+\n+        private static EncryptedTypedSecret fromDbEncryptedSecret(DbEncryptedSecret dbEncryptedSecret) {\n+            byte[] aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+            EncryptionProviderType providerType = dbEncryptedSecret.getEncryptionKeyReference()\n+                                                                   .getEncryptionProviderType();\n+            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference,\n+                    providerType);\n+        }\n+    }\n+\n     private final EncryptionDelegate encryptionDelegate;\n     private final EncryptionProviderType encryptionProviderType;\n     private final DbEncryptedSecretRepository secretRepository;\n     private final DbEncryptionKeyRepository keyRepository;\n+    private final RsaEncrypter rsaEncrypter;\n \n     public SecretManagementService(\n             @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n             final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository) {\n+            final DbEncryptionKeyRepository keyRepository, RsaEncrypter rsaEncrypter) {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n         this.encryptionProviderType = encryptionProviderType;\n         this.secretRepository = secretRepository;\n         this.keyRepository = keyRepository;\n+        this.rsaEncrypter = rsaEncrypter;\n     }\n \n-    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        //@formatter:off\n-        secrets.stream()\n-                .map(t -> this.validateSecret(deviceIdentification, t))\n-                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n-                .forEach(this.secretRepository::save);\n-        //@formatter:on\n-    }\n-\n-    private DbEncryptionKeyReference getKey() {\n+    private DbEncryptionKeyReference getCurrentKey() {\n         final Date now = new Date();\n-        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(now,\n-                this.encryptionProviderType, Pageable.unpaged());\n-        if (keyRefsPage.getSize() > 1) {\n+        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n+                .findByTypeAndValid(this.encryptionProviderType, now);\n+        if (keyRefs.size() > 1) {\n             throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        } else if (keyRefs.size() == 0) {", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2Njk3Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517366972", "bodyText": "Remove the declaration of thrown exception 'org.opensmartgridplatform.shared.exceptionhandling.EncrypterException' which is a runtime exception.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:36Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java", "diffHunk": "@@ -45,21 +46,25 @@ public JreEncryptionProvider(File keyStoreFile) {\n         }\n     }\n \n-    protected Cipher getCipher() {\n+    @Override\n+    protected Cipher getCipher() throws EncrypterException {", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2Njk4NQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517366985", "bodyText": "Remove the declaration of thrown exception 'org.opensmartgridplatform.shared.exceptionhandling.EncrypterException' which is a runtime exception.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:37Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java", "diffHunk": "@@ -36,7 +37,7 @@\n \n     private final byte[] key;\n \n-    public JreEncryptionProvider(File keyStoreFile) {\n+    public JreEncryptionProvider(File keyStoreFile) throws EncrypterException {", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NzAwMQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517367001", "bodyText": "Remove the declaration of thrown exception 'org.opensmartgridplatform.shared.exceptionhandling.EncrypterException' which is a runtime exception.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:37Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java", "diffHunk": "@@ -45,21 +46,25 @@ public JreEncryptionProvider(File keyStoreFile) {\n         }\n     }\n \n-    protected Cipher getCipher() {\n+    @Override\n+    protected Cipher getCipher() throws EncrypterException {\n         try {\n             return Cipher.getInstance(ALGORITHM, PROVIDER);\n         } catch (NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n             throw new EncrypterException(\"Could not get cipher\", e);\n         }\n     }\n \n-    protected Key getSecretEncryptionKey(String keyReference, int cipherMode) {\n+    @Override\n+    protected Key getSecretEncryptionKey(String keyReference, int cipherMode) throws EncrypterException {", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NzAwOQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517367009", "bodyText": "Remove the declaration of thrown exception 'org.opensmartgridplatform.shared.exceptionhandling.EncrypterException' which is a runtime exception.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:38Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java", "diffHunk": "@@ -72,15 +77,28 @@ public String getFormat() {\n \n             @Override\n             public byte[] getEncoded() {\n-                return key;\n+                return JreEncryptionProvider.this.key;\n             }\n         };\n     }\n \n+    @Override\n     protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n         return new IvParameterSpec(IV);\n     }\n \n+    @Override\n+    public byte[] generateAes128BitsSecret(String keyReference) throws EncrypterException {", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NzAyMQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517367021", "bodyText": "Remove the declaration of thrown exception 'org.opensmartgridplatform.shared.exceptionhandling.EncrypterException' which is a runtime exception.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:39Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/EncryptionProvider.java", "diffHunk": "@@ -8,13 +8,23 @@\n  */\n package org.opensmartgridplatform.shared.security.providers;\n \n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n \n public interface EncryptionProvider {\n-    EncryptedSecret encrypt(Secret secret, String keyReference);\n-    Secret decrypt(EncryptedSecret secret, String keyReference);\n+\n+    EncryptedSecret encrypt(byte[] secret, String keyReference) throws EncrypterException;", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NzAzNQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517367035", "bodyText": "Remove the declaration of thrown exception 'org.opensmartgridplatform.shared.exceptionhandling.EncrypterException' which is a runtime exception.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:40Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/EncryptionProvider.java", "diffHunk": "@@ -8,13 +8,23 @@\n  */\n package org.opensmartgridplatform.shared.security.providers;\n \n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n \n public interface EncryptionProvider {\n-    EncryptedSecret encrypt(Secret secret, String keyReference);\n-    Secret decrypt(EncryptedSecret secret, String keyReference);\n+\n+    EncryptedSecret encrypt(byte[] secret, String keyReference) throws EncrypterException;\n+    byte[] decrypt(EncryptedSecret secret, String keyReference) throws EncrypterException;", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NzA0OA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517367048", "bodyText": "Remove the declaration of thrown exception 'org.opensmartgridplatform.shared.exceptionhandling.EncrypterException' which is a runtime exception.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:41Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/EncryptionProvider.java", "diffHunk": "@@ -8,13 +8,23 @@\n  */\n package org.opensmartgridplatform.shared.security.providers;\n \n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n \n public interface EncryptionProvider {\n-    EncryptedSecret encrypt(Secret secret, String keyReference);\n-    Secret decrypt(EncryptedSecret secret, String keyReference);\n+\n+    EncryptedSecret encrypt(byte[] secret, String keyReference) throws EncrypterException;\n+    byte[] decrypt(EncryptedSecret secret, String keyReference) throws EncrypterException;\n+\n+    /**\n+     * Generate an AES-encrypted 128-bits secret\n+     * @param keyReference the reference to the key used for AES-encrypting the secret\n+     * @return the AES-encrypted secret\n+     * @throws EncrypterException when the key cannot be generated (with a specified algoritm) or when AES-encryption\n+     * goes wrong\n+     */\n+    byte[] generateAes128BitsSecret(String keyReference) throws EncrypterException;", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NzA1Ng==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517367056", "bodyText": "Remove the declaration of thrown exception 'org.opensmartgridplatform.shared.exceptionhandling.EncrypterException' which is a runtime exception.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:42Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java", "diffHunk": "@@ -28,28 +27,28 @@\n \n     public abstract EncryptionProviderType getType();\n \n-    protected abstract Cipher getCipher();\n+    protected abstract Cipher getCipher() throws EncrypterException;\n \n     protected abstract AlgorithmParameterSpec getAlgorithmParameterSpec();\n \n-    protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode);\n+    protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode) throws EncrypterException;", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NzA2NQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517367065", "bodyText": "Remove the declaration of thrown exception 'org.opensmartgridplatform.shared.exceptionhandling.EncrypterException' which is a runtime exception.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:43Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java", "diffHunk": "@@ -28,28 +27,28 @@\n \n     public abstract EncryptionProviderType getType();\n \n-    protected abstract Cipher getCipher();\n+    protected abstract Cipher getCipher() throws EncrypterException;\n \n     protected abstract AlgorithmParameterSpec getAlgorithmParameterSpec();\n \n-    protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode);\n+    protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode) throws EncrypterException;\n \n-    protected void setKeyFile(File keyFile) {\n+    protected void setKeyFile(final File keyFile) {\n         this.keyFile = keyFile;\n     }\n \n-    public EncryptedSecret encrypt(Secret secret, String keyReference) {\n+    public EncryptedSecret encrypt(final byte[] secret, final String keyReference) throws EncrypterException {\n         try {\n             final Cipher cipher = this.getCipher();\n             cipher.init(Cipher.ENCRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.ENCRYPT_MODE),\n                     this.getAlgorithmParameterSpec());\n-            return new EncryptedSecret(this.getType(), cipher.doFinal(secret.getSecret()));\n-        } catch (Exception e) {\n+            return new EncryptedSecret(this.getType(), cipher.doFinal(secret));\n+        } catch (final Exception e) {\n             throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n         }\n     }\n \n-    public Secret decrypt(EncryptedSecret secret, String keyReference) {\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) throws EncrypterException {", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NzA4MA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517367080", "bodyText": "Remove the declaration of thrown exception 'org.opensmartgridplatform.shared.exceptionhandling.EncrypterException' which is a runtime exception.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:44Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java", "diffHunk": "@@ -28,28 +27,28 @@\n \n     public abstract EncryptionProviderType getType();\n \n-    protected abstract Cipher getCipher();\n+    protected abstract Cipher getCipher() throws EncrypterException;\n \n     protected abstract AlgorithmParameterSpec getAlgorithmParameterSpec();\n \n-    protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode);\n+    protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode) throws EncrypterException;\n \n-    protected void setKeyFile(File keyFile) {\n+    protected void setKeyFile(final File keyFile) {\n         this.keyFile = keyFile;\n     }\n \n-    public EncryptedSecret encrypt(Secret secret, String keyReference) {\n+    public EncryptedSecret encrypt(final byte[] secret, final String keyReference) throws EncrypterException {", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NzA5MQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517367091", "bodyText": "Remove the declaration of thrown exception 'org.opensmartgridplatform.shared.exceptionhandling.EncrypterException' which is a runtime exception.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:45Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java", "diffHunk": "@@ -28,28 +27,28 @@\n \n     public abstract EncryptionProviderType getType();\n \n-    protected abstract Cipher getCipher();\n+    protected abstract Cipher getCipher() throws EncrypterException;", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NzA5OA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517367098", "bodyText": "Remove the declaration of thrown exception 'org.opensmartgridplatform.shared.exceptionhandling.EncrypterException' which is a runtime exception.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:46Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptionDelegate.java", "diffHunk": "@@ -8,7 +8,12 @@\n  */\n package org.opensmartgridplatform.shared.security;\n \n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+\n public interface EncryptionDelegate {\n-    EncryptedSecret encrypt(EncryptionProviderType encryptionProviderType, Secret secret, String keyReference);\n-    Secret decrypt(EncryptedSecret secret, String keyReference);\n+    EncryptedSecret encrypt(EncryptionProviderType encryptionProviderType, byte[] secret, String keyReference)\n+            throws EncrypterException;\n+    byte[] decrypt(EncryptedSecret secret, String keyReference) throws EncrypterException;", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NzEwNA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517367104", "bodyText": "Remove the declaration of thrown exception 'org.opensmartgridplatform.shared.exceptionhandling.EncrypterException' which is a runtime exception.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:47Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptionDelegate.java", "diffHunk": "@@ -8,7 +8,12 @@\n  */\n package org.opensmartgridplatform.shared.security;\n \n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+\n public interface EncryptionDelegate {\n-    EncryptedSecret encrypt(EncryptionProviderType encryptionProviderType, Secret secret, String keyReference);\n-    Secret decrypt(EncryptedSecret secret, String keyReference);\n+    EncryptedSecret encrypt(EncryptionProviderType encryptionProviderType, byte[] secret, String keyReference)\n+            throws EncrypterException;\n+    byte[] decrypt(EncryptedSecret secret, String keyReference) throws EncrypterException;\n+    byte[] generateAes128BitsSecret(EncryptionProviderType encryptionProviderType, String keyReference)\n+            throws EncrypterException;", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NzExNA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517367114", "bodyText": "Remove the declaration of thrown exception 'org.opensmartgridplatform.shared.exceptionhandling.EncrypterException' which is a runtime exception.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:47Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptionDelegate.java", "diffHunk": "@@ -8,7 +8,12 @@\n  */\n package org.opensmartgridplatform.shared.security;\n \n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+\n public interface EncryptionDelegate {\n-    EncryptedSecret encrypt(EncryptionProviderType encryptionProviderType, Secret secret, String keyReference);\n-    Secret decrypt(EncryptedSecret secret, String keyReference);\n+    EncryptedSecret encrypt(EncryptionProviderType encryptionProviderType, byte[] secret, String keyReference)\n+            throws EncrypterException;", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NzEyNg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517367126", "bodyText": "Remove the declaration of thrown exception 'org.opensmartgridplatform.shared.exceptionhandling.EncrypterException' which is a runtime exception.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:48Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java", "diffHunk": "@@ -45,63 +45,68 @@\n \n     private final KeyStore keyStore;\n \n-    public HsmEncryptionProvider(File keyStoreFile) {\n+    public HsmEncryptionProvider(final File keyStoreFile) throws EncrypterException {", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NzEzNQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517367135", "bodyText": "Remove the declaration of thrown exception 'org.opensmartgridplatform.shared.exceptionhandling.EncrypterException' which is a runtime exception.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:49Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java", "diffHunk": "@@ -45,63 +45,68 @@\n \n     private final KeyStore keyStore;\n \n-    public HsmEncryptionProvider(File keyStoreFile) {\n+    public HsmEncryptionProvider(final File keyStoreFile) throws EncrypterException {\n         try {\n             super.setKeyFile(keyStoreFile);\n             this.keyStore = KeyStore.getInstance(TYPE, PROVIDER);\n-            FileInputStream fIn = new FileInputStream(keyStoreFile);\n+            final FileInputStream fIn = new FileInputStream(keyStoreFile);\n             this.keyStore.load(fIn, null);\n-        } catch (CertificateException | NoSuchAlgorithmException | NoSuchProviderException | IOException | KeyStoreException e) {\n+        } catch (final CertificateException | NoSuchAlgorithmException | NoSuchProviderException | IOException | KeyStoreException e) {\n             throw new EncrypterException(\"Could not read keystore\", e);\n         }\n     }\n \n-    public Secret decrypt(EncryptedSecret secret, String keyReference) {\n-\n-        Secret decryptedSecret = super.decrypt(secret, keyReference);\n-\n-        byte[] decryptedSecretBytes = decryptedSecret.getSecret();\n-\n-        if (decryptedSecretBytes.length > KEY_LENGTH) {\n-\n-            byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecretBytes, 0,\n-                    decryptedSecretBytes.length-16);\n-\n-            LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecretBytes) + \" to \" +\n+    @Override\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) throws EncrypterException {\n+        byte[] decryptedSecret = super.decrypt(secret, keyReference);\n+        if (decryptedSecret.length > KEY_LENGTH) {\n+            final byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecret, 0,\n+                    decryptedSecret.length-16);\n+            LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecret) + \" to \" +\n                             Hex.encodeHexString(truncatedDecryptedSecretBytes));\n-\n-            decryptedSecret = new Secret(truncatedDecryptedSecretBytes);\n+            return truncatedDecryptedSecretBytes;\n         }\n-\n         return decryptedSecret;\n     }\n \n-    protected Cipher getCipher() {\n+    @Override\n+    public byte[] generateAes128BitsSecret(String keyReference) throws EncrypterException {\n+        try {\n+            return this.encrypt(KeyGenerator.getInstance(\"AES\").generateKey().getEncoded(),keyReference).getSecret();\n+        } catch (NoSuchAlgorithmException exc) {\n+            throw new EncrypterException(\"Could not generate secret\", exc);\n+        }\n+    }\n+\n+    @Override\n+    protected Cipher getCipher() throws EncrypterException {\n         try {\n             return Cipher.getInstance(ALGORITHM, PROVIDER);\n-        } catch (NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n+        } catch (final NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n             throw new EncrypterException(\"Could not get cipher\", e);\n         }\n     }\n \n     /**\n-     * This method reads the 'actual' encryption key (from the database).\n-     * Normally this is the key start isValidFrom(now) and isValidUntil(now).\n+     * This method reads the encryption key specified by keyReference from the Hsm.\n      *\n      * @return the key that must be used for encryption/decryption\n      */\n-    protected Key getSecretEncryptionKey(String keyReference, int cipherMode) {\n+    @Override\n+    protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) throws EncrypterException {", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NzE0Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517367142", "bodyText": "Remove the declaration of thrown exception 'org.opensmartgridplatform.shared.exceptionhandling.EncrypterException' which is a runtime exception.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:50Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java", "diffHunk": "@@ -45,63 +45,68 @@\n \n     private final KeyStore keyStore;\n \n-    public HsmEncryptionProvider(File keyStoreFile) {\n+    public HsmEncryptionProvider(final File keyStoreFile) throws EncrypterException {\n         try {\n             super.setKeyFile(keyStoreFile);\n             this.keyStore = KeyStore.getInstance(TYPE, PROVIDER);\n-            FileInputStream fIn = new FileInputStream(keyStoreFile);\n+            final FileInputStream fIn = new FileInputStream(keyStoreFile);\n             this.keyStore.load(fIn, null);\n-        } catch (CertificateException | NoSuchAlgorithmException | NoSuchProviderException | IOException | KeyStoreException e) {\n+        } catch (final CertificateException | NoSuchAlgorithmException | NoSuchProviderException | IOException | KeyStoreException e) {\n             throw new EncrypterException(\"Could not read keystore\", e);\n         }\n     }\n \n-    public Secret decrypt(EncryptedSecret secret, String keyReference) {\n-\n-        Secret decryptedSecret = super.decrypt(secret, keyReference);\n-\n-        byte[] decryptedSecretBytes = decryptedSecret.getSecret();\n-\n-        if (decryptedSecretBytes.length > KEY_LENGTH) {\n-\n-            byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecretBytes, 0,\n-                    decryptedSecretBytes.length-16);\n-\n-            LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecretBytes) + \" to \" +\n+    @Override\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) throws EncrypterException {\n+        byte[] decryptedSecret = super.decrypt(secret, keyReference);\n+        if (decryptedSecret.length > KEY_LENGTH) {\n+            final byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecret, 0,\n+                    decryptedSecret.length-16);\n+            LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecret) + \" to \" +\n                             Hex.encodeHexString(truncatedDecryptedSecretBytes));\n-\n-            decryptedSecret = new Secret(truncatedDecryptedSecretBytes);\n+            return truncatedDecryptedSecretBytes;\n         }\n-\n         return decryptedSecret;\n     }\n \n-    protected Cipher getCipher() {\n+    @Override\n+    public byte[] generateAes128BitsSecret(String keyReference) throws EncrypterException {\n+        try {\n+            return this.encrypt(KeyGenerator.getInstance(\"AES\").generateKey().getEncoded(),keyReference).getSecret();\n+        } catch (NoSuchAlgorithmException exc) {\n+            throw new EncrypterException(\"Could not generate secret\", exc);\n+        }\n+    }\n+\n+    @Override\n+    protected Cipher getCipher() throws EncrypterException {", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NzE1Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517367152", "bodyText": "Remove the declaration of thrown exception 'org.opensmartgridplatform.shared.exceptionhandling.EncrypterException' which is a runtime exception.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:51Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java", "diffHunk": "@@ -45,63 +45,68 @@\n \n     private final KeyStore keyStore;\n \n-    public HsmEncryptionProvider(File keyStoreFile) {\n+    public HsmEncryptionProvider(final File keyStoreFile) throws EncrypterException {\n         try {\n             super.setKeyFile(keyStoreFile);\n             this.keyStore = KeyStore.getInstance(TYPE, PROVIDER);\n-            FileInputStream fIn = new FileInputStream(keyStoreFile);\n+            final FileInputStream fIn = new FileInputStream(keyStoreFile);\n             this.keyStore.load(fIn, null);\n-        } catch (CertificateException | NoSuchAlgorithmException | NoSuchProviderException | IOException | KeyStoreException e) {\n+        } catch (final CertificateException | NoSuchAlgorithmException | NoSuchProviderException | IOException | KeyStoreException e) {\n             throw new EncrypterException(\"Could not read keystore\", e);\n         }\n     }\n \n-    public Secret decrypt(EncryptedSecret secret, String keyReference) {\n-\n-        Secret decryptedSecret = super.decrypt(secret, keyReference);\n-\n-        byte[] decryptedSecretBytes = decryptedSecret.getSecret();\n-\n-        if (decryptedSecretBytes.length > KEY_LENGTH) {\n-\n-            byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecretBytes, 0,\n-                    decryptedSecretBytes.length-16);\n-\n-            LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecretBytes) + \" to \" +\n+    @Override\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) throws EncrypterException {\n+        byte[] decryptedSecret = super.decrypt(secret, keyReference);\n+        if (decryptedSecret.length > KEY_LENGTH) {\n+            final byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecret, 0,\n+                    decryptedSecret.length-16);\n+            LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecret) + \" to \" +\n                             Hex.encodeHexString(truncatedDecryptedSecretBytes));\n-\n-            decryptedSecret = new Secret(truncatedDecryptedSecretBytes);\n+            return truncatedDecryptedSecretBytes;\n         }\n-\n         return decryptedSecret;\n     }\n \n-    protected Cipher getCipher() {\n+    @Override\n+    public byte[] generateAes128BitsSecret(String keyReference) throws EncrypterException {", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NzE2OA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517367168", "bodyText": "Remove the declaration of thrown exception 'org.opensmartgridplatform.shared.exceptionhandling.EncrypterException' which is a runtime exception.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:52Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java", "diffHunk": "@@ -45,63 +45,68 @@\n \n     private final KeyStore keyStore;\n \n-    public HsmEncryptionProvider(File keyStoreFile) {\n+    public HsmEncryptionProvider(final File keyStoreFile) throws EncrypterException {\n         try {\n             super.setKeyFile(keyStoreFile);\n             this.keyStore = KeyStore.getInstance(TYPE, PROVIDER);\n-            FileInputStream fIn = new FileInputStream(keyStoreFile);\n+            final FileInputStream fIn = new FileInputStream(keyStoreFile);\n             this.keyStore.load(fIn, null);\n-        } catch (CertificateException | NoSuchAlgorithmException | NoSuchProviderException | IOException | KeyStoreException e) {\n+        } catch (final CertificateException | NoSuchAlgorithmException | NoSuchProviderException | IOException | KeyStoreException e) {\n             throw new EncrypterException(\"Could not read keystore\", e);\n         }\n     }\n \n-    public Secret decrypt(EncryptedSecret secret, String keyReference) {\n-\n-        Secret decryptedSecret = super.decrypt(secret, keyReference);\n-\n-        byte[] decryptedSecretBytes = decryptedSecret.getSecret();\n-\n-        if (decryptedSecretBytes.length > KEY_LENGTH) {\n-\n-            byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecretBytes, 0,\n-                    decryptedSecretBytes.length-16);\n-\n-            LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecretBytes) + \" to \" +\n+    @Override\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) throws EncrypterException {", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NzIxOQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517367219", "bodyText": "Remove the declaration of thrown exception 'org.opensmartgridplatform.shared.exceptionhandling.FunctionalException', as it cannot be thrown from method's body.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:06:55Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetEncryptionKeyExchangeOnGMeterCommandExecutor.java", "diffHunk": "@@ -82,80 +96,118 @@ public MethodResultCode execute(final DlmsConnectionManager conn, final DlmsDevi\n \n             final String mbusDeviceIdentification = gMeterInfo.getDeviceIdentification();\n             final int channel = gMeterInfo.getChannel();\n-            DlmsDevice mbusDevice = this.dlmsDeviceRepository.findByDeviceIdentification(mbusDeviceIdentification);\n-            if (mbusDevice == null) {\n-                throw new ProtocolAdapterException(\"Unknown M-Bus device: \" + mbusDeviceIdentification);\n-            }\n-\n-            final byte[] mbusUserKey = this.securityKeyService.generateKey();\n-            final byte[] mbusDefaultKey = this.securityKeyService\n-                    .getMbusDefaultKey(gMeterInfo.getDeviceIdentification());\n-\n-            final SecurityKeyType mbusUserKeyType = SecurityKeyType.G_METER_ENCRYPTION;\n-            final byte[] encryptedUserKey = this.securityKeyService.encryptKey(mbusUserKey, mbusUserKeyType);\n-            mbusDevice = this.securityKeyService.storeNewKey(mbusDevice, encryptedUserKey, mbusUserKeyType);\n-\n             final ObisCode obisCode = OBIS_HASHMAP.get(channel);\n+            final byte[] gMeterEncryptionKey = this.securityKeyService\n+                    .generate128BitsKeyAndStoreAsNewKey(mbusDeviceIdentification, G_METER_ENCRYPTION);\n \n-            final MethodParameter methodTransferKey = this.getTransferKeyToMBusMethodParameter(obisCode, mbusDefaultKey,\n-                    mbusUserKey);\n-\n-            conn.getDlmsMessageListener()\n-                    .setDescription(\"SetEncryptionKeyExchangeOnGMeter for channel \" + channel\n-                            + \", call M-Bus Setup transfer_key method: \"\n-                            + JdlmsObjectToStringUtil.describeMethod(methodTransferKey));\n-\n-            MethodResult methodResultCode = conn.getConnection().action(methodTransferKey);\n-            this.checkMethodResultCode(methodResultCode, \"M-Bus Setup transfer_key\");\n-            LOGGER.info(\"Successfully invoked M-Bus Setup transfer_key method: class_id {} obis_code {}\", CLASS_ID,\n-                    obisCode);\n-\n-            conn.getDlmsMessageListener()\n-                    .setDescription(\"SetEncryptionKeyExchangeOnGMeter for channel \" + gMeterInfo.getChannel()\n-                            + \", call M-Bus Setup set_encryption_key method: \"\n-                            + JdlmsObjectToStringUtil.describeMethod(methodTransferKey));\n-\n-            final MethodParameter methodSetEncryptionKey = this.getSetEncryptionKeyMethodParameter(obisCode,\n-                    mbusUserKey);\n-            methodResultCode = conn.getConnection().action(methodSetEncryptionKey);\n-            this.checkMethodResultCode(methodResultCode, \"M-Bus Setup set_encryption_key\");\n-            LOGGER.info(\"Successfully invoked M-Bus Setup set_encryption_key method: class_id {} obis_code {}\",\n-                    CLASS_ID, obisCode);\n+            MethodResult methodResultCode = this\n+                    .transferKey(conn, mbusDeviceIdentification, channel, gMeterEncryptionKey);\n+            this.checkMethodResultCode(methodResultCode, \"M-Bus Setup transfer_key\", obisCode);\n \n-            this.securityKeyService.validateNewKey(mbusDevice, mbusUserKeyType);\n+            methodResultCode = this.setEncryptionKey(conn, channel, gMeterEncryptionKey);\n+            this.checkMethodResultCode(methodResultCode, \"M-Bus Setup set_encryption_key\", obisCode);\n \n+            this.securityKeyService.activateNewKey(mbusDeviceIdentification, G_METER_ENCRYPTION);\n             return MethodResultCode.SUCCESS;\n         } catch (final IOException e) {\n             throw new ConnectionException(e);\n         } catch (final EncrypterException e) {\n             throw new ProtocolAdapterException(\n                     \"Unexpected exception during decryption of security keys, reason = \" + e.getMessage(), e);\n+        } catch (final FunctionalException e) {\n+            throw new ProtocolAdapterException(\"Unexpected exception: \" + e.toString(), e);\n         }\n     }\n \n-    private void checkMethodResultCode(final MethodResult methodResultCode, final String methodParameterName)\n-            throws ProtocolAdapterException {\n+    private MethodResult setEncryptionKey(DlmsConnectionManager conn, int channel, byte[] encryptionKey)\n+            throws IOException {\n+        MethodResult methodResultCode;\n+        final MethodParameter methodSetEncryptionKey = this\n+                .getSetEncryptionKeyMethodParameter(OBIS_HASHMAP.get(channel), encryptionKey);\n+        conn.getDlmsMessageListener().setDescription(\"SetEncryptionKeyExchangeOnGMeter for channel \" + channel\n+                + \", call M-Bus Setup set_encryption_key method: \" + JdlmsObjectToStringUtil\n+                .describeMethod(methodSetEncryptionKey));\n+        methodResultCode = conn.getConnection().action(methodSetEncryptionKey);\n+        return methodResultCode;\n+    }\n+\n+    private MethodResult transferKey(DlmsConnectionManager conn, String mbusDeviceIdentification, int channel,\n+            byte[] encryptionKey) throws ProtocolAdapterException, IOException, FunctionalException {\n+        final MethodParameter methodTransferKey = this\n+                .getTransferKeyMethodParameter(mbusDeviceIdentification, channel, encryptionKey);\n+        conn.getDlmsMessageListener().setDescription(\n+                \"SetEncryptionKeyExchangeOnGMeter for channel \" + channel + \", call M-Bus Setup transfer_key method: \"\n+                        + JdlmsObjectToStringUtil.describeMethod(methodTransferKey));\n+\n+        return conn.getConnection().action(methodTransferKey);\n+    }\n+\n+    private MethodParameter getTransferKeyMethodParameter(String mbusDeviceIdentification, int channel,\n+            byte[] gMeterUserKey) throws ProtocolAdapterException, FunctionalException {", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NzI4MQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517367281", "bodyText": "Do not forget to remove this deprecated code someday.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:07:00Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/repositories/DlmsSecurityKeyRepository.java", "diffHunk": "@@ -17,6 +17,10 @@\n import org.springframework.data.repository.query.Param;\n import org.springframework.stereotype.Repository;\n \n+/**\n+ * @Deprecated with the introduction of secret-management, the security_key table has become obsolete.\n+ */\n+@Deprecated\n @Repository\n public interface DlmsSecurityKeyRepository extends JpaRepository<SecurityKey, Long> {", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NzI5Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/488#discussion_r517367292", "bodyText": "Define a constant instead of duplicating this literal \"Missing input: typed secrets\" 3 times.", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-11-04T14:07:00Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java", "diffHunk": "@@ -37,86 +45,147 @@\n @Slf4j\n public class SecretManagementEndpoint {\n \n-    private static final String NAMESPACE_URI = \"http://www.opensmartgridplatform\"\n-            + \".org/schemas/security/secretmanagement\";\n+    private static final String NAMESPACE_URI =\n+            \"http://www.opensmartgridplatform\" + \".org/schemas/security/secretmanagement\";\n \n     private final SecretManagementService secretManagementService;\n     private final SoapEndpointDataTypeConverter converter;\n \n-    public SecretManagementEndpoint(SecretManagementService secretManagementService,\n-                                    SoapEndpointDataTypeConverter converter) {\n+    public SecretManagementEndpoint(final SecretManagementService secretManagementService,\n+            final SoapEndpointDataTypeConverter converter) {\n         this.secretManagementService = secretManagementService;\n         this.converter = converter;\n     }\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n     @ResponsePayload\n-    public GetSecretsResponse getSecretsRequest(@RequestPayload GetSecretsRequest request) throws OsgpException {\n-\n+    public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request) throws OsgpException {\n         log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-\n         if (log.isDebugEnabled()) {\n-            log.debug(getSecretsRequestToString(request));\n+            log.debug(this.requestToString(request));\n         }\n-\n-        GetSecretsResponse response = new GetSecretsResponse();\n-\n-        SecretTypes soapSecretTypes = request.getSecretTypes();\n-\n+        final GetSecretsResponse response = new GetSecretsResponse();\n+        final SecretTypes soapSecretTypes = request.getSecretTypes();\n         if (soapSecretTypes == null) {\n             throw new TechnicalException(\"Missing input: secret types\");\n         }\n-\n-        List<SecretType> secretTypeList = converter.convertToSecretTypes(soapSecretTypes);\n-        List<TypedSecret> typedSecrets = secretManagementService.retrieveSecrets(request.getDeviceId(),\n+        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveSecrets(request.getDeviceId(),\n                 secretTypeList);\n-\n-        TypedSecrets soapTypedSecrets = converter.convertToSoapTypedSecrets(typedSecrets);\n-\n+        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n         response.setTypedSecrets(soapTypedSecrets);\n         response.setResult(OsgpResultType.OK);\n-\n         log.trace(response.toString());\n+        return response;\n+    }\n \n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getNewSecretsRequest\")\n+    @ResponsePayload\n+    public GetNewSecretsResponse getNewSecretsRequest(@RequestPayload final GetNewSecretsRequest request) throws OsgpException {\n+        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+        if (log.isDebugEnabled()) {\n+            log.debug(this.requestToString(request));\n+        }\n+        final GetNewSecretsResponse response = new GetNewSecretsResponse();\n+        final SecretTypes soapSecretTypes = request.getSecretTypes();\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(\"Missing input: secret types\");\n+        }\n+        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveNewSecrets(request.getDeviceId(),\n+                secretTypeList);\n+        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n+        response.setTypedSecrets(soapTypedSecrets);\n+        response.setResult(OsgpResultType.OK);\n+        log.trace(response.toString());\n         return response;\n     }\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n     @ResponsePayload\n-    public StoreSecretsResponse storeSecretsRequest(@RequestPayload StoreSecretsRequest request) throws OsgpException {\n-\n+    public StoreSecretsResponse storeSecretsRequest(@RequestPayload final StoreSecretsRequest request)\n+            throws OsgpException {\n         log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n         log.trace(request.toString());\n-\n-        StoreSecretsResponse response = new StoreSecretsResponse();\n-\n-        TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n-\n+        final StoreSecretsResponse response = new StoreSecretsResponse();\n+        final TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n         if (soapTypedSecrets == null) {\n             throw new TechnicalException(\"Missing input: typed secrets\");", "originalCommit": "d6b0e667f6214c5a1511a5ef114ce190fb948125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}