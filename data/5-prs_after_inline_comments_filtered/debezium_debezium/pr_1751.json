{"pr_number": 1751, "pr_title": "DBZ-2338 Base WAL position detection on commit LSNs", "pr_createdAt": "2020-08-12T04:58:32Z", "pr_url": "https://github.com/debezium/debezium/pull/1751", "timeline": [{"oid": "99560bc6312576426607690bebb17ca81b5dae0f", "url": "https://github.com/debezium/debezium/commit/99560bc6312576426607690bebb17ca81b5dae0f", "message": "DBZ-2200 Introduce LLSN domain type", "committedDate": "2020-08-21T12:30:55Z", "type": "commit"}, {"oid": "d5d96d20e6b584ed90e0bf010563723a517470c4", "url": "https://github.com/debezium/debezium/commit/d5d96d20e6b584ed90e0bf010563723a517470c4", "message": "DBZ-2338 Base WAL position detection on commit LSNs", "committedDate": "2020-08-21T12:32:53Z", "type": "commit"}, {"oid": "3eb98ca18ace191f46ddc4796b413833c86a0ef9", "url": "https://github.com/debezium/debezium/commit/3eb98ca18ace191f46ddc4796b413833c86a0ef9", "message": "DBZ-2338 Support for pgoutput", "committedDate": "2020-08-21T12:32:53Z", "type": "commit"}, {"oid": "3e478a5da54f3fdbd4b42297201e4519878280f3", "url": "https://github.com/debezium/debezium/commit/3e478a5da54f3fdbd4b42297201e4519878280f3", "message": "DBZ-2338 Minor corrections\n\nCo-authored-by: Gunnar Morling <gunnar.morling@googlemail.com>", "committedDate": "2020-08-21T12:32:53Z", "type": "commit"}, {"oid": "9c7c9c2aad3061efeb4859844b1ef49f59cf3f98", "url": "https://github.com/debezium/debezium/commit/9c7c9c2aad3061efeb4859844b1ef49f59cf3f98", "message": "DBZ-2397 Test for restart in tx", "committedDate": "2020-08-21T12:32:53Z", "type": "commit"}, {"oid": "c49a5a73b0e9d88f20e1ce8b0dfa82addedb52a7", "url": "https://github.com/debezium/debezium/commit/c49a5a73b0e9d88f20e1ce8b0dfa82addedb52a7", "message": "DBZ-2338 Skip initial statements on reconnect", "committedDate": "2020-08-21T13:13:16Z", "type": "commit"}, {"oid": "c49a5a73b0e9d88f20e1ce8b0dfa82addedb52a7", "url": "https://github.com/debezium/debezium/commit/c49a5a73b0e9d88f20e1ce8b0dfa82addedb52a7", "message": "DBZ-2338 Skip initial statements on reconnect", "committedDate": "2020-08-21T13:13:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NjA4Nw==", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r475256087", "bodyText": "Why does keepalive need to be disabled to commit the current transaction?  Asking because PostgresTaskContext#refreshSchema called on https://github.com/debezium/debezium/pull/1751/files#diff-dff0ff397d3f72ba1319e51a37ace1adL118 here performs a commit but does not disable keepalive.", "author": "grantcooksey", "createdAt": "2020-08-23T19:31:20Z", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresStreamingChangeEventSource.java", "diffHunk": "@@ -96,103 +97,45 @@ public void execute(ChangeEventSourceContext context) throws InterruptedExceptio\n         }\n \n         try {\n+            final WalPositionLocator walPosition;\n             if (hasStartLsnStoredInContext) {\n                 // start streaming from the last recorded position in the offset\n-                final Long lsn = offsetContext.lastCompletelyProcessedLsn() != null ? offsetContext.lastCompletelyProcessedLsn() : offsetContext.lsn();\n-                if (LOGGER.isDebugEnabled()) {\n-                    LOGGER.debug(\"retrieved latest position from stored offset '{}'\", ReplicationConnection.format(lsn));\n-                }\n-                replicationStream.compareAndSet(null, replicationConnection.startStreaming(lsn));\n+                final Lsn lsn = offsetContext.lastCompletelyProcessedLsn() != null ? offsetContext.lastCompletelyProcessedLsn() : offsetContext.lsn();\n+                LOGGER.info(\"Retrieved latest position from stored offset '{}'\", lsn);\n+                walPosition = new WalPositionLocator(offsetContext.lastCommitLsn(), lsn);\n+                replicationStream.compareAndSet(null, replicationConnection.startStreaming(lsn, walPosition));\n             }\n             else {\n-                LOGGER.info(\"no previous LSN found in Kafka, streaming from the latest xlogpos or flushed LSN...\");\n-                replicationStream.compareAndSet(null, replicationConnection.startStreaming());\n+                LOGGER.info(\"No previous LSN found in Kafka, streaming from the latest xlogpos or flushed LSN...\");\n+                walPosition = new WalPositionLocator();\n+                replicationStream.compareAndSet(null, replicationConnection.startStreaming(walPosition));\n             }\n             // for large dbs, the refresh of schema can take too much time\n             // such that the connection times out. We must enable keep\n             // alive to ensure that it doesn't time out\n-            final ReplicationStream stream = this.replicationStream.get();\n+            ReplicationStream stream = this.replicationStream.get();\n             stream.startKeepAlive(Executors.newSingleThreadExecutor());\n \n             // refresh the schema so we have a latest view of the DB tables\n             taskContext.refreshSchema(connection, true);\n \n             this.lastCompletelyProcessedLsn = replicationStream.get().startLsn();\n \n-            int noMessageIterations = 0;\n-            while (context.isRunning()) {\n-\n-                boolean receivedMessage = stream.readPending(message -> {\n-                    final Long lsn = stream.lastReceivedLsn();\n-\n-                    if (message.isLastEventForLsn()) {\n-                        lastCompletelyProcessedLsn = lsn;\n-                    }\n-\n-                    // Tx BEGIN/END event\n-                    if (message.isTransactionalMessage()) {\n-                        if (!connectorConfig.shouldProvideTransactionMetadata()) {\n-                            LOGGER.trace(\"Received transactional message {}\", message);\n-                            // Don't skip on BEGIN message as it would flush LSN for the whole transaction\n-                            // too early\n-                            if (message.getOperation() == Operation.COMMIT) {\n-                                skipMessage(lsn);\n-                            }\n-                            return;\n-                        }\n-\n-                        offsetContext.updateWalPosition(lsn, lastCompletelyProcessedLsn, message.getCommitTime(), message.getTransactionId(), null,\n-                                taskContext.getSlotXmin(connection));\n-                        if (message.getOperation() == Operation.BEGIN) {\n-                            dispatcher.dispatchTransactionStartedEvent(Long.toString(message.getTransactionId()), offsetContext);\n-                        }\n-                        else if (message.getOperation() == Operation.COMMIT) {\n-                            dispatcher.dispatchTransactionCommittedEvent(offsetContext);\n-                        }\n-                        maybeWarnAboutGrowingWalBacklog(true);\n-                        return;\n-                    }\n-                    // DML event\n-                    else {\n-                        TableId tableId = null;\n-                        if (message.getOperation() != Operation.NOOP) {\n-                            tableId = PostgresSchema.parse(message.getTable());\n-                            Objects.requireNonNull(tableId);\n-                        }\n-\n-                        offsetContext.updateWalPosition(lsn, lastCompletelyProcessedLsn, message.getCommitTime(), message.getTransactionId(), tableId,\n-                                taskContext.getSlotXmin(connection));\n-\n-                        boolean dispatched = (message.getOperation() == Operation.NOOP) ? false\n-                                : dispatcher.dispatchDataChangeEvent(\n-                                        tableId,\n-                                        new PostgresChangeRecordEmitter(\n-                                                offsetContext,\n-                                                clock,\n-                                                connectorConfig,\n-                                                schema,\n-                                                connection,\n-                                                message));\n-\n-                        maybeWarnAboutGrowingWalBacklog(dispatched);\n-                    }\n-                });\n-\n-                if (receivedMessage) {\n-                    noMessageIterations = 0;\n+            if (walPosition.searchingEnabled()) {\n+                searchWalPosition(context, stream, walPosition);\n+                stream.stopKeepAlive();", "originalCommit": "c49a5a73b0e9d88f20e1ce8b0dfa82addedb52a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTMzNDkwMQ==", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r475334901", "bodyText": "Hi, in this case it is not due to the commit but due to the reconnect that is few lines later down", "author": "jpechane", "createdAt": "2020-08-24T04:24:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NjA4Nw=="}], "type": "inlineReview"}, {"oid": "1af7eb1d8f850218bfcdfe949cd84824636d01f8", "url": "https://github.com/debezium/debezium/commit/1af7eb1d8f850218bfcdfe949cd84824636d01f8", "message": "DBZ-2338 Log exception; restart keepalive", "committedDate": "2020-08-24T04:34:29Z", "type": "commit"}, {"oid": "4f91d032459c2bb24126d361c84432a8f349948c", "url": "https://github.com/debezium/debezium/commit/4f91d032459c2bb24126d361c84432a8f349948c", "message": "DBZ-2338 Flush LSNs on tx boundaries", "committedDate": "2020-08-24T05:17:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5NDUyNA==", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r475594524", "bodyText": "Was changing the log level of this from debug to info intentional?", "author": "Naros", "createdAt": "2020-08-24T13:21:09Z", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresStreamingChangeEventSource.java", "diffHunk": "@@ -96,103 +97,46 @@ public void execute(ChangeEventSourceContext context) throws InterruptedExceptio\n         }\n \n         try {\n+            final WalPositionLocator walPosition;\n             if (hasStartLsnStoredInContext) {\n                 // start streaming from the last recorded position in the offset\n-                final Long lsn = offsetContext.lastCompletelyProcessedLsn() != null ? offsetContext.lastCompletelyProcessedLsn() : offsetContext.lsn();\n-                if (LOGGER.isDebugEnabled()) {\n-                    LOGGER.debug(\"retrieved latest position from stored offset '{}'\", ReplicationConnection.format(lsn));\n-                }\n-                replicationStream.compareAndSet(null, replicationConnection.startStreaming(lsn));\n+                final Lsn lsn = offsetContext.lastCompletelyProcessedLsn() != null ? offsetContext.lastCompletelyProcessedLsn() : offsetContext.lsn();\n+                LOGGER.info(\"Retrieved latest position from stored offset '{}'\", lsn);", "originalCommit": "4f91d032459c2bb24126d361c84432a8f349948c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5OTI4NQ==", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r475599285", "bodyText": "Would it be possible to use queryAndMap here in order to avoid the AtomicReference usage?", "author": "Naros", "createdAt": "2020-08-24T13:28:48Z", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/PostgresReplicationConnection.java", "diffHunk": "@@ -219,7 +218,7 @@ protected void initReplicationSlot() throws SQLException, InterruptedException {\n                 this.createReplicationSlot();\n             }\n \n-            AtomicLong xlogStart = new AtomicLong();\n+            final AtomicReference<Lsn> xlogStart = new AtomicReference<>();", "originalCommit": "4f91d032459c2bb24126d361c84432a8f349948c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgxNTk4NA==", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r475815984", "bodyText": "Done, thanks!", "author": "jpechane", "createdAt": "2020-08-24T18:34:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5OTI4NQ=="}], "type": "inlineReview"}, {"oid": "99b8375a200f422d680c5aca540f0c030432cb94", "url": "https://github.com/debezium/debezium/commit/99b8375a200f422d680c5aca540f0c030432cb94", "message": "DBZ-2338 Atomic is not necessary", "committedDate": "2020-08-24T18:33:57Z", "type": "commit"}]}