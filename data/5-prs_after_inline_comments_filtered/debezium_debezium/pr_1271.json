{"pr_number": 1271, "pr_title": "DBZ-1760 Allow skipping of invalid events", "pr_createdAt": "2020-02-17T11:57:44Z", "pr_url": "https://github.com/debezium/debezium/pull/1271", "timeline": [{"oid": "995f1d39f619be53e80bcf497133f83bc04e757c", "url": "https://github.com/debezium/debezium/commit/995f1d39f619be53e80bcf497133f83bc04e757c", "message": "DBZ-1760 Allow skipping of invalid events", "committedDate": "2020-02-17T12:31:40Z", "type": "commit"}, {"oid": "995f1d39f619be53e80bcf497133f83bc04e757c", "url": "https://github.com/debezium/debezium/commit/995f1d39f619be53e80bcf497133f83bc04e757c", "message": "DBZ-1760 Allow skipping of invalid events", "committedDate": "2020-02-17T12:31:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk0MjAxNQ==", "url": "https://github.com/debezium/debezium/pull/1271#discussion_r381942015", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * Problematic event and will be logged and the events will be skipped.\n          \n          \n            \n                     * Problematic events will be logged and skipped.", "author": "gunnarmorling", "createdAt": "2020-02-20T11:29:14Z", "path": "debezium-core/src/main/java/io/debezium/config/CommonConnectorConfig.java", "diffHunk": "@@ -79,6 +79,60 @@ public static Version parse(String value, String defaultValue) {\n         }\n     }\n \n+    /**\n+     * The set of predefined modes for dealing with failures during event processing.\n+     */\n+    public static enum EventProcessingFailureHandlingMode implements EnumeratedValue {\n+\n+        /**\n+         * Problematic events will be skipped.\n+         */\n+        IGNORE(\"ignore\"),\n+\n+        /**\n+         * Problematic event and will be logged and the events will be skipped.", "originalCommit": "995f1d39f619be53e80bcf497133f83bc04e757c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk0MjUyOA==", "url": "https://github.com/debezium/debezium/pull/1271#discussion_r381942528", "bodyText": "Something more specific would be nice.", "author": "gunnarmorling", "createdAt": "2020-02-20T11:30:24Z", "path": "debezium-connector-sqlserver/src/test/java/io/debezium/connector/sqlserver/EventProcessingFailureHandlingIT.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright Debezium Authors.\n+ *\n+ * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.debezium.connector.sqlserver;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+import java.sql.SQLException;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.awaitility.Awaitility;\n+import org.fest.assertions.Assertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.debezium.config.CommonConnectorConfig.EventProcessingFailureHandlingMode;\n+import io.debezium.config.Configuration;\n+import io.debezium.connector.sqlserver.SqlServerConnectorConfig.SnapshotMode;\n+import io.debezium.connector.sqlserver.util.TestHelper;\n+import io.debezium.embedded.AbstractConnectorTest;\n+import io.debezium.junit.logging.LogInterceptor;\n+import io.debezium.util.Testing;\n+\n+/**\n+ * Integration test for the Debezium SQL Server connector.", "originalCommit": "995f1d39f619be53e80bcf497133f83bc04e757c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk0MjY2MQ==", "url": "https://github.com/debezium/debezium/pull/1271#discussion_r381942661", "bodyText": "Perhaps SKIP is more expressive.", "author": "gunnarmorling", "createdAt": "2020-02-20T11:30:46Z", "path": "debezium-core/src/main/java/io/debezium/config/CommonConnectorConfig.java", "diffHunk": "@@ -79,6 +79,60 @@ public static Version parse(String value, String defaultValue) {\n         }\n     }\n \n+    /**\n+     * The set of predefined modes for dealing with failures during event processing.\n+     */\n+    public static enum EventProcessingFailureHandlingMode implements EnumeratedValue {\n+\n+        /**\n+         * Problematic events will be skipped.\n+         */\n+        IGNORE(\"ignore\"),", "originalCommit": "995f1d39f619be53e80bcf497133f83bc04e757c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk0MzM3MA==", "url": "https://github.com/debezium/debezium/pull/1271#discussion_r381943370", "bodyText": "Either log or throw, not both.", "author": "gunnarmorling", "createdAt": "2020-02-20T11:32:22Z", "path": "debezium-core/src/main/java/io/debezium/pipeline/EventDispatcher.java", "diffHunk": "@@ -130,43 +132,65 @@ public SnapshotReceiver getSnapshotChangeEventReceiver() {\n      * @return {@code true} if an event was dispatched (i.e. sent to the message broker), {@code false} otherwise.\n      */\n     public boolean dispatchDataChangeEvent(T dataCollectionId, ChangeRecordEmitter changeRecordEmitter) throws InterruptedException {\n-        boolean handled = false;\n-        if (!filter.isIncluded(dataCollectionId)) {\n-            LOGGER.trace(\"Filtered data change event for {}\", dataCollectionId);\n-            eventListener.onFilteredEvent(\"source = \" + dataCollectionId);\n-        }\n-        else {\n-            DataCollectionSchema dataCollectionSchema = schema.schemaFor(dataCollectionId);\n-\n-            // TODO handle as per inconsistent schema info option\n-            if (dataCollectionSchema == null) {\n-                final Optional<DataCollectionSchema> replacementSchema = inconsistentSchemaHandler.handle(dataCollectionId, changeRecordEmitter);\n-                if (!replacementSchema.isPresent()) {\n-                    return false;\n-                }\n-                dataCollectionSchema = replacementSchema.get();\n+        try {\n+            boolean handled = false;\n+            if (!filter.isIncluded(dataCollectionId)) {\n+                LOGGER.trace(\"Filtered data change event for {}\", dataCollectionId);\n+                eventListener.onFilteredEvent(\"source = \" + dataCollectionId);\n             }\n+            else {\n+                DataCollectionSchema dataCollectionSchema = schema.schemaFor(dataCollectionId);\n+\n+                // TODO handle as per inconsistent schema info option\n+                if (dataCollectionSchema == null) {\n+                    final Optional<DataCollectionSchema> replacementSchema = inconsistentSchemaHandler.handle(dataCollectionId, changeRecordEmitter);\n+                    if (!replacementSchema.isPresent()) {\n+                        return false;\n+                    }\n+                    dataCollectionSchema = replacementSchema.get();\n+                }\n \n-            changeRecordEmitter.emitChangeRecords(dataCollectionSchema, new Receiver() {\n+                changeRecordEmitter.emitChangeRecords(dataCollectionSchema, new Receiver() {\n \n-                @Override\n-                public void changeRecord(DataCollectionSchema schema, Operation operation, Object key, Struct value,\n-                                         OffsetContext offset)\n-                        throws InterruptedException {\n-                    transactionMonitor.dataEvent(dataCollectionId, offset, key, value);\n-                    eventListener.onEvent(dataCollectionId, offset, key, value);\n-                    streamingReceiver.changeRecord(schema, operation, key, value, offset);\n-                }\n-            });\n-            handled = true;\n-        }\n+                    @Override\n+                    public void changeRecord(DataCollectionSchema schema, Operation operation, Object key, Struct value,\n+                                             OffsetContext offset)\n+                            throws InterruptedException {\n+                        transactionMonitor.dataEvent(dataCollectionId, offset, key, value);\n+                        eventListener.onEvent(dataCollectionId, offset, key, value);\n+                        streamingReceiver.changeRecord(schema, operation, key, value, offset);\n+                    }\n+                });\n+                handled = true;\n+            }\n \n-        heartbeat.heartbeat(\n-                changeRecordEmitter.getOffset().getPartition(),\n-                changeRecordEmitter.getOffset().getOffset(),\n-                this::enqueueHeartbeat);\n+            heartbeat.heartbeat(\n+                    changeRecordEmitter.getOffset().getPartition(),\n+                    changeRecordEmitter.getOffset().getOffset(),\n+                    this::enqueueHeartbeat);\n \n-        return handled;\n+            return handled;\n+        }\n+        catch (Exception e) {\n+            switch (connectorConfig.getEventProcessingFailureHandlingMode()) {\n+                case FAIL:\n+                    LOGGER.error(", "originalCommit": "995f1d39f619be53e80bcf497133f83bc04e757c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "69223a74c9f0b9c28c93a437806cd3cddeccf1ad", "url": "https://github.com/debezium/debezium/commit/69223a74c9f0b9c28c93a437806cd3cddeccf1ad", "message": "DBZ-1760 Align code and docs", "committedDate": "2020-02-24T05:15:55Z", "type": "commit"}]}