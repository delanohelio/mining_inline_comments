{"pr_number": 1366, "pr_title": "DBZ-1782 Groovy based filtering SMT", "pr_createdAt": "2020-03-26T14:37:36Z", "pr_url": "https://github.com/debezium/debezium/pull/1366", "timeline": [{"oid": "6cbc3221c48227a736435cbb923dc06e888d4e74", "url": "https://github.com/debezium/debezium/commit/6cbc3221c48227a736435cbb923dc06e888d4e74", "message": "DBZ-1782 Groovy based filtering SMT", "committedDate": "2020-03-26T14:36:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA3NDQ3MQ==", "url": "https://github.com/debezium/debezium/pull/1366#discussion_r399074471", "bodyText": "Very nice! What I didn't get yet: how does evaluation happen? I saw you bind key, value etc. into the Groovy execution context. But how is the before.id part evaluated?", "author": "gunnarmorling", "createdAt": "2020-03-27T07:19:09Z", "path": "debezium-core/src/test/java/io/debezium/transforms/FilterTest.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright Debezium Authors.\n+ *\n+ * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.debezium.transforms;\n+\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.kafka.connect.data.Schema;\n+import org.apache.kafka.connect.data.SchemaBuilder;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.connect.source.SourceRecord;\n+import org.fest.assertions.Assertions;\n+import org.junit.Test;\n+\n+import io.debezium.DebeziumException;\n+import io.debezium.data.Envelope;\n+\n+/**\n+ * @author Jiri Pechanec\n+ */\n+public class FilterTest {\n+\n+    private static final String LANGUAGE = \"language\";\n+    private static final String EXPRESSION = \"condition\";\n+    private static final String NULL_HANDLING = \"null.handling.mode\";\n+\n+    final Schema recordSchema = SchemaBuilder.struct()\n+            .field(\"id\", SchemaBuilder.int8())\n+            .field(\"name\", SchemaBuilder.string())\n+            .build();\n+\n+    final Schema sourceSchema = SchemaBuilder.struct()\n+            .field(\"lsn\", SchemaBuilder.int32())\n+            .build();\n+\n+    final Envelope envelope = Envelope.defineSchema()\n+            .withName(\"dummy.Envelope\")\n+            .withRecord(recordSchema)\n+            .withSource(sourceSchema)\n+            .build();\n+\n+    @Test(expected = DebeziumException.class)\n+    public void testLanguageRequired() {\n+        try (final Filter<SourceRecord> transform = new Filter<>()) {\n+            final Map<String, String> props = new HashMap<>();\n+            props.put(EXPRESSION, \"operation == 'd'\");\n+            transform.configure(props);\n+        }\n+    }\n+\n+    @Test(expected = DebeziumException.class)\n+    public void testExpressionRequired() {\n+        try (final Filter<SourceRecord> transform = new Filter<>()) {\n+            final Map<String, String> props = new HashMap<>();\n+            props.put(LANGUAGE, \"groovy\");\n+            transform.configure(props);\n+        }\n+    }\n+\n+    @Test(expected = DebeziumException.class)\n+    public void shouldFailOnUnkownLanguage() {\n+        try (final Filter<SourceRecord> transform = new Filter<>()) {\n+            final Map<String, String> props = new HashMap<>();\n+            props.put(EXPRESSION, \"operation == 'd'\");\n+            props.put(LANGUAGE, \"jython\");\n+            transform.configure(props);\n+        }\n+    }\n+\n+    @Test(expected = DebeziumException.class)\n+    public void shouldFailToParseCondition() {\n+        try (final Filter<SourceRecord> transform = new Filter<>()) {\n+            final Map<String, String> props = new HashMap<>();\n+            props.put(EXPRESSION, \"operation == 'd\");\n+            props.put(LANGUAGE, \"groovy\");\n+            transform.configure(props);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldProcessCondition() {\n+        try (final Filter<SourceRecord> transform = new Filter<>()) {\n+            final Map<String, String> props = new HashMap<>();\n+            props.put(EXPRESSION, \"value.op == 'd' && value.before.id == 2\");", "originalCommit": "6cbc3221c48227a736435cbb923dc06e888d4e74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA3NzE0NQ==", "url": "https://github.com/debezium/debezium/pull/1366#discussion_r399077145", "bodyText": "@gunnarmorling That's Groovy magic :-), if such properties are not available but method get is  then it is used - that's derive from Map handling.", "author": "jpechane", "createdAt": "2020-03-27T07:26:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA3NDQ3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4NTUzNw==", "url": "https://github.com/debezium/debezium/pull/1366#discussion_r399085537", "bodyText": "Ah, I see. So they automagically resolve it to .get(\"before\").get(\"id\"). Interesting indeed :)", "author": "gunnarmorling", "createdAt": "2020-03-27T07:49:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA3NDQ3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA3NDU5Ng==", "url": "https://github.com/debezium/debezium/pull/1366#discussion_r399074596", "bodyText": "We mostly do these as static imports.", "author": "gunnarmorling", "createdAt": "2020-03-27T07:19:28Z", "path": "debezium-core/src/test/java/io/debezium/transforms/FilterTest.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright Debezium Authors.\n+ *\n+ * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.debezium.transforms;\n+\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.kafka.connect.data.Schema;\n+import org.apache.kafka.connect.data.SchemaBuilder;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.connect.source.SourceRecord;\n+import org.fest.assertions.Assertions;\n+import org.junit.Test;\n+\n+import io.debezium.DebeziumException;\n+import io.debezium.data.Envelope;\n+\n+/**\n+ * @author Jiri Pechanec\n+ */\n+public class FilterTest {\n+\n+    private static final String LANGUAGE = \"language\";\n+    private static final String EXPRESSION = \"condition\";\n+    private static final String NULL_HANDLING = \"null.handling.mode\";\n+\n+    final Schema recordSchema = SchemaBuilder.struct()\n+            .field(\"id\", SchemaBuilder.int8())\n+            .field(\"name\", SchemaBuilder.string())\n+            .build();\n+\n+    final Schema sourceSchema = SchemaBuilder.struct()\n+            .field(\"lsn\", SchemaBuilder.int32())\n+            .build();\n+\n+    final Envelope envelope = Envelope.defineSchema()\n+            .withName(\"dummy.Envelope\")\n+            .withRecord(recordSchema)\n+            .withSource(sourceSchema)\n+            .build();\n+\n+    @Test(expected = DebeziumException.class)\n+    public void testLanguageRequired() {\n+        try (final Filter<SourceRecord> transform = new Filter<>()) {\n+            final Map<String, String> props = new HashMap<>();\n+            props.put(EXPRESSION, \"operation == 'd'\");\n+            transform.configure(props);\n+        }\n+    }\n+\n+    @Test(expected = DebeziumException.class)\n+    public void testExpressionRequired() {\n+        try (final Filter<SourceRecord> transform = new Filter<>()) {\n+            final Map<String, String> props = new HashMap<>();\n+            props.put(LANGUAGE, \"groovy\");\n+            transform.configure(props);\n+        }\n+    }\n+\n+    @Test(expected = DebeziumException.class)\n+    public void shouldFailOnUnkownLanguage() {\n+        try (final Filter<SourceRecord> transform = new Filter<>()) {\n+            final Map<String, String> props = new HashMap<>();\n+            props.put(EXPRESSION, \"operation == 'd'\");\n+            props.put(LANGUAGE, \"jython\");\n+            transform.configure(props);\n+        }\n+    }\n+\n+    @Test(expected = DebeziumException.class)\n+    public void shouldFailToParseCondition() {\n+        try (final Filter<SourceRecord> transform = new Filter<>()) {\n+            final Map<String, String> props = new HashMap<>();\n+            props.put(EXPRESSION, \"operation == 'd\");\n+            props.put(LANGUAGE, \"groovy\");\n+            transform.configure(props);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldProcessCondition() {\n+        try (final Filter<SourceRecord> transform = new Filter<>()) {\n+            final Map<String, String> props = new HashMap<>();\n+            props.put(EXPRESSION, \"value.op == 'd' && value.before.id == 2\");\n+            props.put(LANGUAGE, \"groovy\");\n+            transform.configure(props);\n+            final SourceRecord record = createDeleteRecord(1);\n+            Assertions.assertThat(transform.apply(createDeleteRecord(2))).isNull();", "originalCommit": "6cbc3221c48227a736435cbb923dc06e888d4e74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA3NTAzNg==", "url": "https://github.com/debezium/debezium/pull/1366#discussion_r399075036", "bodyText": "This reminds me a little bit of JSR 223. How about making this our primary entry point? That'd have the advantage that people could use any compatible scripting language.", "author": "gunnarmorling", "createdAt": "2020-03-27T07:20:39Z", "path": "debezium-core/src/main/java/io/debezium/transforms/filter/Engine.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright Debezium Authors.\n+ *\n+ * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.debezium.transforms.filter;\n+\n+import org.apache.kafka.connect.connector.ConnectRecord;\n+\n+/**\n+ * The interface serves as an abstraction of expression language engine.\n+ *\n+ * @author Jiri Pechanec\n+ */\n+public interface Engine {", "originalCommit": "6cbc3221c48227a736435cbb923dc06e888d4e74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4NjIzNw==", "url": "https://github.com/debezium/debezium/pull/1366#discussion_r399086237", "bodyText": "Ok, so I don't think we'd get the auto-magic resolving of \"properties\" of records here via 223. Or rather, it might depend on the chosen impl. Can you please try out GraalVM JS, it has a JSR 223 binding. This might become a popular choice. I'd like to see how this would work. Would have have to resolve those props ourselves? Might also be there's a resolver contract of sorts for which we could plug in an impl based on records.", "author": "gunnarmorling", "createdAt": "2020-03-27T07:51:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA3NTAzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4OTg5OQ==", "url": "https://github.com/debezium/debezium/pull/1366#discussion_r399089899", "bodyText": "Let me explain - I definitely intend to add support for JSR 223 in future. Right now I wanted to roll out a first implementation of scripting with the full power of Groovy, that's why I opted for native API. Even as it seems now to not be really important I guess we will need to slightly extend the DSL to handle schemas nicely.\nSo I prpose first to get this out and then create a follow up Jira for JS support. I understand why it is useful but I'd like first to check the API thoroughly as we might need to provide more elaborate bindings implementation that would allow the same syntax as we have with groovy right now. I need to now if JS engine has its own API that would allow us to inject the resolver or whether we would need to write Bindings in that way that they would return lmabdas/vs target values.", "author": "jpechane", "createdAt": "2020-03-27T07:59:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA3NTAzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5MjkxNA==", "url": "https://github.com/debezium/debezium/pull/1366#discussion_r399092914", "bodyText": "So do you consider Engine a user-facing contract? What would speak against coding against JSR 223 but use Groovy as the sole supported impl at this point? I'd like to avoid cornering ourselves by supporting just one thing and then having to change user-facing contracts later on.\n\nI need to now if JS engine has its own API...\n\nYes, of course. But that'd be a very valuable evaluation to do, and it could be done right now.", "author": "gunnarmorling", "createdAt": "2020-03-27T08:07:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA3NTAzNg=="}], "type": "inlineReview"}, {"oid": "cf09558b285d10893540f015e7dbb6cc62c78639", "url": "https://github.com/debezium/debezium/commit/cf09558b285d10893540f015e7dbb6cc62c78639", "message": "DBZ-1782 Use JSR223 API", "committedDate": "2020-03-31T08:36:30Z", "type": "commit"}, {"oid": "c72546c436259cf24a52c904c27033b47030e94f", "url": "https://github.com/debezium/debezium/commit/c72546c436259cf24a52c904c27033b47030e94f", "message": "DBZ-1782 Support for Graal JS", "committedDate": "2020-03-31T10:53:48Z", "type": "commit"}, {"oid": "03f7a08cb9745c84ccd1d574cc1f09d02f946438", "url": "https://github.com/debezium/debezium/commit/03f7a08cb9745c84ccd1d574cc1f09d02f946438", "message": "DBZ-1782 Microbenchmark of the filter", "committedDate": "2020-04-08T11:25:22Z", "type": "commit"}, {"oid": "03f7a08cb9745c84ccd1d574cc1f09d02f946438", "url": "https://github.com/debezium/debezium/commit/03f7a08cb9745c84ccd1d574cc1f09d02f946438", "message": "DBZ-1782 Microbenchmark of the filter", "committedDate": "2020-04-08T11:25:22Z", "type": "forcePushed"}, {"oid": "bf9ac93b13743583dd27b16706a8bcafa3dc03d0", "url": "https://github.com/debezium/debezium/commit/bf9ac93b13743583dd27b16706a8bcafa3dc03d0", "message": "DBZ-1782 Misc. fixes", "committedDate": "2020-04-09T15:58:47Z", "type": "commit"}]}