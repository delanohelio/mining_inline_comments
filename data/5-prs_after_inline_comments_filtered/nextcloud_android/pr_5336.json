{"pr_number": 5336, "pr_title": "Fds tests", "pr_createdAt": "2020-01-28T06:49:11Z", "pr_url": "https://github.com/nextcloud/android/pull/5336", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTcxNjU2OQ==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r371716569", "bodyText": "Issue found: Avoid instantiating new objects inside loops", "author": "nextcloud-android-bot", "createdAt": "2020-01-28T10:21:10Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -1605,111 +1579,118 @@ public void saveSharesInFolder(ArrayList<OCShare> shares, OCFile folder) {\n                 Log_OC.e(TAG, EXCEPTION_MSG + e.getMessage(), e);\n             }\n         }\n-\n     }\n \n     /**\n      * Prepare operations to insert or update files to save in the given folder\n-     * @param shares        List of shares to insert\n-     * @param operations    List of operations\n+     *\n+     * @param shares     List of shares to insert\n+     * @param operations List of operations\n      * @return\n      */\n     private ArrayList<ContentProviderOperation> prepareInsertShares(\n-            List<OCShare> shares, ArrayList<ContentProviderOperation> operations) {\n+        List<OCShare> shares, ArrayList<ContentProviderOperation> operations) {\n \n-        if (shares != null) {\n-            ContentValues cv;\n-            // prepare operations to insert or update files to save in the given folder\n-            for (OCShare share : shares) {\n-                cv = new ContentValues();\n-                cv.put(ProviderTableMeta.OCSHARES_FILE_SOURCE, share.getFileSource());\n-                cv.put(ProviderTableMeta.OCSHARES_ITEM_SOURCE, share.getItemSource());\n-                cv.put(ProviderTableMeta.OCSHARES_SHARE_TYPE, share.getShareType().getValue());\n-                cv.put(ProviderTableMeta.OCSHARES_SHARE_WITH, share.getShareWith());\n-                cv.put(ProviderTableMeta.OCSHARES_PATH, share.getPath());\n-                cv.put(ProviderTableMeta.OCSHARES_PERMISSIONS, share.getPermissions());\n-                cv.put(ProviderTableMeta.OCSHARES_SHARED_DATE, share.getSharedDate());\n-                cv.put(ProviderTableMeta.OCSHARES_EXPIRATION_DATE, share.getExpirationDate());\n-                cv.put(ProviderTableMeta.OCSHARES_TOKEN, share.getToken());\n-                cv.put(ProviderTableMeta.OCSHARES_SHARE_WITH_DISPLAY_NAME, share.getSharedWithDisplayName());\n-                cv.put(ProviderTableMeta.OCSHARES_IS_DIRECTORY, share.isFolder() ? 1 : 0);\n-                cv.put(ProviderTableMeta.OCSHARES_USER_ID, share.getUserId());\n-                cv.put(ProviderTableMeta.OCSHARES_ID_REMOTE_SHARED, share.getRemoteId());\n-                cv.put(ProviderTableMeta.OCSHARES_ACCOUNT_OWNER, account.name);\n-                cv.put(ProviderTableMeta.OCSHARES_IS_PASSWORD_PROTECTED, share.isPasswordProtected() ? 1 : 0);\n-                cv.put(ProviderTableMeta.OCSHARES_NOTE, share.getNote());\n-                cv.put(ProviderTableMeta.OCSHARES_HIDE_DOWNLOAD, share.isHideFileDownload());\n-\n-                // adding a new share resource\n-                operations.add(ContentProviderOperation.newInsert(\n-                        ProviderTableMeta.CONTENT_URI_SHARE).withValues(cv).build());\n-            }\n+        ContentValues contentValues;\n+        // prepare operations to insert or update files to save in the given folder\n+        for (OCShare share : shares) {\n+            contentValues = new ContentValues();", "originalCommit": "93fb7d610f6c667ae4b93b003ef3100d21600b01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTcxNjU4NA==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r371716584", "bodyText": "Issue found: Assigning an Object to null is a code smell.  Consider refactoring.", "author": "nextcloud-android-bot", "createdAt": "2020-01-28T10:21:12Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -87,61 +88,70 @@\n     private ContentProviderClient contentProviderClient;\n     @Setter private Account account;\n \n-    public FileDataStorageManager(Account account, ContentResolver cr) {\n-        contentProviderClient = null;\n-        contentResolver = cr;\n+    public FileDataStorageManager(Account account, ContentResolver contentResolver) {\n+        this.contentProviderClient = null;", "originalCommit": "93fb7d610f6c667ae4b93b003ef3100d21600b01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTcxNjU5NQ==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r371716595", "bodyText": "Issue found: Avoid unused local variables such as 'contentUriShare'.", "author": "nextcloud-android-bot", "createdAt": "2020-01-28T10:21:13Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -841,238 +860,223 @@ public void migrateStoredFiles(String srcPath, String dstPath)\n     }\n \n     private List<OCFile> getFolderContent(long parentId, boolean onlyOnDevice) {\n+        List<OCFile> folderContent = new ArrayList<>();\n \n-        List<OCFile> ret = new ArrayList<>();\n-\n-        Uri req_uri = Uri.withAppendedPath(ProviderTableMeta.CONTENT_URI_DIR, String.valueOf(parentId));\n-        Cursor c;\n+        Uri requestURI = Uri.withAppendedPath(ProviderTableMeta.CONTENT_URI_DIR, String.valueOf(parentId));\n+        Cursor cursor;\n \n         if (getContentProviderClient() != null) {\n             try {\n-                c = getContentProviderClient().query(\n-                        req_uri,\n-                        null,\n-                        ProviderTableMeta.FILE_PARENT + \"=?\",\n-                        new String[]{String.valueOf(parentId)},\n-                        null\n+                cursor = getContentProviderClient().query(\n+                    requestURI,\n+                    null,\n+                    ProviderTableMeta.FILE_PARENT + \"=?\",\n+                    new String[]{String.valueOf(parentId)},\n+                    null\n                 );\n             } catch (RemoteException e) {\n                 Log_OC.e(TAG, e.getMessage(), e);\n-                return ret;\n+                return folderContent;\n             }\n         } else {\n-            c = getContentResolver().query(\n-                    req_uri,\n-                    null,\n-                    ProviderTableMeta.FILE_PARENT + \"=?\",\n-                    new String[]{String.valueOf(parentId)},\n-                    null\n+            cursor = getContentResolver().query(\n+                requestURI,\n+                null,\n+                ProviderTableMeta.FILE_PARENT + \"=?\",\n+                new String[]{String.valueOf(parentId)},\n+                null\n             );\n         }\n \n-        if (c != null) {\n-            if (c.moveToFirst()) {\n+        if (cursor != null) {\n+            if (cursor.moveToFirst()) {\n                 do {\n-                    OCFile child = createFileInstance(c);\n+                    OCFile child = createFileInstance(cursor);\n                     if (!onlyOnDevice || child.existsOnDevice()) {\n-                        ret.add(child);\n+                        folderContent.add(child);\n                     }\n-                } while (c.moveToNext());\n+                } while (cursor.moveToNext());\n             }\n-\n-            c.close();\n+            cursor.close();\n         }\n \n-        return ret;\n+        return folderContent;\n     }\n \n \n     private OCFile createRootDir() {\n-        OCFile file = new OCFile(OCFile.ROOT_PATH);\n-        file.setMimeType(MimeType.DIRECTORY);\n-        file.setParentId(FileDataStorageManager.ROOT_PARENT_ID);\n-        saveFile(file);\n-        return file;\n+        OCFile ocFile = new OCFile(OCFile.ROOT_PATH);\n+        ocFile.setMimeType(MimeType.DIRECTORY);\n+        ocFile.setParentId(FileDataStorageManager.ROOT_PARENT_ID);\n+        saveFile(ocFile);\n+\n+        return ocFile;\n     }\n \n-    private boolean fileExists(String cmp_key, String value) {\n-        Cursor c;\n-        if (getContentResolver() != null) {\n-            c = getContentResolver()\n-                    .query(ProviderTableMeta.CONTENT_URI,\n-                            null,\n-                            cmp_key + AND\n-                                    + ProviderTableMeta.FILE_ACCOUNT_OWNER\n-                                    + \"=?\",\n-                            new String[]{value, account.name}, null);\n+    // TODO write test\n+    private boolean fileExists(String key, String value) {\n+        Cursor cursor = getFileCursorForValue(key, value);\n+        boolean isExists = false;\n+\n+        if (cursor == null) {\n+            Log_OC.e(TAG, \"Couldn't determine file existance, assuming non existance\");\n         } else {\n-            try {\n-                c = getContentProviderClient().query(\n-                        ProviderTableMeta.CONTENT_URI,\n-                        null,\n-                        cmp_key + AND\n-                                + ProviderTableMeta.FILE_ACCOUNT_OWNER + \"=?\",\n-                        new String[]{value, account.name}, null);\n-            } catch (RemoteException e) {\n-                Log_OC.e(TAG, \"Couldn't determine file existance, assuming non existance: \" + e.getMessage(), e);\n-                return false;\n-            }\n+            isExists = cursor.moveToFirst();\n+            cursor.close();\n         }\n-        boolean retval = c.moveToFirst();\n-        c.close();\n-        return retval;\n+\n+        return isExists;\n     }\n \n     private Cursor getFileCursorForValue(String key, String value) {\n-        Cursor c;\n+        Cursor cursor;\n         if (getContentResolver() != null) {\n-            c = getContentResolver()\n-                    .query(ProviderTableMeta.CONTENT_URI,\n-                            null,\n-                            key + AND\n-                                    + ProviderTableMeta.FILE_ACCOUNT_OWNER\n-                                    + \"=?\",\n-                            new String[]{value, account.name}, null);\n+            cursor = getContentResolver()\n+                .query(ProviderTableMeta.CONTENT_URI,\n+                       null,\n+                       key + AND\n+                           + ProviderTableMeta.FILE_ACCOUNT_OWNER\n+                           + \"=?\",\n+                       new String[]{value, account.name}, null);\n         } else {\n             try {\n-                c = getContentProviderClient().query(\n-                        ProviderTableMeta.CONTENT_URI,\n-                        null,\n-                        key + AND + ProviderTableMeta.FILE_ACCOUNT_OWNER\n-                                + \"=?\", new String[]{value, account.name},\n-                        null);\n+                cursor = getContentProviderClient().query(\n+                    ProviderTableMeta.CONTENT_URI,\n+                    null,\n+                    key + AND + ProviderTableMeta.FILE_ACCOUNT_OWNER\n+                        + \"=?\", new String[]{value, account.name},\n+                    null);\n             } catch (RemoteException e) {\n                 Log_OC.e(TAG, \"Could not get file details: \" + e.getMessage(), e);\n-                c = null;\n+                cursor = null;\n             }\n         }\n-        return c;\n+        return cursor;\n     }\n \n     @Nullable\n-    private OCFile createFileInstanceFromVirtual(Cursor c) {\n-        OCFile file = null;\n-        if (c != null) {\n-            long fileId = c.getLong(c.getColumnIndex(ProviderTableMeta.VIRTUAL_OCFILE_ID));\n-            file = getFileById(fileId);\n-        }\n+    private OCFile createFileInstanceFromVirtual(Cursor cursor) {\n+        long fileId = cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.VIRTUAL_OCFILE_ID));\n \n-        return file;\n+        return getFileById(fileId);\n     }\n \n-    private OCFile createFileInstance(Cursor c) {\n-        OCFile file = null;\n-        if (c != null) {\n-            file = new OCFile(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_PATH)));\n-            file.setFileId(c.getLong(c.getColumnIndex(ProviderTableMeta._ID)));\n-            file.setParentId(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_PARENT)));\n-            file.setEncryptedFileName(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_ENCRYPTED_NAME)));\n-            file.setMimeType(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_CONTENT_TYPE)));\n-            file.setStoragePath(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_STORAGE_PATH)));\n-            if (file.getStoragePath() == null) {\n+    private OCFile createFileInstance(Cursor cursor) {\n+        OCFile ocFile = null;\n+        if (cursor != null) {\n+            ocFile = new OCFile(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_PATH)));\n+            ocFile.setFileId(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta._ID)));\n+            ocFile.setParentId(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_PARENT)));\n+            ocFile.setEncryptedFileName(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_ENCRYPTED_NAME)));\n+            ocFile.setMimeType(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_CONTENT_TYPE)));\n+            ocFile.setStoragePath(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_STORAGE_PATH)));\n+            if (ocFile.getStoragePath() == null) {\n                 // try to find existing file and bind it with current account;\n                 // with the current update of SynchronizeFolderOperation, this won't be\n                 // necessary anymore after a full synchronization of the account\n-                File f = new File(FileStorageUtils.getDefaultSavePathFor(account.name, file));\n-                if (f.exists()) {\n-                    file.setStoragePath(f.getAbsolutePath());\n-                    file.setLastSyncDateForData(f.lastModified());\n+                File file = new File(FileStorageUtils.getDefaultSavePathFor(account.name, ocFile));\n+                if (file.exists()) {\n+                    ocFile.setStoragePath(file.getAbsolutePath());\n+                    ocFile.setLastSyncDateForData(file.lastModified());\n                 }\n             }\n-            file.setFileLength(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_CONTENT_LENGTH)));\n-            file.setCreationTimestamp(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_CREATION)));\n-            file.setModificationTimestamp(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_MODIFIED)));\n-            file.setModificationTimestampAtLastSyncForData(c.getLong(\n-                    c.getColumnIndex(ProviderTableMeta.FILE_MODIFIED_AT_LAST_SYNC_FOR_DATA)));\n-            file.setLastSyncDateForProperties(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_LAST_SYNC_DATE)));\n-            file.setLastSyncDateForData(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_LAST_SYNC_DATE_FOR_DATA)));\n-            file.setEtag(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_ETAG)));\n-            file.setEtagOnServer(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_ETAG_ON_SERVER)));\n-            file.setSharedViaLink(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_SHARED_VIA_LINK)) == 1);\n-            file.setSharedWithSharee(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_SHARED_WITH_SHAREE)) == 1);\n-            file.setPublicLink(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_PUBLIC_LINK)));\n-            file.setPermissions(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_PERMISSIONS)));\n-            file.setRemoteId(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_REMOTE_ID)));\n-            file.setUpdateThumbnailNeeded(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_UPDATE_THUMBNAIL)) == 1);\n-            file.setDownloading(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_IS_DOWNLOADING)) == 1);\n-            file.setEtagInConflict(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_ETAG_IN_CONFLICT)));\n-            file.setFavorite(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_FAVORITE)) == 1);\n-            file.setEncrypted(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_IS_ENCRYPTED)) == 1);\n-            if (file.isEncrypted()) {\n-                file.setFileName(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_NAME)));\n-            }\n-            file.setMountType(WebdavEntry.MountType.values()[c.getInt(\n-                    c.getColumnIndex(ProviderTableMeta.FILE_MOUNT_TYPE))]);\n-            file.setPreviewAvailable(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_HAS_PREVIEW)) == 1);\n-            file.setUnreadCommentsCount(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_UNREAD_COMMENTS_COUNT)));\n-            file.setOwnerId(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_OWNER_ID)));\n-            file.setOwnerDisplayName(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_OWNER_DISPLAY_NAME)));\n-            file.setNote(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_NOTE)));\n-            file.setRichWorkspace(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_RICH_WORKSPACE)));\n-\n-            String sharees = c.getString(c.getColumnIndex(ProviderTableMeta.FILE_SHAREES));\n+            ocFile.setFileLength(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_CONTENT_LENGTH)));\n+            ocFile.setCreationTimestamp(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_CREATION)));\n+            ocFile.setModificationTimestamp(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_MODIFIED)));\n+            ocFile.setModificationTimestampAtLastSyncForData(cursor.getLong(\n+                cursor.getColumnIndex(ProviderTableMeta.FILE_MODIFIED_AT_LAST_SYNC_FOR_DATA)));\n+            ocFile.setLastSyncDateForProperties(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_LAST_SYNC_DATE)));\n+            ocFile.setLastSyncDateForData(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_LAST_SYNC_DATE_FOR_DATA)));\n+            ocFile.setEtag(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_ETAG)));\n+            ocFile.setEtagOnServer(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_ETAG_ON_SERVER)));\n+            ocFile.setSharedViaLink(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_SHARED_VIA_LINK)) == 1);\n+            ocFile.setSharedWithSharee(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_SHARED_WITH_SHAREE)) == 1);\n+            ocFile.setPublicLink(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_PUBLIC_LINK)));\n+            ocFile.setPermissions(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_PERMISSIONS)));\n+            ocFile.setRemoteId(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_REMOTE_ID)));\n+            ocFile.setUpdateThumbnailNeeded(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_UPDATE_THUMBNAIL)) == 1);\n+            ocFile.setDownloading(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_IS_DOWNLOADING)) == 1);\n+            ocFile.setEtagInConflict(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_ETAG_IN_CONFLICT)));\n+            ocFile.setFavorite(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_FAVORITE)) == 1);\n+            ocFile.setEncrypted(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_IS_ENCRYPTED)) == 1);\n+            if (ocFile.isEncrypted()) {\n+                ocFile.setFileName(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_NAME)));\n+            }\n+            ocFile.setMountType(WebdavEntry.MountType.values()[cursor.getInt(\n+                cursor.getColumnIndex(ProviderTableMeta.FILE_MOUNT_TYPE))]);\n+            ocFile.setPreviewAvailable(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_HAS_PREVIEW)) == 1);\n+            ocFile.setUnreadCommentsCount(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_UNREAD_COMMENTS_COUNT)));\n+            ocFile.setOwnerId(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_OWNER_ID)));\n+            ocFile.setOwnerDisplayName(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_OWNER_DISPLAY_NAME)));\n+            ocFile.setNote(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_NOTE)));\n+            ocFile.setRichWorkspace(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_RICH_WORKSPACE)));\n+\n+            String sharees = cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_SHAREES));\n \n             if (sharees == null || NULL_STRING.equals(sharees) || sharees.isEmpty()) {\n-                file.setSharees(new ArrayList<>());\n+                ocFile.setSharees(new ArrayList<>());\n             } else {\n                 try {\n                     ShareeUser[] shareesArray = new Gson().fromJson(sharees, ShareeUser[].class);\n \n-                    file.setSharees(new ArrayList<>(Arrays.asList(shareesArray)));\n+                    ocFile.setSharees(new ArrayList<>(Arrays.asList(shareesArray)));\n                 } catch (JsonSyntaxException e) {\n                     // ignore saved value due to api change\n-                    file.setSharees(new ArrayList<>());\n+                    ocFile.setSharees(new ArrayList<>());\n                 }\n             }\n         }\n \n-        return file;\n+        return ocFile;\n     }\n \n-    // Methods for Shares\n     public boolean saveShare(OCShare share) {\n         boolean overridden = false;\n-        ContentValues cv = new ContentValues();\n-        cv.put(ProviderTableMeta.OCSHARES_FILE_SOURCE, share.getFileSource());\n-        cv.put(ProviderTableMeta.OCSHARES_ITEM_SOURCE, share.getItemSource());\n-        cv.put(ProviderTableMeta.OCSHARES_SHARE_TYPE, share.getShareType().getValue());\n-        cv.put(ProviderTableMeta.OCSHARES_SHARE_WITH, share.getShareWith());\n-        cv.put(ProviderTableMeta.OCSHARES_PATH, share.getPath());\n-        cv.put(ProviderTableMeta.OCSHARES_PERMISSIONS, share.getPermissions());\n-        cv.put(ProviderTableMeta.OCSHARES_SHARED_DATE, share.getSharedDate());\n-        cv.put(ProviderTableMeta.OCSHARES_EXPIRATION_DATE, share.getExpirationDate());\n-        cv.put(ProviderTableMeta.OCSHARES_TOKEN, share.getToken());\n-        cv.put(ProviderTableMeta.OCSHARES_SHARE_WITH_DISPLAY_NAME, share.getSharedWithDisplayName());\n-        cv.put(ProviderTableMeta.OCSHARES_IS_DIRECTORY, share.isFolder() ? 1 : 0);\n-        cv.put(ProviderTableMeta.OCSHARES_USER_ID, share.getUserId());\n-        cv.put(ProviderTableMeta.OCSHARES_ID_REMOTE_SHARED, share.getRemoteId());\n-        cv.put(ProviderTableMeta.OCSHARES_ACCOUNT_OWNER, account.name);\n-        cv.put(ProviderTableMeta.OCSHARES_IS_PASSWORD_PROTECTED, share.isPasswordProtected() ? 1 : 0);\n-        cv.put(ProviderTableMeta.OCSHARES_NOTE, share.getNote());\n-        cv.put(ProviderTableMeta.OCSHARES_HIDE_DOWNLOAD, share.isHideFileDownload());\n+\n+        Uri contentUriShare = ProviderTableMeta.CONTENT_URI_SHARE;", "originalCommit": "93fb7d610f6c667ae4b93b003ef3100d21600b01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTcxNjYwNQ==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r371716605", "bodyText": "Issue found: Avoid instantiating new objects inside loops", "author": "nextcloud-android-bot", "createdAt": "2020-01-28T10:21:14Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -1337,70 +1340,67 @@ private void cleanShares() {\n         }\n     }\n \n+    // TODO shares null?\n     public void saveShares(Collection<OCShare> shares) {\n         cleanShares();\n-        if (shares != null) {\n-            ArrayList<ContentProviderOperation> operations =\n-                    new ArrayList<ContentProviderOperation>(shares.size());\n+        ArrayList<ContentProviderOperation> operations = new ArrayList<>(shares.size());\n \n-            // prepare operations to insert or update files to save in the given folder\n-            for (OCShare share : shares) {\n-                ContentValues cv = new ContentValues();\n-                cv.put(ProviderTableMeta.OCSHARES_FILE_SOURCE, share.getFileSource());\n-                cv.put(ProviderTableMeta.OCSHARES_ITEM_SOURCE, share.getItemSource());\n-                cv.put(ProviderTableMeta.OCSHARES_SHARE_TYPE, share.getShareType().getValue());\n-                cv.put(ProviderTableMeta.OCSHARES_SHARE_WITH, share.getShareWith());\n-                cv.put(ProviderTableMeta.OCSHARES_PATH, share.getPath());\n-                cv.put(ProviderTableMeta.OCSHARES_PERMISSIONS, share.getPermissions());\n-                cv.put(ProviderTableMeta.OCSHARES_SHARED_DATE, share.getSharedDate());\n-                cv.put(ProviderTableMeta.OCSHARES_EXPIRATION_DATE, share.getExpirationDate());\n-                cv.put(ProviderTableMeta.OCSHARES_TOKEN, share.getToken());\n-                cv.put(ProviderTableMeta.OCSHARES_SHARE_WITH_DISPLAY_NAME, share.getSharedWithDisplayName());\n-                cv.put(ProviderTableMeta.OCSHARES_IS_DIRECTORY, share.isFolder() ? 1 : 0);\n-                cv.put(ProviderTableMeta.OCSHARES_USER_ID, share.getUserId());\n-                cv.put(ProviderTableMeta.OCSHARES_ID_REMOTE_SHARED, share.getRemoteId());\n-                cv.put(ProviderTableMeta.OCSHARES_ACCOUNT_OWNER, account.name);\n-                cv.put(ProviderTableMeta.OCSHARES_IS_PASSWORD_PROTECTED, share.isPasswordProtected() ? 1 : 0);\n-                cv.put(ProviderTableMeta.OCSHARES_NOTE, share.getNote());\n-                cv.put(ProviderTableMeta.OCSHARES_HIDE_DOWNLOAD, share.isHideFileDownload());\n-\n-                if (shareExistsForRemoteId(share.getRemoteId())) {\n-                    // updating an existing file\n-                    operations.add(\n-                            ContentProviderOperation.newUpdate(ProviderTableMeta.CONTENT_URI_SHARE).\n-                                    withValues(cv).\n-                                    withSelection(ProviderTableMeta.OCSHARES_ID_REMOTE_SHARED + \"=?\",\n-                                            new String[]{String.valueOf(share.getRemoteId())})\n-                                    .build());\n-                } else {\n-                    // adding a new file\n-                    operations.add(\n-                            ContentProviderOperation.newInsert(ProviderTableMeta.CONTENT_URI_SHARE).\n-                                    withValues(cv).\n-                                    build()\n-                    );\n-                }\n+        // prepare operations to insert or update files to save in the given folder\n+        for (OCShare share : shares) {\n+            ContentValues contentValues = new ContentValues();", "originalCommit": "93fb7d610f6c667ae4b93b003ef3100d21600b01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTcxNjYxNA==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r371716614", "bodyText": "Issue found: Avoid really long methods.", "author": "nextcloud-android-bot", "createdAt": "2020-01-28T10:21:15Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -324,65 +336,67 @@ public void saveNewFile(OCFile newFile) {\n     /**\n      * Inserts or updates the list of files contained in a given folder.\n      *\n-     * CALLER IS RESPONSIBLE FOR GRANTING RIGHT UPDATE OF INFORMATION, NOT THIS METHOD.\n-     * HERE ONLY DATA CONSISTENCY SHOULD BE GRANTED\n+     * CALLER IS RESPONSIBLE FOR GRANTING RIGHT UPDATE OF INFORMATION, NOT THIS METHOD. HERE ONLY DATA CONSISTENCY\n+     * SHOULD BE GRANTED\n      *\n      * @param folder\n      * @param updatedFiles\n      * @param filesToRemove\n      */\n-    public void saveFolder(OCFile folder, Collection<OCFile> updatedFiles, Collection<OCFile> filesToRemove) {\n+    public void saveFolder(OCFile folder, List<OCFile> updatedFiles, Collection<OCFile> filesToRemove) {", "originalCommit": "93fb7d610f6c667ae4b93b003ef3100d21600b01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTcxNjYyMg==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r371716622", "bodyText": "Issue found: Assigning an Object to null is a code smell.  Consider refactoring.", "author": "nextcloud-android-bot", "createdAt": "2020-01-28T10:21:16Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -417,19 +431,18 @@ public void saveFolder(OCFile folder, Collection<OCFile> updatedFiles, Collectio\n         // update new id in file objects for insertions\n         if (results != null) {\n             long newId;\n-            Iterator<OCFile> filesIt = updatedFiles.iterator();\n-            OCFile file;\n+            Iterator<OCFile> fileIterator = updatedFiles.iterator();\n+            OCFile ocFile;\n             for (ContentProviderResult result : results) {\n-                if (filesIt.hasNext()) {\n-                    file = filesIt.next();\n+                if (fileIterator.hasNext()) {\n+                    ocFile = fileIterator.next();\n                 } else {\n-                    file = null;\n+                    ocFile = null;", "originalCommit": "93fb7d610f6c667ae4b93b003ef3100d21600b01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTcxNjYzNA==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r371716634", "bodyText": "Issue found: Avoid instantiating new objects inside loops", "author": "nextcloud-android-bot", "createdAt": "2020-01-28T10:21:17Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -597,24 +613,22 @@ private boolean removeLocalFolder(OCFile folder) {\n         boolean success = true;\n         String localFolderPath = FileStorageUtils.getDefaultSavePathFor(account.name, folder);\n         File localFolder = new File(localFolderPath);\n+\n         if (localFolder.exists()) {\n             // stage 1: remove the local files already registered in the files database\n             List<OCFile> files = getFolderContent(folder.getFileId(), false);\n-            if (files != null) {\n-                for (OCFile file : files) {\n-                    if (file.isFolder()) {\n-                        success &= removeLocalFolder(file);\n-                    } else {\n-                        if (file.isDown()) {\n-                            File localFile = new File(file.getStoragePath());\n-                            success &= localFile.delete();\n-                            if (success) {\n-                                // notify MediaScanner about removed file\n-                                deleteFileInMediaScan(file.getStoragePath());\n-                                file.setStoragePath(null);\n-                                saveFile(file);\n-                            }\n-                        }\n+            for (OCFile ocFile : files) {\n+                if (ocFile.isFolder()) {\n+                    success &= removeLocalFolder(ocFile);\n+                } else if (ocFile.isDown()) {\n+                    File localFile = new File(ocFile.getStoragePath());", "originalCommit": "93fb7d610f6c667ae4b93b003ef3100d21600b01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTcxNjY0OA==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r371716648", "bodyText": "Issue found: Avoid really long methods.", "author": "nextcloud-android-bot", "createdAt": "2020-01-28T10:21:18Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -639,91 +655,92 @@ private boolean removeLocalFolder(File localFolder) {\n             }\n         }\n         success &= localFolder.delete();\n+\n         return success;\n     }\n \n     /**\n      * Updates database and file system for a file or folder that was moved to a different location.\n      *\n-     * TODO explore better (faster) implementations\n-     * TODO throw exceptions up !\n+     * TODO explore better (faster) implementations TODO throw exceptions up !\n      */\n-    public void moveLocalFile(OCFile file, String targetPath, String targetParentPath) {\n-\n-        if (file != null && file.fileExists() && !OCFile.ROOT_PATH.equals(file.getFileName())) {\n+    public void moveLocalFile(OCFile ocFile, String targetPath, String targetParentPath) {", "originalCommit": "93fb7d610f6c667ae4b93b003ef3100d21600b01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTcxNjY2MA==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r371716660", "bodyText": "Issue found: Avoid instantiating new objects inside loops", "author": "nextcloud-android-bot", "createdAt": "2020-01-28T10:21:19Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -324,65 +336,67 @@ public void saveNewFile(OCFile newFile) {\n     /**\n      * Inserts or updates the list of files contained in a given folder.\n      *\n-     * CALLER IS RESPONSIBLE FOR GRANTING RIGHT UPDATE OF INFORMATION, NOT THIS METHOD.\n-     * HERE ONLY DATA CONSISTENCY SHOULD BE GRANTED\n+     * CALLER IS RESPONSIBLE FOR GRANTING RIGHT UPDATE OF INFORMATION, NOT THIS METHOD. HERE ONLY DATA CONSISTENCY\n+     * SHOULD BE GRANTED\n      *\n      * @param folder\n      * @param updatedFiles\n      * @param filesToRemove\n      */\n-    public void saveFolder(OCFile folder, Collection<OCFile> updatedFiles, Collection<OCFile> filesToRemove) {\n+    public void saveFolder(OCFile folder, List<OCFile> updatedFiles, Collection<OCFile> filesToRemove) {\n         Log_OC.d(TAG, \"Saving folder \" + folder.getRemotePath() + \" with \" + updatedFiles.size()\n-                + \" children and \" + filesToRemove.size() + \" files to remove\");\n+            + \" children and \" + filesToRemove.size() + \" files to remove\");\n \n         ArrayList<ContentProviderOperation> operations = new ArrayList<>(updatedFiles.size());\n \n         // prepare operations to insert or update files to save in the given folder\n-        for (OCFile file : updatedFiles) {\n-            ContentValues cv = createContentValueForFile(file, folder);\n+        for (OCFile ocFile : updatedFiles) {\n+            ContentValues contentValues = createContentValueForFile(ocFile, folder);\n \n-            if (fileExists(file.getFileId()) || fileExists(file.getRemotePath())) {\n+            if (fileExists(ocFile.getFileId()) || fileExists(ocFile.getRemotePath())) {\n                 long fileId;\n-                if (file.getFileId() != -1) {\n-                    fileId = file.getFileId();\n+                if (ocFile.getFileId() != -1) {\n+                    fileId = ocFile.getFileId();\n                 } else {\n-                    fileId = getFileByPath(file.getRemotePath()).getFileId();\n+                    fileId = getFileByPath(ocFile.getRemotePath()).getFileId();\n                 }\n                 // updating an existing file\n                 operations.add(ContentProviderOperation.newUpdate(ProviderTableMeta.CONTENT_URI)\n-                        .withValues(cv)\n-                                   .withSelection(ProviderTableMeta._ID + \"=?\", new String[]{String.valueOf(fileId)})\n-                        .build());\n+                                   .withValues(contentValues)\n+                                   .withSelection(ProviderTableMeta._ID + \" = ?\", new String[]{String.valueOf(fileId)})\n+                                   .build());\n             } else {\n                 // adding a new file\n-                operations.add(ContentProviderOperation.newInsert(ProviderTableMeta.CONTENT_URI).withValues(cv).build());\n+                operations.add(ContentProviderOperation.newInsert(ProviderTableMeta.CONTENT_URI)\n+                                   .withValues(contentValues)\n+                                   .build());\n             }\n         }\n \n         // prepare operations to remove files in the given folder\n-        String where = ProviderTableMeta.FILE_ACCOUNT_OWNER + AND + ProviderTableMeta.FILE_PATH + \"=?\";\n+        String where = ProviderTableMeta.FILE_ACCOUNT_OWNER + AND + ProviderTableMeta.FILE_PATH + \" = ?\";\n         String[] whereArgs = new String[2];\n-        for (OCFile file : filesToRemove) {\n-            if (file.getParentId() == folder.getFileId()) {\n-                whereArgs[0] = account.name;\n-                whereArgs[1] = file.getRemotePath();\n-                if (file.isFolder()) {\n+        whereArgs[0] = account.name;\n+        for (OCFile ocFile : filesToRemove) {\n+            if (ocFile.getParentId() == folder.getFileId()) {\n+                whereArgs[1] = ocFile.getRemotePath();\n+                if (ocFile.isFolder()) {\n                     operations.add(ContentProviderOperation.newDelete(\n-                            ContentUris.withAppendedId(ProviderTableMeta.CONTENT_URI_DIR, file.getFileId()))\n-                            .withSelection(where, whereArgs).build());\n+                        ContentUris.withAppendedId(ProviderTableMeta.CONTENT_URI_DIR, ocFile.getFileId()))\n+                                       .withSelection(where, whereArgs).build());\n \n-                    File localFolder = new File(FileStorageUtils.getDefaultSavePathFor(account.name, file));\n+                    File localFolder = new File(FileStorageUtils.getDefaultSavePathFor(account.name, ocFile));", "originalCommit": "93fb7d610f6c667ae4b93b003ef3100d21600b01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTcxNjY3Ng==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r371716676", "bodyText": "Issue found: Avoid instantiating new objects inside loops", "author": "nextcloud-android-bot", "createdAt": "2020-01-28T10:21:21Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -324,65 +336,67 @@ public void saveNewFile(OCFile newFile) {\n     /**\n      * Inserts or updates the list of files contained in a given folder.\n      *\n-     * CALLER IS RESPONSIBLE FOR GRANTING RIGHT UPDATE OF INFORMATION, NOT THIS METHOD.\n-     * HERE ONLY DATA CONSISTENCY SHOULD BE GRANTED\n+     * CALLER IS RESPONSIBLE FOR GRANTING RIGHT UPDATE OF INFORMATION, NOT THIS METHOD. HERE ONLY DATA CONSISTENCY\n+     * SHOULD BE GRANTED\n      *\n      * @param folder\n      * @param updatedFiles\n      * @param filesToRemove\n      */\n-    public void saveFolder(OCFile folder, Collection<OCFile> updatedFiles, Collection<OCFile> filesToRemove) {\n+    public void saveFolder(OCFile folder, List<OCFile> updatedFiles, Collection<OCFile> filesToRemove) {\n         Log_OC.d(TAG, \"Saving folder \" + folder.getRemotePath() + \" with \" + updatedFiles.size()\n-                + \" children and \" + filesToRemove.size() + \" files to remove\");\n+            + \" children and \" + filesToRemove.size() + \" files to remove\");\n \n         ArrayList<ContentProviderOperation> operations = new ArrayList<>(updatedFiles.size());\n \n         // prepare operations to insert or update files to save in the given folder\n-        for (OCFile file : updatedFiles) {\n-            ContentValues cv = createContentValueForFile(file, folder);\n+        for (OCFile ocFile : updatedFiles) {\n+            ContentValues contentValues = createContentValueForFile(ocFile, folder);\n \n-            if (fileExists(file.getFileId()) || fileExists(file.getRemotePath())) {\n+            if (fileExists(ocFile.getFileId()) || fileExists(ocFile.getRemotePath())) {\n                 long fileId;\n-                if (file.getFileId() != -1) {\n-                    fileId = file.getFileId();\n+                if (ocFile.getFileId() != -1) {\n+                    fileId = ocFile.getFileId();\n                 } else {\n-                    fileId = getFileByPath(file.getRemotePath()).getFileId();\n+                    fileId = getFileByPath(ocFile.getRemotePath()).getFileId();\n                 }\n                 // updating an existing file\n                 operations.add(ContentProviderOperation.newUpdate(ProviderTableMeta.CONTENT_URI)\n-                        .withValues(cv)\n-                                   .withSelection(ProviderTableMeta._ID + \"=?\", new String[]{String.valueOf(fileId)})\n-                        .build());\n+                                   .withValues(contentValues)\n+                                   .withSelection(ProviderTableMeta._ID + \" = ?\", new String[]{String.valueOf(fileId)})\n+                                   .build());\n             } else {\n                 // adding a new file\n-                operations.add(ContentProviderOperation.newInsert(ProviderTableMeta.CONTENT_URI).withValues(cv).build());\n+                operations.add(ContentProviderOperation.newInsert(ProviderTableMeta.CONTENT_URI)\n+                                   .withValues(contentValues)\n+                                   .build());\n             }\n         }\n \n         // prepare operations to remove files in the given folder\n-        String where = ProviderTableMeta.FILE_ACCOUNT_OWNER + AND + ProviderTableMeta.FILE_PATH + \"=?\";\n+        String where = ProviderTableMeta.FILE_ACCOUNT_OWNER + AND + ProviderTableMeta.FILE_PATH + \" = ?\";\n         String[] whereArgs = new String[2];\n-        for (OCFile file : filesToRemove) {\n-            if (file.getParentId() == folder.getFileId()) {\n-                whereArgs[0] = account.name;\n-                whereArgs[1] = file.getRemotePath();\n-                if (file.isFolder()) {\n+        whereArgs[0] = account.name;\n+        for (OCFile ocFile : filesToRemove) {\n+            if (ocFile.getParentId() == folder.getFileId()) {\n+                whereArgs[1] = ocFile.getRemotePath();\n+                if (ocFile.isFolder()) {\n                     operations.add(ContentProviderOperation.newDelete(\n-                            ContentUris.withAppendedId(ProviderTableMeta.CONTENT_URI_DIR, file.getFileId()))\n-                            .withSelection(where, whereArgs).build());\n+                        ContentUris.withAppendedId(ProviderTableMeta.CONTENT_URI_DIR, ocFile.getFileId()))\n+                                       .withSelection(where, whereArgs).build());\n \n-                    File localFolder = new File(FileStorageUtils.getDefaultSavePathFor(account.name, file));\n+                    File localFolder = new File(FileStorageUtils.getDefaultSavePathFor(account.name, ocFile));\n                     if (localFolder.exists()) {\n                         removeLocalFolder(localFolder);\n                     }\n                 } else {\n                     operations.add(ContentProviderOperation.newDelete(\n-                            ContentUris.withAppendedId(ProviderTableMeta.CONTENT_URI_FILE, file.getFileId()))\n-                            .withSelection(where, whereArgs).build());\n+                        ContentUris.withAppendedId(ProviderTableMeta.CONTENT_URI_FILE, ocFile.getFileId()))\n+                                       .withSelection(where, whereArgs).build());\n \n-                    if (file.isDown()) {\n-                        String path = file.getStoragePath();\n-                        if (new File(path).delete() && MimeTypeUtil.isMedia(file.getMimeType())) {\n+                    if (ocFile.isDown()) {\n+                        String path = ocFile.getStoragePath();\n+                        if (new File(path).delete() && MimeTypeUtil.isMedia(ocFile.getMimeType())) {", "originalCommit": "93fb7d610f6c667ae4b93b003ef3100d21600b01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTcxNjY5Ng==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r371716696", "bodyText": "Issue found: Avoid really long methods.", "author": "nextcloud-android-bot", "createdAt": "2020-01-28T10:21:23Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -1741,67 +1722,66 @@ public static void triggerMediaScan(String path) {\n     }\n \n     public void deleteFileInMediaScan(String path) {\n-\n         String mimetypeString = FileStorageUtils.getMimeTypeFromName(path);\n         ContentResolver contentResolver = getContentResolver();\n \n         if (contentResolver != null) {\n             if (MimeTypeUtil.isImage(mimetypeString)) {\n                 // Images\n                 contentResolver.delete(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n-                        MediaStore.Images.Media.DATA + \"=?\", new String[]{path});\n+                                       MediaStore.Images.Media.DATA + \"=?\", new String[]{path});\n             } else if (MimeTypeUtil.isAudio(mimetypeString)) {\n                 // Audio\n                 contentResolver.delete(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n-                        MediaStore.Audio.Media.DATA + \"=?\", new String[]{path});\n+                                       MediaStore.Audio.Media.DATA + \"=?\", new String[]{path});\n             } else if (MimeTypeUtil.isVideo(mimetypeString)) {\n                 // Video\n                 contentResolver.delete(MediaStore.Video.Media.EXTERNAL_CONTENT_URI,\n-                        MediaStore.Video.Media.DATA + \"=?\", new String[]{path});\n+                                       MediaStore.Video.Media.DATA + \"=?\", new String[]{path});\n             }\n         } else {\n             ContentProviderClient contentProviderClient = getContentProviderClient();\n             try {\n                 if (MimeTypeUtil.isImage(mimetypeString)) {\n                     // Images\n                     contentProviderClient.delete(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n-                            MediaStore.Images.Media.DATA + \"=?\", new String[]{path});\n+                                                 MediaStore.Images.Media.DATA + \"=?\", new String[]{path});\n                 } else if (MimeTypeUtil.isAudio(mimetypeString)) {\n                     // Audio\n                     contentProviderClient.delete(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n-                            MediaStore.Audio.Media.DATA + \"=?\", new String[]{path});\n+                                                 MediaStore.Audio.Media.DATA + \"=?\", new String[]{path});\n                 } else if (MimeTypeUtil.isVideo(mimetypeString)) {\n                     // Video\n                     contentProviderClient.delete(MediaStore.Video.Media.EXTERNAL_CONTENT_URI,\n-                            MediaStore.Video.Media.DATA + \"=?\", new String[]{path});\n+                                                 MediaStore.Video.Media.DATA + \"=?\", new String[]{path});\n                 }\n             } catch (RemoteException e) {\n                 Log_OC.e(TAG, \"Exception deleting media file in MediaStore \" + e.getMessage(), e);\n             }\n         }\n     }\n \n-    public void saveConflict(OCFile file, String etagInConflict) {\n-        if (!file.isDown()) {\n+    public void saveConflict(OCFile ocFile, String etagInConflict) {", "originalCommit": "93fb7d610f6c667ae4b93b003ef3100d21600b01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTcxNjcwNQ==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r371716705", "bodyText": "Issue found: Avoid instantiating new objects inside loops", "author": "nextcloud-android-bot", "createdAt": "2020-01-28T10:21:24Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -639,91 +655,92 @@ private boolean removeLocalFolder(File localFolder) {\n             }\n         }\n         success &= localFolder.delete();\n+\n         return success;\n     }\n \n     /**\n      * Updates database and file system for a file or folder that was moved to a different location.\n      *\n-     * TODO explore better (faster) implementations\n-     * TODO throw exceptions up !\n+     * TODO explore better (faster) implementations TODO throw exceptions up !\n      */\n-    public void moveLocalFile(OCFile file, String targetPath, String targetParentPath) {\n-\n-        if (file != null && file.fileExists() && !OCFile.ROOT_PATH.equals(file.getFileName())) {\n+    public void moveLocalFile(OCFile ocFile, String targetPath, String targetParentPath) {\n+        if (ocFile.fileExists() && !OCFile.ROOT_PATH.equals(ocFile.getFileName())) {\n \n             OCFile targetParent = getFileByPath(targetParentPath);\n             if (targetParent == null) {\n                 throw new IllegalStateException(\"Parent folder of the target path does not exist!!\");\n             }\n \n             /// 1. get all the descendants of the moved element in a single QUERY\n-            Cursor c = null;\n+            Cursor cursor = null;\n             if (getContentProviderClient() != null) {\n                 try {\n-                    c = getContentProviderClient().query(\n-                            ProviderTableMeta.CONTENT_URI,\n-                            null,\n-                            ProviderTableMeta.FILE_ACCOUNT_OWNER + AND + ProviderTableMeta.FILE_PATH + \" LIKE ? \",\n-                            new String[]{account.name, file.getRemotePath() + \"%\"},\n-                            ProviderTableMeta.FILE_PATH + \" ASC \"\n+                    cursor = getContentProviderClient().query(\n+                        ProviderTableMeta.CONTENT_URI,\n+                        null,\n+                        ProviderTableMeta.FILE_ACCOUNT_OWNER + AND + ProviderTableMeta.FILE_PATH + \" LIKE ? \",\n+                        new String[]{account.name, ocFile.getRemotePath() + \"%\"},\n+                        ProviderTableMeta.FILE_PATH + \" ASC \"\n                     );\n                 } catch (RemoteException e) {\n                     Log_OC.e(TAG, e.getMessage(), e);\n                 }\n \n             } else {\n-                c = getContentResolver().query(\n-                        ProviderTableMeta.CONTENT_URI,\n-                        null,\n-                        ProviderTableMeta.FILE_ACCOUNT_OWNER + AND + ProviderTableMeta.FILE_PATH + \" LIKE ? \",\n-                        new String[]{account.name, file.getRemotePath() + \"%\"},\n-                        ProviderTableMeta.FILE_PATH + \" ASC \"\n+                cursor = getContentResolver().query(\n+                    ProviderTableMeta.CONTENT_URI,\n+                    null,\n+                    ProviderTableMeta.FILE_ACCOUNT_OWNER + AND + ProviderTableMeta.FILE_PATH + \" LIKE ? \",\n+                    new String[]{account.name, ocFile.getRemotePath() + \"%\"},\n+                    ProviderTableMeta.FILE_PATH + \" ASC \"\n                 );\n             }\n \n             /// 2. prepare a batch of update operations to change all the descendants\n-            ArrayList<ContentProviderOperation> operations = new ArrayList<>(c.getCount());\n+            ArrayList<ContentProviderOperation> operations = new ArrayList<>(cursor.getCount());\n             String defaultSavePath = FileStorageUtils.getSavePath(account.name);\n             List<String> originalPathsToTriggerMediaScan = new ArrayList<>();\n             List<String> newPathsToTriggerMediaScan = new ArrayList<>();\n-            if (c.moveToFirst()) {\n-                int lengthOfOldPath = file.getRemotePath().length();\n+\n+            if (cursor.moveToFirst()) {\n+                int lengthOfOldPath = ocFile.getRemotePath().length();\n                 int lengthOfOldStoragePath = defaultSavePath.length() + lengthOfOldPath;\n-                String[] fileId = new String[1];\n                 do {\n-                    ContentValues cv = new ContentValues(); // keep construction in the loop\n-                    OCFile child = createFileInstance(c);\n-                    cv.put(\n-                            ProviderTableMeta.FILE_PATH,\n-                            targetPath + child.getRemotePath().substring(lengthOfOldPath)\n+                    ContentValues contentValues = new ContentValues(); // keep construction in the loop", "originalCommit": "93fb7d610f6c667ae4b93b003ef3100d21600b01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTcxNjcxOA==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r371716718", "bodyText": "Issue found: Avoid reassigning parameters such as 'etagInConflict'", "author": "nextcloud-android-bot", "createdAt": "2020-01-28T10:21:25Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -1741,67 +1722,66 @@ public static void triggerMediaScan(String path) {\n     }\n \n     public void deleteFileInMediaScan(String path) {\n-\n         String mimetypeString = FileStorageUtils.getMimeTypeFromName(path);\n         ContentResolver contentResolver = getContentResolver();\n \n         if (contentResolver != null) {\n             if (MimeTypeUtil.isImage(mimetypeString)) {\n                 // Images\n                 contentResolver.delete(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n-                        MediaStore.Images.Media.DATA + \"=?\", new String[]{path});\n+                                       MediaStore.Images.Media.DATA + \"=?\", new String[]{path});\n             } else if (MimeTypeUtil.isAudio(mimetypeString)) {\n                 // Audio\n                 contentResolver.delete(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n-                        MediaStore.Audio.Media.DATA + \"=?\", new String[]{path});\n+                                       MediaStore.Audio.Media.DATA + \"=?\", new String[]{path});\n             } else if (MimeTypeUtil.isVideo(mimetypeString)) {\n                 // Video\n                 contentResolver.delete(MediaStore.Video.Media.EXTERNAL_CONTENT_URI,\n-                        MediaStore.Video.Media.DATA + \"=?\", new String[]{path});\n+                                       MediaStore.Video.Media.DATA + \"=?\", new String[]{path});\n             }\n         } else {\n             ContentProviderClient contentProviderClient = getContentProviderClient();\n             try {\n                 if (MimeTypeUtil.isImage(mimetypeString)) {\n                     // Images\n                     contentProviderClient.delete(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n-                            MediaStore.Images.Media.DATA + \"=?\", new String[]{path});\n+                                                 MediaStore.Images.Media.DATA + \"=?\", new String[]{path});\n                 } else if (MimeTypeUtil.isAudio(mimetypeString)) {\n                     // Audio\n                     contentProviderClient.delete(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n-                            MediaStore.Audio.Media.DATA + \"=?\", new String[]{path});\n+                                                 MediaStore.Audio.Media.DATA + \"=?\", new String[]{path});\n                 } else if (MimeTypeUtil.isVideo(mimetypeString)) {\n                     // Video\n                     contentProviderClient.delete(MediaStore.Video.Media.EXTERNAL_CONTENT_URI,\n-                            MediaStore.Video.Media.DATA + \"=?\", new String[]{path});\n+                                                 MediaStore.Video.Media.DATA + \"=?\", new String[]{path});\n                 }\n             } catch (RemoteException e) {\n                 Log_OC.e(TAG, \"Exception deleting media file in MediaStore \" + e.getMessage(), e);\n             }\n         }\n     }\n \n-    public void saveConflict(OCFile file, String etagInConflict) {\n-        if (!file.isDown()) {\n+    public void saveConflict(OCFile ocFile, String etagInConflict) {", "originalCommit": "93fb7d610f6c667ae4b93b003ef3100d21600b01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTcxNjczMQ==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r371716731", "bodyText": "Issue found: Avoid instantiating new objects inside loops", "author": "nextcloud-android-bot", "createdAt": "2020-01-28T10:21:27Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -639,91 +655,92 @@ private boolean removeLocalFolder(File localFolder) {\n             }\n         }\n         success &= localFolder.delete();\n+\n         return success;\n     }\n \n     /**\n      * Updates database and file system for a file or folder that was moved to a different location.\n      *\n-     * TODO explore better (faster) implementations\n-     * TODO throw exceptions up !\n+     * TODO explore better (faster) implementations TODO throw exceptions up !\n      */\n-    public void moveLocalFile(OCFile file, String targetPath, String targetParentPath) {\n-\n-        if (file != null && file.fileExists() && !OCFile.ROOT_PATH.equals(file.getFileName())) {\n+    public void moveLocalFile(OCFile ocFile, String targetPath, String targetParentPath) {\n+        if (ocFile.fileExists() && !OCFile.ROOT_PATH.equals(ocFile.getFileName())) {\n \n             OCFile targetParent = getFileByPath(targetParentPath);\n             if (targetParent == null) {\n                 throw new IllegalStateException(\"Parent folder of the target path does not exist!!\");\n             }\n \n             /// 1. get all the descendants of the moved element in a single QUERY\n-            Cursor c = null;\n+            Cursor cursor = null;\n             if (getContentProviderClient() != null) {\n                 try {\n-                    c = getContentProviderClient().query(\n-                            ProviderTableMeta.CONTENT_URI,\n-                            null,\n-                            ProviderTableMeta.FILE_ACCOUNT_OWNER + AND + ProviderTableMeta.FILE_PATH + \" LIKE ? \",\n-                            new String[]{account.name, file.getRemotePath() + \"%\"},\n-                            ProviderTableMeta.FILE_PATH + \" ASC \"\n+                    cursor = getContentProviderClient().query(\n+                        ProviderTableMeta.CONTENT_URI,\n+                        null,\n+                        ProviderTableMeta.FILE_ACCOUNT_OWNER + AND + ProviderTableMeta.FILE_PATH + \" LIKE ? \",\n+                        new String[]{account.name, ocFile.getRemotePath() + \"%\"},\n+                        ProviderTableMeta.FILE_PATH + \" ASC \"\n                     );\n                 } catch (RemoteException e) {\n                     Log_OC.e(TAG, e.getMessage(), e);\n                 }\n \n             } else {\n-                c = getContentResolver().query(\n-                        ProviderTableMeta.CONTENT_URI,\n-                        null,\n-                        ProviderTableMeta.FILE_ACCOUNT_OWNER + AND + ProviderTableMeta.FILE_PATH + \" LIKE ? \",\n-                        new String[]{account.name, file.getRemotePath() + \"%\"},\n-                        ProviderTableMeta.FILE_PATH + \" ASC \"\n+                cursor = getContentResolver().query(\n+                    ProviderTableMeta.CONTENT_URI,\n+                    null,\n+                    ProviderTableMeta.FILE_ACCOUNT_OWNER + AND + ProviderTableMeta.FILE_PATH + \" LIKE ? \",\n+                    new String[]{account.name, ocFile.getRemotePath() + \"%\"},\n+                    ProviderTableMeta.FILE_PATH + \" ASC \"\n                 );\n             }\n \n             /// 2. prepare a batch of update operations to change all the descendants\n-            ArrayList<ContentProviderOperation> operations = new ArrayList<>(c.getCount());\n+            ArrayList<ContentProviderOperation> operations = new ArrayList<>(cursor.getCount());\n             String defaultSavePath = FileStorageUtils.getSavePath(account.name);\n             List<String> originalPathsToTriggerMediaScan = new ArrayList<>();\n             List<String> newPathsToTriggerMediaScan = new ArrayList<>();\n-            if (c.moveToFirst()) {\n-                int lengthOfOldPath = file.getRemotePath().length();\n+\n+            if (cursor.moveToFirst()) {\n+                int lengthOfOldPath = ocFile.getRemotePath().length();\n                 int lengthOfOldStoragePath = defaultSavePath.length() + lengthOfOldPath;\n-                String[] fileId = new String[1];\n                 do {\n-                    ContentValues cv = new ContentValues(); // keep construction in the loop\n-                    OCFile child = createFileInstance(c);\n-                    cv.put(\n-                            ProviderTableMeta.FILE_PATH,\n-                            targetPath + child.getRemotePath().substring(lengthOfOldPath)\n+                    ContentValues contentValues = new ContentValues(); // keep construction in the loop\n+                    OCFile childFile = createFileInstance(cursor);\n+                    contentValues.put(\n+                        ProviderTableMeta.FILE_PATH,\n+                        targetPath + childFile.getRemotePath().substring(lengthOfOldPath)\n                     );\n-                    if (child.getStoragePath() != null && child.getStoragePath().startsWith(defaultSavePath)) {\n+\n+                    if (childFile.getStoragePath() != null && childFile.getStoragePath().startsWith(defaultSavePath)) {\n                         // update link to downloaded content - but local move is not done here!\n                         String targetLocalPath = defaultSavePath + targetPath +\n-                                child.getStoragePath().substring(lengthOfOldStoragePath);\n+                            childFile.getStoragePath().substring(lengthOfOldStoragePath);\n \n-                        cv.put(ProviderTableMeta.FILE_STORAGE_PATH, targetLocalPath);\n+                        contentValues.put(ProviderTableMeta.FILE_STORAGE_PATH, targetLocalPath);\n \n-                        if (MimeTypeUtil.isMedia(child.getMimeType())) {\n-                            originalPathsToTriggerMediaScan.add(child.getStoragePath());\n+                        if (MimeTypeUtil.isMedia(childFile.getMimeType())) {\n+                            originalPathsToTriggerMediaScan.add(childFile.getStoragePath());\n                             newPathsToTriggerMediaScan.add(targetLocalPath);\n                         }\n \n                     }\n-                    if (child.getRemotePath().equals(file.getRemotePath())) {\n-                        cv.put(ProviderTableMeta.FILE_PARENT, targetParent.getFileId());\n+\n+                    if (childFile.getRemotePath().equals(ocFile.getRemotePath())) {\n+                        contentValues.put(ProviderTableMeta.FILE_PARENT, targetParent.getFileId());\n                     }\n-                    fileId[0] = String.valueOf(child.getFileId());\n+\n                     operations.add(\n-                            ContentProviderOperation.newUpdate(ProviderTableMeta.CONTENT_URI).\n-                                    withValues(cv).\n-                                    withSelection(ProviderTableMeta._ID + \"=?\", fileId)\n-                                    .build());\n+                        ContentProviderOperation.newUpdate(ProviderTableMeta.CONTENT_URI)\n+                            .withValues(contentValues)\n+                            .withSelection(ProviderTableMeta._ID + \" = ?\", new String[]{String.valueOf(childFile.getFileId())})", "originalCommit": "93fb7d610f6c667ae4b93b003ef3100d21600b01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTcxNjc0NA==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r371716744", "bodyText": "Issue found: Avoid declaring a variable if it is unreferenced before a possible exit point.", "author": "nextcloud-android-bot", "createdAt": "2020-01-28T10:21:28Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -841,238 +860,223 @@ public void migrateStoredFiles(String srcPath, String dstPath)\n     }\n \n     private List<OCFile> getFolderContent(long parentId, boolean onlyOnDevice) {\n+        List<OCFile> folderContent = new ArrayList<>();\n \n-        List<OCFile> ret = new ArrayList<>();\n-\n-        Uri req_uri = Uri.withAppendedPath(ProviderTableMeta.CONTENT_URI_DIR, String.valueOf(parentId));\n-        Cursor c;\n+        Uri requestURI = Uri.withAppendedPath(ProviderTableMeta.CONTENT_URI_DIR, String.valueOf(parentId));\n+        Cursor cursor;\n \n         if (getContentProviderClient() != null) {\n             try {\n-                c = getContentProviderClient().query(\n-                        req_uri,\n-                        null,\n-                        ProviderTableMeta.FILE_PARENT + \"=?\",\n-                        new String[]{String.valueOf(parentId)},\n-                        null\n+                cursor = getContentProviderClient().query(\n+                    requestURI,\n+                    null,\n+                    ProviderTableMeta.FILE_PARENT + \"=?\",\n+                    new String[]{String.valueOf(parentId)},\n+                    null\n                 );\n             } catch (RemoteException e) {\n                 Log_OC.e(TAG, e.getMessage(), e);\n-                return ret;\n+                return folderContent;\n             }\n         } else {\n-            c = getContentResolver().query(\n-                    req_uri,\n-                    null,\n-                    ProviderTableMeta.FILE_PARENT + \"=?\",\n-                    new String[]{String.valueOf(parentId)},\n-                    null\n+            cursor = getContentResolver().query(\n+                requestURI,\n+                null,\n+                ProviderTableMeta.FILE_PARENT + \"=?\",\n+                new String[]{String.valueOf(parentId)},\n+                null\n             );\n         }\n \n-        if (c != null) {\n-            if (c.moveToFirst()) {\n+        if (cursor != null) {\n+            if (cursor.moveToFirst()) {\n                 do {\n-                    OCFile child = createFileInstance(c);\n+                    OCFile child = createFileInstance(cursor);\n                     if (!onlyOnDevice || child.existsOnDevice()) {\n-                        ret.add(child);\n+                        folderContent.add(child);\n                     }\n-                } while (c.moveToNext());\n+                } while (cursor.moveToNext());\n             }\n-\n-            c.close();\n+            cursor.close();\n         }\n \n-        return ret;\n+        return folderContent;\n     }\n \n \n     private OCFile createRootDir() {\n-        OCFile file = new OCFile(OCFile.ROOT_PATH);\n-        file.setMimeType(MimeType.DIRECTORY);\n-        file.setParentId(FileDataStorageManager.ROOT_PARENT_ID);\n-        saveFile(file);\n-        return file;\n+        OCFile ocFile = new OCFile(OCFile.ROOT_PATH);\n+        ocFile.setMimeType(MimeType.DIRECTORY);\n+        ocFile.setParentId(FileDataStorageManager.ROOT_PARENT_ID);\n+        saveFile(ocFile);\n+\n+        return ocFile;\n     }\n \n-    private boolean fileExists(String cmp_key, String value) {\n-        Cursor c;\n-        if (getContentResolver() != null) {\n-            c = getContentResolver()\n-                    .query(ProviderTableMeta.CONTENT_URI,\n-                            null,\n-                            cmp_key + AND\n-                                    + ProviderTableMeta.FILE_ACCOUNT_OWNER\n-                                    + \"=?\",\n-                            new String[]{value, account.name}, null);\n+    // TODO write test\n+    private boolean fileExists(String key, String value) {\n+        Cursor cursor = getFileCursorForValue(key, value);\n+        boolean isExists = false;\n+\n+        if (cursor == null) {\n+            Log_OC.e(TAG, \"Couldn't determine file existance, assuming non existance\");\n         } else {\n-            try {\n-                c = getContentProviderClient().query(\n-                        ProviderTableMeta.CONTENT_URI,\n-                        null,\n-                        cmp_key + AND\n-                                + ProviderTableMeta.FILE_ACCOUNT_OWNER + \"=?\",\n-                        new String[]{value, account.name}, null);\n-            } catch (RemoteException e) {\n-                Log_OC.e(TAG, \"Couldn't determine file existance, assuming non existance: \" + e.getMessage(), e);\n-                return false;\n-            }\n+            isExists = cursor.moveToFirst();\n+            cursor.close();\n         }\n-        boolean retval = c.moveToFirst();\n-        c.close();\n-        return retval;\n+\n+        return isExists;\n     }\n \n     private Cursor getFileCursorForValue(String key, String value) {\n-        Cursor c;\n+        Cursor cursor;\n         if (getContentResolver() != null) {\n-            c = getContentResolver()\n-                    .query(ProviderTableMeta.CONTENT_URI,\n-                            null,\n-                            key + AND\n-                                    + ProviderTableMeta.FILE_ACCOUNT_OWNER\n-                                    + \"=?\",\n-                            new String[]{value, account.name}, null);\n+            cursor = getContentResolver()\n+                .query(ProviderTableMeta.CONTENT_URI,\n+                       null,\n+                       key + AND\n+                           + ProviderTableMeta.FILE_ACCOUNT_OWNER\n+                           + \"=?\",\n+                       new String[]{value, account.name}, null);\n         } else {\n             try {\n-                c = getContentProviderClient().query(\n-                        ProviderTableMeta.CONTENT_URI,\n-                        null,\n-                        key + AND + ProviderTableMeta.FILE_ACCOUNT_OWNER\n-                                + \"=?\", new String[]{value, account.name},\n-                        null);\n+                cursor = getContentProviderClient().query(\n+                    ProviderTableMeta.CONTENT_URI,\n+                    null,\n+                    key + AND + ProviderTableMeta.FILE_ACCOUNT_OWNER\n+                        + \"=?\", new String[]{value, account.name},\n+                    null);\n             } catch (RemoteException e) {\n                 Log_OC.e(TAG, \"Could not get file details: \" + e.getMessage(), e);\n-                c = null;\n+                cursor = null;\n             }\n         }\n-        return c;\n+        return cursor;\n     }\n \n     @Nullable\n-    private OCFile createFileInstanceFromVirtual(Cursor c) {\n-        OCFile file = null;\n-        if (c != null) {\n-            long fileId = c.getLong(c.getColumnIndex(ProviderTableMeta.VIRTUAL_OCFILE_ID));\n-            file = getFileById(fileId);\n-        }\n+    private OCFile createFileInstanceFromVirtual(Cursor cursor) {\n+        long fileId = cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.VIRTUAL_OCFILE_ID));\n \n-        return file;\n+        return getFileById(fileId);\n     }\n \n-    private OCFile createFileInstance(Cursor c) {\n-        OCFile file = null;\n-        if (c != null) {\n-            file = new OCFile(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_PATH)));\n-            file.setFileId(c.getLong(c.getColumnIndex(ProviderTableMeta._ID)));\n-            file.setParentId(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_PARENT)));\n-            file.setEncryptedFileName(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_ENCRYPTED_NAME)));\n-            file.setMimeType(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_CONTENT_TYPE)));\n-            file.setStoragePath(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_STORAGE_PATH)));\n-            if (file.getStoragePath() == null) {\n+    private OCFile createFileInstance(Cursor cursor) {\n+        OCFile ocFile = null;\n+        if (cursor != null) {\n+            ocFile = new OCFile(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_PATH)));\n+            ocFile.setFileId(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta._ID)));\n+            ocFile.setParentId(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_PARENT)));\n+            ocFile.setEncryptedFileName(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_ENCRYPTED_NAME)));\n+            ocFile.setMimeType(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_CONTENT_TYPE)));\n+            ocFile.setStoragePath(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_STORAGE_PATH)));\n+            if (ocFile.getStoragePath() == null) {\n                 // try to find existing file and bind it with current account;\n                 // with the current update of SynchronizeFolderOperation, this won't be\n                 // necessary anymore after a full synchronization of the account\n-                File f = new File(FileStorageUtils.getDefaultSavePathFor(account.name, file));\n-                if (f.exists()) {\n-                    file.setStoragePath(f.getAbsolutePath());\n-                    file.setLastSyncDateForData(f.lastModified());\n+                File file = new File(FileStorageUtils.getDefaultSavePathFor(account.name, ocFile));\n+                if (file.exists()) {\n+                    ocFile.setStoragePath(file.getAbsolutePath());\n+                    ocFile.setLastSyncDateForData(file.lastModified());\n                 }\n             }\n-            file.setFileLength(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_CONTENT_LENGTH)));\n-            file.setCreationTimestamp(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_CREATION)));\n-            file.setModificationTimestamp(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_MODIFIED)));\n-            file.setModificationTimestampAtLastSyncForData(c.getLong(\n-                    c.getColumnIndex(ProviderTableMeta.FILE_MODIFIED_AT_LAST_SYNC_FOR_DATA)));\n-            file.setLastSyncDateForProperties(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_LAST_SYNC_DATE)));\n-            file.setLastSyncDateForData(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_LAST_SYNC_DATE_FOR_DATA)));\n-            file.setEtag(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_ETAG)));\n-            file.setEtagOnServer(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_ETAG_ON_SERVER)));\n-            file.setSharedViaLink(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_SHARED_VIA_LINK)) == 1);\n-            file.setSharedWithSharee(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_SHARED_WITH_SHAREE)) == 1);\n-            file.setPublicLink(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_PUBLIC_LINK)));\n-            file.setPermissions(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_PERMISSIONS)));\n-            file.setRemoteId(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_REMOTE_ID)));\n-            file.setUpdateThumbnailNeeded(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_UPDATE_THUMBNAIL)) == 1);\n-            file.setDownloading(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_IS_DOWNLOADING)) == 1);\n-            file.setEtagInConflict(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_ETAG_IN_CONFLICT)));\n-            file.setFavorite(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_FAVORITE)) == 1);\n-            file.setEncrypted(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_IS_ENCRYPTED)) == 1);\n-            if (file.isEncrypted()) {\n-                file.setFileName(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_NAME)));\n-            }\n-            file.setMountType(WebdavEntry.MountType.values()[c.getInt(\n-                    c.getColumnIndex(ProviderTableMeta.FILE_MOUNT_TYPE))]);\n-            file.setPreviewAvailable(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_HAS_PREVIEW)) == 1);\n-            file.setUnreadCommentsCount(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_UNREAD_COMMENTS_COUNT)));\n-            file.setOwnerId(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_OWNER_ID)));\n-            file.setOwnerDisplayName(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_OWNER_DISPLAY_NAME)));\n-            file.setNote(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_NOTE)));\n-            file.setRichWorkspace(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_RICH_WORKSPACE)));\n-\n-            String sharees = c.getString(c.getColumnIndex(ProviderTableMeta.FILE_SHAREES));\n+            ocFile.setFileLength(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_CONTENT_LENGTH)));\n+            ocFile.setCreationTimestamp(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_CREATION)));\n+            ocFile.setModificationTimestamp(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_MODIFIED)));\n+            ocFile.setModificationTimestampAtLastSyncForData(cursor.getLong(\n+                cursor.getColumnIndex(ProviderTableMeta.FILE_MODIFIED_AT_LAST_SYNC_FOR_DATA)));\n+            ocFile.setLastSyncDateForProperties(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_LAST_SYNC_DATE)));\n+            ocFile.setLastSyncDateForData(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_LAST_SYNC_DATE_FOR_DATA)));\n+            ocFile.setEtag(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_ETAG)));\n+            ocFile.setEtagOnServer(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_ETAG_ON_SERVER)));\n+            ocFile.setSharedViaLink(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_SHARED_VIA_LINK)) == 1);\n+            ocFile.setSharedWithSharee(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_SHARED_WITH_SHAREE)) == 1);\n+            ocFile.setPublicLink(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_PUBLIC_LINK)));\n+            ocFile.setPermissions(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_PERMISSIONS)));\n+            ocFile.setRemoteId(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_REMOTE_ID)));\n+            ocFile.setUpdateThumbnailNeeded(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_UPDATE_THUMBNAIL)) == 1);\n+            ocFile.setDownloading(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_IS_DOWNLOADING)) == 1);\n+            ocFile.setEtagInConflict(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_ETAG_IN_CONFLICT)));\n+            ocFile.setFavorite(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_FAVORITE)) == 1);\n+            ocFile.setEncrypted(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_IS_ENCRYPTED)) == 1);\n+            if (ocFile.isEncrypted()) {\n+                ocFile.setFileName(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_NAME)));\n+            }\n+            ocFile.setMountType(WebdavEntry.MountType.values()[cursor.getInt(\n+                cursor.getColumnIndex(ProviderTableMeta.FILE_MOUNT_TYPE))]);\n+            ocFile.setPreviewAvailable(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_HAS_PREVIEW)) == 1);\n+            ocFile.setUnreadCommentsCount(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_UNREAD_COMMENTS_COUNT)));\n+            ocFile.setOwnerId(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_OWNER_ID)));\n+            ocFile.setOwnerDisplayName(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_OWNER_DISPLAY_NAME)));\n+            ocFile.setNote(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_NOTE)));\n+            ocFile.setRichWorkspace(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_RICH_WORKSPACE)));\n+\n+            String sharees = cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_SHAREES));\n \n             if (sharees == null || NULL_STRING.equals(sharees) || sharees.isEmpty()) {\n-                file.setSharees(new ArrayList<>());\n+                ocFile.setSharees(new ArrayList<>());\n             } else {\n                 try {\n                     ShareeUser[] shareesArray = new Gson().fromJson(sharees, ShareeUser[].class);\n \n-                    file.setSharees(new ArrayList<>(Arrays.asList(shareesArray)));\n+                    ocFile.setSharees(new ArrayList<>(Arrays.asList(shareesArray)));\n                 } catch (JsonSyntaxException e) {\n                     // ignore saved value due to api change\n-                    file.setSharees(new ArrayList<>());\n+                    ocFile.setSharees(new ArrayList<>());\n                 }\n             }\n         }\n \n-        return file;\n+        return ocFile;\n     }\n \n-    // Methods for Shares\n     public boolean saveShare(OCShare share) {\n         boolean overridden = false;\n-        ContentValues cv = new ContentValues();\n-        cv.put(ProviderTableMeta.OCSHARES_FILE_SOURCE, share.getFileSource());\n-        cv.put(ProviderTableMeta.OCSHARES_ITEM_SOURCE, share.getItemSource());\n-        cv.put(ProviderTableMeta.OCSHARES_SHARE_TYPE, share.getShareType().getValue());\n-        cv.put(ProviderTableMeta.OCSHARES_SHARE_WITH, share.getShareWith());\n-        cv.put(ProviderTableMeta.OCSHARES_PATH, share.getPath());\n-        cv.put(ProviderTableMeta.OCSHARES_PERMISSIONS, share.getPermissions());\n-        cv.put(ProviderTableMeta.OCSHARES_SHARED_DATE, share.getSharedDate());\n-        cv.put(ProviderTableMeta.OCSHARES_EXPIRATION_DATE, share.getExpirationDate());\n-        cv.put(ProviderTableMeta.OCSHARES_TOKEN, share.getToken());\n-        cv.put(ProviderTableMeta.OCSHARES_SHARE_WITH_DISPLAY_NAME, share.getSharedWithDisplayName());\n-        cv.put(ProviderTableMeta.OCSHARES_IS_DIRECTORY, share.isFolder() ? 1 : 0);\n-        cv.put(ProviderTableMeta.OCSHARES_USER_ID, share.getUserId());\n-        cv.put(ProviderTableMeta.OCSHARES_ID_REMOTE_SHARED, share.getRemoteId());\n-        cv.put(ProviderTableMeta.OCSHARES_ACCOUNT_OWNER, account.name);\n-        cv.put(ProviderTableMeta.OCSHARES_IS_PASSWORD_PROTECTED, share.isPasswordProtected() ? 1 : 0);\n-        cv.put(ProviderTableMeta.OCSHARES_NOTE, share.getNote());\n-        cv.put(ProviderTableMeta.OCSHARES_HIDE_DOWNLOAD, share.isHideFileDownload());\n+\n+        Uri contentUriShare = ProviderTableMeta.CONTENT_URI_SHARE;", "originalCommit": "93fb7d610f6c667ae4b93b003ef3100d21600b01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTcxNjc1OA==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r371716758", "bodyText": "Issue found: Assigning an Object to null is a code smell.  Consider refactoring.", "author": "nextcloud-android-bot", "createdAt": "2020-01-28T10:21:29Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -87,61 +88,70 @@\n     private ContentProviderClient contentProviderClient;\n     @Setter private Account account;\n \n-    public FileDataStorageManager(Account account, ContentResolver cr) {\n-        contentProviderClient = null;\n-        contentResolver = cr;\n+    public FileDataStorageManager(Account account, ContentResolver contentResolver) {\n+        this.contentProviderClient = null;\n+        this.contentResolver = contentResolver;\n         this.account = account;\n     }\n \n-    public FileDataStorageManager(Account account, ContentProviderClient cp) {\n-        contentProviderClient = cp;\n-        contentResolver = null;\n+    public FileDataStorageManager(Account account, ContentProviderClient contentProviderClient) {\n+        this.contentProviderClient = contentProviderClient;\n+        this.contentResolver = null;", "originalCommit": "93fb7d610f6c667ae4b93b003ef3100d21600b01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "92c6f4f074b23e1587f9ae2b5f1fd1ea461332da", "url": "https://github.com/nextcloud/android/commit/92c6f4f074b23e1587f9ae2b5f1fd1ea461332da", "message": "add more test cases\n\nSigned-off-by: tobiasKaminsky <tobias@kaminsky.me>", "committedDate": "2020-05-19T08:57:34Z", "type": "forcePushed"}, {"oid": "1fe816441790ce997087ab0e3c708cee33d5873d", "url": "https://github.com/nextcloud/android/commit/1fe816441790ce997087ab0e3c708cee33d5873d", "message": "Split off of #5150\n\nSigned-off-by: tobiasKaminsky <tobias@kaminsky.me>", "committedDate": "2020-05-27T15:07:17Z", "type": "forcePushed"}, {"oid": "579d98c4b7834b157b6caa750741fb56cb83b105", "url": "https://github.com/nextcloud/android/commit/579d98c4b7834b157b6caa750741fb56cb83b105", "message": "Split off of #5150\n\nSigned-off-by: tobiasKaminsky <tobias@kaminsky.me>", "committedDate": "2020-06-05T10:20:22Z", "type": "forcePushed"}, {"oid": "c7998aa701988c1194de30d427efad80f15ca0f2", "url": "https://github.com/nextcloud/android/commit/c7998aa701988c1194de30d427efad80f15ca0f2", "message": "Split off of #5150\n\nSigned-off-by: tobiasKaminsky <tobias@kaminsky.me>", "committedDate": "2020-06-05T10:25:07Z", "type": "forcePushed"}, {"oid": "008f1af8b0457f6be44f41dbf03989973b181643", "url": "https://github.com/nextcloud/android/commit/008f1af8b0457f6be44f41dbf03989973b181643", "message": "Split off of #5150\n\nSigned-off-by: tobiasKaminsky <tobias@kaminsky.me>", "committedDate": "2020-06-10T11:15:02Z", "type": "forcePushed"}, {"oid": "e9f1c79da2a775652dd76807a9231dc9780a4809", "url": "https://github.com/nextcloud/android/commit/e9f1c79da2a775652dd76807a9231dc9780a4809", "message": "Split off of #5150\n\nSigned-off-by: tobiasKaminsky <tobias@kaminsky.me>", "committedDate": "2020-06-16T05:47:00Z", "type": "forcePushed"}, {"oid": "37bf0dde69ef2a34154b87b42d1b8c678cfb5da2", "url": "https://github.com/nextcloud/android/commit/37bf0dde69ef2a34154b87b42d1b8c678cfb5da2", "message": "Split off of #5150\n\nSigned-off-by: tobiasKaminsky <tobias@kaminsky.me>", "committedDate": "2020-06-16T06:09:42Z", "type": "commit"}, {"oid": "37bf0dde69ef2a34154b87b42d1b8c678cfb5da2", "url": "https://github.com/nextcloud/android/commit/37bf0dde69ef2a34154b87b42d1b8c678cfb5da2", "message": "Split off of #5150\n\nSigned-off-by: tobiasKaminsky <tobias@kaminsky.me>", "committedDate": "2020-06-16T06:09:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwODA1NA==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r440608054", "bodyText": "Issue found: Avoid unused local variables such as 'contentUriShare'.", "author": "nextcloud-android-bot", "createdAt": "2020-06-16T06:13:10Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -854,238 +874,223 @@ public void migrateStoredFiles(String srcPath, String dstPath)\n     }\n \n     private List<OCFile> getFolderContent(long parentId, boolean onlyOnDevice) {\n+        List<OCFile> folderContent = new ArrayList<>();\n \n-        List<OCFile> ret = new ArrayList<>();\n-\n-        Uri req_uri = Uri.withAppendedPath(ProviderTableMeta.CONTENT_URI_DIR, String.valueOf(parentId));\n-        Cursor c;\n+        Uri requestURI = Uri.withAppendedPath(ProviderTableMeta.CONTENT_URI_DIR, String.valueOf(parentId));\n+        Cursor cursor;\n \n         if (getContentProviderClient() != null) {\n             try {\n-                c = getContentProviderClient().query(\n-                        req_uri,\n-                        null,\n-                        ProviderTableMeta.FILE_PARENT + \"=?\",\n-                        new String[]{String.valueOf(parentId)},\n-                        null\n+                cursor = getContentProviderClient().query(\n+                    requestURI,\n+                    null,\n+                    ProviderTableMeta.FILE_PARENT + \"=?\",\n+                    new String[]{String.valueOf(parentId)},\n+                    null\n                 );\n             } catch (RemoteException e) {\n                 Log_OC.e(TAG, e.getMessage(), e);\n-                return ret;\n+                return folderContent;\n             }\n         } else {\n-            c = getContentResolver().query(\n-                    req_uri,\n-                    null,\n-                    ProviderTableMeta.FILE_PARENT + \"=?\",\n-                    new String[]{String.valueOf(parentId)},\n-                    null\n+            cursor = getContentResolver().query(\n+                requestURI,\n+                null,\n+                ProviderTableMeta.FILE_PARENT + \"=?\",\n+                new String[]{String.valueOf(parentId)},\n+                null\n             );\n         }\n \n-        if (c != null) {\n-            if (c.moveToFirst()) {\n+        if (cursor != null) {\n+            if (cursor.moveToFirst()) {\n                 do {\n-                    OCFile child = createFileInstance(c);\n+                    OCFile child = createFileInstance(cursor);\n                     if (!onlyOnDevice || child.existsOnDevice()) {\n-                        ret.add(child);\n+                        folderContent.add(child);\n                     }\n-                } while (c.moveToNext());\n+                } while (cursor.moveToNext());\n             }\n-\n-            c.close();\n+            cursor.close();\n         }\n \n-        return ret;\n+        return folderContent;\n     }\n \n \n     private OCFile createRootDir() {\n-        OCFile file = new OCFile(OCFile.ROOT_PATH);\n-        file.setMimeType(MimeType.DIRECTORY);\n-        file.setParentId(FileDataStorageManager.ROOT_PARENT_ID);\n-        saveFile(file);\n-        return file;\n+        OCFile ocFile = new OCFile(OCFile.ROOT_PATH);\n+        ocFile.setMimeType(MimeType.DIRECTORY);\n+        ocFile.setParentId(FileDataStorageManager.ROOT_PARENT_ID);\n+        saveFile(ocFile);\n+\n+        return ocFile;\n     }\n \n-    private boolean fileExists(String cmp_key, String value) {\n-        Cursor c;\n-        if (getContentResolver() != null) {\n-            c = getContentResolver()\n-                    .query(ProviderTableMeta.CONTENT_URI,\n-                            null,\n-                            cmp_key + AND\n-                                    + ProviderTableMeta.FILE_ACCOUNT_OWNER\n-                                    + \"=?\",\n-                            new String[]{value, account.name}, null);\n+    // TODO write test\n+    private boolean fileExists(String key, String value) {\n+        Cursor cursor = getFileCursorForValue(key, value);\n+        boolean isExists = false;\n+\n+        if (cursor == null) {\n+            Log_OC.e(TAG, \"Couldn't determine file existance, assuming non existance\");\n         } else {\n-            try {\n-                c = getContentProviderClient().query(\n-                        ProviderTableMeta.CONTENT_URI,\n-                        null,\n-                        cmp_key + AND\n-                                + ProviderTableMeta.FILE_ACCOUNT_OWNER + \"=?\",\n-                        new String[]{value, account.name}, null);\n-            } catch (RemoteException e) {\n-                Log_OC.e(TAG, \"Couldn't determine file existance, assuming non existance: \" + e.getMessage(), e);\n-                return false;\n-            }\n+            isExists = cursor.moveToFirst();\n+            cursor.close();\n         }\n-        boolean retval = c.moveToFirst();\n-        c.close();\n-        return retval;\n+\n+        return isExists;\n     }\n \n     private Cursor getFileCursorForValue(String key, String value) {\n-        Cursor c;\n+        Cursor cursor;\n         if (getContentResolver() != null) {\n-            c = getContentResolver()\n-                    .query(ProviderTableMeta.CONTENT_URI,\n-                            null,\n-                            key + AND\n-                                    + ProviderTableMeta.FILE_ACCOUNT_OWNER\n-                                    + \"=?\",\n-                            new String[]{value, account.name}, null);\n+            cursor = getContentResolver()\n+                .query(ProviderTableMeta.CONTENT_URI,\n+                       null,\n+                       key + AND\n+                           + ProviderTableMeta.FILE_ACCOUNT_OWNER\n+                           + \"=?\",\n+                       new String[]{value, account.name}, null);\n         } else {\n             try {\n-                c = getContentProviderClient().query(\n-                        ProviderTableMeta.CONTENT_URI,\n-                        null,\n-                        key + AND + ProviderTableMeta.FILE_ACCOUNT_OWNER\n-                                + \"=?\", new String[]{value, account.name},\n-                        null);\n+                cursor = getContentProviderClient().query(\n+                    ProviderTableMeta.CONTENT_URI,\n+                    null,\n+                    key + AND + ProviderTableMeta.FILE_ACCOUNT_OWNER\n+                        + \"=?\", new String[]{value, account.name},\n+                    null);\n             } catch (RemoteException e) {\n                 Log_OC.e(TAG, \"Could not get file details: \" + e.getMessage(), e);\n-                c = null;\n+                cursor = null;\n             }\n         }\n-        return c;\n+        return cursor;\n     }\n \n     @Nullable\n-    private OCFile createFileInstanceFromVirtual(Cursor c) {\n-        OCFile file = null;\n-        if (c != null) {\n-            long fileId = c.getLong(c.getColumnIndex(ProviderTableMeta.VIRTUAL_OCFILE_ID));\n-            file = getFileById(fileId);\n-        }\n+    private OCFile createFileInstanceFromVirtual(Cursor cursor) {\n+        long fileId = cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.VIRTUAL_OCFILE_ID));\n \n-        return file;\n+        return getFileById(fileId);\n     }\n \n-    private OCFile createFileInstance(Cursor c) {\n-        OCFile file = null;\n-        if (c != null) {\n-            file = new OCFile(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_PATH)));\n-            file.setDecryptedRemotePath(getString(c, ProviderTableMeta.FILE_PATH_DECRYPTED));\n-            file.setFileId(c.getLong(c.getColumnIndex(ProviderTableMeta._ID)));\n-            file.setParentId(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_PARENT)));\n-            file.setMimeType(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_CONTENT_TYPE)));\n-            file.setStoragePath(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_STORAGE_PATH)));\n-            if (file.getStoragePath() == null) {\n+    private OCFile createFileInstance(Cursor cursor) {\n+        OCFile ocFile = null;\n+        if (cursor != null) {\n+            ocFile = new OCFile(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_PATH)));\n+            ocFile.setDecryptedRemotePath(getString(cursor, ProviderTableMeta.FILE_PATH_DECRYPTED));\n+            ocFile.setFileId(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta._ID)));\n+            ocFile.setParentId(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_PARENT)));\n+            ocFile.setMimeType(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_CONTENT_TYPE)));\n+            ocFile.setStoragePath(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_STORAGE_PATH)));\n+            if (ocFile.getStoragePath() == null) {\n                 // try to find existing file and bind it with current account;\n                 // with the current update of SynchronizeFolderOperation, this won't be\n                 // necessary anymore after a full synchronization of the account\n-                File f = new File(FileStorageUtils.getDefaultSavePathFor(account.name, file));\n-                if (f.exists()) {\n-                    file.setStoragePath(f.getAbsolutePath());\n-                    file.setLastSyncDateForData(f.lastModified());\n+                File file = new File(FileStorageUtils.getDefaultSavePathFor(account.name, ocFile));\n+                if (file.exists()) {\n+                    ocFile.setStoragePath(file.getAbsolutePath());\n+                    ocFile.setLastSyncDateForData(file.lastModified());\n                 }\n             }\n-            file.setFileLength(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_CONTENT_LENGTH)));\n-            file.setCreationTimestamp(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_CREATION)));\n-            file.setModificationTimestamp(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_MODIFIED)));\n-            file.setModificationTimestampAtLastSyncForData(c.getLong(\n-                    c.getColumnIndex(ProviderTableMeta.FILE_MODIFIED_AT_LAST_SYNC_FOR_DATA)));\n-            file.setLastSyncDateForProperties(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_LAST_SYNC_DATE)));\n-            file.setLastSyncDateForData(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_LAST_SYNC_DATE_FOR_DATA)));\n-            file.setEtag(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_ETAG)));\n-            file.setEtagOnServer(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_ETAG_ON_SERVER)));\n-            file.setSharedViaLink(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_SHARED_VIA_LINK)) == 1);\n-            file.setSharedWithSharee(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_SHARED_WITH_SHAREE)) == 1);\n-            file.setPublicLink(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_PUBLIC_LINK)));\n-            file.setPermissions(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_PERMISSIONS)));\n-            file.setRemoteId(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_REMOTE_ID)));\n-            file.setUpdateThumbnailNeeded(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_UPDATE_THUMBNAIL)) == 1);\n-            file.setDownloading(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_IS_DOWNLOADING)) == 1);\n-            file.setEtagInConflict(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_ETAG_IN_CONFLICT)));\n-            file.setFavorite(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_FAVORITE)) == 1);\n-            file.setEncrypted(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_IS_ENCRYPTED)) == 1);\n-//            if (file.isEncrypted()) {\n-//                file.setFileName(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_NAME)));\n+            ocFile.setFileLength(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_CONTENT_LENGTH)));\n+            ocFile.setCreationTimestamp(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_CREATION)));\n+            ocFile.setModificationTimestamp(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_MODIFIED)));\n+            ocFile.setModificationTimestampAtLastSyncForData(cursor.getLong(\n+                cursor.getColumnIndex(ProviderTableMeta.FILE_MODIFIED_AT_LAST_SYNC_FOR_DATA)));\n+            ocFile.setLastSyncDateForProperties(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_LAST_SYNC_DATE)));\n+            ocFile.setLastSyncDateForData(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_LAST_SYNC_DATE_FOR_DATA)));\n+            ocFile.setEtag(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_ETAG)));\n+            ocFile.setEtagOnServer(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_ETAG_ON_SERVER)));\n+            ocFile.setSharedViaLink(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_SHARED_VIA_LINK)) == 1);\n+            ocFile.setSharedWithSharee(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_SHARED_WITH_SHAREE)) == 1);\n+            ocFile.setPublicLink(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_PUBLIC_LINK)));\n+            ocFile.setPermissions(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_PERMISSIONS)));\n+            ocFile.setRemoteId(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_REMOTE_ID)));\n+            ocFile.setUpdateThumbnailNeeded(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_UPDATE_THUMBNAIL)) == 1);\n+            ocFile.setDownloading(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_IS_DOWNLOADING)) == 1);\n+            ocFile.setEtagInConflict(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_ETAG_IN_CONFLICT)));\n+            ocFile.setFavorite(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_FAVORITE)) == 1);\n+            ocFile.setEncrypted(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_IS_ENCRYPTED)) == 1);\n+//            if (ocFile.isEncrypted()) {\n+//                ocFile.setFileName(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_NAME)));\n //            }\n-            file.setMountType(WebdavEntry.MountType.values()[c.getInt(\n-                    c.getColumnIndex(ProviderTableMeta.FILE_MOUNT_TYPE))]);\n-            file.setPreviewAvailable(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_HAS_PREVIEW)) == 1);\n-            file.setUnreadCommentsCount(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_UNREAD_COMMENTS_COUNT)));\n-            file.setOwnerId(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_OWNER_ID)));\n-            file.setOwnerDisplayName(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_OWNER_DISPLAY_NAME)));\n-            file.setNote(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_NOTE)));\n-            file.setRichWorkspace(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_RICH_WORKSPACE)));\n+            ocFile.setMountType(WebdavEntry.MountType.values()[cursor.getInt(\n+                cursor.getColumnIndex(ProviderTableMeta.FILE_MOUNT_TYPE))]);\n+            ocFile.setPreviewAvailable(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_HAS_PREVIEW)) == 1);\n+            ocFile.setUnreadCommentsCount(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_UNREAD_COMMENTS_COUNT)));\n+            ocFile.setOwnerId(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_OWNER_ID)));\n+            ocFile.setOwnerDisplayName(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_OWNER_DISPLAY_NAME)));\n+            ocFile.setNote(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_NOTE)));\n+            ocFile.setRichWorkspace(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_RICH_WORKSPACE)));\n \n-            String sharees = c.getString(c.getColumnIndex(ProviderTableMeta.FILE_SHAREES));\n+            String sharees = cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_SHAREES));\n \n             if (sharees == null || NULL_STRING.equals(sharees) || sharees.isEmpty()) {\n-                file.setSharees(new ArrayList<>());\n+                ocFile.setSharees(new ArrayList<>());\n             } else {\n                 try {\n                     ShareeUser[] shareesArray = new Gson().fromJson(sharees, ShareeUser[].class);\n \n-                    file.setSharees(new ArrayList<>(Arrays.asList(shareesArray)));\n+                    ocFile.setSharees(new ArrayList<>(Arrays.asList(shareesArray)));\n                 } catch (JsonSyntaxException e) {\n                     // ignore saved value due to api change\n-                    file.setSharees(new ArrayList<>());\n+                    ocFile.setSharees(new ArrayList<>());\n                 }\n             }\n         }\n \n-        return file;\n+        return ocFile;\n     }\n \n-    // Methods for Shares\n     public boolean saveShare(OCShare share) {\n         boolean overridden = false;\n-        ContentValues cv = new ContentValues();\n-        cv.put(ProviderTableMeta.OCSHARES_FILE_SOURCE, share.getFileSource());\n-        cv.put(ProviderTableMeta.OCSHARES_ITEM_SOURCE, share.getItemSource());\n-        cv.put(ProviderTableMeta.OCSHARES_SHARE_TYPE, share.getShareType().getValue());\n-        cv.put(ProviderTableMeta.OCSHARES_SHARE_WITH, share.getShareWith());\n-        cv.put(ProviderTableMeta.OCSHARES_PATH, share.getPath());\n-        cv.put(ProviderTableMeta.OCSHARES_PERMISSIONS, share.getPermissions());\n-        cv.put(ProviderTableMeta.OCSHARES_SHARED_DATE, share.getSharedDate());\n-        cv.put(ProviderTableMeta.OCSHARES_EXPIRATION_DATE, share.getExpirationDate());\n-        cv.put(ProviderTableMeta.OCSHARES_TOKEN, share.getToken());\n-        cv.put(ProviderTableMeta.OCSHARES_SHARE_WITH_DISPLAY_NAME, share.getSharedWithDisplayName());\n-        cv.put(ProviderTableMeta.OCSHARES_IS_DIRECTORY, share.isFolder() ? 1 : 0);\n-        cv.put(ProviderTableMeta.OCSHARES_USER_ID, share.getUserId());\n-        cv.put(ProviderTableMeta.OCSHARES_ID_REMOTE_SHARED, share.getRemoteId());\n-        cv.put(ProviderTableMeta.OCSHARES_ACCOUNT_OWNER, account.name);\n-        cv.put(ProviderTableMeta.OCSHARES_IS_PASSWORD_PROTECTED, share.isPasswordProtected() ? 1 : 0);\n-        cv.put(ProviderTableMeta.OCSHARES_NOTE, share.getNote());\n-        cv.put(ProviderTableMeta.OCSHARES_HIDE_DOWNLOAD, share.isHideFileDownload());\n+\n+        Uri contentUriShare = ProviderTableMeta.CONTENT_URI_SHARE;", "originalCommit": "37bf0dde69ef2a34154b87b42d1b8c678cfb5da2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwODA2NA==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r440608064", "bodyText": "Issue found: Assigning an Object to null is a code smell.  Consider refactoring.", "author": "nextcloud-android-bot", "createdAt": "2020-06-16T06:13:11Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -430,19 +445,18 @@ public void saveFolder(OCFile folder, Collection<OCFile> updatedFiles, Collectio\n         // update new id in file objects for insertions\n         if (results != null) {\n             long newId;\n-            Iterator<OCFile> filesIt = updatedFiles.iterator();\n-            OCFile file;\n+            Iterator<OCFile> fileIterator = updatedFiles.iterator();\n+            OCFile ocFile;\n             for (ContentProviderResult result : results) {\n-                if (filesIt.hasNext()) {\n-                    file = filesIt.next();\n+                if (fileIterator.hasNext()) {\n+                    ocFile = fileIterator.next();\n                 } else {\n-                    file = null;\n+                    ocFile = null;", "originalCommit": "37bf0dde69ef2a34154b87b42d1b8c678cfb5da2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwODA3MA==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r440608070", "bodyText": "Issue found: Avoid really long methods.", "author": "nextcloud-android-bot", "createdAt": "2020-06-16T06:13:12Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -652,91 +669,92 @@ private boolean removeLocalFolder(File localFolder) {\n             }\n         }\n         success &= localFolder.delete();\n+\n         return success;\n     }\n \n     /**\n      * Updates database and file system for a file or folder that was moved to a different location.\n      *\n-     * TODO explore better (faster) implementations\n-     * TODO throw exceptions up !\n+     * TODO explore better (faster) implementations TODO throw exceptions up !\n      */\n-    public void moveLocalFile(OCFile file, String targetPath, String targetParentPath) {\n-\n-        if (file != null && file.fileExists() && !OCFile.ROOT_PATH.equals(file.getFileName())) {\n+    public void moveLocalFile(OCFile ocFile, String targetPath, String targetParentPath) {", "originalCommit": "37bf0dde69ef2a34154b87b42d1b8c678cfb5da2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwODA3NA==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r440608074", "bodyText": "Issue found: Avoid really long methods.", "author": "nextcloud-android-bot", "createdAt": "2020-06-16T06:13:13Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -337,79 +350,81 @@ public void saveNewFile(OCFile newFile) {\n     /**\n      * Inserts or updates the list of files contained in a given folder.\n      *\n-     * CALLER IS RESPONSIBLE FOR GRANTING RIGHT UPDATE OF INFORMATION, NOT THIS METHOD.\n-     * HERE ONLY DATA CONSISTENCY SHOULD BE GRANTED\n+     * CALLER IS RESPONSIBLE FOR GRANTING RIGHT UPDATE OF INFORMATION, NOT THIS METHOD. HERE ONLY DATA CONSISTENCY\n+     * SHOULD BE GRANTED\n      *\n      * @param folder\n      * @param updatedFiles\n      * @param filesToRemove\n      */\n-    public void saveFolder(OCFile folder, Collection<OCFile> updatedFiles, Collection<OCFile> filesToRemove) {\n+    public void saveFolder(OCFile folder, List<OCFile> updatedFiles, Collection<OCFile> filesToRemove) {", "originalCommit": "37bf0dde69ef2a34154b87b42d1b8c678cfb5da2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwODA3OA==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r440608078", "bodyText": "Issue found: Avoid instantiating new objects inside loops", "author": "nextcloud-android-bot", "createdAt": "2020-06-16T06:13:14Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -1618,101 +1593,99 @@ public void saveSharesInFolder(ArrayList<OCShare> shares, OCFile folder) {\n                 Log_OC.e(TAG, EXCEPTION_MSG + e.getMessage(), e);\n             }\n         }\n-\n     }\n \n     /**\n      * Prepare operations to insert or update files to save in the given folder\n-     * @param shares        List of shares to insert\n-     * @param operations    List of operations\n+     *\n+     * @param shares     List of shares to insert\n+     * @param operations List of operations\n      * @return\n      */\n     private ArrayList<ContentProviderOperation> prepareInsertShares(\n-            List<OCShare> shares, ArrayList<ContentProviderOperation> operations) {\n+        List<OCShare> shares, ArrayList<ContentProviderOperation> operations) {\n \n-        if (shares != null) {\n-            ContentValues cv;\n-            // prepare operations to insert or update files to save in the given folder\n-            for (OCShare share : shares) {\n-                cv = new ContentValues();\n-                cv.put(ProviderTableMeta.OCSHARES_FILE_SOURCE, share.getFileSource());\n-                cv.put(ProviderTableMeta.OCSHARES_ITEM_SOURCE, share.getItemSource());\n-                cv.put(ProviderTableMeta.OCSHARES_SHARE_TYPE, share.getShareType().getValue());\n-                cv.put(ProviderTableMeta.OCSHARES_SHARE_WITH, share.getShareWith());\n-                cv.put(ProviderTableMeta.OCSHARES_PATH, share.getPath());\n-                cv.put(ProviderTableMeta.OCSHARES_PERMISSIONS, share.getPermissions());\n-                cv.put(ProviderTableMeta.OCSHARES_SHARED_DATE, share.getSharedDate());\n-                cv.put(ProviderTableMeta.OCSHARES_EXPIRATION_DATE, share.getExpirationDate());\n-                cv.put(ProviderTableMeta.OCSHARES_TOKEN, share.getToken());\n-                cv.put(ProviderTableMeta.OCSHARES_SHARE_WITH_DISPLAY_NAME, share.getSharedWithDisplayName());\n-                cv.put(ProviderTableMeta.OCSHARES_IS_DIRECTORY, share.isFolder() ? 1 : 0);\n-                cv.put(ProviderTableMeta.OCSHARES_USER_ID, share.getUserId());\n-                cv.put(ProviderTableMeta.OCSHARES_ID_REMOTE_SHARED, share.getRemoteId());\n-                cv.put(ProviderTableMeta.OCSHARES_ACCOUNT_OWNER, account.name);\n-                cv.put(ProviderTableMeta.OCSHARES_IS_PASSWORD_PROTECTED, share.isPasswordProtected() ? 1 : 0);\n-                cv.put(ProviderTableMeta.OCSHARES_NOTE, share.getNote());\n-                cv.put(ProviderTableMeta.OCSHARES_HIDE_DOWNLOAD, share.isHideFileDownload());\n-\n-                // adding a new share resource\n-                operations.add(ContentProviderOperation.newInsert(\n-                        ProviderTableMeta.CONTENT_URI_SHARE).withValues(cv).build());\n-            }\n+        ContentValues contentValues;\n+        // prepare operations to insert or update files to save in the given folder\n+        for (OCShare share : shares) {\n+            contentValues = new ContentValues();", "originalCommit": "37bf0dde69ef2a34154b87b42d1b8c678cfb5da2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwODA4Mw==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r440608083", "bodyText": "Issue found: Avoid unused private fields such as 'FAILED_TO_UPDATE_MSG'.", "author": "nextcloud-android-bot", "createdAt": "2020-06-16T06:13:15Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -73,7 +73,8 @@\n public class FileDataStorageManager {\n     private static final String TAG = FileDataStorageManager.class.getSimpleName();\n \n-    private static final String AND = \"=? AND \";\n+    private static final String AND = \" = ? AND \";\n+    private static final String FAILED_TO_UPDATE_MSG = \"Fail to update file to database \";", "originalCommit": "37bf0dde69ef2a34154b87b42d1b8c678cfb5da2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwODA5MA==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r440608090", "bodyText": "Issue found: Avoid instantiating new objects inside loops", "author": "nextcloud-android-bot", "createdAt": "2020-06-16T06:13:16Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -337,79 +350,81 @@ public void saveNewFile(OCFile newFile) {\n     /**\n      * Inserts or updates the list of files contained in a given folder.\n      *\n-     * CALLER IS RESPONSIBLE FOR GRANTING RIGHT UPDATE OF INFORMATION, NOT THIS METHOD.\n-     * HERE ONLY DATA CONSISTENCY SHOULD BE GRANTED\n+     * CALLER IS RESPONSIBLE FOR GRANTING RIGHT UPDATE OF INFORMATION, NOT THIS METHOD. HERE ONLY DATA CONSISTENCY\n+     * SHOULD BE GRANTED\n      *\n      * @param folder\n      * @param updatedFiles\n      * @param filesToRemove\n      */\n-    public void saveFolder(OCFile folder, Collection<OCFile> updatedFiles, Collection<OCFile> filesToRemove) {\n+    public void saveFolder(OCFile folder, List<OCFile> updatedFiles, Collection<OCFile> filesToRemove) {\n         Log_OC.d(TAG, \"Saving folder \" + folder.getRemotePath() + \" with \" + updatedFiles.size()\n-                + \" children and \" + filesToRemove.size() + \" files to remove\");\n+            + \" children and \" + filesToRemove.size() + \" files to remove\");\n \n         ArrayList<ContentProviderOperation> operations = new ArrayList<>(updatedFiles.size());\n \n         // prepare operations to insert or update files to save in the given folder\n-        for (OCFile file : updatedFiles) {\n-            ContentValues cv = createContentValueForFile(file, folder);\n+        for (OCFile ocFile : updatedFiles) {\n+            ContentValues contentValues = createContentValueForFile(ocFile, folder);\n \n-            if (fileExists(file.getFileId()) || fileExists(file.getRemotePath())) {\n+            if (fileExists(ocFile.getFileId()) || fileExists(ocFile.getRemotePath())) {\n                 long fileId;\n-                if (file.getFileId() != -1) {\n-                    fileId = file.getFileId();\n+                if (ocFile.getFileId() != -1) {\n+                    fileId = ocFile.getFileId();\n                 } else {\n-                    fileId = getFileByPath(file.getRemotePath()).getFileId();\n+                    fileId = getFileByPath(ocFile.getRemotePath()).getFileId();\n                 }\n                 // updating an existing file\n                 operations.add(ContentProviderOperation.newUpdate(ProviderTableMeta.CONTENT_URI)\n-                        .withValues(cv)\n-                                   .withSelection(ProviderTableMeta._ID + \"=?\", new String[]{String.valueOf(fileId)})\n-                        .build());\n+                                   .withValues(contentValues)\n+                                   .withSelection(ProviderTableMeta._ID + \" = ?\", new String[]{String.valueOf(fileId)})\n+                                   .build());\n             } else {\n                 // adding a new file\n-                operations.add(ContentProviderOperation.newInsert(ProviderTableMeta.CONTENT_URI).withValues(cv).build());\n+                operations.add(ContentProviderOperation.newInsert(ProviderTableMeta.CONTENT_URI)\n+                                   .withValues(contentValues)\n+                                   .build());\n             }\n         }\n \n         // prepare operations to remove files in the given folder\n-        String where = ProviderTableMeta.FILE_ACCOUNT_OWNER + AND + ProviderTableMeta.FILE_PATH + \"=?\";\n+        String where = ProviderTableMeta.FILE_ACCOUNT_OWNER + AND + ProviderTableMeta.FILE_PATH + \" = ?\";\n         String[] whereArgs = new String[2];\n-        for (OCFile file : filesToRemove) {\n-            if (file.getParentId() == folder.getFileId()) {\n-                whereArgs[0] = account.name;\n-                whereArgs[1] = file.getRemotePath();\n-                if (file.isFolder()) {\n+        whereArgs[0] = account.name;\n+        for (OCFile ocFile : filesToRemove) {\n+            if (ocFile.getParentId() == folder.getFileId()) {\n+                whereArgs[1] = ocFile.getRemotePath();\n+                if (ocFile.isFolder()) {\n                     operations.add(ContentProviderOperation.newDelete(\n-                            ContentUris.withAppendedId(ProviderTableMeta.CONTENT_URI_DIR, file.getFileId()))\n-                            .withSelection(where, whereArgs).build());\n+                        ContentUris.withAppendedId(ProviderTableMeta.CONTENT_URI_DIR, ocFile.getFileId()))\n+                                       .withSelection(where, whereArgs).build());\n \n-                    File localFolder = new File(FileStorageUtils.getDefaultSavePathFor(account.name, file));\n+                    File localFolder = new File(FileStorageUtils.getDefaultSavePathFor(account.name, ocFile));\n                     if (localFolder.exists()) {\n                         removeLocalFolder(localFolder);\n                     }\n                 } else {\n                     operations.add(ContentProviderOperation.newDelete(\n-                            ContentUris.withAppendedId(ProviderTableMeta.CONTENT_URI_FILE, file.getFileId()))\n-                            .withSelection(where, whereArgs).build());\n+                        ContentUris.withAppendedId(ProviderTableMeta.CONTENT_URI_FILE, ocFile.getFileId()))\n+                                       .withSelection(where, whereArgs).build());\n \n-                    if (file.isDown()) {\n-                        String path = file.getStoragePath();\n-                        if (new File(path).delete() && MimeTypeUtil.isMedia(file.getMimeType())) {\n-                            triggerMediaScan(path, file); // notify MediaScanner about removed file\n+                    if (ocFile.isDown()) {\n+                        String path = ocFile.getStoragePath();\n+                        if (new File(path).delete() && MimeTypeUtil.isMedia(ocFile.getMimeType())) {", "originalCommit": "37bf0dde69ef2a34154b87b42d1b8c678cfb5da2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwODA5Ng==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r440608096", "bodyText": "Issue found: Avoid declaring a variable if it is unreferenced before a possible exit point.", "author": "nextcloud-android-bot", "createdAt": "2020-06-16T06:13:17Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -854,238 +874,223 @@ public void migrateStoredFiles(String srcPath, String dstPath)\n     }\n \n     private List<OCFile> getFolderContent(long parentId, boolean onlyOnDevice) {\n+        List<OCFile> folderContent = new ArrayList<>();\n \n-        List<OCFile> ret = new ArrayList<>();\n-\n-        Uri req_uri = Uri.withAppendedPath(ProviderTableMeta.CONTENT_URI_DIR, String.valueOf(parentId));\n-        Cursor c;\n+        Uri requestURI = Uri.withAppendedPath(ProviderTableMeta.CONTENT_URI_DIR, String.valueOf(parentId));\n+        Cursor cursor;\n \n         if (getContentProviderClient() != null) {\n             try {\n-                c = getContentProviderClient().query(\n-                        req_uri,\n-                        null,\n-                        ProviderTableMeta.FILE_PARENT + \"=?\",\n-                        new String[]{String.valueOf(parentId)},\n-                        null\n+                cursor = getContentProviderClient().query(\n+                    requestURI,\n+                    null,\n+                    ProviderTableMeta.FILE_PARENT + \"=?\",\n+                    new String[]{String.valueOf(parentId)},\n+                    null\n                 );\n             } catch (RemoteException e) {\n                 Log_OC.e(TAG, e.getMessage(), e);\n-                return ret;\n+                return folderContent;\n             }\n         } else {\n-            c = getContentResolver().query(\n-                    req_uri,\n-                    null,\n-                    ProviderTableMeta.FILE_PARENT + \"=?\",\n-                    new String[]{String.valueOf(parentId)},\n-                    null\n+            cursor = getContentResolver().query(\n+                requestURI,\n+                null,\n+                ProviderTableMeta.FILE_PARENT + \"=?\",\n+                new String[]{String.valueOf(parentId)},\n+                null\n             );\n         }\n \n-        if (c != null) {\n-            if (c.moveToFirst()) {\n+        if (cursor != null) {\n+            if (cursor.moveToFirst()) {\n                 do {\n-                    OCFile child = createFileInstance(c);\n+                    OCFile child = createFileInstance(cursor);\n                     if (!onlyOnDevice || child.existsOnDevice()) {\n-                        ret.add(child);\n+                        folderContent.add(child);\n                     }\n-                } while (c.moveToNext());\n+                } while (cursor.moveToNext());\n             }\n-\n-            c.close();\n+            cursor.close();\n         }\n \n-        return ret;\n+        return folderContent;\n     }\n \n \n     private OCFile createRootDir() {\n-        OCFile file = new OCFile(OCFile.ROOT_PATH);\n-        file.setMimeType(MimeType.DIRECTORY);\n-        file.setParentId(FileDataStorageManager.ROOT_PARENT_ID);\n-        saveFile(file);\n-        return file;\n+        OCFile ocFile = new OCFile(OCFile.ROOT_PATH);\n+        ocFile.setMimeType(MimeType.DIRECTORY);\n+        ocFile.setParentId(FileDataStorageManager.ROOT_PARENT_ID);\n+        saveFile(ocFile);\n+\n+        return ocFile;\n     }\n \n-    private boolean fileExists(String cmp_key, String value) {\n-        Cursor c;\n-        if (getContentResolver() != null) {\n-            c = getContentResolver()\n-                    .query(ProviderTableMeta.CONTENT_URI,\n-                            null,\n-                            cmp_key + AND\n-                                    + ProviderTableMeta.FILE_ACCOUNT_OWNER\n-                                    + \"=?\",\n-                            new String[]{value, account.name}, null);\n+    // TODO write test\n+    private boolean fileExists(String key, String value) {\n+        Cursor cursor = getFileCursorForValue(key, value);\n+        boolean isExists = false;\n+\n+        if (cursor == null) {\n+            Log_OC.e(TAG, \"Couldn't determine file existance, assuming non existance\");\n         } else {\n-            try {\n-                c = getContentProviderClient().query(\n-                        ProviderTableMeta.CONTENT_URI,\n-                        null,\n-                        cmp_key + AND\n-                                + ProviderTableMeta.FILE_ACCOUNT_OWNER + \"=?\",\n-                        new String[]{value, account.name}, null);\n-            } catch (RemoteException e) {\n-                Log_OC.e(TAG, \"Couldn't determine file existance, assuming non existance: \" + e.getMessage(), e);\n-                return false;\n-            }\n+            isExists = cursor.moveToFirst();\n+            cursor.close();\n         }\n-        boolean retval = c.moveToFirst();\n-        c.close();\n-        return retval;\n+\n+        return isExists;\n     }\n \n     private Cursor getFileCursorForValue(String key, String value) {\n-        Cursor c;\n+        Cursor cursor;\n         if (getContentResolver() != null) {\n-            c = getContentResolver()\n-                    .query(ProviderTableMeta.CONTENT_URI,\n-                            null,\n-                            key + AND\n-                                    + ProviderTableMeta.FILE_ACCOUNT_OWNER\n-                                    + \"=?\",\n-                            new String[]{value, account.name}, null);\n+            cursor = getContentResolver()\n+                .query(ProviderTableMeta.CONTENT_URI,\n+                       null,\n+                       key + AND\n+                           + ProviderTableMeta.FILE_ACCOUNT_OWNER\n+                           + \"=?\",\n+                       new String[]{value, account.name}, null);\n         } else {\n             try {\n-                c = getContentProviderClient().query(\n-                        ProviderTableMeta.CONTENT_URI,\n-                        null,\n-                        key + AND + ProviderTableMeta.FILE_ACCOUNT_OWNER\n-                                + \"=?\", new String[]{value, account.name},\n-                        null);\n+                cursor = getContentProviderClient().query(\n+                    ProviderTableMeta.CONTENT_URI,\n+                    null,\n+                    key + AND + ProviderTableMeta.FILE_ACCOUNT_OWNER\n+                        + \"=?\", new String[]{value, account.name},\n+                    null);\n             } catch (RemoteException e) {\n                 Log_OC.e(TAG, \"Could not get file details: \" + e.getMessage(), e);\n-                c = null;\n+                cursor = null;\n             }\n         }\n-        return c;\n+        return cursor;\n     }\n \n     @Nullable\n-    private OCFile createFileInstanceFromVirtual(Cursor c) {\n-        OCFile file = null;\n-        if (c != null) {\n-            long fileId = c.getLong(c.getColumnIndex(ProviderTableMeta.VIRTUAL_OCFILE_ID));\n-            file = getFileById(fileId);\n-        }\n+    private OCFile createFileInstanceFromVirtual(Cursor cursor) {\n+        long fileId = cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.VIRTUAL_OCFILE_ID));\n \n-        return file;\n+        return getFileById(fileId);\n     }\n \n-    private OCFile createFileInstance(Cursor c) {\n-        OCFile file = null;\n-        if (c != null) {\n-            file = new OCFile(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_PATH)));\n-            file.setDecryptedRemotePath(getString(c, ProviderTableMeta.FILE_PATH_DECRYPTED));\n-            file.setFileId(c.getLong(c.getColumnIndex(ProviderTableMeta._ID)));\n-            file.setParentId(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_PARENT)));\n-            file.setMimeType(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_CONTENT_TYPE)));\n-            file.setStoragePath(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_STORAGE_PATH)));\n-            if (file.getStoragePath() == null) {\n+    private OCFile createFileInstance(Cursor cursor) {\n+        OCFile ocFile = null;\n+        if (cursor != null) {\n+            ocFile = new OCFile(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_PATH)));\n+            ocFile.setDecryptedRemotePath(getString(cursor, ProviderTableMeta.FILE_PATH_DECRYPTED));\n+            ocFile.setFileId(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta._ID)));\n+            ocFile.setParentId(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_PARENT)));\n+            ocFile.setMimeType(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_CONTENT_TYPE)));\n+            ocFile.setStoragePath(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_STORAGE_PATH)));\n+            if (ocFile.getStoragePath() == null) {\n                 // try to find existing file and bind it with current account;\n                 // with the current update of SynchronizeFolderOperation, this won't be\n                 // necessary anymore after a full synchronization of the account\n-                File f = new File(FileStorageUtils.getDefaultSavePathFor(account.name, file));\n-                if (f.exists()) {\n-                    file.setStoragePath(f.getAbsolutePath());\n-                    file.setLastSyncDateForData(f.lastModified());\n+                File file = new File(FileStorageUtils.getDefaultSavePathFor(account.name, ocFile));\n+                if (file.exists()) {\n+                    ocFile.setStoragePath(file.getAbsolutePath());\n+                    ocFile.setLastSyncDateForData(file.lastModified());\n                 }\n             }\n-            file.setFileLength(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_CONTENT_LENGTH)));\n-            file.setCreationTimestamp(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_CREATION)));\n-            file.setModificationTimestamp(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_MODIFIED)));\n-            file.setModificationTimestampAtLastSyncForData(c.getLong(\n-                    c.getColumnIndex(ProviderTableMeta.FILE_MODIFIED_AT_LAST_SYNC_FOR_DATA)));\n-            file.setLastSyncDateForProperties(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_LAST_SYNC_DATE)));\n-            file.setLastSyncDateForData(c.getLong(c.getColumnIndex(ProviderTableMeta.FILE_LAST_SYNC_DATE_FOR_DATA)));\n-            file.setEtag(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_ETAG)));\n-            file.setEtagOnServer(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_ETAG_ON_SERVER)));\n-            file.setSharedViaLink(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_SHARED_VIA_LINK)) == 1);\n-            file.setSharedWithSharee(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_SHARED_WITH_SHAREE)) == 1);\n-            file.setPublicLink(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_PUBLIC_LINK)));\n-            file.setPermissions(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_PERMISSIONS)));\n-            file.setRemoteId(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_REMOTE_ID)));\n-            file.setUpdateThumbnailNeeded(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_UPDATE_THUMBNAIL)) == 1);\n-            file.setDownloading(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_IS_DOWNLOADING)) == 1);\n-            file.setEtagInConflict(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_ETAG_IN_CONFLICT)));\n-            file.setFavorite(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_FAVORITE)) == 1);\n-            file.setEncrypted(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_IS_ENCRYPTED)) == 1);\n-//            if (file.isEncrypted()) {\n-//                file.setFileName(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_NAME)));\n+            ocFile.setFileLength(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_CONTENT_LENGTH)));\n+            ocFile.setCreationTimestamp(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_CREATION)));\n+            ocFile.setModificationTimestamp(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_MODIFIED)));\n+            ocFile.setModificationTimestampAtLastSyncForData(cursor.getLong(\n+                cursor.getColumnIndex(ProviderTableMeta.FILE_MODIFIED_AT_LAST_SYNC_FOR_DATA)));\n+            ocFile.setLastSyncDateForProperties(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_LAST_SYNC_DATE)));\n+            ocFile.setLastSyncDateForData(cursor.getLong(cursor.getColumnIndex(ProviderTableMeta.FILE_LAST_SYNC_DATE_FOR_DATA)));\n+            ocFile.setEtag(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_ETAG)));\n+            ocFile.setEtagOnServer(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_ETAG_ON_SERVER)));\n+            ocFile.setSharedViaLink(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_SHARED_VIA_LINK)) == 1);\n+            ocFile.setSharedWithSharee(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_SHARED_WITH_SHAREE)) == 1);\n+            ocFile.setPublicLink(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_PUBLIC_LINK)));\n+            ocFile.setPermissions(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_PERMISSIONS)));\n+            ocFile.setRemoteId(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_REMOTE_ID)));\n+            ocFile.setUpdateThumbnailNeeded(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_UPDATE_THUMBNAIL)) == 1);\n+            ocFile.setDownloading(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_IS_DOWNLOADING)) == 1);\n+            ocFile.setEtagInConflict(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_ETAG_IN_CONFLICT)));\n+            ocFile.setFavorite(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_FAVORITE)) == 1);\n+            ocFile.setEncrypted(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_IS_ENCRYPTED)) == 1);\n+//            if (ocFile.isEncrypted()) {\n+//                ocFile.setFileName(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_NAME)));\n //            }\n-            file.setMountType(WebdavEntry.MountType.values()[c.getInt(\n-                    c.getColumnIndex(ProviderTableMeta.FILE_MOUNT_TYPE))]);\n-            file.setPreviewAvailable(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_HAS_PREVIEW)) == 1);\n-            file.setUnreadCommentsCount(c.getInt(c.getColumnIndex(ProviderTableMeta.FILE_UNREAD_COMMENTS_COUNT)));\n-            file.setOwnerId(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_OWNER_ID)));\n-            file.setOwnerDisplayName(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_OWNER_DISPLAY_NAME)));\n-            file.setNote(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_NOTE)));\n-            file.setRichWorkspace(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_RICH_WORKSPACE)));\n+            ocFile.setMountType(WebdavEntry.MountType.values()[cursor.getInt(\n+                cursor.getColumnIndex(ProviderTableMeta.FILE_MOUNT_TYPE))]);\n+            ocFile.setPreviewAvailable(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_HAS_PREVIEW)) == 1);\n+            ocFile.setUnreadCommentsCount(cursor.getInt(cursor.getColumnIndex(ProviderTableMeta.FILE_UNREAD_COMMENTS_COUNT)));\n+            ocFile.setOwnerId(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_OWNER_ID)));\n+            ocFile.setOwnerDisplayName(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_OWNER_DISPLAY_NAME)));\n+            ocFile.setNote(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_NOTE)));\n+            ocFile.setRichWorkspace(cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_RICH_WORKSPACE)));\n \n-            String sharees = c.getString(c.getColumnIndex(ProviderTableMeta.FILE_SHAREES));\n+            String sharees = cursor.getString(cursor.getColumnIndex(ProviderTableMeta.FILE_SHAREES));\n \n             if (sharees == null || NULL_STRING.equals(sharees) || sharees.isEmpty()) {\n-                file.setSharees(new ArrayList<>());\n+                ocFile.setSharees(new ArrayList<>());\n             } else {\n                 try {\n                     ShareeUser[] shareesArray = new Gson().fromJson(sharees, ShareeUser[].class);\n \n-                    file.setSharees(new ArrayList<>(Arrays.asList(shareesArray)));\n+                    ocFile.setSharees(new ArrayList<>(Arrays.asList(shareesArray)));\n                 } catch (JsonSyntaxException e) {\n                     // ignore saved value due to api change\n-                    file.setSharees(new ArrayList<>());\n+                    ocFile.setSharees(new ArrayList<>());\n                 }\n             }\n         }\n \n-        return file;\n+        return ocFile;\n     }\n \n-    // Methods for Shares\n     public boolean saveShare(OCShare share) {\n         boolean overridden = false;\n-        ContentValues cv = new ContentValues();\n-        cv.put(ProviderTableMeta.OCSHARES_FILE_SOURCE, share.getFileSource());\n-        cv.put(ProviderTableMeta.OCSHARES_ITEM_SOURCE, share.getItemSource());\n-        cv.put(ProviderTableMeta.OCSHARES_SHARE_TYPE, share.getShareType().getValue());\n-        cv.put(ProviderTableMeta.OCSHARES_SHARE_WITH, share.getShareWith());\n-        cv.put(ProviderTableMeta.OCSHARES_PATH, share.getPath());\n-        cv.put(ProviderTableMeta.OCSHARES_PERMISSIONS, share.getPermissions());\n-        cv.put(ProviderTableMeta.OCSHARES_SHARED_DATE, share.getSharedDate());\n-        cv.put(ProviderTableMeta.OCSHARES_EXPIRATION_DATE, share.getExpirationDate());\n-        cv.put(ProviderTableMeta.OCSHARES_TOKEN, share.getToken());\n-        cv.put(ProviderTableMeta.OCSHARES_SHARE_WITH_DISPLAY_NAME, share.getSharedWithDisplayName());\n-        cv.put(ProviderTableMeta.OCSHARES_IS_DIRECTORY, share.isFolder() ? 1 : 0);\n-        cv.put(ProviderTableMeta.OCSHARES_USER_ID, share.getUserId());\n-        cv.put(ProviderTableMeta.OCSHARES_ID_REMOTE_SHARED, share.getRemoteId());\n-        cv.put(ProviderTableMeta.OCSHARES_ACCOUNT_OWNER, account.name);\n-        cv.put(ProviderTableMeta.OCSHARES_IS_PASSWORD_PROTECTED, share.isPasswordProtected() ? 1 : 0);\n-        cv.put(ProviderTableMeta.OCSHARES_NOTE, share.getNote());\n-        cv.put(ProviderTableMeta.OCSHARES_HIDE_DOWNLOAD, share.isHideFileDownload());\n+\n+        Uri contentUriShare = ProviderTableMeta.CONTENT_URI_SHARE;", "originalCommit": "37bf0dde69ef2a34154b87b42d1b8c678cfb5da2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwODEwNQ==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r440608105", "bodyText": "Issue found: Avoid instantiating new objects inside loops", "author": "nextcloud-android-bot", "createdAt": "2020-06-16T06:13:18Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -337,79 +350,81 @@ public void saveNewFile(OCFile newFile) {\n     /**\n      * Inserts or updates the list of files contained in a given folder.\n      *\n-     * CALLER IS RESPONSIBLE FOR GRANTING RIGHT UPDATE OF INFORMATION, NOT THIS METHOD.\n-     * HERE ONLY DATA CONSISTENCY SHOULD BE GRANTED\n+     * CALLER IS RESPONSIBLE FOR GRANTING RIGHT UPDATE OF INFORMATION, NOT THIS METHOD. HERE ONLY DATA CONSISTENCY\n+     * SHOULD BE GRANTED\n      *\n      * @param folder\n      * @param updatedFiles\n      * @param filesToRemove\n      */\n-    public void saveFolder(OCFile folder, Collection<OCFile> updatedFiles, Collection<OCFile> filesToRemove) {\n+    public void saveFolder(OCFile folder, List<OCFile> updatedFiles, Collection<OCFile> filesToRemove) {\n         Log_OC.d(TAG, \"Saving folder \" + folder.getRemotePath() + \" with \" + updatedFiles.size()\n-                + \" children and \" + filesToRemove.size() + \" files to remove\");\n+            + \" children and \" + filesToRemove.size() + \" files to remove\");\n \n         ArrayList<ContentProviderOperation> operations = new ArrayList<>(updatedFiles.size());\n \n         // prepare operations to insert or update files to save in the given folder\n-        for (OCFile file : updatedFiles) {\n-            ContentValues cv = createContentValueForFile(file, folder);\n+        for (OCFile ocFile : updatedFiles) {\n+            ContentValues contentValues = createContentValueForFile(ocFile, folder);\n \n-            if (fileExists(file.getFileId()) || fileExists(file.getRemotePath())) {\n+            if (fileExists(ocFile.getFileId()) || fileExists(ocFile.getRemotePath())) {\n                 long fileId;\n-                if (file.getFileId() != -1) {\n-                    fileId = file.getFileId();\n+                if (ocFile.getFileId() != -1) {\n+                    fileId = ocFile.getFileId();\n                 } else {\n-                    fileId = getFileByPath(file.getRemotePath()).getFileId();\n+                    fileId = getFileByPath(ocFile.getRemotePath()).getFileId();\n                 }\n                 // updating an existing file\n                 operations.add(ContentProviderOperation.newUpdate(ProviderTableMeta.CONTENT_URI)\n-                        .withValues(cv)\n-                                   .withSelection(ProviderTableMeta._ID + \"=?\", new String[]{String.valueOf(fileId)})\n-                        .build());\n+                                   .withValues(contentValues)\n+                                   .withSelection(ProviderTableMeta._ID + \" = ?\", new String[]{String.valueOf(fileId)})\n+                                   .build());\n             } else {\n                 // adding a new file\n-                operations.add(ContentProviderOperation.newInsert(ProviderTableMeta.CONTENT_URI).withValues(cv).build());\n+                operations.add(ContentProviderOperation.newInsert(ProviderTableMeta.CONTENT_URI)\n+                                   .withValues(contentValues)\n+                                   .build());\n             }\n         }\n \n         // prepare operations to remove files in the given folder\n-        String where = ProviderTableMeta.FILE_ACCOUNT_OWNER + AND + ProviderTableMeta.FILE_PATH + \"=?\";\n+        String where = ProviderTableMeta.FILE_ACCOUNT_OWNER + AND + ProviderTableMeta.FILE_PATH + \" = ?\";\n         String[] whereArgs = new String[2];\n-        for (OCFile file : filesToRemove) {\n-            if (file.getParentId() == folder.getFileId()) {\n-                whereArgs[0] = account.name;\n-                whereArgs[1] = file.getRemotePath();\n-                if (file.isFolder()) {\n+        whereArgs[0] = account.name;\n+        for (OCFile ocFile : filesToRemove) {\n+            if (ocFile.getParentId() == folder.getFileId()) {\n+                whereArgs[1] = ocFile.getRemotePath();\n+                if (ocFile.isFolder()) {\n                     operations.add(ContentProviderOperation.newDelete(\n-                            ContentUris.withAppendedId(ProviderTableMeta.CONTENT_URI_DIR, file.getFileId()))\n-                            .withSelection(where, whereArgs).build());\n+                        ContentUris.withAppendedId(ProviderTableMeta.CONTENT_URI_DIR, ocFile.getFileId()))\n+                                       .withSelection(where, whereArgs).build());\n \n-                    File localFolder = new File(FileStorageUtils.getDefaultSavePathFor(account.name, file));\n+                    File localFolder = new File(FileStorageUtils.getDefaultSavePathFor(account.name, ocFile));", "originalCommit": "37bf0dde69ef2a34154b87b42d1b8c678cfb5da2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwODExMQ==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r440608111", "bodyText": "Issue found: Avoid instantiating new objects inside loops", "author": "nextcloud-android-bot", "createdAt": "2020-06-16T06:13:19Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -652,91 +669,92 @@ private boolean removeLocalFolder(File localFolder) {\n             }\n         }\n         success &= localFolder.delete();\n+\n         return success;\n     }\n \n     /**\n      * Updates database and file system for a file or folder that was moved to a different location.\n      *\n-     * TODO explore better (faster) implementations\n-     * TODO throw exceptions up !\n+     * TODO explore better (faster) implementations TODO throw exceptions up !\n      */\n-    public void moveLocalFile(OCFile file, String targetPath, String targetParentPath) {\n-\n-        if (file != null && file.fileExists() && !OCFile.ROOT_PATH.equals(file.getFileName())) {\n+    public void moveLocalFile(OCFile ocFile, String targetPath, String targetParentPath) {\n+        if (ocFile.fileExists() && !OCFile.ROOT_PATH.equals(ocFile.getFileName())) {\n \n             OCFile targetParent = getFileByPath(targetParentPath);\n             if (targetParent == null) {\n                 throw new IllegalStateException(\"Parent folder of the target path does not exist!!\");\n             }\n \n             /// 1. get all the descendants of the moved element in a single QUERY\n-            Cursor c = null;\n+            Cursor cursor = null;\n             if (getContentProviderClient() != null) {\n                 try {\n-                    c = getContentProviderClient().query(\n+                    cursor = getContentProviderClient().query(\n                         ProviderTableMeta.CONTENT_URI,\n                         null,\n                         ProviderTableMeta.FILE_ACCOUNT_OWNER + AND + ProviderTableMeta.FILE_PATH + \" LIKE ? \",\n-                        new String[]{account.name, file.getRemotePath() + \"%\"},\n+                        new String[]{account.name, ocFile.getRemotePath() + \"%\"},\n                         ProviderTableMeta.FILE_PATH + \" ASC \"\n                     );\n                 } catch (RemoteException e) {\n                     Log_OC.e(TAG, e.getMessage(), e);\n                 }\n \n             } else {\n-                c = getContentResolver().query(\n+                cursor = getContentResolver().query(\n                     ProviderTableMeta.CONTENT_URI,\n                     null,\n                     ProviderTableMeta.FILE_ACCOUNT_OWNER + AND + ProviderTableMeta.FILE_PATH + \" LIKE ? \",\n-                    new String[]{account.name, file.getRemotePath() + \"%\"},\n+                    new String[]{account.name, ocFile.getRemotePath() + \"%\"},\n                     ProviderTableMeta.FILE_PATH + \" ASC \"\n                 );\n             }\n \n             /// 2. prepare a batch of update operations to change all the descendants\n-            ArrayList<ContentProviderOperation> operations = new ArrayList<>(c.getCount());\n+            ArrayList<ContentProviderOperation> operations = new ArrayList<>(cursor.getCount());\n             String defaultSavePath = FileStorageUtils.getSavePath(account.name);\n             List<String> originalPathsToTriggerMediaScan = new ArrayList<>();\n             List<String> newPathsToTriggerMediaScan = new ArrayList<>();\n-            if (c.moveToFirst()) {\n-                int lengthOfOldPath = file.getRemotePath().length();\n+\n+            if (cursor.moveToFirst()) {\n+                int lengthOfOldPath = ocFile.getRemotePath().length();\n                 int lengthOfOldStoragePath = defaultSavePath.length() + lengthOfOldPath;\n-                String[] fileId = new String[1];\n                 do {\n-                    ContentValues cv = new ContentValues(); // keep construction in the loop\n-                    OCFile child = createFileInstance(c);\n-                    cv.put(\n+                    ContentValues contentValues = new ContentValues(); // keep construction in the loop", "originalCommit": "37bf0dde69ef2a34154b87b42d1b8c678cfb5da2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwODEyMw==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r440608123", "bodyText": "Issue found: Avoid reassigning parameters such as 'etagInConflict'", "author": "nextcloud-android-bot", "createdAt": "2020-06-16T06:13:19Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -1782,67 +1762,66 @@ public static void triggerMediaScan(String path, OCFile file) {\n     }\n \n     public void deleteFileInMediaScan(String path) {\n-\n         String mimetypeString = FileStorageUtils.getMimeTypeFromName(path);\n         ContentResolver contentResolver = getContentResolver();\n \n         if (contentResolver != null) {\n             if (MimeTypeUtil.isImage(mimetypeString)) {\n                 // Images\n                 contentResolver.delete(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n-                        MediaStore.Images.Media.DATA + \"=?\", new String[]{path});\n+                                       MediaStore.Images.Media.DATA + \"=?\", new String[]{path});\n             } else if (MimeTypeUtil.isAudio(mimetypeString)) {\n                 // Audio\n                 contentResolver.delete(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n-                        MediaStore.Audio.Media.DATA + \"=?\", new String[]{path});\n+                                       MediaStore.Audio.Media.DATA + \"=?\", new String[]{path});\n             } else if (MimeTypeUtil.isVideo(mimetypeString)) {\n                 // Video\n                 contentResolver.delete(MediaStore.Video.Media.EXTERNAL_CONTENT_URI,\n-                        MediaStore.Video.Media.DATA + \"=?\", new String[]{path});\n+                                       MediaStore.Video.Media.DATA + \"=?\", new String[]{path});\n             }\n         } else {\n             ContentProviderClient contentProviderClient = getContentProviderClient();\n             try {\n                 if (MimeTypeUtil.isImage(mimetypeString)) {\n                     // Images\n                     contentProviderClient.delete(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n-                            MediaStore.Images.Media.DATA + \"=?\", new String[]{path});\n+                                                 MediaStore.Images.Media.DATA + \"=?\", new String[]{path});\n                 } else if (MimeTypeUtil.isAudio(mimetypeString)) {\n                     // Audio\n                     contentProviderClient.delete(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n-                            MediaStore.Audio.Media.DATA + \"=?\", new String[]{path});\n+                                                 MediaStore.Audio.Media.DATA + \"=?\", new String[]{path});\n                 } else if (MimeTypeUtil.isVideo(mimetypeString)) {\n                     // Video\n                     contentProviderClient.delete(MediaStore.Video.Media.EXTERNAL_CONTENT_URI,\n-                            MediaStore.Video.Media.DATA + \"=?\", new String[]{path});\n+                                                 MediaStore.Video.Media.DATA + \"=?\", new String[]{path});\n                 }\n             } catch (RemoteException e) {\n                 Log_OC.e(TAG, \"Exception deleting media file in MediaStore \" + e.getMessage(), e);\n             }\n         }\n     }\n \n-    public void saveConflict(OCFile file, String etagInConflict) {\n-        if (!file.isDown()) {\n+    public void saveConflict(OCFile ocFile, String etagInConflict) {", "originalCommit": "37bf0dde69ef2a34154b87b42d1b8c678cfb5da2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwODEzMw==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r440608133", "bodyText": "Issue found: Assigning an Object to null is a code smell.  Consider refactoring.", "author": "nextcloud-android-bot", "createdAt": "2020-06-16T06:13:20Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -85,15 +86,15 @@\n     private ContentProviderClient contentProviderClient;\n     private Account account;\n \n-    public FileDataStorageManager(Account account, ContentResolver cr) {\n-        contentProviderClient = null;\n-        contentResolver = cr;\n+    public FileDataStorageManager(Account account, ContentResolver contentResolver) {\n+        this.contentProviderClient = null;", "originalCommit": "37bf0dde69ef2a34154b87b42d1b8c678cfb5da2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwODEzOQ==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r440608139", "bodyText": "Issue found: Assigning an Object to null is a code smell.  Consider refactoring.", "author": "nextcloud-android-bot", "createdAt": "2020-06-16T06:13:21Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -85,15 +86,15 @@\n     private ContentProviderClient contentProviderClient;\n     private Account account;\n \n-    public FileDataStorageManager(Account account, ContentResolver cr) {\n-        contentProviderClient = null;\n-        contentResolver = cr;\n+    public FileDataStorageManager(Account account, ContentResolver contentResolver) {\n+        this.contentProviderClient = null;\n+        this.contentResolver = contentResolver;\n         this.account = account;\n     }\n \n-    public FileDataStorageManager(Account account, ContentProviderClient cp) {\n-        contentProviderClient = cp;\n-        contentResolver = null;\n+    public FileDataStorageManager(Account account, ContentProviderClient contentProviderClient) {\n+        this.contentProviderClient = contentProviderClient;\n+        this.contentResolver = null;", "originalCommit": "37bf0dde69ef2a34154b87b42d1b8c678cfb5da2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwODE0OQ==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r440608149", "bodyText": "Issue found: Avoid really long methods.", "author": "nextcloud-android-bot", "createdAt": "2020-06-16T06:13:22Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -1782,67 +1762,66 @@ public static void triggerMediaScan(String path, OCFile file) {\n     }\n \n     public void deleteFileInMediaScan(String path) {\n-\n         String mimetypeString = FileStorageUtils.getMimeTypeFromName(path);\n         ContentResolver contentResolver = getContentResolver();\n \n         if (contentResolver != null) {\n             if (MimeTypeUtil.isImage(mimetypeString)) {\n                 // Images\n                 contentResolver.delete(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n-                        MediaStore.Images.Media.DATA + \"=?\", new String[]{path});\n+                                       MediaStore.Images.Media.DATA + \"=?\", new String[]{path});\n             } else if (MimeTypeUtil.isAudio(mimetypeString)) {\n                 // Audio\n                 contentResolver.delete(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n-                        MediaStore.Audio.Media.DATA + \"=?\", new String[]{path});\n+                                       MediaStore.Audio.Media.DATA + \"=?\", new String[]{path});\n             } else if (MimeTypeUtil.isVideo(mimetypeString)) {\n                 // Video\n                 contentResolver.delete(MediaStore.Video.Media.EXTERNAL_CONTENT_URI,\n-                        MediaStore.Video.Media.DATA + \"=?\", new String[]{path});\n+                                       MediaStore.Video.Media.DATA + \"=?\", new String[]{path});\n             }\n         } else {\n             ContentProviderClient contentProviderClient = getContentProviderClient();\n             try {\n                 if (MimeTypeUtil.isImage(mimetypeString)) {\n                     // Images\n                     contentProviderClient.delete(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n-                            MediaStore.Images.Media.DATA + \"=?\", new String[]{path});\n+                                                 MediaStore.Images.Media.DATA + \"=?\", new String[]{path});\n                 } else if (MimeTypeUtil.isAudio(mimetypeString)) {\n                     // Audio\n                     contentProviderClient.delete(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n-                            MediaStore.Audio.Media.DATA + \"=?\", new String[]{path});\n+                                                 MediaStore.Audio.Media.DATA + \"=?\", new String[]{path});\n                 } else if (MimeTypeUtil.isVideo(mimetypeString)) {\n                     // Video\n                     contentProviderClient.delete(MediaStore.Video.Media.EXTERNAL_CONTENT_URI,\n-                            MediaStore.Video.Media.DATA + \"=?\", new String[]{path});\n+                                                 MediaStore.Video.Media.DATA + \"=?\", new String[]{path});\n                 }\n             } catch (RemoteException e) {\n                 Log_OC.e(TAG, \"Exception deleting media file in MediaStore \" + e.getMessage(), e);\n             }\n         }\n     }\n \n-    public void saveConflict(OCFile file, String etagInConflict) {\n-        if (!file.isDown()) {\n+    public void saveConflict(OCFile ocFile, String etagInConflict) {", "originalCommit": "37bf0dde69ef2a34154b87b42d1b8c678cfb5da2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwODE1Mw==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r440608153", "bodyText": "Issue found: Avoid instantiating new objects inside loops", "author": "nextcloud-android-bot", "createdAt": "2020-06-16T06:13:23Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -652,91 +669,92 @@ private boolean removeLocalFolder(File localFolder) {\n             }\n         }\n         success &= localFolder.delete();\n+\n         return success;\n     }\n \n     /**\n      * Updates database and file system for a file or folder that was moved to a different location.\n      *\n-     * TODO explore better (faster) implementations\n-     * TODO throw exceptions up !\n+     * TODO explore better (faster) implementations TODO throw exceptions up !\n      */\n-    public void moveLocalFile(OCFile file, String targetPath, String targetParentPath) {\n-\n-        if (file != null && file.fileExists() && !OCFile.ROOT_PATH.equals(file.getFileName())) {\n+    public void moveLocalFile(OCFile ocFile, String targetPath, String targetParentPath) {\n+        if (ocFile.fileExists() && !OCFile.ROOT_PATH.equals(ocFile.getFileName())) {\n \n             OCFile targetParent = getFileByPath(targetParentPath);\n             if (targetParent == null) {\n                 throw new IllegalStateException(\"Parent folder of the target path does not exist!!\");\n             }\n \n             /// 1. get all the descendants of the moved element in a single QUERY\n-            Cursor c = null;\n+            Cursor cursor = null;\n             if (getContentProviderClient() != null) {\n                 try {\n-                    c = getContentProviderClient().query(\n+                    cursor = getContentProviderClient().query(\n                         ProviderTableMeta.CONTENT_URI,\n                         null,\n                         ProviderTableMeta.FILE_ACCOUNT_OWNER + AND + ProviderTableMeta.FILE_PATH + \" LIKE ? \",\n-                        new String[]{account.name, file.getRemotePath() + \"%\"},\n+                        new String[]{account.name, ocFile.getRemotePath() + \"%\"},\n                         ProviderTableMeta.FILE_PATH + \" ASC \"\n                     );\n                 } catch (RemoteException e) {\n                     Log_OC.e(TAG, e.getMessage(), e);\n                 }\n \n             } else {\n-                c = getContentResolver().query(\n+                cursor = getContentResolver().query(\n                     ProviderTableMeta.CONTENT_URI,\n                     null,\n                     ProviderTableMeta.FILE_ACCOUNT_OWNER + AND + ProviderTableMeta.FILE_PATH + \" LIKE ? \",\n-                    new String[]{account.name, file.getRemotePath() + \"%\"},\n+                    new String[]{account.name, ocFile.getRemotePath() + \"%\"},\n                     ProviderTableMeta.FILE_PATH + \" ASC \"\n                 );\n             }\n \n             /// 2. prepare a batch of update operations to change all the descendants\n-            ArrayList<ContentProviderOperation> operations = new ArrayList<>(c.getCount());\n+            ArrayList<ContentProviderOperation> operations = new ArrayList<>(cursor.getCount());\n             String defaultSavePath = FileStorageUtils.getSavePath(account.name);\n             List<String> originalPathsToTriggerMediaScan = new ArrayList<>();\n             List<String> newPathsToTriggerMediaScan = new ArrayList<>();\n-            if (c.moveToFirst()) {\n-                int lengthOfOldPath = file.getRemotePath().length();\n+\n+            if (cursor.moveToFirst()) {\n+                int lengthOfOldPath = ocFile.getRemotePath().length();\n                 int lengthOfOldStoragePath = defaultSavePath.length() + lengthOfOldPath;\n-                String[] fileId = new String[1];\n                 do {\n-                    ContentValues cv = new ContentValues(); // keep construction in the loop\n-                    OCFile child = createFileInstance(c);\n-                    cv.put(\n+                    ContentValues contentValues = new ContentValues(); // keep construction in the loop\n+                    OCFile childFile = createFileInstance(cursor);\n+                    contentValues.put(\n                         ProviderTableMeta.FILE_PATH,\n-                        targetPath + child.getRemotePath().substring(lengthOfOldPath)\n+                        targetPath + childFile.getRemotePath().substring(lengthOfOldPath)\n                     );\n-                    if (child.getStoragePath() != null && child.getStoragePath().startsWith(defaultSavePath)) {\n+\n+                    if (childFile.getStoragePath() != null && childFile.getStoragePath().startsWith(defaultSavePath)) {\n                         // update link to downloaded content - but local move is not done here!\n                         String targetLocalPath = defaultSavePath + targetPath +\n-                                child.getStoragePath().substring(lengthOfOldStoragePath);\n+                            childFile.getStoragePath().substring(lengthOfOldStoragePath);\n \n-                        cv.put(ProviderTableMeta.FILE_STORAGE_PATH, targetLocalPath);\n+                        contentValues.put(ProviderTableMeta.FILE_STORAGE_PATH, targetLocalPath);\n \n-                        if (MimeTypeUtil.isMedia(child.getMimeType())) {\n-                            originalPathsToTriggerMediaScan.add(child.getStoragePath());\n+                        if (MimeTypeUtil.isMedia(childFile.getMimeType())) {\n+                            originalPathsToTriggerMediaScan.add(childFile.getStoragePath());\n                             newPathsToTriggerMediaScan.add(targetLocalPath);\n                         }\n \n                     }\n-                    if (child.getRemotePath().equals(file.getRemotePath())) {\n-                        cv.put(ProviderTableMeta.FILE_PARENT, targetParent.getFileId());\n+\n+                    if (childFile.getRemotePath().equals(ocFile.getRemotePath())) {\n+                        contentValues.put(ProviderTableMeta.FILE_PARENT, targetParent.getFileId());\n                     }\n-                    fileId[0] = String.valueOf(child.getFileId());\n+\n                     operations.add(\n-                            ContentProviderOperation.newUpdate(ProviderTableMeta.CONTENT_URI).\n-                                    withValues(cv).\n-                                    withSelection(ProviderTableMeta._ID + \"=?\", fileId)\n-                                    .build());\n+                        ContentProviderOperation.newUpdate(ProviderTableMeta.CONTENT_URI)\n+                            .withValues(contentValues)\n+                            .withSelection(ProviderTableMeta._ID + \" = ?\", new String[]{String.valueOf(childFile.getFileId())})", "originalCommit": "37bf0dde69ef2a34154b87b42d1b8c678cfb5da2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwODE1Ng==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r440608156", "bodyText": "Issue found: Avoid instantiating new objects inside loops", "author": "nextcloud-android-bot", "createdAt": "2020-06-16T06:13:24Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -610,24 +627,22 @@ private boolean removeLocalFolder(OCFile folder) {\n         boolean success = true;\n         String localFolderPath = FileStorageUtils.getDefaultSavePathFor(account.name, folder);\n         File localFolder = new File(localFolderPath);\n+\n         if (localFolder.exists()) {\n             // stage 1: remove the local files already registered in the files database\n             List<OCFile> files = getFolderContent(folder.getFileId(), false);\n-            if (files != null) {\n-                for (OCFile file : files) {\n-                    if (file.isFolder()) {\n-                        success &= removeLocalFolder(file);\n-                    } else {\n-                        if (file.isDown()) {\n-                            File localFile = new File(file.getStoragePath());\n-                            success &= localFile.delete();\n-                            if (success) {\n-                                // notify MediaScanner about removed file\n-                                deleteFileInMediaScan(file.getStoragePath());\n-                                file.setStoragePath(null);\n-                                saveFile(file);\n-                            }\n-                        }\n+            for (OCFile ocFile : files) {\n+                if (ocFile.isFolder()) {\n+                    success &= removeLocalFolder(ocFile);\n+                } else if (ocFile.isDown()) {\n+                    File localFile = new File(ocFile.getStoragePath());", "originalCommit": "37bf0dde69ef2a34154b87b42d1b8c678cfb5da2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwODE2NA==", "url": "https://github.com/nextcloud/android/pull/5336#discussion_r440608164", "bodyText": "Issue found: Avoid instantiating new objects inside loops", "author": "nextcloud-android-bot", "createdAt": "2020-06-16T06:13:24Z", "path": "src/main/java/com/owncloud/android/datamodel/FileDataStorageManager.java", "diffHunk": "@@ -1350,70 +1354,67 @@ private void cleanShares() {\n         }\n     }\n \n+    // TODO shares null?\n     public void saveShares(Collection<OCShare> shares) {\n         cleanShares();\n-        if (shares != null) {\n-            ArrayList<ContentProviderOperation> operations =\n-                    new ArrayList<ContentProviderOperation>(shares.size());\n+        ArrayList<ContentProviderOperation> operations = new ArrayList<>(shares.size());\n \n-            // prepare operations to insert or update files to save in the given folder\n-            for (OCShare share : shares) {\n-                ContentValues cv = new ContentValues();\n-                cv.put(ProviderTableMeta.OCSHARES_FILE_SOURCE, share.getFileSource());\n-                cv.put(ProviderTableMeta.OCSHARES_ITEM_SOURCE, share.getItemSource());\n-                cv.put(ProviderTableMeta.OCSHARES_SHARE_TYPE, share.getShareType().getValue());\n-                cv.put(ProviderTableMeta.OCSHARES_SHARE_WITH, share.getShareWith());\n-                cv.put(ProviderTableMeta.OCSHARES_PATH, share.getPath());\n-                cv.put(ProviderTableMeta.OCSHARES_PERMISSIONS, share.getPermissions());\n-                cv.put(ProviderTableMeta.OCSHARES_SHARED_DATE, share.getSharedDate());\n-                cv.put(ProviderTableMeta.OCSHARES_EXPIRATION_DATE, share.getExpirationDate());\n-                cv.put(ProviderTableMeta.OCSHARES_TOKEN, share.getToken());\n-                cv.put(ProviderTableMeta.OCSHARES_SHARE_WITH_DISPLAY_NAME, share.getSharedWithDisplayName());\n-                cv.put(ProviderTableMeta.OCSHARES_IS_DIRECTORY, share.isFolder() ? 1 : 0);\n-                cv.put(ProviderTableMeta.OCSHARES_USER_ID, share.getUserId());\n-                cv.put(ProviderTableMeta.OCSHARES_ID_REMOTE_SHARED, share.getRemoteId());\n-                cv.put(ProviderTableMeta.OCSHARES_ACCOUNT_OWNER, account.name);\n-                cv.put(ProviderTableMeta.OCSHARES_IS_PASSWORD_PROTECTED, share.isPasswordProtected() ? 1 : 0);\n-                cv.put(ProviderTableMeta.OCSHARES_NOTE, share.getNote());\n-                cv.put(ProviderTableMeta.OCSHARES_HIDE_DOWNLOAD, share.isHideFileDownload());\n-\n-                if (shareExistsForRemoteId(share.getRemoteId())) {\n-                    // updating an existing file\n-                    operations.add(\n-                            ContentProviderOperation.newUpdate(ProviderTableMeta.CONTENT_URI_SHARE).\n-                                    withValues(cv).\n-                                    withSelection(ProviderTableMeta.OCSHARES_ID_REMOTE_SHARED + \"=?\",\n-                                            new String[]{String.valueOf(share.getRemoteId())})\n-                                    .build());\n-                } else {\n-                    // adding a new file\n-                    operations.add(\n-                            ContentProviderOperation.newInsert(ProviderTableMeta.CONTENT_URI_SHARE).\n-                                    withValues(cv).\n-                                    build()\n-                    );\n-                }\n+        // prepare operations to insert or update files to save in the given folder\n+        for (OCShare share : shares) {\n+            ContentValues contentValues = new ContentValues();", "originalCommit": "37bf0dde69ef2a34154b87b42d1b8c678cfb5da2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}