{"pr_number": 1801, "pr_title": "Correct two JPA processing bugs", "pr_createdAt": "2020-04-14T22:32:23Z", "pr_url": "https://github.com/hapifhir/hapi-fhir/pull/1801", "timeline": [{"oid": "925ed26cd8afde5620a450d212ba51dc4fb0a7c8", "url": "https://github.com/hapifhir/hapi-fhir/commit/925ed26cd8afde5620a450d212ba51dc4fb0a7c8", "message": "Work on search params on contained", "committedDate": "2020-04-14T09:35:04Z", "type": "commit"}, {"oid": "cb3cd693dfb901c79484d5c5fff5c4bfe1fe12b3", "url": "https://github.com/hapifhir/hapi-fhir/commit/cb3cd693dfb901c79484d5c5fff5c4bfe1fe12b3", "message": "Add workaround for stored decimals with leading decimal point", "committedDate": "2020-04-14T22:28:51Z", "type": "commit"}, {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1", "url": "https://github.com/hapifhir/hapi-fhir/commit/2bf30a98003d7d08d933823b673fbe0382cf44e1", "message": "Add changelog", "committedDate": "2020-04-14T22:36:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MTI2NQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408481265", "bodyText": "What happens if the string is literal . ? that substring will fail, but is that a possible state this resource could be in?", "author": "tadgh", "createdAt": "2020-04-14T22:50:48Z", "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/parser/ParserState.java", "diffHunk": "@@ -1269,41 +1272,50 @@ public boolean isPreResource() {\n \n \tprivate class PrimitiveState extends BaseState {\n \t\tprivate final String myChildName;\n+\t\tprivate final String myTypeName;\n \t\tprivate IPrimitiveType<?> myInstance;\n \n-\t\tPrimitiveState(PreResourceState thePreResourceState, IPrimitiveType<?> theInstance, String theChildName) {\n+\t\tPrimitiveState(PreResourceState thePreResourceState, IPrimitiveType<?> theInstance, String theChildName, String theTypeName) {\n \t\t\tsuper(thePreResourceState);\n \t\t\tmyInstance = theInstance;\n \t\t\tmyChildName = theChildName;\n+\t\t\tmyTypeName = theTypeName;\n \t\t}\n \n \t\t@Override\n \t\tpublic void attributeValue(String theName, String theValue) throws DataFormatException {\n+\t\t\tString value = theValue;\n \t\t\tif (\"value\".equals(theName)) {\n-\t\t\t\tif (\"\".equals(theValue)) {\n+\t\t\t\tif (\"\".equals(value)) {\n \t\t\t\t\tParseLocation location = ParseLocation.fromElementName(myChildName);\n-\t\t\t\t\tmyErrorHandler.invalidValue(location, theValue, \"Attribute value must not be empty (\\\"\\\")\");\n+\t\t\t\t\tmyErrorHandler.invalidValue(location, value, \"Attribute value must not be empty (\\\"\\\")\");\n \t\t\t\t} else {\n+\t\t\t\t\tif (\"decimal\".equals(myTypeName)) {\n+\t\t\t\t\t\tif (value != null && value.startsWith(\".\") && NumberUtils.isDigits(value.substring(1))) {", "originalCommit": "2bf30a98003d7d08d933823b673fbe0382cf44e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMjAzOA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408502038", "bodyText": "Good question, adding a test!", "author": "jamesagnew", "createdAt": "2020-04-14T23:54:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MTI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MjQ0Mg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408482442", "bodyText": "could we not just private the constructor and provide a factory method", "author": "tadgh", "createdAt": "2020-04-14T22:54:11Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/util/TolerantJsonParser.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package ca.uhn.fhir.jpa.util;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.parser.DataFormatException;\n+import ca.uhn.fhir.parser.IParserErrorHandler;\n+import ca.uhn.fhir.parser.JsonParser;\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.commons.lang3.StringUtils.defaultString;\n+\n+public class TolerantJsonParser extends JsonParser {\n+\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(TolerantJsonParser.class);\n+\n+\t/**\n+\t * Do not use this constructor, the recommended way to obtain a new instance of the JSON parser is to invoke\n+\t * {@link FhirContext#newJsonParser()}.\n+\t */\n+\tpublic TolerantJsonParser(FhirContext theContext, IParserErrorHandler theParserErrorHandler) {", "originalCommit": "2bf30a98003d7d08d933823b673fbe0382cf44e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMzI5NQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408503295", "bodyText": "oops, that comment is actually just copy-paste from the regular JsonParser.. but this whole class should really be package-protected. Doing that,", "author": "jamesagnew", "createdAt": "2020-04-14T23:58:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MjQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4Mjc4NA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408482784", "bodyText": "\ud83d\udc4d", "author": "tadgh", "createdAt": "2020-04-14T22:55:05Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/util/TolerantJsonParser.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package ca.uhn.fhir.jpa.util;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.parser.DataFormatException;\n+import ca.uhn.fhir.parser.IParserErrorHandler;\n+import ca.uhn.fhir.parser.JsonParser;\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.commons.lang3.StringUtils.defaultString;\n+\n+public class TolerantJsonParser extends JsonParser {\n+\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(TolerantJsonParser.class);\n+\n+\t/**\n+\t * Do not use this constructor, the recommended way to obtain a new instance of the JSON parser is to invoke\n+\t * {@link FhirContext#newJsonParser()}.\n+\t */\n+\tpublic TolerantJsonParser(FhirContext theContext, IParserErrorHandler theParserErrorHandler) {\n+\t\tsuper(theContext, theParserErrorHandler);\n+\t}\n+\n+\t@Override\n+\tpublic <T extends IBaseResource> T parseResource(Class<T> theResourceType, String theMessageString) {\n+\t\ttry {\n+\t\t\treturn super.parseResource(theResourceType, theMessageString);\n+\t\t} catch (DataFormatException e) {\n+\t\t\tif (defaultString(e.getMessage()).contains(\"Unexpected character ('.' (code 46))\")) {\n+\n+\t\t\t\t/*\n+\t\t\t\t * The following is a hacky and gross workaround until the following PR is hopefully merged:\n+\t\t\t\t * https://github.com/FasterXML/jackson-core/pull/611\n+\t\t\t\t *\n+\t\t\t\t * The issue this solves is that under Gson it was possible to store JSON containing\n+\t\t\t\t * decimal numbers with no leading integer, e.g. .123\n+\t\t\t\t *\n+\t\t\t\t * These don't parse in Jackson, meaning we can be stuck with data in the database\n+\t\t\t\t * that can't be loaded back out.\n+\t\t\t\t *\n+\t\t\t\t * Note that if we fix this in the future to rely on Jackson natively handing this\n+\t\t\t\t * nicely we may or may not be able to remove some code from\n+\t\t\t\t * ParserState.Primitive state too.\n+\t\t\t\t */", "originalCommit": "2bf30a98003d7d08d933823b673fbe0382cf44e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MjkxOQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408482919", "bodyText": "heh nice fix", "author": "tadgh", "createdAt": "2020-04-14T22:55:23Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/util/TolerantJsonParser.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package ca.uhn.fhir.jpa.util;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.parser.DataFormatException;\n+import ca.uhn.fhir.parser.IParserErrorHandler;\n+import ca.uhn.fhir.parser.JsonParser;\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.commons.lang3.StringUtils.defaultString;\n+\n+public class TolerantJsonParser extends JsonParser {\n+\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(TolerantJsonParser.class);\n+\n+\t/**\n+\t * Do not use this constructor, the recommended way to obtain a new instance of the JSON parser is to invoke\n+\t * {@link FhirContext#newJsonParser()}.\n+\t */\n+\tpublic TolerantJsonParser(FhirContext theContext, IParserErrorHandler theParserErrorHandler) {\n+\t\tsuper(theContext, theParserErrorHandler);\n+\t}\n+\n+\t@Override\n+\tpublic <T extends IBaseResource> T parseResource(Class<T> theResourceType, String theMessageString) {\n+\t\ttry {\n+\t\t\treturn super.parseResource(theResourceType, theMessageString);\n+\t\t} catch (DataFormatException e) {\n+\t\t\tif (defaultString(e.getMessage()).contains(\"Unexpected character ('.' (code 46))\")) {\n+\n+\t\t\t\t/*\n+\t\t\t\t * The following is a hacky and gross workaround until the following PR is hopefully merged:\n+\t\t\t\t * https://github.com/FasterXML/jackson-core/pull/611\n+\t\t\t\t *\n+\t\t\t\t * The issue this solves is that under Gson it was possible to store JSON containing\n+\t\t\t\t * decimal numbers with no leading integer, e.g. .123\n+\t\t\t\t *\n+\t\t\t\t * These don't parse in Jackson, meaning we can be stuck with data in the database\n+\t\t\t\t * that can't be loaded back out.\n+\t\t\t\t *\n+\t\t\t\t * Note that if we fix this in the future to rely on Jackson natively handing this\n+\t\t\t\t * nicely we may or may not be able to remove some code from\n+\t\t\t\t * ParserState.Primitive state too.\n+\t\t\t\t */\n+\n+\t\t\t\tGson gson = new Gson();\n+\n+\t\t\t\tJsonObject object = gson.fromJson(theMessageString, JsonObject.class);\n+\t\t\t\tString corrected = gson.toJson(object);\n+\n+\t\t\t\treturn super.parseResource(theResourceType, corrected);\n+", "originalCommit": "2bf30a98003d7d08d933823b673fbe0382cf44e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMzUwNw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408503507", "bodyText": "\"nice\"\n... gross more like :p", "author": "jamesagnew", "createdAt": "2020-04-14T23:59:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MjkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MzU3MA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408483570", "bodyText": "JSONing a SearchParameter feels pretty brittle in a test. Is there a reason why we don't just instantiate it and pass it to the DAO?", "author": "tadgh", "createdAt": "2020-04-14T22:57:18Z", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/dstu3/FhirResourceDaoDstu3SearchCustomSearchParamTest.java", "diffHunk": "@@ -1054,6 +1057,55 @@ public void testSearchWithCustomParamDraft() {\n \n \t}\n \n+\t@Test\n+\tpublic void testProgramaticallyContainedByReferenceAreStillResolvable() {\n+\t\tString sp = \"{\" +\n+\t\t\t\"\\\"resourceType\\\": \\\"SearchParameter\\\",\\n\" +\n+\t\t\t\"  \\\"id\\\": \\\"medicationadministration-ingredient-medication\\\",\\n\" +\n+\t\t\t\"  \\\"url\\\": \\\"http://hapifhir.io/fhir/StructureDefinition/sp-unique\\\",\\n\" +\n+\t\t\t\"  \\\"name\\\": \\\"MEDICATIONADMINISTRATION-INGREDIENT-MEDICATION\\\",\\n\" +\n+\t\t\t\"  \\\"status\\\": \\\"active\\\",\\n\" +\n+\t\t\t\"  \\\"code\\\": \\\"medicationadministration-ingredient-medication\\\",\\n\" +\n+\t\t\t\"  \\\"base\\\": [\\n\" +\n+\t\t\t\"    \\\"MedicationAdministration\\\"\\n\" +\n+\t\t\t\"  ],\\n\" +\n+\t\t\t\"  \\\"type\\\": \\\"token\\\",\\n\" +\n+\t\t\t\"  \\\"description\\\": \\\"This search parameter is used to find a MedicationAdministration by contained medication\\\",\\n\" +\n+\t\t\t\"  \\\"expression\\\": \\\"MedicationAdministration.medication.resolve().ingredient.item.as(Reference).resolve().code\\\",\\n\" +\n+\t\t\t\"  \\\"xpathUsage\\\": \\\"normal\\\"\\n\" +\n+\t\t\t\"}\\n\";", "originalCommit": "2bf30a98003d7d08d933823b673fbe0382cf44e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwNDEzNQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408504135", "bodyText": "Just laziness... fixing it now :)", "author": "jamesagnew", "createdAt": "2020-04-15T00:01:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MzU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4Mzc1Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408483753", "bodyText": "I imagine this is a typo?", "author": "tadgh", "createdAt": "2020-04-14T22:57:50Z", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirSystemDaoR4Test.java", "diffHunk": "@@ -645,7 +645,7 @@ public void testReindexingSingleStringHashIdentityValueIsDeleted() {\n \n \t\trunInTransaction(()->{\n \t\t\tLong i = myEntityManager\n-\t\t\t\t.createQuery(\"SELECT count(s) FROM ResourceIndexedSearchParamString s WHERE s.myHashIdentity IS null\", Long.class)\n+\t\t\t\t.createQuery(\"SELECT count(s) FROM ResourceIndexedSearchParamString s WHERE s.myHashIdentity IS nullhir\", Long.class)", "originalCommit": "2bf30a98003d7d08d933823b673fbe0382cf44e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwNDMwNg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408504306", "bodyText": "yyyyup", "author": "jamesagnew", "createdAt": "2020-04-15T00:02:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4Mzc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4NjQ3Mg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408486472", "bodyText": "I am relatively lost as to whats going on in this function, but i understand this is a hack that will probably eventually be removed, so I'm good with it. May be worthwhile to document somewhere that this needs reworking", "author": "tadgh", "createdAt": "2020-04-14T23:05:47Z", "path": "hapi-fhir-jpaserver-searchparam/src/main/java/ca/uhn/fhir/jpa/searchparam/extractor/SearchParamExtractorService.java", "diffHunk": "@@ -90,8 +115,155 @@ public void extractFromResource(RequestDetails theRequestDetails, ResourceIndexe\n \t\tpopulateResourceTable(theParams.myUriParams, theEntity);\n \t\tpopulateResourceTable(theParams.myCoordsParams, theEntity);\n \t\tpopulateResourceTable(theParams.myTokenParams, theEntity);\n+\n+\t\ttheParams.setUpdatedTime(theUpdateTime);\n+\t}\n+\n+\t/**\n+\t * This is a bit hacky, but if someone has manually populated a resource (ie. my working directly with the model\n+\t * as opposed to by parsing a serialized instance) it's possible that they have put in contained resources\n+\t * using {@link IBaseReference#setResource(IBaseResource)}, and those contained resources have not yet\n+\t * ended up in the Resource.contained array, meaning that FHIRPath expressions won't be able to find them.\n+\t *\n+\t * As a result, we to a serialize-and-parse to normalize the object. This really only affects people who\n+\t * are calling the JPA DAOs directly, but there are a few of those...\n+\t */\n+\tprivate IBaseResource normalizeResource(IBaseResource theResource) {\n+\t\tIParser parser = myContext.newJsonParser().setPrettyPrint(false);\n+\t\ttheResource = parser.parseResource(parser.encodeResourceToString(theResource));\n+\t\treturn theResource;\n+\t}\n+\n+\tprivate void extractResourceLinks(ResourceIndexedSearchParams theParams, ResourceTable theEntity, IBaseResource theResource, Date theUpdateTime, IResourceLinkResolver theResourceLinkResolver, boolean theFailOnInvalidReference, RequestDetails theRequest) {\n+\t\tString resourceName = myContext.getResourceDefinition(theResource).getName();\n+\n+\t\tISearchParamExtractor.SearchParamSet<PathAndRef> refs = mySearchParamExtractor.extractResourceLinks(theResource);\n+\t\tSearchParamExtractorService.handleWarnings(theRequest, myInterceptorBroadcaster, refs);\n+\n+\t\tMap<String, IResourceLookup> resourceIdToResolvedTarget = new HashMap<>();\n+\t\tfor (PathAndRef nextPathAndRef : refs) {\n+\t\t\tRuntimeSearchParam searchParam = mySearchParamRegistry.getActiveSearchParam(resourceName, nextPathAndRef.getSearchParamName());\n+\t\t\textractResourceLinks(theParams, theEntity, theUpdateTime, theResourceLinkResolver, searchParam, nextPathAndRef, theFailOnInvalidReference, theRequest, resourceIdToResolvedTarget);\n+\t\t}\n+\n+\t\ttheEntity.setHasLinks(theParams.myLinks.size() > 0);\n+\t}\n+\n+\tprivate void extractResourceLinks(ResourceIndexedSearchParams theParams, ResourceTable theEntity, Date theUpdateTime, IResourceLinkResolver theResourceLinkResolver, RuntimeSearchParam theRuntimeSearchParam, PathAndRef thePathAndRef, boolean theFailOnInvalidReference, RequestDetails theRequest, Map<String, IResourceLookup> theResourceIdToResolvedTarget) {\n+\t\tIBaseReference nextReference = thePathAndRef.getRef();\n+\t\tIIdType nextId = nextReference.getReferenceElement();\n+\t\tString path = thePathAndRef.getPath();\n+\n+\t\t/*\n+\t\t * This can only really happen if the DAO is being called\n+\t\t * programmatically with a Bundle (not through the FHIR REST API)\n+\t\t * but Smile does this\n+\t\t */\n+\t\tif (nextId.isEmpty() && nextReference.getResource() != null) {\n+\t\t\tnextId = nextReference.getResource().getIdElement();\n+\t\t}\n+\n+\t\ttheParams.myPopulatedResourceLinkParameters.add(thePathAndRef.getSearchParamName());\n+\n+\t\tboolean canonical = thePathAndRef.isCanonical();\n+\t\tif (LogicalReferenceHelper.isLogicalReference(myModelConfig, nextId) || canonical) {\n+\t\t\tString value = nextId.getValue();\n+\t\t\tResourceLink resourceLink = ResourceLink.forLogicalReference(thePathAndRef.getPath(), theEntity, value, theUpdateTime);\n+\t\t\tif (theParams.myLinks.add(resourceLink)) {\n+\t\t\t\tourLog.debug(\"Indexing remote resource reference URL: {}\", nextId);\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tString baseUrl = nextId.getBaseUrl();\n+\t\tString typeString = nextId.getResourceType();\n+\t\tif (isBlank(typeString)) {\n+\t\t\tString msg = \"Invalid resource reference found at path[\" + path + \"] - Does not contain resource type - \" + nextId.getValue();\n+\t\t\tif (theFailOnInvalidReference) {\n+\t\t\t\tthrow new InvalidRequestException(msg);\n+\t\t\t} else {\n+\t\t\t\tourLog.debug(msg);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tRuntimeResourceDefinition resourceDefinition;\n+\t\ttry {\n+\t\t\tresourceDefinition = myContext.getResourceDefinition(typeString);\n+\t\t} catch (DataFormatException e) {\n+\t\t\tString msg = \"Invalid resource reference found at path[\" + path + \"] - Resource type is unknown or not supported on this server - \" + nextId.getValue();\n+\t\t\tif (theFailOnInvalidReference) {\n+\t\t\t\tthrow new InvalidRequestException(msg);\n+\t\t\t} else {\n+\t\t\t\tourLog.debug(msg);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (theRuntimeSearchParam.hasTargets()) {\n+\t\t\tif (!theRuntimeSearchParam.getTargets().contains(typeString)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (isNotBlank(baseUrl)) {\n+\t\t\tif (!myModelConfig.getTreatBaseUrlsAsLocal().contains(baseUrl) && !myModelConfig.isAllowExternalReferences()) {\n+\t\t\t\tString msg = myContext.getLocalizer().getMessage(BaseSearchParamExtractor.class, \"externalReferenceNotAllowed\", nextId.getValue());\n+\t\t\t\tthrow new InvalidRequestException(msg);\n+\t\t\t} else {\n+\t\t\t\tResourceLink resourceLink = ResourceLink.forAbsoluteReference(thePathAndRef.getPath(), theEntity, nextId, theUpdateTime);\n+\t\t\t\tif (theParams.myLinks.add(resourceLink)) {\n+\t\t\t\t\tourLog.debug(\"Indexing remote resource reference URL: {}\", nextId);\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\tClass<? extends IBaseResource> type = resourceDefinition.getImplementingClass();\n+\t\tString id = nextId.getIdPart();\n+\t\tif (StringUtils.isBlank(id)) {\n+\t\t\tString msg = \"Invalid resource reference found at path[\" + path + \"] - Does not contain resource ID - \" + nextId.getValue();\n+\t\t\tif (theFailOnInvalidReference) {\n+\t\t\t\tthrow new InvalidRequestException(msg);\n+\t\t\t} else {\n+\t\t\t\tourLog.debug(msg);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\ttheResourceLinkResolver.validateTypeOrThrowException(type);\n+\t\tResourceLink resourceLink = createResourceLink(theEntity, theUpdateTime, theResourceLinkResolver, theRuntimeSearchParam, path, thePathAndRef, nextId, typeString, type, nextReference, theRequest, theResourceIdToResolvedTarget);\n+\t\tif (resourceLink == null) {\n+\t\t\treturn;\n+\t\t}\n+\t\ttheParams.myLinks.add(resourceLink);", "originalCommit": "2bf30a98003d7d08d933823b673fbe0382cf44e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwNTY1OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408505658", "bodyText": "This class is actually not going away.. I did some cleanup to turn two redundant services into one so that I wouldn't have to fix this bug in 2 places.\nI'm gonna reorganize a bit to make it more readable.", "author": "jamesagnew", "createdAt": "2020-04-15T00:06:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4NjQ3Mg=="}], "type": "inlineReview"}, {"oid": "36311a86d5019cb451fa90262b671c61bc60cb9b", "url": "https://github.com/hapifhir/hapi-fhir/commit/36311a86d5019cb451fa90262b671c61bc60cb9b", "message": "Cleanup", "committedDate": "2020-04-15T00:14:16Z", "type": "commit"}, {"oid": "797c7ffb0bc3b9d65cbed5cf6f748e643507316e", "url": "https://github.com/hapifhir/hapi-fhir/commit/797c7ffb0bc3b9d65cbed5cf6f748e643507316e", "message": "Test fix", "committedDate": "2020-04-15T12:30:30Z", "type": "commit"}, {"oid": "e26884a84980fabdf9d4b58d712b4d9b9373f1cc", "url": "https://github.com/hapifhir/hapi-fhir/commit/e26884a84980fabdf9d4b58d712b4d9b9373f1cc", "message": "Test fix", "committedDate": "2020-04-15T16:37:53Z", "type": "commit"}, {"oid": "5090c2902f09b72ca43f72c8edf586bc599a63e7", "url": "https://github.com/hapifhir/hapi-fhir/commit/5090c2902f09b72ca43f72c8edf586bc599a63e7", "message": "One more test fix", "committedDate": "2020-04-15T17:22:04Z", "type": "commit"}]}