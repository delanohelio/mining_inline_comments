{"pr_number": 2149, "pr_title": "#2148 Initial implementation", "pr_createdAt": "2020-10-27T19:55:02Z", "pr_url": "https://github.com/hapifhir/hapi-fhir/pull/2149", "timeline": [{"oid": "170cf245cccddbf8cab357bd5e789d83d4b2c483", "url": "https://github.com/hapifhir/hapi-fhir/commit/170cf245cccddbf8cab357bd5e789d83d4b2c483", "message": "#2184 Initial implementation", "committedDate": "2020-10-27T19:50:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3ODg0Nw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513478847", "bodyText": "@fil512 What do you think about this implementation of converting match status -> MatchGrade? Since we are being forced to use these matchgrades here in the $match operation, how should these map to our internal assurance levels?", "author": "tadgh", "createdAt": "2020-10-28T14:16:18Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderR4.java", "diffHunk": "@@ -74,25 +79,50 @@ public EmpiProviderR4(FhirContext theFhirContext, IEmpiControllerSvc theEmpiCont\n \t}\n \n \t@Operation(name = ProviderConstants.EMPI_MATCH, type = Patient.class)\n-\tpublic Bundle match(@OperationParam(name=ProviderConstants.EMPI_MATCH_RESOURCE, min = 1, max = 1) Patient thePatient) {\n+\tpublic Bundle match(@OperationParam(name = ProviderConstants.EMPI_MATCH_RESOURCE, min = 1, max = 1) Patient thePatient) {\n \t\tif (thePatient == null) {\n \t\t\tthrow new InvalidRequestException(\"resource may not be null\");\n \t\t}\n \n-\t\tCollection<IAnyResource> matches = myEmpiMatchFinderSvc.findMatches(\"Patient\", thePatient);\n+\t\tList<MatchedTarget> matches = myEmpiMatchFinderSvc.getMatchedTargets(\"Patient\", thePatient);\n \n \t\tBundle retVal = new Bundle();\n \t\tretVal.setType(Bundle.BundleType.SEARCHSET);\n \t\tretVal.setId(UUID.randomUUID().toString());\n \t\tretVal.getMeta().setLastUpdatedElement(InstantType.now());\n \n-\t\tfor (IAnyResource next : matches) {\n-\t\t\tretVal.addEntry().setResource((Resource) next);\n+\t\tfor (MatchedTarget next : matches) {\n+\t\t\tboolean shouldKeepThisEntry = next.isMatch() || next.isPossibleMatch();\n+\t\t\tif (!shouldKeepThisEntry) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBundle.BundleEntryComponent entry = new Bundle.BundleEntryComponent();\n+\t\t\tentry.setResource((Resource) next.getTarget());\n+\t\t\tentry.setSearch(toBundleEntrySearchComponent(next));\n+\n+\t\t\tretVal.addEntry(entry);\n \t\t}\n \n \t\treturn retVal;\n \t}\n \n+\tprivate Bundle.BundleEntrySearchComponent toBundleEntrySearchComponent(MatchedTarget next) {\n+\t\tBundle.BundleEntrySearchComponent searchComponent = new Bundle.BundleEntrySearchComponent();\n+\t\tsearchComponent.setMode(Bundle.SearchEntryMode.MATCH);\n+\t\tsearchComponent.setScore(next.getMatchResult().getNormalizedScore());\n+\n+\t\tMatchGrade matchGrade = MatchGrade.PROBABLE;\n+\t\tif (next.isMatch()) {\n+\t\t\tmatchGrade = MatchGrade.CERTAIN;\n+\t\t} else if (next.isPossibleMatch()) {\n+\t\t\tmatchGrade = MatchGrade.POSSIBLE;\n+\t\t}\n+\t\tsearchComponent.addExtension(\"http://hl7.org/fhir/StructureDefinition/match-grade\",\n+\t\t\tnew CodeType(matchGrade.toCode()));\n+\t\treturn searchComponent;\n+\t}\n+", "originalCommit": "170cf245cccddbf8cab357bd5e789d83d4b2c483", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3MzY1MQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513573651", "bodyText": "It looks like he implemented the mapping I requested", "author": "fil512", "createdAt": "2020-10-28T16:11:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3ODg0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MTQyOA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513481428", "bodyText": "Are we certain these are ordered in terms of descending score? It looks to me as though these are just in returned order. The spec says: The response from an MPI $match operation is a set of patient records, ordered from most likely to least likely. . Can we add a test to prove this is the case? And if it isn't the case, add a sort to the list before returning? This can easily be done via a stream comparator before return", "author": "tadgh", "createdAt": "2020-10-28T14:19:40Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderDstu3.java", "diffHunk": "@@ -77,20 +81,45 @@ public Bundle match(@OperationParam(name=ProviderConstants.EMPI_MATCH_RESOURCE,\n \t\tif (thePatient == null) {\n \t\t\tthrow new InvalidRequestException(\"resource may not be null\");\n \t\t}\n-\t\tCollection<IAnyResource> matches = myEmpiMatchFinderSvc.findMatches(\"Patient\", thePatient);\n+\t\tList<MatchedTarget> matches = myEmpiMatchFinderSvc.getMatchedTargets(\"Patient\", thePatient);\n \n \t\tBundle retVal = new Bundle();\n \t\tretVal.setType(Bundle.BundleType.SEARCHSET);\n \t\tretVal.setId(UUID.randomUUID().toString());\n \t\tretVal.getMeta().setLastUpdatedElement(InstantType.now());\n \n-\t\tfor (IAnyResource next : matches) {\n-\t\t\tretVal.addEntry().setResource((Resource) next);\n+\t\tfor (MatchedTarget next : matches) {\n+\t\t\tboolean shouldKeepThisEntry = next.isMatch() || next.isPossibleMatch();\n+\t\t\tif (!shouldKeepThisEntry) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBundle.BundleEntryComponent entry = new Bundle.BundleEntryComponent();\n+\t\t\tentry.setResource((Resource) next.getTarget());\n+\t\t\tentry.setSearch(toBundleEntrySearchComponent(next));\n+\n+\t\t\tretVal.addEntry(entry);\n \t\t}\n \n \t\treturn retVal;", "originalCommit": "170cf245cccddbf8cab357bd5e789d83d4b2c483", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY5NzE1Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513697153", "bodyText": "Great catch, thank you, added sorting to the matched items", "author": "nvg-smile", "createdAt": "2020-10-28T19:12:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MTQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4Mjc4OQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513482789", "bodyText": "next is generally innapropriate unless it is directly involved in a loop. Since this is a helper function, i think a name like theMatchedTarget is better. Also, note the convention for naming of the hapi-fhir repository. Method params are prefixed with the, member variables are my, and static variables are our", "author": "tadgh", "createdAt": "2020-10-28T14:21:20Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderDstu3.java", "diffHunk": "@@ -77,20 +81,45 @@ public Bundle match(@OperationParam(name=ProviderConstants.EMPI_MATCH_RESOURCE,\n \t\tif (thePatient == null) {\n \t\t\tthrow new InvalidRequestException(\"resource may not be null\");\n \t\t}\n-\t\tCollection<IAnyResource> matches = myEmpiMatchFinderSvc.findMatches(\"Patient\", thePatient);\n+\t\tList<MatchedTarget> matches = myEmpiMatchFinderSvc.getMatchedTargets(\"Patient\", thePatient);\n \n \t\tBundle retVal = new Bundle();\n \t\tretVal.setType(Bundle.BundleType.SEARCHSET);\n \t\tretVal.setId(UUID.randomUUID().toString());\n \t\tretVal.getMeta().setLastUpdatedElement(InstantType.now());\n \n-\t\tfor (IAnyResource next : matches) {\n-\t\t\tretVal.addEntry().setResource((Resource) next);\n+\t\tfor (MatchedTarget next : matches) {\n+\t\t\tboolean shouldKeepThisEntry = next.isMatch() || next.isPossibleMatch();\n+\t\t\tif (!shouldKeepThisEntry) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBundle.BundleEntryComponent entry = new Bundle.BundleEntryComponent();\n+\t\t\tentry.setResource((Resource) next.getTarget());\n+\t\t\tentry.setSearch(toBundleEntrySearchComponent(next));\n+\n+\t\t\tretVal.addEntry(entry);\n \t\t}\n \n \t\treturn retVal;\n \t}\n \n+\tprivate Bundle.BundleEntrySearchComponent toBundleEntrySearchComponent(MatchedTarget next) {", "originalCommit": "170cf245cccddbf8cab357bd5e789d83d4b2c483", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY5NzI1MA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513697250", "bodyText": "Fixed, thank you for pointing out", "author": "nvg-smile", "createdAt": "2020-10-28T19:12:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4Mjc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MzIxNA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513483214", "bodyText": "This String should be ripped into a server constant and reused across both implementations", "author": "tadgh", "createdAt": "2020-10-28T14:21:50Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderR4.java", "diffHunk": "@@ -74,25 +79,50 @@ public EmpiProviderR4(FhirContext theFhirContext, IEmpiControllerSvc theEmpiCont\n \t}\n \n \t@Operation(name = ProviderConstants.EMPI_MATCH, type = Patient.class)\n-\tpublic Bundle match(@OperationParam(name=ProviderConstants.EMPI_MATCH_RESOURCE, min = 1, max = 1) Patient thePatient) {\n+\tpublic Bundle match(@OperationParam(name = ProviderConstants.EMPI_MATCH_RESOURCE, min = 1, max = 1) Patient thePatient) {\n \t\tif (thePatient == null) {\n \t\t\tthrow new InvalidRequestException(\"resource may not be null\");\n \t\t}\n \n-\t\tCollection<IAnyResource> matches = myEmpiMatchFinderSvc.findMatches(\"Patient\", thePatient);\n+\t\tList<MatchedTarget> matches = myEmpiMatchFinderSvc.getMatchedTargets(\"Patient\", thePatient);\n \n \t\tBundle retVal = new Bundle();\n \t\tretVal.setType(Bundle.BundleType.SEARCHSET);\n \t\tretVal.setId(UUID.randomUUID().toString());\n \t\tretVal.getMeta().setLastUpdatedElement(InstantType.now());\n \n-\t\tfor (IAnyResource next : matches) {\n-\t\t\tretVal.addEntry().setResource((Resource) next);\n+\t\tfor (MatchedTarget next : matches) {\n+\t\t\tboolean shouldKeepThisEntry = next.isMatch() || next.isPossibleMatch();\n+\t\t\tif (!shouldKeepThisEntry) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBundle.BundleEntryComponent entry = new Bundle.BundleEntryComponent();\n+\t\t\tentry.setResource((Resource) next.getTarget());\n+\t\t\tentry.setSearch(toBundleEntrySearchComponent(next));\n+\n+\t\t\tretVal.addEntry(entry);\n \t\t}\n \n \t\treturn retVal;\n \t}\n \n+\tprivate Bundle.BundleEntrySearchComponent toBundleEntrySearchComponent(MatchedTarget next) {\n+\t\tBundle.BundleEntrySearchComponent searchComponent = new Bundle.BundleEntrySearchComponent();\n+\t\tsearchComponent.setMode(Bundle.SearchEntryMode.MATCH);\n+\t\tsearchComponent.setScore(next.getMatchResult().getNormalizedScore());\n+\n+\t\tMatchGrade matchGrade = MatchGrade.PROBABLE;\n+\t\tif (next.isMatch()) {\n+\t\t\tmatchGrade = MatchGrade.CERTAIN;\n+\t\t} else if (next.isPossibleMatch()) {\n+\t\t\tmatchGrade = MatchGrade.POSSIBLE;\n+\t\t}\n+\t\tsearchComponent.addExtension(\"http://hl7.org/fhir/StructureDefinition/match-grade\",", "originalCommit": "170cf245cccddbf8cab357bd5e789d83d4b2c483", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY5NzMyNw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513697327", "bodyText": "Done, thank you", "author": "nvg-smile", "createdAt": "2020-10-28T19:12:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MzIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4Mzc5MQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513483791", "bodyText": "@fil512 Would appreciate your input on this as well. I think this is correct for normalization, but this needs your eyes on it.", "author": "tadgh", "createdAt": "2020-10-28T14:22:34Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/api/EmpiMatchOutcome.java", "diffHunk": "@@ -105,6 +105,21 @@ public EmpiMatchOutcome setEidMatch(boolean theEidMatch) {\n \t\treturn this;\n \t}\n \n+\t/**\n+\t * Gets normalized score that is in the range from zero to one\n+\t *\n+\t * @return\n+\t * \tReturns the normalized score\n+\t */\n+\tpublic Double getNormalizedScore() {\n+\t\tif (vector == 0) {\n+\t\t\treturn 0.0;\n+\t\t} else if (score > vector) {\n+\t\t\treturn 1.0;\n+\t\t}\n+\t\treturn score / vector;\n+\t}\n+", "originalCommit": "170cf245cccddbf8cab357bd5e789d83d4b2c483", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3NDA3NA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513574074", "bodyText": "Nick also checked with me on this ahead of time and it looks like the best option to me", "author": "fil512", "createdAt": "2020-10-28T16:11:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4Mzc5MQ=="}], "type": "inlineReview"}, {"oid": "954fbf054ff36efc99b11fa107555a2e2da788e7", "url": "https://github.com/hapifhir/hapi-fhir/commit/954fbf054ff36efc99b11fa107555a2e2da788e7", "message": "Fixed implementation based on the feedback.", "committedDate": "2020-10-28T19:09:15Z", "type": "commit"}]}