{"pr_number": 1802, "pr_title": "Improve search method binding priority", "pr_createdAt": "2020-04-15T22:01:43Z", "pr_url": "https://github.com/hapifhir/hapi-fhir/pull/1802", "timeline": [{"oid": "10b450bbe8f0d900623ec82b48cdf6097b80b819", "url": "https://github.com/hapifhir/hapi-fhir/commit/10b450bbe8f0d900623ec82b48cdf6097b80b819", "message": "Work on search method binding priority", "committedDate": "2020-04-15T11:48:52Z", "type": "commit"}, {"oid": "768d6ff00a48d40114876878f359ca49fb5b584d", "url": "https://github.com/hapifhir/hapi-fhir/commit/768d6ff00a48d40114876878f359ca49fb5b584d", "message": "Work on method priority", "committedDate": "2020-04-15T15:34:01Z", "type": "commit"}, {"oid": "47fa2dea80d4fd8db012ff4cbc74232f135d1d66", "url": "https://github.com/hapifhir/hapi-fhir/commit/47fa2dea80d4fd8db012ff4cbc74232f135d1d66", "message": "Work on binding priority", "committedDate": "2020-04-15T18:02:16Z", "type": "commit"}, {"oid": "438d7705a061898c283a78b1cd157552a37ee753", "url": "https://github.com/hapifhir/hapi-fhir/commit/438d7705a061898c283a78b1cd157552a37ee753", "message": "Test fixes", "committedDate": "2020-04-15T19:59:39Z", "type": "commit"}, {"oid": "a316143ddf88cd3153ccec81c77a45d3b7faea89", "url": "https://github.com/hapifhir/hapi-fhir/commit/a316143ddf88cd3153ccec81c77a45d3b7faea89", "message": "Add changelog", "committedDate": "2020-04-15T22:05:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE2ODc3Nw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409168777", "bodyText": "remove FIXME :-)", "author": "fil512", "createdAt": "2020-04-15T22:22:18Z", "path": "hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/method/SearchMethodBinding.java", "diffHunk": "@@ -129,114 +141,215 @@ public ReturnTypeEnum getReturnType() {\n \t}\n \n \t@Override\n-\tpublic boolean incomingServerRequestMatchesMethod(RequestDetails theRequest) {\n+\tpublic MethodMatchEnum incomingServerRequestMatchesMethod(RequestDetails theRequest) {\n \n \t\tif (theRequest.getId() != null && myIdParamIndex == null) {\n \t\t\tourLog.trace(\"Method {} doesn't match because ID is not null: {}\", getMethod(), theRequest.getId());\n-\t\t\treturn false;\n+\t\t\treturn MethodMatchEnum.NONE;\n \t\t}\n \t\tif (theRequest.getRequestType() == RequestTypeEnum.GET && theRequest.getOperation() != null && !Constants.PARAM_SEARCH.equals(theRequest.getOperation())) {\n \t\t\tourLog.trace(\"Method {} doesn't match because request type is GET but operation is not null: {}\", theRequest.getId(), theRequest.getOperation());\n-\t\t\treturn false;\n+\t\t\treturn MethodMatchEnum.NONE;\n \t\t}\n \t\tif (theRequest.getRequestType() == RequestTypeEnum.POST && !Constants.PARAM_SEARCH.equals(theRequest.getOperation())) {\n \t\t\tourLog.trace(\"Method {} doesn't match because request type is POST but operation is not _search: {}\", theRequest.getId(), theRequest.getOperation());\n-\t\t\treturn false;\n+\t\t\treturn MethodMatchEnum.NONE;\n \t\t}\n \t\tif (theRequest.getRequestType() != RequestTypeEnum.GET && theRequest.getRequestType() != RequestTypeEnum.POST) {\n \t\t\tourLog.trace(\"Method {} doesn't match because request type is {}\", getMethod(), theRequest.getRequestType());\n-\t\t\treturn false;\n+\t\t\treturn MethodMatchEnum.NONE;\n \t\t}\n \t\tif (!StringUtils.equals(myCompartmentName, theRequest.getCompartmentName())) {\n \t\t\tourLog.trace(\"Method {} doesn't match because it is for compartment {} but request is compartment {}\", getMethod(), myCompartmentName, theRequest.getCompartmentName());\n-\t\t\treturn false;\n+\t\t\treturn MethodMatchEnum.NONE;\n \t\t}\n \t\tif (theRequest.getParameters().get(Constants.PARAM_PAGINGACTION) != null) {\n-\t\t\treturn false;\n+\t\t\treturn MethodMatchEnum.NONE;\n \t\t}\n \n-\t\t// This is used to track all the parameters so we can reject queries that\n-\t\t// have additional params we don't understand\n-\t\tSet<String> methodParamsTemp = new HashSet<>();\n-\n-\t\tSet<String> unqualifiedNames = theRequest.getUnqualifiedToQualifiedNames().keySet();\n-\t\tSet<String> qualifiedParamNames = theRequest.getParameters().keySet();\n-\t\tfor (IParameter nextParameter : getParameters()) {\n-\t\t\tif (!(nextParameter instanceof BaseQueryParameter)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tBaseQueryParameter nextQueryParameter = (BaseQueryParameter) nextParameter;\n-\t\t\tString name = nextQueryParameter.getName();\n-\t\t\tif (nextQueryParameter.isRequired()) {\n-\n-\t\t\t\tif (qualifiedParamNames.contains(name)) {\n-\t\t\t\t\tQualifierDetails qualifiers = extractQualifiersFromParameterName(name);\n-\t\t\t\t\tif (qualifiers.passes(nextQueryParameter.getQualifierWhitelist(), nextQueryParameter.getQualifierBlacklist())) {\n-\t\t\t\t\t\tmethodParamsTemp.add(name);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (unqualifiedNames.contains(name)) {\n-\t\t\t\t\tList<String> qualifiedNames = theRequest.getUnqualifiedToQualifiedNames().get(name);\n-\t\t\t\t\tqualifiedNames = processWhitelistAndBlacklist(qualifiedNames, nextQueryParameter.getQualifierWhitelist(), nextQueryParameter.getQualifierBlacklist());\n-\t\t\t\t\tmethodParamsTemp.addAll(qualifiedNames);\n-\t\t\t\t}\n-\t\t\t\tif (!qualifiedParamNames.contains(name) && !unqualifiedNames.contains(name)) {\n-\t\t\t\t\tourLog.trace(\"Method {} doesn't match param '{}' is not present\", getMethod().getName(), name);\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\n-\t\t\t} else {\n-\t\t\t\tif (qualifiedParamNames.contains(name)) {\n-\t\t\t\t\tQualifierDetails qualifiers = extractQualifiersFromParameterName(name);\n-\t\t\t\t\tif (qualifiers.passes(nextQueryParameter.getQualifierWhitelist(), nextQueryParameter.getQualifierBlacklist())) {\n-\t\t\t\t\t\tmethodParamsTemp.add(name);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (unqualifiedNames.contains(name)) {\n-\t\t\t\t\tList<String> qualifiedNames = theRequest.getUnqualifiedToQualifiedNames().get(name);\n-\t\t\t\t\tqualifiedNames = processWhitelistAndBlacklist(qualifiedNames, nextQueryParameter.getQualifierWhitelist(), nextQueryParameter.getQualifierBlacklist());\n-\t\t\t\t\tmethodParamsTemp.addAll(qualifiedNames);\n-\t\t\t\t}\n-\t\t\t\tif (!qualifiedParamNames.contains(name)) {\n-\t\t\t\t\tmethodParamsTemp.add(name);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n \t\tif (myQueryName != null) {\n \t\t\tString[] queryNameValues = theRequest.getParameters().get(Constants.PARAM_QUERY);\n \t\t\tif (queryNameValues != null && StringUtils.isNotBlank(queryNameValues[0])) {\n \t\t\t\tString queryName = queryNameValues[0];\n \t\t\t\tif (!myQueryName.equals(queryName)) {\n \t\t\t\t\tourLog.trace(\"Query name does not match {}\", myQueryName);\n-\t\t\t\t\treturn false;\n+\t\t\t\t\treturn MethodMatchEnum.NONE;\n \t\t\t\t}\n-\t\t\t\tmethodParamsTemp.add(Constants.PARAM_QUERY);\n \t\t\t} else {\n \t\t\t\tourLog.trace(\"Query name does not match {}\", myQueryName);\n-\t\t\t\treturn false;\n+\t\t\t\treturn MethodMatchEnum.NONE;\n \t\t\t}\n \t\t} else {\n \t\t\tString[] queryNameValues = theRequest.getParameters().get(Constants.PARAM_QUERY);\n \t\t\tif (queryNameValues != null && StringUtils.isNotBlank(queryNameValues[0])) {\n \t\t\t\tourLog.trace(\"Query has name\");\n-\t\t\t\treturn false;\n+\t\t\t\treturn MethodMatchEnum.NONE;\n \t\t\t}\n \t\t}\n-\t\tfor (String next : theRequest.getParameters().keySet()) {\n-\t\t\tif (next.startsWith(\"_\") && !SPECIAL_SEARCH_PARAMS.contains(truncModifierPart(next))) {\n-\t\t\t\tmethodParamsTemp.add(next);\n+\n+\t\tSet<String> unqualifiedNames = theRequest.getUnqualifiedToQualifiedNames().keySet();\n+\t\tSet<String> qualifiedParamNames = theRequest.getParameters().keySet();\n+\n+\t\tMethodMatchEnum retVal = MethodMatchEnum.PERFECT;\n+\t\tfor (String nextRequestParam : theRequest.getParameters().keySet()) {\n+\t\t\tif (nextRequestParam.startsWith(\"_\") && !SPECIAL_SEARCH_PARAMS.contains(truncModifierPart(nextRequestParam))) {\n+\t\t\t\tcontinue;\n \t\t\t}\n+\n+\t\t\tString nextUnqualifiedRequestParam = nextRequestParam;\n+\t\t\tfor (int i = 0; i < nextUnqualifiedRequestParam.length(); i++) {\n+\t\t\t\tchar nextChar = nextUnqualifiedRequestParam.charAt(i);\n+\t\t\t\tif (nextChar == ':' || nextChar == '.') {\n+\t\t\t\t\tnextUnqualifiedRequestParam = nextUnqualifiedRequestParam.substring(0, i);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tboolean parameterMatches = false;\n+\t\t\tboolean approx = false;\n+\t\t\tfor (BaseQueryParameter nextMethodParam : getQueryParameters()) {\n+\n+\t\t\t\tif (nextRequestParam.equals(nextMethodParam.getName())) {\n+\t\t\t\t\tQualifierDetails qualifiers = extractQualifiersFromParameterName(nextRequestParam);\n+\t\t\t\t\tif (qualifiers.passes(nextMethodParam.getQualifierWhitelist(), nextMethodParam.getQualifierBlacklist())) {\n+\t\t\t\t\t\tparameterMatches = true;\n+\t\t\t\t\t}\n+\t\t\t\t} else if (nextUnqualifiedRequestParam.equals(nextMethodParam.getName())) {\n+\t\t\t\t\tList<String> qualifiedNames = theRequest.getUnqualifiedToQualifiedNames().get(nextUnqualifiedRequestParam);\n+\t\t\t\t\tif (passesWhitelistAndBlacklist(qualifiedNames, nextMethodParam.getQualifierWhitelist(), nextMethodParam.getQualifierBlacklist())) {\n+\t\t\t\t\t\tparameterMatches = true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t// Repetitions supplied by URL but not supported by this parameter\n+\t\t\t\tif (theRequest.getParameters().get(nextRequestParam).length > 1 != nextMethodParam.supportsRepetition()) {\n+\t\t\t\t\tapprox = true;\n+\t\t\t\t}\n+\n+\t\t\t}\n+\n+\n+\t\t\tif (parameterMatches) {\n+\n+\t\t\t\tif (approx) {\n+\t\t\t\t\tretVal = retVal.weakerOf(MethodMatchEnum.APPROXIMATE);\n+\t\t\t\t}\n+\n+\t\t\t} else {\n+\n+\t\t\t\tif (myAllowUnknownParams) {\n+\t\t\t\t\tretVal = retVal.weakerOf(MethodMatchEnum.APPROXIMATE);\n+\t\t\t\t} else {\n+\t\t\t\t\tretVal = retVal.weakerOf(MethodMatchEnum.NONE);\n+\t\t\t\t}\n+\n+\t\t\t}\n+\n+\t\t\tif (retVal == MethodMatchEnum.NONE) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n \t\t}\n-\t\tSet<String> keySet = theRequest.getParameters().keySet();\n \n-\t\tif (myAllowUnknownParams == false) {\n-\t\t\tfor (String next : keySet) {\n-\t\t\t\tif (!methodParamsTemp.contains(next)) {\n-\t\t\t\t\treturn false;\n+\t\tif (retVal != MethodMatchEnum.NONE) {\n+\t\t\tfor (String nextRequiredParamName : myRequiredParamNames) {\n+\t\t\t\tif (!qualifiedParamNames.contains(nextRequiredParamName)) {\n+\t\t\t\t\tif (!unqualifiedNames.contains(nextRequiredParamName)) {\n+\t\t\t\t\t\tretVal = MethodMatchEnum.NONE;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\treturn true;\n+\n+\t\treturn retVal;\n+\n+\t\t// FIXME: remove", "originalCommit": "a316143ddf88cd3153ccec81c77a45d3b7faea89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU5MTk0MQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409591941", "bodyText": "Done", "author": "jamesagnew", "createdAt": "2020-04-16T14:16:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE2ODc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE2ODg5Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409168893", "bodyText": "remove FIXME :-)", "author": "fil512", "createdAt": "2020-04-15T22:22:38Z", "path": "hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/method/SearchMethodBinding.java", "diffHunk": "@@ -264,6 +377,8 @@ protected boolean isAddContentLocationHeader() {\n \t\treturn false;\n \t}\n \n+\n+\t// FIXME: remove", "originalCommit": "a316143ddf88cd3153ccec81c77a45d3b7faea89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQyODI4OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409428288", "bodyText": "done.... CI caught this too, woohoo!", "author": "jamesagnew", "createdAt": "2020-04-16T09:51:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE2ODg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE2OTk5Nw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409169997", "bodyText": "Wouldn't NumberParam and QuantityParam also support repetition?", "author": "fil512", "createdAt": "2020-04-15T22:25:36Z", "path": "hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/method/SearchParameter.java", "diffHunk": "@@ -248,42 +249,52 @@ public void setRequired(boolean required) {\n \t\tthis.myRequired = required;\n \t}\n \n+\t@Override\n+\tprotected boolean supportsRepetition() {\n+\t\treturn mySupportsRepetition;\n+\t}\n+\n \t@SuppressWarnings(\"unchecked\")\n-\tpublic void setType(FhirContext theContext, final Class<?> type, Class<? extends Collection<?>> theInnerCollectionType, Class<? extends Collection<?>> theOuterCollectionType) {\n+\tpublic void setType(FhirContext theContext, final Class<?> theType, Class<? extends Collection<?>> theInnerCollectionType, Class<? extends Collection<?>> theOuterCollectionType) {\n \n \t\t\n-\t\tthis.myType = type;\n-\t\tif (IQueryParameterType.class.isAssignableFrom(type)) {\n-\t\t\tmyParamBinder = new QueryParameterTypeBinder((Class<? extends IQueryParameterType>) type, myCompositeTypes);\n-\t\t} else if (IQueryParameterOr.class.isAssignableFrom(type)) {\n-\t\t\tmyParamBinder = new QueryParameterOrBinder((Class<? extends IQueryParameterOr<?>>) type, myCompositeTypes);\n-\t\t} else if (IQueryParameterAnd.class.isAssignableFrom(type)) {\n-\t\t\tmyParamBinder = new QueryParameterAndBinder((Class<? extends IQueryParameterAnd<?>>) type, myCompositeTypes);\n-\t\t} else if (String.class.equals(type)) {\n+\t\tthis.myType = theType;\n+\t\tif (IQueryParameterType.class.isAssignableFrom(theType)) {\n+\t\t\tmyParamBinder = new QueryParameterTypeBinder((Class<? extends IQueryParameterType>) theType, myCompositeTypes);\n+\t\t} else if (IQueryParameterOr.class.isAssignableFrom(theType)) {\n+\t\t\tmyParamBinder = new QueryParameterOrBinder((Class<? extends IQueryParameterOr<?>>) theType, myCompositeTypes);\n+\t\t} else if (IQueryParameterAnd.class.isAssignableFrom(theType)) {\n+\t\t\tmyParamBinder = new QueryParameterAndBinder((Class<? extends IQueryParameterAnd<?>>) theType, myCompositeTypes);\n+\t\t\tmySupportsRepetition = true;\n+\t\t} else if (String.class.equals(theType)) {\n \t\t\tmyParamBinder = new StringBinder();\n \t\t\tmyParamType = RestSearchParameterTypeEnum.STRING;\n-\t\t} else if (Date.class.equals(type)) {\n+\t\t} else if (Date.class.equals(theType)) {\n \t\t\tmyParamBinder = new DateBinder();\n \t\t\tmyParamType = RestSearchParameterTypeEnum.DATE;\n-\t\t} else if (Calendar.class.equals(type)) {\n+\t\t} else if (Calendar.class.equals(theType)) {\n \t\t\tmyParamBinder = new CalendarBinder();\n \t\t\tmyParamType = RestSearchParameterTypeEnum.DATE;\n-\t\t} else if (IPrimitiveType.class.isAssignableFrom(type) && ReflectionUtil.isInstantiable(type)) {\n-\t\t\tRuntimePrimitiveDatatypeDefinition def = (RuntimePrimitiveDatatypeDefinition) theContext.getElementDefinition((Class<? extends IPrimitiveType<?>>) type);\n+\t\t} else if (IPrimitiveType.class.isAssignableFrom(theType) && ReflectionUtil.isInstantiable(theType)) {\n+\t\t\tRuntimePrimitiveDatatypeDefinition def = (RuntimePrimitiveDatatypeDefinition) theContext.getElementDefinition((Class<? extends IPrimitiveType<?>>) theType);\n \t\t\tif (def.getNativeType() != null) {\n \t\t\t\tif (def.getNativeType().equals(Date.class)) {\n-\t\t\t\t\tmyParamBinder = new FhirPrimitiveBinder((Class<IPrimitiveType<?>>) type);\n+\t\t\t\t\tmyParamBinder = new FhirPrimitiveBinder((Class<IPrimitiveType<?>>) theType);\n \t\t\t\t\tmyParamType = RestSearchParameterTypeEnum.DATE;\n \t\t\t\t} else if (def.getNativeType().equals(String.class)) {\n-\t\t\t\t\tmyParamBinder = new FhirPrimitiveBinder((Class<IPrimitiveType<?>>) type);\n+\t\t\t\t\tmyParamBinder = new FhirPrimitiveBinder((Class<IPrimitiveType<?>>) theType);\n \t\t\t\t\tmyParamType = RestSearchParameterTypeEnum.STRING;\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n-\t\t\tthrow new ConfigurationException(\"Unsupported data type for parameter: \" + type.getCanonicalName());\n+\t\t\tthrow new ConfigurationException(\"Unsupported data theType for parameter: \" + theType.getCanonicalName());\n+\t\t}\n+\n+\t\tif (DateRangeParam.class.isAssignableFrom(theType)) {", "originalCommit": "a316143ddf88cd3153ccec81c77a45d3b7faea89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3MDMxNw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409170317", "bodyText": "Consider changing to:\nif (theType.supportsRepetition())", "author": "fil512", "createdAt": "2020-04-15T22:26:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE2OTk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU5NTI4Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409595283", "bodyText": "Good call, DateRangeParam is kind of the outlier, have added tests to show that regular \"AndParamXXX\" types work too.", "author": "jamesagnew", "createdAt": "2020-04-16T14:20:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE2OTk5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3MDcxOA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409170718", "bodyText": "Is EXACT more descriptive than PERFECT?", "author": "fil512", "createdAt": "2020-04-15T22:27:41Z", "path": "hapi-fhir-server/src/test/java/ca/uhn/fhir/rest/server/method/MethodMatchEnumTest.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package ca.uhn.fhir.rest.server.method;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.*;\n+\n+public class MethodMatchEnumTest {\n+\n+\t@Test\n+\tpublic void testOrder() {\n+\t\tassertEquals(0, MethodMatchEnum.NONE.ordinal());\n+\t\tassertEquals(1, MethodMatchEnum.APPROXIMATE.ordinal());\n+\t\tassertEquals(2, MethodMatchEnum.PERFECT.ordinal());", "originalCommit": "a316143ddf88cd3153ccec81c77a45d3b7faea89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQzMzAzOQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409433039", "bodyText": "Yeah, that is better.. changing", "author": "jamesagnew", "createdAt": "2020-04-16T09:58:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3MDcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3MTAxMQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409171011", "bodyText": ":-) :-)", "author": "fil512", "createdAt": "2020-04-15T22:28:28Z", "path": "hapi-fhir-structures-r4/src/test/java/ca/uhn/fhir/rest/server/SearchDateParamPriorityTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package ca.uhn.fhir.rest.server;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.rest.annotation.RequiredParam;\n+import ca.uhn.fhir.rest.annotation.Search;\n+import ca.uhn.fhir.rest.client.api.IGenericClient;\n+import ca.uhn.fhir.rest.param.DateParam;\n+import ca.uhn.fhir.rest.param.DateRangeParam;\n+import ca.uhn.fhir.test.utilities.server.RestfulServerRule;\n+import com.google.common.collect.Lists;\n+import org.hl7.fhir.r4.model.Bundle;\n+import org.hl7.fhir.r4.model.Patient;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class SearchDateParamPriorityTest {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(SearchDateParamPriorityTest.class);\n+\n+\tprivate static FhirContext ourCtx = FhirContext.forR4();\n+\n+\t@ClassRule\n+\tpublic static RestfulServerRule ourServerRule = new RestfulServerRule(ourCtx);", "originalCommit": "a316143ddf88cd3153ccec81c77a45d3b7faea89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQxMjM0Mg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409412342", "bodyText": "I am so in love with this approach now.....", "author": "jamesagnew", "createdAt": "2020-04-16T09:25:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3MTAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3MTQwOQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409171409", "bodyText": "Can we add an unregisterAllProviders() method to RestfulServer?", "author": "fil512", "createdAt": "2020-04-15T22:29:22Z", "path": "hapi-fhir-structures-r4/src/test/java/ca/uhn/fhir/rest/server/SearchDateParamPriorityTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package ca.uhn.fhir.rest.server;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.rest.annotation.RequiredParam;\n+import ca.uhn.fhir.rest.annotation.Search;\n+import ca.uhn.fhir.rest.client.api.IGenericClient;\n+import ca.uhn.fhir.rest.param.DateParam;\n+import ca.uhn.fhir.rest.param.DateRangeParam;\n+import ca.uhn.fhir.test.utilities.server.RestfulServerRule;\n+import com.google.common.collect.Lists;\n+import org.hl7.fhir.r4.model.Bundle;\n+import org.hl7.fhir.r4.model.Patient;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class SearchDateParamPriorityTest {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(SearchDateParamPriorityTest.class);\n+\n+\tprivate static FhirContext ourCtx = FhirContext.forR4();\n+\n+\t@ClassRule\n+\tpublic static RestfulServerRule ourServerRule = new RestfulServerRule(ourCtx);\n+\tprivate String myLastMethod;\n+\n+\t@Before\n+\tpublic void before() {\n+\t\tmyLastMethod = null;\n+\t}\n+\n+\t@After\n+\tpublic void after() {\n+\t\twhile (ourServerRule.getRestfulServer().getResourceProviders().size() > 0) {\n+\t\t\tourServerRule.getRestfulServer().unregisterProvider(ourServerRule.getRestfulServer().getResourceProviders().iterator().next());", "originalCommit": "a316143ddf88cd3153ccec81c77a45d3b7faea89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQxMjYxNA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409412614", "bodyText": "Yeah I guess we could really. I'll do that.", "author": "jamesagnew", "createdAt": "2020-04-16T09:26:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3MTQwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3MjExNQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409172115", "bodyText": "This is a really beautiful test.", "author": "fil512", "createdAt": "2020-04-15T22:31:12Z", "path": "hapi-fhir-structures-r4/src/test/java/ca/uhn/fhir/rest/server/SearchDateParamPriorityTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package ca.uhn.fhir.rest.server;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.rest.annotation.RequiredParam;\n+import ca.uhn.fhir.rest.annotation.Search;\n+import ca.uhn.fhir.rest.client.api.IGenericClient;\n+import ca.uhn.fhir.rest.param.DateParam;\n+import ca.uhn.fhir.rest.param.DateRangeParam;\n+import ca.uhn.fhir.test.utilities.server.RestfulServerRule;\n+import com.google.common.collect.Lists;\n+import org.hl7.fhir.r4.model.Bundle;\n+import org.hl7.fhir.r4.model.Patient;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class SearchDateParamPriorityTest {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(SearchDateParamPriorityTest.class);\n+\n+\tprivate static FhirContext ourCtx = FhirContext.forR4();\n+\n+\t@ClassRule\n+\tpublic static RestfulServerRule ourServerRule = new RestfulServerRule(ourCtx);\n+\tprivate String myLastMethod;\n+\n+\t@Before\n+\tpublic void before() {\n+\t\tmyLastMethod = null;\n+\t}\n+\n+\t@After\n+\tpublic void after() {\n+\t\twhile (ourServerRule.getRestfulServer().getResourceProviders().size() > 0) {\n+\t\t\tourServerRule.getRestfulServer().unregisterProvider(ourServerRule.getRestfulServer().getResourceProviders().iterator().next());\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testDateRangeSelectedWhenMultipleParametersProvided() {\n+\t\tPatientResourceProvider provider = new PatientResourceProvider();\n+\t\tourServerRule.getRestfulServer().registerProviders(provider);\n+\n+\t\tIGenericClient client = ourServerRule.getFhirClient();\n+\t\tclient\n+\t\t\t.search()\n+\t\t\t.forResource(\"Patient\")\n+\t\t\t.where(Patient.BIRTHDATE.after().day(\"2001-01-01\"))\n+\t\t\t.and(Patient.BIRTHDATE.before().day(\"2002-01-01\"))\n+\t\t\t.returnBundle(Bundle.class)\n+\t\t\t.execute();\n+\n+\t\tassertEquals(\"findDateRangeParam\", myLastMethod);\n+\t}\n+\n+\t@Test\n+\tpublic void testDateRangeNotSelectedWhenSingleParameterProvided() {\n+\t\tPatientResourceProvider provider = new PatientResourceProvider();\n+\t\tourServerRule.getRestfulServer().registerProviders(provider);\n+\n+\t\tIGenericClient client = ourServerRule.getFhirClient();\n+\t\tclient\n+\t\t\t.search()\n+\t\t\t.forResource(\"Patient\")\n+\t\t\t.where(Patient.BIRTHDATE.after().day(\"2001-01-01\"))\n+\t\t\t.returnBundle(Bundle.class)\n+\t\t\t.execute();\n+\n+\t\tassertEquals(\"findDateParam\", myLastMethod);\n+\t}\n+\n+\t@Test\n+\tpublic void testEmptySearchProvidedWithNoParameters() {\n+\t\tPatientResourceProvider provider = new PatientResourceProvider();\n+\t\tourServerRule.getRestfulServer().registerProviders(provider);\n+\n+\t\tIGenericClient client = ourServerRule.getFhirClient();\n+\t\tclient\n+\t\t\t.search()\n+\t\t\t.forResource(\"Patient\")\n+\t\t\t.returnBundle(Bundle.class)\n+\t\t\t.execute();\n+\n+\t\tassertEquals(\"find\", myLastMethod);\n+\t}\n+\n+\tpublic class PatientResourceProvider implements IResourceProvider {", "originalCommit": "a316143ddf88cd3153ccec81c77a45d3b7faea89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQyNDE0OQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409424149", "bodyText": "Haha thanks", "author": "jamesagnew", "createdAt": "2020-04-16T09:44:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3MjExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3MjMxOQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409172319", "bodyText": "Throw the above two lines in a @before", "author": "fil512", "createdAt": "2020-04-15T22:31:49Z", "path": "hapi-fhir-structures-r4/src/test/java/ca/uhn/fhir/rest/server/SearchDateParamPriorityTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package ca.uhn.fhir.rest.server;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.rest.annotation.RequiredParam;\n+import ca.uhn.fhir.rest.annotation.Search;\n+import ca.uhn.fhir.rest.client.api.IGenericClient;\n+import ca.uhn.fhir.rest.param.DateParam;\n+import ca.uhn.fhir.rest.param.DateRangeParam;\n+import ca.uhn.fhir.test.utilities.server.RestfulServerRule;\n+import com.google.common.collect.Lists;\n+import org.hl7.fhir.r4.model.Bundle;\n+import org.hl7.fhir.r4.model.Patient;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class SearchDateParamPriorityTest {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(SearchDateParamPriorityTest.class);\n+\n+\tprivate static FhirContext ourCtx = FhirContext.forR4();\n+\n+\t@ClassRule\n+\tpublic static RestfulServerRule ourServerRule = new RestfulServerRule(ourCtx);\n+\tprivate String myLastMethod;\n+\n+\t@Before\n+\tpublic void before() {\n+\t\tmyLastMethod = null;\n+\t}\n+\n+\t@After\n+\tpublic void after() {\n+\t\twhile (ourServerRule.getRestfulServer().getResourceProviders().size() > 0) {\n+\t\t\tourServerRule.getRestfulServer().unregisterProvider(ourServerRule.getRestfulServer().getResourceProviders().iterator().next());\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testDateRangeSelectedWhenMultipleParametersProvided() {\n+\t\tPatientResourceProvider provider = new PatientResourceProvider();\n+\t\tourServerRule.getRestfulServer().registerProviders(provider);", "originalCommit": "a316143ddf88cd3153ccec81c77a45d3b7faea89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQyNDA1Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409424053", "bodyText": "Done", "author": "jamesagnew", "createdAt": "2020-04-16T09:44:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3MjMxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQyNzkyNA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409427924", "bodyText": "done", "author": "jamesagnew", "createdAt": "2020-04-16T09:50:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3MjMxOQ=="}], "type": "inlineReview"}, {"oid": "c683a949722fe20895a91419ed62fd3a41c2c707", "url": "https://github.com/hapifhir/hapi-fhir/commit/c683a949722fe20895a91419ed62fd3a41c2c707", "message": "Test fixes", "committedDate": "2020-04-16T12:55:10Z", "type": "commit"}, {"oid": "6ae1eb5465798e2c2965ceb94f70cb2f96455461", "url": "https://github.com/hapifhir/hapi-fhir/commit/6ae1eb5465798e2c2965ceb94f70cb2f96455461", "message": "Merge branch 'master' into ja_20200415_search_binding_priority", "committedDate": "2020-04-16T14:07:25Z", "type": "commit"}, {"oid": "63e9507f7c729c6a9822c5c618dfbae6751367d2", "url": "https://github.com/hapifhir/hapi-fhir/commit/63e9507f7c729c6a9822c5c618dfbae6751367d2", "message": "compile fix", "committedDate": "2020-04-16T14:12:02Z", "type": "commit"}, {"oid": "5ed8402fede0348644108fb537c9bf189bb51ad4", "url": "https://github.com/hapifhir/hapi-fhir/commit/5ed8402fede0348644108fb537c9bf189bb51ad4", "message": "One more comple fix", "committedDate": "2020-04-16T14:14:41Z", "type": "commit"}, {"oid": "24e25f11ff0f75525c80c4cca6e99a4dd980cd3b", "url": "https://github.com/hapifhir/hapi-fhir/commit/24e25f11ff0f75525c80c4cca6e99a4dd980cd3b", "message": "Test cleanup", "committedDate": "2020-04-16T14:19:43Z", "type": "commit"}, {"oid": "165ed75b04b718edb65130f7ffaa4906f4789cfe", "url": "https://github.com/hapifhir/hapi-fhir/commit/165ed75b04b718edb65130f7ffaa4906f4789cfe", "message": "Test fix", "committedDate": "2020-04-17T12:41:21Z", "type": "commit"}]}