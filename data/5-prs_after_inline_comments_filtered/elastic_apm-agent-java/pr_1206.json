{"pr_number": 1206, "pr_title": "Instrument Runnables/Callables instead of wrapping them", "pr_createdAt": "2020-05-27T15:06:04Z", "pr_url": "https://github.com/elastic/apm-agent-java/pull/1206", "timeline": [{"oid": "140d51c4ca910b5e79d1b9f42a0338c62df53445", "url": "https://github.com/elastic/apm-agent-java/commit/140d51c4ca910b5e79d1b9f42a0338c62df53445", "message": "Instrument Runnables/Callables instead of wrapping\n\ncloses #987", "committedDate": "2020-05-27T14:59:11Z", "type": "commit"}, {"oid": "c6095a7f0fe1290ef0611b2b4f3b4bb109f7d57a", "url": "https://github.com/elastic/apm-agent-java/commit/c6095a7f0fe1290ef0611b2b4f3b4bb109f7d57a", "message": "Add changelog", "committedDate": "2020-05-27T15:03:38Z", "type": "commit"}, {"oid": "2424cdc98f02f8f1a517ea7fc2bfd9263ab9ae67", "url": "https://github.com/elastic/apm-agent-java/commit/2424cdc98f02f8f1a517ea7fc2bfd9263ab9ae67", "message": "Instrument ExecutorService#invoke{All|Any}", "committedDate": "2020-05-29T11:38:19Z", "type": "commit"}, {"oid": "28fa7957d4e2919b31d6cbea8d06c8f2d084c8e1", "url": "https://github.com/elastic/apm-agent-java/commit/28fa7957d4e2919b31d6cbea8d06c8f2d084c8e1", "message": "Fix for Executors that execute on current thread", "committedDate": "2020-05-30T09:05:41Z", "type": "commit"}, {"oid": "aa9610e8d02f23331c1cd4251c26b26f0b39cf39", "url": "https://github.com/elastic/apm-agent-java/commit/aa9610e8d02f23331c1cd4251c26b26f0b39cf39", "message": "Instrument ForkJoinPool and ScheduledExecutorService", "committedDate": "2020-05-31T13:58:27Z", "type": "commit"}, {"oid": "d70189033185b03d953cfcb883c8d7d1279d78ed", "url": "https://github.com/elastic/apm-agent-java/commit/d70189033185b03d953cfcb883c8d7d1279d78ed", "message": "Speed up tests by avoiding to call Mockito spy in hot method", "committedDate": "2020-05-31T14:44:10Z", "type": "commit"}, {"oid": "332e1fb2bd497411d6dbb32d5fdace4ee89d6e20", "url": "https://github.com/elastic/apm-agent-java/commit/332e1fb2bd497411d6dbb32d5fdace4ee89d6e20", "message": "Fix Javadoc error", "committedDate": "2020-06-02T11:09:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzNTM4MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r439935381", "bodyText": "Obtain these two class lists outside the matching flow, otherwise Mockito has problems with the config mocks. See this comment.", "author": "eyalkoren", "createdAt": "2020-06-15T05:20:47Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/bci/ElasticApmAgent.java", "diffHunk": "@@ -467,18 +467,8 @@ private static AgentBuilder getAgentBuilder(final ByteBuddy byteBuddy, final Cor\n             .or(nameStartsWith(\"io.sqreen.\"))\n             .or(nameContains(\"javassist\"))\n             .or(nameContains(\".asm.\"))\n-            .or(new ElementMatcher.Junction.AbstractBase<TypeDescription>() {\n-                @Override\n-                public boolean matches(TypeDescription target) {\n-                    return WildcardMatcher.anyMatch(coreConfiguration.getDefaultClassesExcludedFromInstrumentation(), target.getName()) != null;\n-                }\n-            })\n-            .or(new ElementMatcher.Junction.AbstractBase<TypeDescription>() {\n-                @Override\n-                public boolean matches(TypeDescription target) {\n-                    return WildcardMatcher.anyMatch(coreConfiguration.getClassesExcludedFromInstrumentation(), target.getName()) != null;\n-                }\n-            })\n+            .or(anyMatch(coreConfiguration.getDefaultClassesExcludedFromInstrumentation()))\n+            .or(anyMatch(coreConfiguration.getClassesExcludedFromInstrumentation()))", "originalCommit": "332e1fb2bd497411d6dbb32d5fdace4ee89d6e20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk5NzM5MA==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r439997390", "bodyText": "That's what it does \ud83d\ude42", "author": "felixbarny", "createdAt": "2020-06-15T08:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzNTM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2ODUzNA==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r440368534", "bodyText": "That's right \ud83d\ude42", "author": "eyalkoren", "createdAt": "2020-06-15T18:33:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzNTM4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzNjcxMw==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r439936713", "bodyText": "Is it used?", "author": "eyalkoren", "createdAt": "2020-06-15T05:26:26Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/util/CallDepth.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.util;\n+\n+import java.util.Map;\n+import java.util.WeakHashMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * A utility that makes it easy to detect nested method calls.\n+ */\n+public class CallDepth {", "originalCommit": "332e1fb2bd497411d6dbb32d5fdace4ee89d6e20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA2NTk1MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r440065951", "bodyText": "no. can and should be removed. It's coming back in a different form in #1230", "author": "felixbarny", "createdAt": "2020-06-15T10:01:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzNjcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzNzA3MA==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r439937070", "bodyText": "If it's thread local, why using an AtomicInteger?\nAlso, if it's about identification of nesting only (without knowing the level of nesting), no need for a map - a stack of classes is sufficient.\nLastly, using class name may be better as it won't require weak referencing.", "author": "eyalkoren", "createdAt": "2020-06-15T05:28:05Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/util/CallDepth.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.util;\n+\n+import java.util.Map;\n+import java.util.WeakHashMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * A utility that makes it easy to detect nested method calls.\n+ */\n+public class CallDepth {\n+    private static final ThreadLocal<Map<Class<?>, AtomicInteger>> callDepthPerThread = new ThreadLocal<Map<Class<?>, AtomicInteger>>();", "originalCommit": "332e1fb2bd497411d6dbb32d5fdace4ee89d6e20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE3MjE1Ng==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r440172156", "bodyText": "Also, if it's about identification of nesting only (without knowing the level of nesting), no need for a map - a stack of classes is sufficient.\n\nNot quite sure what you mean by that. Note that often you also need to know in the exit advice whether it's a nested invocation.\n\nIf it's thread local, why using an AtomicInteger?\n\nMainly out of convenience. We could create something like a MultableInt to get rid of the volatile reads/writes if that's what you're hinting at?\n\nLastly, using class name may be better as it won't require weak referencing.\n\nThe new version is using a string which is important so the call depth is a global vs a per classloader counter.", "author": "felixbarny", "createdAt": "2020-06-15T13:24:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzNzA3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM5OTIyMA==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r440399220", "bodyText": "Note that often you also need to know in the exit advice whether it's a nested invocation.\n\nWhy isn't a stack enough for that? In any case, if you know in the enter advice, it should be easy to tell the exit advice...\n\nMainly out of convenience. We could create something like a MultableInt to get rid of the volatile reads/writes if that's what you're hinting at?\n\nThe volatile and the additional overhead of atomically fetching and incrementing/decrementing. Why does it have to be mutable and not an Integer you override when incrementing/decrementing? You would really need a deep nesting to be out of the Integer cache\n\nThe new version is using a string which is important so the call depth is a global vs a per classloader counter.\n\nDo you think the usage of same class names loaded by different class loaders on the same stack is a concern?", "author": "eyalkoren", "createdAt": "2020-06-15T19:30:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzNzA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk2MzA5NA==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r439963094", "bodyText": "Done both in the if and else, can be done outside", "author": "eyalkoren", "createdAt": "2020-06-15T06:51:08Z", "path": "apm-agent-plugins/apm-java-concurrent-plugin/src/main/java/co/elastic/apm/agent/concurrent/JavaConcurrent.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmAgent;\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.TraceContext;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ForkJoinTask;\n+\n+public class JavaConcurrent {\n+\n+    private static final WeakConcurrentMap<Object, AbstractSpan<?>> contextMap = new WeakConcurrentMap<Object, AbstractSpan<?>>(false);\n+    private static final List<Class<? extends ElasticApmInstrumentation>> RUNNABLE_CALLABLE_FJTASK_INSTRUMENTATION = Collections.\n+        <Class<? extends ElasticApmInstrumentation>>singletonList(RunnableCallableForkJoinTaskInstrumentation.class);\n+    private static final ThreadLocal<Boolean> needsContext = new ThreadLocal<>();\n+\n+    private static void removeContext(Object o) {\n+        AbstractSpan<?> context = contextMap.remove(o);\n+        if (context != null) {\n+            context.decrementReferences();\n+        }\n+    }\n+\n+    @Nullable\n+    public static AbstractSpan<?> restoreContext(Object o, @Nullable ElasticApmTracer tracer) {\n+        if (tracer == null) {\n+            return null;\n+        }\n+        // When an Executor executes directly on the current thread we need to enable this thread for context propagation again\n+        needsContext.set(Boolean.TRUE);\n+        AbstractSpan<?> context = contextMap.remove(o);\n+        if (context == null) {\n+            return null;\n+        }\n+        if (tracer.getActive() != context) {\n+            context.activate();\n+            context.decrementReferences();", "originalCommit": "332e1fb2bd497411d6dbb32d5fdace4ee89d6e20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDcxNDE1Nw==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r440714157", "bodyText": "The decrement should happen after the activate. Otherwise, the span might be recycled if the reference count goes down to 0.", "author": "felixbarny", "createdAt": "2020-06-16T09:28:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk2MzA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk2NDMwNw==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r439964307", "bodyText": "\ud83d\udc4d", "author": "eyalkoren", "createdAt": "2020-06-15T06:54:11Z", "path": "apm-agent-plugins/apm-java-concurrent-plugin/src/main/java/co/elastic/apm/agent/concurrent/JavaConcurrent.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmAgent;\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.TraceContext;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ForkJoinTask;\n+\n+public class JavaConcurrent {\n+\n+    private static final WeakConcurrentMap<Object, AbstractSpan<?>> contextMap = new WeakConcurrentMap<Object, AbstractSpan<?>>(false);\n+    private static final List<Class<? extends ElasticApmInstrumentation>> RUNNABLE_CALLABLE_FJTASK_INSTRUMENTATION = Collections.\n+        <Class<? extends ElasticApmInstrumentation>>singletonList(RunnableCallableForkJoinTaskInstrumentation.class);\n+    private static final ThreadLocal<Boolean> needsContext = new ThreadLocal<>();\n+\n+    private static void removeContext(Object o) {\n+        AbstractSpan<?> context = contextMap.remove(o);\n+        if (context != null) {\n+            context.decrementReferences();\n+        }\n+    }\n+\n+    @Nullable\n+    public static AbstractSpan<?> restoreContext(Object o, @Nullable ElasticApmTracer tracer) {\n+        if (tracer == null) {\n+            return null;\n+        }\n+        // When an Executor executes directly on the current thread we need to enable this thread for context propagation again\n+        needsContext.set(Boolean.TRUE);\n+        AbstractSpan<?> context = contextMap.remove(o);\n+        if (context == null) {\n+            return null;\n+        }\n+        if (tracer.getActive() != context) {\n+            context.activate();\n+            context.decrementReferences();\n+            return context;\n+        } else {\n+            context.decrementReferences();\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Wraps the provided runnable and makes this {@link AbstractSpan} active in the {@link Runnable#run()} method.\n+     *\n+     * <p>\n+     * Note: does activates the {@link AbstractSpan} and not only the {@link TraceContext}.\n+     * This should only be used when the span is closed in thread the provided {@link Runnable} is executed in.\n+     * </p>\n+     */\n+    @Nullable\n+    public static Runnable withContext(@Nullable Runnable runnable, @Nullable ElasticApmTracer tracer) {\n+        if (runnable instanceof RunnableLambdaWrapper || runnable == null || tracer == null || needsContext.get() == Boolean.FALSE) {\n+            return runnable;\n+        }\n+        needsContext.set(Boolean.FALSE);\n+        AbstractSpan<?> active = tracer.getActive();\n+        if (active == null) {\n+            return runnable;\n+        }\n+        if (isLambda(runnable)) {\n+            runnable = new RunnableLambdaWrapper(runnable);\n+        }\n+        ElasticApmAgent.ensureInstrumented(runnable.getClass(), RUNNABLE_CALLABLE_FJTASK_INSTRUMENTATION);", "originalCommit": "332e1fb2bd497411d6dbb32d5fdace4ee89d6e20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk2NDQxNw==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r439964417", "bodyText": "Update javadoc", "author": "eyalkoren", "createdAt": "2020-06-15T06:54:29Z", "path": "apm-agent-plugins/apm-java-concurrent-plugin/src/main/java/co/elastic/apm/agent/concurrent/JavaConcurrent.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmAgent;\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.TraceContext;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ForkJoinTask;\n+\n+public class JavaConcurrent {\n+\n+    private static final WeakConcurrentMap<Object, AbstractSpan<?>> contextMap = new WeakConcurrentMap<Object, AbstractSpan<?>>(false);\n+    private static final List<Class<? extends ElasticApmInstrumentation>> RUNNABLE_CALLABLE_FJTASK_INSTRUMENTATION = Collections.\n+        <Class<? extends ElasticApmInstrumentation>>singletonList(RunnableCallableForkJoinTaskInstrumentation.class);\n+    private static final ThreadLocal<Boolean> needsContext = new ThreadLocal<>();\n+\n+    private static void removeContext(Object o) {\n+        AbstractSpan<?> context = contextMap.remove(o);\n+        if (context != null) {\n+            context.decrementReferences();\n+        }\n+    }\n+\n+    @Nullable\n+    public static AbstractSpan<?> restoreContext(Object o, @Nullable ElasticApmTracer tracer) {\n+        if (tracer == null) {\n+            return null;\n+        }\n+        // When an Executor executes directly on the current thread we need to enable this thread for context propagation again\n+        needsContext.set(Boolean.TRUE);\n+        AbstractSpan<?> context = contextMap.remove(o);\n+        if (context == null) {\n+            return null;\n+        }\n+        if (tracer.getActive() != context) {\n+            context.activate();\n+            context.decrementReferences();\n+            return context;\n+        } else {\n+            context.decrementReferences();\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Wraps the provided runnable and makes this {@link AbstractSpan} active in the {@link Runnable#run()} method.\n+     *\n+     * <p>\n+     * Note: does activates the {@link AbstractSpan} and not only the {@link TraceContext}.\n+     * This should only be used when the span is closed in thread the provided {@link Runnable} is executed in.\n+     * </p>", "originalCommit": "332e1fb2bd497411d6dbb32d5fdace4ee89d6e20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk2NDU4MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r439964581", "bodyText": "Update javadoc", "author": "eyalkoren", "createdAt": "2020-06-15T06:54:53Z", "path": "apm-agent-plugins/apm-java-concurrent-plugin/src/main/java/co/elastic/apm/agent/concurrent/JavaConcurrent.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmAgent;\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.TraceContext;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ForkJoinTask;\n+\n+public class JavaConcurrent {\n+\n+    private static final WeakConcurrentMap<Object, AbstractSpan<?>> contextMap = new WeakConcurrentMap<Object, AbstractSpan<?>>(false);\n+    private static final List<Class<? extends ElasticApmInstrumentation>> RUNNABLE_CALLABLE_FJTASK_INSTRUMENTATION = Collections.\n+        <Class<? extends ElasticApmInstrumentation>>singletonList(RunnableCallableForkJoinTaskInstrumentation.class);\n+    private static final ThreadLocal<Boolean> needsContext = new ThreadLocal<>();\n+\n+    private static void removeContext(Object o) {\n+        AbstractSpan<?> context = contextMap.remove(o);\n+        if (context != null) {\n+            context.decrementReferences();\n+        }\n+    }\n+\n+    @Nullable\n+    public static AbstractSpan<?> restoreContext(Object o, @Nullable ElasticApmTracer tracer) {\n+        if (tracer == null) {\n+            return null;\n+        }\n+        // When an Executor executes directly on the current thread we need to enable this thread for context propagation again\n+        needsContext.set(Boolean.TRUE);\n+        AbstractSpan<?> context = contextMap.remove(o);\n+        if (context == null) {\n+            return null;\n+        }\n+        if (tracer.getActive() != context) {\n+            context.activate();\n+            context.decrementReferences();\n+            return context;\n+        } else {\n+            context.decrementReferences();\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Wraps the provided runnable and makes this {@link AbstractSpan} active in the {@link Runnable#run()} method.\n+     *\n+     * <p>\n+     * Note: does activates the {@link AbstractSpan} and not only the {@link TraceContext}.\n+     * This should only be used when the span is closed in thread the provided {@link Runnable} is executed in.\n+     * </p>\n+     */\n+    @Nullable\n+    public static Runnable withContext(@Nullable Runnable runnable, @Nullable ElasticApmTracer tracer) {\n+        if (runnable instanceof RunnableLambdaWrapper || runnable == null || tracer == null || needsContext.get() == Boolean.FALSE) {\n+            return runnable;\n+        }\n+        needsContext.set(Boolean.FALSE);\n+        AbstractSpan<?> active = tracer.getActive();\n+        if (active == null) {\n+            return runnable;\n+        }\n+        if (isLambda(runnable)) {\n+            runnable = new RunnableLambdaWrapper(runnable);\n+        }\n+        ElasticApmAgent.ensureInstrumented(runnable.getClass(), RUNNABLE_CALLABLE_FJTASK_INSTRUMENTATION);\n+        contextMap.put(runnable, active);\n+        active.incrementReferences();\n+        // Do no discard branches leading to async operations so not to break span references\n+        active.setNonDiscardable();\n+        return runnable;\n+    }\n+\n+    /**\n+     * Wraps the provided runnable and makes this {@link AbstractSpan} active in the {@link Runnable#run()} method.\n+     *\n+     * <p>\n+     * Note: does activates the {@link AbstractSpan} and not only the {@link TraceContext}.\n+     * This should only be used when the span is closed in thread the provided {@link Runnable} is executed in.\n+     * </p>\n+     */", "originalCommit": "332e1fb2bd497411d6dbb32d5fdace4ee89d6e20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk2OTQxOA==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r439969418", "bodyText": "We need some cleanup of stale entries, maybe use WeakConcurrentMap.WithInlinedExpunction?\nOn the other hand, given that this map may be accessed VERY frequently, using a cleaner thread makes more sense", "author": "eyalkoren", "createdAt": "2020-06-15T07:07:04Z", "path": "apm-agent-plugins/apm-java-concurrent-plugin/src/main/java/co/elastic/apm/agent/concurrent/JavaConcurrent.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmAgent;\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.TraceContext;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ForkJoinTask;\n+\n+public class JavaConcurrent {\n+\n+    private static final WeakConcurrentMap<Object, AbstractSpan<?>> contextMap = new WeakConcurrentMap<Object, AbstractSpan<?>>(false);", "originalCommit": "332e1fb2bd497411d6dbb32d5fdace4ee89d6e20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE3NDQzMw==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r440174433", "bodyText": "Good catch, it's not using any extinction at all \ud83d\ude48\nWe should create a global registry for WeakConcurrentMaps so that we only need one cleaner thread for all vs one per map. But for now, WithInlinedExpunction should do.", "author": "felixbarny", "createdAt": "2020-06-15T13:27:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk2OTQxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwMDUxOA==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r440400518", "bodyText": "I also had that in mind, but didn't see an API in WeakConcurrentMap to control which thread is the cleaner thread.", "author": "eyalkoren", "createdAt": "2020-06-15T19:33:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk2OTQxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc0NjIyMg==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r440746222", "bodyText": "I've added a central registry to get and clean weak maps", "author": "felixbarny", "createdAt": "2020-06-16T10:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk2OTQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NjM3Ng==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r439976376", "bodyText": "This introduces a risk of causing ClassCastException due to the collection type. I think it's better to try/catch using Collection.remove and Collection.add and avoid wrapping (with logging) if not supported by the collection.", "author": "eyalkoren", "createdAt": "2020-06-15T07:22:33Z", "path": "apm-agent-plugins/apm-java-concurrent-plugin/src/main/java/co/elastic/apm/agent/concurrent/JavaConcurrent.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmAgent;\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.TraceContext;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ForkJoinTask;\n+\n+public class JavaConcurrent {\n+\n+    private static final WeakConcurrentMap<Object, AbstractSpan<?>> contextMap = new WeakConcurrentMap<Object, AbstractSpan<?>>(false);\n+    private static final List<Class<? extends ElasticApmInstrumentation>> RUNNABLE_CALLABLE_FJTASK_INSTRUMENTATION = Collections.\n+        <Class<? extends ElasticApmInstrumentation>>singletonList(RunnableCallableForkJoinTaskInstrumentation.class);\n+    private static final ThreadLocal<Boolean> needsContext = new ThreadLocal<>();\n+\n+    private static void removeContext(Object o) {\n+        AbstractSpan<?> context = contextMap.remove(o);\n+        if (context != null) {\n+            context.decrementReferences();\n+        }\n+    }\n+\n+    @Nullable\n+    public static AbstractSpan<?> restoreContext(Object o, @Nullable ElasticApmTracer tracer) {\n+        if (tracer == null) {\n+            return null;\n+        }\n+        // When an Executor executes directly on the current thread we need to enable this thread for context propagation again\n+        needsContext.set(Boolean.TRUE);\n+        AbstractSpan<?> context = contextMap.remove(o);\n+        if (context == null) {\n+            return null;\n+        }\n+        if (tracer.getActive() != context) {\n+            context.activate();\n+            context.decrementReferences();\n+            return context;\n+        } else {\n+            context.decrementReferences();\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Wraps the provided runnable and makes this {@link AbstractSpan} active in the {@link Runnable#run()} method.\n+     *\n+     * <p>\n+     * Note: does activates the {@link AbstractSpan} and not only the {@link TraceContext}.\n+     * This should only be used when the span is closed in thread the provided {@link Runnable} is executed in.\n+     * </p>\n+     */\n+    @Nullable\n+    public static Runnable withContext(@Nullable Runnable runnable, @Nullable ElasticApmTracer tracer) {\n+        if (runnable instanceof RunnableLambdaWrapper || runnable == null || tracer == null || needsContext.get() == Boolean.FALSE) {\n+            return runnable;\n+        }\n+        needsContext.set(Boolean.FALSE);\n+        AbstractSpan<?> active = tracer.getActive();\n+        if (active == null) {\n+            return runnable;\n+        }\n+        if (isLambda(runnable)) {\n+            runnable = new RunnableLambdaWrapper(runnable);\n+        }\n+        ElasticApmAgent.ensureInstrumented(runnable.getClass(), RUNNABLE_CALLABLE_FJTASK_INSTRUMENTATION);\n+        contextMap.put(runnable, active);\n+        active.incrementReferences();\n+        // Do no discard branches leading to async operations so not to break span references\n+        active.setNonDiscardable();\n+        return runnable;\n+    }\n+\n+    /**\n+     * Wraps the provided runnable and makes this {@link AbstractSpan} active in the {@link Runnable#run()} method.\n+     *\n+     * <p>\n+     * Note: does activates the {@link AbstractSpan} and not only the {@link TraceContext}.\n+     * This should only be used when the span is closed in thread the provided {@link Runnable} is executed in.\n+     * </p>\n+     */\n+    @Nullable\n+    public static <T> Callable<T> withContext(@Nullable Callable<T> callable, @Nullable ElasticApmTracer tracer) {\n+        if (callable instanceof CallableLambdaWrapper || callable == null || tracer == null  || needsContext.get() == Boolean.FALSE) {\n+            return callable;\n+        }\n+        needsContext.set(Boolean.FALSE);\n+        AbstractSpan<?> active = tracer.getActive();\n+        if (active == null) {\n+            return callable;\n+        }\n+        if (isLambda(callable)) {\n+            callable = new CallableLambdaWrapper<>(callable);\n+        }\n+        ElasticApmAgent.ensureInstrumented(callable.getClass(), RUNNABLE_CALLABLE_FJTASK_INSTRUMENTATION);\n+        contextMap.put(callable, active);\n+        active.incrementReferences();\n+        return callable;\n+    }\n+\n+    @Nullable\n+    public static <T> ForkJoinTask<T> withContext(@Nullable ForkJoinTask<T> task, @Nullable ElasticApmTracer tracer) {\n+        if (task == null || tracer == null  || needsContext.get() == Boolean.FALSE) {\n+            return task;\n+        }\n+        needsContext.set(Boolean.FALSE);\n+        AbstractSpan<?> active = tracer.getActive();\n+        if (active == null) {\n+            return task;\n+        }\n+        ElasticApmAgent.ensureInstrumented(task.getClass(), RUNNABLE_CALLABLE_FJTASK_INSTRUMENTATION);\n+        contextMap.put(task, active);\n+        active.incrementReferences();\n+        return task;\n+    }\n+\n+    public static void doFinally(@Nullable Throwable thrown, @Nullable Object contextObject) {\n+        needsContext.set(Boolean.TRUE);\n+        if (thrown != null && contextObject != null) {\n+            removeContext(contextObject);\n+        }\n+    }\n+\n+    public static void doFinally(@Nullable Throwable thrown, @Nullable Collection<? extends Callable<?>> callables) {\n+        needsContext.set(Boolean.TRUE);\n+        if (thrown != null && callables != null) {\n+            for (Callable<?> callable : callables) {\n+                removeContext(callable);\n+            }\n+        }\n+    }\n+\n+    private static boolean isLambda(Object o) {\n+        return o.getClass().getName().indexOf('/') != -1;\n+    }\n+\n+    @Nullable\n+    public static <T> Collection<? extends Callable<T>> withContext(@Nullable Collection<? extends Callable<T>> callables, @Nullable ElasticApmTracer tracer) {\n+        if (callables == null || tracer == null) {\n+            return null;\n+        }\n+        if (callables.isEmpty()) {\n+            return callables;\n+        }\n+        final Collection<Callable<T>> wrapped;\n+        if (needsWrapping(callables)) {\n+            wrapped = new ArrayList<>(callables.size());", "originalCommit": "332e1fb2bd497411d6dbb32d5fdace4ee89d6e20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE3OTM5Ng==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r440179396", "bodyText": "That would impact the order of the callables in the collection. But we could clear and re-fill it.", "author": "felixbarny", "createdAt": "2020-06-15T13:35:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NjM3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM4MDY3Mw==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r440380673", "bodyText": "That's right. So either that, or avoid wrapping (meaning - not supporting lambdas in collections) if you feel it adds too much complexity.", "author": "eyalkoren", "createdAt": "2020-06-15T18:56:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NjM3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc0Mjk3MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r440742971", "bodyText": "I think calling add and remove is more likely to fail than creating an entirely new list because that's a good chance the collection is immutable.\nMaybe leave as-is and remove if we see it causes problems?", "author": "felixbarny", "createdAt": "2020-06-16T10:17:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NjM3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc5MTI4Ng==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r440791286", "bodyText": "My vote is actually to go the other way around - fail (meaning - don't wrap lambdas in collections if the collection is immutable) or not try to wrap in collections and see if we get requests to support that. I prefer questions about why something is not working than issues with breaking applications.\nIf you are not convinced - leave as is.", "author": "eyalkoren", "createdAt": "2020-06-16T11:52:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NjM3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgyNDgxNA==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r440824814", "bodyText": "That may cause subtle context losses that are very hard to debug. I'd like to resort to these defensive measures only if there are actual problems in the wild which will surface in a more obvious way by throwing an exception. I'll add a new instrumentation group name executor-collection to disable just this instrumentation more easily.\nI think in practice it's unlikely that an executor implementation depends on the type of the collection or even overrides the default implementation in AbstractExecutorService.", "author": "felixbarny", "createdAt": "2020-06-16T12:52:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NjM3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg2NjA3Ng==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r440866076", "bodyText": "This entire PR is about executors exposing APIs that allow interfaces but expect specific types \ud83d\ude42", "author": "eyalkoren", "createdAt": "2020-06-16T13:51:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NjM3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NzMyMQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r439977321", "bodyText": "What about pooling wrappers? Could be used very frequently.", "author": "eyalkoren", "createdAt": "2020-06-15T07:24:29Z", "path": "apm-agent-plugins/apm-java-concurrent-plugin/src/main/java/co/elastic/apm/agent/concurrent/JavaConcurrent.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmAgent;\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.TraceContext;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ForkJoinTask;\n+\n+public class JavaConcurrent {\n+\n+    private static final WeakConcurrentMap<Object, AbstractSpan<?>> contextMap = new WeakConcurrentMap<Object, AbstractSpan<?>>(false);\n+    private static final List<Class<? extends ElasticApmInstrumentation>> RUNNABLE_CALLABLE_FJTASK_INSTRUMENTATION = Collections.\n+        <Class<? extends ElasticApmInstrumentation>>singletonList(RunnableCallableForkJoinTaskInstrumentation.class);\n+    private static final ThreadLocal<Boolean> needsContext = new ThreadLocal<>();\n+\n+    private static void removeContext(Object o) {\n+        AbstractSpan<?> context = contextMap.remove(o);\n+        if (context != null) {\n+            context.decrementReferences();\n+        }\n+    }\n+\n+    @Nullable\n+    public static AbstractSpan<?> restoreContext(Object o, @Nullable ElasticApmTracer tracer) {\n+        if (tracer == null) {\n+            return null;\n+        }\n+        // When an Executor executes directly on the current thread we need to enable this thread for context propagation again\n+        needsContext.set(Boolean.TRUE);\n+        AbstractSpan<?> context = contextMap.remove(o);\n+        if (context == null) {\n+            return null;\n+        }\n+        if (tracer.getActive() != context) {\n+            context.activate();\n+            context.decrementReferences();\n+            return context;\n+        } else {\n+            context.decrementReferences();\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Wraps the provided runnable and makes this {@link AbstractSpan} active in the {@link Runnable#run()} method.\n+     *\n+     * <p>\n+     * Note: does activates the {@link AbstractSpan} and not only the {@link TraceContext}.\n+     * This should only be used when the span is closed in thread the provided {@link Runnable} is executed in.\n+     * </p>\n+     */\n+    @Nullable\n+    public static Runnable withContext(@Nullable Runnable runnable, @Nullable ElasticApmTracer tracer) {\n+        if (runnable instanceof RunnableLambdaWrapper || runnable == null || tracer == null || needsContext.get() == Boolean.FALSE) {\n+            return runnable;\n+        }\n+        needsContext.set(Boolean.FALSE);\n+        AbstractSpan<?> active = tracer.getActive();\n+        if (active == null) {\n+            return runnable;\n+        }\n+        if (isLambda(runnable)) {\n+            runnable = new RunnableLambdaWrapper(runnable);", "originalCommit": "332e1fb2bd497411d6dbb32d5fdace4ee89d6e20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDIwNzQ2OQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r440207469", "bodyText": "By putting the runnable in a WeakConcurrentMap, we're already allocating a WeakReference and a Map.Entry so pooling the Runnable wrapper won't make it allocation free, unfortunately. Given that, I don't think it's worth it.", "author": "felixbarny", "createdAt": "2020-06-15T14:15:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NzMyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3OTUxMw==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r440379513", "bodyText": "Okey dokey", "author": "eyalkoren", "createdAt": "2020-06-15T18:54:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NzMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3OTkzMQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r439979931", "bodyText": "[minor] - proposal: make the activation here, rather than implicit, making it symmetric with onExit.", "author": "eyalkoren", "createdAt": "2020-06-15T07:29:47Z", "path": "apm-agent-plugins/apm-java-concurrent-plugin/src/main/java/co/elastic/apm/agent/concurrent/RunnableCallableForkJoinTaskInstrumentation.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ForkJoinTask;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.hasSuperType;\n+import static net.bytebuddy.matcher.ElementMatchers.is;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.returns;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+/**\n+ * Used only within {@link JavaConcurrent#withContext} to\n+ * {@linkplain co.elastic.apm.agent.bci.ElasticApmAgent#ensureInstrumented(Class, Collection) ensure}\n+ * that particular {@link Callable}, {@link Runnable} and {@link ForkJoinTask} classes are instrumented.\n+ */\n+public class RunnableCallableForkJoinTaskInstrumentation extends ElasticApmInstrumentation {\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(\n+            is(Runnable.class)\n+            .or(is(Callable.class))\n+            .or(is(ForkJoinTask.class))\n+        );\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+        return named(\"run\").and(takesArguments(0))\n+            .or(named(\"call\").and(takesArguments(0)))\n+            .or(named(\"exec\").and(takesArguments(0).and(returns(boolean.class))));\n+    }\n+\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"executor\");\n+    }\n+\n+    @Nullable\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    private static AbstractSpan<?> onEnter(@Advice.This Object thiz) {\n+        return JavaConcurrent.restoreContext(thiz, tracer);", "originalCommit": "332e1fb2bd497411d6dbb32d5fdace4ee89d6e20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc0Njc3OQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1206#discussion_r440746779", "bodyText": "I did that on purpose to minimize the null checks you need to do.", "author": "felixbarny", "createdAt": "2020-06-16T10:24:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3OTkzMQ=="}], "type": "inlineReview"}, {"oid": "a8f5b7e175b9bc305b876d2b8c9c6d20fe7639d9", "url": "https://github.com/elastic/apm-agent-java/commit/a8f5b7e175b9bc305b876d2b8c9c6d20fe7639d9", "message": "Remove unused CallDepth", "committedDate": "2020-06-16T09:24:27Z", "type": "commit"}, {"oid": "08ecfb81a8073ade8c6aef0702c571eef820496a", "url": "https://github.com/elastic/apm-agent-java/commit/08ecfb81a8073ade8c6aef0702c571eef820496a", "message": "Merge remote-tracking branch 'origin/master' into executor-instrument-runnables", "committedDate": "2020-06-16T09:54:19Z", "type": "commit"}, {"oid": "b9b5d7da061de92c018b253e27b5d8206748124c", "url": "https://github.com/elastic/apm-agent-java/commit/b9b5d7da061de92c018b253e27b5d8206748124c", "message": "Add global expunging of stale WeakConcurrentMap entries", "committedDate": "2020-06-16T10:19:56Z", "type": "commit"}, {"oid": "6463427c64efb18d1689afa1afcff98dc1e36d29", "url": "https://github.com/elastic/apm-agent-java/commit/6463427c64efb18d1689afa1afcff98dc1e36d29", "message": "Revert problematic usages of WeakMapSupplier", "committedDate": "2020-06-16T12:34:32Z", "type": "commit"}, {"oid": "a51ad0e1501336fc175364f095d929fb0669e276", "url": "https://github.com/elastic/apm-agent-java/commit/a51ad0e1501336fc175364f095d929fb0669e276", "message": "Add executor-collection instrumentation group", "committedDate": "2020-06-16T12:53:26Z", "type": "commit"}, {"oid": "38493d9fe14fbc6781c56c22b59609fdf21d66d0", "url": "https://github.com/elastic/apm-agent-java/commit/38493d9fe14fbc6781c56c22b59609fdf21d66d0", "message": "Update docs", "committedDate": "2020-06-16T13:07:19Z", "type": "commit"}, {"oid": "4a4e0028834a8e638aafdb731dcf849ed2c23f19", "url": "https://github.com/elastic/apm-agent-java/commit/4a4e0028834a8e638aafdb731dcf849ed2c23f19", "message": "Disable problematic async Dubbo tests for now", "committedDate": "2020-06-17T08:36:55Z", "type": "commit"}, {"oid": "48f75e15d8fe2b7df2e84253ea69c18972971c41", "url": "https://github.com/elastic/apm-agent-java/commit/48f75e15d8fe2b7df2e84253ea69c18972971c41", "message": "Merge branch 'master' into executor-instrument-runnables", "committedDate": "2020-06-17T14:44:48Z", "type": "commit"}]}