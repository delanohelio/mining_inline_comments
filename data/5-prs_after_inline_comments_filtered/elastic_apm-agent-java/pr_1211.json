{"pr_number": 1211, "pr_title": "Add cgroup support (#1197)", "pr_createdAt": "2020-06-01T18:17:39Z", "pr_url": "https://github.com/elastic/apm-agent-java/pull/1211", "timeline": [{"oid": "b562f0e00016cd059d0e176128876e1338864fd8", "url": "https://github.com/elastic/apm-agent-java/commit/b562f0e00016cd059d0e176128876e1338864fd8", "message": "Add cgroup support (#1197)", "committedDate": "2020-06-01T18:08:02Z", "type": "commit"}, {"oid": "0e16ff0cf27fce8d1e4d5398705830e51aff0564", "url": "https://github.com/elastic/apm-agent-java/commit/0e16ff0cf27fce8d1e4d5398705830e51aff0564", "message": "Fix Suggestion", "committedDate": "2020-06-02T13:15:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0MzI1Nw==", "url": "https://github.com/elastic/apm-agent-java/pull/1211#discussion_r434343257", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                    if (cgroupFiles == null && memInfoFile.canRead()) {\n          \n          \n            \n                    else if (memInfoFile.canRead()) {", "author": "eyalkoren", "createdAt": "2020-06-03T06:48:09Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/SystemMetrics.java", "diffHunk": "@@ -114,7 +168,35 @@ public double get() {\n             }\n         });\n \n-        if (memInfoFile.canRead()) {\n+        if (cgroupFiles != null) {\n+            metricRegistry.addUnlessNan(\"system.memory.actual.free\", Labels.EMPTY, new DoubleSupplier() {\n+                @Override\n+                public double get() {\n+                    try(BufferedReader fileReaderMemoryMax = new BufferedReader(new FileReader(cgroupFiles.getMaxMemory()));\n+                        BufferedReader fileReaderMemoryUsed = new BufferedReader(new FileReader(cgroupFiles.getUsedMemory()))\n+                    ) {\n+                        long memMax = Long.parseLong(fileReaderMemoryMax.readLine());\n+                        long memUsed = Long.parseLong(fileReaderMemoryUsed.readLine());\n+                        return memMax - memUsed;\n+                    } catch (Exception ignored) {\n+                        return Double.NaN;\n+                    }\n+                }\n+            });\n+            metricRegistry.addUnlessNan(\"system.memory.total\", Labels.EMPTY, new DoubleSupplier() {\n+                @Override\n+                public double get() {\n+                    try(BufferedReader fileReaderMemoryMax = new BufferedReader(new FileReader(cgroupFiles.getMaxMemory()))) {\n+                        long memMax = Long.parseLong(fileReaderMemoryMax.readLine());\n+                        return memMax;\n+                    } catch (Exception ignored) {\n+                        return Double.NaN;\n+                    }\n+                }\n+            });\n+        }\n+\n+        if (cgroupFiles == null && memInfoFile.canRead()) {", "originalCommit": "0e16ff0cf27fce8d1e4d5398705830e51aff0564", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0NjY4OQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1211#discussion_r434346689", "bodyText": "Why 9:? This is not constant", "author": "eyalkoren", "createdAt": "2020-06-03T06:55:57Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/SystemMetrics.java", "diffHunk": "@@ -78,19 +86,65 @@\n     @Nullable\n     private final Method virtualProcessMemory;\n     private final File memInfoFile;\n+    private final CgroupFiles cgroupFiles;\n \n     public SystemMetrics() {\n-        this(new File(\"/proc/meminfo\"));\n+        this(new File(\"/proc/meminfo\"), new File(PROC_SELF_CGROUP), new File(SYS_FS_CGROUP));\n     }\n \n-    SystemMetrics(File memInfoFile) {\n+    SystemMetrics(File memInfoFile, File procSelfCgroup, File sysFsCgroup) {\n         this.operatingSystemBean = ManagementFactory.getOperatingSystemMXBean();\n         this.systemCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getSystemCpuLoad\");\n         this.processCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getProcessCpuLoad\");\n         this.freeMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getFreePhysicalMemorySize\");\n         this.totalMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getTotalPhysicalMemorySize\");\n         this.virtualProcessMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getCommittedVirtualMemorySize\");\n         this.memInfoFile = memInfoFile;\n+\n+        cgroupFiles = verifyCgroupEnabled(procSelfCgroup, sysFsCgroup);\n+    }\n+\n+    public CgroupFiles verifyCgroupEnabled(File procSelfCgroup, File sysFsCgroup) {\n+        try(BufferedReader fileReader = new BufferedReader(new FileReader(procSelfCgroup))) {\n+            String lineCgroup = null;\n+            for (String cgroupLine = fileReader.readLine(); cgroupLine != null && !cgroupLine.isEmpty(); cgroupLine = fileReader.readLine()) {\n+                if (lineCgroup==null && cgroupLine.startsWith(\"0:\")) {\n+                    lineCgroup = cgroupLine;\n+                }\n+                if (cgroupLine.startsWith(\"9:memory\")) {", "originalCommit": "0e16ff0cf27fce8d1e4d5398705830e51aff0564", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0OTc5MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1211#discussion_r434349791", "bodyText": "Here is how the memory cgroup line looks like in the three images of different OSs I tested: 5:memory:/docker/6d3f70f8a4ec754f90370c78443bdffbf958fb59ffd31000994f7d351285bf0b, where the path does not represent a valid directory path, but seems to be a logical one only.\nHow are you testing this?", "author": "eyalkoren", "createdAt": "2020-06-03T07:02:47Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/SystemMetrics.java", "diffHunk": "@@ -78,19 +86,65 @@\n     @Nullable\n     private final Method virtualProcessMemory;\n     private final File memInfoFile;\n+    private final CgroupFiles cgroupFiles;\n \n     public SystemMetrics() {\n-        this(new File(\"/proc/meminfo\"));\n+        this(new File(\"/proc/meminfo\"), new File(PROC_SELF_CGROUP), new File(SYS_FS_CGROUP));\n     }\n \n-    SystemMetrics(File memInfoFile) {\n+    SystemMetrics(File memInfoFile, File procSelfCgroup, File sysFsCgroup) {\n         this.operatingSystemBean = ManagementFactory.getOperatingSystemMXBean();\n         this.systemCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getSystemCpuLoad\");\n         this.processCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getProcessCpuLoad\");\n         this.freeMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getFreePhysicalMemorySize\");\n         this.totalMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getTotalPhysicalMemorySize\");\n         this.virtualProcessMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getCommittedVirtualMemorySize\");\n         this.memInfoFile = memInfoFile;\n+\n+        cgroupFiles = verifyCgroupEnabled(procSelfCgroup, sysFsCgroup);\n+    }\n+\n+    public CgroupFiles verifyCgroupEnabled(File procSelfCgroup, File sysFsCgroup) {\n+        try(BufferedReader fileReader = new BufferedReader(new FileReader(procSelfCgroup))) {\n+            String lineCgroup = null;\n+            for (String cgroupLine = fileReader.readLine(); cgroupLine != null && !cgroupLine.isEmpty(); cgroupLine = fileReader.readLine()) {\n+                if (lineCgroup==null && cgroupLine.startsWith(\"0:\")) {\n+                    lineCgroup = cgroupLine;\n+                }\n+                if (cgroupLine.startsWith(\"9:memory\")) {\n+                    lineCgroup = cgroupLine;\n+                }\n+            }\n+            if ( lineCgroup!=null ) {\n+                final String[] cgroupSplit = StringUtils.split(lineCgroup, ':');\n+                // Checking cgroup2\n+                File maxMemory = new File(sysFsCgroup, cgroupSplit[cgroupSplit.length - 1] + \"/\" + CGROUP2_MAX_MEMORY);\n+                if (maxMemory.canRead()) {\n+                    try(BufferedReader fileReaderMem = new BufferedReader(new FileReader(maxMemory))) {\n+                        String memMaxLine = fileReaderMem.readLine();\n+                        if (!\"max\".equalsIgnoreCase(memMaxLine)) {\n+                            return new CgroupFiles(maxMemory,\n+                                new File(sysFsCgroup, cgroupSplit[cgroupSplit.length - 1] + \"/\" + CGROUP2_USED_MEMORY));", "originalCommit": "0e16ff0cf27fce8d1e4d5398705830e51aff0564", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM3MDc0Nw==", "url": "https://github.com/elastic/apm-agent-java/pull/1211#discussion_r434370747", "bodyText": "Guard with canRead?", "author": "eyalkoren", "createdAt": "2020-06-03T07:42:53Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/SystemMetrics.java", "diffHunk": "@@ -78,19 +86,65 @@\n     @Nullable\n     private final Method virtualProcessMemory;\n     private final File memInfoFile;\n+    private final CgroupFiles cgroupFiles;\n \n     public SystemMetrics() {\n-        this(new File(\"/proc/meminfo\"));\n+        this(new File(\"/proc/meminfo\"), new File(PROC_SELF_CGROUP), new File(SYS_FS_CGROUP));\n     }\n \n-    SystemMetrics(File memInfoFile) {\n+    SystemMetrics(File memInfoFile, File procSelfCgroup, File sysFsCgroup) {\n         this.operatingSystemBean = ManagementFactory.getOperatingSystemMXBean();\n         this.systemCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getSystemCpuLoad\");\n         this.processCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getProcessCpuLoad\");\n         this.freeMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getFreePhysicalMemorySize\");\n         this.totalMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getTotalPhysicalMemorySize\");\n         this.virtualProcessMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getCommittedVirtualMemorySize\");\n         this.memInfoFile = memInfoFile;\n+\n+        cgroupFiles = verifyCgroupEnabled(procSelfCgroup, sysFsCgroup);\n+    }\n+\n+    public CgroupFiles verifyCgroupEnabled(File procSelfCgroup, File sysFsCgroup) {\n+        try(BufferedReader fileReader = new BufferedReader(new FileReader(procSelfCgroup))) {", "originalCommit": "0e16ff0cf27fce8d1e4d5398705830e51aff0564", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e0daa4776b68eb9bce402cdd072ca856254ad74c", "url": "https://github.com/elastic/apm-agent-java/commit/e0daa4776b68eb9bce402cdd072ca856254ad74c", "message": "More fixes", "committedDate": "2020-06-03T11:54:35Z", "type": "commit"}, {"oid": "1b58678825dbe1742fc48c3b2941852c356516e8", "url": "https://github.com/elastic/apm-agent-java/commit/1b58678825dbe1742fc48c3b2941852c356516e8", "message": "cgroup mountpoint discover", "committedDate": "2020-06-04T13:19:17Z", "type": "commit"}, {"oid": "cbbcb7c3aae0ddd5182020c5e1ad77b666512275", "url": "https://github.com/elastic/apm-agent-java/commit/cbbcb7c3aae0ddd5182020c5e1ad77b666512275", "message": "Fix variable names", "committedDate": "2020-07-11T15:36:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ2NDcxMA==", "url": "https://github.com/elastic/apm-agent-java/pull/1211#discussion_r453464710", "bodyText": "No need for a list if we need a single matcher, but in any case, I suggest not using a matcher at all but an exact match - see comment where this is used", "author": "eyalkoren", "createdAt": "2020-07-13T06:45:40Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/SystemMetrics.java", "diffHunk": "@@ -60,9 +63,25 @@\n  * under Apache License 2.0\n  */\n public class SystemMetrics extends AbstractLifecycleListener {\n-\n+    public static final String PROC_SELF_CGROUP = \"/proc/self/cgroup\";\n+    public static final String SYS_FS_CGROUP = \"/sys/fs/cgroup\";\n+    public static final String PROC_SELF_MOUNTINFO = \"/proc/self/mountinfo\";\n     private final OperatingSystemMXBean operatingSystemBean;\n \n+    final private List<WildcardMatcher> inactiveMemoryRelevantLines = Arrays.asList(caseSensitiveMatcher(\"inactive_file *\"));", "originalCommit": "cbbcb7c3aae0ddd5182020c5e1ad77b666512275", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ3ODc2OQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1211#discussion_r453478769", "bodyText": "mountInfo is not a must - we have a default way to find the memory cgroup path.", "author": "eyalkoren", "createdAt": "2020-07-13T08:26:31Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/SystemMetrics.java", "diffHunk": "@@ -78,26 +97,133 @@\n     @Nullable\n     private final Method virtualProcessMemory;\n     private final File memInfoFile;\n+    @Nullable\n+    private final CgroupFiles cgroupFiles;\n \n     public SystemMetrics() {\n-        this(new File(\"/proc/meminfo\"));\n+        this(new File(\"/proc/meminfo\"), new File(PROC_SELF_CGROUP), new File(PROC_SELF_MOUNTINFO));\n     }\n \n-    SystemMetrics(File memInfoFile) {\n+    SystemMetrics(File memInfoFile, File procSelfCgroup, File mountInfo) {\n         this.operatingSystemBean = ManagementFactory.getOperatingSystemMXBean();\n         this.systemCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getSystemCpuLoad\");\n         this.processCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getProcessCpuLoad\");\n         this.freeMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getFreePhysicalMemorySize\");\n         this.totalMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getTotalPhysicalMemorySize\");\n         this.virtualProcessMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getCommittedVirtualMemorySize\");\n         this.memInfoFile = memInfoFile;\n+\n+        cgroupFiles = verifyCgroupEnabled(procSelfCgroup, mountInfo);\n+    }\n+\n+    public CgroupFiles verifyCgroupEnabled(File procSelfCgroup, File mountInfo) {\n+        if (procSelfCgroup.canRead() && mountInfo.canRead()) {", "originalCommit": "cbbcb7c3aae0ddd5182020c5e1ad77b666512275", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYyNTk4Mw==", "url": "https://github.com/elastic/apm-agent-java/pull/1211#discussion_r453625983", "bodyText": "Log an error", "author": "eyalkoren", "createdAt": "2020-07-13T12:51:14Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/SystemMetrics.java", "diffHunk": "@@ -78,26 +97,133 @@\n     @Nullable\n     private final Method virtualProcessMemory;\n     private final File memInfoFile;\n+    @Nullable\n+    private final CgroupFiles cgroupFiles;\n \n     public SystemMetrics() {\n-        this(new File(\"/proc/meminfo\"));\n+        this(new File(\"/proc/meminfo\"), new File(PROC_SELF_CGROUP), new File(PROC_SELF_MOUNTINFO));\n     }\n \n-    SystemMetrics(File memInfoFile) {\n+    SystemMetrics(File memInfoFile, File procSelfCgroup, File mountInfo) {\n         this.operatingSystemBean = ManagementFactory.getOperatingSystemMXBean();\n         this.systemCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getSystemCpuLoad\");\n         this.processCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getProcessCpuLoad\");\n         this.freeMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getFreePhysicalMemorySize\");\n         this.totalMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getTotalPhysicalMemorySize\");\n         this.virtualProcessMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getCommittedVirtualMemorySize\");\n         this.memInfoFile = memInfoFile;\n+\n+        cgroupFiles = verifyCgroupEnabled(procSelfCgroup, mountInfo);\n+    }\n+\n+    public CgroupFiles verifyCgroupEnabled(File procSelfCgroup, File mountInfo) {\n+        if (procSelfCgroup.canRead() && mountInfo.canRead()) {\n+            try(BufferedReader fileReader = new BufferedReader(new FileReader(procSelfCgroup))) {\n+                String lineCgroup = null;\n+                for (String cgroupLine = fileReader.readLine(); cgroupLine != null && !cgroupLine.isEmpty(); cgroupLine = fileReader.readLine()) {\n+                    if (lineCgroup == null && cgroupLine.startsWith(\"0:\")) {\n+                        lineCgroup = cgroupLine;\n+                    }\n+                    if (MEMORY_CGROUP.matcher(cgroupLine).matches()) {\n+                        lineCgroup = cgroupLine;\n+                    }\n+                }\n+                if (lineCgroup != null) {\n+                    CgroupFiles cgroupFilesTest = null;\n+                    try(BufferedReader fileMountInfoReader = new BufferedReader(new FileReader(mountInfo))) {\n+                        for (String mountLine = fileMountInfoReader.readLine(); mountLine != null && !mountLine.isEmpty(); mountLine = fileMountInfoReader.readLine()) {\n+                            String foundRegex = applyCgroup2Regex(mountLine);\n+                            if (foundRegex != null) {\n+                                cgroupFilesTest = verifyCgroup2Available(lineCgroup, new File(foundRegex));\n+                                if (cgroupFilesTest != null) return cgroupFilesTest;\n+                            }\n+                            foundRegex = applyCgroup1Regex(mountLine);\n+                            if (foundRegex != null) {\n+                                cgroupFilesTest = verifyCgroup1Available(new File(foundRegex));\n+                                if (cgroupFilesTest != null) return cgroupFilesTest;\n+                            }\n+                        }\n+                    }\n+                    // Fall back to /sys/fs/cgroup if not found on mountinfo\n+                    cgroupFilesTest = verifyCgroup2Available(lineCgroup, new File(SYS_FS_CGROUP));\n+                    if (cgroupFilesTest != null) return cgroupFilesTest;\n+                    cgroupFilesTest = verifyCgroup1Available( new File(SYS_FS_CGROUP + File.pathSeparator + \"memory\"));\n+                    if (cgroupFilesTest != null) return cgroupFilesTest;\n+\n+                }\n+            } catch (Exception e) {", "originalCommit": "cbbcb7c3aae0ddd5182020c5e1ad77b666512275", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYyNzQ0Ng==", "url": "https://github.com/elastic/apm-agent-java/pull/1211#discussion_r453627446", "bodyText": "Only execute if the mountInfo file exists and available for us. Also add a catch clause for any related exception of this try block, because we still have a default to fall back to if any of this fails", "author": "eyalkoren", "createdAt": "2020-07-13T12:54:01Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/SystemMetrics.java", "diffHunk": "@@ -78,26 +97,133 @@\n     @Nullable\n     private final Method virtualProcessMemory;\n     private final File memInfoFile;\n+    @Nullable\n+    private final CgroupFiles cgroupFiles;\n \n     public SystemMetrics() {\n-        this(new File(\"/proc/meminfo\"));\n+        this(new File(\"/proc/meminfo\"), new File(PROC_SELF_CGROUP), new File(PROC_SELF_MOUNTINFO));\n     }\n \n-    SystemMetrics(File memInfoFile) {\n+    SystemMetrics(File memInfoFile, File procSelfCgroup, File mountInfo) {\n         this.operatingSystemBean = ManagementFactory.getOperatingSystemMXBean();\n         this.systemCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getSystemCpuLoad\");\n         this.processCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getProcessCpuLoad\");\n         this.freeMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getFreePhysicalMemorySize\");\n         this.totalMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getTotalPhysicalMemorySize\");\n         this.virtualProcessMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getCommittedVirtualMemorySize\");\n         this.memInfoFile = memInfoFile;\n+\n+        cgroupFiles = verifyCgroupEnabled(procSelfCgroup, mountInfo);\n+    }\n+\n+    public CgroupFiles verifyCgroupEnabled(File procSelfCgroup, File mountInfo) {\n+        if (procSelfCgroup.canRead() && mountInfo.canRead()) {\n+            try(BufferedReader fileReader = new BufferedReader(new FileReader(procSelfCgroup))) {\n+                String lineCgroup = null;\n+                for (String cgroupLine = fileReader.readLine(); cgroupLine != null && !cgroupLine.isEmpty(); cgroupLine = fileReader.readLine()) {\n+                    if (lineCgroup == null && cgroupLine.startsWith(\"0:\")) {\n+                        lineCgroup = cgroupLine;\n+                    }\n+                    if (MEMORY_CGROUP.matcher(cgroupLine).matches()) {\n+                        lineCgroup = cgroupLine;\n+                    }\n+                }\n+                if (lineCgroup != null) {\n+                    CgroupFiles cgroupFilesTest = null;\n+                    try(BufferedReader fileMountInfoReader = new BufferedReader(new FileReader(mountInfo))) {\n+                        for (String mountLine = fileMountInfoReader.readLine(); mountLine != null && !mountLine.isEmpty(); mountLine = fileMountInfoReader.readLine()) {\n+                            String foundRegex = applyCgroup2Regex(mountLine);\n+                            if (foundRegex != null) {\n+                                cgroupFilesTest = verifyCgroup2Available(lineCgroup, new File(foundRegex));\n+                                if (cgroupFilesTest != null) return cgroupFilesTest;\n+                            }\n+                            foundRegex = applyCgroup1Regex(mountLine);\n+                            if (foundRegex != null) {\n+                                cgroupFilesTest = verifyCgroup1Available(new File(foundRegex));\n+                                if (cgroupFilesTest != null) return cgroupFilesTest;\n+                            }\n+                        }\n+                    }", "originalCommit": "cbbcb7c3aae0ddd5182020c5e1ad77b666512275", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY1Mzg5MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1211#discussion_r453653891", "bodyText": "Why is an empty line used as a stop condition for the parsing? Isn't it enough to stop when readLine() produces null?\nIn fact, isn't it enough to do:\nString cgroupLine = fileReader.readLine()\nwhile (cgroupLine != null) {\n  ...\n  cgroupLine = fileReader.readLine()\n}", "author": "eyalkoren", "createdAt": "2020-07-13T13:35:56Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/SystemMetrics.java", "diffHunk": "@@ -78,26 +97,133 @@\n     @Nullable\n     private final Method virtualProcessMemory;\n     private final File memInfoFile;\n+    @Nullable\n+    private final CgroupFiles cgroupFiles;\n \n     public SystemMetrics() {\n-        this(new File(\"/proc/meminfo\"));\n+        this(new File(\"/proc/meminfo\"), new File(PROC_SELF_CGROUP), new File(PROC_SELF_MOUNTINFO));\n     }\n \n-    SystemMetrics(File memInfoFile) {\n+    SystemMetrics(File memInfoFile, File procSelfCgroup, File mountInfo) {\n         this.operatingSystemBean = ManagementFactory.getOperatingSystemMXBean();\n         this.systemCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getSystemCpuLoad\");\n         this.processCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getProcessCpuLoad\");\n         this.freeMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getFreePhysicalMemorySize\");\n         this.totalMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getTotalPhysicalMemorySize\");\n         this.virtualProcessMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getCommittedVirtualMemorySize\");\n         this.memInfoFile = memInfoFile;\n+\n+        cgroupFiles = verifyCgroupEnabled(procSelfCgroup, mountInfo);\n+    }\n+\n+    public CgroupFiles verifyCgroupEnabled(File procSelfCgroup, File mountInfo) {\n+        if (procSelfCgroup.canRead() && mountInfo.canRead()) {\n+            try(BufferedReader fileReader = new BufferedReader(new FileReader(procSelfCgroup))) {\n+                String lineCgroup = null;\n+                for (String cgroupLine = fileReader.readLine(); cgroupLine != null && !cgroupLine.isEmpty(); cgroupLine = fileReader.readLine()) {", "originalCommit": "cbbcb7c3aae0ddd5182020c5e1ad77b666512275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE3NTA0MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1211#discussion_r455175041", "bodyText": "I used the same logic that was used previously on metricRegistry.addUnlessNan(\"system.memory.total\", ....\nIf it was previuosly done this way I believe it safe parser this system files in this way", "author": "tanquetav", "createdAt": "2020-07-15T16:24:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY1Mzg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY1NjcyNw==", "url": "https://github.com/elastic/apm-agent-java/pull/1211#discussion_r453656727", "bodyText": "Same as above - looks like a complicated for loop", "author": "eyalkoren", "createdAt": "2020-07-13T13:40:05Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/SystemMetrics.java", "diffHunk": "@@ -78,26 +97,133 @@\n     @Nullable\n     private final Method virtualProcessMemory;\n     private final File memInfoFile;\n+    @Nullable\n+    private final CgroupFiles cgroupFiles;\n \n     public SystemMetrics() {\n-        this(new File(\"/proc/meminfo\"));\n+        this(new File(\"/proc/meminfo\"), new File(PROC_SELF_CGROUP), new File(PROC_SELF_MOUNTINFO));\n     }\n \n-    SystemMetrics(File memInfoFile) {\n+    SystemMetrics(File memInfoFile, File procSelfCgroup, File mountInfo) {\n         this.operatingSystemBean = ManagementFactory.getOperatingSystemMXBean();\n         this.systemCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getSystemCpuLoad\");\n         this.processCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getProcessCpuLoad\");\n         this.freeMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getFreePhysicalMemorySize\");\n         this.totalMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getTotalPhysicalMemorySize\");\n         this.virtualProcessMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getCommittedVirtualMemorySize\");\n         this.memInfoFile = memInfoFile;\n+\n+        cgroupFiles = verifyCgroupEnabled(procSelfCgroup, mountInfo);\n+    }\n+\n+    public CgroupFiles verifyCgroupEnabled(File procSelfCgroup, File mountInfo) {\n+        if (procSelfCgroup.canRead() && mountInfo.canRead()) {\n+            try(BufferedReader fileReader = new BufferedReader(new FileReader(procSelfCgroup))) {\n+                String lineCgroup = null;\n+                for (String cgroupLine = fileReader.readLine(); cgroupLine != null && !cgroupLine.isEmpty(); cgroupLine = fileReader.readLine()) {\n+                    if (lineCgroup == null && cgroupLine.startsWith(\"0:\")) {\n+                        lineCgroup = cgroupLine;\n+                    }\n+                    if (MEMORY_CGROUP.matcher(cgroupLine).matches()) {\n+                        lineCgroup = cgroupLine;\n+                    }\n+                }\n+                if (lineCgroup != null) {\n+                    CgroupFiles cgroupFilesTest = null;\n+                    try(BufferedReader fileMountInfoReader = new BufferedReader(new FileReader(mountInfo))) {\n+                        for (String mountLine = fileMountInfoReader.readLine(); mountLine != null && !mountLine.isEmpty(); mountLine = fileMountInfoReader.readLine()) {", "originalCommit": "cbbcb7c3aae0ddd5182020c5e1ad77b666512275", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY2NjAzMw==", "url": "https://github.com/elastic/apm-agent-java/pull/1211#discussion_r453666033", "bodyText": "Same as in cgroup1", "author": "eyalkoren", "createdAt": "2020-07-13T13:53:17Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/SystemMetrics.java", "diffHunk": "@@ -60,9 +63,25 @@\n  * under Apache License 2.0\n  */\n public class SystemMetrics extends AbstractLifecycleListener {\n-\n+    public static final String PROC_SELF_CGROUP = \"/proc/self/cgroup\";\n+    public static final String SYS_FS_CGROUP = \"/sys/fs/cgroup\";\n+    public static final String PROC_SELF_MOUNTINFO = \"/proc/self/mountinfo\";\n     private final OperatingSystemMXBean operatingSystemBean;\n \n+    final private List<WildcardMatcher> inactiveMemoryRelevantLines = Arrays.asList(caseSensitiveMatcher(\"inactive_file *\"));\n+\n+    private static String CGROUP1_MAX_MEMORY = \"memory.limit_in_bytes\";\n+    private static String CGROUP1_USED_MEMORY = \"memory.usage_in_bytes\";\n+    private static String CGROUP1_STAT_MEMORY = \"memory.stat\";\n+    private static String CGROUP2_MAX_MEMORY = \"memory.max\";\n+    private static String CGROUP2_USED_MEMORY = \"memory.current\";\n+    private static String CGROUP2_STAT_MEMORY = \"memory.stat\";", "originalCommit": "cbbcb7c3aae0ddd5182020c5e1ad77b666512275", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY3MTE2NA==", "url": "https://github.com/elastic/apm-agent-java/pull/1211#discussion_r453671164", "bodyText": "Same code - should be extracted into one method", "author": "eyalkoren", "createdAt": "2020-07-13T14:00:14Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/SystemMetrics.java", "diffHunk": "@@ -78,26 +97,133 @@\n     @Nullable\n     private final Method virtualProcessMemory;\n     private final File memInfoFile;\n+    @Nullable\n+    private final CgroupFiles cgroupFiles;\n \n     public SystemMetrics() {\n-        this(new File(\"/proc/meminfo\"));\n+        this(new File(\"/proc/meminfo\"), new File(PROC_SELF_CGROUP), new File(PROC_SELF_MOUNTINFO));\n     }\n \n-    SystemMetrics(File memInfoFile) {\n+    SystemMetrics(File memInfoFile, File procSelfCgroup, File mountInfo) {\n         this.operatingSystemBean = ManagementFactory.getOperatingSystemMXBean();\n         this.systemCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getSystemCpuLoad\");\n         this.processCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getProcessCpuLoad\");\n         this.freeMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getFreePhysicalMemorySize\");\n         this.totalMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getTotalPhysicalMemorySize\");\n         this.virtualProcessMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getCommittedVirtualMemorySize\");\n         this.memInfoFile = memInfoFile;\n+\n+        cgroupFiles = verifyCgroupEnabled(procSelfCgroup, mountInfo);\n+    }\n+\n+    public CgroupFiles verifyCgroupEnabled(File procSelfCgroup, File mountInfo) {\n+        if (procSelfCgroup.canRead() && mountInfo.canRead()) {\n+            try(BufferedReader fileReader = new BufferedReader(new FileReader(procSelfCgroup))) {\n+                String lineCgroup = null;\n+                for (String cgroupLine = fileReader.readLine(); cgroupLine != null && !cgroupLine.isEmpty(); cgroupLine = fileReader.readLine()) {\n+                    if (lineCgroup == null && cgroupLine.startsWith(\"0:\")) {\n+                        lineCgroup = cgroupLine;\n+                    }\n+                    if (MEMORY_CGROUP.matcher(cgroupLine).matches()) {\n+                        lineCgroup = cgroupLine;\n+                    }\n+                }\n+                if (lineCgroup != null) {\n+                    CgroupFiles cgroupFilesTest = null;\n+                    try(BufferedReader fileMountInfoReader = new BufferedReader(new FileReader(mountInfo))) {\n+                        for (String mountLine = fileMountInfoReader.readLine(); mountLine != null && !mountLine.isEmpty(); mountLine = fileMountInfoReader.readLine()) {\n+                            String foundRegex = applyCgroup2Regex(mountLine);\n+                            if (foundRegex != null) {\n+                                cgroupFilesTest = verifyCgroup2Available(lineCgroup, new File(foundRegex));\n+                                if (cgroupFilesTest != null) return cgroupFilesTest;\n+                            }\n+                            foundRegex = applyCgroup1Regex(mountLine);\n+                            if (foundRegex != null) {\n+                                cgroupFilesTest = verifyCgroup1Available(new File(foundRegex));\n+                                if (cgroupFilesTest != null) return cgroupFilesTest;\n+                            }\n+                        }\n+                    }\n+                    // Fall back to /sys/fs/cgroup if not found on mountinfo\n+                    cgroupFilesTest = verifyCgroup2Available(lineCgroup, new File(SYS_FS_CGROUP));\n+                    if (cgroupFilesTest != null) return cgroupFilesTest;\n+                    cgroupFilesTest = verifyCgroup1Available( new File(SYS_FS_CGROUP + File.pathSeparator + \"memory\"));\n+                    if (cgroupFilesTest != null) return cgroupFilesTest;\n+\n+                }\n+            } catch (Exception e) {\n+            }\n+        }\n+        return null;\n+    }\n+    String applyCgroup1Regex(String mountLine) {\n+        Matcher matcher = CGROUP1_MOUNT_POINT.matcher(mountLine);\n+        if (matcher.matches()) {\n+            return matcher.group(1);\n+        }\n+        return null;\n+    }\n+    String applyCgroup2Regex(String mountLine) {\n+        Matcher matcher = CGROUP2_MOUNT_POINT.matcher(mountLine);\n+        if (matcher.matches()) {\n+            return matcher.group(1);\n+        }\n+        return null;\n+    }", "originalCommit": "cbbcb7c3aae0ddd5182020c5e1ad77b666512275", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY3MTU4OQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1211#discussion_r453671589", "bodyText": "Very similar. Please extract common code", "author": "eyalkoren", "createdAt": "2020-07-13T14:00:50Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/SystemMetrics.java", "diffHunk": "@@ -78,26 +97,133 @@\n     @Nullable\n     private final Method virtualProcessMemory;\n     private final File memInfoFile;\n+    @Nullable\n+    private final CgroupFiles cgroupFiles;\n \n     public SystemMetrics() {\n-        this(new File(\"/proc/meminfo\"));\n+        this(new File(\"/proc/meminfo\"), new File(PROC_SELF_CGROUP), new File(PROC_SELF_MOUNTINFO));\n     }\n \n-    SystemMetrics(File memInfoFile) {\n+    SystemMetrics(File memInfoFile, File procSelfCgroup, File mountInfo) {\n         this.operatingSystemBean = ManagementFactory.getOperatingSystemMXBean();\n         this.systemCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getSystemCpuLoad\");\n         this.processCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getProcessCpuLoad\");\n         this.freeMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getFreePhysicalMemorySize\");\n         this.totalMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getTotalPhysicalMemorySize\");\n         this.virtualProcessMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getCommittedVirtualMemorySize\");\n         this.memInfoFile = memInfoFile;\n+\n+        cgroupFiles = verifyCgroupEnabled(procSelfCgroup, mountInfo);\n+    }\n+\n+    public CgroupFiles verifyCgroupEnabled(File procSelfCgroup, File mountInfo) {\n+        if (procSelfCgroup.canRead() && mountInfo.canRead()) {\n+            try(BufferedReader fileReader = new BufferedReader(new FileReader(procSelfCgroup))) {\n+                String lineCgroup = null;\n+                for (String cgroupLine = fileReader.readLine(); cgroupLine != null && !cgroupLine.isEmpty(); cgroupLine = fileReader.readLine()) {\n+                    if (lineCgroup == null && cgroupLine.startsWith(\"0:\")) {\n+                        lineCgroup = cgroupLine;\n+                    }\n+                    if (MEMORY_CGROUP.matcher(cgroupLine).matches()) {\n+                        lineCgroup = cgroupLine;\n+                    }\n+                }\n+                if (lineCgroup != null) {\n+                    CgroupFiles cgroupFilesTest = null;\n+                    try(BufferedReader fileMountInfoReader = new BufferedReader(new FileReader(mountInfo))) {\n+                        for (String mountLine = fileMountInfoReader.readLine(); mountLine != null && !mountLine.isEmpty(); mountLine = fileMountInfoReader.readLine()) {\n+                            String foundRegex = applyCgroup2Regex(mountLine);\n+                            if (foundRegex != null) {\n+                                cgroupFilesTest = verifyCgroup2Available(lineCgroup, new File(foundRegex));\n+                                if (cgroupFilesTest != null) return cgroupFilesTest;\n+                            }\n+                            foundRegex = applyCgroup1Regex(mountLine);\n+                            if (foundRegex != null) {\n+                                cgroupFilesTest = verifyCgroup1Available(new File(foundRegex));\n+                                if (cgroupFilesTest != null) return cgroupFilesTest;\n+                            }\n+                        }\n+                    }\n+                    // Fall back to /sys/fs/cgroup if not found on mountinfo\n+                    cgroupFilesTest = verifyCgroup2Available(lineCgroup, new File(SYS_FS_CGROUP));\n+                    if (cgroupFilesTest != null) return cgroupFilesTest;\n+                    cgroupFilesTest = verifyCgroup1Available( new File(SYS_FS_CGROUP + File.pathSeparator + \"memory\"));\n+                    if (cgroupFilesTest != null) return cgroupFilesTest;\n+\n+                }\n+            } catch (Exception e) {\n+            }\n+        }\n+        return null;\n+    }\n+    String applyCgroup1Regex(String mountLine) {\n+        Matcher matcher = CGROUP1_MOUNT_POINT.matcher(mountLine);\n+        if (matcher.matches()) {\n+            return matcher.group(1);\n+        }\n+        return null;\n+    }\n+    String applyCgroup2Regex(String mountLine) {\n+        Matcher matcher = CGROUP2_MOUNT_POINT.matcher(mountLine);\n+        if (matcher.matches()) {\n+            return matcher.group(1);\n+        }\n+        return null;\n+    }\n+    private CgroupFiles verifyCgroup2Available(String lineCgroup, File mountDiscovered) throws IOException {\n+        final String[] cgroupSplit = StringUtils.split(lineCgroup, ':');\n+        // Checking cgroup2\n+        File maxMemory = new File(mountDiscovered, cgroupSplit[cgroupSplit.length - 1] + \"/\" + CGROUP2_MAX_MEMORY);\n+        if (maxMemory.canRead()) {\n+            try(BufferedReader fileReaderMem = new BufferedReader(new FileReader(maxMemory))) {\n+                String memMaxLine = fileReaderMem.readLine();\n+                if (!\"max\".equalsIgnoreCase(memMaxLine)) {\n+                    return new CgroupFiles(maxMemory,\n+                        new File(mountDiscovered, cgroupSplit[cgroupSplit.length - 1] + \"/\" + CGROUP2_USED_MEMORY),\n+                        new File(mountDiscovered, cgroupSplit[cgroupSplit.length - 1] + \"/\" + CGROUP2_STAT_MEMORY));\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private CgroupFiles verifyCgroup1Available(File mountDiscovered) throws IOException {\n+        // Checking cgroup1\n+        File maxMemory = new File(mountDiscovered, CGROUP1_MAX_MEMORY);\n+        if (maxMemory.canRead()) {\n+            try(BufferedReader fileReaderMem = new BufferedReader(new FileReader(maxMemory))) {\n+                String memMaxLine = fileReaderMem.readLine();\n+                long memMax = Long.parseLong(memMaxLine);\n+                if (memMax < UNLIMITED) { // Cgroup1 use a contant to disabled limits\n+                    return new CgroupFiles(maxMemory,\n+                        new File(mountDiscovered, CGROUP1_USED_MEMORY),\n+                        new File(mountDiscovered, CGROUP1_STAT_MEMORY));\n+                }\n+            }\n+        }\n+        return null;\n     }", "originalCommit": "cbbcb7c3aae0ddd5182020c5e1ad77b666512275", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY3NDE1OA==", "url": "https://github.com/elastic/apm-agent-java/pull/1211#discussion_r453674158", "bodyText": "Let's not use a wildcard matcher here, search for exact line instead. Split each line and look at the first part for both inactive_file and total_inactive_file, preferring total_inactive_file if exists.", "author": "eyalkoren", "createdAt": "2020-07-13T14:04:32Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/SystemMetrics.java", "diffHunk": "@@ -78,26 +97,133 @@\n     @Nullable\n     private final Method virtualProcessMemory;\n     private final File memInfoFile;\n+    @Nullable\n+    private final CgroupFiles cgroupFiles;\n \n     public SystemMetrics() {\n-        this(new File(\"/proc/meminfo\"));\n+        this(new File(\"/proc/meminfo\"), new File(PROC_SELF_CGROUP), new File(PROC_SELF_MOUNTINFO));\n     }\n \n-    SystemMetrics(File memInfoFile) {\n+    SystemMetrics(File memInfoFile, File procSelfCgroup, File mountInfo) {\n         this.operatingSystemBean = ManagementFactory.getOperatingSystemMXBean();\n         this.systemCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getSystemCpuLoad\");\n         this.processCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getProcessCpuLoad\");\n         this.freeMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getFreePhysicalMemorySize\");\n         this.totalMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getTotalPhysicalMemorySize\");\n         this.virtualProcessMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getCommittedVirtualMemorySize\");\n         this.memInfoFile = memInfoFile;\n+\n+        cgroupFiles = verifyCgroupEnabled(procSelfCgroup, mountInfo);\n+    }\n+\n+    public CgroupFiles verifyCgroupEnabled(File procSelfCgroup, File mountInfo) {\n+        if (procSelfCgroup.canRead() && mountInfo.canRead()) {\n+            try(BufferedReader fileReader = new BufferedReader(new FileReader(procSelfCgroup))) {\n+                String lineCgroup = null;\n+                for (String cgroupLine = fileReader.readLine(); cgroupLine != null && !cgroupLine.isEmpty(); cgroupLine = fileReader.readLine()) {\n+                    if (lineCgroup == null && cgroupLine.startsWith(\"0:\")) {\n+                        lineCgroup = cgroupLine;\n+                    }\n+                    if (MEMORY_CGROUP.matcher(cgroupLine).matches()) {\n+                        lineCgroup = cgroupLine;\n+                    }\n+                }\n+                if (lineCgroup != null) {\n+                    CgroupFiles cgroupFilesTest = null;\n+                    try(BufferedReader fileMountInfoReader = new BufferedReader(new FileReader(mountInfo))) {\n+                        for (String mountLine = fileMountInfoReader.readLine(); mountLine != null && !mountLine.isEmpty(); mountLine = fileMountInfoReader.readLine()) {\n+                            String foundRegex = applyCgroup2Regex(mountLine);\n+                            if (foundRegex != null) {\n+                                cgroupFilesTest = verifyCgroup2Available(lineCgroup, new File(foundRegex));\n+                                if (cgroupFilesTest != null) return cgroupFilesTest;\n+                            }\n+                            foundRegex = applyCgroup1Regex(mountLine);\n+                            if (foundRegex != null) {\n+                                cgroupFilesTest = verifyCgroup1Available(new File(foundRegex));\n+                                if (cgroupFilesTest != null) return cgroupFilesTest;\n+                            }\n+                        }\n+                    }\n+                    // Fall back to /sys/fs/cgroup if not found on mountinfo\n+                    cgroupFilesTest = verifyCgroup2Available(lineCgroup, new File(SYS_FS_CGROUP));\n+                    if (cgroupFilesTest != null) return cgroupFilesTest;\n+                    cgroupFilesTest = verifyCgroup1Available( new File(SYS_FS_CGROUP + File.pathSeparator + \"memory\"));\n+                    if (cgroupFilesTest != null) return cgroupFilesTest;\n+\n+                }\n+            } catch (Exception e) {\n+            }\n+        }\n+        return null;\n+    }\n+    String applyCgroup1Regex(String mountLine) {\n+        Matcher matcher = CGROUP1_MOUNT_POINT.matcher(mountLine);\n+        if (matcher.matches()) {\n+            return matcher.group(1);\n+        }\n+        return null;\n+    }\n+    String applyCgroup2Regex(String mountLine) {\n+        Matcher matcher = CGROUP2_MOUNT_POINT.matcher(mountLine);\n+        if (matcher.matches()) {\n+            return matcher.group(1);\n+        }\n+        return null;\n+    }\n+    private CgroupFiles verifyCgroup2Available(String lineCgroup, File mountDiscovered) throws IOException {\n+        final String[] cgroupSplit = StringUtils.split(lineCgroup, ':');\n+        // Checking cgroup2\n+        File maxMemory = new File(mountDiscovered, cgroupSplit[cgroupSplit.length - 1] + \"/\" + CGROUP2_MAX_MEMORY);\n+        if (maxMemory.canRead()) {\n+            try(BufferedReader fileReaderMem = new BufferedReader(new FileReader(maxMemory))) {\n+                String memMaxLine = fileReaderMem.readLine();\n+                if (!\"max\".equalsIgnoreCase(memMaxLine)) {\n+                    return new CgroupFiles(maxMemory,\n+                        new File(mountDiscovered, cgroupSplit[cgroupSplit.length - 1] + \"/\" + CGROUP2_USED_MEMORY),\n+                        new File(mountDiscovered, cgroupSplit[cgroupSplit.length - 1] + \"/\" + CGROUP2_STAT_MEMORY));\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private CgroupFiles verifyCgroup1Available(File mountDiscovered) throws IOException {\n+        // Checking cgroup1\n+        File maxMemory = new File(mountDiscovered, CGROUP1_MAX_MEMORY);\n+        if (maxMemory.canRead()) {\n+            try(BufferedReader fileReaderMem = new BufferedReader(new FileReader(maxMemory))) {\n+                String memMaxLine = fileReaderMem.readLine();\n+                long memMax = Long.parseLong(memMaxLine);\n+                if (memMax < UNLIMITED) { // Cgroup1 use a contant to disabled limits\n+                    return new CgroupFiles(maxMemory,\n+                        new File(mountDiscovered, CGROUP1_USED_MEMORY),\n+                        new File(mountDiscovered, CGROUP1_STAT_MEMORY));\n+                }\n+            }\n+        }\n+        return null;\n     }\n \n     @Override\n     public void start(ElasticApmTracer tracer) {\n         bindTo(tracer.getMetricRegistry());\n     }\n \n+    private double getInactiveMemory() {\n+        try(BufferedReader fileReaderStatFile = new BufferedReader(new FileReader(cgroupFiles.getStatMemory()))) {\n+            long sum = 0;\n+            for (String statLine = fileReaderStatFile.readLine(); statLine != null && !statLine.isEmpty(); statLine = fileReaderStatFile.readLine()) {\n+                if (WildcardMatcher.isAnyMatch(inactiveMemoryRelevantLines, statLine)) {", "originalCommit": "cbbcb7c3aae0ddd5182020c5e1ad77b666512275", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY4MDQ5MA==", "url": "https://github.com/elastic/apm-agent-java/pull/1211#discussion_r453680490", "bodyText": "No need to look at unlimited", "author": "eyalkoren", "createdAt": "2020-07-13T14:14:10Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/SystemMetrics.java", "diffHunk": "@@ -78,26 +97,133 @@\n     @Nullable\n     private final Method virtualProcessMemory;\n     private final File memInfoFile;\n+    @Nullable\n+    private final CgroupFiles cgroupFiles;\n \n     public SystemMetrics() {\n-        this(new File(\"/proc/meminfo\"));\n+        this(new File(\"/proc/meminfo\"), new File(PROC_SELF_CGROUP), new File(PROC_SELF_MOUNTINFO));\n     }\n \n-    SystemMetrics(File memInfoFile) {\n+    SystemMetrics(File memInfoFile, File procSelfCgroup, File mountInfo) {\n         this.operatingSystemBean = ManagementFactory.getOperatingSystemMXBean();\n         this.systemCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getSystemCpuLoad\");\n         this.processCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getProcessCpuLoad\");\n         this.freeMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getFreePhysicalMemorySize\");\n         this.totalMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getTotalPhysicalMemorySize\");\n         this.virtualProcessMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getCommittedVirtualMemorySize\");\n         this.memInfoFile = memInfoFile;\n+\n+        cgroupFiles = verifyCgroupEnabled(procSelfCgroup, mountInfo);\n+    }\n+\n+    public CgroupFiles verifyCgroupEnabled(File procSelfCgroup, File mountInfo) {\n+        if (procSelfCgroup.canRead() && mountInfo.canRead()) {\n+            try(BufferedReader fileReader = new BufferedReader(new FileReader(procSelfCgroup))) {\n+                String lineCgroup = null;\n+                for (String cgroupLine = fileReader.readLine(); cgroupLine != null && !cgroupLine.isEmpty(); cgroupLine = fileReader.readLine()) {\n+                    if (lineCgroup == null && cgroupLine.startsWith(\"0:\")) {\n+                        lineCgroup = cgroupLine;\n+                    }\n+                    if (MEMORY_CGROUP.matcher(cgroupLine).matches()) {\n+                        lineCgroup = cgroupLine;\n+                    }\n+                }\n+                if (lineCgroup != null) {\n+                    CgroupFiles cgroupFilesTest = null;\n+                    try(BufferedReader fileMountInfoReader = new BufferedReader(new FileReader(mountInfo))) {\n+                        for (String mountLine = fileMountInfoReader.readLine(); mountLine != null && !mountLine.isEmpty(); mountLine = fileMountInfoReader.readLine()) {\n+                            String foundRegex = applyCgroup2Regex(mountLine);\n+                            if (foundRegex != null) {\n+                                cgroupFilesTest = verifyCgroup2Available(lineCgroup, new File(foundRegex));\n+                                if (cgroupFilesTest != null) return cgroupFilesTest;\n+                            }\n+                            foundRegex = applyCgroup1Regex(mountLine);\n+                            if (foundRegex != null) {\n+                                cgroupFilesTest = verifyCgroup1Available(new File(foundRegex));\n+                                if (cgroupFilesTest != null) return cgroupFilesTest;\n+                            }\n+                        }\n+                    }\n+                    // Fall back to /sys/fs/cgroup if not found on mountinfo\n+                    cgroupFilesTest = verifyCgroup2Available(lineCgroup, new File(SYS_FS_CGROUP));\n+                    if (cgroupFilesTest != null) return cgroupFilesTest;\n+                    cgroupFilesTest = verifyCgroup1Available( new File(SYS_FS_CGROUP + File.pathSeparator + \"memory\"));\n+                    if (cgroupFilesTest != null) return cgroupFilesTest;\n+\n+                }\n+            } catch (Exception e) {\n+            }\n+        }\n+        return null;\n+    }\n+    String applyCgroup1Regex(String mountLine) {\n+        Matcher matcher = CGROUP1_MOUNT_POINT.matcher(mountLine);\n+        if (matcher.matches()) {\n+            return matcher.group(1);\n+        }\n+        return null;\n+    }\n+    String applyCgroup2Regex(String mountLine) {\n+        Matcher matcher = CGROUP2_MOUNT_POINT.matcher(mountLine);\n+        if (matcher.matches()) {\n+            return matcher.group(1);\n+        }\n+        return null;\n+    }\n+    private CgroupFiles verifyCgroup2Available(String lineCgroup, File mountDiscovered) throws IOException {\n+        final String[] cgroupSplit = StringUtils.split(lineCgroup, ':');\n+        // Checking cgroup2\n+        File maxMemory = new File(mountDiscovered, cgroupSplit[cgroupSplit.length - 1] + \"/\" + CGROUP2_MAX_MEMORY);\n+        if (maxMemory.canRead()) {\n+            try(BufferedReader fileReaderMem = new BufferedReader(new FileReader(maxMemory))) {\n+                String memMaxLine = fileReaderMem.readLine();\n+                if (!\"max\".equalsIgnoreCase(memMaxLine)) {\n+                    return new CgroupFiles(maxMemory,\n+                        new File(mountDiscovered, cgroupSplit[cgroupSplit.length - 1] + \"/\" + CGROUP2_USED_MEMORY),\n+                        new File(mountDiscovered, cgroupSplit[cgroupSplit.length - 1] + \"/\" + CGROUP2_STAT_MEMORY));\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private CgroupFiles verifyCgroup1Available(File mountDiscovered) throws IOException {\n+        // Checking cgroup1\n+        File maxMemory = new File(mountDiscovered, CGROUP1_MAX_MEMORY);\n+        if (maxMemory.canRead()) {\n+            try(BufferedReader fileReaderMem = new BufferedReader(new FileReader(maxMemory))) {\n+                String memMaxLine = fileReaderMem.readLine();\n+                long memMax = Long.parseLong(memMaxLine);\n+                if (memMax < UNLIMITED) { // Cgroup1 use a contant to disabled limits", "originalCommit": "cbbcb7c3aae0ddd5182020c5e1ad77b666512275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI0MzE0MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1211#discussion_r455243141", "bodyText": "I read about to track cgroup itens even if it is not limited.\nMy afraid is that on normal use cases, like running on a linux environment these metrics be collected, and it will track all host values, like memory usage, it will be memory usage of all OS, because nothing is limited on cgroup.", "author": "tanquetav", "createdAt": "2020-07-15T18:06:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY4MDQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY4NTc0NQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1211#discussion_r453685745", "bodyText": "Ohh, so in cgroup2 max represents unlimited memory for the cgroup?\nThis is important! We just decided to transfer the special treatment of unlimited max to the UI, but we rely on sending the special numeric representing unlimited. We can't send a string. We can send the unlimited value, but it makes more sense, we better not send anything if we see max and make sure UI properly deals with that.", "author": "eyalkoren", "createdAt": "2020-07-13T14:21:40Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/SystemMetrics.java", "diffHunk": "@@ -78,26 +97,133 @@\n     @Nullable\n     private final Method virtualProcessMemory;\n     private final File memInfoFile;\n+    @Nullable\n+    private final CgroupFiles cgroupFiles;\n \n     public SystemMetrics() {\n-        this(new File(\"/proc/meminfo\"));\n+        this(new File(\"/proc/meminfo\"), new File(PROC_SELF_CGROUP), new File(PROC_SELF_MOUNTINFO));\n     }\n \n-    SystemMetrics(File memInfoFile) {\n+    SystemMetrics(File memInfoFile, File procSelfCgroup, File mountInfo) {\n         this.operatingSystemBean = ManagementFactory.getOperatingSystemMXBean();\n         this.systemCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getSystemCpuLoad\");\n         this.processCpuUsage = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getProcessCpuLoad\");\n         this.freeMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getFreePhysicalMemorySize\");\n         this.totalMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getTotalPhysicalMemorySize\");\n         this.virtualProcessMemory = JmxUtils.getOperatingSystemMBeanMethod(operatingSystemBean, \"getCommittedVirtualMemorySize\");\n         this.memInfoFile = memInfoFile;\n+\n+        cgroupFiles = verifyCgroupEnabled(procSelfCgroup, mountInfo);\n+    }\n+\n+    public CgroupFiles verifyCgroupEnabled(File procSelfCgroup, File mountInfo) {\n+        if (procSelfCgroup.canRead() && mountInfo.canRead()) {\n+            try(BufferedReader fileReader = new BufferedReader(new FileReader(procSelfCgroup))) {\n+                String lineCgroup = null;\n+                for (String cgroupLine = fileReader.readLine(); cgroupLine != null && !cgroupLine.isEmpty(); cgroupLine = fileReader.readLine()) {\n+                    if (lineCgroup == null && cgroupLine.startsWith(\"0:\")) {\n+                        lineCgroup = cgroupLine;\n+                    }\n+                    if (MEMORY_CGROUP.matcher(cgroupLine).matches()) {\n+                        lineCgroup = cgroupLine;\n+                    }\n+                }\n+                if (lineCgroup != null) {\n+                    CgroupFiles cgroupFilesTest = null;\n+                    try(BufferedReader fileMountInfoReader = new BufferedReader(new FileReader(mountInfo))) {\n+                        for (String mountLine = fileMountInfoReader.readLine(); mountLine != null && !mountLine.isEmpty(); mountLine = fileMountInfoReader.readLine()) {\n+                            String foundRegex = applyCgroup2Regex(mountLine);\n+                            if (foundRegex != null) {\n+                                cgroupFilesTest = verifyCgroup2Available(lineCgroup, new File(foundRegex));\n+                                if (cgroupFilesTest != null) return cgroupFilesTest;\n+                            }\n+                            foundRegex = applyCgroup1Regex(mountLine);\n+                            if (foundRegex != null) {\n+                                cgroupFilesTest = verifyCgroup1Available(new File(foundRegex));\n+                                if (cgroupFilesTest != null) return cgroupFilesTest;\n+                            }\n+                        }\n+                    }\n+                    // Fall back to /sys/fs/cgroup if not found on mountinfo\n+                    cgroupFilesTest = verifyCgroup2Available(lineCgroup, new File(SYS_FS_CGROUP));\n+                    if (cgroupFilesTest != null) return cgroupFilesTest;\n+                    cgroupFilesTest = verifyCgroup1Available( new File(SYS_FS_CGROUP + File.pathSeparator + \"memory\"));\n+                    if (cgroupFilesTest != null) return cgroupFilesTest;\n+\n+                }\n+            } catch (Exception e) {\n+            }\n+        }\n+        return null;\n+    }\n+    String applyCgroup1Regex(String mountLine) {\n+        Matcher matcher = CGROUP1_MOUNT_POINT.matcher(mountLine);\n+        if (matcher.matches()) {\n+            return matcher.group(1);\n+        }\n+        return null;\n+    }\n+    String applyCgroup2Regex(String mountLine) {\n+        Matcher matcher = CGROUP2_MOUNT_POINT.matcher(mountLine);\n+        if (matcher.matches()) {\n+            return matcher.group(1);\n+        }\n+        return null;\n+    }\n+    private CgroupFiles verifyCgroup2Available(String lineCgroup, File mountDiscovered) throws IOException {\n+        final String[] cgroupSplit = StringUtils.split(lineCgroup, ':');\n+        // Checking cgroup2\n+        File maxMemory = new File(mountDiscovered, cgroupSplit[cgroupSplit.length - 1] + \"/\" + CGROUP2_MAX_MEMORY);\n+        if (maxMemory.canRead()) {\n+            try(BufferedReader fileReaderMem = new BufferedReader(new FileReader(maxMemory))) {\n+                String memMaxLine = fileReaderMem.readLine();\n+                if (!\"max\".equalsIgnoreCase(memMaxLine)) {", "originalCommit": "cbbcb7c3aae0ddd5182020c5e1ad77b666512275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE4MTUyNw==", "url": "https://github.com/elastic/apm-agent-java/pull/1211#discussion_r455181527", "bodyText": "Yes, on cgroup2 it is a string. what about to use the UNLIMITED constant from cgroup1 ?", "author": "tanquetav", "createdAt": "2020-07-15T16:34:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY4NTc0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTUxNTEyMg==", "url": "https://github.com/elastic/apm-agent-java/pull/1211#discussion_r455515122", "bodyText": "Yes, that's what I poorly tried to say in my comment - we could do that, but it doesn't make a lot of sense...\nLetting the UI even be aware of the UNLIMITED numeric value was a way to implement once, instead of making all APM agents aware of that. Now that I am aware of the literal UNLIMITED value in v2, we must handle in agents, as the metric value in the intake API and Elasticsearch would be numeric.\nI think that making sure agents omit the value when it is max and making sure UI expects that is enough.", "author": "eyalkoren", "createdAt": "2020-07-16T05:16:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY4NTc0NQ=="}], "type": "inlineReview"}, {"oid": "44d63f7849cd234d63fd8f15f29a58d05c242c18", "url": "https://github.com/elastic/apm-agent-java/commit/44d63f7849cd234d63fd8f15f29a58d05c242c18", "message": "Suggested changes for cgroup metrics", "committedDate": "2020-07-14T09:01:09Z", "type": "commit"}, {"oid": "69d3c788fb77a8c11216b9cf1d0c450ace6c5c22", "url": "https://github.com/elastic/apm-agent-java/commit/69d3c788fb77a8c11216b9cf1d0c450ace6c5c22", "message": "Merge pull request #1 from eyalkoren/suggested-changes-for-cgroup-metrics\n\nSuggested changes for cgroup metrics", "committedDate": "2020-07-15T22:13:50Z", "type": "commit"}, {"oid": "69572c09432d51a0dba29dae181a5ba954f26e11", "url": "https://github.com/elastic/apm-agent-java/commit/69572c09432d51a0dba29dae181a5ba954f26e11", "message": "Split CGroupFile", "committedDate": "2020-07-16T00:08:12Z", "type": "forcePushed"}, {"oid": "44d0561a75813275064de1915edaabca54e7bfe1", "url": "https://github.com/elastic/apm-agent-java/commit/44d0561a75813275064de1915edaabca54e7bfe1", "message": "Split CGroupFile", "committedDate": "2020-07-16T01:35:59Z", "type": "commit"}, {"oid": "44d0561a75813275064de1915edaabca54e7bfe1", "url": "https://github.com/elastic/apm-agent-java/commit/44d0561a75813275064de1915edaabca54e7bfe1", "message": "Split CGroupFile", "committedDate": "2020-07-16T01:35:59Z", "type": "forcePushed"}, {"oid": "e343b2d19d30bf477c0ab91797df6c3ea819f9f6", "url": "https://github.com/elastic/apm-agent-java/commit/e343b2d19d30bf477c0ab91797df6c3ea819f9f6", "message": "Increase test coverage", "committedDate": "2020-07-16T10:57:40Z", "type": "commit"}, {"oid": "20d0bf4a8dd0ca35df95e8e2d1bfb4d50664213f", "url": "https://github.com/elastic/apm-agent-java/commit/20d0bf4a8dd0ca35df95e8e2d1bfb4d50664213f", "message": "Merge branch 'master' into cgroup_support", "committedDate": "2020-07-16T14:16:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyODk5Ng==", "url": "https://github.com/elastic/apm-agent-java/pull/1211#discussion_r460828996", "bodyText": "We revisited this, so we need to restore the unlimited check for v1 as well so, like we did in v2, if the value stored in the memory.limit_in_bytes file is the special UNLIMITED value, we shouldn't report it (meaning - use null for the maxMemoryFile).", "author": "eyalkoren", "createdAt": "2020-07-27T11:37:56Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/CGroupMetrics.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.metrics.builtin;\n+\n+import co.elastic.apm.agent.context.AbstractLifecycleListener;\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.matcher.WildcardMatcher;\n+import co.elastic.apm.agent.metrics.DoubleSupplier;\n+import co.elastic.apm.agent.metrics.Labels;\n+import co.elastic.apm.agent.metrics.MetricRegistry;\n+import co.elastic.apm.agent.util.JmxUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.stagemonitor.util.StringUtils;\n+\n+import javax.annotation.Nullable;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.OperatingSystemMXBean;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static co.elastic.apm.agent.matcher.WildcardMatcher.caseSensitiveMatcher;\n+\n+/**\n+ * Record metrics related to the CGroup Usage.\n+ */\n+public class CGroupMetrics extends AbstractLifecycleListener {\n+\n+    public static final String PROC_SELF_CGROUP = \"/proc/self/cgroup\";\n+    public static final String PROC_SELF_MOUNTINFO = \"/proc/self/mountinfo\";\n+    public static final String DEFAULT_SYS_FS_CGROUP = \"/sys/fs/cgroup\";\n+\n+    static final String CGROUP1_MAX_MEMORY = \"memory.limit_in_bytes\";\n+    static final String CGROUP1_USED_MEMORY = \"memory.usage_in_bytes\";\n+    static final String CGROUP2_MAX_MEMORY = \"memory.max\";\n+    static final String CGROUP2_USED_MEMORY = \"memory.current\";\n+    static final String CGROUP_MEMORY_STAT = \"memory.stat\";\n+\n+    static final Pattern MEMORY_CGROUP = Pattern.compile(\"^\\\\d+\\\\:memory\\\\:.*\");\n+    static final Pattern CGROUP1_MOUNT_POINT = Pattern.compile(\"^\\\\d+? \\\\d+? .+? .+? (.*?) .*cgroup.*memory.*\");\n+    static final Pattern CGROUP2_MOUNT_POINT = Pattern.compile(\"^\\\\d+? \\\\d+? .+? .+? (.*?) .*cgroup2.*cgroup.*\");\n+\n+    private static final Logger logger = LoggerFactory.getLogger(CGroupMetrics.class);\n+\n+\n+    @Nullable\n+    private final CgroupFiles cgroupFiles;\n+\n+    public CGroupMetrics() {\n+        this(new File(PROC_SELF_CGROUP), new File(PROC_SELF_MOUNTINFO));\n+    }\n+\n+    CGroupMetrics( File procSelfCgroup, File mountInfo) {\n+        cgroupFiles = findCgroupFiles(procSelfCgroup, mountInfo);\n+    }\n+\n+    /**\n+     * Implementing the cgroup metrics spec - https://github.com/elastic/apm/blob/master/docs/agents/agent-development.md#cgroup-metrics\n+     *\n+     * @param procSelfCgroup /proc/self/cgroup file\n+     * @param mountInfo      /proc/self/mountinfo file\n+     * @return a holder for the memory cgroup files if found or {@code null} if not found\n+     */\n+    @Nullable\n+    public CgroupFiles findCgroupFiles(File procSelfCgroup, File mountInfo) {\n+        if (procSelfCgroup.canRead()) {\n+            String cgroupLine = null;\n+            try (BufferedReader fileReader = new BufferedReader(new FileReader(procSelfCgroup))) {\n+                String currentLine = fileReader.readLine();\n+                while (currentLine != null) {\n+                    if (cgroupLine == null && currentLine.startsWith(\"0:\")) {\n+                        cgroupLine = currentLine;\n+                    }\n+                    if (MEMORY_CGROUP.matcher(currentLine).matches()) {\n+                        cgroupLine = currentLine;\n+                        break;\n+                    }\n+                    currentLine = fileReader.readLine();\n+                }\n+\n+                if (cgroupLine != null) {\n+                    CgroupFiles cgroupFiles;\n+\n+                    // Try to discover the cgroup fs path from the mountinfo file\n+                    if (mountInfo.canRead()) {\n+                        String mountLine = null;\n+                        try (BufferedReader fileMountInfoReader = new BufferedReader(new FileReader(mountInfo))) {\n+                            mountLine = fileMountInfoReader.readLine();\n+                            while (mountLine != null) {\n+                                // cgroup v2\n+                                String rootCgroupFsPath = applyCgroupRegex(CGROUP2_MOUNT_POINT, mountLine);\n+                                if (rootCgroupFsPath != null) {\n+                                    cgroupFiles = createCgroup2Files(cgroupLine, new File(rootCgroupFsPath));\n+                                    if (cgroupFiles != null) {\n+                                        return cgroupFiles;\n+                                    }\n+                                }\n+\n+                                // cgroup v1\n+                                String memoryMountPath = applyCgroupRegex(CGROUP1_MOUNT_POINT, mountLine);\n+                                if (memoryMountPath != null) {\n+                                    cgroupFiles = createCgroup1Files(\n+                                        new File(memoryMountPath)\n+                                    );\n+                                    if (cgroupFiles != null) {\n+                                        return cgroupFiles;\n+                                    }\n+                                }\n+\n+                                mountLine = fileMountInfoReader.readLine();\n+                            }\n+                        } catch (Exception e) {\n+                            logger.info(\"Failed to discover memory mount files path based on mountinfo line '{}'.\", mountLine);\n+                        }\n+                    } else {\n+                        logger.info(\"Failed to find/read /proc/self/mountinfo file. Looking for memory files in /sys/fs/cgroup.\");\n+                    }\n+\n+                    // Failed to auto-discover the cgroup fs path from mountinfo, fall back to /sys/fs/cgroup\n+                    // cgroup v2\n+                    cgroupFiles = createCgroup2Files(cgroupLine, new File(DEFAULT_SYS_FS_CGROUP));\n+                    if (cgroupFiles != null) {\n+                        return cgroupFiles;\n+                    }\n+                    // cgroup v1\n+                    cgroupFiles = createCgroup1Files(new File(DEFAULT_SYS_FS_CGROUP + File.pathSeparator + \"memory\"));\n+                    if (cgroupFiles != null) {\n+                        return cgroupFiles;\n+                    }\n+                } else {\n+                    logger.warn(\"No /proc/self/cgroup file line matched the tested patterns. Cgroup metrics will not be reported.\");\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Failed to discover memory mount files path based on cgroup line '\" + cgroupLine +\n+                    \"'. Cgroup metrics will not be reported,\", e);\n+            }\n+        } else {\n+            logger.debug(\"Cannot find/read /proc/self/cgroup file. Cgroup metrics will not be reported.\");\n+        }\n+        return null;\n+    }\n+\n+    @Nullable\n+    String applyCgroupRegex(Pattern regex, String mountLine) {\n+        Matcher matcher = regex.matcher(mountLine);\n+        if (matcher.matches()) {\n+            return matcher.group(1);\n+        }\n+        return null;\n+    }\n+\n+    @Nullable\n+    private CgroupFiles createCgroup2Files(String cgroupLine, File rootCgroupFsPath) throws IOException {\n+        final String[] cgroupLineParts = StringUtils.split(cgroupLine, ':');\n+        String sliceSubdir = cgroupLineParts[cgroupLineParts.length - 1];\n+        File maxMemoryFile = new File(rootCgroupFsPath, sliceSubdir + File.separatorChar + CGROUP2_MAX_MEMORY);\n+        if (maxMemoryFile.canRead()) {\n+            try (BufferedReader maxFileReader = new BufferedReader(new FileReader(maxMemoryFile))) {\n+                String memMaxLine = maxFileReader.readLine();\n+                if (\"max\".equalsIgnoreCase(memMaxLine)) {\n+                    // Make sure we don't send the max metric when cgroup is not bound to a memory limit\n+                    maxMemoryFile = null;\n+                }\n+            }\n+            return new CgroupFiles(\n+                maxMemoryFile,\n+                new File(rootCgroupFsPath, sliceSubdir + File.separator + CGROUP2_USED_MEMORY),\n+                new File(rootCgroupFsPath, sliceSubdir + File.separator + CGROUP_MEMORY_STAT)\n+            );\n+        }\n+        return null;\n+    }\n+\n+    @Nullable\n+    private CgroupFiles createCgroup1Files(File memoryMountPath) {\n+        File maxMemoryFile = new File(memoryMountPath, CGroupMetrics.CGROUP1_MAX_MEMORY);\n+        if (maxMemoryFile.canRead()) {\n+            // No need for special treatment for the special \"unlimited\" value (0x7ffffffffffff000) - omitted by the UI", "originalCommit": "20d0bf4a8dd0ca35df95e8e2d1bfb4d50664213f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cf271e19082f8f11fdc5b88ed656509d798fd4f3", "url": "https://github.com/elastic/apm-agent-java/commit/cf271e19082f8f11fdc5b88ed656509d798fd4f3", "message": "Merge branch 'master' into cgroup_support", "committedDate": "2020-07-30T20:35:35Z", "type": "commit"}, {"oid": "7827295524d9c17ba61ce0fc203dd46e4c2fe5ac", "url": "https://github.com/elastic/apm-agent-java/commit/7827295524d9c17ba61ce0fc203dd46e4c2fe5ac", "message": "Cgroup unlimited memory check and documentation", "committedDate": "2020-07-30T21:29:45Z", "type": "commit"}, {"oid": "51e7aba721da7c6c2a45ea74eeadbac248f56d76", "url": "https://github.com/elastic/apm-agent-java/commit/51e7aba721da7c6c2a45ea74eeadbac248f56d76", "message": "Small fixes", "committedDate": "2020-08-03T12:55:45Z", "type": "commit"}, {"oid": "1a4e2dbdb17fd85f6983332d8e1a86f6ddaa7283", "url": "https://github.com/elastic/apm-agent-java/commit/1a4e2dbdb17fd85f6983332d8e1a86f6ddaa7283", "message": "minor style changes", "committedDate": "2020-08-18T14:42:58Z", "type": "commit"}]}