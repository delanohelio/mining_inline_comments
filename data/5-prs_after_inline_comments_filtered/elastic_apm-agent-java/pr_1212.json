{"pr_number": 1212, "pr_title": "issue-557 added automatically span creation for DispatcherTypes: FORWARD, INCLUDE, ERROR", "pr_createdAt": "2020-06-01T18:47:37Z", "pr_url": "https://github.com/elastic/apm-agent-java/pull/1212", "timeline": [{"oid": "e33b14d3c9653ded790ad9609470b83f792a204c", "url": "https://github.com/elastic/apm-agent-java/commit/e33b14d3c9653ded790ad9609470b83f792a204c", "message": "issue-557 added automatically span creation for DispatcherTypes: FORWARD, INCLUDE, ERROR", "committedDate": "2020-06-01T20:01:28Z", "type": "forcePushed"}, {"oid": "722d42a183c275c40baeeac707fcf1c121d790c5", "url": "https://github.com/elastic/apm-agent-java/commit/722d42a183c275c40baeeac707fcf1c121d790c5", "message": "clear", "committedDate": "2020-06-02T11:29:30Z", "type": "forcePushed"}, {"oid": "99a0789c1ecd67af76eef0a2b199311605b892e8", "url": "https://github.com/elastic/apm-agent-java/commit/99a0789c1ecd67af76eef0a2b199311605b892e8", "message": "clear", "committedDate": "2020-06-02T11:35:36Z", "type": "forcePushed"}, {"oid": "6eef95e0b3154103e28940fe58474d994b65ab1e", "url": "https://github.com/elastic/apm-agent-java/commit/6eef95e0b3154103e28940fe58474d994b65ab1e", "message": "added path info for span name of FORWARD, INCLUDE dispatcher types.", "committedDate": "2020-06-09T05:26:35Z", "type": "forcePushed"}, {"oid": "db73c877c9ba112d75d5dd2bff71ecca2c509365", "url": "https://github.com/elastic/apm-agent-java/commit/db73c877c9ba112d75d5dd2bff71ecca2c509365", "message": "delete testTransactionReportingWithErrorHandling test", "committedDate": "2020-06-09T18:52:46Z", "type": "forcePushed"}, {"oid": "ede29338fb5a47532d42ec1b61a46634299cd594", "url": "https://github.com/elastic/apm-agent-java/commit/ede29338fb5a47532d42ec1b61a46634299cd594", "message": "return setFramework", "committedDate": "2020-06-14T20:36:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI4Mjk3Nw==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r442282977", "bodyText": "This is allocating four String objects every time. Please use the AbstractSpan#appendToName() API instead (create it before).\nSame for the other ones.", "author": "eyalkoren", "createdAt": "2020-06-18T14:45:38Z", "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -143,6 +156,37 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n             servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n                 request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n                 request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+        } else if (transaction == null && servletRequest instanceof HttpServletRequest) {\n+            final AbstractSpan<?> parent = tracer.getActive();\n+            if (parent != null) {\n+                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                DispatcherType dispatcherType = request.getDispatcherType();\n+                boolean isAllowedType = false;\n+                String spanAction = null, spanName = null;\n+                if (dispatcherType == DispatcherType.FORWARD) {\n+                    String pathInfo = request.getPathInfo();\n+                    spanName = FORWARD + SPACE + request.getServletPath() + (pathInfo != null ? pathInfo : EMPTY);", "originalCommit": "96711728acd8fb3d4b652c676cf29ee656ecd085", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwODI4Mg==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r465908282", "bodyText": "repalced with appendToName", "author": "kananindzya", "createdAt": "2020-08-05T18:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI4Mjk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI5MTE2Ng==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r442291166", "bodyText": "This else statement looks misplaced. Its content should go inside the if above and you can do else with the servletRequest.getDispatcherType() == DispatcherType.REQUEST check.", "author": "eyalkoren", "createdAt": "2020-06-18T14:56:27Z", "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -143,6 +156,37 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n             servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n                 request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n                 request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+        } else if (transaction == null && servletRequest instanceof HttpServletRequest) {", "originalCommit": "96711728acd8fb3d4b652c676cf29ee656ecd085", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI5ODQzMw==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r442298433", "bodyText": "Why using RequestDispatcher.FORWARD_SERVLET_PATH in this case? I think we want the error page path. The transaction will contain the original servlet path.", "author": "eyalkoren", "createdAt": "2020-06-18T15:06:55Z", "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -143,6 +156,37 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n             servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n                 request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n                 request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+        } else if (transaction == null && servletRequest instanceof HttpServletRequest) {\n+            final AbstractSpan<?> parent = tracer.getActive();\n+            if (parent != null) {\n+                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                DispatcherType dispatcherType = request.getDispatcherType();\n+                boolean isAllowedType = false;\n+                String spanAction = null, spanName = null;\n+                if (dispatcherType == DispatcherType.FORWARD) {\n+                    String pathInfo = request.getPathInfo();\n+                    spanName = FORWARD + SPACE + request.getServletPath() + (pathInfo != null ? pathInfo : EMPTY);\n+                    spanAction = FORWARD_SPAN_ACTION;\n+                    isAllowedType = true;\n+                } else if (dispatcherType == DispatcherType.INCLUDE) {\n+                    Object pathInfo = request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);\n+                    spanName = INCLUDE + SPACE + request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH) + (pathInfo != null ? pathInfo : EMPTY);\n+                    spanAction = INCLUDE_SPAN_ACTION;\n+                    isAllowedType = true;\n+                } else if (dispatcherType == DispatcherType.ERROR) {\n+                    spanName = ERROR + SPACE + request.getAttribute(RequestDispatcher.FORWARD_SERVLET_PATH);", "originalCommit": "96711728acd8fb3d4b652c676cf29ee656ecd085", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwODk5NA==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r465908994", "bodyText": "changed to getting\nObject servletPath = request.getServletPath();", "author": "kananindzya", "createdAt": "2020-08-05T18:05:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI5ODQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMwMDU3MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r442300571", "bodyText": "Please check if you already get the Exception object stored in the RequestDispatcher.ERROR_EXCEPTION attribute somewhere else. If not, let's create and send an error here with captureException through the parent span.", "author": "eyalkoren", "createdAt": "2020-06-18T15:10:09Z", "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -143,6 +156,37 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n             servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n                 request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n                 request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+        } else if (transaction == null && servletRequest instanceof HttpServletRequest) {\n+            final AbstractSpan<?> parent = tracer.getActive();\n+            if (parent != null) {\n+                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                DispatcherType dispatcherType = request.getDispatcherType();\n+                boolean isAllowedType = false;\n+                String spanAction = null, spanName = null;\n+                if (dispatcherType == DispatcherType.FORWARD) {\n+                    String pathInfo = request.getPathInfo();\n+                    spanName = FORWARD + SPACE + request.getServletPath() + (pathInfo != null ? pathInfo : EMPTY);\n+                    spanAction = FORWARD_SPAN_ACTION;\n+                    isAllowedType = true;\n+                } else if (dispatcherType == DispatcherType.INCLUDE) {\n+                    Object pathInfo = request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);\n+                    spanName = INCLUDE + SPACE + request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH) + (pathInfo != null ? pathInfo : EMPTY);\n+                    spanAction = INCLUDE_SPAN_ACTION;\n+                    isAllowedType = true;\n+                } else if (dispatcherType == DispatcherType.ERROR) {\n+                    spanName = ERROR + SPACE + request.getAttribute(RequestDispatcher.FORWARD_SERVLET_PATH);\n+                    spanAction = ERROR_SPAN_ACTION;\n+                    isAllowedType = true;", "originalCommit": "96711728acd8fb3d4b652c676cf29ee656ecd085", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMxMTExMA==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r442311110", "bodyText": "You need to assert that exactly the expected spans are captured. Potentially, this can pass if two non-related spans are captured.\nYou can filter the span collection for each and assert you get exactly one that contains the required info.", "author": "eyalkoren", "createdAt": "2020-06-18T15:25:21Z", "path": "integration-tests/application-server-integration-tests/src/test/java/co/elastic/apm/servlet/tests/ServletApiTestApp.java", "diffHunk": "@@ -75,6 +78,58 @@ private void testCaptureBody(AbstractServletContainerIntegrationTest test) throw\n         }\n     }\n \n+    private void testTransactionReportingWithForward(AbstractServletContainerIntegrationTest test) throws Exception {\n+        String pathToTest = \"/simple-webapp\" + \"/forward\";\n+        boolean isExistForwardSpan = false;\n+        boolean isExistDbH2QuerySpan = false;\n+        test.clearMockServerLog();\n+\n+        test.executeAndValidateRequest(pathToTest, \"Hello World\", 200, null);\n+\n+        JsonNode transaction = test.assertTransactionReported(pathToTest, 200);\n+\n+        List<JsonNode> reportedSpans = test.getReportedSpans();\n+        assertThat(reportedSpans.size()).isEqualTo(2);\n+\n+        for (JsonNode span : test.getReportedSpans()) {\n+            String spanType = span.get(\"type\").textValue();\n+            if (\"servlet.request-dispatcher.forward\".equals(spanType)) {\n+                isExistForwardSpan = true;\n+                assertThat(span.get(\"name\").textValue()).isEqualTo(\"FORWARD /servlet\");\n+            } else if (\"db.h2.query\".equals(spanType)) {\n+                isExistDbH2QuerySpan = true;\n+            }\n+        }", "originalCommit": "96711728acd8fb3d4b652c676cf29ee656ecd085", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwOTk4Ng==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r465909986", "bodyText": "added filter before assert.", "author": "kananindzya", "createdAt": "2020-08-05T18:07:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMxMTExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3NzUxOA==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r449977518", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final String FORWARD = \"FORWARD\";\n          \n          \n            \n                private static final String INCLUDE = \"INCLUDE\";\n          \n          \n            \n                private static final String ERROR = \"ERROR\";\n          \n          \n            \n                private static final String SPACE = \" \";\n          \n          \n            \n                private static final String EMPTY = \"\";\n          \n          \n            \n                private static final String FORWARD = \"FORWARD \";\n          \n          \n            \n                private static final String INCLUDE = \"INCLUDE \";\n          \n          \n            \n                private static final String ERROR = \"ERROR \";", "author": "eyalkoren", "createdAt": "2020-07-06T04:27:39Z", "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -60,6 +63,16 @@\n public class ServletApiAdvice {\n \n     private static final String FRAMEWORK_NAME = \"Servlet API\";\n+    private static final String SPAN_TYPE = \"servlet\";\n+    private static final String SPAN_SUBTYPE = \"request-dispatcher\";\n+    private static final String FORWARD_SPAN_ACTION = \"forward\";\n+    private static final String INCLUDE_SPAN_ACTION = \"include\";\n+    private static final String ERROR_SPAN_ACTION = \"error\";\n+    private static final String FORWARD = \"FORWARD\";\n+    private static final String INCLUDE = \"INCLUDE\";\n+    private static final String ERROR = \"ERROR\";\n+    private static final String SPACE = \" \";\n+    private static final String EMPTY = \"\";", "originalCommit": "4be406076c63ed4421d7b9e4fa1a9faec3914b18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3Nzg2Mg==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r449977862", "bodyText": "Why is the transaction == null required here? Seems it will always be null", "author": "eyalkoren", "createdAt": "2020-07-06T04:29:14Z", "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -100,49 +122,96 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n         if (tracer.isRunning() &&\n             servletTransactionHelper != null &&\n             servletRequest instanceof HttpServletRequest &&\n-            servletRequest.getDispatcherType() == DispatcherType.REQUEST &&\n             !Boolean.TRUE.equals(excluded.get())) {\n+            if (servletRequest.getDispatcherType() == DispatcherType.REQUEST) {\n+                ServletContext servletContext = servletRequest.getServletContext();\n+                if (servletContext != null) {\n+                    // this makes sure service name discovery also works when attaching at runtime\n+                    determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n+                }\n \n-            ServletContext servletContext = servletRequest.getServletContext();\n-            if (servletContext != null) {\n-                // this makes sure service name discovery also works when attaching at runtime\n-                determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n-            }\n-\n-            final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-            if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n-                ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n-                    ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n-                if (helper != null) {\n-                    transaction = helper.createAndActivateTransaction(request);\n+                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n+                    ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n+                        ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n+                    if (helper != null) {\n+                        transaction = helper.createAndActivateTransaction(request);\n+                    }\n                 }\n-            }\n \n-            if (transaction == null) {\n-                // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n-                excluded.set(Boolean.TRUE);\n-                return;\n-            }\n-            final Request req = transaction.getContext().getRequest();\n-            if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n-                if (request.getCookies() != null) {\n-                    for (Cookie cookie : request.getCookies()) {\n-                        req.addCookie(cookie.getName(), cookie.getValue());\n+                if (transaction == null) {\n+                    // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n+                    excluded.set(Boolean.TRUE);\n+                    return;\n+                }\n+                final Request req = transaction.getContext().getRequest();\n+                if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n+                    if (request.getCookies() != null) {\n+                        for (Cookie cookie : request.getCookies()) {\n+                            req.addCookie(cookie.getName(), cookie.getValue());\n+                        }\n+                    }\n+                    final Enumeration<String> headerNames = request.getHeaderNames();\n+                    if (headerNames != null) {\n+                        while (headerNames.hasMoreElements()) {\n+                            final String headerName = headerNames.nextElement();\n+                            req.addHeader(headerName, request.getHeaders(headerName));\n+                        }\n                     }\n                 }\n-                final Enumeration<String> headerNames = request.getHeaderNames();\n-                if (headerNames != null) {\n-                    while (headerNames.hasMoreElements()) {\n-                        final String headerName = headerNames.nextElement();\n-                        req.addHeader(headerName, request.getHeaders(headerName));\n+                transaction.setFrameworkName(FRAMEWORK_NAME);\n+\n+                servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n+                    request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n+                    request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+            } else if (transaction == null) {", "originalCommit": "4be406076c63ed4421d7b9e4fa1a9faec3914b18", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwOTY0OA==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r465909648", "bodyText": "i changed here condition to ->\nservletRequest.getDispatcherType() != DispatcherType.ASYNC", "author": "kananindzya", "createdAt": "2020-08-05T18:06:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3Nzg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3Nzk0NQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r449977945", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    span.withAction(FORWARD_SPAN_ACTION);\n          \n          \n            \n                                    span.withAction(INCLUDE_SPAN_ACTION);", "author": "eyalkoren", "createdAt": "2020-07-06T04:29:41Z", "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -100,49 +122,96 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n         if (tracer.isRunning() &&\n             servletTransactionHelper != null &&\n             servletRequest instanceof HttpServletRequest &&\n-            servletRequest.getDispatcherType() == DispatcherType.REQUEST &&\n             !Boolean.TRUE.equals(excluded.get())) {\n+            if (servletRequest.getDispatcherType() == DispatcherType.REQUEST) {\n+                ServletContext servletContext = servletRequest.getServletContext();\n+                if (servletContext != null) {\n+                    // this makes sure service name discovery also works when attaching at runtime\n+                    determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n+                }\n \n-            ServletContext servletContext = servletRequest.getServletContext();\n-            if (servletContext != null) {\n-                // this makes sure service name discovery also works when attaching at runtime\n-                determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n-            }\n-\n-            final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-            if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n-                ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n-                    ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n-                if (helper != null) {\n-                    transaction = helper.createAndActivateTransaction(request);\n+                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n+                    ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n+                        ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n+                    if (helper != null) {\n+                        transaction = helper.createAndActivateTransaction(request);\n+                    }\n                 }\n-            }\n \n-            if (transaction == null) {\n-                // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n-                excluded.set(Boolean.TRUE);\n-                return;\n-            }\n-            final Request req = transaction.getContext().getRequest();\n-            if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n-                if (request.getCookies() != null) {\n-                    for (Cookie cookie : request.getCookies()) {\n-                        req.addCookie(cookie.getName(), cookie.getValue());\n+                if (transaction == null) {\n+                    // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n+                    excluded.set(Boolean.TRUE);\n+                    return;\n+                }\n+                final Request req = transaction.getContext().getRequest();\n+                if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n+                    if (request.getCookies() != null) {\n+                        for (Cookie cookie : request.getCookies()) {\n+                            req.addCookie(cookie.getName(), cookie.getValue());\n+                        }\n+                    }\n+                    final Enumeration<String> headerNames = request.getHeaderNames();\n+                    if (headerNames != null) {\n+                        while (headerNames.hasMoreElements()) {\n+                            final String headerName = headerNames.nextElement();\n+                            req.addHeader(headerName, request.getHeaders(headerName));\n+                        }\n                     }\n                 }\n-                final Enumeration<String> headerNames = request.getHeaderNames();\n-                if (headerNames != null) {\n-                    while (headerNames.hasMoreElements()) {\n-                        final String headerName = headerNames.nextElement();\n-                        req.addHeader(headerName, request.getHeaders(headerName));\n+                transaction.setFrameworkName(FRAMEWORK_NAME);\n+\n+                servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n+                    request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n+                    request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+            } else if (transaction == null) {\n+                final AbstractSpan<?> parent = tracer.getActive();\n+                if (parent != null) {\n+                    final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                    DispatcherType dispatcherType = request.getDispatcherType();\n+                    boolean isSpannableDispatcherType = false;\n+                    span = parent.createSpan()\n+                        .withType(SPAN_TYPE)\n+                        .withSubtype(SPAN_SUBTYPE);\n+\n+                    if (dispatcherType == DispatcherType.FORWARD) {\n+                        span.appendToName(FORWARD)\n+                            .appendToName(SPACE)\n+                            .appendToName(request.getServletPath());\n+                        if (request.getPathInfo() != null) {\n+                            span.appendToName(request.getPathInfo());\n+                        }\n+                        span.withAction(FORWARD_SPAN_ACTION);\n+                        isSpannableDispatcherType = true;\n+                    } else if (dispatcherType == DispatcherType.INCLUDE) {\n+                        Object pathInfo = request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);\n+                        Object includeServletPath = request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);\n+                        span.appendToName(INCLUDE)\n+                            .appendToName(SPACE);\n+                        if (includeServletPath != null) {\n+                            span.appendToName((String) includeServletPath);\n+                        }\n+                        if (pathInfo != null) {\n+                            span.appendToName((String) pathInfo);\n+                        }\n+                        span.withAction(FORWARD_SPAN_ACTION);", "originalCommit": "4be406076c63ed4421d7b9e4fa1a9faec3914b18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk4MDU0NA==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r449980544", "bodyText": "Do not create a span unless you know we need one. Currently these spans can leak. You must always end a span you created, like you must always deactivate a span you activated (which you did).\nIn rare cases (this is not one), you may create a span and then requestDiscarding it, but you still must end it.", "author": "eyalkoren", "createdAt": "2020-07-06T04:42:06Z", "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -100,49 +122,96 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n         if (tracer.isRunning() &&\n             servletTransactionHelper != null &&\n             servletRequest instanceof HttpServletRequest &&\n-            servletRequest.getDispatcherType() == DispatcherType.REQUEST &&\n             !Boolean.TRUE.equals(excluded.get())) {\n+            if (servletRequest.getDispatcherType() == DispatcherType.REQUEST) {\n+                ServletContext servletContext = servletRequest.getServletContext();\n+                if (servletContext != null) {\n+                    // this makes sure service name discovery also works when attaching at runtime\n+                    determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n+                }\n \n-            ServletContext servletContext = servletRequest.getServletContext();\n-            if (servletContext != null) {\n-                // this makes sure service name discovery also works when attaching at runtime\n-                determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n-            }\n-\n-            final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-            if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n-                ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n-                    ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n-                if (helper != null) {\n-                    transaction = helper.createAndActivateTransaction(request);\n+                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n+                    ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n+                        ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n+                    if (helper != null) {\n+                        transaction = helper.createAndActivateTransaction(request);\n+                    }\n                 }\n-            }\n \n-            if (transaction == null) {\n-                // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n-                excluded.set(Boolean.TRUE);\n-                return;\n-            }\n-            final Request req = transaction.getContext().getRequest();\n-            if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n-                if (request.getCookies() != null) {\n-                    for (Cookie cookie : request.getCookies()) {\n-                        req.addCookie(cookie.getName(), cookie.getValue());\n+                if (transaction == null) {\n+                    // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n+                    excluded.set(Boolean.TRUE);\n+                    return;\n+                }\n+                final Request req = transaction.getContext().getRequest();\n+                if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n+                    if (request.getCookies() != null) {\n+                        for (Cookie cookie : request.getCookies()) {\n+                            req.addCookie(cookie.getName(), cookie.getValue());\n+                        }\n+                    }\n+                    final Enumeration<String> headerNames = request.getHeaderNames();\n+                    if (headerNames != null) {\n+                        while (headerNames.hasMoreElements()) {\n+                            final String headerName = headerNames.nextElement();\n+                            req.addHeader(headerName, request.getHeaders(headerName));\n+                        }\n                     }\n                 }\n-                final Enumeration<String> headerNames = request.getHeaderNames();\n-                if (headerNames != null) {\n-                    while (headerNames.hasMoreElements()) {\n-                        final String headerName = headerNames.nextElement();\n-                        req.addHeader(headerName, request.getHeaders(headerName));\n+                transaction.setFrameworkName(FRAMEWORK_NAME);\n+\n+                servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n+                    request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n+                    request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+            } else if (transaction == null) {\n+                final AbstractSpan<?> parent = tracer.getActive();\n+                if (parent != null) {\n+                    final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                    DispatcherType dispatcherType = request.getDispatcherType();\n+                    boolean isSpannableDispatcherType = false;\n+                    span = parent.createSpan()\n+                        .withType(SPAN_TYPE)\n+                        .withSubtype(SPAN_SUBTYPE);", "originalCommit": "4be406076c63ed4421d7b9e4fa1a9faec3914b18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk4MTc1Mg==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r449981752", "bodyText": "getNameAsString is allocating a String objects (so two in this comparison).\nThere are better ways to avoid creation of same nested spans. For example, before creating a span, see if the parent span has the same type, subtype and action.\nWhat cases are you trying to prevent with this comparison?", "author": "eyalkoren", "createdAt": "2020-07-06T04:48:40Z", "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -100,49 +122,96 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n         if (tracer.isRunning() &&\n             servletTransactionHelper != null &&\n             servletRequest instanceof HttpServletRequest &&\n-            servletRequest.getDispatcherType() == DispatcherType.REQUEST &&\n             !Boolean.TRUE.equals(excluded.get())) {\n+            if (servletRequest.getDispatcherType() == DispatcherType.REQUEST) {\n+                ServletContext servletContext = servletRequest.getServletContext();\n+                if (servletContext != null) {\n+                    // this makes sure service name discovery also works when attaching at runtime\n+                    determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n+                }\n \n-            ServletContext servletContext = servletRequest.getServletContext();\n-            if (servletContext != null) {\n-                // this makes sure service name discovery also works when attaching at runtime\n-                determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n-            }\n-\n-            final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-            if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n-                ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n-                    ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n-                if (helper != null) {\n-                    transaction = helper.createAndActivateTransaction(request);\n+                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n+                    ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n+                        ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n+                    if (helper != null) {\n+                        transaction = helper.createAndActivateTransaction(request);\n+                    }\n                 }\n-            }\n \n-            if (transaction == null) {\n-                // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n-                excluded.set(Boolean.TRUE);\n-                return;\n-            }\n-            final Request req = transaction.getContext().getRequest();\n-            if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n-                if (request.getCookies() != null) {\n-                    for (Cookie cookie : request.getCookies()) {\n-                        req.addCookie(cookie.getName(), cookie.getValue());\n+                if (transaction == null) {\n+                    // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n+                    excluded.set(Boolean.TRUE);\n+                    return;\n+                }\n+                final Request req = transaction.getContext().getRequest();\n+                if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n+                    if (request.getCookies() != null) {\n+                        for (Cookie cookie : request.getCookies()) {\n+                            req.addCookie(cookie.getName(), cookie.getValue());\n+                        }\n+                    }\n+                    final Enumeration<String> headerNames = request.getHeaderNames();\n+                    if (headerNames != null) {\n+                        while (headerNames.hasMoreElements()) {\n+                            final String headerName = headerNames.nextElement();\n+                            req.addHeader(headerName, request.getHeaders(headerName));\n+                        }\n                     }\n                 }\n-                final Enumeration<String> headerNames = request.getHeaderNames();\n-                if (headerNames != null) {\n-                    while (headerNames.hasMoreElements()) {\n-                        final String headerName = headerNames.nextElement();\n-                        req.addHeader(headerName, request.getHeaders(headerName));\n+                transaction.setFrameworkName(FRAMEWORK_NAME);\n+\n+                servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n+                    request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n+                    request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+            } else if (transaction == null) {\n+                final AbstractSpan<?> parent = tracer.getActive();\n+                if (parent != null) {\n+                    final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                    DispatcherType dispatcherType = request.getDispatcherType();\n+                    boolean isSpannableDispatcherType = false;\n+                    span = parent.createSpan()\n+                        .withType(SPAN_TYPE)\n+                        .withSubtype(SPAN_SUBTYPE);\n+\n+                    if (dispatcherType == DispatcherType.FORWARD) {\n+                        span.appendToName(FORWARD)\n+                            .appendToName(SPACE)\n+                            .appendToName(request.getServletPath());\n+                        if (request.getPathInfo() != null) {\n+                            span.appendToName(request.getPathInfo());\n+                        }\n+                        span.withAction(FORWARD_SPAN_ACTION);\n+                        isSpannableDispatcherType = true;\n+                    } else if (dispatcherType == DispatcherType.INCLUDE) {\n+                        Object pathInfo = request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);\n+                        Object includeServletPath = request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);\n+                        span.appendToName(INCLUDE)\n+                            .appendToName(SPACE);\n+                        if (includeServletPath != null) {\n+                            span.appendToName((String) includeServletPath);\n+                        }\n+                        if (pathInfo != null) {\n+                            span.appendToName((String) pathInfo);\n+                        }\n+                        span.withAction(FORWARD_SPAN_ACTION);\n+                        isSpannableDispatcherType = true;\n+                    } else if (dispatcherType == DispatcherType.ERROR) {\n+                        Object servletPath = request.getServletPath();\n+                        span.appendToName(ERROR)\n+                            .appendToName(SPACE);\n+                        if (servletPath != null) {\n+                            span.appendToName((String) servletPath);\n+                        }\n+                        span.withAction(ERROR_SPAN_ACTION);\n+                        isSpannableDispatcherType = true;\n+                    }\n+                    if (isSpannableDispatcherType && !parent.getNameAsString().equals(span.getNameAsString())) {", "originalCommit": "4be406076c63ed4421d7b9e4fa1a9faec3914b18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "db15630aa76758604b14c0b2365512207fd3a1ac", "url": "https://github.com/elastic/apm-agent-java/commit/db15630aa76758604b14c0b2365512207fd3a1ac", "message": "issue-557 added automatically span creation for DispatcherTypes: FORWARD, INCLUDE, ERROR\nminor fixes with creating span that has same names\nadded path info for span name of FORWARD, INCLUDE dispatcher types.\ndelete testTransactionReportingWithErrorHandling test\nUpdate apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\nCo-authored-by: eyalkoren <41850454+eyalkoren@users.noreply.github.com>\nUpdate apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\nCo-authored-by: eyalkoren <41850454+eyalkoren@users.noreply.github.com>", "committedDate": "2020-08-05T16:21:11Z", "type": "commit"}, {"oid": "e77603e4d1477333942461bf64062d50fe2e104a", "url": "https://github.com/elastic/apm-agent-java/commit/e77603e4d1477333942461bf64062d50fe2e104a", "message": "merged from master", "committedDate": "2020-08-05T17:52:02Z", "type": "commit"}, {"oid": "e77603e4d1477333942461bf64062d50fe2e104a", "url": "https://github.com/elastic/apm-agent-java/commit/e77603e4d1477333942461bf64062d50fe2e104a", "message": "merged from master", "committedDate": "2020-08-05T17:52:02Z", "type": "forcePushed"}, {"oid": "52b87b92acaaaec5c596f67c873c3859705fa7d7", "url": "https://github.com/elastic/apm-agent-java/commit/52b87b92acaaaec5c596f67c873c3859705fa7d7", "message": "fixed logic with excluded for psans", "committedDate": "2020-08-06T21:48:30Z", "type": "commit"}, {"oid": "c0dee5794e079384260e3539dae85bde745f34d9", "url": "https://github.com/elastic/apm-agent-java/commit/c0dee5794e079384260e3539dae85bde745f34d9", "message": "fixed logic with span creating, before we check that parent span is has same name", "committedDate": "2020-08-07T19:15:15Z", "type": "commit"}, {"oid": "df6c456152ce9e9e57bbdf3a071c992c49369e64", "url": "https://github.com/elastic/apm-agent-java/commit/df6c456152ce9e9e57bbdf3a071c992c49369e64", "message": "Suggested changes", "committedDate": "2020-08-11T13:02:43Z", "type": "commit"}, {"oid": "deed18c5c5d999c9c105c61164fd9a3a28394fdd", "url": "https://github.com/elastic/apm-agent-java/commit/deed18c5c5d999c9c105c61164fd9a3a28394fdd", "message": "Merge pull request #6 from eyalkoren/suggested-changes\n\nSuggested changes", "committedDate": "2020-08-11T16:39:51Z", "type": "commit"}, {"oid": "0dc1a1f568d8be0fe364e63bff92b4834200b73c", "url": "https://github.com/elastic/apm-agent-java/commit/0dc1a1f568d8be0fe364e63bff92b4834200b73c", "message": "added RequestDispatcher.ERROR_EXCEPTION attribute exception handling", "committedDate": "2020-08-11T19:28:23Z", "type": "commit"}, {"oid": "532276b369f6339d1ffaf0dd80848bfdb5d12715", "url": "https://github.com/elastic/apm-agent-java/commit/532276b369f6339d1ffaf0dd80848bfdb5d12715", "message": "Merge remote-tracking branch 'upstream/master' into issue-557-track-spans-request-dispatcher-forward-include", "committedDate": "2020-08-12T06:44:39Z", "type": "commit"}, {"oid": "02605be8d4fb2a99161c4a503a079c150764e1ad", "url": "https://github.com/elastic/apm-agent-java/commit/02605be8d4fb2a99161c4a503a079c150764e1ad", "message": "Error handling", "committedDate": "2020-08-12T07:16:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzNjE1Mg==", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r469036152", "bodyText": "No, we can't do that as we don't know if it's the same exception or not.", "author": "eyalkoren", "createdAt": "2020-08-12T06:37:31Z", "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -253,8 +254,12 @@ public static void onExitServletService(@Advice.Argument(0) ServletRequest servl\n                         Object throwable = request.getAttribute(attributeName);\n                         if (throwable instanceof Throwable) {\n                             t2 = (Throwable) throwable;\n-                            if (!attributeName.equals(\"javax.servlet.error.exception\")) {\n+                            if (!attributeName.equals(RequestDispatcher.ERROR_EXCEPTION)) {\n                                 overrideStatusCodeOnThrowable = false;\n+                            } else {\n+                                if (Boolean.TRUE.equals(isExceptionAttributeCaptured.get())) {\n+                                    t2 = null;\n+                                }", "originalCommit": "0dc1a1f568d8be0fe364e63bff92b4834200b73c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "50290852236aeb820f6ea322844d71a2a94caf61", "url": "https://github.com/elastic/apm-agent-java/commit/50290852236aeb820f6ea322844d71a2a94caf61", "message": "Merge branch 'master' into issue-557-track-spans-request-dispatcher-forward-include\n\nAlso apply few minor changes", "committedDate": "2020-08-21T14:30:44Z", "type": "commit"}]}