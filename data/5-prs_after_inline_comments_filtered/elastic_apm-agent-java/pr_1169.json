{"pr_number": 1169, "pr_title": "Use log4j2 for logging", "pr_createdAt": "2020-04-30T15:36:43Z", "pr_url": "https://github.com/elastic/apm-agent-java/pull/1169", "timeline": [{"oid": "2c11027256053f79e78f1ad1635535e159309e41", "url": "https://github.com/elastic/apm-agent-java/commit/2c11027256053f79e78f1ad1635535e159309e41", "message": "Tail files and notify FileChangeListener", "committedDate": "2020-04-06T14:31:22Z", "type": "commit"}, {"oid": "1ad565608426e923d8c9ed668f59015e10f7ceb1", "url": "https://github.com/elastic/apm-agent-java/commit/1ad565608426e923d8c9ed668f59015e10f7ceb1", "message": "ApmServerLogShipper", "committedDate": "2020-04-07T12:57:49Z", "type": "commit"}, {"oid": "ddd348571f0fc902ff7ce0d7bbeb2b33b3ac2a5d", "url": "https://github.com/elastic/apm-agent-java/commit/ddd348571f0fc902ff7ce0d7bbeb2b33b3ac2a5d", "message": "Use log4j2 and ecs-logging-java as opposed to simple-logger\n\nTail that log and send to APM Server to the not yet existing\n/intake/v2/logs endpoint", "committedDate": "2020-04-08T12:24:14Z", "type": "commit"}, {"oid": "7677cd9c715ca30a6c9165b785c250429d7919ac", "url": "https://github.com/elastic/apm-agent-java/commit/7677cd9c715ca30a6c9165b785c250429d7919ac", "message": "Merge remote-tracking branch 'origin/master' into log-shipper", "committedDate": "2020-04-08T12:24:53Z", "type": "commit"}, {"oid": "38b20b1372f0cb918ee920a216d578a9e373300d", "url": "https://github.com/elastic/apm-agent-java/commit/38b20b1372f0cb918ee920a216d578a9e373300d", "message": "Set service.name and event.dataset in logs", "committedDate": "2020-04-08T13:04:40Z", "type": "commit"}, {"oid": "9a8f954ae969dff538648d410a137e79c78758a4", "url": "https://github.com/elastic/apm-agent-java/commit/9a8f954ae969dff538648d410a137e79c78758a4", "message": "Store and restore persistent state about file position", "committedDate": "2020-04-09T07:38:55Z", "type": "commit"}, {"oid": "13b8a2516d9bf067e2dfc0965f7eef04468f6d61", "url": "https://github.com/elastic/apm-agent-java/commit/13b8a2516d9bf067e2dfc0965f7eef04468f6d61", "message": "Store and restore persistent state about file position", "committedDate": "2020-04-09T14:27:06Z", "type": "commit"}, {"oid": "c23aee7caf4954966b3b0780c64270c06251474a", "url": "https://github.com/elastic/apm-agent-java/commit/c23aee7caf4954966b3b0780c64270c06251474a", "message": "Set rollover policy to size 50M max 2", "committedDate": "2020-04-09T14:27:07Z", "type": "commit"}, {"oid": "60db4435427c6e59ddce114b34df6abd4635ca24", "url": "https://github.com/elastic/apm-agent-java/commit/60db4435427c6e59ddce114b34df6abd4635ca24", "message": "Send file metadata", "committedDate": "2020-04-09T14:27:07Z", "type": "commit"}, {"oid": "52013bbdfa3a48ebbe286d98a0ff45b3ba38abc0", "url": "https://github.com/elastic/apm-agent-java/commit/52013bbdfa3a48ebbe286d98a0ff45b3ba38abc0", "message": "Ack/nak state", "committedDate": "2020-04-11T07:10:32Z", "type": "commit"}, {"oid": "350440e38c1971f80290345d31e6638781c53476", "url": "https://github.com/elastic/apm-agent-java/commit/350440e38c1971f80290345d31e6638781c53476", "message": "Look up file by inode if available", "committedDate": "2020-04-17T07:48:02Z", "type": "commit"}, {"oid": "15bc635a15187c8e4d895ff115605bc758c6018e", "url": "https://github.com/elastic/apm-agent-java/commit/15bc635a15187c8e4d895ff115605bc758c6018e", "message": "Add log_file_max_size option", "committedDate": "2020-04-17T07:48:27Z", "type": "commit"}, {"oid": "225b38971bc00faaa252d82b7f8c421e0dcbc15e", "url": "https://github.com/elastic/apm-agent-java/commit/225b38971bc00faaa252d82b7f8c421e0dcbc15e", "message": "No need to set service.name as it's sent in metadata", "committedDate": "2020-04-17T15:54:14Z", "type": "commit"}, {"oid": "eeb4aeb78100396fa65a4c971ed345f49b5633dc", "url": "https://github.com/elastic/apm-agent-java/commit/eeb4aeb78100396fa65a4c971ed345f49b5633dc", "message": "When logging to sout, ship temp log file", "committedDate": "2020-04-20T06:24:21Z", "type": "commit"}, {"oid": "b7c162ba4b8acb1c66e9ea9d3b748b26c9f031ed", "url": "https://github.com/elastic/apm-agent-java/commit/b7c162ba4b8acb1c66e9ea9d3b748b26c9f031ed", "message": "Merge remote-tracking branch 'origin/master' into log-shipper", "committedDate": "2020-04-20T06:24:46Z", "type": "commit"}, {"oid": "a2549ffc1c5e9dd24188af700423b6ce2bdc2d60", "url": "https://github.com/elastic/apm-agent-java/commit/a2549ffc1c5e9dd24188af700423b6ce2bdc2d60", "message": "Fix tests", "committedDate": "2020-04-22T06:22:49Z", "type": "commit"}, {"oid": "61cbbc8ed853b34cdbbc2afa7723c63596065ed4", "url": "https://github.com/elastic/apm-agent-java/commit/61cbbc8ed853b34cdbbc2afa7723c63596065ed4", "message": "Use log.file instead of file\n\nSee also https://github.com/elastic/ecs/pull/802", "committedDate": "2020-04-23T15:05:40Z", "type": "commit"}, {"oid": "05e4324cd179cbf45462a5bff9e003d6fd02d8c6", "url": "https://github.com/elastic/apm-agent-java/commit/05e4324cd179cbf45462a5bff9e003d6fd02d8c6", "message": "Merge remote-tracking branch 'origin/master' into log-shipper", "committedDate": "2020-04-30T14:12:54Z", "type": "commit"}, {"oid": "9ce0f258ab785e9f2774170b1de06a97cc5785f8", "url": "https://github.com/elastic/apm-agent-java/commit/9ce0f258ab785e9f2774170b1de06a97cc5785f8", "message": "Add test for log level OFF", "committedDate": "2020-04-30T14:35:22Z", "type": "commit"}, {"oid": "e859dfae312bc49c96743b090bd459923e54c1d7", "url": "https://github.com/elastic/apm-agent-java/commit/e859dfae312bc49c96743b090bd459923e54c1d7", "message": "Prepare to make this mergable now\n\n- Default to PLAIN_TEXT for log_format_file\n- Make `ship_agent_logs` internal and `false` by default\n- Remove System.err logging in ApmServerLogShipper", "committedDate": "2020-04-30T15:33:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0NzE5Mw==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r419947193", "bodyText": "does it allows to make log4j plugin management work with relocation ? If yes, it might be a good idea to add a comment to make it a bit more explicit.", "author": "SylvainJuge", "createdAt": "2020-05-05T08:34:28Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/logging/Log4j2ConfigurationFactory.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.logging;\n+\n+import co.elastic.apm.agent.bci.ElasticApmAgent;\n+import co.elastic.apm.agent.configuration.CoreConfiguration;\n+import co.elastic.apm.agent.configuration.ServiceNameUtil;\n+import co.elastic.apm.agent.configuration.converter.ByteValue;\n+import co.elastic.logging.log4j2.EcsLayout;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.core.LoggerContext;\n+import org.apache.logging.log4j.core.appender.ConsoleAppender;\n+import org.apache.logging.log4j.core.config.Configuration;\n+import org.apache.logging.log4j.core.config.ConfigurationFactory;\n+import org.apache.logging.log4j.core.config.ConfigurationSource;\n+import org.apache.logging.log4j.core.config.builder.api.AppenderComponentBuilder;\n+import org.apache.logging.log4j.core.config.builder.api.ConfigurationBuilder;\n+import org.apache.logging.log4j.core.config.builder.api.LayoutComponentBuilder;\n+import org.apache.logging.log4j.core.config.builder.api.RootLoggerComponentBuilder;\n+import org.apache.logging.log4j.core.config.builder.impl.BuiltConfiguration;\n+import org.apache.logging.log4j.core.config.plugins.util.PluginManager;\n+import org.stagemonitor.configuration.ConfigurationOption;\n+import org.stagemonitor.configuration.converter.EnumValueConverter;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.AGENT_HOME_PLACEHOLDER;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.DEFAULT_LOG_FILE;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.DEPRECATED_LOG_FILE_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.DEPRECATED_LOG_LEVEL_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_FILE_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_FORMAT_FILE_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_FORMAT_SOUT_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_LEVEL_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.SHIP_AGENT_LOGS;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.SYSTEM_OUT;\n+\n+public class Log4j2ConfigurationFactory extends ConfigurationFactory {\n+\n+    static {\n+        PluginManager.addPackage(EcsLayout.class.getPackage().getName());", "originalCommit": "e859dfae312bc49c96743b090bd459923e54c1d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0OTc4MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r419949781", "bodyText": "probably better to use mkdirs() instead to create parent folders if required.", "author": "SylvainJuge", "createdAt": "2020-05-05T08:39:07Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/logging/Log4j2ConfigurationFactory.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.logging;\n+\n+import co.elastic.apm.agent.bci.ElasticApmAgent;\n+import co.elastic.apm.agent.configuration.CoreConfiguration;\n+import co.elastic.apm.agent.configuration.ServiceNameUtil;\n+import co.elastic.apm.agent.configuration.converter.ByteValue;\n+import co.elastic.logging.log4j2.EcsLayout;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.core.LoggerContext;\n+import org.apache.logging.log4j.core.appender.ConsoleAppender;\n+import org.apache.logging.log4j.core.config.Configuration;\n+import org.apache.logging.log4j.core.config.ConfigurationFactory;\n+import org.apache.logging.log4j.core.config.ConfigurationSource;\n+import org.apache.logging.log4j.core.config.builder.api.AppenderComponentBuilder;\n+import org.apache.logging.log4j.core.config.builder.api.ConfigurationBuilder;\n+import org.apache.logging.log4j.core.config.builder.api.LayoutComponentBuilder;\n+import org.apache.logging.log4j.core.config.builder.api.RootLoggerComponentBuilder;\n+import org.apache.logging.log4j.core.config.builder.impl.BuiltConfiguration;\n+import org.apache.logging.log4j.core.config.plugins.util.PluginManager;\n+import org.stagemonitor.configuration.ConfigurationOption;\n+import org.stagemonitor.configuration.converter.EnumValueConverter;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.AGENT_HOME_PLACEHOLDER;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.DEFAULT_LOG_FILE;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.DEPRECATED_LOG_FILE_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.DEPRECATED_LOG_LEVEL_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_FILE_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_FORMAT_FILE_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_FORMAT_SOUT_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_LEVEL_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.SHIP_AGENT_LOGS;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.SYSTEM_OUT;\n+\n+public class Log4j2ConfigurationFactory extends ConfigurationFactory {\n+\n+    static {\n+        PluginManager.addPackage(EcsLayout.class.getPackage().getName());\n+        PluginManager.addPackage(LoggerContext.class.getPackage().getName());\n+    }\n+\n+    private final List<org.stagemonitor.configuration.source.ConfigurationSource> sources;\n+    private final String ephemeralId;\n+\n+    public Log4j2ConfigurationFactory(List<org.stagemonitor.configuration.source.ConfigurationSource> sources, String ephemeralId) {\n+        this.sources = sources;\n+        this.ephemeralId = ephemeralId;\n+    }\n+\n+    /**\n+     * The ConfigurationRegistry uses and thereby initializes a logger,\n+     * so we can't use it here initialize the {@link ConfigurationOption}s in this class.\n+     */\n+    private static String getValue(String key, List<org.stagemonitor.configuration.source.ConfigurationSource> sources, String defaultValue) {\n+        for (org.stagemonitor.configuration.source.ConfigurationSource source : sources) {\n+            final String value = source.getValue(key);\n+            if (value != null) {\n+                return value;\n+            }\n+        }\n+        return defaultValue;\n+    }\n+\n+    @Nonnull\n+    static String getActualLogFile(@Nullable String agentHome, String logFile) {\n+        if (logFile.equalsIgnoreCase(SYSTEM_OUT)) {\n+            return SYSTEM_OUT;\n+        }\n+        if (logFile.contains(AGENT_HOME_PLACEHOLDER)) {\n+            if (agentHome == null) {\n+                System.err.println(\"Could not resolve \" + AGENT_HOME_PLACEHOLDER + \". Falling back to System.out.\");\n+                return SYSTEM_OUT;\n+            } else {\n+                logFile = logFile.replace(AGENT_HOME_PLACEHOLDER, agentHome);\n+            }\n+        }\n+        logFile = new File(logFile).getAbsolutePath();\n+        final File logDir = new File(logFile).getParentFile();\n+        if (!logDir.exists()) {\n+            logDir.mkdir();", "originalCommit": "e859dfae312bc49c96743b090bd459923e54c1d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1MTIxMw==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r419951213", "bodyText": "for those error/warn messages in system out, we should probably have a prefix + severity level to make it obvious to the user that it comes from Elastic agent. Something like [elastic-apm-agent] WARN.", "author": "SylvainJuge", "createdAt": "2020-05-05T08:41:38Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/logging/Log4j2ConfigurationFactory.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.logging;\n+\n+import co.elastic.apm.agent.bci.ElasticApmAgent;\n+import co.elastic.apm.agent.configuration.CoreConfiguration;\n+import co.elastic.apm.agent.configuration.ServiceNameUtil;\n+import co.elastic.apm.agent.configuration.converter.ByteValue;\n+import co.elastic.logging.log4j2.EcsLayout;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.core.LoggerContext;\n+import org.apache.logging.log4j.core.appender.ConsoleAppender;\n+import org.apache.logging.log4j.core.config.Configuration;\n+import org.apache.logging.log4j.core.config.ConfigurationFactory;\n+import org.apache.logging.log4j.core.config.ConfigurationSource;\n+import org.apache.logging.log4j.core.config.builder.api.AppenderComponentBuilder;\n+import org.apache.logging.log4j.core.config.builder.api.ConfigurationBuilder;\n+import org.apache.logging.log4j.core.config.builder.api.LayoutComponentBuilder;\n+import org.apache.logging.log4j.core.config.builder.api.RootLoggerComponentBuilder;\n+import org.apache.logging.log4j.core.config.builder.impl.BuiltConfiguration;\n+import org.apache.logging.log4j.core.config.plugins.util.PluginManager;\n+import org.stagemonitor.configuration.ConfigurationOption;\n+import org.stagemonitor.configuration.converter.EnumValueConverter;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.AGENT_HOME_PLACEHOLDER;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.DEFAULT_LOG_FILE;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.DEPRECATED_LOG_FILE_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.DEPRECATED_LOG_LEVEL_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_FILE_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_FORMAT_FILE_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_FORMAT_SOUT_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_LEVEL_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.SHIP_AGENT_LOGS;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.SYSTEM_OUT;\n+\n+public class Log4j2ConfigurationFactory extends ConfigurationFactory {\n+\n+    static {\n+        PluginManager.addPackage(EcsLayout.class.getPackage().getName());\n+        PluginManager.addPackage(LoggerContext.class.getPackage().getName());\n+    }\n+\n+    private final List<org.stagemonitor.configuration.source.ConfigurationSource> sources;\n+    private final String ephemeralId;\n+\n+    public Log4j2ConfigurationFactory(List<org.stagemonitor.configuration.source.ConfigurationSource> sources, String ephemeralId) {\n+        this.sources = sources;\n+        this.ephemeralId = ephemeralId;\n+    }\n+\n+    /**\n+     * The ConfigurationRegistry uses and thereby initializes a logger,\n+     * so we can't use it here initialize the {@link ConfigurationOption}s in this class.\n+     */\n+    private static String getValue(String key, List<org.stagemonitor.configuration.source.ConfigurationSource> sources, String defaultValue) {\n+        for (org.stagemonitor.configuration.source.ConfigurationSource source : sources) {\n+            final String value = source.getValue(key);\n+            if (value != null) {\n+                return value;\n+            }\n+        }\n+        return defaultValue;\n+    }\n+\n+    @Nonnull\n+    static String getActualLogFile(@Nullable String agentHome, String logFile) {\n+        if (logFile.equalsIgnoreCase(SYSTEM_OUT)) {\n+            return SYSTEM_OUT;\n+        }\n+        if (logFile.contains(AGENT_HOME_PLACEHOLDER)) {\n+            if (agentHome == null) {\n+                System.err.println(\"Could not resolve \" + AGENT_HOME_PLACEHOLDER + \". Falling back to System.out.\");", "originalCommit": "e859dfae312bc49c96743b090bd459923e54c1d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1MzYwNQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r419953605", "bodyText": "Probably better to use OS compliant path separator instead of a raw / character.\nAlso, do we need to make path to this file configurable ?", "author": "SylvainJuge", "createdAt": "2020-05-05T08:45:47Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/logging/Log4j2ConfigurationFactory.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.logging;\n+\n+import co.elastic.apm.agent.bci.ElasticApmAgent;\n+import co.elastic.apm.agent.configuration.CoreConfiguration;\n+import co.elastic.apm.agent.configuration.ServiceNameUtil;\n+import co.elastic.apm.agent.configuration.converter.ByteValue;\n+import co.elastic.logging.log4j2.EcsLayout;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.core.LoggerContext;\n+import org.apache.logging.log4j.core.appender.ConsoleAppender;\n+import org.apache.logging.log4j.core.config.Configuration;\n+import org.apache.logging.log4j.core.config.ConfigurationFactory;\n+import org.apache.logging.log4j.core.config.ConfigurationSource;\n+import org.apache.logging.log4j.core.config.builder.api.AppenderComponentBuilder;\n+import org.apache.logging.log4j.core.config.builder.api.ConfigurationBuilder;\n+import org.apache.logging.log4j.core.config.builder.api.LayoutComponentBuilder;\n+import org.apache.logging.log4j.core.config.builder.api.RootLoggerComponentBuilder;\n+import org.apache.logging.log4j.core.config.builder.impl.BuiltConfiguration;\n+import org.apache.logging.log4j.core.config.plugins.util.PluginManager;\n+import org.stagemonitor.configuration.ConfigurationOption;\n+import org.stagemonitor.configuration.converter.EnumValueConverter;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.AGENT_HOME_PLACEHOLDER;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.DEFAULT_LOG_FILE;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.DEPRECATED_LOG_FILE_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.DEPRECATED_LOG_LEVEL_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_FILE_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_FORMAT_FILE_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_FORMAT_SOUT_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_LEVEL_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.SHIP_AGENT_LOGS;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.SYSTEM_OUT;\n+\n+public class Log4j2ConfigurationFactory extends ConfigurationFactory {\n+\n+    static {\n+        PluginManager.addPackage(EcsLayout.class.getPackage().getName());\n+        PluginManager.addPackage(LoggerContext.class.getPackage().getName());\n+    }\n+\n+    private final List<org.stagemonitor.configuration.source.ConfigurationSource> sources;\n+    private final String ephemeralId;\n+\n+    public Log4j2ConfigurationFactory(List<org.stagemonitor.configuration.source.ConfigurationSource> sources, String ephemeralId) {\n+        this.sources = sources;\n+        this.ephemeralId = ephemeralId;\n+    }\n+\n+    /**\n+     * The ConfigurationRegistry uses and thereby initializes a logger,\n+     * so we can't use it here initialize the {@link ConfigurationOption}s in this class.\n+     */\n+    private static String getValue(String key, List<org.stagemonitor.configuration.source.ConfigurationSource> sources, String defaultValue) {\n+        for (org.stagemonitor.configuration.source.ConfigurationSource source : sources) {\n+            final String value = source.getValue(key);\n+            if (value != null) {\n+                return value;\n+            }\n+        }\n+        return defaultValue;\n+    }\n+\n+    @Nonnull\n+    static String getActualLogFile(@Nullable String agentHome, String logFile) {\n+        if (logFile.equalsIgnoreCase(SYSTEM_OUT)) {\n+            return SYSTEM_OUT;\n+        }\n+        if (logFile.contains(AGENT_HOME_PLACEHOLDER)) {\n+            if (agentHome == null) {\n+                System.err.println(\"Could not resolve \" + AGENT_HOME_PLACEHOLDER + \". Falling back to System.out.\");\n+                return SYSTEM_OUT;\n+            } else {\n+                logFile = logFile.replace(AGENT_HOME_PLACEHOLDER, agentHome);\n+            }\n+        }\n+        logFile = new File(logFile).getAbsolutePath();\n+        final File logDir = new File(logFile).getParentFile();\n+        if (!logDir.exists()) {\n+            logDir.mkdir();\n+        }\n+        if (!logDir.canWrite()) {\n+            System.err.println(\"Log file \" + logFile + \" is not writable. Falling back to System.out.\");\n+            return SYSTEM_OUT;\n+        }\n+        return logFile;\n+    }\n+\n+    @Override\n+    protected String[] getSupportedTypes() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Configuration getConfiguration(LoggerContext loggerContext, String name, URI configLocation) {\n+        return getConfiguration();\n+    }\n+\n+    @Override\n+    public Configuration getConfiguration(LoggerContext loggerContext, ConfigurationSource source) {\n+        return getConfiguration();\n+    }\n+\n+    public Configuration getConfiguration() {\n+        ConfigurationBuilder<BuiltConfiguration> builder = newConfigurationBuilder();\n+        builder.setStatusLevel(Level.ERROR)\n+            .setConfigurationName(\"ElasticAPM\");\n+\n+        Level level = Level.valueOf(getValue(LOG_LEVEL_KEY, sources, getValue(DEPRECATED_LOG_LEVEL_KEY, sources, Level.INFO.toString())));\n+        RootLoggerComponentBuilder rootLogger = builder.newRootLogger(level);\n+        List<AppenderComponentBuilder> appenders = createAppenders(builder);\n+        for (AppenderComponentBuilder appender : appenders) {\n+            rootLogger.add(builder.newAppenderRef(appender.getName()));\n+        }\n+        builder.add(rootLogger);\n+        return builder.build();\n+    }\n+\n+    private List<AppenderComponentBuilder> createAppenders(ConfigurationBuilder<BuiltConfiguration> builder) {\n+        List<AppenderComponentBuilder> appenders = new ArrayList<>();\n+        String logFile = getActualLogFile(ElasticApmAgent.getAgentHome(), getValue(LOG_FILE_KEY, sources, getValue(DEPRECATED_LOG_FILE_KEY, sources, DEFAULT_LOG_FILE)));\n+        if (logFile.equals(SYSTEM_OUT)) {\n+            appenders.add(createConsoleAppender(builder));\n+            if (Boolean.parseBoolean(getValue(SHIP_AGENT_LOGS, sources, Boolean.TRUE.toString()))) {\n+                File tempLog = getTempLogFile(ephemeralId);\n+                tempLog.deleteOnExit();\n+                File rotatedTempLog = new File(tempLog + \".1\");\n+                rotatedTempLog.deleteOnExit();\n+                appenders.add(createFileAppender(builder, tempLog.getAbsolutePath(), createLayout(builder, LogFormat.JSON)));\n+            }\n+        } else {\n+            appenders.add(createFileAppender(builder, logFile, createLayout(builder, getFileLogFormat())));\n+        }\n+        for (AppenderComponentBuilder appender : appenders) {\n+            builder.add(appender);\n+        }\n+        return appenders;\n+    }\n+\n+    public static File getTempLogFile(String ephemeralId) {\n+        return new File(System.getProperty(\"java.io.tmpdir\") + \"/elasticapm-java-\" + ephemeralId + \".log.json\");", "originalCommit": "e859dfae312bc49c96743b090bd459923e54c1d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1NjQzNw==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r419956437", "bodyText": "why do we have to create two File instances in the case of shipping logs ? Feels like only one is needed and should be created directly with the .1 suffix.", "author": "SylvainJuge", "createdAt": "2020-05-05T08:50:52Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/logging/Log4j2ConfigurationFactory.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.logging;\n+\n+import co.elastic.apm.agent.bci.ElasticApmAgent;\n+import co.elastic.apm.agent.configuration.CoreConfiguration;\n+import co.elastic.apm.agent.configuration.ServiceNameUtil;\n+import co.elastic.apm.agent.configuration.converter.ByteValue;\n+import co.elastic.logging.log4j2.EcsLayout;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.core.LoggerContext;\n+import org.apache.logging.log4j.core.appender.ConsoleAppender;\n+import org.apache.logging.log4j.core.config.Configuration;\n+import org.apache.logging.log4j.core.config.ConfigurationFactory;\n+import org.apache.logging.log4j.core.config.ConfigurationSource;\n+import org.apache.logging.log4j.core.config.builder.api.AppenderComponentBuilder;\n+import org.apache.logging.log4j.core.config.builder.api.ConfigurationBuilder;\n+import org.apache.logging.log4j.core.config.builder.api.LayoutComponentBuilder;\n+import org.apache.logging.log4j.core.config.builder.api.RootLoggerComponentBuilder;\n+import org.apache.logging.log4j.core.config.builder.impl.BuiltConfiguration;\n+import org.apache.logging.log4j.core.config.plugins.util.PluginManager;\n+import org.stagemonitor.configuration.ConfigurationOption;\n+import org.stagemonitor.configuration.converter.EnumValueConverter;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.AGENT_HOME_PLACEHOLDER;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.DEFAULT_LOG_FILE;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.DEPRECATED_LOG_FILE_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.DEPRECATED_LOG_LEVEL_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_FILE_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_FORMAT_FILE_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_FORMAT_SOUT_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_LEVEL_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.SHIP_AGENT_LOGS;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.SYSTEM_OUT;\n+\n+public class Log4j2ConfigurationFactory extends ConfigurationFactory {\n+\n+    static {\n+        PluginManager.addPackage(EcsLayout.class.getPackage().getName());\n+        PluginManager.addPackage(LoggerContext.class.getPackage().getName());\n+    }\n+\n+    private final List<org.stagemonitor.configuration.source.ConfigurationSource> sources;\n+    private final String ephemeralId;\n+\n+    public Log4j2ConfigurationFactory(List<org.stagemonitor.configuration.source.ConfigurationSource> sources, String ephemeralId) {\n+        this.sources = sources;\n+        this.ephemeralId = ephemeralId;\n+    }\n+\n+    /**\n+     * The ConfigurationRegistry uses and thereby initializes a logger,\n+     * so we can't use it here initialize the {@link ConfigurationOption}s in this class.\n+     */\n+    private static String getValue(String key, List<org.stagemonitor.configuration.source.ConfigurationSource> sources, String defaultValue) {\n+        for (org.stagemonitor.configuration.source.ConfigurationSource source : sources) {\n+            final String value = source.getValue(key);\n+            if (value != null) {\n+                return value;\n+            }\n+        }\n+        return defaultValue;\n+    }\n+\n+    @Nonnull\n+    static String getActualLogFile(@Nullable String agentHome, String logFile) {\n+        if (logFile.equalsIgnoreCase(SYSTEM_OUT)) {\n+            return SYSTEM_OUT;\n+        }\n+        if (logFile.contains(AGENT_HOME_PLACEHOLDER)) {\n+            if (agentHome == null) {\n+                System.err.println(\"Could not resolve \" + AGENT_HOME_PLACEHOLDER + \". Falling back to System.out.\");\n+                return SYSTEM_OUT;\n+            } else {\n+                logFile = logFile.replace(AGENT_HOME_PLACEHOLDER, agentHome);\n+            }\n+        }\n+        logFile = new File(logFile).getAbsolutePath();\n+        final File logDir = new File(logFile).getParentFile();\n+        if (!logDir.exists()) {\n+            logDir.mkdir();\n+        }\n+        if (!logDir.canWrite()) {\n+            System.err.println(\"Log file \" + logFile + \" is not writable. Falling back to System.out.\");\n+            return SYSTEM_OUT;\n+        }\n+        return logFile;\n+    }\n+\n+    @Override\n+    protected String[] getSupportedTypes() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Configuration getConfiguration(LoggerContext loggerContext, String name, URI configLocation) {\n+        return getConfiguration();\n+    }\n+\n+    @Override\n+    public Configuration getConfiguration(LoggerContext loggerContext, ConfigurationSource source) {\n+        return getConfiguration();\n+    }\n+\n+    public Configuration getConfiguration() {\n+        ConfigurationBuilder<BuiltConfiguration> builder = newConfigurationBuilder();\n+        builder.setStatusLevel(Level.ERROR)\n+            .setConfigurationName(\"ElasticAPM\");\n+\n+        Level level = Level.valueOf(getValue(LOG_LEVEL_KEY, sources, getValue(DEPRECATED_LOG_LEVEL_KEY, sources, Level.INFO.toString())));\n+        RootLoggerComponentBuilder rootLogger = builder.newRootLogger(level);\n+        List<AppenderComponentBuilder> appenders = createAppenders(builder);\n+        for (AppenderComponentBuilder appender : appenders) {\n+            rootLogger.add(builder.newAppenderRef(appender.getName()));\n+        }\n+        builder.add(rootLogger);\n+        return builder.build();\n+    }\n+\n+    private List<AppenderComponentBuilder> createAppenders(ConfigurationBuilder<BuiltConfiguration> builder) {\n+        List<AppenderComponentBuilder> appenders = new ArrayList<>();\n+        String logFile = getActualLogFile(ElasticApmAgent.getAgentHome(), getValue(LOG_FILE_KEY, sources, getValue(DEPRECATED_LOG_FILE_KEY, sources, DEFAULT_LOG_FILE)));\n+        if (logFile.equals(SYSTEM_OUT)) {\n+            appenders.add(createConsoleAppender(builder));\n+            if (Boolean.parseBoolean(getValue(SHIP_AGENT_LOGS, sources, Boolean.TRUE.toString()))) {\n+                File tempLog = getTempLogFile(ephemeralId);", "originalCommit": "e859dfae312bc49c96743b090bd459923e54c1d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU5MjI1Mg==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r420592252", "bodyText": "Not sure how we could get rid of tempLog and what the benefits are?", "author": "felixbarny", "createdAt": "2020-05-06T07:25:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1NjQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1NzI3NQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r419957275", "bodyText": "probably rename to console here also for consistency", "author": "SylvainJuge", "createdAt": "2020-05-05T08:52:20Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/logging/Log4j2ConfigurationFactory.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.logging;\n+\n+import co.elastic.apm.agent.bci.ElasticApmAgent;\n+import co.elastic.apm.agent.configuration.CoreConfiguration;\n+import co.elastic.apm.agent.configuration.ServiceNameUtil;\n+import co.elastic.apm.agent.configuration.converter.ByteValue;\n+import co.elastic.logging.log4j2.EcsLayout;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.core.LoggerContext;\n+import org.apache.logging.log4j.core.appender.ConsoleAppender;\n+import org.apache.logging.log4j.core.config.Configuration;\n+import org.apache.logging.log4j.core.config.ConfigurationFactory;\n+import org.apache.logging.log4j.core.config.ConfigurationSource;\n+import org.apache.logging.log4j.core.config.builder.api.AppenderComponentBuilder;\n+import org.apache.logging.log4j.core.config.builder.api.ConfigurationBuilder;\n+import org.apache.logging.log4j.core.config.builder.api.LayoutComponentBuilder;\n+import org.apache.logging.log4j.core.config.builder.api.RootLoggerComponentBuilder;\n+import org.apache.logging.log4j.core.config.builder.impl.BuiltConfiguration;\n+import org.apache.logging.log4j.core.config.plugins.util.PluginManager;\n+import org.stagemonitor.configuration.ConfigurationOption;\n+import org.stagemonitor.configuration.converter.EnumValueConverter;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.AGENT_HOME_PLACEHOLDER;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.DEFAULT_LOG_FILE;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.DEPRECATED_LOG_FILE_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.DEPRECATED_LOG_LEVEL_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_FILE_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_FORMAT_FILE_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_FORMAT_SOUT_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.LOG_LEVEL_KEY;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.SHIP_AGENT_LOGS;\n+import static co.elastic.apm.agent.logging.LoggingConfiguration.SYSTEM_OUT;\n+\n+public class Log4j2ConfigurationFactory extends ConfigurationFactory {\n+\n+    static {\n+        PluginManager.addPackage(EcsLayout.class.getPackage().getName());\n+        PluginManager.addPackage(LoggerContext.class.getPackage().getName());\n+    }\n+\n+    private final List<org.stagemonitor.configuration.source.ConfigurationSource> sources;\n+    private final String ephemeralId;\n+\n+    public Log4j2ConfigurationFactory(List<org.stagemonitor.configuration.source.ConfigurationSource> sources, String ephemeralId) {\n+        this.sources = sources;\n+        this.ephemeralId = ephemeralId;\n+    }\n+\n+    /**\n+     * The ConfigurationRegistry uses and thereby initializes a logger,\n+     * so we can't use it here initialize the {@link ConfigurationOption}s in this class.\n+     */\n+    private static String getValue(String key, List<org.stagemonitor.configuration.source.ConfigurationSource> sources, String defaultValue) {\n+        for (org.stagemonitor.configuration.source.ConfigurationSource source : sources) {\n+            final String value = source.getValue(key);\n+            if (value != null) {\n+                return value;\n+            }\n+        }\n+        return defaultValue;\n+    }\n+\n+    @Nonnull\n+    static String getActualLogFile(@Nullable String agentHome, String logFile) {\n+        if (logFile.equalsIgnoreCase(SYSTEM_OUT)) {\n+            return SYSTEM_OUT;\n+        }\n+        if (logFile.contains(AGENT_HOME_PLACEHOLDER)) {\n+            if (agentHome == null) {\n+                System.err.println(\"Could not resolve \" + AGENT_HOME_PLACEHOLDER + \". Falling back to System.out.\");\n+                return SYSTEM_OUT;\n+            } else {\n+                logFile = logFile.replace(AGENT_HOME_PLACEHOLDER, agentHome);\n+            }\n+        }\n+        logFile = new File(logFile).getAbsolutePath();\n+        final File logDir = new File(logFile).getParentFile();\n+        if (!logDir.exists()) {\n+            logDir.mkdir();\n+        }\n+        if (!logDir.canWrite()) {\n+            System.err.println(\"Log file \" + logFile + \" is not writable. Falling back to System.out.\");\n+            return SYSTEM_OUT;\n+        }\n+        return logFile;\n+    }\n+\n+    @Override\n+    protected String[] getSupportedTypes() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Configuration getConfiguration(LoggerContext loggerContext, String name, URI configLocation) {\n+        return getConfiguration();\n+    }\n+\n+    @Override\n+    public Configuration getConfiguration(LoggerContext loggerContext, ConfigurationSource source) {\n+        return getConfiguration();\n+    }\n+\n+    public Configuration getConfiguration() {\n+        ConfigurationBuilder<BuiltConfiguration> builder = newConfigurationBuilder();\n+        builder.setStatusLevel(Level.ERROR)\n+            .setConfigurationName(\"ElasticAPM\");\n+\n+        Level level = Level.valueOf(getValue(LOG_LEVEL_KEY, sources, getValue(DEPRECATED_LOG_LEVEL_KEY, sources, Level.INFO.toString())));\n+        RootLoggerComponentBuilder rootLogger = builder.newRootLogger(level);\n+        List<AppenderComponentBuilder> appenders = createAppenders(builder);\n+        for (AppenderComponentBuilder appender : appenders) {\n+            rootLogger.add(builder.newAppenderRef(appender.getName()));\n+        }\n+        builder.add(rootLogger);\n+        return builder.build();\n+    }\n+\n+    private List<AppenderComponentBuilder> createAppenders(ConfigurationBuilder<BuiltConfiguration> builder) {\n+        List<AppenderComponentBuilder> appenders = new ArrayList<>();\n+        String logFile = getActualLogFile(ElasticApmAgent.getAgentHome(), getValue(LOG_FILE_KEY, sources, getValue(DEPRECATED_LOG_FILE_KEY, sources, DEFAULT_LOG_FILE)));\n+        if (logFile.equals(SYSTEM_OUT)) {\n+            appenders.add(createConsoleAppender(builder));\n+            if (Boolean.parseBoolean(getValue(SHIP_AGENT_LOGS, sources, Boolean.TRUE.toString()))) {\n+                File tempLog = getTempLogFile(ephemeralId);\n+                tempLog.deleteOnExit();\n+                File rotatedTempLog = new File(tempLog + \".1\");\n+                rotatedTempLog.deleteOnExit();\n+                appenders.add(createFileAppender(builder, tempLog.getAbsolutePath(), createLayout(builder, LogFormat.JSON)));\n+            }\n+        } else {\n+            appenders.add(createFileAppender(builder, logFile, createLayout(builder, getFileLogFormat())));\n+        }\n+        for (AppenderComponentBuilder appender : appenders) {\n+            builder.add(appender);\n+        }\n+        return appenders;\n+    }\n+\n+    public static File getTempLogFile(String ephemeralId) {\n+        return new File(System.getProperty(\"java.io.tmpdir\") + \"/elasticapm-java-\" + ephemeralId + \".log.json\");\n+    }\n+\n+    private AppenderComponentBuilder createConsoleAppender(ConfigurationBuilder<BuiltConfiguration> builder) {\n+        return builder.newAppender(\"Stdout\", \"CONSOLE\")\n+            .addAttribute(\"target\", ConsoleAppender.Target.SYSTEM_OUT)\n+            .add(createLayout(builder, getSoutLogFormat()));\n+    }\n+\n+    private LayoutComponentBuilder createLayout(ConfigurationBuilder<BuiltConfiguration> builder, LogFormat logFormat) {\n+        if (logFormat == LogFormat.PLAIN_TEXT) {\n+            return builder\n+                    .newLayout(\"PatternLayout\")\n+                    .addAttribute(\"pattern\", \"%d [%thread] %-5level %logger{36} - %msg%n\");\n+        } else {\n+            String serviceName = getValue(CoreConfiguration.SERVICE_NAME, sources, ServiceNameUtil.getDefaultServiceName());\n+            return builder.newLayout(\"EcsLayout\")\n+                .addAttribute(\"eventDataset\", serviceName + \".apm\");\n+        }\n+    }\n+\n+    private LogFormat getSoutLogFormat() {", "originalCommit": "e859dfae312bc49c96743b090bd459923e54c1d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1ODg4NQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r419958885", "bodyText": "why is it unused ?", "author": "SylvainJuge", "createdAt": "2020-05-05T08:55:16Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/logging/LoggingConfiguration.java", "diffHunk": "@@ -117,67 +122,94 @@ public void assertValid(Boolean value) {\n         })\n         .buildWithDefault(false);\n \n-    public static void init(List<ConfigurationSource> sources) {\n-        setLogLevel(getValue(LOG_LEVEL_KEY, sources,\n-            getValue(DEPRECATED_LOG_LEVEL_KEY, sources, LogLevel.INFO.toString())));\n-        setLogFileLocation(ElasticApmAgent.getAgentHome(), getValue(LOG_FILE_KEY, sources,\n-            getValue(DEPRECATED_LOG_FILE_KEY, sources, DEFAULT_LOG_FILE)));\n-    }\n+    @SuppressWarnings(\"unused\")", "originalCommit": "e859dfae312bc49c96743b090bd459923e54c1d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU5NTQwNg==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r420595406", "bodyText": "That's because we don't access the configuration value through the logFileMaxSize ConfigurationOption instance. That would require the configuration registry to be initialized already. However, the registry initializes logging. In order to break up the cyclic dependency and to not accidentally initialize logging before we had the chance to configure the logging, we manually resolve these options.", "author": "felixbarny", "createdAt": "2020-05-06T07:31:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1ODg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk2MzY5MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r419963691", "bodyText": "there is some commented code, probably leftovers.\nAlso, not really sure about the wording, something like agent keeps one history file, thus the amount of storage used by agent logs will be equal to twice this value.\nI feel that we could make this less confusing by using a value that is half of the configured value.\nIMHO it provides the following advantages:\n\nusers expect a limit to be enforced, and using twice the configured value would be seen as a defect, even if it's documented\nit's unlikely that anyone will complain about the agent using less storage than expected, nobody wants a full hard drive\nwe could still document that this limit is shared between the two copies of the log file when using log shipping feature.", "author": "SylvainJuge", "createdAt": "2020-05-05T09:03:26Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/logging/LoggingConfiguration.java", "diffHunk": "@@ -117,67 +122,94 @@ public void assertValid(Boolean value) {\n         })\n         .buildWithDefault(false);\n \n-    public static void init(List<ConfigurationSource> sources) {\n-        setLogLevel(getValue(LOG_LEVEL_KEY, sources,\n-            getValue(DEPRECATED_LOG_LEVEL_KEY, sources, LogLevel.INFO.toString())));\n-        setLogFileLocation(ElasticApmAgent.getAgentHome(), getValue(LOG_FILE_KEY, sources,\n-            getValue(DEPRECATED_LOG_FILE_KEY, sources, DEFAULT_LOG_FILE)));\n-    }\n+    @SuppressWarnings(\"unused\")\n+    public ConfigurationOption<ByteValue> logFileMaxSize = ByteValueConverter.byteOption()\n+        .key(LOG_FILE_MAX_SIZE_KEY)\n+        .configurationCategory(LOGGING_CATEGORY)\n+        .description(\"The max size of the log file.\\n\" +\n+            \"\\n\" +\n+            //\"To support <<config-ship-agent-logs,shipping the logs>> to APM Server,\\n\" +\n+            \"The agent always keeps one history file so that the max total log file size is twice the value of this setting.\\n\")", "originalCommit": "e859dfae312bc49c96743b090bd459923e54c1d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU5ODcwOQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r420598709", "bodyText": "there is some commented code, probably leftovers\n\nThis is intentionally left in as it will be needed when we support shipping logs.\n\nI feel that we could make this less confusing by using a value that is half of the configured value.\n\nThe reason why I did it this way is that log_file_max_size also determines how much is buffered on disk before data is deleted. When shipping logs, it basically determines how much data can be buffered without data loss while the APM Server is down. So they might expect that we always buffer at least log_file_max_size. We can only guarantee that, if both the primary and the history log file have the max size of log_file_max_size.", "author": "felixbarny", "createdAt": "2020-05-06T07:38:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk2MzY5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMwMDQ5OA==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r424300498", "bodyText": "Then, probably removing the 'max' from the configuration would remove any expectation to be the actual max disk usage by the agent. for example if we name it log_file_buffer_size and then document that disk usage is at most equal to twice this value.", "author": "SylvainJuge", "createdAt": "2020-05-13T09:28:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk2MzY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk2NDQ0Mw==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r419964443", "bodyText": "commented code", "author": "SylvainJuge", "createdAt": "2020-05-05T09:04:53Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/logging/LoggingConfiguration.java", "diffHunk": "@@ -117,67 +122,94 @@ public void assertValid(Boolean value) {\n         })\n         .buildWithDefault(false);\n \n-    public static void init(List<ConfigurationSource> sources) {\n-        setLogLevel(getValue(LOG_LEVEL_KEY, sources,\n-            getValue(DEPRECATED_LOG_LEVEL_KEY, sources, LogLevel.INFO.toString())));\n-        setLogFileLocation(ElasticApmAgent.getAgentHome(), getValue(LOG_FILE_KEY, sources,\n-            getValue(DEPRECATED_LOG_FILE_KEY, sources, DEFAULT_LOG_FILE)));\n-    }\n+    @SuppressWarnings(\"unused\")\n+    public ConfigurationOption<ByteValue> logFileMaxSize = ByteValueConverter.byteOption()\n+        .key(LOG_FILE_MAX_SIZE_KEY)\n+        .configurationCategory(LOGGING_CATEGORY)\n+        .description(\"The max size of the log file.\\n\" +\n+            \"\\n\" +\n+            //\"To support <<config-ship-agent-logs,shipping the logs>> to APM Server,\\n\" +\n+            \"The agent always keeps one history file so that the max total log file size is twice the value of this setting.\\n\")\n+        .dynamic(false)\n+        .tags(\"added[1.16.0]\")\n+        .buildWithDefault(ByteValue.of(DEFAULT_MAX_SIZE));\n \n-    /**\n-     * The ConfigurationRegistry uses and thereby initializes a logger,\n-     * so we can't use it here initialize the {@link ConfigurationOption}s in this class.\n-     */\n-    private static String getValue(String key, List<ConfigurationSource> sources, String defaultValue) {\n-        for (ConfigurationSource source : sources) {\n-            final String value = source.getValue(key);\n-            if (value != null) {\n-                return value;\n-            }\n-        }\n-        return defaultValue;\n-    }\n+    private final ConfigurationOption<Boolean> shipAgentLogs = ConfigurationOption.booleanOption()\n+        .key(SHIP_AGENT_LOGS)\n+        .configurationCategory(LOGGING_CATEGORY)\n+        .description(\"This helps you to centralize your agent logs by automatically sending them to APM Server (requires APM Server 7.9+).\\n\" +\n+            \"Use the Kibana Logs App to see the logs from all of your agents.\\n\" +\n+            \"\\n\" +\n+            \"If <<config-log-file,`log_file`>> is set to a real file location (as opposed to `System.out`),\\n\" +\n+            \"this file will be shipped to the APM Server by the agent.\\n\" +\n+            \"Note that <<config-log-format-file,`log_format_file`>> needs to be set to `JSON` when this option is enabled.\\n\" +\n+            \"\\n\" +\n+            \"If APM Server is temporarily not available, the agent will resume sending where it left off as soon as the server is back up again.\\n\" +\n+            \"The amount of logs that can be buffered is at least <<config-log-file-max-size,`log_file_max_size`>>.\\n\" +\n+            \"If the application crashes or APM Server is not available when shutting down,\\n\" +\n+            \"the agent will resume shipping the log file when the application restarts.\\n\" +\n+            \"\\n\" +\n+            \"Resume on restart does not work when the log is inside an ephemeral container.\\n\" +\n+            \"Consider mounting the log file to the host or use Filebeat if you need the extra reliability in this case.\\n\" +\n+            \"\\n\" +\n+            \"If <<config-log-file,`log_file`>> is set to `System.out`,\\n\" +\n+            \"the agent will additionally log into a temp file which is then sent to APM Server.\\n\" +\n+            \"This log's size is determined by <<config-log-file-max-size,`log_file_max_size`>> and will be deleted on shutdown.\\n\" +\n+            \"This means that logs that could not be sent before the application terminates are lost.\")\n+        .dynamic(false)\n+        .tags(\"added[not officially added yet]\", \"internal\")\n+        .buildWithDefault(false);\n \n-    private static void setLogLevel(@Nullable String level) {\n-        System.setProperty(SimpleLogger.LOG_KEY_PREFIX + \"co.elastic.apm\", level != null ? level : LogLevel.INFO.toString());\n-        System.setProperty(SimpleLogger.LOG_KEY_PREFIX + \"co.elastic.apm.agent.shaded\", LogLevel.OFF.toString().equals(level) ? level : LogLevel.WARN.toString());\n-        System.setProperty(SimpleLogger.SHOW_DATE_TIME_KEY, Boolean.TRUE.toString());\n-        System.setProperty(SimpleLogger.DATE_TIME_FORMAT_KEY, \"yyyy-MM-dd HH:mm:ss.SSS\");\n+    @SuppressWarnings(\"unused\")\n+    public ConfigurationOption<LogFormat> logFormatSout = ConfigurationOption.enumOption(LogFormat.class)\n+        .key(LOG_FORMAT_SOUT_KEY)\n+        .configurationCategory(LOGGING_CATEGORY)\n+        .description(\"Defines the log format when logging to `System.out`.\\n\" +\n+            \"\\n\" +\n+            \"When set to `JSON`, the agent will format the logs in an https://github.com/elastic/ecs-logging-java[ECS-compliant JSON format]\\n\" +\n+            \"where each log event is serialized as a single line.\")\n+        .tags(\"added[1.16.0]\")\n+        .buildWithDefault(LogFormat.PLAIN_TEXT);\n+\n+    @SuppressWarnings(\"unused\")\n+    public ConfigurationOption<LogFormat> logFormatFile = ConfigurationOption.enumOption(LogFormat.class)\n+        .key(LOG_FORMAT_FILE_KEY)\n+        .configurationCategory(LOGGING_CATEGORY)\n+        .description(\"Defines the log format when logging to a file.\\n\" +\n+            \"\\n\" +\n+            \"When set to `JSON`, the agent will format the logs in an https://github.com/elastic/ecs-logging-java[ECS-compliant JSON format]\\n\" +\n+            \"where each log event is serialized as a single line.\\n\"\n+            //+ \"\\n\" +", "originalCommit": "e859dfae312bc49c96743b090bd459923e54c1d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU5ODg1Mw==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r420598853", "bodyText": "This is intentionally left in as it will be needed when we support shipping logs.", "author": "felixbarny", "createdAt": "2020-05-06T07:38:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk2NDQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk2NzY1NQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r419967655", "bodyText": "leftover TODO", "author": "SylvainJuge", "createdAt": "2020-05-05T09:10:41Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/report/AbstractIntakeApiHandler.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.report;\n+\n+import co.elastic.apm.agent.impl.MetaData;\n+import co.elastic.apm.agent.report.serialize.DslJsonSerializer;\n+import co.elastic.apm.agent.report.serialize.PayloadSerializer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.stagemonitor.util.IOUtils;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.TimeUnit;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+\n+public class AbstractIntakeApiHandler {\n+    protected final Logger logger = LoggerFactory.getLogger(getClass());\n+    protected static final int GZIP_COMPRESSION_LEVEL = 1;\n+    private static final Object WAIT_LOCK = new Object();\n+\n+    protected final ReporterConfiguration reporterConfiguration;\n+    protected final PayloadSerializer payloadSerializer;\n+    protected final ApmServerClient apmServerClient;\n+    protected final byte[] metaData;\n+    protected Deflater deflater;\n+    protected long currentlyTransmitting = 0;\n+    protected long reported = 0;\n+    protected long dropped = 0;\n+    @Nullable\n+    protected HttpURLConnection connection;\n+    @Nullable\n+    protected OutputStream os;\n+    protected int errorCount;\n+    protected volatile boolean shutDown;\n+\n+    public AbstractIntakeApiHandler(ReporterConfiguration reporterConfiguration, MetaData metaData, PayloadSerializer payloadSerializer, ApmServerClient apmServerClient) {\n+        this.reporterConfiguration = reporterConfiguration;\n+        this.payloadSerializer = payloadSerializer;\n+        this.apmServerClient = apmServerClient;\n+        this.deflater = new Deflater(GZIP_COMPRESSION_LEVEL);\n+        payloadSerializer.serializeMetaDataNdJson(metaData);\n+        this.metaData = payloadSerializer.toString().getBytes(StandardCharsets.UTF_8);\n+        try {\n+            payloadSerializer.flush();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /*\n+     * We add \u00b110% jitter to the calculated grace period in case multiple agents entered the grace period simultaneously.\n+     * This can happen if the APM server queue is full which leads to sending an error response to all connected agents.\n+     * The random jitter makes sure the agents will not all try to reconnect at the same time,\n+     * which would overwhelm the APM server again.\n+     */\n+    static long getRandomJitter(long backoffTimeMillis) {\n+        final long tenPercentOfBackoffTimeMillis = (long) (backoffTimeMillis * 0.1);\n+        return (long) (tenPercentOfBackoffTimeMillis * 2 * Math.random()) - tenPercentOfBackoffTimeMillis;\n+    }\n+\n+    static long getBackoffTimeSeconds(long errorCount) {\n+        return (long) Math.pow(Math.min(errorCount, 6), 2);\n+    }\n+\n+    protected boolean shouldEndRequest() {\n+        final long written = deflater.getBytesWritten() + DslJsonSerializer.BUFFER_SIZE;\n+        final boolean endRequest = written >= reporterConfiguration.getApiRequestSize();\n+        if (endRequest && logger.isDebugEnabled()) {\n+            logger.debug(\"Flushing, because request size limit exceeded {}/{}\", written, reporterConfiguration.getApiRequestSize());\n+        }\n+        return endRequest;\n+    }\n+\n+    protected HttpURLConnection startRequest(String endpoint) throws IOException {\n+        final HttpURLConnection connection = apmServerClient.startRequest(endpoint);\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Starting new request to {}\", connection.getURL());\n+        }\n+        connection.setRequestMethod(\"POST\");\n+        connection.setDoOutput(true);\n+        connection.setChunkedStreamingMode(DslJsonSerializer.BUFFER_SIZE);\n+        connection.setRequestProperty(\"Content-Encoding\", \"deflate\");\n+        connection.setRequestProperty(\"Content-Type\", \"application/x-ndjson\");\n+        connection.setUseCaches(false);\n+        connection.connect();\n+        os = new DeflaterOutputStream(connection.getOutputStream(), deflater);\n+        os.write(metaData);\n+        return connection;\n+    }\n+\n+    public void endRequest() {\n+        if (connection != null) {\n+            try {\n+                payloadSerializer.flush();\n+                if (os != null) {\n+                    os.close();\n+                }\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\"Flushing {} uncompressed {} compressed bytes\", deflater.getBytesRead(), deflater.getBytesWritten());\n+                }\n+                InputStream inputStream = connection.getInputStream();\n+                final int responseCode = connection.getResponseCode();\n+                if (responseCode >= 400) {\n+                    onRequestError(responseCode, inputStream, null);\n+                } else {\n+                    onRequestSuccess();\n+                }\n+            } catch (IOException e) {\n+                try {\n+                    onRequestError(connection.getResponseCode(), connection.getErrorStream(), e);\n+                } catch (IOException e1) {\n+                    onRequestError(-1, connection.getErrorStream(), e);\n+                }\n+            } finally {\n+                HttpUtils.consumeAndClose(connection);\n+                connection = null;\n+                deflater.reset();\n+                currentlyTransmitting = 0;\n+            }\n+        }\n+    }\n+\n+    protected void onRequestError(Integer responseCode, InputStream inputStream, @Nullable IOException e) {\n+        // TODO read accepted, dropped and invalid", "originalCommit": "e859dfae312bc49c96743b090bd459923e54c1d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU5OTgzOA==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r420599838", "bodyText": "That's just factored out code from co.elastic.apm.agent.report.IntakeV2ReportingEventHandler and it's indeed something that's still to do.", "author": "felixbarny", "createdAt": "2020-05-06T07:40:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk2NzY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk2ODM4Mw==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r419968383", "bodyText": "what are the actual units/usage of currentlyTransmitting reported and dropped ? Number of bytes ? For reported and dropped number of success / failures while sending ?", "author": "SylvainJuge", "createdAt": "2020-05-05T09:12:02Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/report/AbstractIntakeApiHandler.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.report;\n+\n+import co.elastic.apm.agent.impl.MetaData;\n+import co.elastic.apm.agent.report.serialize.DslJsonSerializer;\n+import co.elastic.apm.agent.report.serialize.PayloadSerializer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.stagemonitor.util.IOUtils;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.TimeUnit;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+\n+public class AbstractIntakeApiHandler {\n+    protected final Logger logger = LoggerFactory.getLogger(getClass());\n+    protected static final int GZIP_COMPRESSION_LEVEL = 1;\n+    private static final Object WAIT_LOCK = new Object();\n+\n+    protected final ReporterConfiguration reporterConfiguration;\n+    protected final PayloadSerializer payloadSerializer;\n+    protected final ApmServerClient apmServerClient;\n+    protected final byte[] metaData;\n+    protected Deflater deflater;\n+    protected long currentlyTransmitting = 0;\n+    protected long reported = 0;\n+    protected long dropped = 0;", "originalCommit": "e859dfae312bc49c96743b090bd459923e54c1d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU5OTI4NA==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r420599284", "bodyText": "That's the number of events", "author": "felixbarny", "createdAt": "2020-05-06T07:39:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk2ODM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk3MTcyMw==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r419971723", "bodyText": "Just wondering, do we have this payload defined in server specs ? Might be relevant to have a link to this PR for reference as it's the 1st agent to implement this.", "author": "SylvainJuge", "createdAt": "2020-05-05T09:18:11Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/report/serialize/DslJsonSerializer.java", "diffHunk": "@@ -230,6 +231,29 @@ public void serializeMetrics(MetricRegistry metricRegistry) {\n         metricRegistry.report(this);\n     }\n \n+    @Override\n+    public void serializeFileMetaData(File file) {", "originalCommit": "e859dfae312bc49c96743b090bd459923e54c1d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYwMDYwOQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r420600609", "bodyText": "No, the whole logs endpoint and the spec does not exist yet. This is just a POC. Therefore it's disabled by default and the option to enable it is internal.", "author": "felixbarny", "createdAt": "2020-05-06T07:42:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk3MTcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk3OTI5MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r419979291", "bodyText": "does this interface attempts to replicate something currently implemented in beat agents to ship files ? I feel it somehow miss some javadoc to explain how it works.", "author": "SylvainJuge", "createdAt": "2020-05-05T09:31:43Z", "path": "apm-agent-plugins/apm-log-shipper-plugin/src/main/java/co/elastic/apm/agent/log/shipper/FileChangeListener.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.log.shipper;\n+\n+import java.io.IOException;\n+\n+public interface FileChangeListener {", "originalCommit": "e859dfae312bc49c96743b090bd459923e54c1d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYwMTMyOQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r420601329", "bodyText": "I don't know how that part is implemented in Filebeat but I agree it misses some docs.", "author": "felixbarny", "createdAt": "2020-05-06T07:43:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk3OTI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk4NTYyOA==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r419985628", "bodyText": "why do we need to poll just after stop is requested ?", "author": "SylvainJuge", "createdAt": "2020-05-05T09:42:52Z", "path": "apm-agent-plugins/apm-log-shipper-plugin/src/main/java/co/elastic/apm/agent/log/shipper/FileTailer.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.log.shipper;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ThreadFactory;\n+\n+public class FileTailer implements Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(FileTailer.class);\n+    private final List<TailableFile> tailableFiles;\n+    private final FileChangeListener fileChangeListener;\n+    private final ByteBuffer buffer;\n+    private final int maxLinesPerCycle;\n+    private volatile boolean stopRequested = false;\n+    private final long idleTimeMs;\n+    private final Thread processingThread;\n+\n+    public FileTailer(FileChangeListener fileChangeListener, int bufferSize, int maxLinesPerCycle, long idleTimeMs, ThreadFactory processingThreadFactory) {\n+        this.tailableFiles = new CopyOnWriteArrayList<>();\n+        this.fileChangeListener = fileChangeListener;\n+        this.buffer = ByteBuffer.allocate(bufferSize);\n+        this.maxLinesPerCycle = maxLinesPerCycle;\n+        this.idleTimeMs = idleTimeMs;\n+        this.processingThread = processingThreadFactory.newThread(this);\n+    }\n+\n+    public TailableFile tailFile(File file) throws IOException {\n+        TailableFile tailableFile = new TailableFile(file);\n+        tailableFiles.add(tailableFile);\n+        return tailableFile;\n+    }\n+\n+    public void start() {\n+        processingThread.start();\n+    }\n+\n+    public void stop(long timeout) throws Exception {\n+        stopRequested = true;\n+        fileChangeListener.onShutdownInitiated();\n+        processingThread.join(timeout);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!stopRequested) {\n+                int readLines = pollAll();\n+                if (readLines == 0) {\n+                    fileChangeListener.onIdle();\n+                    Thread.sleep(idleTimeMs);\n+                }\n+            }\n+            pollAll();", "originalCommit": "e859dfae312bc49c96743b090bd459923e54c1d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYwMzc3NA==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r420603774", "bodyText": "That's because we want to make sure we have sent everything in the file and don't immediately stop sending when shutting down. We should also attempt to send logs emitted during the shutdown. But the timeout provided to the stop method makes sure we don't block indefinitely.\nThis part is still very much POC and WIP which is why there's also not a lot of docs. Part of it is specified in elastic/apm#252 but it lacks some details atm.\nAgain, this code is not active by default and can only be activated through an internal option.", "author": "felixbarny", "createdAt": "2020-05-06T07:48:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk4NTYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk4OTAzNg==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r419989036", "bodyText": "what is the equivalent value for Windows ?", "author": "SylvainJuge", "createdAt": "2020-05-05T09:49:08Z", "path": "apm-agent-plugins/apm-log-shipper-plugin/src/main/java/co/elastic/apm/agent/log/shipper/TailableFile.java", "diffHunk": "@@ -0,0 +1,357 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.log.shipper;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.FileFilter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.FileLock;\n+import java.nio.channels.OverlappingFileLockException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Properties;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.nio.file.StandardOpenOption.CREATE;\n+import static java.nio.file.StandardOpenOption.READ;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+\n+public class TailableFile implements Closeable {\n+    private static final Logger logger = LoggerFactory.getLogger(TailableFile.class);\n+    private static final byte NEW_LINE = (byte) '\\n';\n+    private static final int EOF = -1;\n+    private final File file;\n+    private final File stateFile;\n+    private final FileChannel stateFileChannel;\n+    private final FileLock stateFileLock;\n+    @Nullable\n+    private FileChannel fileChannel;\n+    /**\n+     * The creation date of the file.\n+     * The name of the file might change as its being read due to file rotation.\n+     * The file creation time can help to identify which file to read from when restoring the state.\n+     */\n+    private long fileCreationTime;\n+    private long inode;\n+\n+    public TailableFile(File file) throws IOException {\n+        this.file = file;\n+        stateFile = new File(file + \".state\");\n+        stateFileChannel = FileChannel.open(stateFile.toPath(), CREATE, READ, WRITE);\n+        try {\n+            stateFileLock = stateFileChannel.tryLock();\n+            if (stateFileLock == null) {\n+                throw new IllegalStateException(\"This file is currently locked by another process: \" + stateFile);\n+            }\n+        } catch (OverlappingFileLockException e) {\n+            throw new IllegalStateException(\"This file is currently locked by this process: \" + stateFile, e);\n+        }\n+        Properties state = readState();\n+        if (!state.isEmpty()) {\n+            restoreState(state);\n+        } else {\n+            tryOpenFile();\n+        }\n+    }\n+\n+    private Properties readState() throws IOException {\n+        Properties properties = new Properties();\n+        try (InputStream input = new FileInputStream(stateFile)) {\n+            properties.load(input);\n+        } catch (FileNotFoundException ignore) {\n+        }\n+        return properties;\n+    }\n+\n+    void deleteStateFile() {\n+        new File(file + \".state\").delete();\n+    }\n+\n+    public void deleteStateFileOnExit() {\n+        new File(file + \".state\").deleteOnExit();\n+    }\n+\n+    private void restoreState(Properties state) throws IOException {\n+        long position = Long.parseLong(state.getProperty(\"position\", \"0\"));\n+        long creationTime = Long.parseLong(state.getProperty(\"creationTime\", Long.toString(getCreationTime(file.toPath()))));\n+        long inode = Long.parseLong(state.getProperty(\"inode\", Long.toString(getInode(file.toPath()))));\n+        if (hasRotated(creationTime, inode)) {\n+            openRotatedFile(position, creationTime, inode);\n+        } else {\n+            openExistingFile(position, file.toPath());\n+        }\n+    }\n+\n+    private boolean hasRotated(long creationTime, long inode) throws IOException {\n+        if (inode != -1) {\n+            return getInode(file.toPath()) != inode;\n+        } else {\n+            return getCreationTime(file.toPath()) != creationTime;\n+        }\n+    }\n+\n+    private void openRotatedFile(long position, long creationTime, long inode) throws IOException {\n+        // the file has rotated and is now named differently, maybe something like file-0.log\n+        // let's search in the same directory for a file with the creation time from the state file\n+        File rotatedFile;\n+        if (inode == -1) {\n+            rotatedFile = findFileWithCreationDate(file.getParentFile(), creationTime);\n+        } else {\n+            rotatedFile = findFileWithInode(file.getParentFile(), inode);\n+        }\n+        if (rotatedFile != null && rotatedFile.length() > position) {\n+            openExistingFile(position, rotatedFile.toPath());\n+        }\n+    }\n+\n+    private void saveState(FileChannel fileChannel, long fileCreationTime) throws IOException {\n+        Properties properties = new Properties();\n+        properties.put(\"position\", Long.toString(fileChannel.position()));\n+        properties.put(\"creationTime\", Long.toString(fileCreationTime));\n+        properties.put(\"inode\", Long.toString(inode));\n+        try (FileOutputStream os = new FileOutputStream(stateFile)) {\n+            properties.store(os, null);\n+        }\n+    }\n+\n+    public void ack() {\n+        if (fileChannel == null) {\n+            throw new IllegalStateException(\"Can't acknowledge the state if the file has not been opened yet\");\n+        }\n+        try {\n+            saveState(fileChannel, fileCreationTime);\n+        } catch (IOException e) {\n+            logger.error(e.getMessage(), e);\n+        }\n+    }\n+\n+    public void nak() {\n+        try {\n+            Properties state = readState();\n+            if (!state.isEmpty()) {\n+                restoreState(state);\n+            }\n+        } catch (IOException e) {\n+            logger.error(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Nullable\n+    private File findFileWithCreationDate(File dir, final long creationTime) {\n+        File[] files = dir.listFiles(new FileFilter() {\n+            @Override\n+            public boolean accept(File file) {\n+                try {\n+                    return !file.getName().endsWith(\".state\") && getCreationTime(file.toPath()) == creationTime;\n+                } catch (IOException e) {\n+                    return false;\n+                }\n+            }\n+        });\n+        if (files != null && files.length == 1) {\n+            return files[0];\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Nullable\n+    private File findFileWithInode(File dir, final long inode) {\n+        File[] files = dir.listFiles(new FileFilter() {\n+            @Override\n+            public boolean accept(File file) {\n+                return getInode(file.toPath()) == inode;\n+            }\n+        });\n+        if (files != null && files.length == 1) {\n+            return files[0];\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private long getCreationTime(Path path) throws IOException {\n+        BasicFileAttributes attr = Files.readAttributes(path, BasicFileAttributes.class);\n+        return attr.creationTime().to(TimeUnit.MILLISECONDS);\n+    }\n+\n+    private long getInode(Path path) {\n+        try {\n+            return (Long) Files.getAttribute(path, \"unix:ino\");", "originalCommit": "e859dfae312bc49c96743b090bd459923e54c1d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYwNDI3MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r420604271", "bodyText": "There is none, that's we fall back to the creation timestamp.", "author": "felixbarny", "createdAt": "2020-05-06T07:49:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk4OTAzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk5MjY3MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r419992671", "bodyText": "maybe making file a Path instead of a File would be a bit better as it avoids conversions and Channel requires it anyway. Also, it's already commonly used in TailableFileTest.java.", "author": "SylvainJuge", "createdAt": "2020-05-05T09:55:49Z", "path": "apm-agent-plugins/apm-log-shipper-plugin/src/main/java/co/elastic/apm/agent/log/shipper/TailableFile.java", "diffHunk": "@@ -0,0 +1,357 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.log.shipper;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.FileFilter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.FileLock;\n+import java.nio.channels.OverlappingFileLockException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Properties;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.nio.file.StandardOpenOption.CREATE;\n+import static java.nio.file.StandardOpenOption.READ;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+\n+public class TailableFile implements Closeable {\n+    private static final Logger logger = LoggerFactory.getLogger(TailableFile.class);\n+    private static final byte NEW_LINE = (byte) '\\n';\n+    private static final int EOF = -1;\n+    private final File file;\n+    private final File stateFile;\n+    private final FileChannel stateFileChannel;\n+    private final FileLock stateFileLock;\n+    @Nullable\n+    private FileChannel fileChannel;\n+    /**\n+     * The creation date of the file.\n+     * The name of the file might change as its being read due to file rotation.\n+     * The file creation time can help to identify which file to read from when restoring the state.\n+     */\n+    private long fileCreationTime;\n+    private long inode;\n+\n+    public TailableFile(File file) throws IOException {\n+        this.file = file;", "originalCommit": "e859dfae312bc49c96743b090bd459923e54c1d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYwNTQzNQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r420605435", "bodyText": "That would, in turn, require lots of conversations from Path to File", "author": "felixbarny", "createdAt": "2020-05-06T07:52:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk5MjY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk5MzM1Nw==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r419993357", "bodyText": "why make this static and provide an instance as first argument ?", "author": "SylvainJuge", "createdAt": "2020-05-05T09:57:03Z", "path": "apm-agent-plugins/apm-log-shipper-plugin/src/main/java/co/elastic/apm/agent/log/shipper/TailableFile.java", "diffHunk": "@@ -0,0 +1,357 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.log.shipper;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.FileFilter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.FileLock;\n+import java.nio.channels.OverlappingFileLockException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Properties;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.nio.file.StandardOpenOption.CREATE;\n+import static java.nio.file.StandardOpenOption.READ;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+\n+public class TailableFile implements Closeable {\n+    private static final Logger logger = LoggerFactory.getLogger(TailableFile.class);\n+    private static final byte NEW_LINE = (byte) '\\n';\n+    private static final int EOF = -1;\n+    private final File file;\n+    private final File stateFile;\n+    private final FileChannel stateFileChannel;\n+    private final FileLock stateFileLock;\n+    @Nullable\n+    private FileChannel fileChannel;\n+    /**\n+     * The creation date of the file.\n+     * The name of the file might change as its being read due to file rotation.\n+     * The file creation time can help to identify which file to read from when restoring the state.\n+     */\n+    private long fileCreationTime;\n+    private long inode;\n+\n+    public TailableFile(File file) throws IOException {\n+        this.file = file;\n+        stateFile = new File(file + \".state\");\n+        stateFileChannel = FileChannel.open(stateFile.toPath(), CREATE, READ, WRITE);\n+        try {\n+            stateFileLock = stateFileChannel.tryLock();\n+            if (stateFileLock == null) {\n+                throw new IllegalStateException(\"This file is currently locked by another process: \" + stateFile);\n+            }\n+        } catch (OverlappingFileLockException e) {\n+            throw new IllegalStateException(\"This file is currently locked by this process: \" + stateFile, e);\n+        }\n+        Properties state = readState();\n+        if (!state.isEmpty()) {\n+            restoreState(state);\n+        } else {\n+            tryOpenFile();\n+        }\n+    }\n+\n+    private Properties readState() throws IOException {\n+        Properties properties = new Properties();\n+        try (InputStream input = new FileInputStream(stateFile)) {\n+            properties.load(input);\n+        } catch (FileNotFoundException ignore) {\n+        }\n+        return properties;\n+    }\n+\n+    void deleteStateFile() {\n+        new File(file + \".state\").delete();\n+    }\n+\n+    public void deleteStateFileOnExit() {\n+        new File(file + \".state\").deleteOnExit();\n+    }\n+\n+    private void restoreState(Properties state) throws IOException {\n+        long position = Long.parseLong(state.getProperty(\"position\", \"0\"));\n+        long creationTime = Long.parseLong(state.getProperty(\"creationTime\", Long.toString(getCreationTime(file.toPath()))));\n+        long inode = Long.parseLong(state.getProperty(\"inode\", Long.toString(getInode(file.toPath()))));\n+        if (hasRotated(creationTime, inode)) {\n+            openRotatedFile(position, creationTime, inode);\n+        } else {\n+            openExistingFile(position, file.toPath());\n+        }\n+    }\n+\n+    private boolean hasRotated(long creationTime, long inode) throws IOException {\n+        if (inode != -1) {\n+            return getInode(file.toPath()) != inode;\n+        } else {\n+            return getCreationTime(file.toPath()) != creationTime;\n+        }\n+    }\n+\n+    private void openRotatedFile(long position, long creationTime, long inode) throws IOException {\n+        // the file has rotated and is now named differently, maybe something like file-0.log\n+        // let's search in the same directory for a file with the creation time from the state file\n+        File rotatedFile;\n+        if (inode == -1) {\n+            rotatedFile = findFileWithCreationDate(file.getParentFile(), creationTime);\n+        } else {\n+            rotatedFile = findFileWithInode(file.getParentFile(), inode);\n+        }\n+        if (rotatedFile != null && rotatedFile.length() > position) {\n+            openExistingFile(position, rotatedFile.toPath());\n+        }\n+    }\n+\n+    private void saveState(FileChannel fileChannel, long fileCreationTime) throws IOException {\n+        Properties properties = new Properties();\n+        properties.put(\"position\", Long.toString(fileChannel.position()));\n+        properties.put(\"creationTime\", Long.toString(fileCreationTime));\n+        properties.put(\"inode\", Long.toString(inode));\n+        try (FileOutputStream os = new FileOutputStream(stateFile)) {\n+            properties.store(os, null);\n+        }\n+    }\n+\n+    public void ack() {\n+        if (fileChannel == null) {\n+            throw new IllegalStateException(\"Can't acknowledge the state if the file has not been opened yet\");\n+        }\n+        try {\n+            saveState(fileChannel, fileCreationTime);\n+        } catch (IOException e) {\n+            logger.error(e.getMessage(), e);\n+        }\n+    }\n+\n+    public void nak() {\n+        try {\n+            Properties state = readState();\n+            if (!state.isEmpty()) {\n+                restoreState(state);\n+            }\n+        } catch (IOException e) {\n+            logger.error(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Nullable\n+    private File findFileWithCreationDate(File dir, final long creationTime) {\n+        File[] files = dir.listFiles(new FileFilter() {\n+            @Override\n+            public boolean accept(File file) {\n+                try {\n+                    return !file.getName().endsWith(\".state\") && getCreationTime(file.toPath()) == creationTime;\n+                } catch (IOException e) {\n+                    return false;\n+                }\n+            }\n+        });\n+        if (files != null && files.length == 1) {\n+            return files[0];\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Nullable\n+    private File findFileWithInode(File dir, final long inode) {\n+        File[] files = dir.listFiles(new FileFilter() {\n+            @Override\n+            public boolean accept(File file) {\n+                return getInode(file.toPath()) == inode;\n+            }\n+        });\n+        if (files != null && files.length == 1) {\n+            return files[0];\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private long getCreationTime(Path path) throws IOException {\n+        BasicFileAttributes attr = Files.readAttributes(path, BasicFileAttributes.class);\n+        return attr.creationTime().to(TimeUnit.MILLISECONDS);\n+    }\n+\n+    private long getInode(Path path) {\n+        try {\n+            return (Long) Files.getAttribute(path, \"unix:ino\");\n+        } catch (Exception e) {\n+            return -1;\n+        }\n+    }\n+\n+    public int tail(ByteBuffer buffer, FileChangeListener listener, int maxLines) throws IOException {\n+        int readLines = 0;\n+        while (readLines < maxLines) {\n+            FileChannel currentFile = getFileChannel();\n+            if (currentFile == null || isFullyRead()) {\n+                return readLines;\n+            }\n+            readLines += readFile(buffer, listener, maxLines - readLines, currentFile);\n+        }\n+        return readLines;\n+    }\n+\n+    private int readFile(ByteBuffer buffer, FileChangeListener listener, int maxLines, FileChannel currentFile) throws IOException {\n+        int readLines = 0;\n+        while (readLines < maxLines) {\n+            buffer.clear();\n+            int read = currentFile.read(buffer);\n+            if (read != EOF) {\n+                buffer.flip();\n+                readLines += readLines(this, buffer, maxLines - readLines, listener);\n+                currentFile.position(currentFile.position() - buffer.remaining());\n+            } else {\n+                // assumes EOF equals EOL\n+                // this might be wrong when another process is in the middle of writing the line\n+                // (when is the new file size visible to other processes?)\n+                return readLines;\n+            }\n+        }\n+        return readLines;\n+    }\n+\n+    @Nullable\n+    private FileChannel getFileChannel() throws IOException {\n+        if (fileChannel == null || (isFullyRead() && hasRotated())) {\n+            tryOpenFile();\n+        }\n+        return fileChannel;\n+    }\n+\n+    private boolean hasRotated() throws IOException {\n+        return fileChannel != null && file.exists() && file.length() < fileChannel.position();\n+    }\n+\n+    private boolean isFullyRead() throws IOException {\n+        return fileChannel != null && fileChannel.position() == fileChannel.size();\n+    }\n+\n+    private void tryOpenFile() throws IOException {\n+        if (!file.exists()) {\n+            return;\n+        }\n+        openExistingFile(0, file.toPath());\n+    }\n+\n+    private void openExistingFile(long position, Path path) throws IOException {\n+        if (this.fileChannel != null) {\n+            this.fileChannel.close();\n+        }\n+        FileChannel fileChannel = FileChannel.open(path);\n+        fileChannel.position(position);\n+        fileCreationTime = getCreationTime(file.toPath());\n+        inode = getInode(file.toPath());\n+        if (this.fileChannel == null) {\n+            saveState(fileChannel, fileCreationTime);\n+        }\n+        this.fileChannel = fileChannel;\n+    }\n+\n+    static int readLines(TailableFile file, ByteBuffer buffer, int maxLines, FileChangeListener listener) throws IOException {", "originalCommit": "e859dfae312bc49c96743b090bd459923e54c1d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYwNjIwNA==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r420606204", "bodyText": "\ud83e\udd37", "author": "felixbarny", "createdAt": "2020-05-06T07:53:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk5MzM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk5NTk3OA==", "url": "https://github.com/elastic/apm-agent-java/pull/1169#discussion_r419995978", "bodyText": "Buffy the logs slayer \u2122\ufe0f", "author": "SylvainJuge", "createdAt": "2020-05-05T10:01:52Z", "path": "apm-agent-plugins/apm-log-shipper-plugin/src/test/java/co/elastic/apm/agent/log/shipper/TailableFileTest.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.log.shipper;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+import static java.nio.file.StandardOpenOption.CREATE_NEW;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+\n+class TailableFileTest {\n+\n+    private final ByteBuffer buffy = ByteBuffer.allocate(1024);", "originalCommit": "e859dfae312bc49c96743b090bd459923e54c1d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2e12e224ed43f958362b88a1d5b0e1a86b66e0d3", "url": "https://github.com/elastic/apm-agent-java/commit/2e12e224ed43f958362b88a1d5b0e1a86b66e0d3", "message": "Fix log4j test dependency conflict with elasticsearch-rest-high-level-client", "committedDate": "2020-05-05T11:37:21Z", "type": "commit"}, {"oid": "3a93be1d0d51f5d9811155f2cff7b2a5ccd0f2bf", "url": "https://github.com/elastic/apm-agent-java/commit/3a93be1d0d51f5d9811155f2cff7b2a5ccd0f2bf", "message": "Apply suggestions from review", "committedDate": "2020-05-06T07:54:21Z", "type": "commit"}, {"oid": "c4a0a72d38e006c88f2d04c6e56fc5dd20f692c9", "url": "https://github.com/elastic/apm-agent-java/commit/c4a0a72d38e006c88f2d04c6e56fc5dd20f692c9", "message": "Rename log_file_max_size to log_file_size", "committedDate": "2020-05-14T09:04:58Z", "type": "commit"}, {"oid": "7c92d980421d0e257494fc86e9372dde5017d6e3", "url": "https://github.com/elastic/apm-agent-java/commit/7c92d980421d0e257494fc86e9372dde5017d6e3", "message": "Merge remote-tracking branch 'origin/master' into log-shipper", "committedDate": "2020-05-14T09:07:09Z", "type": "commit"}, {"oid": "95726c839e78aa12b8b4e1251cbd2e3dc06219ce", "url": "https://github.com/elastic/apm-agent-java/commit/95726c839e78aa12b8b4e1251cbd2e3dc06219ce", "message": "Fix parent pom version", "committedDate": "2020-05-14T09:15:59Z", "type": "commit"}, {"oid": "4cd63334fbcd7100919929b93a32967e31b9ed6a", "url": "https://github.com/elastic/apm-agent-java/commit/4cd63334fbcd7100919929b93a32967e31b9ed6a", "message": "Remove multi-version release files for log4j and relocate Log4j- files", "committedDate": "2020-05-14T10:30:20Z", "type": "commit"}, {"oid": "17870aa2133300fe889511430c15e1b5db63a541", "url": "https://github.com/elastic/apm-agent-java/commit/17870aa2133300fe889511430c15e1b5db63a541", "message": "Fix error on Wildfly start by avoiding MBean server init", "committedDate": "2020-05-15T11:14:21Z", "type": "commit"}, {"oid": "0c771fd819bceac2a99fc2b9a20825d217d07b2c", "url": "https://github.com/elastic/apm-agent-java/commit/0c771fd819bceac2a99fc2b9a20825d217d07b2c", "message": "Avoid log4j2 conflicts in Spring Boot tests", "committedDate": "2020-05-15T13:29:40Z", "type": "commit"}]}