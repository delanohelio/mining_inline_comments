{"pr_number": 986, "pr_title": "Make instrumentation options dynamic", "pr_createdAt": "2020-01-08T10:25:40Z", "pr_url": "https://github.com/elastic/apm-agent-java/pull/986", "timeline": [{"oid": "32fff57ee444363887dbb2f26cbc9af5988479d5", "url": "https://github.com/elastic/apm-agent-java/commit/32fff57ee444363887dbb2f26cbc9af5988479d5", "message": "Experiment with AgentBuilder.patchOnByteBuddyAgent", "committedDate": "2020-01-02T17:57:16Z", "type": "commit"}, {"oid": "d863ad2da07ab1146e052973e50271397364aa1e", "url": "https://github.com/elastic/apm-agent-java/commit/d863ad2da07ab1146e052973e50271397364aa1e", "message": "Make instrumentation options dynamic\n\nPowered by Byte Buddy's new patchOnByteBuddyAgent feature which will release in 1.10.7\nAffects options instrument, disable_instrumentations and trace_methods", "committedDate": "2020-01-06T15:29:19Z", "type": "commit"}, {"oid": "c81f67d67e3163441fe1898ff64c83f11f9ed0b1", "url": "https://github.com/elastic/apm-agent-java/commit/c81f67d67e3163441fe1898ff64c83f11f9ed0b1", "message": "Use POOL_ONLY on startup and HYBRID on re-init", "committedDate": "2020-01-08T10:23:59Z", "type": "commit"}, {"oid": "d1012d56e4119a0720bcff1f1e9a1691db677285", "url": "https://github.com/elastic/apm-agent-java/commit/d1012d56e4119a0720bcff1f1e9a1691db677285", "message": "Merge remote-tracking branch 'origin/master' into make-instrumentation-options-dynamic", "committedDate": "2020-03-04T16:32:59Z", "type": "commit"}, {"oid": "8a23cd0758201ac4a3efbfd86e9a6b81f20e57bd", "url": "https://github.com/elastic/apm-agent-java/commit/8a23cd0758201ac4a3efbfd86e9a6b81f20e57bd", "message": "Decouple retransform from configuration reload thread", "committedDate": "2020-03-04T16:48:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM2NzIxOQ==", "url": "https://github.com/elastic/apm-agent-java/pull/986#discussion_r389367219", "bodyText": "Can this happen during startup if the remote config overrides local settings?\nEither case, I believe the HYBRID strategy is not as safe as it relies on reflection, which can wake up hidden daemons.\nI recall a scenario where some JDBC driver compiled with one JDBC specification version, was used in an environment that contained an older JDBC version. While that was never a problem, as the incompatible methods were never used and the JVM did method-granularity-lazy class linkage, the usage of getDeclaredMethods surfaced this incompatibility as it caused an attempt to resolve all methods.", "author": "eyalkoren", "createdAt": "2020-03-08T12:59:46Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/bci/ElasticApmAgent.java", "diffHunk": "@@ -141,12 +148,54 @@ public void run() {\n             return;\n         }\n         ElasticApmInstrumentation.staticInit(tracer);\n+        // POOL_ONLY because we don't want to cause eager linking on startup as the class path may not be complete yet\n+        AgentBuilder agentBuilder = initAgentBuilder(tracer, instrumentation, instrumentations, logger, AgentBuilder.DescriptionStrategy.Default.POOL_ONLY);\n+        resettableClassFileTransformer = agentBuilder.installOn(ElasticApmAgent.instrumentation);\n+        CoreConfiguration coreConfig = tracer.getConfig(CoreConfiguration.class);\n+        for (ConfigurationOption instrumentationOption : coreConfig.getInstrumentationOptions()) {\n+            instrumentationOption.addChangeListener(new ConfigurationOption.ChangeListener() {\n+                @Override\n+                public void onChange(ConfigurationOption configurationOption, Object oldValue, Object newValue) {\n+                    reInitInstrumentation();\n+                }\n+            });\n+        }\n+    }\n+\n+    public static synchronized Future<?> reInitInstrumentation() {\n+        ElasticApmTracer tracer = ElasticApmInstrumentation.tracer;\n+        if (tracer == null || instrumentation == null) {\n+            throw new IllegalStateException(\"Can't re-init agent before it has been initialized\");\n+        }\n+        ThreadPoolExecutor executor = ExecutorUtils.createSingleThreadDeamonPool(\"apm-reinit\", 1);\n+        try {\n+            return executor.submit(new Runnable() {\n+                @Override\n+                public void run() {\n+                    doReInitInstrumentation(loadInstrumentations(tracer));\n+                }\n+            });\n+        } finally {\n+            executor.shutdown();\n+        }\n+    }\n+\n+    static synchronized void doReInitInstrumentation(Iterable<ElasticApmInstrumentation> instrumentations) {\n+        final Logger logger = LoggerFactory.getLogger(ElasticApmAgent.class);\n+        logger.info(\"Re initializing instrumentation\");\n+        // HYBRID to speed up the matchers, assuming dependant classes have already loaded so we don't interfere with the ordering of initialization", "originalCommit": "8a23cd0758201ac4a3efbfd86e9a6b81f20e57bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTczODU1Nw==", "url": "https://github.com/elastic/apm-agent-java/pull/986#discussion_r389738557", "bodyText": "Can this happen during startup if the remote config overrides local settings?\n\nyes, that's possible\n\nthe usage of getDeclaredMethods surfaced this incompatibility as it caused an attempt to resolve all methods\n\nWhat is the consequence of that? Can't we just ignore the linkage errors?", "author": "felixbarny", "createdAt": "2020-03-09T14:47:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM2NzIxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc0NzQyOQ==", "url": "https://github.com/elastic/apm-agent-java/pull/986#discussion_r389747429", "bodyText": "Good question, I am not sure how the JVM would treat a class that is already loaded and partly linked and suddenly fails linkage...", "author": "eyalkoren", "createdAt": "2020-03-09T15:00:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM2NzIxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc1MjUyOQ==", "url": "https://github.com/elastic/apm-agent-java/pull/986#discussion_r389752529", "bodyText": "Can this happen during startup if the remote config overrides local settings?\n\nyes, that's possible\n\nIn this case reflection may be used on startup", "author": "eyalkoren", "createdAt": "2020-03-09T15:07:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM2NzIxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc1NDE5NQ==", "url": "https://github.com/elastic/apm-agent-java/pull/986#discussion_r389754195", "bodyText": "I guess it should be relatively safe to ignore them. However, we'd lose the ability to instrument those classes. Changing to POOL_ONLY for now.", "author": "felixbarny", "createdAt": "2020-03-09T15:10:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM2NzIxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM2OTk5Mw==", "url": "https://github.com/elastic/apm-agent-java/pull/986#discussion_r389369993", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertThat(reporter.getSpans()).hasSize(0);\n          \n          \n            \n                    // if original configuration was used, a span would have been created - see `testTraceMethod`\n          \n          \n            \n                    assertThat(reporter.getSpans()).hasSize(0);", "author": "eyalkoren", "createdAt": "2020-03-08T13:33:36Z", "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/bci/methodmatching/TraceMethodInstrumentationTest.java", "diffHunk": "@@ -107,6 +108,17 @@ void testTraceMethod() {\n         assertThat(reporter.getFirstSpan().getNameAsString()).isEqualTo(\"TestClass#traceMeToo\");\n     }\n \n+    @Test\n+    void testReInitTraceMethod() throws Exception {\n+        when(coreConfiguration.getTraceMethods()).thenReturn(\n+            List.of(MethodMatcher.of(\"private co.elastic.apm.agent.bci.methodmatching.TraceMethodInstrumentationTest$TestClass#traceMe()\")));\n+        ElasticApmAgent.reInitInstrumentation().get();\n+        TestClass.traceMe();\n+        assertThat(reporter.getTransactions()).hasSize(1);\n+        assertThat(reporter.getFirstTransaction().getNameAsString()).isEqualTo(\"TestClass#traceMe\");\n+        assertThat(reporter.getSpans()).hasSize(0);", "originalCommit": "8a23cd0758201ac4a3efbfd86e9a6b81f20e57bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3MTIwNA==", "url": "https://github.com/elastic/apm-agent-java/pull/986#discussion_r389371204", "bodyText": "Make the initInstrumentation() method synchronized as well, as it registers listeners that can be called concurrently (assuming that net.bytebuddy.agent.builder.AgentBuilder#installOn and net.bytebuddy.agent.builder.AgentBuilder#patchOnByteBuddyAgent should not be invoked concurrently)", "author": "eyalkoren", "createdAt": "2020-03-08T13:49:19Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/bci/ElasticApmAgent.java", "diffHunk": "@@ -141,12 +148,54 @@ public void run() {\n             return;\n         }\n         ElasticApmInstrumentation.staticInit(tracer);\n+        // POOL_ONLY because we don't want to cause eager linking on startup as the class path may not be complete yet\n+        AgentBuilder agentBuilder = initAgentBuilder(tracer, instrumentation, instrumentations, logger, AgentBuilder.DescriptionStrategy.Default.POOL_ONLY);\n+        resettableClassFileTransformer = agentBuilder.installOn(ElasticApmAgent.instrumentation);\n+        CoreConfiguration coreConfig = tracer.getConfig(CoreConfiguration.class);\n+        for (ConfigurationOption instrumentationOption : coreConfig.getInstrumentationOptions()) {\n+            instrumentationOption.addChangeListener(new ConfigurationOption.ChangeListener() {\n+                @Override\n+                public void onChange(ConfigurationOption configurationOption, Object oldValue, Object newValue) {\n+                    reInitInstrumentation();\n+                }\n+            });\n+        }\n+    }\n+\n+    public static synchronized Future<?> reInitInstrumentation() {", "originalCommit": "8a23cd0758201ac4a3efbfd86e9a6b81f20e57bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3NDc1OQ==", "url": "https://github.com/elastic/apm-agent-java/pull/986#discussion_r389374759", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)\n          \n          \n            \n                        .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)\n          \n          \n            \n                        .with(new AgentBuilder.RedefinitionStrategy.BatchAllocator() {\n          \n          \n            \n                            @Override\n          \n          \n            \n                            public Iterable<? extends List<Class<?>>> batch(List<Class<?>> types) {\n          \n          \n            \n                                // if this is on startup, do the same as BatchAllocator.ForTotal, otherwise use batches\n          \n          \n            \n                            }\n          \n          \n            \n                        })\n          \n      \n    \n    \n  \n\nNot exactly this, but this BatchAllocator can be handy for retransformations...", "author": "eyalkoren", "createdAt": "2020-03-08T14:32:23Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/bci/ElasticApmAgent.java", "diffHunk": "@@ -348,7 +396,7 @@ private static AgentBuilder getAgentBuilder(final ByteBuddy byteBuddy, final Cor\n \n         return new AgentBuilder.Default(byteBuddy)\n             .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)", "originalCommit": "8a23cd0758201ac4a3efbfd86e9a6b81f20e57bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTczOTg5MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/986#discussion_r389739891", "bodyText": "Byte Buddy is batching by default (via RedefinitionStrategy.BatchAllocator.ForTotal.INSTANCE)", "author": "felixbarny", "createdAt": "2020-03-09T14:50:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3NDc1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc0ODA3MA==", "url": "https://github.com/elastic/apm-agent-java/pull/986#discussion_r389748070", "bodyText": "RedefinitionStrategy.BatchAllocator.ForTotal.INSTANCE means it is not batching, it includes all in one batch", "author": "eyalkoren", "createdAt": "2020-03-09T15:01:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3NDc1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc2MzE5NQ==", "url": "https://github.com/elastic/apm-agent-java/pull/986#discussion_r389763195", "bodyText": "I see what you mean now. Which batch size would you propose? Should we sleep between batches? Or should we just start with a single batch?", "author": "felixbarny", "createdAt": "2020-03-09T15:23:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3NDc1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4MDI5NA==", "url": "https://github.com/elastic/apm-agent-java/pull/986#discussion_r389780294", "bodyText": "I would say it makes sense to use a single batch on startup when the instrumentations are applied through premain or programmatic attach and use batches when applied through agentmain or when re-instrumenting.\n\nshould we just start with a single batch?\n\nThe reason I am suggesting it in this PR is because of the introduction of re-instrumentation, but if you have a reason to merge this quickly, it can be done in a separate PR. I think that if it is a matter of small effort- it worth it. Your call.\n\nWhich batch size would you propose?\n\nWell, as you imagine, it would just be random anyways \ud83d\ude42 . The main idea is not to cause a long degradation in app performance. From the top of my head- 100 per batch.\n\nShould we sleep between batches?\n\nCertainly, . We can use net.bytebuddy.agent.builder.AgentBuilder.RedefinitionStrategy.Listener.Pausing for that.", "author": "eyalkoren", "createdAt": "2020-03-09T15:48:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3NDc1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzMTM1NA==", "url": "https://github.com/elastic/apm-agent-java/pull/986#discussion_r389531354", "bodyText": "traceMethods and disabledInstrumentations are tested, but seems that dynamically changing instrument is not tested.", "author": "eyalkoren", "createdAt": "2020-03-09T09:03:04Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/configuration/CoreConfiguration.java", "diffHunk": "@@ -516,6 +519,10 @@ public boolean isInstrument() {\n         return instrument.get();\n     }\n \n+    public List<ConfigurationOption<?>> getInstrumentationOptions() {\n+        return Arrays.asList(instrument, traceMethods, disabledInstrumentations);", "originalCommit": "8a23cd0758201ac4a3efbfd86e9a6b81f20e57bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cf9c9d275e7df701ca21760cfe5cc30bf274ce50", "url": "https://github.com/elastic/apm-agent-java/commit/cf9c9d275e7df701ca21760cfe5cc30bf274ce50", "message": "Merge remote-tracking branch 'origin/master' into make-instrumentation-options-dynamic", "committedDate": "2020-03-09T14:50:32Z", "type": "commit"}, {"oid": "8ca5f2b5adf45acad8b28a0254aff8aa87edd10f", "url": "https://github.com/elastic/apm-agent-java/commit/8ca5f2b5adf45acad8b28a0254aff8aa87edd10f", "message": "Apply suggestions from code review", "committedDate": "2020-03-09T15:49:10Z", "type": "commit"}, {"oid": "b02e4e9fc621929f0dd34a0ed05d696ae874f574", "url": "https://github.com/elastic/apm-agent-java/commit/b02e4e9fc621929f0dd34a0ed05d696ae874f574", "message": "Limit batch size of retransformations", "committedDate": "2020-03-09T17:00:00Z", "type": "commit"}]}