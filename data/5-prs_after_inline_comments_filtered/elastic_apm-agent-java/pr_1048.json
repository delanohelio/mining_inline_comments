{"pr_number": 1048, "pr_title": "Add Scala concurrent plugin", "pr_createdAt": "2020-02-22T21:05:45Z", "pr_url": "https://github.com/elastic/apm-agent-java/pull/1048", "timeline": [{"oid": "404f6fb364eab81b066483af102a2685da3fc6ac", "url": "https://github.com/elastic/apm-agent-java/commit/404f6fb364eab81b066483af102a2685da3fc6ac", "message": "WIP", "committedDate": "2020-02-16T18:45:04Z", "type": "commit"}, {"oid": "9ce7f3fc27d83b0671b5f11fbafd08d2ec2f211b", "url": "https://github.com/elastic/apm-agent-java/commit/9ce7f3fc27d83b0671b5f11fbafd08d2ec2f211b", "message": "Add initial scala instrumentation for Future", "committedDate": "2020-02-22T12:17:07Z", "type": "commit"}, {"oid": "e0a4335e8be3ee9afbdbcf8a3d69cbef82f1be6b", "url": "https://github.com/elastic/apm-agent-java/commit/e0a4335e8be3ee9afbdbcf8a3d69cbef82f1be6b", "message": "Remove test-dependency", "committedDate": "2020-02-24T15:14:44Z", "type": "commit"}, {"oid": "e57e2d8c03b2a972a805498b59d5467701c24dd1", "url": "https://github.com/elastic/apm-agent-java/commit/e57e2d8c03b2a972a805498b59d5467701c24dd1", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm", "committedDate": "2020-03-29T10:17:17Z", "type": "commit"}, {"oid": "3ef57c0f45f274926c314413454cc35ed8e141ad", "url": "https://github.com/elastic/apm-agent-java/commit/3ef57c0f45f274926c314413454cc35ed8e141ad", "message": "Add first test approach", "committedDate": "2020-03-29T19:50:59Z", "type": "commit"}, {"oid": "2dd336d4fad4ed76beacccad038b8bd7f864adc7", "url": "https://github.com/elastic/apm-agent-java/commit/2dd336d4fad4ed76beacccad038b8bd7f864adc7", "message": "Use Java for method matching", "committedDate": "2020-04-09T19:17:01Z", "type": "commit"}, {"oid": "167ecde0806ada0f1454bc806e84a2499d700b25", "url": "https://github.com/elastic/apm-agent-java/commit/167ecde0806ada0f1454bc806e84a2499d700b25", "message": "Add dummy test using Scala", "committedDate": "2020-04-14T15:56:37Z", "type": "commit"}, {"oid": "90d0b6f227399923a3a3ce2271dae8db32df44fe", "url": "https://github.com/elastic/apm-agent-java/commit/90d0b6f227399923a3a3ce2271dae8db32df44fe", "message": "Add java-version", "committedDate": "2020-04-14T20:36:16Z", "type": "commit"}, {"oid": "1b5b369d9ff7a343ee7e3faf7d6b4adf1c238b63", "url": "https://github.com/elastic/apm-agent-java/commit/1b5b369d9ff7a343ee7e3faf7d6b4adf1c238b63", "message": "Add first matching instrumentation test", "committedDate": "2020-04-14T20:37:03Z", "type": "commit"}, {"oid": "f20a929179a0b7ca8e64add118f8e86de6a4b3d6", "url": "https://github.com/elastic/apm-agent-java/commit/f20a929179a0b7ca8e64add118f8e86de6a4b3d6", "message": "WIP", "committedDate": "2020-04-18T08:54:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY3MjY2Mw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r410672663", "bodyText": "Im currently trying out to create a first real test to see how everything works.\nIm currently stuck on why ByteBuddy is not executing this onEnter function even though I see method-matches on DEBUG level:\n[ScalaTest-main-running-FutureInstrumentationSpec] DEBUG co.elastic.apm.agent.bci.ElasticApmAgent - Method match for instrumentation FutureInstrumentation: ((((name(equals(onComplete)) and returns(erasure(is(void)))) or (name(equals(transform)) and returns(erasure(name(equals(scala.concurrent.Future)))))) or (name(equals(transformWith)) and returns(erasure(name(equals(scala.concurrent.Future)))))) or name(equals(result))) matches public final void scala.concurrent.impl.Promise$DefaultPromise.onComplete(scala.Function1,scala.concurrent.ExecutionContext)\n[ScalaTest-main-running-FutureInstrumentationSpec] DEBUG co.elastic.apm.agent.bci.ElasticApmAgent - Method match for instrumentation FutureInstrumentation: ((((name(equals(onComplete)) and returns(erasure(is(void)))) or (name(equals(transform)) and returns(erasure(name(equals(scala.concurrent.Future)))))) or (name(equals(transformWith)) and returns(erasure(name(equals(scala.concurrent.Future)))))) or name(equals(result))) matches public final java.lang.Object scala.concurrent.impl.Promise$DefaultPromise.result(scala.concurrent.duration.Duration,scala.concurrent.CanAwait) throws java.lang.Exception\n\nI see that the log also mentions throws java.lang.Exception but it is unclear on how and when that Exception is thrown.\n@felixbarny Any idea on what I'm missing on why onEnter is not being called even though there is a method match?", "author": "milanvdm", "createdAt": "2020-04-18T09:11:40Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"scala.concurrent.Future\"))\n+            .or(hasSuperType(named(\"scala.concurrent.impl.Promise\")))\n+            .or(hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\")))\n+            .or(hasSuperType(named(\"scala.concurrent.Future$\")));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+        return named(\"onComplete\").and(returns(void.class))\n+            .or(named(\"transform\").and(returns(named(\"scala.concurrent.Future\"))))\n+            .or(named(\"transformWith\").and(returns(named(\"scala.concurrent.Future\"))))\n+            .or(named(\"result\"));\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    @VisibleForAdvice\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void onEnter() {\n+        System.out.println(\"DEBUG2\");", "originalCommit": "f20a929179a0b7ca8e64add118f8e86de6a4b3d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTExNzQ4Mg==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r411117482", "bodyText": "Have you tried setting a breakpoint at Promise$DefaultPromise.onComplete or a method breakpoint for Promise.onComplete to see if the methods get called at all?\n\nI see that the log also mentions throws java.lang.Exception but it is unclear on how and when that Exception is thrown.\n\nThis is just a part of the method signature to indicate this method may throw any java.lang.Exception.", "author": "felixbarny", "createdAt": "2020-04-20T06:11:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY3MjY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NDQ3OA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r412494478", "bodyText": "Thanks for the tip, this helped me figure out the underlying process a lot better :)\nStruggling with ByteBuddy now to figure out how I could add a transaction-id to a matched class as a field.\nFrom my current understanding, a Promise will be created and at some point, the run method will be called on that Promise. Since the call on that run could happen on a different thread, I think it would make sense to somehow store the original context on that Promise and make sure to activate it again before the run.\nI've tried working with @Advice.FieldValue and @Advice.Local but I'm not sure if those values are really kept on the Promise itself.", "author": "milanvdm", "createdAt": "2020-04-21T21:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY3MjY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcyNTk5OA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r412725998", "bodyText": "Our agent supports to be attached at runtime. One of the limitations when instrumenting classes that are already loaded is that you can't change the class file format. That means you can't add interfaces, methods or fields.\nA common technique we use to overcome this is to put things like a Promise as the key of a WeakConcurrentMap and the corresponding Span as the value.\nExample:\n\n  \n    \n      apm-agent-java/apm-agent-plugins/apm-redis-plugin/apm-lettuce-plugin/src/main/java/co/elastic/apm/agent/redis/lettuce/Lettuce5StartSpanInstrumentation.java\n    \n    \n         Line 57\n      in\n      8421856\n    \n    \n    \n    \n\n        \n          \n           public static final WeakConcurrentMap<RedisCommand, Span> commandToSpan = new WeakConcurrentMap.WithInlinedExpunction<RedisCommand, Span>();", "author": "felixbarny", "createdAt": "2020-04-22T07:08:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY3MjY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjczNDk5NA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r412734994", "bodyText": "What if it is a Scala Promise? I remember a comment that we should prevent loading Scala classes since they would not be available on all code-bases.\nEspecially, I'm not sure if Java has any Scala interop.", "author": "milanvdm", "createdAt": "2020-04-22T07:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY3MjY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk1ODY3OQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r412958679", "bodyText": "Defining a WeakConcurrentMap<Promise, Span> does not cause loading/linking the Promise.  That's because the javac compiler erases the generic arguments. We only put promises in at runtime as we encounter these promises so they are guaranteed to already have been loaded.", "author": "felixbarny", "createdAt": "2020-04-22T12:57:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY3MjY2Mw=="}], "type": "inlineReview"}, {"oid": "b2d2bb72c3f2d0e200b81ab07e6c5ec47931b3ba", "url": "https://github.com/elastic/apm-agent-java/commit/b2d2bb72c3f2d0e200b81ab07e6c5ec47931b3ba", "message": "Use MUnit", "committedDate": "2020-04-20T21:09:56Z", "type": "commit"}, {"oid": "2feb98fdbd6dde9243158d7928fb5b954398d835", "url": "https://github.com/elastic/apm-agent-java/commit/2feb98fdbd6dde9243158d7928fb5b954398d835", "message": "Cleanup pom", "committedDate": "2020-04-22T20:23:52Z", "type": "commit"}, {"oid": "0af62cef3da61e316f994f5fd7e1c7600a5d2d3e", "url": "https://github.com/elastic/apm-agent-java/commit/0af62cef3da61e316f994f5fd7e1c7600a5d2d3e", "message": "Add Future instrumentation", "committedDate": "2020-04-22T20:24:05Z", "type": "commit"}, {"oid": "f97b0b10f431f082307efcc3160e6d10146c862b", "url": "https://github.com/elastic/apm-agent-java/commit/f97b0b10f431f082307efcc3160e6d10146c862b", "message": "Add tests", "committedDate": "2020-04-22T20:24:15Z", "type": "commit"}, {"oid": "649207b84ef4a73c923569193fde0f94df62efbd", "url": "https://github.com/elastic/apm-agent-java/commit/649207b84ef4a73c923569193fde0f94df62efbd", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm", "committedDate": "2020-04-23T15:47:31Z", "type": "commit"}, {"oid": "324ce67e0f9648e7f95fe86416ee6d0807be635b", "url": "https://github.com/elastic/apm-agent-java/commit/324ce67e0f9648e7f95fe86416ee6d0807be635b", "message": "Add plugin to release process", "committedDate": "2020-04-23T20:47:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyMzE0NA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414323144", "bodyText": "Don't forget to deactivate the context.", "author": "felixbarny", "createdAt": "2020-04-24T06:19:37Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Promise<?>, TraceContextHolder<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null) {\n+                promisesToContext.put(thiz, active);\n+            }\n+        }\n+\n+    }\n+\n+    public static class RunInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"run\").and(returns(void.class));\n+        }\n+\n+        @VisibleForAdvice\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onEnter(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> context = promisesToContext.getIfPresent(thiz);\n+            if (tracer != null && context != null) {\n+                tracer.activate(context);\n+            }\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            promisesToContext.remove(thiz);", "originalCommit": "324ce67e0f9648e7f95fe86416ee6d0807be635b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNDU5NA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414324594", "bodyText": "Catch thrown exceptions @Thrown @Nullable Throwable t and captureException(t)", "author": "felixbarny", "createdAt": "2020-04-24T06:23:01Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Promise<?>, TraceContextHolder<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null) {\n+                promisesToContext.put(thiz, active);\n+            }\n+        }\n+\n+    }\n+\n+    public static class RunInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"run\").and(returns(void.class));\n+        }\n+\n+        @VisibleForAdvice\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onEnter(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> context = promisesToContext.getIfPresent(thiz);\n+            if (tracer != null && context != null) {\n+                tracer.activate(context);\n+            }\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {", "originalCommit": "324ce67e0f9648e7f95fe86416ee6d0807be635b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414325356", "bodyText": "Promises could be created outside a transaction but used in the context of a transaction at the point a promise is scheduled.\nIs there a canonical place where promises are scheduled? Maybe something equivalent to Executor#execute(Runnable)?", "author": "felixbarny", "createdAt": "2020-04-24T06:24:54Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Promise<?>, TraceContextHolder<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();", "originalCommit": "324ce67e0f9648e7f95fe86416ee6d0807be635b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMzNTMwOQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414335309", "bodyText": "Mmmm, Ill have a look.\nDo you mean in the context of, someone creates a Promise outside of a transaction, without evaluating it. And then only start evaluating it later on, inside of a transaction?", "author": "milanvdm", "createdAt": "2020-04-24T06:46:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM0MzYxMw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414343613", "bodyText": "Yes, exactly.\nThis would also allow us to do another nice thing. Currenly, all classes have to be evaluated whether they are a subclass of Promise (hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"))). This is a rather costly matcher as we can't exclude any class by name so all classes that are loaded have to be parsed.\nSee this example of the AsyncHttpClient instrumentation how we only instrument AsyncHandler classes that are passed to the org.asynchttpclient.DefaultAsyncHttpClient#executeRequest(org.asynchttpclient.Request, org.asynchttpclient.AsyncHandler<T>) method.\n\n  \n    \n      apm-agent-java/apm-agent-plugins/apm-asynchttpclient-plugin/src/main/java/co/elastic/apm/agent/asynchttpclient/AbstractAsyncHttpClientInstrumentation.java\n    \n    \n         Line 106\n      in\n      75160fe\n    \n    \n    \n    \n\n        \n          \n           ElasticApmAgent.ensureInstrumented(asyncHandler.getClass(), ASYNC_HANDLER_INSTRUMENTATIONS); \n        \n    \n  \n\n\nUsing this strategy, we wouldn't have to instrument any Promises to start with. Only those subclasses that pass the canonical place where they are scheduled would be instrumented at runtime.", "author": "felixbarny", "createdAt": "2020-04-24T07:04:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM0ODQ4Ng==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414348486", "bodyText": "But how would you handle the case that there is a thread-switch between the creation of a Promise and the scheduling?\nIf the context is not propagated across that thread-switch, you would not know the transaction linked to this Promise and schedule it linked to no transaction.", "author": "milanvdm", "createdAt": "2020-04-24T07:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM1NzU0OQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414357549", "bodyText": "Usually, the thread on which the promise is scheduled is the thread we want to propagate the context.\nDo you know any counter-examples?", "author": "felixbarny", "createdAt": "2020-04-24T07:30:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM2Mzg2Ng==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414363866", "bodyText": "You start a transaction (thread 1)\nYou create a Promise (thread 1) - no context is saved on this Promise now\nSome thread switching - as I understand, the transaction of thread 1 will not be propagated\nPromise gets scheduled (thread 2) - it cannot find an active transaction", "author": "milanvdm", "createdAt": "2020-04-24T07:40:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM4NDM5NA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414384394", "bodyText": "Some thread switching\n\nThis thread switching should also be covered by one of our instrumentation. For example, if the switch is done by another promise.", "author": "felixbarny", "createdAt": "2020-04-24T08:15:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM4NzAyMQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414387021", "bodyText": "Oke, I'll dig a bit deeper into how Scala executes the Promises.", "author": "milanvdm", "createdAt": "2020-04-24T08:19:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYyNzE4Nw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414627187", "bodyText": "I've added some instrumentation on Scala's ExecutionContext instead of the Promise directly.\nIt seems to be working correctly since all spans are correctly reported in the APM UI.\nOne of the issues that I have is the logging though. With %X{transaction.id:-null} in my logback, I had all transaction ids of every operation when instrumenting the Promises directly.\nWith the instrumentation on the ExecutionContext, I see quite some nulls appearing:\nForkJoinPool-3-worker-5-id INFO  Main - Starting with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-21-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-5-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-21-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-31-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-25-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-7-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-23-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-25-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-25-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-23-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-25-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-25-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-25-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id null\nForkJoinPool-3-worker-25-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id null\nForkJoinPool-3-worker-25-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id null\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id null\nForkJoinPool-3-worker-25-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id null\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id null\nForkJoinPool-3-worker-25-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id null\nForkJoinPool-3-worker-25-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id null\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id null\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id null\nForkJoinPool-3-worker-21-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-17-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-3-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-3-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-7-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-9-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-5-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-13-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-31-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-31-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  Main - Halfway with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-13-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id null\nForkJoinPool-3-worker-5-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id null\nForkJoinPool-3-worker-23-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id null\nForkJoinPool-3-worker-5-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id null\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-17-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id null\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id null\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-31-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id null\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-31-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-31-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-31-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-31-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id null\nForkJoinPool-3-worker-17-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id null\nForkJoinPool-3-worker-17-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id null\nForkJoinPool-3-worker-9-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id null\nForkJoinPool-3-worker-3-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id null\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-5-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id null\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id null\nForkJoinPool-3-worker-13-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id null\nForkJoinPool-3-worker-13-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id null\nForkJoinPool-3-worker-13-id INFO  Main - Finished with transaction-id null", "author": "milanvdm", "createdAt": "2020-04-24T14:38:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc3MTY4Nw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414771687", "bodyText": "Not sure if relevant, but in DEBUG mode, I see the following:\n2020-04-24 20:14:59.428 [ForkJoinPool-1-worker-19] DEBUG co.elastic.apm.agent.mdc.MdcActivationListener - Class loader jdk.internal.loader.ClassLoaders$AppClassLoader@512ddf17 cannot load log4j API\njava.lang.ClassNotFoundException: org.apache.log4j.MDC\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:581)\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)\n\tat co.elastic.apm.agent.mdc.MdcActivationListener$2.get(MdcActivationListener.java:76)\n\tat co.elastic.apm.agent.mdc.MdcActivationListener$2.get(MdcActivationListener.java:70)\n\tat co.elastic.apm.agent.cache.WeakKeySoftValueLoadingCache$CacheValue.<init>(WeakKeySoftValueLoadingCache.java:124)\n\tat co.elastic.apm.agent.cache.WeakKeySoftValueLoadingCache$CacheValue.<init>(WeakKeySoftValueLoadingCache.java:116)\n\tat co.elastic.apm.agent.cache.WeakKeySoftValueLoadingCache.get(WeakKeySoftValueLoadingCache.java:81)\n\tat co.elastic.apm.agent.mdc.MdcActivationListener.beforeActivate(MdcActivationListener.java:154)\n\tat co.elastic.apm.agent.impl.transaction.TraceContextHolder.activate(TraceContextHolder.java:101)\n\tat co.elastic.apm.agent.impl.transaction.AbstractSpan.activate(AbstractSpan.java:345)\n\tat co.elastic.apm.agent.impl.transaction.AbstractSpan.activate(AbstractSpan.java:42)\n\tat co.elastic.apm.api.AbstractSpanImpl.activate(AbstractSpanImpl.java:137)\n\tat me.milan.MainF$.$anonfun$program$3(MainF.scala:30)", "author": "milanvdm", "createdAt": "2020-04-24T18:16:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg2MzI5OA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r416863298", "bodyText": "@felixbarny Should I create an issue about the mismatch between traces in the UI and the actual logging of the transaction-id?", "author": "milanvdm", "createdAt": "2020-04-28T19:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzOTYzNA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417139634", "bodyText": "One of the issues that I have is the logging though. With %X{transaction.id:-null} in my logback, I had all transaction ids of every operation when instrumenting the Promises directly.\n\nHm, that's strange.. Maybe there's another thread switch in-between? Could there be some work-stealing going on? Is it seemingly random when the MDC works and when it doesn't? In the cases where there's no MDC, does ElasticApm.currentSpan() (from the apm-agent-api module) return a noop span?\nThe debug message about ClassNotFoundException: org.apache.log4j.MDC can be ignored.", "author": "felixbarny", "createdAt": "2020-04-29T08:11:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0MjU0NQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417242545", "bodyText": "At the moment it looks quite random. I'll look into into it a bit more to see if I can reproduce it in a better way.\nBut as far as I understand it, the logging should be part of the submitted Runnable and therefore have exactly the same transaction as the action it is logging.", "author": "milanvdm", "createdAt": "2020-04-29T11:24:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI1NTM3Nw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417255377", "bodyText": "Yes, that's correct. Whenever a span is activated, it also sets the MDC.", "author": "felixbarny", "createdAt": "2020-04-29T11:49:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI1Njk5Mg==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417256992", "bodyText": "In the cases where there's no MDC, does ElasticApm.currentSpan() (from the apm-agent-api module) return a noop span?\n\nWould you test this by adding doing something like:\nprintln(ElasticApm.currentSpan())\nlog.info(testing MDC)", "author": "milanvdm", "createdAt": "2020-04-29T11:52:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI1Nzk2OA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417257968", "bodyText": "Yes, exactly", "author": "felixbarny", "createdAt": "2020-04-29T11:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU1NDYwNw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417554607", "bodyText": "@felixbarny The println of ElasticApm.currentSpan().getId() returns an empty String so according to the docs it is indeed a noop.\nI'll need to check how the logging is executed in a different thread for whatever reason.", "author": "milanvdm", "createdAt": "2020-04-29T19:21:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg5MDgwMQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417890801", "bodyText": "It seems to be related to the usage of the Scala sttp library. It wraps the AsyncHttpClient from Java with https://github.com/reactive-streams/reactive-streams-jvm.\nAsyncHttpClient from Java uses https://github.com/reactive-streams/reactive-streams-jvm and it the way how the sttp library uses it, makes it lose the context.\nI'm checking out where it exactly loses the tracing context.", "author": "milanvdm", "createdAt": "2020-04-30T09:50:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk1Mjg2OA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417952868", "bodyText": "@felixbarny So basically what happens is that the Scala future will be completed (scheduled?) the moment override def onCompleted(): Unit is called on the org.asynchttpclient.handler.StreamedAsyncHandler.\nIf I add an ElasticAPM.currentSpan() in the onCompleted, it prints a Noop which shows that no trace-context is available at that moment. And therefore, also not on the Scala Future that gets completed by that method.\nI assume because the AsyncHttpClient is instrumented on the executeRequest, it causes the span of the http request to still be correctly closed.\nBut because I continue logging after the completion of the Scala future, the logging lost its context due to the org.asynchttpclient.handler.StreamedAsyncHandler.\nThis seems to boil down to a decision on instrumenting on a Promise directly or instrumenting the ExecutionContext. Unless you see it as a mistake that the trace-context is not passed into the org.asynchttpclient.handler.StreamedAsyncHandler#onCompleted?\nBut maybe there are other cases where thread-switches happen and that a Scala Future is completed on a different thread where there is no trace-context.", "author": "milanvdm", "createdAt": "2020-04-30T11:50:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0MzY5Mg==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r419543692", "bodyText": "So basically what happens is that the Scala future will be completed (scheduled?) the moment override def onCompleted(): Unit is called on the org.asynchttpclient.handler.StreamedAsyncHandler\n\nThanks for the analysis!\n\nUnless you see it as a mistake that the trace-context is not passed into the org.asynchttpclient.handler.StreamedAsyncHandler#onCompleted?\n\nYes, that's a mistake.\nThis should be easy to fix in the AsyncHttpClient instrumentation:\n\n  \n    \n      apm-agent-java/apm-agent-plugins/apm-asynchttpclient-plugin/src/main/java/co/elastic/apm/agent/asynchttpclient/AbstractAsyncHttpClientInstrumentation.java\n    \n    \n        Lines 174 to 187\n      in\n      94c9215\n    \n    \n    \n    \n\n        \n          \n           public static class AsyncHandlerOnCompletedInstrumentation extends AbstractAsyncHandlerInstrumentation { \n        \n\n        \n          \n            \n        \n\n        \n          \n               public AsyncHandlerOnCompletedInstrumentation() { \n        \n\n        \n          \n                   super(named(\"onCompleted\").and(takesArguments(0))); \n        \n\n        \n          \n               } \n        \n\n        \n          \n            \n        \n\n        \n          \n               @Advice.OnMethodEnter(suppress = Throwable.class) \n        \n\n        \n          \n               private static void onMethodEnter(@Advice.This AsyncHandler<?> asyncHandler) { \n        \n\n        \n          \n                   final Span span = handlerSpanMap.remove(asyncHandler); \n        \n\n        \n          \n                   if (span != null) { \n        \n\n        \n          \n                       span.end(); \n        \n\n        \n          \n                   } \n        \n\n        \n          \n               } \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nWe should activate the span in the @OnMethodEnter advice and deactivate it in the @OnMethodExit advice.", "author": "felixbarny", "createdAt": "2020-05-04T15:58:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1NzkwOA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r419557908", "bodyText": "@felixbarny Cool :) Can I try to create a PR to fix the AsyncHttpClient or do you prefer to do it from your side?\nOnce that is merged, Ill continue with testing this PR and start cleaning it up.", "author": "milanvdm", "createdAt": "2020-05-04T16:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3MDM5OA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r419570398", "bodyText": "Can I try to create a PR to fix the AsyncHttpClient or do you prefer to do it from your side?\n\nSure, go ahead! I think we should do the activation on all currently instrumented AsyncHandler callback methods. This way, users can add custom stuff in their own callbacks to the spans like ElasticApm.currentSpan().addCustom(\"foo\", responseStatus.getStatusText());", "author": "felixbarny", "createdAt": "2020-05-04T16:37:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYyNzU3OA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r419627578", "bodyText": "@felixbarny First attempt: #1172\nWill need some help on how to add proper tests for this though.", "author": "milanvdm", "createdAt": "2020-05-04T18:08:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1ODMyMQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r422058321", "bodyText": "@felixbarny I missed a method onStream on #1172 so will create a follow PR to add that one as well.\nLocally, it seems the span is now correctly passed along the AsyncHandler but there is still a place in my test setup where the span is not correctly passed on through all the Scala Futures.\nI will investigate further but I am maybe thinking there was a reason why other solutions instrument the Promise directly and not the ExecutionContext.", "author": "milanvdm", "createdAt": "2020-05-08T10:02:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA4NzMxMA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r422087310", "bodyText": "Both approaches seem to have their pros and cons. I currently don't have a clear opinion which is the best approach. I'm leaning towards instrument on ExecutionContext#execute as it's more efficient (no startup overhead) and supports propagating context for Promises that are created outside of a transaction. But I also see that it requires more work and is potentially more brittle.", "author": "felixbarny", "createdAt": "2020-05-08T11:17:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ3NjQwNg==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r422476406", "bodyText": "@felixbarny\nI went into the code again and found the behavior described in the accepted answer on https://stackoverflow.com/questions/59642314/scala-future-with-callback-and-context-switching.\nWhat seems to happen is that if a Future is already completed, it will be executed immediately. Meaning that final AbstractSpan<?> active = getActive(); in the OnExecute instrumentation, may return a null since the callback is executed on a thread that does not have an active span on it.\nSince the scala.concurrent.impl.Promise.DefaultPromise#dispatchOrAddCallback is the method that is executing the Future, this method somehow needs to be able to track which span is linked to that Future/Promise.\nI think this forces the choice to instrument on the Future/Promise directly instead of with the ExecutionContext.\nOne if the issues with instrumenting on the Promise directly, seems to be the extra dependency on Scala in the agent which cause some strange LinkageErrors sometimes. Is this related to the reason why the Elastic agent needs to shade libraries to avoid certain conflicts?", "author": "milanvdm", "createdAt": "2020-05-09T09:46:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzMjkwNQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r424232905", "bodyText": "I added the instrumentation on the Promise back. It all works now for my test-setup.\nI sometimes get a warning though:\n09:35:28.230 [ForkJoinPool-5-worker-19] WARN co.elastic.apm.agent.impl.ElasticApmTracer - Tried to start a span with a non-zero reference count 1 'GET postman-echo.com' 00-00e98d3ae2d1d3665c8286557ca405f1-05f18334e53a3ee6-01 (3c295061)\nAs well as the LinkageError in some cases:\n[ERROR] Exception in thread \"main\" java.lang.LinkageError: loader constraint violation: loader 'bootstrap' wants to load class scala.collection.immutable.LazyList$State$Empty$. A different class with the same name was previously loaded by 'app'. (scala.collection.immutable.LazyList$State$Empty$ is in unnamed module of loader 'app')", "author": "milanvdm", "createdAt": "2020-05-13T07:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTczMTE2OQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r425731169", "bodyText": "@felixbarny As discussed, I make the Map use an Object instead of a Promise but it still get the Linkage issue. Here is the full trace:\nscala-elastic-apm[ERROR] Exception in thread \"main\" java.lang.LinkageError: loader constraint violation: loader 'bootstrap' wants to load class scala.collection.immutable.LazyList$State$Empty$. A different class with the same name was previously loaded by 'app'. (scala.collection.immutable.LazyList$State$Empty$ is in unnamed module of loader 'app')\nscala-elastic-apm[ERROR] \tat scala.collection.immutable.LazyList$.<clinit>(LazyList.scala:949)\nscala-elastic-apm[ERROR] \tat scala.package$.<clinit>(package.scala:89)\nscala-elastic-apm 2020-05-15 13:09:22.792 [elastic-apm-init-instrumentation-shutdown-hook] INFO co.elastic.apm.agent.impl.ElasticApmTracer - Tracer switched to STOPPED state\nscala-elastic-apm[ERROR] \tat scala.Predef$.<clinit>(Predef.scala:154)\nscala-elastic-apm 2020-05-15 13:09:22.792 [elastic-apm-init-instrumentation-shutdown-hook] INFO co.elastic.apm.agent.report.ApmServerReporter - dropped events because of full queue: 0\nscala-elastic-apm[ERROR] \tat scala.concurrent.Future$.<clinit>(Future.scala:520)\nscala-elastic-apm[ERROR] \tat me.milan.main.future.Main$.delayedEndpoint$me$milan$main$future$Main$1(Main.scala:32)\nscala-elastic-apm[ERROR] \tat me.milan.main.future.Main$delayedInit$body.apply(Main.scala:19)\nscala-elastic-apm[ERROR] \tat scala.Function0.apply$mcV$sp(Function0.scala:39)\nscala-elastic-apm[ERROR] \tat scala.Function0.apply$mcV$sp$(Function0.scala:39)\nscala-elastic-apm[ERROR] \tat scala.runtime.AbstractFunction0.apply$mcV$sp(AbstractFunction0.scala:17)\nscala-elastic-apm[ERROR] \tat scala.App.$anonfun$main$1(App.scala:73)\nscala-elastic-apm[ERROR] \tat scala.App.$anonfun$main$1$adapted(App.scala:73)\nscala-elastic-apm[ERROR] \tat scala.collection.IterableOnceOps.foreach(IterableOnce.scala:553)\nscala-elastic-apm[ERROR] \tat scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:551)\nscala-elastic-apm[ERROR] \tat scala.collection.AbstractIterable.foreach(Iterable.scala:920)\nscala-elastic-apm[ERROR] \tat scala.App.main(App.scala:73)\nscala-elastic-apm[ERROR] \tat scala.App.main$(App.scala:71)\nscala-elastic-apm[ERROR] \tat me.milan.main.future.Main$.main(Main.scala:19)", "author": "milanvdm", "createdAt": "2020-05-15T11:11:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTczNTMwMw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r425735303", "bodyText": "Actually, the usage of Promise as a type parameter of the map shouldn't be a problem because of type erasure.\nWhat you could try is to use Object instead of Promise<?> in the advice method signatures and cast within the method body. Maybe that avoids some eager linking. For example:\n        @Advice.OnMethodExit(suppress = Throwable.class)\n        public static void onExit(@Advice.This Object thiz) {\n            final AbstractSpan<?> context = getActive();\n            if (context != null) {\n                promisesToContext.put(thiz, context);\n            }\n        }", "author": "felixbarny", "createdAt": "2020-05-15T11:20:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc2MjIwNg==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r425762206", "bodyText": "Some things:\n\nWhen I use Object in the Map and method so that I can remove the Scala dependency, there is no LinkageError.\nUsing Promise in the Map and in the method parameters Object does still have the LinkageError\nThe LinkageError does only happen when forking the JVM (in case of running Debug from IntelliJ or using something like https://github.com/spray/sbt-revolver to start your application)", "author": "milanvdm", "createdAt": "2020-05-15T12:18:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NDQ4OQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r426154489", "bodyText": "The LinkageError also happens when Cinnamon is enabled (and without running a forked JVM). So it seems specific to the Scala dependencies clashing somehow.\nOn the WARN that is happening:\nscala-elastic-apm 2020-05-15 14:08:53.201 [ForkJoinPool-1-worker-23] WARN co.elastic.apm.agent.impl.ElasticApmTracer - Tried to start a span with a non-zero reference count 1 'SELECT' 00-fbed3a699f6c244dffa8de3a3d95e48d-bd4655c8959cd4c8-01 (7b9e3d51)\nIm confused on how this warning can be generated. The method that logs this warning, first creates a new Span, and then counts the references. I don't see how the new Span can suddenly have any references right after being made and before the method actually returns the created Span.", "author": "milanvdm", "createdAt": "2020-05-16T13:39:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NTk5NQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r426155995", "bodyText": "I've added suggestions that are likely to fix the cause of this.\n\nI don't see how the new Span can suddenly have any references right after being made and before the method actually returns the created Span.\n\nThat's because the span it gets out of the pool is still being referenced.", "author": "felixbarny", "createdAt": "2020-05-16T13:59:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1OTkzMQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r426159931", "bodyText": "The WARN is gone indeed :)\nSo ElasticAPM uses a pool of Spans that it cycles through? And since the Span is creating in the Promise but only activated later on, it may be that the Span gets recycled before it is actually used?\nIncrementing and decrementing makes sure the Span does not get recycled?", "author": "milanvdm", "createdAt": "2020-05-16T14:47:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2MTYwNg==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r426161606", "bodyText": "Exactly. The pool is basically a queue that is initially empty. When trying to get a span from an empty pool, a new span is created. If the reference count if a span is 0, it gets recycled. Activating a span increments the reference count so under normal circumstances, you don\u2019t have to worry about the ref count. But in those async scenarios, it\u2019s important to keep the span alive if it can be used after it\u2019s ended.", "author": "felixbarny", "createdAt": "2020-05-16T15:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA5NDU4MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r427094581", "bodyText": "And since the Span is creating in the Promise but only activated later on, it may be that the Span gets recycled before it is actually used?\n\nActually, it's not creating any span for the Promise. It just propagates the span that has been active when the promise was created to the thread that executes the promise. But the span might be already ended once the promise is executed.", "author": "felixbarny", "createdAt": "2020-05-19T07:43:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}], "type": "inlineReview"}, {"oid": "9d0eb3926e7a103d72c4757b7fc3a47ef6dc1451", "url": "https://github.com/elastic/apm-agent-java/commit/9d0eb3926e7a103d72c4757b7fc3a47ef6dc1451", "message": "Instrument ExecutionContext", "committedDate": "2020-04-24T18:06:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MjQxNw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417142417", "bodyText": "To properly deactivate on exit with considering wrapped promises, add @Advice.Local(\"context\") TraceContextHolder<?> context to the parameters.", "author": "felixbarny", "createdAt": "2020-04-29T08:16:55Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Promise<?>, TraceContextHolder<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    public static class ExecutionContextInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.ExecutionContext\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher(){\n+            return named(\"execute\").and(returns(void.class)).and(takesArguments(Runnable.class));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onExecute(@Advice.Argument(value = 0, readOnly = false) @Nullable Runnable runnable) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null && runnable != null && tracer != null) {\n+                // Do no discard branches leading to async operations so not to break span references\n+                active.setDiscard(false);\n+                runnable = active.withActive(runnable);\n+            }\n+        }\n+\n+    }\n+\n+    public static class BatchedExecutionContextInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.BatchingExecutor\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher(){\n+            return named(\"submitForExecution\").and(returns(void.class)).and(takesArguments(Runnable.class))\n+                .or(named(\"submitAsyncBatched\").and(returns(void.class)).and(takesArguments(Runnable.class)))\n+                .or(named(\"submitSyncBatched\").and(returns(void.class)).and(takesArguments(Runnable.class)));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onExecute(@Advice.Argument(value = 0, readOnly = false) @Nullable Runnable runnable) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null && runnable != null && tracer != null) {\n+                // Do no discard branches leading to async operations so not to break span references\n+                active.setDiscard(false);\n+                runnable = active.withActive(runnable);\n+            }\n+        }\n+\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null) {\n+                promisesToContext.put(thiz, active);\n+            }\n+        }\n+\n+    }\n+\n+    public static class RunInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"run\").and(returns(void.class));\n+        }\n+\n+        @VisibleForAdvice\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onEnter(@Advice.This Promise<?> thiz) {", "originalCommit": "9d0eb3926e7a103d72c4757b7fc3a47ef6dc1451", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MzkzMg==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417143932", "bodyText": "Maybe the non-deactivated context has something to do with the MDC issue.", "author": "felixbarny", "createdAt": "2020-04-29T08:19:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MjQxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0MTUwNQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417241505", "bodyText": "Im not using the matchers on the Promise directly anymore. I'm only using matchers on the ExecutionContext directly using the wrapped Runnables:\nco.elastic.apm.agent.scala.concurrent.FutureInstrumentation$ExecutionContextInstrumentation\nco.elastic.apm.agent.scala.concurrent.FutureInstrumentation$BatchedExecutionContextInstrumentation\n#co.elastic.apm.agent.scala.concurrent.FutureInstrumentation$ConstructorInstrumentation\n#co.elastic.apm.agent.scala.concurrent.FutureInstrumentation$RunInstrumentation", "author": "milanvdm", "createdAt": "2020-04-29T11:22:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MjQxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI1NTM1Ng==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417255356", "bodyText": "ah, got it", "author": "felixbarny", "createdAt": "2020-04-29T11:49:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MjQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MjczMw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417142733", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public static void onExit(@Advice.This Promise<?> thiz) {\n          \n          \n            \n                    public static void onExit(@Advice.This Promise<?> thiz, @Nullable @Advice.Local(\"context\") TraceContextHolder<?> context) {", "author": "felixbarny", "createdAt": "2020-04-29T08:17:34Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Promise<?>, TraceContextHolder<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    public static class ExecutionContextInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.ExecutionContext\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher(){\n+            return named(\"execute\").and(returns(void.class)).and(takesArguments(Runnable.class));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onExecute(@Advice.Argument(value = 0, readOnly = false) @Nullable Runnable runnable) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null && runnable != null && tracer != null) {\n+                // Do no discard branches leading to async operations so not to break span references\n+                active.setDiscard(false);\n+                runnable = active.withActive(runnable);\n+            }\n+        }\n+\n+    }\n+\n+    public static class BatchedExecutionContextInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.BatchingExecutor\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher(){\n+            return named(\"submitForExecution\").and(returns(void.class)).and(takesArguments(Runnable.class))\n+                .or(named(\"submitAsyncBatched\").and(returns(void.class)).and(takesArguments(Runnable.class)))\n+                .or(named(\"submitSyncBatched\").and(returns(void.class)).and(takesArguments(Runnable.class)));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onExecute(@Advice.Argument(value = 0, readOnly = false) @Nullable Runnable runnable) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null && runnable != null && tracer != null) {\n+                // Do no discard branches leading to async operations so not to break span references\n+                active.setDiscard(false);\n+                runnable = active.withActive(runnable);\n+            }\n+        }\n+\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null) {\n+                promisesToContext.put(thiz, active);\n+            }\n+        }\n+\n+    }\n+\n+    public static class RunInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"run\").and(returns(void.class));\n+        }\n+\n+        @VisibleForAdvice\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onEnter(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> context = promisesToContext.getIfPresent(thiz);\n+            if (tracer != null && context != null) {\n+                tracer.activate(context);\n+            }\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {", "originalCommit": "9d0eb3926e7a103d72c4757b7fc3a47ef6dc1451", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MzMzNQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417143335", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        promisesToContext.remove(thiz);\n          \n          \n            \n                        if (context != null) {\n          \n          \n            \n                            promisesToContext.remove(thiz);\n          \n          \n            \n                            tracer.deactivate(context);\n          \n          \n            \n                        }", "author": "felixbarny", "createdAt": "2020-04-29T08:18:41Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Promise<?>, TraceContextHolder<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    public static class ExecutionContextInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.ExecutionContext\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher(){\n+            return named(\"execute\").and(returns(void.class)).and(takesArguments(Runnable.class));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onExecute(@Advice.Argument(value = 0, readOnly = false) @Nullable Runnable runnable) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null && runnable != null && tracer != null) {\n+                // Do no discard branches leading to async operations so not to break span references\n+                active.setDiscard(false);\n+                runnable = active.withActive(runnable);\n+            }\n+        }\n+\n+    }\n+\n+    public static class BatchedExecutionContextInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.BatchingExecutor\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher(){\n+            return named(\"submitForExecution\").and(returns(void.class)).and(takesArguments(Runnable.class))\n+                .or(named(\"submitAsyncBatched\").and(returns(void.class)).and(takesArguments(Runnable.class)))\n+                .or(named(\"submitSyncBatched\").and(returns(void.class)).and(takesArguments(Runnable.class)));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onExecute(@Advice.Argument(value = 0, readOnly = false) @Nullable Runnable runnable) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null && runnable != null && tracer != null) {\n+                // Do no discard branches leading to async operations so not to break span references\n+                active.setDiscard(false);\n+                runnable = active.withActive(runnable);\n+            }\n+        }\n+\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null) {\n+                promisesToContext.put(thiz, active);\n+            }\n+        }\n+\n+    }\n+\n+    public static class RunInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"run\").and(returns(void.class));\n+        }\n+\n+        @VisibleForAdvice\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onEnter(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> context = promisesToContext.getIfPresent(thiz);\n+            if (tracer != null && context != null) {\n+                tracer.activate(context);\n+            }\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            promisesToContext.remove(thiz);", "originalCommit": "9d0eb3926e7a103d72c4757b7fc3a47ef6dc1451", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7ab2834402574dd4baa0c04cf76bf562e9448943", "url": "https://github.com/elastic/apm-agent-java/commit/7ab2834402574dd4baa0c04cf76bf562e9448943", "message": "Merge branch 'master' into add-scala-executor-apm", "committedDate": "2020-05-08T07:39:26Z", "type": "commit"}, {"oid": "ee6da7dacbcded6509264890011e547cffdb3974", "url": "https://github.com/elastic/apm-agent-java/commit/ee6da7dacbcded6509264890011e547cffdb3974", "message": "Add onStream instrumentation on AsyncHandler", "committedDate": "2020-05-08T10:15:57Z", "type": "commit"}, {"oid": "ec2b7eb1da08e9d011da26da03d1ad99fdd6c4c2", "url": "https://github.com/elastic/apm-agent-java/commit/ec2b7eb1da08e9d011da26da03d1ad99fdd6c4c2", "message": "Add StreamHandler tests", "committedDate": "2020-05-08T11:02:49Z", "type": "commit"}, {"oid": "d9e0762aea300de8f45437353e384ec5739a7988", "url": "https://github.com/elastic/apm-agent-java/commit/d9e0762aea300de8f45437353e384ec5739a7988", "message": "Merge branch 'keep-spans-active-on-stream-async-http' into add-scala-executor-apm", "committedDate": "2020-05-08T11:12:00Z", "type": "commit"}, {"oid": "84417b0c209008813b79228a342f5b67c5884c8a", "url": "https://github.com/elastic/apm-agent-java/commit/84417b0c209008813b79228a342f5b67c5884c8a", "message": "Add Promise instrumentation", "committedDate": "2020-05-13T07:18:21Z", "type": "commit"}, {"oid": "199e514be3fcb9baf8fb086eb74a6c3cd217fd9e", "url": "https://github.com/elastic/apm-agent-java/commit/199e514be3fcb9baf8fb086eb74a6c3cd217fd9e", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm", "committedDate": "2020-05-13T07:18:30Z", "type": "commit"}, {"oid": "ad429931922d2f810fed7e4a323b922c89123e33", "url": "https://github.com/elastic/apm-agent-java/commit/ad429931922d2f810fed7e4a323b922c89123e33", "message": "Cleanup", "committedDate": "2020-05-15T09:56:23Z", "type": "commit"}, {"oid": "49bca5fe02443656ffbef02cfcc74f9ee685caf3", "url": "https://github.com/elastic/apm-agent-java/commit/49bca5fe02443656ffbef02cfcc74f9ee685caf3", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm", "committedDate": "2020-05-15T10:22:08Z", "type": "commit"}, {"oid": "e41f63c2d07732c4886892f22a1551dcebeb9062", "url": "https://github.com/elastic/apm-agent-java/commit/e41f63c2d07732c4886892f22a1551dcebeb9062", "message": "Fix versions", "committedDate": "2020-05-15T11:10:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NTQwMw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r426155403", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            promisesToContext.put(thiz, context);\n          \n          \n            \n                            promisesToContext.put(thiz, context);\n          \n          \n            \n                            // this span might be ended before the Promise$Transformation#run method starts\n          \n          \n            \n                            // we have to avoid that this span gets recycled, even in the above mentioned case\n          \n          \n            \n                            context.incrementReferences();", "author": "felixbarny", "createdAt": "2020-05-16T13:50:59Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Object, AbstractSpan<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return named(\"scala.concurrent.impl.Promise$Transformation\");\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            final AbstractSpan<?> context = getActive();\n+            if (context != null) {\n+                promisesToContext.put(thiz, context);", "originalCommit": "e41f63c2d07732c4886892f22a1551dcebeb9062", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NTgyMg==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r426155822", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            tracer.activate(context);\n          \n          \n            \n                            tracer.activate(context);\n          \n          \n            \n                            // decrements the reference we incremented to avoid that the parent context gets recycled before the promise is run\n          \n          \n            \n                            // because we have activated it, we can be sure it doesn't get recycled until we deactivate in the OnMethodExit advice\n          \n          \n            \n                            context.decrementReferences();", "author": "felixbarny", "createdAt": "2020-05-16T13:57:02Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Object, AbstractSpan<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return named(\"scala.concurrent.impl.Promise$Transformation\");\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            final AbstractSpan<?> context = getActive();\n+            if (context != null) {\n+                promisesToContext.put(thiz, context);\n+            }\n+        }\n+\n+    }\n+\n+    public static class RunInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return named(\"scala.concurrent.impl.Promise$Transformation\");\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"run\").and(returns(void.class));\n+        }\n+\n+        @VisibleForAdvice\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onEnter(@Advice.This Promise<?> thiz, @Nullable @Advice.Local(\"context\") AbstractSpan<?> context) {\n+            context = promisesToContext.remove(thiz);\n+            if (tracer != null && context != null) {\n+                tracer.activate(context);", "originalCommit": "e41f63c2d07732c4886892f22a1551dcebeb9062", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a0375b74bf560d68cc4b0f9638d7e05213b81b5d", "url": "https://github.com/elastic/apm-agent-java/commit/a0375b74bf560d68cc4b0f9638d7e05213b81b5d", "message": "Make sure spans are not recycled", "committedDate": "2020-05-16T14:44:58Z", "type": "commit"}, {"oid": "accd469299e47d98a9cd03f6597a25b7bac1b75d", "url": "https://github.com/elastic/apm-agent-java/commit/accd469299e47d98a9cd03f6597a25b7bac1b75d", "message": "Cleanup Java 9 compilers", "committedDate": "2020-05-19T08:38:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM3NDcwOQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r427374709", "bodyText": "Marking as experimental disables this instrumentation by default.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return Arrays.asList(\"concurrent\", \"future\");\n          \n          \n            \n                    return Arrays.asList(\"scala-future\", \"experimental\");", "author": "felixbarny", "createdAt": "2020-05-19T15:03:05Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Object, AbstractSpan<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");", "originalCommit": "accd469299e47d98a9cd03f6597a25b7bac1b75d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7843966cc39a26e402b10955c25ccab258e564d3", "url": "https://github.com/elastic/apm-agent-java/commit/7843966cc39a26e402b10955c25ccab258e564d3", "message": "Add docs", "committedDate": "2020-05-19T17:14:34Z", "type": "commit"}, {"oid": "0f7b25734c84ed509f5f50d42d8249795a8fb4b2", "url": "https://github.com/elastic/apm-agent-java/commit/0f7b25734c84ed509f5f50d42d8249795a8fb4b2", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm", "committedDate": "2020-05-19T17:15:10Z", "type": "commit"}, {"oid": "f9b8e56f8ca5d8c4a5a3f96c120394dfab5cc8a4", "url": "https://github.com/elastic/apm-agent-java/commit/f9b8e56f8ca5d8c4a5a3f96c120394dfab5cc8a4", "message": "Fix merge", "committedDate": "2020-05-19T17:15:45Z", "type": "commit"}, {"oid": "063ed391f99b95686f6b2aec0cabe5a99dcf364d", "url": "https://github.com/elastic/apm-agent-java/commit/063ed391f99b95686f6b2aec0cabe5a99dcf364d", "message": "Remove Java version", "committedDate": "2020-05-27T18:35:14Z", "type": "commit"}, {"oid": "6c638d9509fd5d44d1632d851f4d532089efb15c", "url": "https://github.com/elastic/apm-agent-java/commit/6c638d9509fd5d44d1632d851f4d532089efb15c", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm", "committedDate": "2020-05-27T18:35:22Z", "type": "commit"}, {"oid": "40033fa77968c637587e912fe77d418c7eea1b47", "url": "https://github.com/elastic/apm-agent-java/commit/40033fa77968c637587e912fe77d418c7eea1b47", "message": "Improve testing for edge cases", "committedDate": "2020-05-29T18:47:18Z", "type": "commit"}, {"oid": "5ee2b3b1cff2686e4511fd7651c70967154b2f9b", "url": "https://github.com/elastic/apm-agent-java/commit/5ee2b3b1cff2686e4511fd7651c70967154b2f9b", "message": "Simplify failing test", "committedDate": "2020-05-29T19:02:32Z", "type": "commit"}, {"oid": "1721794b2f3a6c83c4d398fa3b87208dab54cceb", "url": "https://github.com/elastic/apm-agent-java/commit/1721794b2f3a6c83c4d398fa3b87208dab54cceb", "message": "Add extra failing test on Future.sequence", "committedDate": "2020-05-29T19:36:53Z", "type": "commit"}, {"oid": "737bb0e01e1e4aff843a36778f03a3fe2ea4cbf6", "url": "https://github.com/elastic/apm-agent-java/commit/737bb0e01e1e4aff843a36778f03a3fe2ea4cbf6", "message": "Merge branch 'master' into add-scala-executor-apm", "committedDate": "2020-06-15T15:01:40Z", "type": "commit"}, {"oid": "1885c8e64e22363b5ece20d07ddc24ce49496cb5", "url": "https://github.com/elastic/apm-agent-java/commit/1885c8e64e22363b5ece20d07ddc24ce49496cb5", "message": "Add java apm dependency to test", "committedDate": "2020-06-15T16:18:55Z", "type": "commit"}, {"oid": "c893ac024e0fdfa27a97c41708a64f8a72b78964", "url": "https://github.com/elastic/apm-agent-java/commit/c893ac024e0fdfa27a97c41708a64f8a72b78964", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm", "committedDate": "2020-06-17T15:47:04Z", "type": "commit"}, {"oid": "f844049da47c548259973da58d5623fa1bca12b7", "url": "https://github.com/elastic/apm-agent-java/commit/f844049da47c548259973da58d5623fa1bca12b7", "message": "Bump to new snapshot version", "committedDate": "2020-06-17T15:48:28Z", "type": "commit"}, {"oid": "0f530a0684d941e3fd282157f0296ba4435409ac", "url": "https://github.com/elastic/apm-agent-java/commit/0f530a0684d941e3fd282157f0296ba4435409ac", "message": "Start tracer", "committedDate": "2020-06-23T18:24:06Z", "type": "commit"}, {"oid": "c6a6581d6e431a1eb593c16fe6f48c805d1296b4", "url": "https://github.com/elastic/apm-agent-java/commit/c6a6581d6e431a1eb593c16fe6f48c805d1296b4", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm", "committedDate": "2020-06-23T18:24:52Z", "type": "commit"}, {"oid": "b68d3d2f4f87b8921a79cb3a5580c06c3ef8bc8f", "url": "https://github.com/elastic/apm-agent-java/commit/b68d3d2f4f87b8921a79cb3a5580c06c3ef8bc8f", "message": "Merge branch 'master' into add-scala-executor-apm", "committedDate": "2020-06-25T09:17:09Z", "type": "commit"}]}