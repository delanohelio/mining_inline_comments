{"pr_number": 3093, "pr_title": "Stops looking for local RabbitMQ connection", "pr_createdAt": "2020-05-26T02:48:10Z", "pr_url": "https://github.com/openzipkin/zipkin/pull/3093", "timeline": [{"oid": "42619907f911de71d5d1a2e6b76b2bbdf6ddf966", "url": "https://github.com/openzipkin/zipkin/commit/42619907f911de71d5d1a2e6b76b2bbdf6ddf966", "message": "Stops looking for local RabbitMQ connection\n\nThis improves the Docker based RabbitMQ tests in the same manner as\nhttps://github.com/openzipkin/zipkin-reporter-java/pull/176\n\nThis notably stops looking for a local RabbitMQ install. It also reduces\nflakes by using the CLI and not sharing static collector resources in\ninstance-level tests.\n\nFixes #1748", "committedDate": "2020-05-26T02:48:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEzMDQzNg==", "url": "https://github.com/openzipkin/zipkin/pull/3093#discussion_r430130436", "bodyText": "a lot of flakes are possible when static java connections and such are used for test methods.. It is very true that rabbit itself should be instantiated once per (suite if possible) as it is slow to start.", "author": "codefromthecrypt", "createdAt": "2020-05-26T02:49:30Z", "path": "zipkin-collector/rabbitmq/src/test/java/zipkin2/collector/rabbitmq/ITRabbitMQCollector.java", "diffHunk": "@@ -15,151 +15,120 @@\n \n import com.rabbitmq.client.Channel;\n import java.io.IOException;\n-import java.io.UncheckedIOException;\n import java.util.Arrays;\n-import java.util.Collections;\n import java.util.List;\n import java.util.concurrent.TimeoutException;\n import org.junit.After;\n import org.junit.ClassRule;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n-import zipkin2.Component;\n import zipkin2.Span;\n import zipkin2.codec.SpanBytesEncoder;\n-import zipkin2.collector.CollectorMetrics;\n+import zipkin2.collector.InMemoryCollectorMetrics;\n import zipkin2.storage.InMemoryStorage;\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static zipkin2.TestObjects.LOTS_OF_SPANS;\n import static zipkin2.TestObjects.UTF_8;\n+import static zipkin2.codec.SpanBytesEncoder.JSON_V2;\n import static zipkin2.codec.SpanBytesEncoder.THRIFT;\n-import static zipkin2.collector.rabbitmq.RabbitMQCollector.builder;\n \n public class ITRabbitMQCollector {\n   List<Span> spans = Arrays.asList(LOTS_OF_SPANS[0], LOTS_OF_SPANS[1]);\n \n-  @ClassRule\n-  public static RabbitMQCollectorRule rabbit = new RabbitMQCollectorRule(\"rabbitmq:3.7-alpine\");\n+  @ClassRule public static RabbitMQCollectorRule rabbit = new RabbitMQCollectorRule();\n \n-  @After\n-  public void clear() {\n-    rabbit.metrics.clear();", "originalCommit": "42619907f911de71d5d1a2e6b76b2bbdf6ddf966", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEzMTI1Ng==", "url": "https://github.com/openzipkin/zipkin/pull/3093#discussion_r430131256", "bodyText": "As far as I know rabbit is push not poll, so any delay here would be how long it can decode the message and synchronously add to our in-memory storage. 200L is a bit excessive but less slow than 1s", "author": "codefromthecrypt", "createdAt": "2020-05-26T02:53:37Z", "path": "zipkin-collector/rabbitmq/src/test/java/zipkin2/collector/rabbitmq/ITRabbitMQCollector.java", "diffHunk": "@@ -15,151 +15,120 @@\n \n import com.rabbitmq.client.Channel;\n import java.io.IOException;\n-import java.io.UncheckedIOException;\n import java.util.Arrays;\n-import java.util.Collections;\n import java.util.List;\n import java.util.concurrent.TimeoutException;\n import org.junit.After;\n import org.junit.ClassRule;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n-import zipkin2.Component;\n import zipkin2.Span;\n import zipkin2.codec.SpanBytesEncoder;\n-import zipkin2.collector.CollectorMetrics;\n+import zipkin2.collector.InMemoryCollectorMetrics;\n import zipkin2.storage.InMemoryStorage;\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static zipkin2.TestObjects.LOTS_OF_SPANS;\n import static zipkin2.TestObjects.UTF_8;\n+import static zipkin2.codec.SpanBytesEncoder.JSON_V2;\n import static zipkin2.codec.SpanBytesEncoder.THRIFT;\n-import static zipkin2.collector.rabbitmq.RabbitMQCollector.builder;\n \n public class ITRabbitMQCollector {\n   List<Span> spans = Arrays.asList(LOTS_OF_SPANS[0], LOTS_OF_SPANS[1]);\n \n-  @ClassRule\n-  public static RabbitMQCollectorRule rabbit = new RabbitMQCollectorRule(\"rabbitmq:3.7-alpine\");\n+  @ClassRule public static RabbitMQCollectorRule rabbit = new RabbitMQCollectorRule();\n \n-  @After\n-  public void clear() {\n-    rabbit.metrics.clear();\n-    rabbit.storage.clear();\n-  }\n-\n-  @Rule public ExpectedException thrown = ExpectedException.none();\n+  InMemoryStorage storage = InMemoryStorage.newBuilder().build();\n+  InMemoryCollectorMetrics metrics = new InMemoryCollectorMetrics();\n+  InMemoryCollectorMetrics rabbitmqMetrics = metrics.forTransport(\"rabbitmq\");\n+  RabbitMQCollector collector = rabbit.tryToInitializeCollector(newCollectorBuilder()).start();\n \n-  @Test\n-  public void checkPasses() {\n-    assertThat(rabbit.collector.check().ok()).isTrue();\n-  }\n-\n-  @Test\n-  public void startFailsWithInvalidRabbitMqServer() throws Exception {\n-    // we can be pretty certain RabbitMQ isn't running on localhost port 80\n-    String notRabbitMqAddress = \"localhost:80\";\n-    try (RabbitMQCollector collector =\n-        builder().addresses(Collections.singletonList(notRabbitMqAddress)).build()) {\n-      thrown.expect(UncheckedIOException.class);\n-      thrown.expectMessage(\"Unable to establish connection to RabbitMQ server: Connection refused\");\n-      collector.start();\n-    }\n+  @After public void after() throws Exception {\n+    collector.close();\n   }\n \n   /** Ensures list encoding works: a json encoded list of spans */\n-  @Test\n-  public void messageWithMultipleSpans_json() throws Exception {\n+  @Test public void messageWithMultipleSpans_json() throws Exception {\n     messageWithMultipleSpans(SpanBytesEncoder.JSON_V1);\n   }\n \n   /** Ensures list encoding works: a version 2 json list of spans */\n-  @Test\n-  public void messageWithMultipleSpans_json2() throws Exception {\n+  @Test public void messageWithMultipleSpans_json2() throws Exception {\n     messageWithMultipleSpans(SpanBytesEncoder.JSON_V2);\n   }\n \n   /** Ensures list encoding works: proto3 ListOfSpans */\n-  @Test\n-  public void messageWithMultipleSpans_proto3() throws Exception {\n+  @Test public void messageWithMultipleSpans_proto3() throws Exception {\n     messageWithMultipleSpans(SpanBytesEncoder.PROTO3);\n   }\n \n   void messageWithMultipleSpans(SpanBytesEncoder encoder) throws Exception {\n     byte[] message = encoder.encodeList(spans);\n-    rabbit.publish(message);\n+    publish(message);\n \n-    Thread.sleep(1000);\n-    assertThat(rabbit.storage.acceptedSpanCount()).isEqualTo(spans.size());\n+    Thread.sleep(200L);\n+    assertThat(storage.acceptedSpanCount()).isEqualTo(spans.size());\n \n-    assertThat(rabbit.rabbitmqMetrics.messages()).isEqualTo(1);\n-    assertThat(rabbit.rabbitmqMetrics.messagesDropped()).isZero();\n-    assertThat(rabbit.rabbitmqMetrics.bytes()).isEqualTo(message.length);\n-    assertThat(rabbit.rabbitmqMetrics.spans()).isEqualTo(spans.size());\n-    assertThat(rabbit.rabbitmqMetrics.spansDropped()).isZero();\n+    assertThat(rabbitmqMetrics.messages()).isEqualTo(1);\n+    assertThat(rabbitmqMetrics.messagesDropped()).isZero();\n+    assertThat(rabbitmqMetrics.bytes()).isEqualTo(message.length);\n+    assertThat(rabbitmqMetrics.spans()).isEqualTo(spans.size());\n+    assertThat(rabbitmqMetrics.spansDropped()).isZero();\n   }\n \n   /** Ensures malformed spans don't hang the collector */\n-  @Test\n-  public void skipsMalformedData() throws Exception {\n+  @Test public void skipsMalformedData() throws Exception {\n     byte[] malformed1 = \"[\\\"='\".getBytes(UTF_8); // screwed up json\n     byte[] malformed2 = \"malformed\".getBytes(UTF_8);\n-    rabbit.publish(THRIFT.encodeList(spans));\n-    rabbit.publish(new byte[0]);\n-    rabbit.publish(malformed1);\n-    rabbit.publish(malformed2);\n-    rabbit.publish(THRIFT.encodeList(spans));\n+    publish(THRIFT.encodeList(spans));\n+    publish(new byte[0]);\n+    publish(malformed1);\n+    publish(malformed2);\n+    publish(THRIFT.encodeList(spans));\n \n-    Thread.sleep(1000);\n+    Thread.sleep(200L);", "originalCommit": "42619907f911de71d5d1a2e6b76b2bbdf6ddf966", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0ab388a8621d697da9adaa13653bb7218e4287cf", "url": "https://github.com/openzipkin/zipkin/commit/0ab388a8621d697da9adaa13653bb7218e4287cf", "message": "less problems", "committedDate": "2020-05-26T04:00:42Z", "type": "commit"}]}