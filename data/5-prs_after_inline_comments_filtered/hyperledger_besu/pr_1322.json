{"pr_number": 1322, "pr_title": "Fix  memory expansion bounds checking", "pr_createdAt": "2020-08-19T17:57:48Z", "pr_url": "https://github.com/hyperledger/besu/pull/1322", "timeline": [{"oid": "282edd50737d64bfe988bae5b1a3c9740462cac1", "url": "https://github.com/hyperledger/besu/commit/282edd50737d64bfe988bae5b1a3c9740462cac1", "message": "Fix  memory expansion bounds checking\n\nWhen a CALL series operation has an erroneous input offset (such as\nstarting at a ETH address instead of a real offset) we threw an\nArithmeticException.\n\n* Restore the old memory bounds checking on memory expansion\n* Treat these formerly uncaught exceptions as invalid transactions and\n  report errors with a stack trace and custom halt reason.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-08-19T17:56:44Z", "type": "commit"}, {"oid": "2bfc4279e823f1afaa11de13393464e15b50afcc", "url": "https://github.com/hyperledger/besu/commit/2bfc4279e823f1afaa11de13393464e15b50afcc", "message": "spotless\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-08-19T18:52:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMDQ2NQ==", "url": "https://github.com/hyperledger/besu/pull/1322#discussion_r474100465", "bodyText": "How come we don't need this in the PrivateTransactionProcessor?", "author": "RatanRSur", "createdAt": "2020-08-20T16:07:51Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/MainnetTransactionProcessor.java", "diffHunk": "@@ -208,193 +209,204 @@ public Result processTransaction(\n       final BlockHashLookup blockHashLookup,\n       final Boolean isPersistingPrivateState,\n       final TransactionValidationParams transactionValidationParams) {\n-    LOG.trace(\"Starting execution of {}\", transaction);\n-\n-    ValidationResult<TransactionValidator.TransactionInvalidReason> validationResult =\n-        transactionValidator.validate(transaction, blockHeader.getBaseFee());\n-    // Make sure the transaction is intrinsically valid before trying to\n-    // compare against a sender account (because the transaction may not\n-    // be signed correctly to extract the sender).\n-    if (!validationResult.isValid()) {\n-      LOG.warn(\"Invalid transaction: {}\", validationResult.getErrorMessage());\n-      return Result.invalid(validationResult);\n-    }\n+    try {\n+      LOG.trace(\"Starting execution of {}\", transaction);\n+\n+      ValidationResult<TransactionValidator.TransactionInvalidReason> validationResult =\n+          transactionValidator.validate(transaction, blockHeader.getBaseFee());\n+      // Make sure the transaction is intrinsically valid before trying to\n+      // compare against a sender account (because the transaction may not\n+      // be signed correctly to extract the sender).\n+      if (!validationResult.isValid()) {\n+        LOG.warn(\"Invalid transaction: {}\", validationResult.getErrorMessage());\n+        return Result.invalid(validationResult);\n+      }\n \n-    final Address senderAddress = transaction.getSender();\n-    final DefaultEvmAccount sender = worldState.getOrCreate(senderAddress);\n-    validationResult =\n-        transactionValidator.validateForSender(transaction, sender, transactionValidationParams);\n-    if (!validationResult.isValid()) {\n-      LOG.debug(\"Invalid transaction: {}\", validationResult.getErrorMessage());\n-      return Result.invalid(validationResult);\n-    }\n+      final Address senderAddress = transaction.getSender();\n+      final DefaultEvmAccount sender = worldState.getOrCreate(senderAddress);\n+      validationResult =\n+          transactionValidator.validateForSender(transaction, sender, transactionValidationParams);\n+      if (!validationResult.isValid()) {\n+        LOG.debug(\"Invalid transaction: {}\", validationResult.getErrorMessage());\n+        return Result.invalid(validationResult);\n+      }\n \n-    final MutableAccount senderMutableAccount = sender.getMutable();\n-    final long previousNonce = senderMutableAccount.incrementNonce();\n-    final Wei transactionGasPrice =\n-        transactionPriceCalculator.price(transaction, blockHeader.getBaseFee());\n-    LOG.trace(\n-        \"Incremented sender {} nonce ({} -> {})\", senderAddress, previousNonce, sender.getNonce());\n-\n-    final Wei upfrontGasCost = transaction.getUpfrontGasCost(transactionGasPrice);\n-    final Wei previousBalance = senderMutableAccount.decrementBalance(upfrontGasCost);\n-    LOG.trace(\n-        \"Deducted sender {} upfront gas cost {} ({} -> {})\",\n-        senderAddress,\n-        upfrontGasCost,\n-        previousBalance,\n-        sender.getBalance());\n-\n-    final Gas intrinsicGas = gasCalculator.transactionIntrinsicGasCost(transaction);\n-    final Gas gasAvailable = Gas.of(transaction.getGasLimit()).minus(intrinsicGas);\n-    LOG.trace(\n-        \"Gas available for execution {} = {} - {} (limit - intrinsic)\",\n-        gasAvailable,\n-        transaction.getGasLimit(),\n-        intrinsicGas);\n-\n-    final WorldUpdater worldUpdater = worldState.updater();\n-    final MessageFrame initialFrame;\n-    final Deque<MessageFrame> messageFrameStack = new ArrayDeque<>();\n-    final ReturnStack returnStack = new ReturnStack();\n-\n-    if (transaction.isContractCreation()) {\n-      final Address contractAddress =\n-          Address.contractAddress(senderAddress, sender.getNonce() - 1L);\n-\n-      initialFrame =\n-          MessageFrame.builder()\n-              .type(MessageFrame.Type.CONTRACT_CREATION)\n-              .messageFrameStack(messageFrameStack)\n-              .returnStack(returnStack)\n-              .blockchain(blockchain)\n-              .worldState(worldUpdater.updater())\n-              .initialGas(gasAvailable)\n-              .address(contractAddress)\n-              .originator(senderAddress)\n-              .contract(contractAddress)\n-              .contractAccountVersion(createContractAccountVersion)\n-              .gasPrice(transactionGasPrice)\n-              .inputData(Bytes.EMPTY)\n-              .sender(senderAddress)\n-              .value(transaction.getValue())\n-              .apparentValue(transaction.getValue())\n-              .code(new Code(transaction.getPayload()))\n-              .blockHeader(blockHeader)\n-              .depth(0)\n-              .completer(c -> {})\n-              .miningBeneficiary(miningBeneficiary)\n-              .blockHashLookup(blockHashLookup)\n-              .isPersistingPrivateState(isPersistingPrivateState)\n-              .maxStackSize(maxStackSize)\n-              .transactionHash(transaction.getHash())\n-              .build();\n-\n-    } else {\n-      final Address to = transaction.getTo().get();\n-      final Account contract = worldState.get(to);\n-\n-      initialFrame =\n-          MessageFrame.builder()\n-              .type(MessageFrame.Type.MESSAGE_CALL)\n-              .messageFrameStack(messageFrameStack)\n-              .returnStack(returnStack)\n-              .blockchain(blockchain)\n-              .worldState(worldUpdater.updater())\n-              .initialGas(gasAvailable)\n-              .address(to)\n-              .originator(senderAddress)\n-              .contract(to)\n-              .contractAccountVersion(\n-                  contract != null ? contract.getVersion() : Account.DEFAULT_VERSION)\n-              .gasPrice(transactionGasPrice)\n-              .inputData(transaction.getPayload())\n-              .sender(senderAddress)\n-              .value(transaction.getValue())\n-              .apparentValue(transaction.getValue())\n-              .code(new Code(contract != null ? contract.getCode() : Bytes.EMPTY))\n-              .blockHeader(blockHeader)\n-              .depth(0)\n-              .completer(c -> {})\n-              .miningBeneficiary(miningBeneficiary)\n-              .blockHashLookup(blockHashLookup)\n-              .maxStackSize(maxStackSize)\n-              .isPersistingPrivateState(isPersistingPrivateState)\n-              .transactionHash(transaction.getHash())\n-              .build();\n-    }\n+      final MutableAccount senderMutableAccount = sender.getMutable();\n+      final long previousNonce = senderMutableAccount.incrementNonce();\n+      final Wei transactionGasPrice =\n+          transactionPriceCalculator.price(transaction, blockHeader.getBaseFee());\n+      LOG.trace(\n+          \"Incremented sender {} nonce ({} -> {})\",\n+          senderAddress,\n+          previousNonce,\n+          sender.getNonce());\n \n-    messageFrameStack.addFirst(initialFrame);\n+      final Wei upfrontGasCost = transaction.getUpfrontGasCost(transactionGasPrice);\n+      final Wei previousBalance = senderMutableAccount.decrementBalance(upfrontGasCost);\n+      LOG.trace(\n+          \"Deducted sender {} upfront gas cost {} ({} -> {})\",\n+          senderAddress,\n+          upfrontGasCost,\n+          previousBalance,\n+          sender.getBalance());\n+\n+      final Gas intrinsicGas = gasCalculator.transactionIntrinsicGasCost(transaction);\n+      final Gas gasAvailable = Gas.of(transaction.getGasLimit()).minus(intrinsicGas);\n+      LOG.trace(\n+          \"Gas available for execution {} = {} - {} (limit - intrinsic)\",\n+          gasAvailable,\n+          transaction.getGasLimit(),\n+          intrinsicGas);\n+\n+      final WorldUpdater worldUpdater = worldState.updater();\n+      final MessageFrame initialFrame;\n+      final Deque<MessageFrame> messageFrameStack = new ArrayDeque<>();\n+      final ReturnStack returnStack = new ReturnStack();\n+\n+      if (transaction.isContractCreation()) {\n+        final Address contractAddress =\n+            Address.contractAddress(senderAddress, sender.getNonce() - 1L);\n+\n+        initialFrame =\n+            MessageFrame.builder()\n+                .type(MessageFrame.Type.CONTRACT_CREATION)\n+                .messageFrameStack(messageFrameStack)\n+                .returnStack(returnStack)\n+                .blockchain(blockchain)\n+                .worldState(worldUpdater.updater())\n+                .initialGas(gasAvailable)\n+                .address(contractAddress)\n+                .originator(senderAddress)\n+                .contract(contractAddress)\n+                .contractAccountVersion(createContractAccountVersion)\n+                .gasPrice(transactionGasPrice)\n+                .inputData(Bytes.EMPTY)\n+                .sender(senderAddress)\n+                .value(transaction.getValue())\n+                .apparentValue(transaction.getValue())\n+                .code(new Code(transaction.getPayload()))\n+                .blockHeader(blockHeader)\n+                .depth(0)\n+                .completer(c -> {})\n+                .miningBeneficiary(miningBeneficiary)\n+                .blockHashLookup(blockHashLookup)\n+                .isPersistingPrivateState(isPersistingPrivateState)\n+                .maxStackSize(maxStackSize)\n+                .transactionHash(transaction.getHash())\n+                .build();\n+\n+      } else {\n+        final Address to = transaction.getTo().get();\n+        final Account contract = worldState.get(to);\n+\n+        initialFrame =\n+            MessageFrame.builder()\n+                .type(MessageFrame.Type.MESSAGE_CALL)\n+                .messageFrameStack(messageFrameStack)\n+                .returnStack(returnStack)\n+                .blockchain(blockchain)\n+                .worldState(worldUpdater.updater())\n+                .initialGas(gasAvailable)\n+                .address(to)\n+                .originator(senderAddress)\n+                .contract(to)\n+                .contractAccountVersion(\n+                    contract != null ? contract.getVersion() : Account.DEFAULT_VERSION)\n+                .gasPrice(transactionGasPrice)\n+                .inputData(transaction.getPayload())\n+                .sender(senderAddress)\n+                .value(transaction.getValue())\n+                .apparentValue(transaction.getValue())\n+                .code(new Code(contract != null ? contract.getCode() : Bytes.EMPTY))\n+                .blockHeader(blockHeader)\n+                .depth(0)\n+                .completer(c -> {})\n+                .miningBeneficiary(miningBeneficiary)\n+                .blockHashLookup(blockHashLookup)\n+                .maxStackSize(maxStackSize)\n+                .isPersistingPrivateState(isPersistingPrivateState)\n+                .transactionHash(transaction.getHash())\n+                .build();\n+      }\n \n-    while (!messageFrameStack.isEmpty()) {\n-      process(messageFrameStack.peekFirst(), operationTracer);\n-    }\n+      messageFrameStack.addFirst(initialFrame);\n \n-    if (initialFrame.getState() == MessageFrame.State.COMPLETED_SUCCESS) {\n-      worldUpdater.commit();\n-    }\n+      while (!messageFrameStack.isEmpty()) {\n+        process(messageFrameStack.peekFirst(), operationTracer);\n+      }\n \n-    if (LOG.isTraceEnabled()) {\n-      LOG.trace(\n-          \"Gas used by transaction: {}, by message call/contract creation: {}\",\n-          () -> Gas.of(transaction.getGasLimit()).minus(initialFrame.getRemainingGas()),\n-          () -> gasAvailable.minus(initialFrame.getRemainingGas()));\n-    }\n+      if (initialFrame.getState() == MessageFrame.State.COMPLETED_SUCCESS) {\n+        worldUpdater.commit();\n+      }\n \n-    // Refund the sender by what we should and pay the miner fee (note that we're doing them one\n-    // after the other so that if it is the same account somehow, we end up with the right result)\n-    final Gas selfDestructRefund =\n-        gasCalculator.getSelfDestructRefundAmount().times(initialFrame.getSelfDestructs().size());\n-    final Gas refundGas = initialFrame.getGasRefund().plus(selfDestructRefund);\n-    final Gas refunded = refunded(transaction, initialFrame.getRemainingGas(), refundGas);\n-    final Wei refundedWei = refunded.priceFor(transactionGasPrice);\n-    senderMutableAccount.incrementBalance(refundedWei);\n-\n-    final Gas gasUsedByTransaction =\n-        Gas.of(transaction.getGasLimit()).minus(initialFrame.getRemainingGas());\n-\n-    final MutableAccount coinbase = worldState.getOrCreate(miningBeneficiary).getMutable();\n-    final Gas coinbaseFee = Gas.of(transaction.getGasLimit()).minus(refunded);\n-    if (blockHeader.getBaseFee().isPresent() && transaction.isEIP1559Transaction()) {\n-      final Wei baseFee = Wei.of(blockHeader.getBaseFee().get());\n-      if (transactionGasPrice.compareTo(baseFee) < 0) {\n-        return Result.failed(\n-            gasUsedByTransaction.toLong(),\n-            refunded.toLong(),\n-            ValidationResult.invalid(\n-                TransactionValidator.TransactionInvalidReason.TRANSACTION_PRICE_TOO_LOW,\n-                \"transaction price must be greater than base fee\"),\n-            Optional.empty());\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\n+            \"Gas used by transaction: {}, by message call/contract creation: {}\",\n+            () -> Gas.of(transaction.getGasLimit()).minus(initialFrame.getRemainingGas()),\n+            () -> gasAvailable.minus(initialFrame.getRemainingGas()));\n       }\n-    }\n-    final CoinbaseFeePriceCalculator coinbaseCreditService =\n-        transaction.isFrontierTransaction()\n-            ? CoinbaseFeePriceCalculator.frontier()\n-            : coinbaseFeePriceCalculator;\n-    final Wei coinbaseWeiDelta =\n-        coinbaseCreditService.price(coinbaseFee, transactionGasPrice, blockHeader.getBaseFee());\n \n-    coinbase.incrementBalance(coinbaseWeiDelta);\n+      // Refund the sender by what we should and pay the miner fee (note that we're doing them one\n+      // after the other so that if it is the same account somehow, we end up with the right result)\n+      final Gas selfDestructRefund =\n+          gasCalculator.getSelfDestructRefundAmount().times(initialFrame.getSelfDestructs().size());\n+      final Gas refundGas = initialFrame.getGasRefund().plus(selfDestructRefund);\n+      final Gas refunded = refunded(transaction, initialFrame.getRemainingGas(), refundGas);\n+      final Wei refundedWei = refunded.priceFor(transactionGasPrice);\n+      senderMutableAccount.incrementBalance(refundedWei);\n+\n+      final Gas gasUsedByTransaction =\n+          Gas.of(transaction.getGasLimit()).minus(initialFrame.getRemainingGas());\n+\n+      final MutableAccount coinbase = worldState.getOrCreate(miningBeneficiary).getMutable();\n+      final Gas coinbaseFee = Gas.of(transaction.getGasLimit()).minus(refunded);\n+      if (blockHeader.getBaseFee().isPresent() && transaction.isEIP1559Transaction()) {\n+        final Wei baseFee = Wei.of(blockHeader.getBaseFee().get());\n+        if (transactionGasPrice.compareTo(baseFee) < 0) {\n+          return Result.failed(\n+              gasUsedByTransaction.toLong(),\n+              refunded.toLong(),\n+              ValidationResult.invalid(\n+                  TransactionValidator.TransactionInvalidReason.TRANSACTION_PRICE_TOO_LOW,\n+                  \"transaction price must be greater than base fee\"),\n+              Optional.empty());\n+        }\n+      }\n+      final CoinbaseFeePriceCalculator coinbaseCreditService =\n+          transaction.isFrontierTransaction()\n+              ? CoinbaseFeePriceCalculator.frontier()\n+              : coinbaseFeePriceCalculator;\n+      final Wei coinbaseWeiDelta =\n+          coinbaseCreditService.price(coinbaseFee, transactionGasPrice, blockHeader.getBaseFee());\n \n-    initialFrame.getSelfDestructs().forEach(worldState::deleteAccount);\n+      coinbase.incrementBalance(coinbaseWeiDelta);\n \n-    if (clearEmptyAccounts) {\n-      clearEmptyAccounts(worldState);\n-    }\n+      initialFrame.getSelfDestructs().forEach(worldState::deleteAccount);\n \n-    if (initialFrame.getState() == MessageFrame.State.COMPLETED_SUCCESS) {\n-      return Result.successful(\n-          initialFrame.getLogs(),\n-          gasUsedByTransaction.toLong(),\n-          refunded.toLong(),\n-          initialFrame.getOutputData(),\n-          validationResult);\n-    } else {\n-      return Result.failed(\n-          gasUsedByTransaction.toLong(),\n-          refunded.toLong(),\n-          validationResult,\n-          initialFrame.getRevertReason());\n+      if (clearEmptyAccounts) {\n+        clearEmptyAccounts(worldState);\n+      }\n+\n+      if (initialFrame.getState() == MessageFrame.State.COMPLETED_SUCCESS) {\n+        return Result.successful(\n+            initialFrame.getLogs(),\n+            gasUsedByTransaction.toLong(),\n+            refunded.toLong(),\n+            initialFrame.getOutputData(),\n+            validationResult);\n+      } else {\n+        return Result.failed(\n+            gasUsedByTransaction.toLong(),\n+            refunded.toLong(),\n+            validationResult,\n+            initialFrame.getRevertReason());\n+      }\n+    } catch (final RuntimeException re) {\n+      LOG.error(\"Critical Exception Processing Transaction\", re);\n+      return Result.invalid(\n+          ValidationResult.invalid(\n+              TransactionInvalidReason.INTERNAL_ERROR,\n+              \"Internal Error in Besu - \" + re.toString()));\n     }", "originalCommit": "2bfc4279e823f1afaa11de13393464e15b50afcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwODM5Nw==", "url": "https://github.com/hyperledger/besu/pull/1322#discussion_r474108397", "bodyText": "We need it there too.  Added.", "author": "shemnon", "createdAt": "2020-08-20T16:20:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMDQ2NQ=="}], "type": "inlineReview"}, {"oid": "23ced9de382e1a4f574a72dcdfa8e2d4bfbb9fa6", "url": "https://github.com/hyperledger/besu/commit/23ced9de382e1a4f574a72dcdfa8e2d4bfbb9fa6", "message": "add to PrivateTransactionProcessor\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-08-20T16:19:49Z", "type": "commit"}, {"oid": "7f1dc4a68128ebb76fabe162d31aa9fb00c60688", "url": "https://github.com/hyperledger/besu/commit/7f1dc4a68128ebb76fabe162d31aa9fb00c60688", "message": "Merge branch 'master' into memoryExpansion", "committedDate": "2020-08-20T16:20:21Z", "type": "commit"}]}