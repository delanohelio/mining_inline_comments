{"pr_number": 1664, "pr_title": "Bonsai Tries early prototype", "pr_createdAt": "2020-12-03T20:39:06Z", "pr_url": "https://github.com/hyperledger/besu/pull/1664", "timeline": [{"oid": "a90611b1dbfc3d83bf6e45913ebd550fb74c7d7f", "url": "https://github.com/hyperledger/besu/commit/a90611b1dbfc3d83bf6e45913ebd550fb74c7d7f", "message": "Change Native AltBN library\n\nUse the MatterLabs AltBN library.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-09-29T01:26:02Z", "type": "commit"}, {"oid": "78a63f160a79fdcdee64b96042de55cbd61244fe", "url": "https://github.com/hyperledger/besu/commit/78a63f160a79fdcdee64b96042de55cbd61244fe", "message": "checkpoint - up to SLOAD on Goerli\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-09-29T23:33:27Z", "type": "commit"}, {"oid": "931ad4e0f6fc654f38f032100ae8fc93870feedf", "url": "https://github.com/hyperledger/besu/commit/931ad4e0f6fc654f38f032100ae8fc93870feedf", "message": "write stuff to disk\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-09-29T23:33:27Z", "type": "commit"}, {"oid": "900e0794ee19ff4dbdb1e99eac8c2a67d3e97cb3", "url": "https://github.com/hyperledger/besu/commit/900e0794ee19ff4dbdb1e99eac8c2a67d3e97cb3", "message": "works up until a TX reverts\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-09-29T23:33:27Z", "type": "commit"}, {"oid": "e2663065a3005f9ee86c340ef18c377c09ff3445", "url": "https://github.com/hyperledger/besu/commit/e2663065a3005f9ee86c340ef18c377c09ff3445", "message": "Refactors:\n\n* Move UpdateTracingAccount to package level\n* Rename DefaultEvmAccount to WrappedEvmAccount\n* Change some method signatures to use ? extends Account\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-09-29T23:33:27Z", "type": "commit"}, {"oid": "6e6ad5de4cd3e25a3f625b1d5602ce3caaa264f5", "url": "https://github.com/hyperledger/besu/commit/6e6ad5de4cd3e25a3f625b1d5602ce3caaa264f5", "message": "BonsaiUpdater uses stacked updater and abstract updater\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-09-29T23:33:28Z", "type": "commit"}, {"oid": "cc5fe7cb07fc99cdcbbba4e7c822cc5dea26d78c", "url": "https://github.com/hyperledger/besu/commit/cc5fe7cb07fc99cdcbbba4e7c822cc5dea26d78c", "message": "non-threaded block import\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-09-29T23:33:44Z", "type": "commit"}, {"oid": "d3b0d48fb307af5aa633492768f9bb55c3c67199", "url": "https://github.com/hyperledger/besu/commit/d3b0d48fb307af5aa633492768f9bb55c3c67199", "message": "works up to requireing storage clearing.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-09-29T23:34:36Z", "type": "commit"}, {"oid": "6de579673ec94fa95a4393df97c5ada05057e202", "url": "https://github.com/hyperledger/besu/commit/6de579673ec94fa95a4393df97c5ada05057e202", "message": "proper account clearing\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-09-29T23:34:39Z", "type": "commit"}, {"oid": "6927d6be7a123ec7d1d1644bdffac2c3b3c31c9a", "url": "https://github.com/hyperledger/besu/commit/6927d6be7a123ec7d1d1644bdffac2c3b3c31c9a", "message": "goerli syncs leaf piles\n\n* fix last sstore original value issues\n* manicure trie\n* reformat\n* remove logging\n* fix broken tests\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-09-29T23:34:39Z", "type": "commit"}, {"oid": "eaab141b665fec06ef7471ce79bfd28d607572ea", "url": "https://github.com/hyperledger/besu/commit/eaab141b665fec06ef7471ce79bfd28d607572ea", "message": "follow standard experimental flags rules\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-09-29T23:39:39Z", "type": "commit"}, {"oid": "8c5185eb3cb939a7c708ffd4cf6f1c96b9fa3a3f", "url": "https://github.com/hyperledger/besu/commit/8c5185eb3cb939a7c708ffd4cf6f1c96b9fa3a3f", "message": "EIP-2999\n\nUpdate costs to 2999\nUpdate benchmark\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-01T22:49:38Z", "type": "commit"}, {"oid": "8bd5ea9d3260a11ee18b6317046b47c20cbf14b3", "url": "https://github.com/hyperledger/besu/commit/8bd5ea9d3260a11ee18b6317046b47c20cbf14b3", "message": "update g2add vector.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-02T14:28:24Z", "type": "commit"}, {"oid": "a8063cf8829224f7084d9ff5485d424883569b2a", "url": "https://github.com/hyperledger/besu/commit/a8063cf8829224f7084d9ff5485d424883569b2a", "message": "use library's input padding.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-02T15:15:50Z", "type": "commit"}, {"oid": "38072c77bde7c4b1e591cbe413a48e10a188a380", "url": "https://github.com/hyperledger/besu/commit/38072c77bde7c4b1e591cbe413a48e10a188a380", "message": "modexp bench and repricing\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-02T19:30:09Z", "type": "commit"}, {"oid": "d813f2e02d5ff4623da8579749215573e003058e", "url": "https://github.com/hyperledger/besu/commit/d813f2e02d5ff4623da8579749215573e003058e", "message": "Merge branch 'master' into bonsai\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>\n\n# Conflicts:\n#\tbesu/src/main/java/org/hyperledger/besu/controller/BesuControllerBuilder.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/core/AbstractWorldUpdater.java", "committedDate": "2020-10-05T19:42:38Z", "type": "commit"}, {"oid": "5443698ff922cb7ef11da11f27466d1bef4b4b2a", "url": "https://github.com/hyperledger/besu/commit/5443698ff922cb7ef11da11f27466d1bef4b4b2a", "message": "cleanup\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-05T20:07:27Z", "type": "commit"}, {"oid": "ab3fd49e7105d4ee13a23677ce7a5185e89c9efc", "url": "https://github.com/hyperledger/besu/commit/ab3fd49e7105d4ee13a23677ce7a5185e89c9efc", "message": "trie log writes\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-07T14:44:47Z", "type": "commit"}, {"oid": "cd3011c1bd8493f8e21b37401081ccc6a349c4ca", "url": "https://github.com/hyperledger/besu/commit/cd3011c1bd8493f8e21b37401081ccc6a349c4ca", "message": "use bonsaivalue for account changes instead of toUpdate/toDelete\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-09T21:38:09Z", "type": "commit"}, {"oid": "8e9fb7ddcd172ad4af5567d8b759dcf93dfdf3dc", "url": "https://github.com/hyperledger/besu/commit/8e9fb7ddcd172ad4af5567d8b759dcf93dfdf3dc", "message": "factor out rolling writers\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-12T22:44:39Z", "type": "commit"}, {"oid": "41c3ec6e59ecdcd9c6361c7d6c99b86317812b6b", "url": "https://github.com/hyperledger/besu/commit/41c3ec6e59ecdcd9c6361c7d6c99b86317812b6b", "message": "rollforward simple one and stacked\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-12T22:45:06Z", "type": "commit"}, {"oid": "ec94d735c85c81993450063e5c7f8e7034e902b5", "url": "https://github.com/hyperledger/besu/commit/ec94d735c85c81993450063e5c7f8e7034e902b5", "message": "account trie didn't commit.  fix that.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-15T14:45:04Z", "type": "commit"}, {"oid": "789a030e3aa0ebab401a48f63a9e49c6ce3897d6", "url": "https://github.com/hyperledger/besu/commit/789a030e3aa0ebab401a48f63a9e49c6ce3897d6", "message": "just an order issue\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-15T20:44:50Z", "type": "commit"}, {"oid": "a5d129c854e713a142b68bd1017cc0b44019b5bf", "url": "https://github.com/hyperledger/besu/commit/a5d129c854e713a142b68bd1017cc0b44019b5bf", "message": "cleanup\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-16T02:44:42Z", "type": "commit"}, {"oid": "1a9d8fa162eaef8b0a3862a1d7c40225f518ad7a", "url": "https://github.com/hyperledger/besu/commit/1a9d8fa162eaef8b0a3862a1d7c40225f518ad7a", "message": "Merge branch 'master' of github.com:hyperledger/besu into bonsai\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-16T02:44:59Z", "type": "commit"}, {"oid": "daebbcab63e96836ad5cd48833cd0c521c213e3f", "url": "https://github.com/hyperledger/besu/commit/daebbcab63e96836ad5cd48833cd0c521c213e3f", "message": "formatting fixes and errorprone\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-16T05:22:39Z", "type": "commit"}, {"oid": "ebb840755a120c80f8fa9946f7c8e54dce38c521", "url": "https://github.com/hyperledger/besu/commit/ebb840755a120c80f8fa9946f7c8e54dce38c521", "message": "rollback was easy.  Still need to fix trie log to block hash plumbing.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-16T15:15:30Z", "type": "commit"}, {"oid": "a967b4707e5521d4c311e5db4467256b49a20502", "url": "https://github.com/hyperledger/besu/commit/a967b4707e5521d4c311e5db4467256b49a20502", "message": "fix table flub\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-16T18:36:23Z", "type": "commit"}, {"oid": "5a4f9202462facb2f1da301e50de64ae12c1597b", "url": "https://github.com/hyperledger/besu/commit/5a4f9202462facb2f1da301e50de64ae12c1597b", "message": "persist by blokc hash\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-16T23:24:03Z", "type": "commit"}, {"oid": "59f0cb8f05b27f6e235110e871b9dbb0747bbf6a", "url": "https://github.com/hyperledger/besu/commit/59f0cb8f05b27f6e235110e871b9dbb0747bbf6a", "message": "goerli roll-forward to 1M blocks\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-21T05:51:39Z", "type": "commit"}, {"oid": "fb5d110c1a9ecf2efbc6313fca653e439614d756", "url": "https://github.com/hyperledger/besu/commit/fb5d110c1a9ecf2efbc6313fca653e439614d756", "message": "full roll of 3.5MM of bonsai\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-22T01:22:38Z", "type": "commit"}, {"oid": "8166ee4fe806d873453e3192f34431f5a88ae766", "url": "https://github.com/hyperledger/besu/commit/8166ee4fe806d873453e3192f34431f5a88ae766", "message": "add mgps stats\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-22T15:58:37Z", "type": "commit"}, {"oid": "bae33cef7e088fdfcd501db65aa0ed940bfae1bf", "url": "https://github.com/hyperledger/besu/commit/bae33cef7e088fdfcd501db65aa0ed940bfae1bf", "message": "restore threaded block importer\n\nfix build errors.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-23T05:59:48Z", "type": "commit"}, {"oid": "85cbbf8790136e8620cc5a5d0a7ab625624334ed", "url": "https://github.com/hyperledger/besu/commit/85cbbf8790136e8620cc5a5d0a7ab625624334ed", "message": "Merge branch 'master' of github.com:hyperledger/besu into bonsai\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-23T15:34:26Z", "type": "commit"}, {"oid": "95ad665e7cfe0a339755de1873332ca340f9de95", "url": "https://github.com/hyperledger/besu/commit/95ad665e7cfe0a339755de1873332ca340f9de95", "message": "spotless and one benchmark\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-23T21:36:14Z", "type": "commit"}, {"oid": "36ee810f5281b59ca60ef4c4395d62384d937169", "url": "https://github.com/hyperledger/besu/commit/36ee810f5281b59ca60ef4c4395d62384d937169", "message": "Merge branch 'master' of github.com:hyperledger/besu into matterLabsAltBN\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-23T21:39:04Z", "type": "commit"}, {"oid": "2dc7b4f51aa920ab68d9ca30254307cb6e4d0e1b", "url": "https://github.com/hyperledger/besu/commit/2dc7b4f51aa920ab68d9ca30254307cb6e4d0e1b", "message": "Merge branch 'matterLabsAltBN' of github.com:shemnon/besu into bonsai\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-23T21:47:33Z", "type": "commit"}, {"oid": "652b1d4caa5ecec91e483f52e975262f210d5828", "url": "https://github.com/hyperledger/besu/commit/652b1d4caa5ecec91e483f52e975262f210d5828", "message": "no really, write the layer file\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-10-29T22:13:45Z", "type": "commit"}, {"oid": "372da84a402cf3f5c4702a34a9b636c06eea2547", "url": "https://github.com/hyperledger/besu/commit/372da84a402cf3f5c4702a34a9b636c06eea2547", "message": "merge\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-11-03T04:24:01Z", "type": "commit"}, {"oid": "9d31fbf14814aa894d4494b38af2e9fa86e8ece4", "url": "https://github.com/hyperledger/besu/commit/9d31fbf14814aa894d4494b38af2e9fa86e8ece4", "message": "add location to nodeloader and nodeupdater\n\nAdd the trie location as args to NodeLoader and NodeUpdater.  Tried to\nmake sensible changes to all the tendrils but likely this will have far\nreaching impacts.  Tests _currently_ pass.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-11-03T20:49:46Z", "type": "commit"}, {"oid": "7323aa4c75906d8b330339bec0a453d0696bb988", "url": "https://github.com/hyperledger/besu/commit/7323aa4c75906d8b330339bec0a453d0696bb988", "message": "merge\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-11-09T22:15:48Z", "type": "commit"}, {"oid": "ad6a4648a9b57c17b5f7f2fd60b6ca670e25a506", "url": "https://github.com/hyperledger/besu/commit/ad6a4648a9b57c17b5f7f2fd60b6ca670e25a506", "message": "by location storage\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-11-09T22:42:20Z", "type": "commit"}, {"oid": "a51b98320b5edc87d51c3743bdb9a969b0b89f4c", "url": "https://github.com/hyperledger/besu/commit/a51b98320b5edc87d51c3743bdb9a969b0b89f4c", "message": "cleanup\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-11-09T23:12:53Z", "type": "commit"}, {"oid": "7a794af8b17c66904391f7fc264f7d5960590cb5", "url": "https://github.com/hyperledger/besu/commit/7a794af8b17c66904391f7fc264f7d5960590cb5", "message": "fix forest fast sync\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-11-09T23:42:17Z", "type": "commit"}, {"oid": "2651166106ea383fc08fda03dc84d1698224e506", "url": "https://github.com/hyperledger/besu/commit/2651166106ea383fc08fda03dc84d1698224e506", "message": "speling and other cleanup\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-11-10T19:44:12Z", "type": "commit"}, {"oid": "46bdc4267210158483e4f7819ef45fa2d5c53373", "url": "https://github.com/hyperledger/besu/commit/46bdc4267210158483e4f7819ef45fa2d5c53373", "message": "cleanup\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-11-10T20:44:25Z", "type": "commit"}, {"oid": "cfbfd8068b7151c72a24f966f943b269814565e3", "url": "https://github.com/hyperledger/besu/commit/cfbfd8068b7151c72a24f966f943b269814565e3", "message": "logging formatting\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-11-10T23:19:54Z", "type": "commit"}, {"oid": "07893e870b4ad47803029bfd1cbb63a46b4e3107", "url": "https://github.com/hyperledger/besu/commit/07893e870b4ad47803029bfd1cbb63a46b4e3107", "message": "one more place for duration.  Up to 1 sec/block\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-11-11T00:16:54Z", "type": "commit"}, {"oid": "bc32a55c00fb773063d8d73c7e3807b30dbf430b", "url": "https://github.com/hyperledger/besu/commit/bc32a55c00fb773063d8d73c7e3807b30dbf430b", "message": "one more place for gas, 12.5MMx1K = 12.5B\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-11-11T01:44:55Z", "type": "commit"}, {"oid": "40dda02915492b3d80df9576d136823b2e8d0ca6", "url": "https://github.com/hyperledger/besu/commit/40dda02915492b3d80df9576d136823b2e8d0ca6", "message": "split out mutable state into BonsaiWorldStateUpdater and DB access into\nBonsaiPersistedWorldState\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-11-24T22:49:37Z", "type": "commit"}, {"oid": "e8f7c7a5c4c4d83d9e444d763eb44033ca61cbd4", "url": "https://github.com/hyperledger/besu/commit/e8f7c7a5c4c4d83d9e444d763eb44033ca61cbd4", "message": "merge\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-11-25T07:28:19Z", "type": "commit"}, {"oid": "cb628222ae814f36737786457745d6e9c825284f", "url": "https://github.com/hyperledger/besu/commit/cb628222ae814f36737786457745d6e9c825284f", "message": "unneeded change\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-11-25T15:58:03Z", "type": "commit"}, {"oid": "cf9acaeaa127a0c1f7aa6b5b87862f31028dc3f5", "url": "https://github.com/hyperledger/besu/commit/cf9acaeaa127a0c1f7aa6b5b87862f31028dc3f5", "message": "javadoc\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-11-25T16:50:31Z", "type": "commit"}, {"oid": "1765a29aacd48a4dbd84e7c16c680b1857810fdf", "url": "https://github.com/hyperledger/besu/commit/1765a29aacd48a4dbd84e7c16c680b1857810fdf", "message": "Merge branch 'master' of github.com:hyperledger/besu into bonsai\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-11-28T03:32:40Z", "type": "commit"}, {"oid": "19bce4a437441342f7d49219b0f0338ab8218e44", "url": "https://github.com/hyperledger/besu/commit/19bce4a437441342f7d49219b0f0338ab8218e44", "message": "Merge branch 'master' of github.com:hyperledger/besu into bonsai\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-11-30T18:35:23Z", "type": "commit"}, {"oid": "8b8015b97eb05b7882893a12b68a1f24e98c2af0", "url": "https://github.com/hyperledger/besu/commit/8b8015b97eb05b7882893a12b68a1f24e98c2af0", "message": "merge\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-12-01T15:25:42Z", "type": "commit"}, {"oid": "56fa83e1cbcd2a86bacbe87357e39d364c4f83c2", "url": "https://github.com/hyperledger/besu/commit/56fa83e1cbcd2a86bacbe87357e39d364c4f83c2", "message": "run form layered data\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-12-01T23:22:32Z", "type": "commit"}, {"oid": "abfc47f27a822e64fd85b02369c245de4db96ecd", "url": "https://github.com/hyperledger/besu/commit/abfc47f27a822e64fd85b02369c245de4db96ecd", "message": "merge\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-12-02T22:46:23Z", "type": "commit"}, {"oid": "508457808b61bd40b9c83b3d46a1a259f954962a", "url": "https://github.com/hyperledger/besu/commit/508457808b61bd40b9c83b3d46a1a259f954962a", "message": "deletes were not getting rolled forward\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-12-03T06:41:22Z", "type": "commit"}, {"oid": "c43ec5a44488483e38d8ce205db65c239dff7634", "url": "https://github.com/hyperledger/besu/commit/c43ec5a44488483e38d8ce205db65c239dff7634", "message": "Merge branch 'master' of github.com:hyperledger/besu into bonsai\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-12-03T06:41:51Z", "type": "commit"}, {"oid": "f00806d75c18c3d48043c3dbf7e1ebecdc25ec3d", "url": "https://github.com/hyperledger/besu/commit/f00806d75c18c3d48043c3dbf7e1ebecdc25ec3d", "message": "merge cleanup\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-12-03T20:22:00Z", "type": "commit"}, {"oid": "dbbc1465c97b96dfc23e9e72d80c64fe40bffaf4", "url": "https://github.com/hyperledger/besu/commit/dbbc1465c97b96dfc23e9e72d80c64fe40bffaf4", "message": "missed a FIXME\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-12-03T20:25:56Z", "type": "commit"}, {"oid": "bd172d3bfc76ff65ff2067b3023fa2e9877d4d04", "url": "https://github.com/hyperledger/besu/commit/bd172d3bfc76ff65ff2067b3023fa2e9877d4d04", "message": "more FIXMEs\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-12-03T20:28:42Z", "type": "commit"}, {"oid": "59fc091f99c97138ebea7d85508338acbff836dc", "url": "https://github.com/hyperledger/besu/commit/59fc091f99c97138ebea7d85508338acbff836dc", "message": "spotless\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-12-03T20:54:16Z", "type": "commit"}, {"oid": "9ce1bf43aa2de39044b0a277b603e9caabd35408", "url": "https://github.com/hyperledger/besu/commit/9ce1bf43aa2de39044b0a277b603e9caabd35408", "message": "fix two exception messages and the plugin API hash\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-12-03T21:16:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY4NzE5NA==", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r535687194", "bodyText": "\ud83e\udd23", "author": "timbeiko", "createdAt": "2020-12-03T22:23:14Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiAccount.java", "diffHunk": "@@ -251,7 +251,7 @@ public UInt256 getOriginalStorageValue(final UInt256 key) {\n   @Override\n   public NavigableMap<Bytes32, AccountStorageEntry> storageEntriesFrom(\n       final Bytes32 startKeyHash, final int limit) {\n-    throw new RuntimeException(\"LOL no\");", "originalCommit": "9ce1bf43aa2de39044b0a277b603e9caabd35408", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a9bd8d5200aae80bd1b6643b996130975eafb94d", "url": "https://github.com/hyperledger/besu/commit/a9bd8d5200aae80bd1b6643b996130975eafb94d", "message": "semmle fixes\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-12-03T22:34:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA2OTE2MQ==", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536069161", "bodyText": "Does this byte32 with SuppressWarnings unused is important ? For future use ?", "author": "matkt", "createdAt": "2020-12-04T12:36:34Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiPersistedWorldState.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import static org.hyperledger.besu.ethereum.bonsai.BonsaiAccount.fromRLP;\n+\n+import org.hyperledger.besu.ethereum.core.Account;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.MerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorage;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorageTransaction;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import javax.annotation.Nonnull;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class BonsaiPersistedWorldState implements MutableWorldState, BonsaiWorldState {\n+\n+  private static final byte[] WORLD_ROOT_KEY = \"worldRoot\".getBytes(StandardCharsets.UTF_8);\n+\n+  private final KeyValueStorage accountStorage;\n+  private final KeyValueStorage codeStorage;\n+  private final KeyValueStorage storageStorage;\n+  private final KeyValueStorage trieBranchStorage;\n+  private final KeyValueStorage trieLogStorage;\n+\n+  private Bytes32 worldStateRootHash;\n+\n+  private final BonsaiWorldStateArchive archive;\n+  private BonsaiWorldStateUpdater updater;\n+\n+  public BonsaiPersistedWorldState(\n+      final BonsaiWorldStateArchive archive,\n+      final KeyValueStorage accountStorage,\n+      final KeyValueStorage codeStorage,\n+      final KeyValueStorage storageStorage,\n+      final KeyValueStorage trieBranchStorage,\n+      final KeyValueStorage trieLogStorage) {\n+    this.archive = archive;\n+    this.accountStorage = accountStorage;\n+    this.codeStorage = codeStorage;\n+    this.storageStorage = storageStorage;\n+    this.trieBranchStorage = trieBranchStorage;\n+    this.trieLogStorage = trieLogStorage;\n+    worldStateRootHash =\n+        Bytes32.wrap(\n+            trieBranchStorage.get(WORLD_ROOT_KEY).map(Bytes::wrap).orElse(Hash.EMPTY_TRIE_HASH));\n+  }\n+\n+  public BonsaiWorldStateArchive getArchive() {\n+    return archive;\n+  }\n+\n+  @Override\n+  public MutableWorldState copy() {\n+    throw new UnsupportedOperationException(\n+        \"Bonsai Tries does not support direct duplication of the persisted tries.\");\n+  }\n+\n+  @Override\n+  public Bytes getCode(@Nonnull final Address address) {\n+    return codeStorage.get(address.toArrayUnsafe()).map(Bytes::wrap).orElse(Bytes.EMPTY);\n+  }\n+\n+  @Override\n+  public void persist(final Hash blockHash) {\n+    boolean success = false;\n+    final KeyValueStorageTransaction accountTx = accountStorage.startTransaction();\n+    final KeyValueStorageTransaction codeTx = codeStorage.startTransaction();\n+    final KeyValueStorageTransaction storageTx = storageStorage.startTransaction();\n+    final KeyValueStorageTransaction trieBranchTx = trieBranchStorage.startTransaction();\n+    final KeyValueStorageTransaction trieLogTx = trieLogStorage.startTransaction();\n+\n+    try {\n+      // first clear storage\n+      for (final Address address : updater.getStorageToClear()) {\n+        // because we are clearing persisted values we need the account root as persisted\n+        final BonsaiAccount oldAccount =\n+            accountStorage\n+                .get(address.toArrayUnsafe())\n+                .map(\n+                    bytes ->\n+                        fromRLP(BonsaiPersistedWorldState.this, address, Bytes.wrap(bytes), true))\n+                .orElse(null);\n+        if (oldAccount == null) {\n+          // This is when an account is both created and deleted within the scope of the same\n+          // block.  A not-uncommon DeFi bot pattern.\n+          continue;\n+        }\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(address, location, key),\n+                oldAccount.getStorageRoot(),\n+                Function.identity(),\n+                Function.identity());\n+        Map<Bytes32, Bytes> entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+        while (!entriesToDelete.isEmpty()) {\n+          entriesToDelete\n+              .keySet()\n+              .forEach(k -> storageTx.remove(Bytes.concatenate(address, k).toArrayUnsafe()));\n+          if (entriesToDelete.size() == 256) {\n+            entriesToDelete.keySet().forEach(storageTrie::remove);\n+            entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+          } else {\n+            break;\n+          }\n+        }\n+      }\n+\n+      // second update account storage state.  This must be done before updating the accounts so\n+      // that we can get the storage state hash\n+      for (final Map.Entry<Address, Map<Hash, BonsaiValue<UInt256>>> storageAccountUpdate :\n+          updater.getStorageToUpdate().entrySet()) {\n+        final Address updatedAddress = storageAccountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> accountValue =\n+            updater.getAccountsToUpdate().get(updatedAddress);\n+        final BonsaiAccount accountOriginal = accountValue.getOriginal();\n+        final Hash storageRoot =\n+            (accountOriginal == null) ? Hash.EMPTY_TRIE_HASH : accountOriginal.getStorageRoot();\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(updatedAddress, location, key),\n+                storageRoot,\n+                Function.identity(),\n+                Function.identity());\n+\n+        // for manicured tries and composting, collect branches here (not implemented)\n+\n+        for (final Map.Entry<Hash, BonsaiValue<UInt256>> storageUpdate :\n+            storageAccountUpdate.getValue().entrySet()) {\n+          final Hash keyHash = storageUpdate.getKey();\n+          final byte[] writeAddress = Bytes.concatenate(updatedAddress, keyHash).toArrayUnsafe();\n+          final UInt256 updatedStorage = storageUpdate.getValue().getUpdated();\n+          if (updatedStorage == null || updatedStorage.equals(UInt256.ZERO)) {\n+            storageTx.remove(writeAddress);\n+            storageTrie.remove(keyHash);\n+          } else {\n+            final Bytes32 updatedStorageBytes = updatedStorage.toBytes();\n+            storageTx.put(writeAddress, updatedStorageBytes.toArrayUnsafe());\n+            storageTrie.put(keyHash, rlpEncode(updatedStorageBytes));\n+          }\n+        }\n+\n+        final BonsaiAccount accountUpdated = accountValue.getUpdated();\n+        if (accountUpdated != null) {\n+          storageTrie.commit(\n+              (location, key, value) ->\n+                  writeStorageTrieNode(trieBranchTx, updatedAddress, location, key, value));\n+          final Hash newStorageRoot = Hash.wrap(storageTrie.getRootHash());\n+          accountUpdated.setStorageRoot(newStorageRoot);\n+        }\n+        // for manicured tries and composting, trim and compost here\n+      }\n+\n+      // Third update the code.  This has the side effect of ensuring a code hash is calculated.\n+      for (final Map.Entry<Address, BonsaiValue<Bytes>> codeUpdate :\n+          updater.getCodeToUpdate().entrySet()) {\n+        final Bytes updatedCode = codeUpdate.getValue().getUpdated();\n+        if (updatedCode == null || updatedCode.size() == 0) {\n+          codeTx.remove(codeUpdate.getKey().toArrayUnsafe());\n+        } else {\n+          codeTx.put(codeUpdate.getKey().toArrayUnsafe(), updatedCode.toArrayUnsafe());\n+        }\n+      }\n+\n+      // next collect the branches that will be trimmed\n+      final StoredMerklePatriciaTrie<Bytes, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              this::getTrieNode, worldStateRootHash, Function.identity(), Function.identity());\n+\n+      // for manicured tries and composting, collect branches here (not implemented)\n+\n+      // now add the accounts\n+      for (final Map.Entry<Address, BonsaiValue<BonsaiAccount>> accountUpdate :\n+          updater.getAccountsToUpdate().entrySet()) {\n+        final Bytes accountKey = accountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> bonsaiValue = accountUpdate.getValue();\n+        final BonsaiAccount updatedAccount = bonsaiValue.getUpdated();\n+        if (updatedAccount == null) {\n+          final Hash addressHash = Hash.hash(accountKey);\n+          accountTrie.remove(addressHash);\n+          accountTx.remove(accountKey.toArrayUnsafe());\n+        } else {\n+          final Hash addressHash = updatedAccount.getAddressHash();\n+          final Bytes accountValue = updatedAccount.serializeAccount();\n+          accountTx.put(accountKey.toArrayUnsafe(), accountValue.toArrayUnsafe());\n+          accountTrie.put(addressHash, accountValue);\n+        }\n+      }\n+\n+      accountTrie.commit(\n+          (location, hash, value) -> writeTrieNode(trieBranchTx, location, hash, value));\n+      worldStateRootHash = accountTrie.getRootHash();\n+      trieBranchTx.put(WORLD_ROOT_KEY, worldStateRootHash.toArrayUnsafe());\n+\n+      // for manicured tries and composting, trim and compost branches here\n+\n+      if (blockHash != null) {\n+        final TrieLogLayer trieLog = updater.generateTrieLog(blockHash);\n+        trieLog.freeze();\n+        // TODO add to archive here, but only once we get persisted follow distance implemented\n+        // archive.addLayeredWorldState(new BonsaiLayeredWorldState(this, trieLog));\n+\n+        final BytesValueRLPOutput rlpLog = new BytesValueRLPOutput();\n+        trieLog.writeTo(rlpLog);\n+        trieLogTx.put(blockHash.toArrayUnsafe(), rlpLog.encoded().toArrayUnsafe());\n+      }\n+\n+      success = true;\n+    } finally {\n+      if (success) {\n+        accountTx.commit();\n+        codeTx.commit();\n+        storageTx.commit();\n+        trieBranchTx.commit();\n+        trieLogTx.commit();\n+        updater.reset();\n+      } else {\n+        accountTx.rollback();\n+        codeTx.rollback();\n+        storageTx.rollback();\n+        trieBranchTx.rollback();\n+        trieLogTx.rollback();\n+      }\n+    }\n+  }\n+\n+  private static Bytes rlpEncode(final Bytes bytes) {\n+    final BytesValueRLPOutput out = new BytesValueRLPOutput();\n+    out.writeBytes(bytes.trimLeadingZeros());\n+    return out.encoded();\n+  }\n+\n+  @Override\n+  public WorldUpdater updater() {\n+    if (updater == null) {\n+      updater = new BonsaiWorldStateUpdater(this);\n+    }\n+    return updater;\n+  }\n+\n+  @Override\n+  public Hash rootHash() {\n+    return Hash.wrap(worldStateRootHash);\n+  }\n+\n+  @Override\n+  public Stream<StreamableAccount> streamAccounts(final Bytes32 startKeyHash, final int limit) {\n+    throw new RuntimeException(\"NIY\");\n+  }\n+\n+  @Override\n+  public Account get(final Address address) {\n+    return accountStorage\n+        .get(address.toArrayUnsafe())\n+        .map(bytes -> fromRLP(updater, address, Bytes.wrap(bytes), true))\n+        .orElse(null);\n+  }\n+\n+  private Optional<Bytes> getTrieNode(final Bytes location, final Bytes32 nodeHash) {\n+    if (nodeHash.equals(MerklePatriciaTrie.EMPTY_TRIE_NODE_HASH)) {\n+      return Optional.of(MerklePatriciaTrie.EMPTY_TRIE_NODE);\n+    } else {\n+      return trieBranchStorage.get(location.toArrayUnsafe()).map(Bytes::wrap);\n+    }\n+  }\n+\n+  private void writeTrieNode(\n+      final KeyValueStorageTransaction tx,\n+      final Bytes location,\n+      @SuppressWarnings(\"unused\") final Bytes32 nodeHash,", "originalCommit": "a9bd8d5200aae80bd1b6643b996130975eafb94d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjExNzMzOA==", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536117338", "bodyText": "It can go since we are creating a custom lambda to call it anyway.", "author": "shemnon", "createdAt": "2020-12-04T13:57:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA2OTE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA2OTIxMw==", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536069213", "bodyText": "Does this byte32 with SuppressWarnings unused is important ? For future use ?", "author": "matkt", "createdAt": "2020-12-04T12:36:40Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiPersistedWorldState.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import static org.hyperledger.besu.ethereum.bonsai.BonsaiAccount.fromRLP;\n+\n+import org.hyperledger.besu.ethereum.core.Account;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.MerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorage;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorageTransaction;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import javax.annotation.Nonnull;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class BonsaiPersistedWorldState implements MutableWorldState, BonsaiWorldState {\n+\n+  private static final byte[] WORLD_ROOT_KEY = \"worldRoot\".getBytes(StandardCharsets.UTF_8);\n+\n+  private final KeyValueStorage accountStorage;\n+  private final KeyValueStorage codeStorage;\n+  private final KeyValueStorage storageStorage;\n+  private final KeyValueStorage trieBranchStorage;\n+  private final KeyValueStorage trieLogStorage;\n+\n+  private Bytes32 worldStateRootHash;\n+\n+  private final BonsaiWorldStateArchive archive;\n+  private BonsaiWorldStateUpdater updater;\n+\n+  public BonsaiPersistedWorldState(\n+      final BonsaiWorldStateArchive archive,\n+      final KeyValueStorage accountStorage,\n+      final KeyValueStorage codeStorage,\n+      final KeyValueStorage storageStorage,\n+      final KeyValueStorage trieBranchStorage,\n+      final KeyValueStorage trieLogStorage) {\n+    this.archive = archive;\n+    this.accountStorage = accountStorage;\n+    this.codeStorage = codeStorage;\n+    this.storageStorage = storageStorage;\n+    this.trieBranchStorage = trieBranchStorage;\n+    this.trieLogStorage = trieLogStorage;\n+    worldStateRootHash =\n+        Bytes32.wrap(\n+            trieBranchStorage.get(WORLD_ROOT_KEY).map(Bytes::wrap).orElse(Hash.EMPTY_TRIE_HASH));\n+  }\n+\n+  public BonsaiWorldStateArchive getArchive() {\n+    return archive;\n+  }\n+\n+  @Override\n+  public MutableWorldState copy() {\n+    throw new UnsupportedOperationException(\n+        \"Bonsai Tries does not support direct duplication of the persisted tries.\");\n+  }\n+\n+  @Override\n+  public Bytes getCode(@Nonnull final Address address) {\n+    return codeStorage.get(address.toArrayUnsafe()).map(Bytes::wrap).orElse(Bytes.EMPTY);\n+  }\n+\n+  @Override\n+  public void persist(final Hash blockHash) {\n+    boolean success = false;\n+    final KeyValueStorageTransaction accountTx = accountStorage.startTransaction();\n+    final KeyValueStorageTransaction codeTx = codeStorage.startTransaction();\n+    final KeyValueStorageTransaction storageTx = storageStorage.startTransaction();\n+    final KeyValueStorageTransaction trieBranchTx = trieBranchStorage.startTransaction();\n+    final KeyValueStorageTransaction trieLogTx = trieLogStorage.startTransaction();\n+\n+    try {\n+      // first clear storage\n+      for (final Address address : updater.getStorageToClear()) {\n+        // because we are clearing persisted values we need the account root as persisted\n+        final BonsaiAccount oldAccount =\n+            accountStorage\n+                .get(address.toArrayUnsafe())\n+                .map(\n+                    bytes ->\n+                        fromRLP(BonsaiPersistedWorldState.this, address, Bytes.wrap(bytes), true))\n+                .orElse(null);\n+        if (oldAccount == null) {\n+          // This is when an account is both created and deleted within the scope of the same\n+          // block.  A not-uncommon DeFi bot pattern.\n+          continue;\n+        }\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(address, location, key),\n+                oldAccount.getStorageRoot(),\n+                Function.identity(),\n+                Function.identity());\n+        Map<Bytes32, Bytes> entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+        while (!entriesToDelete.isEmpty()) {\n+          entriesToDelete\n+              .keySet()\n+              .forEach(k -> storageTx.remove(Bytes.concatenate(address, k).toArrayUnsafe()));\n+          if (entriesToDelete.size() == 256) {\n+            entriesToDelete.keySet().forEach(storageTrie::remove);\n+            entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+          } else {\n+            break;\n+          }\n+        }\n+      }\n+\n+      // second update account storage state.  This must be done before updating the accounts so\n+      // that we can get the storage state hash\n+      for (final Map.Entry<Address, Map<Hash, BonsaiValue<UInt256>>> storageAccountUpdate :\n+          updater.getStorageToUpdate().entrySet()) {\n+        final Address updatedAddress = storageAccountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> accountValue =\n+            updater.getAccountsToUpdate().get(updatedAddress);\n+        final BonsaiAccount accountOriginal = accountValue.getOriginal();\n+        final Hash storageRoot =\n+            (accountOriginal == null) ? Hash.EMPTY_TRIE_HASH : accountOriginal.getStorageRoot();\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(updatedAddress, location, key),\n+                storageRoot,\n+                Function.identity(),\n+                Function.identity());\n+\n+        // for manicured tries and composting, collect branches here (not implemented)\n+\n+        for (final Map.Entry<Hash, BonsaiValue<UInt256>> storageUpdate :\n+            storageAccountUpdate.getValue().entrySet()) {\n+          final Hash keyHash = storageUpdate.getKey();\n+          final byte[] writeAddress = Bytes.concatenate(updatedAddress, keyHash).toArrayUnsafe();\n+          final UInt256 updatedStorage = storageUpdate.getValue().getUpdated();\n+          if (updatedStorage == null || updatedStorage.equals(UInt256.ZERO)) {\n+            storageTx.remove(writeAddress);\n+            storageTrie.remove(keyHash);\n+          } else {\n+            final Bytes32 updatedStorageBytes = updatedStorage.toBytes();\n+            storageTx.put(writeAddress, updatedStorageBytes.toArrayUnsafe());\n+            storageTrie.put(keyHash, rlpEncode(updatedStorageBytes));\n+          }\n+        }\n+\n+        final BonsaiAccount accountUpdated = accountValue.getUpdated();\n+        if (accountUpdated != null) {\n+          storageTrie.commit(\n+              (location, key, value) ->\n+                  writeStorageTrieNode(trieBranchTx, updatedAddress, location, key, value));\n+          final Hash newStorageRoot = Hash.wrap(storageTrie.getRootHash());\n+          accountUpdated.setStorageRoot(newStorageRoot);\n+        }\n+        // for manicured tries and composting, trim and compost here\n+      }\n+\n+      // Third update the code.  This has the side effect of ensuring a code hash is calculated.\n+      for (final Map.Entry<Address, BonsaiValue<Bytes>> codeUpdate :\n+          updater.getCodeToUpdate().entrySet()) {\n+        final Bytes updatedCode = codeUpdate.getValue().getUpdated();\n+        if (updatedCode == null || updatedCode.size() == 0) {\n+          codeTx.remove(codeUpdate.getKey().toArrayUnsafe());\n+        } else {\n+          codeTx.put(codeUpdate.getKey().toArrayUnsafe(), updatedCode.toArrayUnsafe());\n+        }\n+      }\n+\n+      // next collect the branches that will be trimmed\n+      final StoredMerklePatriciaTrie<Bytes, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              this::getTrieNode, worldStateRootHash, Function.identity(), Function.identity());\n+\n+      // for manicured tries and composting, collect branches here (not implemented)\n+\n+      // now add the accounts\n+      for (final Map.Entry<Address, BonsaiValue<BonsaiAccount>> accountUpdate :\n+          updater.getAccountsToUpdate().entrySet()) {\n+        final Bytes accountKey = accountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> bonsaiValue = accountUpdate.getValue();\n+        final BonsaiAccount updatedAccount = bonsaiValue.getUpdated();\n+        if (updatedAccount == null) {\n+          final Hash addressHash = Hash.hash(accountKey);\n+          accountTrie.remove(addressHash);\n+          accountTx.remove(accountKey.toArrayUnsafe());\n+        } else {\n+          final Hash addressHash = updatedAccount.getAddressHash();\n+          final Bytes accountValue = updatedAccount.serializeAccount();\n+          accountTx.put(accountKey.toArrayUnsafe(), accountValue.toArrayUnsafe());\n+          accountTrie.put(addressHash, accountValue);\n+        }\n+      }\n+\n+      accountTrie.commit(\n+          (location, hash, value) -> writeTrieNode(trieBranchTx, location, hash, value));\n+      worldStateRootHash = accountTrie.getRootHash();\n+      trieBranchTx.put(WORLD_ROOT_KEY, worldStateRootHash.toArrayUnsafe());\n+\n+      // for manicured tries and composting, trim and compost branches here\n+\n+      if (blockHash != null) {\n+        final TrieLogLayer trieLog = updater.generateTrieLog(blockHash);\n+        trieLog.freeze();\n+        // TODO add to archive here, but only once we get persisted follow distance implemented\n+        // archive.addLayeredWorldState(new BonsaiLayeredWorldState(this, trieLog));\n+\n+        final BytesValueRLPOutput rlpLog = new BytesValueRLPOutput();\n+        trieLog.writeTo(rlpLog);\n+        trieLogTx.put(blockHash.toArrayUnsafe(), rlpLog.encoded().toArrayUnsafe());\n+      }\n+\n+      success = true;\n+    } finally {\n+      if (success) {\n+        accountTx.commit();\n+        codeTx.commit();\n+        storageTx.commit();\n+        trieBranchTx.commit();\n+        trieLogTx.commit();\n+        updater.reset();\n+      } else {\n+        accountTx.rollback();\n+        codeTx.rollback();\n+        storageTx.rollback();\n+        trieBranchTx.rollback();\n+        trieLogTx.rollback();\n+      }\n+    }\n+  }\n+\n+  private static Bytes rlpEncode(final Bytes bytes) {\n+    final BytesValueRLPOutput out = new BytesValueRLPOutput();\n+    out.writeBytes(bytes.trimLeadingZeros());\n+    return out.encoded();\n+  }\n+\n+  @Override\n+  public WorldUpdater updater() {\n+    if (updater == null) {\n+      updater = new BonsaiWorldStateUpdater(this);\n+    }\n+    return updater;\n+  }\n+\n+  @Override\n+  public Hash rootHash() {\n+    return Hash.wrap(worldStateRootHash);\n+  }\n+\n+  @Override\n+  public Stream<StreamableAccount> streamAccounts(final Bytes32 startKeyHash, final int limit) {\n+    throw new RuntimeException(\"NIY\");\n+  }\n+\n+  @Override\n+  public Account get(final Address address) {\n+    return accountStorage\n+        .get(address.toArrayUnsafe())\n+        .map(bytes -> fromRLP(updater, address, Bytes.wrap(bytes), true))\n+        .orElse(null);\n+  }\n+\n+  private Optional<Bytes> getTrieNode(final Bytes location, final Bytes32 nodeHash) {\n+    if (nodeHash.equals(MerklePatriciaTrie.EMPTY_TRIE_NODE_HASH)) {\n+      return Optional.of(MerklePatriciaTrie.EMPTY_TRIE_NODE);\n+    } else {\n+      return trieBranchStorage.get(location.toArrayUnsafe()).map(Bytes::wrap);\n+    }\n+  }\n+\n+  private void writeTrieNode(\n+      final KeyValueStorageTransaction tx,\n+      final Bytes location,\n+      @SuppressWarnings(\"unused\") final Bytes32 nodeHash,\n+      final Bytes value) {\n+    tx.put(location.toArrayUnsafe(), value.toArrayUnsafe());\n+  }\n+\n+  private Optional<Bytes> getStorageTrieNode(\n+      final Address address, final Bytes location, final Bytes32 nodeHash) {\n+    if (nodeHash.equals(MerklePatriciaTrie.EMPTY_TRIE_NODE_HASH)) {\n+      return Optional.of(MerklePatriciaTrie.EMPTY_TRIE_NODE);\n+    } else {\n+      return trieBranchStorage\n+          .get(Bytes.concatenate(address, location).toArrayUnsafe())\n+          .map(Bytes::wrap);\n+    }\n+  }\n+\n+  private void writeStorageTrieNode(\n+      final KeyValueStorageTransaction tx,\n+      final Address address,\n+      final Bytes location,\n+      @SuppressWarnings(\"unused\") final Bytes32 key,", "originalCommit": "a9bd8d5200aae80bd1b6643b996130975eafb94d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjExODEzNA==", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536118134", "bodyText": "Same, it was originally a direct lambda but when the KVStorTransaction got added via lambda wrapping it became unneeded.", "author": "shemnon", "createdAt": "2020-12-04T13:58:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA2OTIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA4NTYyNA==", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536085624", "bodyText": "Why not doing get(EMPTY_ROOT_HASH).get() like here \n  \n    \n      besu/ethereum/core/src/main/java/org/hyperledger/besu/ethereum/worldstate/DefaultWorldStateArchive.java\n    \n    \n         Line 66\n      in\n      7e52d4d\n    \n    \n    \n    \n\n        \n          \n           return get(EMPTY_ROOT_HASH).get();", "author": "matkt", "createdAt": "2020-12-04T13:05:40Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiWorldStateArchive.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.WorldState;\n+import org.hyperledger.besu.ethereum.proof.WorldStateProof;\n+import org.hyperledger.besu.ethereum.storage.StorageProvider;\n+import org.hyperledger.besu.ethereum.storage.keyvalue.KeyValueSegmentIdentifier;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class BonsaiWorldStateArchive implements WorldStateArchive {\n+\n+  private final BonsaiPersistedWorldState persistedState;\n+  private final Map<Bytes32, BonsaiLayeredWorldState> layeredWorldStates;\n+\n+  public BonsaiWorldStateArchive(final StorageProvider provider) {\n+    persistedState =\n+        new BonsaiPersistedWorldState(\n+            this,\n+            provider.getStorageBySegmentIdentifier(KeyValueSegmentIdentifier.ACCOUNT_INFO_STATE),\n+            provider.getStorageBySegmentIdentifier(KeyValueSegmentIdentifier.CODE_STORAGE),\n+            provider.getStorageBySegmentIdentifier(\n+                KeyValueSegmentIdentifier.ACCOUNT_STORAGE_STORAGE),\n+            provider.getStorageBySegmentIdentifier(KeyValueSegmentIdentifier.TRIE_BRANCH_STORAGE),\n+            provider.getStorageBySegmentIdentifier(KeyValueSegmentIdentifier.TRIE_LOG_STORAGE));\n+    layeredWorldStates = new HashMap<>();\n+  }\n+\n+  @Override\n+  public Optional<WorldState> get(final Hash rootHash) {\n+    if (layeredWorldStates.containsKey(rootHash)) {\n+      return Optional.of(layeredWorldStates.get(rootHash));\n+    } else if (rootHash.equals(persistedState.rootHash())) {\n+      return Optional.of(persistedState);\n+    } else {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  public void addLayeredWorldState(final BonsaiLayeredWorldState worldState) {\n+    layeredWorldStates.put(worldState.rootHash(), worldState);\n+  }\n+\n+  @Override\n+  public boolean isWorldStateAvailable(final Hash rootHash) {\n+    return layeredWorldStates.containsKey(rootHash)\n+        || persistedState.rootHash().equals(rootHash) /* || check disk storage */;\n+  }\n+\n+  @Override\n+  public Optional<MutableWorldState> getMutable(final Hash rootHash) {\n+    if (rootHash.equals(persistedState.rootHash())) {\n+      return Optional.of(persistedState);\n+    } else {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  @Override\n+  public WorldState get() {\n+    return null;", "originalCommit": "a9bd8d5200aae80bd1b6643b996130975eafb94d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjExOTY5Ng==", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536119696", "bodyText": "org.hyperledger.besu.ethereum.worldstate.WorldStateArchive#get() is a dead method and should be removed.  No one calls it.  I'll remove it from the parent and the Forest world state too.", "author": "shemnon", "createdAt": "2020-12-04T14:01:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA4NTYyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA5OTU3Ng==", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536099576", "bodyText": "I wonder if an optional wouldn't be an idea to avoid having to call this method with null ?", "author": "matkt", "createdAt": "2020-12-04T13:29:06Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/OnChainPrivacyPrecompiledContract.java", "diffHunk": "@@ -191,7 +191,7 @@ public Bytes compute(final Bytes input, final MessageFrame messageFrame) {\n     if (messageFrame.isPersistingPrivateState()) {\n \n       privateWorldStateUpdater.commit();\n-      disposablePrivateState.persist();\n+      disposablePrivateState.persist(null);", "originalCommit": "a9bd8d5200aae80bd1b6643b996130975eafb94d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEyMjU0NA==", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536122544", "bodyText": "The only argument is style really.  The forest ignores it, in bonsai mode Tthe block that switches on whether or not it is null is too large for a good looking lambda.  The bulk of the null calls are in test code.  Another option is two methods, one with no args.  But in the places it's called directly with null it's a good reminder in the code \"this is not a regular commit\".", "author": "shemnon", "createdAt": "2020-12-04T14:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA5OTU3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEzMTQzNg==", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536131436", "bodyText": "it's called directly with null it's a good reminder in the code \"this is not a regular commit\".\n\nThat suits me . We can leave it if it provides information and if the majority of calls like this are in the test", "author": "matkt", "createdAt": "2020-12-04T14:18:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA5OTU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEwMzI5NQ==", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536103295", "bodyText": "NIY ? Not implemented yet ?", "author": "matkt", "createdAt": "2020-12-04T13:35:18Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiPersistedWorldState.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import static org.hyperledger.besu.ethereum.bonsai.BonsaiAccount.fromRLP;\n+\n+import org.hyperledger.besu.ethereum.core.Account;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.MerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorage;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorageTransaction;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import javax.annotation.Nonnull;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class BonsaiPersistedWorldState implements MutableWorldState, BonsaiWorldState {\n+\n+  private static final byte[] WORLD_ROOT_KEY = \"worldRoot\".getBytes(StandardCharsets.UTF_8);\n+\n+  private final KeyValueStorage accountStorage;\n+  private final KeyValueStorage codeStorage;\n+  private final KeyValueStorage storageStorage;\n+  private final KeyValueStorage trieBranchStorage;\n+  private final KeyValueStorage trieLogStorage;\n+\n+  private Bytes32 worldStateRootHash;\n+\n+  private final BonsaiWorldStateArchive archive;\n+  private BonsaiWorldStateUpdater updater;\n+\n+  public BonsaiPersistedWorldState(\n+      final BonsaiWorldStateArchive archive,\n+      final KeyValueStorage accountStorage,\n+      final KeyValueStorage codeStorage,\n+      final KeyValueStorage storageStorage,\n+      final KeyValueStorage trieBranchStorage,\n+      final KeyValueStorage trieLogStorage) {\n+    this.archive = archive;\n+    this.accountStorage = accountStorage;\n+    this.codeStorage = codeStorage;\n+    this.storageStorage = storageStorage;\n+    this.trieBranchStorage = trieBranchStorage;\n+    this.trieLogStorage = trieLogStorage;\n+    worldStateRootHash =\n+        Bytes32.wrap(\n+            trieBranchStorage.get(WORLD_ROOT_KEY).map(Bytes::wrap).orElse(Hash.EMPTY_TRIE_HASH));\n+  }\n+\n+  public BonsaiWorldStateArchive getArchive() {\n+    return archive;\n+  }\n+\n+  @Override\n+  public MutableWorldState copy() {\n+    throw new UnsupportedOperationException(\n+        \"Bonsai Tries does not support direct duplication of the persisted tries.\");\n+  }\n+\n+  @Override\n+  public Bytes getCode(@Nonnull final Address address) {\n+    return codeStorage.get(address.toArrayUnsafe()).map(Bytes::wrap).orElse(Bytes.EMPTY);\n+  }\n+\n+  @Override\n+  public void persist(final Hash blockHash) {\n+    boolean success = false;\n+    final KeyValueStorageTransaction accountTx = accountStorage.startTransaction();\n+    final KeyValueStorageTransaction codeTx = codeStorage.startTransaction();\n+    final KeyValueStorageTransaction storageTx = storageStorage.startTransaction();\n+    final KeyValueStorageTransaction trieBranchTx = trieBranchStorage.startTransaction();\n+    final KeyValueStorageTransaction trieLogTx = trieLogStorage.startTransaction();\n+\n+    try {\n+      // first clear storage\n+      for (final Address address : updater.getStorageToClear()) {\n+        // because we are clearing persisted values we need the account root as persisted\n+        final BonsaiAccount oldAccount =\n+            accountStorage\n+                .get(address.toArrayUnsafe())\n+                .map(\n+                    bytes ->\n+                        fromRLP(BonsaiPersistedWorldState.this, address, Bytes.wrap(bytes), true))\n+                .orElse(null);\n+        if (oldAccount == null) {\n+          // This is when an account is both created and deleted within the scope of the same\n+          // block.  A not-uncommon DeFi bot pattern.\n+          continue;\n+        }\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(address, location, key),\n+                oldAccount.getStorageRoot(),\n+                Function.identity(),\n+                Function.identity());\n+        Map<Bytes32, Bytes> entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+        while (!entriesToDelete.isEmpty()) {\n+          entriesToDelete\n+              .keySet()\n+              .forEach(k -> storageTx.remove(Bytes.concatenate(address, k).toArrayUnsafe()));\n+          if (entriesToDelete.size() == 256) {\n+            entriesToDelete.keySet().forEach(storageTrie::remove);\n+            entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+          } else {\n+            break;\n+          }\n+        }\n+      }\n+\n+      // second update account storage state.  This must be done before updating the accounts so\n+      // that we can get the storage state hash\n+      for (final Map.Entry<Address, Map<Hash, BonsaiValue<UInt256>>> storageAccountUpdate :\n+          updater.getStorageToUpdate().entrySet()) {\n+        final Address updatedAddress = storageAccountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> accountValue =\n+            updater.getAccountsToUpdate().get(updatedAddress);\n+        final BonsaiAccount accountOriginal = accountValue.getOriginal();\n+        final Hash storageRoot =\n+            (accountOriginal == null) ? Hash.EMPTY_TRIE_HASH : accountOriginal.getStorageRoot();\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(updatedAddress, location, key),\n+                storageRoot,\n+                Function.identity(),\n+                Function.identity());\n+\n+        // for manicured tries and composting, collect branches here (not implemented)\n+\n+        for (final Map.Entry<Hash, BonsaiValue<UInt256>> storageUpdate :\n+            storageAccountUpdate.getValue().entrySet()) {\n+          final Hash keyHash = storageUpdate.getKey();\n+          final byte[] writeAddress = Bytes.concatenate(updatedAddress, keyHash).toArrayUnsafe();\n+          final UInt256 updatedStorage = storageUpdate.getValue().getUpdated();\n+          if (updatedStorage == null || updatedStorage.equals(UInt256.ZERO)) {\n+            storageTx.remove(writeAddress);\n+            storageTrie.remove(keyHash);\n+          } else {\n+            final Bytes32 updatedStorageBytes = updatedStorage.toBytes();\n+            storageTx.put(writeAddress, updatedStorageBytes.toArrayUnsafe());\n+            storageTrie.put(keyHash, rlpEncode(updatedStorageBytes));\n+          }\n+        }\n+\n+        final BonsaiAccount accountUpdated = accountValue.getUpdated();\n+        if (accountUpdated != null) {\n+          storageTrie.commit(\n+              (location, key, value) ->\n+                  writeStorageTrieNode(trieBranchTx, updatedAddress, location, key, value));\n+          final Hash newStorageRoot = Hash.wrap(storageTrie.getRootHash());\n+          accountUpdated.setStorageRoot(newStorageRoot);\n+        }\n+        // for manicured tries and composting, trim and compost here\n+      }\n+\n+      // Third update the code.  This has the side effect of ensuring a code hash is calculated.\n+      for (final Map.Entry<Address, BonsaiValue<Bytes>> codeUpdate :\n+          updater.getCodeToUpdate().entrySet()) {\n+        final Bytes updatedCode = codeUpdate.getValue().getUpdated();\n+        if (updatedCode == null || updatedCode.size() == 0) {\n+          codeTx.remove(codeUpdate.getKey().toArrayUnsafe());\n+        } else {\n+          codeTx.put(codeUpdate.getKey().toArrayUnsafe(), updatedCode.toArrayUnsafe());\n+        }\n+      }\n+\n+      // next collect the branches that will be trimmed\n+      final StoredMerklePatriciaTrie<Bytes, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              this::getTrieNode, worldStateRootHash, Function.identity(), Function.identity());\n+\n+      // for manicured tries and composting, collect branches here (not implemented)\n+\n+      // now add the accounts\n+      for (final Map.Entry<Address, BonsaiValue<BonsaiAccount>> accountUpdate :\n+          updater.getAccountsToUpdate().entrySet()) {\n+        final Bytes accountKey = accountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> bonsaiValue = accountUpdate.getValue();\n+        final BonsaiAccount updatedAccount = bonsaiValue.getUpdated();\n+        if (updatedAccount == null) {\n+          final Hash addressHash = Hash.hash(accountKey);\n+          accountTrie.remove(addressHash);\n+          accountTx.remove(accountKey.toArrayUnsafe());\n+        } else {\n+          final Hash addressHash = updatedAccount.getAddressHash();\n+          final Bytes accountValue = updatedAccount.serializeAccount();\n+          accountTx.put(accountKey.toArrayUnsafe(), accountValue.toArrayUnsafe());\n+          accountTrie.put(addressHash, accountValue);\n+        }\n+      }\n+\n+      accountTrie.commit(\n+          (location, hash, value) -> writeTrieNode(trieBranchTx, location, hash, value));\n+      worldStateRootHash = accountTrie.getRootHash();\n+      trieBranchTx.put(WORLD_ROOT_KEY, worldStateRootHash.toArrayUnsafe());\n+\n+      // for manicured tries and composting, trim and compost branches here\n+\n+      if (blockHash != null) {\n+        final TrieLogLayer trieLog = updater.generateTrieLog(blockHash);\n+        trieLog.freeze();\n+        // TODO add to archive here, but only once we get persisted follow distance implemented\n+        // archive.addLayeredWorldState(new BonsaiLayeredWorldState(this, trieLog));\n+\n+        final BytesValueRLPOutput rlpLog = new BytesValueRLPOutput();\n+        trieLog.writeTo(rlpLog);\n+        trieLogTx.put(blockHash.toArrayUnsafe(), rlpLog.encoded().toArrayUnsafe());\n+      }\n+\n+      success = true;\n+    } finally {\n+      if (success) {\n+        accountTx.commit();\n+        codeTx.commit();\n+        storageTx.commit();\n+        trieBranchTx.commit();\n+        trieLogTx.commit();\n+        updater.reset();\n+      } else {\n+        accountTx.rollback();\n+        codeTx.rollback();\n+        storageTx.rollback();\n+        trieBranchTx.rollback();\n+        trieLogTx.rollback();\n+      }\n+    }\n+  }\n+\n+  private static Bytes rlpEncode(final Bytes bytes) {\n+    final BytesValueRLPOutput out = new BytesValueRLPOutput();\n+    out.writeBytes(bytes.trimLeadingZeros());\n+    return out.encoded();\n+  }\n+\n+  @Override\n+  public WorldUpdater updater() {\n+    if (updater == null) {\n+      updater = new BonsaiWorldStateUpdater(this);\n+    }\n+    return updater;\n+  }\n+\n+  @Override\n+  public Hash rootHash() {\n+    return Hash.wrap(worldStateRootHash);\n+  }\n+\n+  @Override\n+  public Stream<StreamableAccount> streamAccounts(final Bytes32 startKeyHash, final int limit) {\n+    throw new RuntimeException(\"NIY\");", "originalCommit": "a9bd8d5200aae80bd1b6643b996130975eafb94d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEyMjc2OA==", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536122768", "bodyText": "Not Implemented Yet.  Yes.  I'll put a more verbose description.", "author": "shemnon", "createdAt": "2020-12-04T14:05:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEwMzI5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEyMzcxNw==", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536123717", "bodyText": "The impact is the debug API and hence remix needs it.  So I would have to do a heavy weight merge operation with the layered modes.  For local debugging I think keeping forest for now is the thing to do.", "author": "shemnon", "createdAt": "2020-12-04T14:07:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEwMzI5NQ=="}], "type": "inlineReview"}, {"oid": "78bc7200d64f19cfa93f1be765cb53afa3cee451", "url": "https://github.com/hyperledger/besu/commit/78bc7200d64f19cfa93f1be765cb53afa3cee451", "message": "review changes.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-12-04T14:07:49Z", "type": "commit"}, {"oid": "f6bf59a6060ad3f577368a329a008fc3bc248651", "url": "https://github.com/hyperledger/besu/commit/f6bf59a6060ad3f577368a329a008fc3bc248651", "message": "Merge branch 'master' of github.com:hyperledger/besu into bonsai\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-12-04T14:39:44Z", "type": "commit"}, {"oid": "624587f9e2e91ef5d39de022facb62cd1e04ef15", "url": "https://github.com/hyperledger/besu/commit/624587f9e2e91ef5d39de022facb62cd1e04ef15", "message": "spotless\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-12-04T14:59:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgyODg4OQ==", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536828889", "bodyText": "\ud83e\udd23", "author": "RatanRSur", "createdAt": "2020-12-05T17:38:01Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/TrieLogLayer.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.rlp.RLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLPOutput;\n+import org.hyperledger.besu.ethereum.worldstate.StateTrieAccountValue;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+/**\n+ * This class encapsulates the changes that are done to transition one block to the next. This\n+ * includes serialization and deserialization tasks for storing this log to off-memory storage.\n+ *\n+ * <p>In this particular formulation only the \"Leaves\" are tracked\" Future layers may track patrica\n+ * trie changes as well.\n+ */\n+public class TrieLogLayer {\n+\n+  private Hash blockHash;\n+  private final Map<Address, BonsaiValue<StateTrieAccountValue>> accounts = new TreeMap<>();\n+  private final Map<Address, BonsaiValue<Bytes>> code = new TreeMap<>();\n+  private final Map<Address, Map<Hash, BonsaiValue<UInt256>>> storage = new TreeMap<>();\n+  private boolean frozen = false;\n+\n+  /** Locks the layer so no new changes can be added; */\n+  void freeze() {\n+    frozen = true; // The code never bothered me anyway", "originalCommit": "624587f9e2e91ef5d39de022facb62cd1e04ef15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgzMDg3Nw==", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536830877", "bodyText": "It felt logically circuitous that the updater comes from a persisted world state (which is like the \"bottom\" layer in my head) but ultimately gets at the layers \"above\" through the context in the BonsaiAccount. AbstractBlockProcessor requires a MutableWorldState and in this implementation that's only the BonsaiPersistedWorldState. I wonder if it would become cleaner if the MutableWorldState was an object that encapsulated the totality of layered and persisted storage?", "author": "RatanRSur", "createdAt": "2020-12-05T17:50:31Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiPersistedWorldState.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import static org.hyperledger.besu.ethereum.bonsai.BonsaiAccount.fromRLP;\n+\n+import org.hyperledger.besu.ethereum.core.Account;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.MerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorage;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorageTransaction;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import javax.annotation.Nonnull;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class BonsaiPersistedWorldState implements MutableWorldState, BonsaiWorldState {\n+\n+  private static final byte[] WORLD_ROOT_KEY = \"worldRoot\".getBytes(StandardCharsets.UTF_8);\n+\n+  private final KeyValueStorage accountStorage;\n+  private final KeyValueStorage codeStorage;\n+  private final KeyValueStorage storageStorage;\n+  private final KeyValueStorage trieBranchStorage;\n+  private final KeyValueStorage trieLogStorage;\n+\n+  private Bytes32 worldStateRootHash;\n+\n+  private final BonsaiWorldStateArchive archive;\n+  private BonsaiWorldStateUpdater updater;\n+\n+  public BonsaiPersistedWorldState(\n+      final BonsaiWorldStateArchive archive,\n+      final KeyValueStorage accountStorage,\n+      final KeyValueStorage codeStorage,\n+      final KeyValueStorage storageStorage,\n+      final KeyValueStorage trieBranchStorage,\n+      final KeyValueStorage trieLogStorage) {\n+    this.archive = archive;\n+    this.accountStorage = accountStorage;\n+    this.codeStorage = codeStorage;\n+    this.storageStorage = storageStorage;\n+    this.trieBranchStorage = trieBranchStorage;\n+    this.trieLogStorage = trieLogStorage;\n+    worldStateRootHash =\n+        Bytes32.wrap(\n+            trieBranchStorage.get(WORLD_ROOT_KEY).map(Bytes::wrap).orElse(Hash.EMPTY_TRIE_HASH));\n+  }\n+\n+  public BonsaiWorldStateArchive getArchive() {\n+    return archive;\n+  }\n+\n+  @Override\n+  public MutableWorldState copy() {\n+    throw new UnsupportedOperationException(\n+        \"Bonsai Tries does not support direct duplication of the persisted tries.\");\n+  }\n+\n+  @Override\n+  public Bytes getCode(@Nonnull final Address address) {\n+    return codeStorage.get(address.toArrayUnsafe()).map(Bytes::wrap).orElse(Bytes.EMPTY);\n+  }\n+\n+  @Override\n+  public void persist(final Hash blockHash) {\n+    boolean success = false;\n+    final KeyValueStorageTransaction accountTx = accountStorage.startTransaction();\n+    final KeyValueStorageTransaction codeTx = codeStorage.startTransaction();\n+    final KeyValueStorageTransaction storageTx = storageStorage.startTransaction();\n+    final KeyValueStorageTransaction trieBranchTx = trieBranchStorage.startTransaction();\n+    final KeyValueStorageTransaction trieLogTx = trieLogStorage.startTransaction();\n+\n+    try {\n+      // first clear storage\n+      for (final Address address : updater.getStorageToClear()) {\n+        // because we are clearing persisted values we need the account root as persisted\n+        final BonsaiAccount oldAccount =\n+            accountStorage\n+                .get(address.toArrayUnsafe())\n+                .map(\n+                    bytes ->\n+                        fromRLP(BonsaiPersistedWorldState.this, address, Bytes.wrap(bytes), true))\n+                .orElse(null);\n+        if (oldAccount == null) {\n+          // This is when an account is both created and deleted within the scope of the same\n+          // block.  A not-uncommon DeFi bot pattern.\n+          continue;\n+        }\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(address, location, key),\n+                oldAccount.getStorageRoot(),\n+                Function.identity(),\n+                Function.identity());\n+        Map<Bytes32, Bytes> entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+        while (!entriesToDelete.isEmpty()) {\n+          entriesToDelete\n+              .keySet()\n+              .forEach(k -> storageTx.remove(Bytes.concatenate(address, k).toArrayUnsafe()));\n+          if (entriesToDelete.size() == 256) {\n+            entriesToDelete.keySet().forEach(storageTrie::remove);\n+            entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+          } else {\n+            break;\n+          }\n+        }\n+      }\n+\n+      // second update account storage state.  This must be done before updating the accounts so\n+      // that we can get the storage state hash\n+      for (final Map.Entry<Address, Map<Hash, BonsaiValue<UInt256>>> storageAccountUpdate :\n+          updater.getStorageToUpdate().entrySet()) {\n+        final Address updatedAddress = storageAccountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> accountValue =\n+            updater.getAccountsToUpdate().get(updatedAddress);\n+        final BonsaiAccount accountOriginal = accountValue.getOriginal();\n+        final Hash storageRoot =\n+            (accountOriginal == null) ? Hash.EMPTY_TRIE_HASH : accountOriginal.getStorageRoot();\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(updatedAddress, location, key),\n+                storageRoot,\n+                Function.identity(),\n+                Function.identity());\n+\n+        // for manicured tries and composting, collect branches here (not implemented)\n+\n+        for (final Map.Entry<Hash, BonsaiValue<UInt256>> storageUpdate :\n+            storageAccountUpdate.getValue().entrySet()) {\n+          final Hash keyHash = storageUpdate.getKey();\n+          final byte[] writeAddress = Bytes.concatenate(updatedAddress, keyHash).toArrayUnsafe();\n+          final UInt256 updatedStorage = storageUpdate.getValue().getUpdated();\n+          if (updatedStorage == null || updatedStorage.equals(UInt256.ZERO)) {\n+            storageTx.remove(writeAddress);\n+            storageTrie.remove(keyHash);\n+          } else {\n+            final Bytes32 updatedStorageBytes = updatedStorage.toBytes();\n+            storageTx.put(writeAddress, updatedStorageBytes.toArrayUnsafe());\n+            storageTrie.put(keyHash, rlpEncode(updatedStorageBytes));\n+          }\n+        }\n+\n+        final BonsaiAccount accountUpdated = accountValue.getUpdated();\n+        if (accountUpdated != null) {\n+          storageTrie.commit(\n+              (location, key, value) ->\n+                  writeStorageTrieNode(trieBranchTx, updatedAddress, location, value));\n+          final Hash newStorageRoot = Hash.wrap(storageTrie.getRootHash());\n+          accountUpdated.setStorageRoot(newStorageRoot);\n+        }\n+        // for manicured tries and composting, trim and compost here\n+      }\n+\n+      // Third update the code.  This has the side effect of ensuring a code hash is calculated.\n+      for (final Map.Entry<Address, BonsaiValue<Bytes>> codeUpdate :\n+          updater.getCodeToUpdate().entrySet()) {\n+        final Bytes updatedCode = codeUpdate.getValue().getUpdated();\n+        if (updatedCode == null || updatedCode.size() == 0) {\n+          codeTx.remove(codeUpdate.getKey().toArrayUnsafe());\n+        } else {\n+          codeTx.put(codeUpdate.getKey().toArrayUnsafe(), updatedCode.toArrayUnsafe());\n+        }\n+      }\n+\n+      // next collect the branches that will be trimmed\n+      final StoredMerklePatriciaTrie<Bytes, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              this::getTrieNode, worldStateRootHash, Function.identity(), Function.identity());\n+\n+      // for manicured tries and composting, collect branches here (not implemented)\n+\n+      // now add the accounts\n+      for (final Map.Entry<Address, BonsaiValue<BonsaiAccount>> accountUpdate :\n+          updater.getAccountsToUpdate().entrySet()) {\n+        final Bytes accountKey = accountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> bonsaiValue = accountUpdate.getValue();\n+        final BonsaiAccount updatedAccount = bonsaiValue.getUpdated();\n+        if (updatedAccount == null) {\n+          final Hash addressHash = Hash.hash(accountKey);\n+          accountTrie.remove(addressHash);\n+          accountTx.remove(accountKey.toArrayUnsafe());\n+        } else {\n+          final Hash addressHash = updatedAccount.getAddressHash();\n+          final Bytes accountValue = updatedAccount.serializeAccount();\n+          accountTx.put(accountKey.toArrayUnsafe(), accountValue.toArrayUnsafe());\n+          accountTrie.put(addressHash, accountValue);\n+        }\n+      }\n+\n+      accountTrie.commit((location, hash, value) -> writeTrieNode(trieBranchTx, location, value));\n+      worldStateRootHash = accountTrie.getRootHash();\n+      trieBranchTx.put(WORLD_ROOT_KEY, worldStateRootHash.toArrayUnsafe());\n+\n+      // for manicured tries and composting, trim and compost branches here\n+\n+      if (blockHash != null) {\n+        final TrieLogLayer trieLog = updater.generateTrieLog(blockHash);\n+        trieLog.freeze();\n+        // TODO add to archive here, but only once we get persisted follow distance implemented\n+        // archive.addLayeredWorldState(new BonsaiLayeredWorldState(this, trieLog));\n+\n+        final BytesValueRLPOutput rlpLog = new BytesValueRLPOutput();\n+        trieLog.writeTo(rlpLog);\n+        trieLogTx.put(blockHash.toArrayUnsafe(), rlpLog.encoded().toArrayUnsafe());\n+      }\n+\n+      success = true;\n+    } finally {\n+      if (success) {\n+        accountTx.commit();\n+        codeTx.commit();\n+        storageTx.commit();\n+        trieBranchTx.commit();\n+        trieLogTx.commit();\n+        updater.reset();\n+      } else {\n+        accountTx.rollback();\n+        codeTx.rollback();\n+        storageTx.rollback();\n+        trieBranchTx.rollback();\n+        trieLogTx.rollback();\n+      }\n+    }\n+  }\n+\n+  private static Bytes rlpEncode(final Bytes bytes) {\n+    final BytesValueRLPOutput out = new BytesValueRLPOutput();\n+    out.writeBytes(bytes.trimLeadingZeros());\n+    return out.encoded();\n+  }\n+\n+  @Override\n+  public WorldUpdater updater() {\n+    if (updater == null) {\n+      updater = new BonsaiWorldStateUpdater(this);", "originalCommit": "624587f9e2e91ef5d39de022facb62cd1e04ef15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg5OTEzMQ==", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536899131", "bodyText": "As I get to the full lagging persisted state this will change.  Right now no layered world states sit between the updater and the persisted state, and there is only one persisted and one pending state.  Expect this to change dramatically.", "author": "shemnon", "createdAt": "2020-12-05T21:50:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgzMDg3Nw=="}], "type": "inlineReview"}]}