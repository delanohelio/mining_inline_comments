{"pr_number": 1235, "pr_title": "Backup and Restore", "pr_createdAt": "2020-07-17T23:42:09Z", "pr_url": "https://github.com/hyperledger/besu/pull/1235", "timeline": [{"oid": "f7ab859082d21f0083a10bce6269070d2937c84c", "url": "https://github.com/hyperledger/besu/commit/f7ab859082d21f0083a10bce6269070d2937c84c", "message": "Leaf and Chaindata backup\n\nCreate leaf and chaindata backup files.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-07-17T20:21:13Z", "type": "commit"}, {"oid": "b3d3b91425e680cce85392e8858aa4cbbb9a406a", "url": "https://github.com/hyperledger/besu/commit/b3d3b91425e680cce85392e8858aa4cbbb9a406a", "message": "optional compression\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-07-17T23:37:59Z", "type": "commit"}, {"oid": "0a75fe8cf1355170d9fb940ee71c49568670424c", "url": "https://github.com/hyperledger/besu/commit/0a75fe8cf1355170d9fb940ee71c49568670424c", "message": "add indexing to chain and lead backup\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-07-23T14:04:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE1MDY3Ng==", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r460150676", "bodyText": "The error message should be in the negative", "author": "RatanRSur", "createdAt": "2020-07-24T16:11:12Z", "path": "besu/src/main/java/org/hyperledger/besu/cli/subcommands/operator/BackupState.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.cli.subcommands.operator;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static org.hyperledger.besu.cli.DefaultCommandValues.MANDATORY_LONG_FORMAT_HELP;\n+\n+import org.hyperledger.besu.BesuInfo;\n+import org.hyperledger.besu.controller.BesuController;\n+import org.hyperledger.besu.ethereum.api.query.StateBackupService;\n+import org.hyperledger.besu.ethereum.api.query.StateBackupService.BackupStatus;\n+import org.hyperledger.besu.ethereum.chain.MutableBlockchain;\n+import org.hyperledger.besu.ethereum.eth.manager.EthScheduler;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateStorage;\n+import org.hyperledger.besu.metrics.noop.NoOpMetricsSystem;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.LockSupport;\n+\n+import picocli.CommandLine.Command;\n+import picocli.CommandLine.Option;\n+import picocli.CommandLine.ParentCommand;\n+\n+@Command(\n+    name = \"backup-state\",\n+    description = \"Backups up the state and accounts of a specified block.\",\n+    mixinStandardHelpOptions = true)\n+public class BackupState implements Runnable {\n+\n+  @Option(\n+      names = \"--block\",\n+      paramLabel = MANDATORY_LONG_FORMAT_HELP,\n+      description = \"The block to perform the backup at (default: calculated chain head)\",\n+      arity = \"1..1\")\n+  private final Long block = Long.MAX_VALUE;\n+\n+  @Option(\n+      names = \"--backup-path\",\n+      required = true,\n+      paramLabel = MANDATORY_LONG_FORMAT_HELP,\n+      description = \"The path to store the backup files.\",\n+      arity = \"1..1\")\n+  private final File backupDir = null;\n+\n+  @Option(\n+      names = {\"--compression-enabled\"},\n+      description = \"Enable data compression\",\n+      arity = \"1\")\n+  private final Boolean compress = true;\n+\n+  @ParentCommand private OperatorSubCommand parentCommand;\n+\n+  @Override\n+  public void run() {\n+    checkArgument(\n+        backupDir.exists() || backupDir.mkdirs(), \"Backup directory exists or can be created\");", "originalCommit": "0a75fe8cf1355170d9fb940ee71c49568670424c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2MDcxNA==", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r460160714", "bodyText": "Do we need to create a whole EthScheduler for this? Can we just have an ExecutorService? Then we can do CompleteableFuture.supplyAsync(computation, executor).", "author": "RatanRSur", "createdAt": "2020-07-24T16:30:28Z", "path": "besu/src/main/java/org/hyperledger/besu/cli/subcommands/operator/BackupState.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.cli.subcommands.operator;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static org.hyperledger.besu.cli.DefaultCommandValues.MANDATORY_LONG_FORMAT_HELP;\n+\n+import org.hyperledger.besu.BesuInfo;\n+import org.hyperledger.besu.controller.BesuController;\n+import org.hyperledger.besu.ethereum.api.query.StateBackupService;\n+import org.hyperledger.besu.ethereum.api.query.StateBackupService.BackupStatus;\n+import org.hyperledger.besu.ethereum.chain.MutableBlockchain;\n+import org.hyperledger.besu.ethereum.eth.manager.EthScheduler;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateStorage;\n+import org.hyperledger.besu.metrics.noop.NoOpMetricsSystem;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.LockSupport;\n+\n+import picocli.CommandLine.Command;\n+import picocli.CommandLine.Option;\n+import picocli.CommandLine.ParentCommand;\n+\n+@Command(\n+    name = \"backup-state\",\n+    description = \"Backups up the state and accounts of a specified block.\",\n+    mixinStandardHelpOptions = true)\n+public class BackupState implements Runnable {\n+\n+  @Option(\n+      names = \"--block\",\n+      paramLabel = MANDATORY_LONG_FORMAT_HELP,\n+      description = \"The block to perform the backup at (default: calculated chain head)\",\n+      arity = \"1..1\")\n+  private final Long block = Long.MAX_VALUE;\n+\n+  @Option(\n+      names = \"--backup-path\",\n+      required = true,\n+      paramLabel = MANDATORY_LONG_FORMAT_HELP,\n+      description = \"The path to store the backup files.\",\n+      arity = \"1..1\")\n+  private final File backupDir = null;\n+\n+  @Option(\n+      names = {\"--compression-enabled\"},\n+      description = \"Enable data compression\",\n+      arity = \"1\")\n+  private final Boolean compress = true;\n+\n+  @ParentCommand private OperatorSubCommand parentCommand;\n+\n+  @Override\n+  public void run() {\n+    checkArgument(\n+        backupDir.exists() || backupDir.mkdirs(), \"Backup directory exists or can be created\");\n+\n+    final BesuController besuController = createBesuController();\n+    final MutableBlockchain blockchain = besuController.getProtocolContext().getBlockchain();\n+    final WorldStateStorage worldStateStorage =\n+        besuController.getProtocolContext().getWorldStateArchive().getWorldStateStorage();\n+    final EthScheduler scheduler = new EthScheduler(1, 1, 1, 1, new NoOpMetricsSystem());", "originalCommit": "0a75fe8cf1355170d9fb940ee71c49568670424c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEzNzgzMg==", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r463137832", "bodyText": "We need the EthScheduler to futureproof the StateBackupService.  We may do backup segments in parallel or even pipelined and the service should have access to the needed infrastructure.", "author": "shemnon", "createdAt": "2020-07-30T16:55:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2MDcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzNDY1Mw==", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r467134653", "bodyText": "EthScheduler's current role is overkill for just parallelization. It assumes you've got specific subsystem threadpools you're scheduling against. I also don't see how it helps with pipelining more than CompletableFutures do because the only other utility methods are scheduling at a specific time.\nGiven that we're in a self-contained operator that doesn't have subsystems, why not opt for just an ExecutorService?", "author": "RatanRSur", "createdAt": "2020-08-07T16:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2MDcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwMDk2OQ==", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r467300969", "bodyText": "Right now we are a self-contained subsystem, but on the roadmap is doing these backups from a web service on a live node as well as a disconnected node.  Putting int he eth scheduler now ensures the backup is compatibile with the threading model of the node.", "author": "shemnon", "createdAt": "2020-08-07T21:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2MDcxNA=="}], "type": "inlineReview"}, {"oid": "5a9276f9db268f58c512713d3b611d30d8d1eb11", "url": "https://github.com/hyperledger/besu/commit/5a9276f9db268f58c512713d3b611d30d8d1eb11", "message": "checkpoint\n\nReads in the RLP and stuffs seems to add up so far.\n* add account count\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-07-27T20:07:02Z", "type": "commit"}, {"oid": "a4489466750449d92ae6bc8240300e8bba41f3aa", "url": "https://github.com/hyperledger/besu/commit/a4489466750449d92ae6bc8240300e8bba41f3aa", "message": "Merge branch 'master' of github.com:hyperledger/besu into backupGenerate\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-07-28T15:18:13Z", "type": "commit"}, {"oid": "73db4926d4dbc97a6b09a9a03431169089a81385", "url": "https://github.com/hyperledger/besu/commit/73db4926d4dbc97a6b09a9a03431169089a81385", "message": "retore checkpoint\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-07-28T17:03:01Z", "type": "commit"}, {"oid": "faafecd38f52c40be2cfab1179885a0a8c2c69e6", "url": "https://github.com/hyperledger/besu/commit/faafecd38f52c40be2cfab1179885a0a8c2c69e6", "message": "Merge branch 'master' of github.com:hyperledger/besu into backupGenerate\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-07-28T17:04:20Z", "type": "commit"}, {"oid": "4e1290129c36e1625b5001725bad149d90b46aa4", "url": "https://github.com/hyperledger/besu/commit/4e1290129c36e1625b5001725bad149d90b46aa4", "message": "possibly works now.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-07-30T04:21:08Z", "type": "commit"}, {"oid": "d9766b972de2465cf98b278c36f2327b7a3fb395", "url": "https://github.com/hyperledger/besu/commit/d9766b972de2465cf98b278c36f2327b7a3fb395", "message": "spotless and fix unit test\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-07-30T16:45:30Z", "type": "commit"}, {"oid": "77d2fb9e68c9cca0c68e7f17d6ffbe185f504fa7", "url": "https://github.com/hyperledger/besu/commit/77d2fb9e68c9cca0c68e7f17d6ffbe185f504fa7", "message": "Acceptance Test refactors\n\nRefactors prior to Backup/Restore\n* Allow multiple extra commands on the command line\n* Extra commands appear at the end of the command line\n* Pull node setup out of DB migration test\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-07-31T06:10:09Z", "type": "commit"}, {"oid": "15012eff784c7b350a9c9ab9695a0dda129feed9", "url": "https://github.com/hyperledger/besu/commit/15012eff784c7b350a9c9ab9695a0dda129feed9", "message": "Merge branch 'atRefactor' into backupGenerate\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-07-31T06:12:57Z", "type": "commit"}, {"oid": "853f607f2243f132ff364ba5bb43e4a4dd3df77c", "url": "https://github.com/hyperledger/besu/commit/853f607f2243f132ff364ba5bb43e4a4dd3df77c", "message": "backup/restore/rebackup acceptance tests\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-07-31T06:14:44Z", "type": "commit"}, {"oid": "7af05d221342f4a4f309339c15450f1d2402f7a1", "url": "https://github.com/hyperledger/besu/commit/7af05d221342f4a4f309339c15450f1d2402f7a1", "message": "spotless\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-07-31T14:58:31Z", "type": "commit"}, {"oid": "611079d98fe19db124b0ef018cfd6befdfa36d2e", "url": "https://github.com/hyperledger/besu/commit/611079d98fe19db124b0ef018cfd6befdfa36d2e", "message": "Merge branch 'master' of github.com:hyperledger/besu into backupGenerate\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-07-31T16:03:12Z", "type": "commit"}, {"oid": "c32e96d89b11de7732fd63b41c28c34019aa6639", "url": "https://github.com/hyperledger/besu/commit/c32e96d89b11de7732fd63b41c28c34019aa6639", "message": "add AT asserts\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-07-31T16:11:16Z", "type": "commit"}, {"oid": "5804852bc98e69ffc5e4a7272083b930001b6b7c", "url": "https://github.com/hyperledger/besu/commit/5804852bc98e69ffc5e4a7272083b930001b6b7c", "message": "test name\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-07-31T17:05:37Z", "type": "commit"}, {"oid": "a2c56bd719285d36033afdebb4debd837823a398", "url": "https://github.com/hyperledger/besu/commit/a2c56bd719285d36033afdebb4debd837823a398", "message": "fix ropsten breakage\n\n* Use a null terminated sequence of RLPs for storage, rather than a full\n  list.  The full list may not always fit in memory for large accounts.\n* Change commands to `x-<foo>` commands until we freeze the backup\n  format.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-08-01T16:34:15Z", "type": "commit"}, {"oid": "23518eaf00e83b7bee5dd53d75fb269eb9533a98", "url": "https://github.com/hyperledger/besu/commit/23518eaf00e83b7bee5dd53d75fb269eb9533a98", "message": "spotless\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-08-01T16:45:16Z", "type": "commit"}, {"oid": "7478c2d39cb110aef6a250f09ae2eed616cf6f41", "url": "https://github.com/hyperledger/besu/commit/7478c2d39cb110aef6a250f09ae2eed616cf6f41", "message": "acceptance tests had old operator names\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-08-01T17:04:18Z", "type": "commit"}, {"oid": "a93472c70b483146a5c615bc28d975b9e9977ef1", "url": "https://github.com/hyperledger/besu/commit/a93472c70b483146a5c615bc28d975b9e9977ef1", "message": "unload nodes on backup iteration\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-08-03T21:10:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU0MDQ4OQ==", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r466540489", "bodyText": "why we don't use LogManager here ?", "author": "matkt", "createdAt": "2020-08-06T16:36:45Z", "path": "besu/src/main/java/org/hyperledger/besu/cli/subcommands/operator/BackupState.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.cli.subcommands.operator;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static org.hyperledger.besu.cli.DefaultCommandValues.MANDATORY_LONG_FORMAT_HELP;\n+\n+import org.hyperledger.besu.BesuInfo;\n+import org.hyperledger.besu.controller.BesuController;\n+import org.hyperledger.besu.ethereum.api.query.StateBackupService;\n+import org.hyperledger.besu.ethereum.api.query.StateBackupService.BackupStatus;\n+import org.hyperledger.besu.ethereum.chain.MutableBlockchain;\n+import org.hyperledger.besu.ethereum.eth.manager.EthScheduler;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateStorage;\n+import org.hyperledger.besu.metrics.noop.NoOpMetricsSystem;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.LockSupport;\n+\n+import picocli.CommandLine.Command;\n+import picocli.CommandLine.Option;\n+import picocli.CommandLine.ParentCommand;\n+\n+@Command(\n+    name = \"x-backup-state\",\n+    description = \"Backups up the state and accounts of a specified block.\",\n+    mixinStandardHelpOptions = true)\n+public class BackupState implements Runnable {\n+\n+  @Option(\n+      names = \"--block\",\n+      paramLabel = MANDATORY_LONG_FORMAT_HELP,\n+      description = \"The block to perform the backup at (default: calculated chain head)\",\n+      arity = \"1..1\")\n+  private final Long block = Long.MAX_VALUE;\n+\n+  @Option(\n+      names = \"--backup-path\",\n+      required = true,\n+      paramLabel = MANDATORY_LONG_FORMAT_HELP,\n+      description = \"The path to store the backup files.\",\n+      arity = \"1..1\")\n+  private final File backupDir = null;\n+\n+  @Option(\n+      names = {\"--compression-enabled\"},\n+      description = \"Enable data compression\",\n+      arity = \"1\")\n+  private final Boolean compress = true;\n+\n+  @ParentCommand private OperatorSubCommand parentCommand;\n+\n+  @Override\n+  public void run() {\n+    checkArgument(\n+        parentCommand.parentCommand.dataDir().toFile().exists(),\n+        \"DataDir (the blockchain being backed up) does not exist.\");\n+    checkArgument(\n+        backupDir.exists() || backupDir.mkdirs(),\n+        \"Backup directory does not exist and cannot be created.\");\n+\n+    final BesuController besuController = createBesuController();\n+    final MutableBlockchain blockchain = besuController.getProtocolContext().getBlockchain();\n+    final WorldStateStorage worldStateStorage =\n+        besuController.getProtocolContext().getWorldStateArchive().getWorldStateStorage();\n+    final EthScheduler scheduler = new EthScheduler(1, 1, 1, 1, new NoOpMetricsSystem());\n+    try {\n+      final long targetBlock = Math.min(blockchain.getChainHeadBlockNumber(), this.block);\n+      final StateBackupService backup =\n+          new StateBackupService(\n+              BesuInfo.version(), blockchain, backupDir.toPath(), scheduler, worldStateStorage);\n+      final BackupStatus status = backup.requestBackup(targetBlock, compress, Optional.empty());\n+\n+      final double refValue = Math.pow(2, 256) / 100.0d;\n+      while (status.isBackingUp()) {\n+        if (status.getTargetBlockNum() != status.getStoredBlockNum()) {\n+          System.out.printf(\n+              \"Chain Progress - %,d of %,d (%5.2f%%)%n\",\n+              status.getStoredBlockNum(),\n+              status.getTargetBlockNum(),\n+              status.getStoredBlockNum() * 100.0d / status.getTargetBlockNum());\n+        } else {\n+          System.out.printf(\n+              \"State Progress - %6.3f%% / %,d Accounts / %,d Storage Nodes%n\",\n+              status.getCurrentAccountBytes().toUnsignedBigInteger().doubleValue() / refValue,\n+              status.getAccountCount(),\n+              status.getStorageCount());\n+        }\n+        LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(10));\n+      }\n+\n+      System.out.printf(", "originalCommit": "a93472c70b483146a5c615bc28d975b9e9977ef1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2MjAyNw==", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r466562027", "bodyText": "As a command the output should only ever be to standard out.  Logging does not guarantee this.", "author": "shemnon", "createdAt": "2020-08-06T17:14:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU0MDQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU0MTc0Ng==", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r466541746", "bodyText": "Is it not possible to have something like while(len!=0) instead of while (true) ?", "author": "matkt", "createdAt": "2020-08-06T16:38:55Z", "path": "besu/src/main/java/org/hyperledger/besu/cli/subcommands/operator/RestoreState.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.cli.subcommands.operator;\n+\n+import static org.hyperledger.besu.cli.DefaultCommandValues.MANDATORY_LONG_FORMAT_HELP;\n+import static org.hyperledger.besu.ethereum.trie.CompactEncoding.bytesToPath;\n+\n+import org.hyperledger.besu.config.JsonUtil;\n+import org.hyperledger.besu.controller.BesuController;\n+import org.hyperledger.besu.ethereum.api.query.StateBackupService;\n+import org.hyperledger.besu.ethereum.chain.MutableBlockchain;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockBody;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.BlockHeaderFunctions;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.TransactionReceipt;\n+import org.hyperledger.besu.ethereum.mainnet.MainnetBlockHeaderFunctions;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLPInput;\n+import org.hyperledger.besu.ethereum.trie.Node;\n+import org.hyperledger.besu.ethereum.trie.PersistVisitor;\n+import org.hyperledger.besu.ethereum.trie.RestoreVisitor;\n+import org.hyperledger.besu.ethereum.worldstate.StateTrieAccountValue;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateStorage;\n+\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.EOFException;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.xerial.snappy.Snappy;\n+import picocli.CommandLine.Command;\n+import picocli.CommandLine.Option;\n+import picocli.CommandLine.ParentCommand;\n+\n+@Command(\n+    name = \"x-restore-state\",\n+    description = \"Restores the chain from a previously generated backup-state.\",\n+    mixinStandardHelpOptions = true)\n+public class RestoreState implements Runnable {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  @Option(\n+      names = \"--backup-path\",\n+      required = true,\n+      paramLabel = MANDATORY_LONG_FORMAT_HELP,\n+      description = \"The path to store the backup files.\",\n+      arity = \"1..1\")\n+  private final Path backupDir = null;\n+\n+  @ParentCommand private OperatorSubCommand parentCommand;\n+\n+  private static final int TRIE_NODE_COMMIT_BATCH_SIZE = 100;\n+\n+  private long targetBlock;\n+  private long accountCount;\n+  private long trieNodeCount;\n+  private boolean compressed;\n+  private BesuController besuController;\n+  private WorldStateStorage.Updater updater;\n+\n+  private Path accountFileName(final int fileNumber, final boolean compressed) {\n+    return StateBackupService.accountFileName(backupDir, targetBlock, fileNumber, compressed);\n+  }\n+\n+  private Path headerFileName(final int fileNumber, final boolean compressed) {\n+    return StateBackupService.headerFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private Path bodyFileName(final int fileNumber, final boolean compressed) {\n+    return StateBackupService.bodyFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private Path receiptFileName(final int fileNumber, final boolean compressed) {\n+    return StateBackupService.receiptFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  @Override\n+  public void run() {\n+    try {\n+      final ObjectNode manifest =\n+          JsonUtil.objectNodeFromString(\n+              Files.readString(backupDir.resolve(\"besu-backup-manifest.json\")));\n+\n+      compressed = manifest.get(\"compressed\").asBoolean(false);\n+      targetBlock = manifest.get(\"targetBlock\").asLong();\n+      accountCount = manifest.get(\"accountCount\").asLong();\n+      besuController = createBesuController();\n+\n+      restoreBlocks();\n+      restoreAccounts();\n+\n+      LOG.info(\"Restore complete\");\n+\n+    } catch (final IOException e) {\n+      LOG.error(\"Error restoring state\", e);\n+    }\n+  }\n+\n+  private void restoreBlocks() throws IOException {\n+    try (final RollingFileReader headerReader =\n+            new RollingFileReader(this::headerFileName, compressed);\n+        final RollingFileReader bodyReader = new RollingFileReader(this::bodyFileName, compressed);\n+        final RollingFileReader receiptReader =\n+            new RollingFileReader(this::receiptFileName, compressed)) {\n+      final MutableBlockchain blockchain = besuController.getProtocolContext().getBlockchain();\n+      // target block is \"including\" the target block, so LE test not LT.\n+      for (int i = 0; i <= targetBlock; i++) {\n+        if (i % 100000 == 0) {\n+          LOG.info(\"Loading chain data {} / {}\", i, targetBlock);\n+        }\n+\n+        final byte[] headerEntry = headerReader.readBytes();\n+        final byte[] bodyEntry = bodyReader.readBytes();\n+        final byte[] receiptEntry = receiptReader.readBytes();\n+        final BlockHeaderFunctions functions = new MainnetBlockHeaderFunctions();\n+\n+        final BlockHeader header =\n+            BlockHeader.readFrom(\n+                new BytesValueRLPInput(Bytes.wrap(headerEntry), false, true), functions);\n+        final BlockBody body =\n+            BlockBody.readFrom(\n+                new BytesValueRLPInput(Bytes.wrap(bodyEntry), false, true), functions);\n+        final RLPInput receiptsRlp = new BytesValueRLPInput(Bytes.wrap(receiptEntry), false, true);\n+        final int receiptsCount = receiptsRlp.enterList();\n+        final List<TransactionReceipt> receipts = new ArrayList<>(receiptsCount);\n+        for (int j = 0; j < receiptsCount; j++) {\n+          receipts.add(TransactionReceipt.readFrom(receiptsRlp, true));\n+        }\n+        receiptsRlp.leaveList();\n+\n+        blockchain.appendBlock(new Block(header, body), receipts);\n+      }\n+    }\n+    LOG.info(\"Chain data loaded\");\n+  }\n+\n+  @SuppressWarnings(\"UnusedVariable\")\n+  private void restoreAccounts() throws IOException {\n+    newWorldStateUpdater();\n+    int storageBranchCount = 0;\n+    int storageExtensionCount = 0;\n+    int storageLeafCount = 0;\n+\n+    final PersistVisitor<Bytes> accountPersistVisitor =\n+        new PersistVisitor<>(this::updateAccountState);\n+    Node<Bytes> root = accountPersistVisitor.initialRoot();\n+\n+    try (final RollingFileReader reader =\n+        new RollingFileReader(this::accountFileName, compressed)) {\n+      for (int i = 0; i < accountCount; i++) {\n+        if (i % 100000 == 0) {\n+          LOG.info(\"Loading account data {} / {}\", i, accountCount);\n+        }\n+        final byte[] accountEntry = reader.readBytes();\n+        final BytesValueRLPInput accountInput =\n+            new BytesValueRLPInput(Bytes.of(accountEntry), false, true);\n+        final int length = accountInput.enterList();\n+        if (length != 3) {\n+          throw new RuntimeException(\"Unexpected account length \" + length);\n+        }\n+        final Bytes32 trieKey = accountInput.readBytes32();\n+        final Bytes accountRlp = accountInput.readBytes();\n+        final Bytes code = accountInput.readBytes();\n+\n+        final StateTrieAccountValue trieAccount =\n+            StateTrieAccountValue.readFrom(new BytesValueRLPInput(accountRlp, false, true));\n+        if (!trieAccount.getCodeHash().equals(Hash.hash(code))) {\n+          throw new RuntimeException(\"Code hash doesn't match\");\n+        }\n+        if (code.size() > 0) {\n+          updateCode(code);\n+        }\n+\n+        final RestoreVisitor<Bytes> accountTrieWriteVisitor =\n+            new RestoreVisitor<>(t -> t, accountRlp, accountPersistVisitor);\n+\n+        root = root.accept(accountTrieWriteVisitor, bytesToPath(trieKey));\n+\n+        final PersistVisitor<Bytes> storagePersistVisitor =\n+            new PersistVisitor<>(this::updateAccountStorage);\n+        Node<Bytes> storageRoot = storagePersistVisitor.initialRoot();\n+\n+        while (true) {", "originalCommit": "a93472c70b483146a5c615bc28d975b9e9977ef1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2MTYyMA==", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r466561620", "bodyText": "Because we don't know a-priori what the length of the list of leaf nodes will be.  It's too large for memory (I tried) and reading it twice imposes a huge DB hit.  So I null terminate the list.\nMaking it a len check would involve duplicating the code to read the trie value.", "author": "shemnon", "createdAt": "2020-08-06T17:13:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU0MTc0Ng=="}], "type": "inlineReview"}, {"oid": "536dcfcaa84dfa034723ec94a591bf5f90ae50ab", "url": "https://github.com/hyperledger/besu/commit/536dcfcaa84dfa034723ec94a591bf5f90ae50ab", "message": "Merge branch 'master' into backupGenerate", "committedDate": "2020-08-07T15:20:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0MjMxMQ==", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r467142311", "bodyText": "At a quick glance I can't see where this is used.", "author": "RatanRSur", "createdAt": "2020-08-07T16:24:27Z", "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/query/StateBackupService.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.api.query;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import org.hyperledger.besu.config.JsonUtil;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.TransactionReceipt;\n+import org.hyperledger.besu.ethereum.eth.manager.EthScheduler;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.Node;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.TrieIterator;\n+import org.hyperledger.besu.ethereum.trie.TrieIterator.State;\n+import org.hyperledger.besu.ethereum.worldstate.StateTrieAccountValue;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateStorage;\n+import org.hyperledger.besu.plugin.data.Hash;\n+\n+import java.io.Closeable;\n+import java.io.DataOutputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import com.fasterxml.jackson.annotation.JsonGetter;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.xerial.snappy.Snappy;\n+\n+public class StateBackupService {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final long MAX_FILE_SIZE = 1 << 28; // 256 MiB max file size\n+  private static final Bytes ACCOUNT_END_MARKER;\n+\n+  static {\n+    final BytesValueRLPOutput endMarker = new BytesValueRLPOutput();\n+    endMarker.startList();\n+    endMarker.endList();\n+    ACCOUNT_END_MARKER = endMarker.encoded();\n+  }\n+\n+  private final String besuVesion;\n+  private final Lock submissionLock = new ReentrantLock();\n+  private final EthScheduler scheduler;\n+  private final Blockchain blockchain;\n+  private final WorldStateStorage worldStateStorage;\n+  private final BackupStatus backupStatus = new BackupStatus();\n+\n+  private Path backupDir;\n+  private RollingFileWriter accountFileWriter;\n+\n+  public StateBackupService(\n+      final String besuVesion,\n+      final Blockchain blockchain,\n+      final Path backupDir,\n+      final EthScheduler scheduler,\n+      final WorldStateStorage worldStateStorage) {\n+    this.besuVesion = besuVesion;\n+    this.blockchain = blockchain;\n+    this.backupDir = backupDir;\n+    this.scheduler = scheduler;\n+    this.worldStateStorage = worldStateStorage;\n+  }\n+\n+  public Path getBackupDir() {\n+    return backupDir;\n+  }\n+\n+  public BackupStatus requestBackup(\n+      final long block, final boolean compress, final Optional<Path> backupDir) {\n+    boolean requestAccepted = false;\n+    try {\n+      if (submissionLock.tryLock(100, TimeUnit.MILLISECONDS)) {\n+        try {\n+          if (!backupStatus.isBackingUp()) {\n+            requestAccepted = true;\n+            this.backupDir = backupDir.orElse(this.backupDir);\n+            backupStatus.targetBlock = block;\n+            backupStatus.compressed = compress;\n+            backupStatus.currentAccount = Bytes32.ZERO;\n+            scheduler.scheduleComputationTask(\n+                () -> {\n+                  try {\n+                    return backup(block, compress);\n+\n+                  } catch (final IOException ioe) {\n+                    LOG.error(\"Error writing backups\", ioe);\n+                    return backupStatus;\n+                  }\n+                });\n+          }\n+        } finally {\n+          submissionLock.unlock();\n+        }\n+      }\n+    } catch (final InterruptedException e) {\n+      // ignore\n+    }\n+    backupStatus.requestAccepted = requestAccepted;\n+    return backupStatus;\n+  }\n+\n+  public static Path dataFileToIndex(final Path dataName) {\n+    return Path.of(dataName.toString().replaceAll(\"(.*)[-.]\\\\d\\\\d\\\\d\\\\d\\\\.(.)dat\", \"$1.$2idx\"));\n+  }\n+\n+  public static Path accountFileName(\n+      final Path backupDir,\n+      final long targetBlock,\n+      final int fileNumber,\n+      final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\n+            \"besu-account-backup-%08d-%04d.%sdat\",\n+            targetBlock, fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path headerFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-header-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path bodyFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-body-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path receiptFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-receipt-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  private Path accountFileName(final int fileNumber, final boolean compressed) {\n+    return accountFileName(backupDir, backupStatus.targetBlock, fileNumber, compressed);\n+  }\n+\n+  private Path headerFileName(final int fileNumber, final boolean compressed) {\n+    return headerFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private Path bodyFileName(final int fileNumber, final boolean compressed) {\n+    return bodyFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private Path receiptFileName(final int fileNumber, final boolean compressed) {\n+    return receiptFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private BackupStatus backup(final long block, final boolean compress) throws IOException {\n+    try {\n+      checkArgument(\n+          block >= 0 && block <= blockchain.getChainHeadBlockNumber(),\n+          \"Backup Block must be within blockchain\");\n+      backupStatus.targetBlock = block;\n+      backupStatus.compressed = compress;\n+      backupStatus.currentAccount = Bytes32.ZERO;\n+\n+      backupChaindata();\n+      backupLeaves();\n+\n+      writeManifest();\n+\n+      return backupStatus;\n+    } catch (final Throwable t) {\n+      LOG.error(\"Unexpected error\", t);\n+      throw t;\n+    }\n+  }\n+\n+  private void writeManifest() throws IOException {\n+    final Map<String, Object> manifest = new HashMap<>();\n+    manifest.put(\"clientVersion\", besuVesion);\n+    manifest.put(\"compressed\", backupStatus.compressed);\n+    manifest.put(\"targetBlock\", backupStatus.targetBlock);\n+    manifest.put(\"accountCount\", backupStatus.accountCount);\n+\n+    Files.write(\n+        backupDir.resolve(\"besu-backup-manifest.json\"),\n+        JsonUtil.getJson(manifest).getBytes(StandardCharsets.UTF_8));\n+  }\n+\n+  private void backupLeaves() throws IOException {\n+    final Optional<BlockHeader> header = blockchain.getBlockHeader(backupStatus.targetBlock);\n+    if (header.isEmpty()) {\n+      backupStatus.currentAccount = null;\n+      return;\n+    }\n+    final Optional<Bytes> worldStateRoot =\n+        worldStateStorage.getAccountStateTrieNode(header.get().getStateRoot());\n+    if (worldStateRoot.isEmpty()) {\n+      backupStatus.currentAccount = null;\n+      return;\n+    }\n+\n+    try (final RollingFileWriter accountFileWriter =\n+        new RollingFileWriter(this::accountFileName, backupStatus.compressed)) {\n+      this.accountFileWriter = accountFileWriter;\n+\n+      final StoredMerklePatriciaTrie<Bytes32, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              worldStateStorage::getAccountStateTrieNode,\n+              header.get().getStateRoot(),\n+              Function.identity(),\n+              Function.identity());\n+\n+      accountTrie.visitLeafs(this::visitAccount);\n+      backupStatus.currentAccount = null;\n+    }\n+  }\n+\n+  private TrieIterator.State visitAccount(final Bytes32 nodeKey, final Node<Bytes> node) {\n+    if (node.getValue().isEmpty()) {\n+      return State.CONTINUE;\n+    }\n+\n+    backupStatus.currentAccount = nodeKey;\n+    final Bytes nodeValue = node.getValue().orElse(Hash.EMPTY);\n+    final StateTrieAccountValue account =\n+        StateTrieAccountValue.readFrom(new BytesValueRLPInput(nodeValue, false));\n+\n+    final Bytes code = worldStateStorage.getCode(account.getCodeHash()).orElse(Bytes.EMPTY);\n+    backupStatus.codeSize.addAndGet(code.size());\n+\n+    final BytesValueRLPOutput accountOutput = new BytesValueRLPOutput();\n+    accountOutput.startList();\n+    accountOutput.writeBytes(nodeKey); // trie hash\n+    accountOutput.writeBytes(nodeValue); // account rlp\n+    accountOutput.writeBytes(code); // code\n+    accountOutput.endList();\n+\n+    try {\n+      accountFileWriter.writeBytes(accountOutput.encoded().toArrayUnsafe());\n+    } catch (final IOException ioe) {\n+      LOG.error(\"Failure writing backup\", ioe);\n+      return State.STOP;\n+    }\n+\n+    // storage is written for each leaf, otherwise the whole trie would have to fit in memory\n+    final StoredMerklePatriciaTrie<Bytes32, Bytes> storageTrie =\n+        new StoredMerklePatriciaTrie<>(\n+            worldStateStorage::getAccountStateTrieNode,\n+            account.getStorageRoot(),\n+            Function.identity(),\n+            Function.identity());\n+    storageTrie.visitLeafs(\n+        (storageKey, storageValue) ->\n+            visitAccountStorage(storageKey, storageValue, accountFileWriter));\n+\n+    try {\n+      accountFileWriter.writeBytes(ACCOUNT_END_MARKER.toArrayUnsafe());\n+    } catch (final IOException ioe) {\n+      LOG.error(\"Failure writing backup\", ioe);\n+      return State.STOP;\n+    }\n+\n+    backupStatus.accountCount.incrementAndGet();\n+    return State.CONTINUE;\n+  }\n+\n+  private void backupChaindata() throws IOException {\n+    try (final RollingFileWriter headerWriter =\n+            new RollingFileWriter(this::headerFileName, backupStatus.compressed);\n+        final RollingFileWriter bodyWriter =\n+            new RollingFileWriter(this::bodyFileName, backupStatus.compressed);\n+        final RollingFileWriter receiptsWriter =\n+            new RollingFileWriter(this::receiptFileName, backupStatus.compressed)) {\n+      for (int blockNumber = 0; blockNumber <= backupStatus.targetBlock; blockNumber++) {\n+        final Optional<Block> block = blockchain.getBlockByNumber(blockNumber);\n+        if (block.isEmpty()) {\n+          throw new IllegalStateException(\n+              \"Block data for \" + blockNumber + \" was not found in the archive\");\n+        }\n+        final Optional<List<TransactionReceipt>> receipts =\n+            blockchain.getTxReceipts(block.get().getHash());\n+        if (receipts.isEmpty()) {\n+          throw new IllegalStateException(\n+              \"Receipts for \" + blockNumber + \" was not found in the archive\");\n+        }\n+\n+        final BytesValueRLPOutput headerOutput = new BytesValueRLPOutput();\n+        block.get().getHeader().writeTo(headerOutput);\n+        headerWriter.writeBytes(headerOutput.encoded().toArrayUnsafe());\n+\n+        final BytesValueRLPOutput bodyOutput = new BytesValueRLPOutput();\n+        block.get().getBody().writeTo(bodyOutput);\n+        bodyWriter.writeBytes(bodyOutput.encoded().toArrayUnsafe());\n+\n+        final BytesValueRLPOutput receiptsOutput = new BytesValueRLPOutput();\n+        receiptsOutput.writeList(receipts.get(), TransactionReceipt::writeToWithRevertReason);\n+        receiptsWriter.writeBytes(receiptsOutput.encoded().toArrayUnsafe());\n+\n+        backupStatus.storedBlock = blockNumber;\n+      }\n+    }\n+  }\n+\n+  private TrieIterator.State visitAccountStorage(\n+      final Bytes32 nodeKey, final Node<Bytes> node, final RollingFileWriter accountFileWriter) {\n+    backupStatus.currentStorage = nodeKey;\n+\n+    final BytesValueRLPOutput output = new BytesValueRLPOutput();\n+    output.startList();\n+    output.writeBytes(nodeKey);\n+    output.writeBytes(node.getValue().orElse(Bytes.EMPTY));\n+    output.endList();\n+\n+    try {\n+      accountFileWriter.writeBytes(output.encoded().toArrayUnsafe());\n+    } catch (final IOException ioe) {\n+      LOG.error(\"Failure writing backup\", ioe);\n+      return State.STOP;\n+    }\n+\n+    backupStatus.storageCount.incrementAndGet();\n+    return State.CONTINUE;\n+  }\n+\n+  static class RollingFileWriter implements Closeable {\n+    final BiFunction<Integer, Boolean, Path> filenameGenerator;\n+    final boolean compressed;\n+    int currentSize;\n+    int fileNumber;\n+    FileOutputStream out;\n+    final DataOutputStream index;\n+\n+    RollingFileWriter(\n+        final BiFunction<Integer, Boolean, Path> filenameGenerator, final boolean compressed)\n+        throws FileNotFoundException {\n+      this.filenameGenerator = filenameGenerator;\n+      this.compressed = compressed;\n+      currentSize = 0;\n+      fileNumber = 0;\n+      final Path firstOutputFile = filenameGenerator.apply(fileNumber, compressed);\n+      out = new FileOutputStream(firstOutputFile.toFile());\n+      index = new DataOutputStream(new FileOutputStream(dataFileToIndex(firstOutputFile).toFile()));\n+    }\n+\n+    void writeBytes(final byte[] bytes) throws IOException {\n+      final byte[] finalBytes;\n+      if (compressed) {\n+        finalBytes = Snappy.compress(bytes);\n+      } else {\n+        finalBytes = bytes;\n+      }\n+      int pos = currentSize;\n+      currentSize += finalBytes.length;\n+      if (currentSize > MAX_FILE_SIZE) {\n+        out.close();\n+        out = new FileOutputStream(filenameGenerator.apply(++fileNumber, compressed).toFile());\n+        currentSize = finalBytes.length;\n+        pos = 0;\n+      }\n+      index.writeShort(fileNumber);\n+      index.writeInt(pos);\n+      out.write(finalBytes);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+      out.close();\n+      index.close();\n+    }\n+  }\n+\n+  public static final class BackupStatus {\n+    long targetBlock;\n+    long storedBlock;\n+    boolean compressed;\n+    Bytes32 currentAccount;\n+    Bytes32 currentStorage;\n+    AtomicLong accountCount = new AtomicLong(0);\n+    AtomicLong codeSize = new AtomicLong(0);\n+    AtomicLong storageCount = new AtomicLong(0);\n+    boolean requestAccepted;", "originalCommit": "536dcfcaa84dfa034723ec94a591bf5f90ae50ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwMzAwMw==", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r467303003", "bodyText": "This is for the future looking JSON-RPC api.  It will work like the AdminGenerateLogBloomCache where if a backup is in progress the request to backup is rejected.", "author": "shemnon", "createdAt": "2020-08-07T21:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0MjMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0NjA1OQ==", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r467146059", "bodyText": "(optional) checkState here and below as well", "author": "RatanRSur", "createdAt": "2020-08-07T16:31:49Z", "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/query/StateBackupService.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.api.query;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import org.hyperledger.besu.config.JsonUtil;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.TransactionReceipt;\n+import org.hyperledger.besu.ethereum.eth.manager.EthScheduler;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.Node;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.TrieIterator;\n+import org.hyperledger.besu.ethereum.trie.TrieIterator.State;\n+import org.hyperledger.besu.ethereum.worldstate.StateTrieAccountValue;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateStorage;\n+import org.hyperledger.besu.plugin.data.Hash;\n+\n+import java.io.Closeable;\n+import java.io.DataOutputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import com.fasterxml.jackson.annotation.JsonGetter;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.xerial.snappy.Snappy;\n+\n+public class StateBackupService {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final long MAX_FILE_SIZE = 1 << 28; // 256 MiB max file size\n+  private static final Bytes ACCOUNT_END_MARKER;\n+\n+  static {\n+    final BytesValueRLPOutput endMarker = new BytesValueRLPOutput();\n+    endMarker.startList();\n+    endMarker.endList();\n+    ACCOUNT_END_MARKER = endMarker.encoded();\n+  }\n+\n+  private final String besuVesion;\n+  private final Lock submissionLock = new ReentrantLock();\n+  private final EthScheduler scheduler;\n+  private final Blockchain blockchain;\n+  private final WorldStateStorage worldStateStorage;\n+  private final BackupStatus backupStatus = new BackupStatus();\n+\n+  private Path backupDir;\n+  private RollingFileWriter accountFileWriter;\n+\n+  public StateBackupService(\n+      final String besuVesion,\n+      final Blockchain blockchain,\n+      final Path backupDir,\n+      final EthScheduler scheduler,\n+      final WorldStateStorage worldStateStorage) {\n+    this.besuVesion = besuVesion;\n+    this.blockchain = blockchain;\n+    this.backupDir = backupDir;\n+    this.scheduler = scheduler;\n+    this.worldStateStorage = worldStateStorage;\n+  }\n+\n+  public Path getBackupDir() {\n+    return backupDir;\n+  }\n+\n+  public BackupStatus requestBackup(\n+      final long block, final boolean compress, final Optional<Path> backupDir) {\n+    boolean requestAccepted = false;\n+    try {\n+      if (submissionLock.tryLock(100, TimeUnit.MILLISECONDS)) {\n+        try {\n+          if (!backupStatus.isBackingUp()) {\n+            requestAccepted = true;\n+            this.backupDir = backupDir.orElse(this.backupDir);\n+            backupStatus.targetBlock = block;\n+            backupStatus.compressed = compress;\n+            backupStatus.currentAccount = Bytes32.ZERO;\n+            scheduler.scheduleComputationTask(\n+                () -> {\n+                  try {\n+                    return backup(block, compress);\n+\n+                  } catch (final IOException ioe) {\n+                    LOG.error(\"Error writing backups\", ioe);\n+                    return backupStatus;\n+                  }\n+                });\n+          }\n+        } finally {\n+          submissionLock.unlock();\n+        }\n+      }\n+    } catch (final InterruptedException e) {\n+      // ignore\n+    }\n+    backupStatus.requestAccepted = requestAccepted;\n+    return backupStatus;\n+  }\n+\n+  public static Path dataFileToIndex(final Path dataName) {\n+    return Path.of(dataName.toString().replaceAll(\"(.*)[-.]\\\\d\\\\d\\\\d\\\\d\\\\.(.)dat\", \"$1.$2idx\"));\n+  }\n+\n+  public static Path accountFileName(\n+      final Path backupDir,\n+      final long targetBlock,\n+      final int fileNumber,\n+      final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\n+            \"besu-account-backup-%08d-%04d.%sdat\",\n+            targetBlock, fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path headerFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-header-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path bodyFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-body-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path receiptFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-receipt-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  private Path accountFileName(final int fileNumber, final boolean compressed) {\n+    return accountFileName(backupDir, backupStatus.targetBlock, fileNumber, compressed);\n+  }\n+\n+  private Path headerFileName(final int fileNumber, final boolean compressed) {\n+    return headerFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private Path bodyFileName(final int fileNumber, final boolean compressed) {\n+    return bodyFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private Path receiptFileName(final int fileNumber, final boolean compressed) {\n+    return receiptFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private BackupStatus backup(final long block, final boolean compress) throws IOException {\n+    try {\n+      checkArgument(\n+          block >= 0 && block <= blockchain.getChainHeadBlockNumber(),\n+          \"Backup Block must be within blockchain\");\n+      backupStatus.targetBlock = block;\n+      backupStatus.compressed = compress;\n+      backupStatus.currentAccount = Bytes32.ZERO;\n+\n+      backupChaindata();\n+      backupLeaves();\n+\n+      writeManifest();\n+\n+      return backupStatus;\n+    } catch (final Throwable t) {\n+      LOG.error(\"Unexpected error\", t);\n+      throw t;\n+    }\n+  }\n+\n+  private void writeManifest() throws IOException {\n+    final Map<String, Object> manifest = new HashMap<>();\n+    manifest.put(\"clientVersion\", besuVesion);\n+    manifest.put(\"compressed\", backupStatus.compressed);\n+    manifest.put(\"targetBlock\", backupStatus.targetBlock);\n+    manifest.put(\"accountCount\", backupStatus.accountCount);\n+\n+    Files.write(\n+        backupDir.resolve(\"besu-backup-manifest.json\"),\n+        JsonUtil.getJson(manifest).getBytes(StandardCharsets.UTF_8));\n+  }\n+\n+  private void backupLeaves() throws IOException {\n+    final Optional<BlockHeader> header = blockchain.getBlockHeader(backupStatus.targetBlock);\n+    if (header.isEmpty()) {\n+      backupStatus.currentAccount = null;\n+      return;\n+    }\n+    final Optional<Bytes> worldStateRoot =\n+        worldStateStorage.getAccountStateTrieNode(header.get().getStateRoot());\n+    if (worldStateRoot.isEmpty()) {\n+      backupStatus.currentAccount = null;\n+      return;\n+    }\n+\n+    try (final RollingFileWriter accountFileWriter =\n+        new RollingFileWriter(this::accountFileName, backupStatus.compressed)) {\n+      this.accountFileWriter = accountFileWriter;\n+\n+      final StoredMerklePatriciaTrie<Bytes32, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              worldStateStorage::getAccountStateTrieNode,\n+              header.get().getStateRoot(),\n+              Function.identity(),\n+              Function.identity());\n+\n+      accountTrie.visitLeafs(this::visitAccount);\n+      backupStatus.currentAccount = null;\n+    }\n+  }\n+\n+  private TrieIterator.State visitAccount(final Bytes32 nodeKey, final Node<Bytes> node) {\n+    if (node.getValue().isEmpty()) {\n+      return State.CONTINUE;\n+    }\n+\n+    backupStatus.currentAccount = nodeKey;\n+    final Bytes nodeValue = node.getValue().orElse(Hash.EMPTY);\n+    final StateTrieAccountValue account =\n+        StateTrieAccountValue.readFrom(new BytesValueRLPInput(nodeValue, false));\n+\n+    final Bytes code = worldStateStorage.getCode(account.getCodeHash()).orElse(Bytes.EMPTY);\n+    backupStatus.codeSize.addAndGet(code.size());\n+\n+    final BytesValueRLPOutput accountOutput = new BytesValueRLPOutput();\n+    accountOutput.startList();\n+    accountOutput.writeBytes(nodeKey); // trie hash\n+    accountOutput.writeBytes(nodeValue); // account rlp\n+    accountOutput.writeBytes(code); // code\n+    accountOutput.endList();\n+\n+    try {\n+      accountFileWriter.writeBytes(accountOutput.encoded().toArrayUnsafe());\n+    } catch (final IOException ioe) {\n+      LOG.error(\"Failure writing backup\", ioe);\n+      return State.STOP;\n+    }\n+\n+    // storage is written for each leaf, otherwise the whole trie would have to fit in memory\n+    final StoredMerklePatriciaTrie<Bytes32, Bytes> storageTrie =\n+        new StoredMerklePatriciaTrie<>(\n+            worldStateStorage::getAccountStateTrieNode,\n+            account.getStorageRoot(),\n+            Function.identity(),\n+            Function.identity());\n+    storageTrie.visitLeafs(\n+        (storageKey, storageValue) ->\n+            visitAccountStorage(storageKey, storageValue, accountFileWriter));\n+\n+    try {\n+      accountFileWriter.writeBytes(ACCOUNT_END_MARKER.toArrayUnsafe());\n+    } catch (final IOException ioe) {\n+      LOG.error(\"Failure writing backup\", ioe);\n+      return State.STOP;\n+    }\n+\n+    backupStatus.accountCount.incrementAndGet();\n+    return State.CONTINUE;\n+  }\n+\n+  private void backupChaindata() throws IOException {\n+    try (final RollingFileWriter headerWriter =\n+            new RollingFileWriter(this::headerFileName, backupStatus.compressed);\n+        final RollingFileWriter bodyWriter =\n+            new RollingFileWriter(this::bodyFileName, backupStatus.compressed);\n+        final RollingFileWriter receiptsWriter =\n+            new RollingFileWriter(this::receiptFileName, backupStatus.compressed)) {\n+      for (int blockNumber = 0; blockNumber <= backupStatus.targetBlock; blockNumber++) {\n+        final Optional<Block> block = blockchain.getBlockByNumber(blockNumber);\n+        if (block.isEmpty()) {\n+          throw new IllegalStateException(\n+              \"Block data for \" + blockNumber + \" was not found in the archive\");\n+        }", "originalCommit": "536dcfcaa84dfa034723ec94a591bf5f90ae50ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzMDI4OA==", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r467330288", "bodyText": "done", "author": "shemnon", "createdAt": "2020-08-07T23:48:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0NjA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0NjczNg==", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r467146736", "bodyText": "This is surprising to me, there can't be any blocks without receipts? How does it work for empty blocks?", "author": "RatanRSur", "createdAt": "2020-08-07T16:33:17Z", "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/query/StateBackupService.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.api.query;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import org.hyperledger.besu.config.JsonUtil;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.TransactionReceipt;\n+import org.hyperledger.besu.ethereum.eth.manager.EthScheduler;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.Node;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.TrieIterator;\n+import org.hyperledger.besu.ethereum.trie.TrieIterator.State;\n+import org.hyperledger.besu.ethereum.worldstate.StateTrieAccountValue;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateStorage;\n+import org.hyperledger.besu.plugin.data.Hash;\n+\n+import java.io.Closeable;\n+import java.io.DataOutputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import com.fasterxml.jackson.annotation.JsonGetter;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.xerial.snappy.Snappy;\n+\n+public class StateBackupService {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final long MAX_FILE_SIZE = 1 << 28; // 256 MiB max file size\n+  private static final Bytes ACCOUNT_END_MARKER;\n+\n+  static {\n+    final BytesValueRLPOutput endMarker = new BytesValueRLPOutput();\n+    endMarker.startList();\n+    endMarker.endList();\n+    ACCOUNT_END_MARKER = endMarker.encoded();\n+  }\n+\n+  private final String besuVesion;\n+  private final Lock submissionLock = new ReentrantLock();\n+  private final EthScheduler scheduler;\n+  private final Blockchain blockchain;\n+  private final WorldStateStorage worldStateStorage;\n+  private final BackupStatus backupStatus = new BackupStatus();\n+\n+  private Path backupDir;\n+  private RollingFileWriter accountFileWriter;\n+\n+  public StateBackupService(\n+      final String besuVesion,\n+      final Blockchain blockchain,\n+      final Path backupDir,\n+      final EthScheduler scheduler,\n+      final WorldStateStorage worldStateStorage) {\n+    this.besuVesion = besuVesion;\n+    this.blockchain = blockchain;\n+    this.backupDir = backupDir;\n+    this.scheduler = scheduler;\n+    this.worldStateStorage = worldStateStorage;\n+  }\n+\n+  public Path getBackupDir() {\n+    return backupDir;\n+  }\n+\n+  public BackupStatus requestBackup(\n+      final long block, final boolean compress, final Optional<Path> backupDir) {\n+    boolean requestAccepted = false;\n+    try {\n+      if (submissionLock.tryLock(100, TimeUnit.MILLISECONDS)) {\n+        try {\n+          if (!backupStatus.isBackingUp()) {\n+            requestAccepted = true;\n+            this.backupDir = backupDir.orElse(this.backupDir);\n+            backupStatus.targetBlock = block;\n+            backupStatus.compressed = compress;\n+            backupStatus.currentAccount = Bytes32.ZERO;\n+            scheduler.scheduleComputationTask(\n+                () -> {\n+                  try {\n+                    return backup(block, compress);\n+\n+                  } catch (final IOException ioe) {\n+                    LOG.error(\"Error writing backups\", ioe);\n+                    return backupStatus;\n+                  }\n+                });\n+          }\n+        } finally {\n+          submissionLock.unlock();\n+        }\n+      }\n+    } catch (final InterruptedException e) {\n+      // ignore\n+    }\n+    backupStatus.requestAccepted = requestAccepted;\n+    return backupStatus;\n+  }\n+\n+  public static Path dataFileToIndex(final Path dataName) {\n+    return Path.of(dataName.toString().replaceAll(\"(.*)[-.]\\\\d\\\\d\\\\d\\\\d\\\\.(.)dat\", \"$1.$2idx\"));\n+  }\n+\n+  public static Path accountFileName(\n+      final Path backupDir,\n+      final long targetBlock,\n+      final int fileNumber,\n+      final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\n+            \"besu-account-backup-%08d-%04d.%sdat\",\n+            targetBlock, fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path headerFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-header-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path bodyFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-body-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path receiptFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-receipt-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  private Path accountFileName(final int fileNumber, final boolean compressed) {\n+    return accountFileName(backupDir, backupStatus.targetBlock, fileNumber, compressed);\n+  }\n+\n+  private Path headerFileName(final int fileNumber, final boolean compressed) {\n+    return headerFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private Path bodyFileName(final int fileNumber, final boolean compressed) {\n+    return bodyFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private Path receiptFileName(final int fileNumber, final boolean compressed) {\n+    return receiptFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private BackupStatus backup(final long block, final boolean compress) throws IOException {\n+    try {\n+      checkArgument(\n+          block >= 0 && block <= blockchain.getChainHeadBlockNumber(),\n+          \"Backup Block must be within blockchain\");\n+      backupStatus.targetBlock = block;\n+      backupStatus.compressed = compress;\n+      backupStatus.currentAccount = Bytes32.ZERO;\n+\n+      backupChaindata();\n+      backupLeaves();\n+\n+      writeManifest();\n+\n+      return backupStatus;\n+    } catch (final Throwable t) {\n+      LOG.error(\"Unexpected error\", t);\n+      throw t;\n+    }\n+  }\n+\n+  private void writeManifest() throws IOException {\n+    final Map<String, Object> manifest = new HashMap<>();\n+    manifest.put(\"clientVersion\", besuVesion);\n+    manifest.put(\"compressed\", backupStatus.compressed);\n+    manifest.put(\"targetBlock\", backupStatus.targetBlock);\n+    manifest.put(\"accountCount\", backupStatus.accountCount);\n+\n+    Files.write(\n+        backupDir.resolve(\"besu-backup-manifest.json\"),\n+        JsonUtil.getJson(manifest).getBytes(StandardCharsets.UTF_8));\n+  }\n+\n+  private void backupLeaves() throws IOException {\n+    final Optional<BlockHeader> header = blockchain.getBlockHeader(backupStatus.targetBlock);\n+    if (header.isEmpty()) {\n+      backupStatus.currentAccount = null;\n+      return;\n+    }\n+    final Optional<Bytes> worldStateRoot =\n+        worldStateStorage.getAccountStateTrieNode(header.get().getStateRoot());\n+    if (worldStateRoot.isEmpty()) {\n+      backupStatus.currentAccount = null;\n+      return;\n+    }\n+\n+    try (final RollingFileWriter accountFileWriter =\n+        new RollingFileWriter(this::accountFileName, backupStatus.compressed)) {\n+      this.accountFileWriter = accountFileWriter;\n+\n+      final StoredMerklePatriciaTrie<Bytes32, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              worldStateStorage::getAccountStateTrieNode,\n+              header.get().getStateRoot(),\n+              Function.identity(),\n+              Function.identity());\n+\n+      accountTrie.visitLeafs(this::visitAccount);\n+      backupStatus.currentAccount = null;\n+    }\n+  }\n+\n+  private TrieIterator.State visitAccount(final Bytes32 nodeKey, final Node<Bytes> node) {\n+    if (node.getValue().isEmpty()) {\n+      return State.CONTINUE;\n+    }\n+\n+    backupStatus.currentAccount = nodeKey;\n+    final Bytes nodeValue = node.getValue().orElse(Hash.EMPTY);\n+    final StateTrieAccountValue account =\n+        StateTrieAccountValue.readFrom(new BytesValueRLPInput(nodeValue, false));\n+\n+    final Bytes code = worldStateStorage.getCode(account.getCodeHash()).orElse(Bytes.EMPTY);\n+    backupStatus.codeSize.addAndGet(code.size());\n+\n+    final BytesValueRLPOutput accountOutput = new BytesValueRLPOutput();\n+    accountOutput.startList();\n+    accountOutput.writeBytes(nodeKey); // trie hash\n+    accountOutput.writeBytes(nodeValue); // account rlp\n+    accountOutput.writeBytes(code); // code\n+    accountOutput.endList();\n+\n+    try {\n+      accountFileWriter.writeBytes(accountOutput.encoded().toArrayUnsafe());\n+    } catch (final IOException ioe) {\n+      LOG.error(\"Failure writing backup\", ioe);\n+      return State.STOP;\n+    }\n+\n+    // storage is written for each leaf, otherwise the whole trie would have to fit in memory\n+    final StoredMerklePatriciaTrie<Bytes32, Bytes> storageTrie =\n+        new StoredMerklePatriciaTrie<>(\n+            worldStateStorage::getAccountStateTrieNode,\n+            account.getStorageRoot(),\n+            Function.identity(),\n+            Function.identity());\n+    storageTrie.visitLeafs(\n+        (storageKey, storageValue) ->\n+            visitAccountStorage(storageKey, storageValue, accountFileWriter));\n+\n+    try {\n+      accountFileWriter.writeBytes(ACCOUNT_END_MARKER.toArrayUnsafe());\n+    } catch (final IOException ioe) {\n+      LOG.error(\"Failure writing backup\", ioe);\n+      return State.STOP;\n+    }\n+\n+    backupStatus.accountCount.incrementAndGet();\n+    return State.CONTINUE;\n+  }\n+\n+  private void backupChaindata() throws IOException {\n+    try (final RollingFileWriter headerWriter =\n+            new RollingFileWriter(this::headerFileName, backupStatus.compressed);\n+        final RollingFileWriter bodyWriter =\n+            new RollingFileWriter(this::bodyFileName, backupStatus.compressed);\n+        final RollingFileWriter receiptsWriter =\n+            new RollingFileWriter(this::receiptFileName, backupStatus.compressed)) {\n+      for (int blockNumber = 0; blockNumber <= backupStatus.targetBlock; blockNumber++) {\n+        final Optional<Block> block = blockchain.getBlockByNumber(blockNumber);\n+        if (block.isEmpty()) {\n+          throw new IllegalStateException(\n+              \"Block data for \" + blockNumber + \" was not found in the archive\");\n+        }\n+        final Optional<List<TransactionReceipt>> receipts =\n+            blockchain.getTxReceipts(block.get().getHash());\n+        if (receipts.isEmpty()) {\n+          throw new IllegalStateException(\n+              \"Receipts for \" + blockNumber + \" was not found in the archive\");\n+        }", "originalCommit": "536dcfcaa84dfa034723ec94a591bf5f90ae50ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwNDM0Mw==", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r467304343", "bodyText": "It will return an optional of an empty list if the block header exists and there are no transacitons.  If the block doesn't exist we get an empty optional.", "author": "shemnon", "createdAt": "2020-08-07T22:01:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0NjczNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxMTk4Mg==", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r467211982", "bodyText": "I'm kinda confused about what this does.\nAlso, won't isBackingUp return false when we're backing up the leaves?", "author": "RatanRSur", "createdAt": "2020-08-07T18:49:11Z", "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/query/StateBackupService.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.api.query;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import org.hyperledger.besu.config.JsonUtil;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.TransactionReceipt;\n+import org.hyperledger.besu.ethereum.eth.manager.EthScheduler;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.Node;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.TrieIterator;\n+import org.hyperledger.besu.ethereum.trie.TrieIterator.State;\n+import org.hyperledger.besu.ethereum.worldstate.StateTrieAccountValue;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateStorage;\n+import org.hyperledger.besu.plugin.data.Hash;\n+\n+import java.io.Closeable;\n+import java.io.DataOutputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import com.fasterxml.jackson.annotation.JsonGetter;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.xerial.snappy.Snappy;\n+\n+public class StateBackupService {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final long MAX_FILE_SIZE = 1 << 28; // 256 MiB max file size\n+  private static final Bytes ACCOUNT_END_MARKER;\n+\n+  static {\n+    final BytesValueRLPOutput endMarker = new BytesValueRLPOutput();\n+    endMarker.startList();\n+    endMarker.endList();\n+    ACCOUNT_END_MARKER = endMarker.encoded();\n+  }\n+\n+  private final String besuVesion;\n+  private final Lock submissionLock = new ReentrantLock();\n+  private final EthScheduler scheduler;\n+  private final Blockchain blockchain;\n+  private final WorldStateStorage worldStateStorage;\n+  private final BackupStatus backupStatus = new BackupStatus();\n+\n+  private Path backupDir;\n+  private RollingFileWriter accountFileWriter;\n+\n+  public StateBackupService(\n+      final String besuVesion,\n+      final Blockchain blockchain,\n+      final Path backupDir,\n+      final EthScheduler scheduler,\n+      final WorldStateStorage worldStateStorage) {\n+    this.besuVesion = besuVesion;\n+    this.blockchain = blockchain;\n+    this.backupDir = backupDir;\n+    this.scheduler = scheduler;\n+    this.worldStateStorage = worldStateStorage;\n+  }\n+\n+  public Path getBackupDir() {\n+    return backupDir;\n+  }\n+\n+  public BackupStatus requestBackup(\n+      final long block, final boolean compress, final Optional<Path> backupDir) {\n+    boolean requestAccepted = false;\n+    try {\n+      if (submissionLock.tryLock(100, TimeUnit.MILLISECONDS)) {\n+        try {\n+          if (!backupStatus.isBackingUp()) {\n+            requestAccepted = true;\n+            this.backupDir = backupDir.orElse(this.backupDir);\n+            backupStatus.targetBlock = block;\n+            backupStatus.compressed = compress;\n+            backupStatus.currentAccount = Bytes32.ZERO;\n+            scheduler.scheduleComputationTask(\n+                () -> {\n+                  try {\n+                    return backup(block, compress);\n+\n+                  } catch (final IOException ioe) {\n+                    LOG.error(\"Error writing backups\", ioe);\n+                    return backupStatus;\n+                  }\n+                });\n+          }\n+        } finally {\n+          submissionLock.unlock();\n+        }\n+      }\n+    } catch (final InterruptedException e) {\n+      // ignore\n+    }\n+    backupStatus.requestAccepted = requestAccepted;\n+    return backupStatus;\n+  }\n+\n+  public static Path dataFileToIndex(final Path dataName) {\n+    return Path.of(dataName.toString().replaceAll(\"(.*)[-.]\\\\d\\\\d\\\\d\\\\d\\\\.(.)dat\", \"$1.$2idx\"));\n+  }\n+\n+  public static Path accountFileName(\n+      final Path backupDir,\n+      final long targetBlock,\n+      final int fileNumber,\n+      final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\n+            \"besu-account-backup-%08d-%04d.%sdat\",\n+            targetBlock, fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path headerFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-header-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path bodyFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-body-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path receiptFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-receipt-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  private Path accountFileName(final int fileNumber, final boolean compressed) {\n+    return accountFileName(backupDir, backupStatus.targetBlock, fileNumber, compressed);\n+  }\n+\n+  private Path headerFileName(final int fileNumber, final boolean compressed) {\n+    return headerFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private Path bodyFileName(final int fileNumber, final boolean compressed) {\n+    return bodyFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private Path receiptFileName(final int fileNumber, final boolean compressed) {\n+    return receiptFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private BackupStatus backup(final long block, final boolean compress) throws IOException {\n+    try {\n+      checkArgument(\n+          block >= 0 && block <= blockchain.getChainHeadBlockNumber(),\n+          \"Backup Block must be within blockchain\");\n+      backupStatus.targetBlock = block;\n+      backupStatus.compressed = compress;\n+      backupStatus.currentAccount = Bytes32.ZERO;\n+\n+      backupChaindata();\n+      backupLeaves();\n+\n+      writeManifest();\n+\n+      return backupStatus;\n+    } catch (final Throwable t) {\n+      LOG.error(\"Unexpected error\", t);\n+      throw t;\n+    }\n+  }\n+\n+  private void writeManifest() throws IOException {\n+    final Map<String, Object> manifest = new HashMap<>();\n+    manifest.put(\"clientVersion\", besuVesion);\n+    manifest.put(\"compressed\", backupStatus.compressed);\n+    manifest.put(\"targetBlock\", backupStatus.targetBlock);\n+    manifest.put(\"accountCount\", backupStatus.accountCount);\n+\n+    Files.write(\n+        backupDir.resolve(\"besu-backup-manifest.json\"),\n+        JsonUtil.getJson(manifest).getBytes(StandardCharsets.UTF_8));\n+  }\n+\n+  private void backupLeaves() throws IOException {\n+    final Optional<BlockHeader> header = blockchain.getBlockHeader(backupStatus.targetBlock);\n+    if (header.isEmpty()) {\n+      backupStatus.currentAccount = null;\n+      return;\n+    }\n+    final Optional<Bytes> worldStateRoot =\n+        worldStateStorage.getAccountStateTrieNode(header.get().getStateRoot());\n+    if (worldStateRoot.isEmpty()) {\n+      backupStatus.currentAccount = null;\n+      return;\n+    }", "originalCommit": "536dcfcaa84dfa034723ec94a591bf5f90ae50ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyODk4Ng==", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r467328986", "bodyText": "Edge case for where there is world state.  currentAccount starts at zero, and when it is done it gets set to null.  It is at zero while blocks are being written.", "author": "shemnon", "createdAt": "2020-08-07T23:41:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxMTk4Mg=="}], "type": "inlineReview"}, {"oid": "6fe5c09a3d70e18f3d2d8c91be2ef811c60a16be", "url": "https://github.com/hyperledger/besu/commit/6fe5c09a3d70e18f3d2d8c91be2ef811c60a16be", "message": "checkState\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-08-07T23:42:12Z", "type": "commit"}, {"oid": "04f51bcdc0dbe64ac7938f8829544a8bcd41677b", "url": "https://github.com/hyperledger/besu/commit/04f51bcdc0dbe64ac7938f8829544a8bcd41677b", "message": "Merge branch 'master' into backupGenerate", "committedDate": "2020-08-10T20:59:09Z", "type": "commit"}, {"oid": "5cb3c5ea15b37149fb180a7efd787948e4ad0053", "url": "https://github.com/hyperledger/besu/commit/5cb3c5ea15b37149fb180a7efd787948e4ad0053", "message": "changelog\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-08-10T21:09:41Z", "type": "commit"}, {"oid": "8617430a60f8e46468b9a1785cd60063ebfdc101", "url": "https://github.com/hyperledger/besu/commit/8617430a60f8e46468b9a1785cd60063ebfdc101", "message": "a word\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-08-10T21:10:28Z", "type": "commit"}]}