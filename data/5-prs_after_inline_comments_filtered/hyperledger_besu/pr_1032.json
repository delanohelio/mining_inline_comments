{"pr_number": 1032, "pr_title": "Initial support for multi-tenancy with flexible privacy groups", "pr_createdAt": "2020-06-03T02:26:50Z", "pr_url": "https://github.com/hyperledger/besu/pull/1032", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4NTExNA==", "url": "https://github.com/hyperledger/besu/pull/1032#discussion_r435685114", "bodyText": "I'm not sure I really understand why you need these two constructors here ...\nI think you either make all the possible information available that could be available, or you remove this constructor.", "author": "pinges", "createdAt": "2020-06-05T04:35:41Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/ExecutedPrivateTransaction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy;\n+\n+import org.hyperledger.besu.ethereum.chain.TransactionLocation;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.Transaction;\n+\n+import java.util.Objects;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * This class represents a private transaction that has been executed. Therefore, it contains the\n+ * original private transaction data plus information about the associated PMT and its block.\n+ */\n+public class ExecutedPrivateTransaction extends PrivateTransaction {\n+\n+  private final Hash blockHash;\n+  private final long blockNumber;\n+  private final Hash pmtHash;\n+  private final int pmtIndex;\n+  private final String internalPrivacyGroup;\n+\n+  ExecutedPrivateTransaction(", "originalCommit": "76aeba9d9a4fb75f6152f26675bba3880d66fc62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEzNDI2Mw==", "url": "https://github.com/hyperledger/besu/pull/1032#discussion_r437134263", "bodyText": "I'll remove it.", "author": "lucassaldanha", "createdAt": "2020-06-09T04:43:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4NTExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4NTUzNw==", "url": "https://github.com/hyperledger/besu/pull/1032#discussion_r435685537", "bodyText": "do we really need the equal?", "author": "pinges", "createdAt": "2020-06-05T04:37:41Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/ExecutedPrivateTransaction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy;\n+\n+import org.hyperledger.besu.ethereum.chain.TransactionLocation;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.Transaction;\n+\n+import java.util.Objects;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * This class represents a private transaction that has been executed. Therefore, it contains the\n+ * original private transaction data plus information about the associated PMT and its block.\n+ */\n+public class ExecutedPrivateTransaction extends PrivateTransaction {\n+\n+  private final Hash blockHash;\n+  private final long blockNumber;\n+  private final Hash pmtHash;\n+  private final int pmtIndex;\n+  private final String internalPrivacyGroup;\n+\n+  ExecutedPrivateTransaction(\n+      final BlockHeader blockHeader,\n+      final Transaction pmt,\n+      final TransactionLocation pmtLocation,\n+      final String internalPrivacyGroup,\n+      final PrivateTransaction privateTransaction) {\n+    this(\n+        blockHeader.getHash(),\n+        blockHeader.getNumber(),\n+        pmt.getHash(),\n+        pmtLocation.getTransactionIndex(),\n+        internalPrivacyGroup,\n+        privateTransaction);\n+  }\n+\n+  @VisibleForTesting\n+  public ExecutedPrivateTransaction(\n+      final Hash blockHash,\n+      final long blockNumber,\n+      final Hash pmtHash,\n+      final int pmtIndex,\n+      final String internalPrivacyGroupId,\n+      final PrivateTransaction privateTransaction) {\n+    super(privateTransaction);\n+    this.blockHash = blockHash;\n+    this.blockNumber = blockNumber;\n+    this.pmtHash = pmtHash;\n+    this.pmtIndex = pmtIndex;\n+    this.internalPrivacyGroup = internalPrivacyGroupId;\n+  }\n+\n+  public Hash getBlockHash() {\n+    return blockHash;\n+  }\n+\n+  public long getBlockNumber() {\n+    return blockNumber;\n+  }\n+\n+  public Hash getPmtHash() {\n+    return pmtHash;\n+  }\n+\n+  public int getPmtIndex() {\n+    return pmtIndex;\n+  }\n+\n+  /**\n+   * Legacy transactions don't have the privacyGroupId as part of their RLP data. The internal\n+   * privacy group id is returned from the Enclave. We are keeping it separate from the\n+   * 'getPrivacyGroup()' to differentiate legacy transactions.\n+   *\n+   * @return the privacy group id\n+   */\n+  public String getInternalPrivacyGroup() {\n+    return internalPrivacyGroup;\n+  }\n+\n+  @Override\n+  public boolean equals(final Object o) {", "originalCommit": "76aeba9d9a4fb75f6152f26675bba3880d66fc62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEzNDIxNg==", "url": "https://github.com/hyperledger/besu/pull/1032#discussion_r437134216", "bodyText": "Probably not. I'll remove.", "author": "lucassaldanha", "createdAt": "2020-06-09T04:43:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4NTUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4NTYzNw==", "url": "https://github.com/hyperledger/besu/pull/1032#discussion_r435685637", "bodyText": "do we really need the hashCode?", "author": "pinges", "createdAt": "2020-06-05T04:38:04Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/ExecutedPrivateTransaction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy;\n+\n+import org.hyperledger.besu.ethereum.chain.TransactionLocation;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.Transaction;\n+\n+import java.util.Objects;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * This class represents a private transaction that has been executed. Therefore, it contains the\n+ * original private transaction data plus information about the associated PMT and its block.\n+ */\n+public class ExecutedPrivateTransaction extends PrivateTransaction {\n+\n+  private final Hash blockHash;\n+  private final long blockNumber;\n+  private final Hash pmtHash;\n+  private final int pmtIndex;\n+  private final String internalPrivacyGroup;\n+\n+  ExecutedPrivateTransaction(\n+      final BlockHeader blockHeader,\n+      final Transaction pmt,\n+      final TransactionLocation pmtLocation,\n+      final String internalPrivacyGroup,\n+      final PrivateTransaction privateTransaction) {\n+    this(\n+        blockHeader.getHash(),\n+        blockHeader.getNumber(),\n+        pmt.getHash(),\n+        pmtLocation.getTransactionIndex(),\n+        internalPrivacyGroup,\n+        privateTransaction);\n+  }\n+\n+  @VisibleForTesting\n+  public ExecutedPrivateTransaction(\n+      final Hash blockHash,\n+      final long blockNumber,\n+      final Hash pmtHash,\n+      final int pmtIndex,\n+      final String internalPrivacyGroupId,\n+      final PrivateTransaction privateTransaction) {\n+    super(privateTransaction);\n+    this.blockHash = blockHash;\n+    this.blockNumber = blockNumber;\n+    this.pmtHash = pmtHash;\n+    this.pmtIndex = pmtIndex;\n+    this.internalPrivacyGroup = internalPrivacyGroupId;\n+  }\n+\n+  public Hash getBlockHash() {\n+    return blockHash;\n+  }\n+\n+  public long getBlockNumber() {\n+    return blockNumber;\n+  }\n+\n+  public Hash getPmtHash() {\n+    return pmtHash;\n+  }\n+\n+  public int getPmtIndex() {\n+    return pmtIndex;\n+  }\n+\n+  /**\n+   * Legacy transactions don't have the privacyGroupId as part of their RLP data. The internal\n+   * privacy group id is returned from the Enclave. We are keeping it separate from the\n+   * 'getPrivacyGroup()' to differentiate legacy transactions.\n+   *\n+   * @return the privacy group id\n+   */\n+  public String getInternalPrivacyGroup() {\n+    return internalPrivacyGroup;\n+  }\n+\n+  @Override\n+  public boolean equals(final Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    if (!super.equals(o)) {\n+      return false;\n+    }\n+\n+    final ExecutedPrivateTransaction that = (ExecutedPrivateTransaction) o;\n+\n+    return blockNumber == that.blockNumber\n+        && pmtIndex == that.pmtIndex\n+        && blockHash.equals(that.blockHash)\n+        && pmtHash.equals(that.pmtHash)\n+        && internalPrivacyGroup.equals((that.internalPrivacyGroup));\n+  }\n+\n+  @Override\n+  public int hashCode() {", "originalCommit": "76aeba9d9a4fb75f6152f26675bba3880d66fc62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEzNDIzMQ==", "url": "https://github.com/hyperledger/besu/pull/1032#discussion_r437134231", "bodyText": "Probably not. I'll remove.", "author": "lucassaldanha", "createdAt": "2020-06-09T04:43:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4NTYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4NjM1Nw==", "url": "https://github.com/hyperledger/besu/pull/1032#discussion_r435686357", "bodyText": "Don't know whether we need this comment...", "author": "pinges", "createdAt": "2020-06-05T04:41:34Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivateTransactionLocator.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.apache.logging.log4j.LogManager.getLogger;\n+\n+import org.hyperledger.besu.enclave.Enclave;\n+import org.hyperledger.besu.enclave.EnclaveClientException;\n+import org.hyperledger.besu.enclave.types.ReceiveResponse;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.chain.TransactionLocation;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.Transaction;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLPException;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class PrivateTransactionLocator {\n+\n+  private static final Logger LOG = getLogger();\n+\n+  private final Blockchain blockchain;\n+  private final Enclave enclave;\n+  private final PrivateStateStorage privateStateStorage;\n+\n+  public PrivateTransactionLocator(\n+      final Blockchain blockchain,\n+      final Enclave enclave,\n+      final PrivateStateStorage privateStateStorage) {\n+    this.blockchain = blockchain;\n+    this.enclave = enclave;\n+    this.privateStateStorage = privateStateStorage;\n+  }\n+\n+  /**\n+   * Returns a private transaction with extra data (block and pmt information). The private\n+   * transaction is retrieved from the Enclave, either as a single transaction or from an existing\n+   * \"blob\".<br>\n+   * In both cases, we are passing the enclaveKey (public key of the participant) down to the\n+   * Enclave, with the expectation that the Enclave will only return the payload if the matching\n+   * private key of the enclaveKey passed as a parameter is able to be used to decrypt the payload.\n+   *\n+   * <p>This enclaveKey \"validation\" in the Enclave makes retrieving a payload multi-tenancy safe.\n+   *\n+   * @param pmtHash the hash of the PMT associated with the private transaction\n+   * @param enclaveKey participant public key that must match the private key used to decrypt the\n+   *     payload\n+   * @return An executed private transaction\n+   */\n+  public Optional<ExecutedPrivateTransaction> findByPmtHash(\n+      final Hash pmtHash, final String enclaveKey) {\n+    final Optional<TransactionLocation> maybePmtLocation =\n+        blockchain.getTransactionLocation(pmtHash);\n+    if (maybePmtLocation.isEmpty()) {\n+      return Optional.empty();\n+    }\n+\n+    /*\n+     If tx location isn't empty it is safe to assume that the block header and transaction exist.", "originalCommit": "76aeba9d9a4fb75f6152f26675bba3880d66fc62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4NzQ1OQ==", "url": "https://github.com/hyperledger/besu/pull/1032#discussion_r435687459", "bodyText": "nit: final", "author": "pinges", "createdAt": "2020-06-05T04:46:38Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivateTransactionLocator.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.apache.logging.log4j.LogManager.getLogger;\n+\n+import org.hyperledger.besu.enclave.Enclave;\n+import org.hyperledger.besu.enclave.EnclaveClientException;\n+import org.hyperledger.besu.enclave.types.ReceiveResponse;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.chain.TransactionLocation;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.Transaction;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLPException;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class PrivateTransactionLocator {\n+\n+  private static final Logger LOG = getLogger();\n+\n+  private final Blockchain blockchain;\n+  private final Enclave enclave;\n+  private final PrivateStateStorage privateStateStorage;\n+\n+  public PrivateTransactionLocator(\n+      final Blockchain blockchain,\n+      final Enclave enclave,\n+      final PrivateStateStorage privateStateStorage) {\n+    this.blockchain = blockchain;\n+    this.enclave = enclave;\n+    this.privateStateStorage = privateStateStorage;\n+  }\n+\n+  /**\n+   * Returns a private transaction with extra data (block and pmt information). The private\n+   * transaction is retrieved from the Enclave, either as a single transaction or from an existing\n+   * \"blob\".<br>\n+   * In both cases, we are passing the enclaveKey (public key of the participant) down to the\n+   * Enclave, with the expectation that the Enclave will only return the payload if the matching\n+   * private key of the enclaveKey passed as a parameter is able to be used to decrypt the payload.\n+   *\n+   * <p>This enclaveKey \"validation\" in the Enclave makes retrieving a payload multi-tenancy safe.\n+   *\n+   * @param pmtHash the hash of the PMT associated with the private transaction\n+   * @param enclaveKey participant public key that must match the private key used to decrypt the\n+   *     payload\n+   * @return An executed private transaction\n+   */\n+  public Optional<ExecutedPrivateTransaction> findByPmtHash(\n+      final Hash pmtHash, final String enclaveKey) {\n+    final Optional<TransactionLocation> maybePmtLocation =\n+        blockchain.getTransactionLocation(pmtHash);\n+    if (maybePmtLocation.isEmpty()) {\n+      return Optional.empty();\n+    }\n+\n+    /*\n+     If tx location isn't empty it is safe to assume that the block header and transaction exist.\n+     Therefore, using orElseThrow here makes sense\n+    */\n+    final TransactionLocation pmtLocation = maybePmtLocation.get();\n+    final Transaction pmt = blockchain.getTransactionByHash(pmtHash).orElseThrow();\n+    final BlockHeader blockHeader =\n+        blockchain.getBlockHeader(pmtLocation.getBlockHash()).orElseThrow();\n+    final String payloadKey = readPayloadKeyFromPmt(pmt);\n+\n+    return tryFetchingPrivateTransactionFromEnclave(payloadKey, enclaveKey)\n+        .or(() -> tryFetchingTransactionFromAddBlob(blockHeader.getHash(), pmtHash, enclaveKey))\n+        .map(\n+            tx ->\n+                new ExecutedPrivateTransaction(\n+                    blockHeader,\n+                    pmt,\n+                    pmtLocation,\n+                    tx.getExternalPrivacyGroupId(),\n+                    tx.getPrivateTransaction()));\n+  }\n+\n+  private String readPayloadKeyFromPmt(final Transaction privacyMarkerTx) {\n+    return privacyMarkerTx.getPayload().slice(0, 32).toBase64String();\n+  }\n+\n+  /**\n+   * Retrieves a single private transaction from the Enclave\n+   *\n+   * @param payloadKey unique key identifying the payload\n+   * @param enclaveKey participant public key that must match the private key used to decrypt the\n+   *     payload\n+   * @return an optional containing the private transaction, if found. Or an empty optional if the\n+   *     private transaction couldnt' be found.\n+   */\n+  private Optional<TransactionFromEnclave> tryFetchingPrivateTransactionFromEnclave(\n+      final String payloadKey, final String enclaveKey) {\n+    return retrievePayloadFromEnclave(payloadKey, enclaveKey)\n+        .map(this::readPrivateTransactionFromPayload);\n+  }\n+\n+  private Optional<ReceiveResponse> retrievePayloadFromEnclave(\n+      final String payloadKey, final String enclaveKey) {\n+    try {\n+      return Optional.of(enclave.receive(payloadKey, enclaveKey));\n+    } catch (final EnclaveClientException e) {\n+      // Enclave throws an exception with a 404 status code if the payload isn't found\n+      if (e.getStatusCode() == 404) {\n+        return Optional.empty();\n+      } else {\n+        throw e;\n+      }\n+    }\n+  }\n+\n+  private TransactionFromEnclave readPrivateTransactionFromPayload(\n+      final ReceiveResponse receiveResponse) {\n+    final PrivateTransaction privateTransaction;\n+    final BytesValueRLPInput input =\n+        new BytesValueRLPInput(\n+            Bytes.fromBase64String(new String(receiveResponse.getPayload(), UTF_8)), false);\n+\n+    /*\n+     When using on-chain privacy groups, the payload is a list with the first element being the\n+     private transaction RLP and the second element being the version. This is why we have the\n+     nextIsList() check.\n+    */\n+    try {\n+      input.enterList();\n+      if (input.nextIsList()) {\n+        // private transaction and version (we only read the first element in the list)\n+        privateTransaction = PrivateTransaction.readFrom(input);\n+        input.leaveListLenient();\n+      } else {\n+        // private transaction only (read the whole RLP)\n+        input.reset();\n+        privateTransaction = PrivateTransaction.readFrom(input);\n+      }\n+    } catch (RLPException e) {", "originalCommit": "76aeba9d9a4fb75f6152f26675bba3880d66fc62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MTQ1MQ==", "url": "https://github.com/hyperledger/besu/pull/1032#discussion_r435691451", "bodyText": "This should not be empty if we have found the addDataKey. We should at least log a warning ... ?", "author": "pinges", "createdAt": "2020-06-05T05:03:44Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivateTransactionLocator.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.apache.logging.log4j.LogManager.getLogger;\n+\n+import org.hyperledger.besu.enclave.Enclave;\n+import org.hyperledger.besu.enclave.EnclaveClientException;\n+import org.hyperledger.besu.enclave.types.ReceiveResponse;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.chain.TransactionLocation;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.Transaction;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLPException;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class PrivateTransactionLocator {\n+\n+  private static final Logger LOG = getLogger();\n+\n+  private final Blockchain blockchain;\n+  private final Enclave enclave;\n+  private final PrivateStateStorage privateStateStorage;\n+\n+  public PrivateTransactionLocator(\n+      final Blockchain blockchain,\n+      final Enclave enclave,\n+      final PrivateStateStorage privateStateStorage) {\n+    this.blockchain = blockchain;\n+    this.enclave = enclave;\n+    this.privateStateStorage = privateStateStorage;\n+  }\n+\n+  /**\n+   * Returns a private transaction with extra data (block and pmt information). The private\n+   * transaction is retrieved from the Enclave, either as a single transaction or from an existing\n+   * \"blob\".<br>\n+   * In both cases, we are passing the enclaveKey (public key of the participant) down to the\n+   * Enclave, with the expectation that the Enclave will only return the payload if the matching\n+   * private key of the enclaveKey passed as a parameter is able to be used to decrypt the payload.\n+   *\n+   * <p>This enclaveKey \"validation\" in the Enclave makes retrieving a payload multi-tenancy safe.\n+   *\n+   * @param pmtHash the hash of the PMT associated with the private transaction\n+   * @param enclaveKey participant public key that must match the private key used to decrypt the\n+   *     payload\n+   * @return An executed private transaction\n+   */\n+  public Optional<ExecutedPrivateTransaction> findByPmtHash(\n+      final Hash pmtHash, final String enclaveKey) {\n+    final Optional<TransactionLocation> maybePmtLocation =\n+        blockchain.getTransactionLocation(pmtHash);\n+    if (maybePmtLocation.isEmpty()) {\n+      return Optional.empty();\n+    }\n+\n+    /*\n+     If tx location isn't empty it is safe to assume that the block header and transaction exist.\n+     Therefore, using orElseThrow here makes sense\n+    */\n+    final TransactionLocation pmtLocation = maybePmtLocation.get();\n+    final Transaction pmt = blockchain.getTransactionByHash(pmtHash).orElseThrow();\n+    final BlockHeader blockHeader =\n+        blockchain.getBlockHeader(pmtLocation.getBlockHash()).orElseThrow();\n+    final String payloadKey = readPayloadKeyFromPmt(pmt);\n+\n+    return tryFetchingPrivateTransactionFromEnclave(payloadKey, enclaveKey)\n+        .or(() -> tryFetchingTransactionFromAddBlob(blockHeader.getHash(), pmtHash, enclaveKey))\n+        .map(\n+            tx ->\n+                new ExecutedPrivateTransaction(\n+                    blockHeader,\n+                    pmt,\n+                    pmtLocation,\n+                    tx.getExternalPrivacyGroupId(),\n+                    tx.getPrivateTransaction()));\n+  }\n+\n+  private String readPayloadKeyFromPmt(final Transaction privacyMarkerTx) {\n+    return privacyMarkerTx.getPayload().slice(0, 32).toBase64String();\n+  }\n+\n+  /**\n+   * Retrieves a single private transaction from the Enclave\n+   *\n+   * @param payloadKey unique key identifying the payload\n+   * @param enclaveKey participant public key that must match the private key used to decrypt the\n+   *     payload\n+   * @return an optional containing the private transaction, if found. Or an empty optional if the\n+   *     private transaction couldnt' be found.\n+   */\n+  private Optional<TransactionFromEnclave> tryFetchingPrivateTransactionFromEnclave(\n+      final String payloadKey, final String enclaveKey) {\n+    return retrievePayloadFromEnclave(payloadKey, enclaveKey)\n+        .map(this::readPrivateTransactionFromPayload);\n+  }\n+\n+  private Optional<ReceiveResponse> retrievePayloadFromEnclave(\n+      final String payloadKey, final String enclaveKey) {\n+    try {\n+      return Optional.of(enclave.receive(payloadKey, enclaveKey));\n+    } catch (final EnclaveClientException e) {\n+      // Enclave throws an exception with a 404 status code if the payload isn't found\n+      if (e.getStatusCode() == 404) {\n+        return Optional.empty();\n+      } else {\n+        throw e;\n+      }\n+    }\n+  }\n+\n+  private TransactionFromEnclave readPrivateTransactionFromPayload(\n+      final ReceiveResponse receiveResponse) {\n+    final PrivateTransaction privateTransaction;\n+    final BytesValueRLPInput input =\n+        new BytesValueRLPInput(\n+            Bytes.fromBase64String(new String(receiveResponse.getPayload(), UTF_8)), false);\n+\n+    /*\n+     When using on-chain privacy groups, the payload is a list with the first element being the\n+     private transaction RLP and the second element being the version. This is why we have the\n+     nextIsList() check.\n+    */\n+    try {\n+      input.enterList();\n+      if (input.nextIsList()) {\n+        // private transaction and version (we only read the first element in the list)\n+        privateTransaction = PrivateTransaction.readFrom(input);\n+        input.leaveListLenient();\n+      } else {\n+        // private transaction only (read the whole RLP)\n+        input.reset();\n+        privateTransaction = PrivateTransaction.readFrom(input);\n+      }\n+    } catch (RLPException e) {\n+      LOG.debug(\"Error de-serializing private transaction from enclave\", e);\n+      throw e;\n+    }\n+\n+    return new TransactionFromEnclave(privateTransaction, receiveResponse.getPrivacyGroupId());\n+  }\n+\n+  private Optional<TransactionFromEnclave> tryFetchingTransactionFromAddBlob(\n+      final Bytes32 blockHash, final Hash expectedPmtHash, final String enclaveKey) {\n+    LOG.trace(\"Fetching transaction information from add blob\");\n+\n+    final Optional<PrivacyGroupHeadBlockMap> privacyGroupHeadBlockMapOptional =\n+        privateStateStorage.getPrivacyGroupHeadBlockMap(blockHash);\n+\n+    if (privacyGroupHeadBlockMapOptional.isPresent()) {\n+      final Set<Bytes32> mappedPrivacyGroupIds = privacyGroupHeadBlockMapOptional.get().keySet();\n+\n+      for (final Bytes32 privacyGroupId : mappedPrivacyGroupIds) {\n+        final Optional<Bytes32> addDataKey = privateStateStorage.getAddDataKey(privacyGroupId);\n+\n+        if (addDataKey.isPresent()) {\n+          final Optional<ReceiveResponse> receiveResponse =\n+              retrievePayloadFromEnclave(addDataKey.get().toBase64String(), enclaveKey);\n+          if (receiveResponse.isEmpty()) {", "originalCommit": "76aeba9d9a4fb75f6152f26675bba3880d66fc62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MjQyMw==", "url": "https://github.com/hyperledger/besu/pull/1032#discussion_r435692423", "bodyText": "We should think about adding the privacy group information to the PMT so we do not have to go through all the groups here. Having that info in the PMT has other benefits as well.", "author": "pinges", "createdAt": "2020-06-05T05:07:41Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivateTransactionLocator.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.apache.logging.log4j.LogManager.getLogger;\n+\n+import org.hyperledger.besu.enclave.Enclave;\n+import org.hyperledger.besu.enclave.EnclaveClientException;\n+import org.hyperledger.besu.enclave.types.ReceiveResponse;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.chain.TransactionLocation;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.Transaction;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLPException;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class PrivateTransactionLocator {\n+\n+  private static final Logger LOG = getLogger();\n+\n+  private final Blockchain blockchain;\n+  private final Enclave enclave;\n+  private final PrivateStateStorage privateStateStorage;\n+\n+  public PrivateTransactionLocator(\n+      final Blockchain blockchain,\n+      final Enclave enclave,\n+      final PrivateStateStorage privateStateStorage) {\n+    this.blockchain = blockchain;\n+    this.enclave = enclave;\n+    this.privateStateStorage = privateStateStorage;\n+  }\n+\n+  /**\n+   * Returns a private transaction with extra data (block and pmt information). The private\n+   * transaction is retrieved from the Enclave, either as a single transaction or from an existing\n+   * \"blob\".<br>\n+   * In both cases, we are passing the enclaveKey (public key of the participant) down to the\n+   * Enclave, with the expectation that the Enclave will only return the payload if the matching\n+   * private key of the enclaveKey passed as a parameter is able to be used to decrypt the payload.\n+   *\n+   * <p>This enclaveKey \"validation\" in the Enclave makes retrieving a payload multi-tenancy safe.\n+   *\n+   * @param pmtHash the hash of the PMT associated with the private transaction\n+   * @param enclaveKey participant public key that must match the private key used to decrypt the\n+   *     payload\n+   * @return An executed private transaction\n+   */\n+  public Optional<ExecutedPrivateTransaction> findByPmtHash(\n+      final Hash pmtHash, final String enclaveKey) {\n+    final Optional<TransactionLocation> maybePmtLocation =\n+        blockchain.getTransactionLocation(pmtHash);\n+    if (maybePmtLocation.isEmpty()) {\n+      return Optional.empty();\n+    }\n+\n+    /*\n+     If tx location isn't empty it is safe to assume that the block header and transaction exist.\n+     Therefore, using orElseThrow here makes sense\n+    */\n+    final TransactionLocation pmtLocation = maybePmtLocation.get();\n+    final Transaction pmt = blockchain.getTransactionByHash(pmtHash).orElseThrow();\n+    final BlockHeader blockHeader =\n+        blockchain.getBlockHeader(pmtLocation.getBlockHash()).orElseThrow();\n+    final String payloadKey = readPayloadKeyFromPmt(pmt);\n+\n+    return tryFetchingPrivateTransactionFromEnclave(payloadKey, enclaveKey)\n+        .or(() -> tryFetchingTransactionFromAddBlob(blockHeader.getHash(), pmtHash, enclaveKey))\n+        .map(\n+            tx ->\n+                new ExecutedPrivateTransaction(\n+                    blockHeader,\n+                    pmt,\n+                    pmtLocation,\n+                    tx.getExternalPrivacyGroupId(),\n+                    tx.getPrivateTransaction()));\n+  }\n+\n+  private String readPayloadKeyFromPmt(final Transaction privacyMarkerTx) {\n+    return privacyMarkerTx.getPayload().slice(0, 32).toBase64String();\n+  }\n+\n+  /**\n+   * Retrieves a single private transaction from the Enclave\n+   *\n+   * @param payloadKey unique key identifying the payload\n+   * @param enclaveKey participant public key that must match the private key used to decrypt the\n+   *     payload\n+   * @return an optional containing the private transaction, if found. Or an empty optional if the\n+   *     private transaction couldnt' be found.\n+   */\n+  private Optional<TransactionFromEnclave> tryFetchingPrivateTransactionFromEnclave(\n+      final String payloadKey, final String enclaveKey) {\n+    return retrievePayloadFromEnclave(payloadKey, enclaveKey)\n+        .map(this::readPrivateTransactionFromPayload);\n+  }\n+\n+  private Optional<ReceiveResponse> retrievePayloadFromEnclave(\n+      final String payloadKey, final String enclaveKey) {\n+    try {\n+      return Optional.of(enclave.receive(payloadKey, enclaveKey));\n+    } catch (final EnclaveClientException e) {\n+      // Enclave throws an exception with a 404 status code if the payload isn't found\n+      if (e.getStatusCode() == 404) {\n+        return Optional.empty();\n+      } else {\n+        throw e;\n+      }\n+    }\n+  }\n+\n+  private TransactionFromEnclave readPrivateTransactionFromPayload(\n+      final ReceiveResponse receiveResponse) {\n+    final PrivateTransaction privateTransaction;\n+    final BytesValueRLPInput input =\n+        new BytesValueRLPInput(\n+            Bytes.fromBase64String(new String(receiveResponse.getPayload(), UTF_8)), false);\n+\n+    /*\n+     When using on-chain privacy groups, the payload is a list with the first element being the\n+     private transaction RLP and the second element being the version. This is why we have the\n+     nextIsList() check.\n+    */\n+    try {\n+      input.enterList();\n+      if (input.nextIsList()) {\n+        // private transaction and version (we only read the first element in the list)\n+        privateTransaction = PrivateTransaction.readFrom(input);\n+        input.leaveListLenient();\n+      } else {\n+        // private transaction only (read the whole RLP)\n+        input.reset();\n+        privateTransaction = PrivateTransaction.readFrom(input);\n+      }\n+    } catch (RLPException e) {\n+      LOG.debug(\"Error de-serializing private transaction from enclave\", e);\n+      throw e;\n+    }\n+\n+    return new TransactionFromEnclave(privateTransaction, receiveResponse.getPrivacyGroupId());\n+  }\n+\n+  private Optional<TransactionFromEnclave> tryFetchingTransactionFromAddBlob(\n+      final Bytes32 blockHash, final Hash expectedPmtHash, final String enclaveKey) {\n+    LOG.trace(\"Fetching transaction information from add blob\");\n+\n+    final Optional<PrivacyGroupHeadBlockMap> privacyGroupHeadBlockMapOptional =\n+        privateStateStorage.getPrivacyGroupHeadBlockMap(blockHash);\n+\n+    if (privacyGroupHeadBlockMapOptional.isPresent()) {\n+      final Set<Bytes32> mappedPrivacyGroupIds = privacyGroupHeadBlockMapOptional.get().keySet();\n+\n+      for (final Bytes32 privacyGroupId : mappedPrivacyGroupIds) {", "originalCommit": "76aeba9d9a4fb75f6152f26675bba3880d66fc62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEzMTQxMg==", "url": "https://github.com/hyperledger/besu/pull/1032#discussion_r437131412", "bodyText": "Probably something for a separate PR.", "author": "lucassaldanha", "createdAt": "2020-06-09T04:31:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MjQyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MjgzMg==", "url": "https://github.com/hyperledger/besu/pull/1032#discussion_r435692832", "bodyText": "we could safe some time if we were to check here if the PMT hash is in the metadata ...\nWe don't have to serialise all of the data then ...", "author": "pinges", "createdAt": "2020-06-05T05:09:25Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivateTransactionLocator.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.apache.logging.log4j.LogManager.getLogger;\n+\n+import org.hyperledger.besu.enclave.Enclave;\n+import org.hyperledger.besu.enclave.EnclaveClientException;\n+import org.hyperledger.besu.enclave.types.ReceiveResponse;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.chain.TransactionLocation;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.Transaction;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLPException;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class PrivateTransactionLocator {\n+\n+  private static final Logger LOG = getLogger();\n+\n+  private final Blockchain blockchain;\n+  private final Enclave enclave;\n+  private final PrivateStateStorage privateStateStorage;\n+\n+  public PrivateTransactionLocator(\n+      final Blockchain blockchain,\n+      final Enclave enclave,\n+      final PrivateStateStorage privateStateStorage) {\n+    this.blockchain = blockchain;\n+    this.enclave = enclave;\n+    this.privateStateStorage = privateStateStorage;\n+  }\n+\n+  /**\n+   * Returns a private transaction with extra data (block and pmt information). The private\n+   * transaction is retrieved from the Enclave, either as a single transaction or from an existing\n+   * \"blob\".<br>\n+   * In both cases, we are passing the enclaveKey (public key of the participant) down to the\n+   * Enclave, with the expectation that the Enclave will only return the payload if the matching\n+   * private key of the enclaveKey passed as a parameter is able to be used to decrypt the payload.\n+   *\n+   * <p>This enclaveKey \"validation\" in the Enclave makes retrieving a payload multi-tenancy safe.\n+   *\n+   * @param pmtHash the hash of the PMT associated with the private transaction\n+   * @param enclaveKey participant public key that must match the private key used to decrypt the\n+   *     payload\n+   * @return An executed private transaction\n+   */\n+  public Optional<ExecutedPrivateTransaction> findByPmtHash(\n+      final Hash pmtHash, final String enclaveKey) {\n+    final Optional<TransactionLocation> maybePmtLocation =\n+        blockchain.getTransactionLocation(pmtHash);\n+    if (maybePmtLocation.isEmpty()) {\n+      return Optional.empty();\n+    }\n+\n+    /*\n+     If tx location isn't empty it is safe to assume that the block header and transaction exist.\n+     Therefore, using orElseThrow here makes sense\n+    */\n+    final TransactionLocation pmtLocation = maybePmtLocation.get();\n+    final Transaction pmt = blockchain.getTransactionByHash(pmtHash).orElseThrow();\n+    final BlockHeader blockHeader =\n+        blockchain.getBlockHeader(pmtLocation.getBlockHash()).orElseThrow();\n+    final String payloadKey = readPayloadKeyFromPmt(pmt);\n+\n+    return tryFetchingPrivateTransactionFromEnclave(payloadKey, enclaveKey)\n+        .or(() -> tryFetchingTransactionFromAddBlob(blockHeader.getHash(), pmtHash, enclaveKey))\n+        .map(\n+            tx ->\n+                new ExecutedPrivateTransaction(\n+                    blockHeader,\n+                    pmt,\n+                    pmtLocation,\n+                    tx.getExternalPrivacyGroupId(),\n+                    tx.getPrivateTransaction()));\n+  }\n+\n+  private String readPayloadKeyFromPmt(final Transaction privacyMarkerTx) {\n+    return privacyMarkerTx.getPayload().slice(0, 32).toBase64String();\n+  }\n+\n+  /**\n+   * Retrieves a single private transaction from the Enclave\n+   *\n+   * @param payloadKey unique key identifying the payload\n+   * @param enclaveKey participant public key that must match the private key used to decrypt the\n+   *     payload\n+   * @return an optional containing the private transaction, if found. Or an empty optional if the\n+   *     private transaction couldnt' be found.\n+   */\n+  private Optional<TransactionFromEnclave> tryFetchingPrivateTransactionFromEnclave(\n+      final String payloadKey, final String enclaveKey) {\n+    return retrievePayloadFromEnclave(payloadKey, enclaveKey)\n+        .map(this::readPrivateTransactionFromPayload);\n+  }\n+\n+  private Optional<ReceiveResponse> retrievePayloadFromEnclave(\n+      final String payloadKey, final String enclaveKey) {\n+    try {\n+      return Optional.of(enclave.receive(payloadKey, enclaveKey));\n+    } catch (final EnclaveClientException e) {\n+      // Enclave throws an exception with a 404 status code if the payload isn't found\n+      if (e.getStatusCode() == 404) {\n+        return Optional.empty();\n+      } else {\n+        throw e;\n+      }\n+    }\n+  }\n+\n+  private TransactionFromEnclave readPrivateTransactionFromPayload(\n+      final ReceiveResponse receiveResponse) {\n+    final PrivateTransaction privateTransaction;\n+    final BytesValueRLPInput input =\n+        new BytesValueRLPInput(\n+            Bytes.fromBase64String(new String(receiveResponse.getPayload(), UTF_8)), false);\n+\n+    /*\n+     When using on-chain privacy groups, the payload is a list with the first element being the\n+     private transaction RLP and the second element being the version. This is why we have the\n+     nextIsList() check.\n+    */\n+    try {\n+      input.enterList();\n+      if (input.nextIsList()) {\n+        // private transaction and version (we only read the first element in the list)\n+        privateTransaction = PrivateTransaction.readFrom(input);\n+        input.leaveListLenient();\n+      } else {\n+        // private transaction only (read the whole RLP)\n+        input.reset();\n+        privateTransaction = PrivateTransaction.readFrom(input);\n+      }\n+    } catch (RLPException e) {\n+      LOG.debug(\"Error de-serializing private transaction from enclave\", e);\n+      throw e;\n+    }\n+\n+    return new TransactionFromEnclave(privateTransaction, receiveResponse.getPrivacyGroupId());\n+  }\n+\n+  private Optional<TransactionFromEnclave> tryFetchingTransactionFromAddBlob(\n+      final Bytes32 blockHash, final Hash expectedPmtHash, final String enclaveKey) {\n+    LOG.trace(\"Fetching transaction information from add blob\");\n+\n+    final Optional<PrivacyGroupHeadBlockMap> privacyGroupHeadBlockMapOptional =\n+        privateStateStorage.getPrivacyGroupHeadBlockMap(blockHash);\n+\n+    if (privacyGroupHeadBlockMapOptional.isPresent()) {\n+      final Set<Bytes32> mappedPrivacyGroupIds = privacyGroupHeadBlockMapOptional.get().keySet();\n+\n+      for (final Bytes32 privacyGroupId : mappedPrivacyGroupIds) {\n+        final Optional<Bytes32> addDataKey = privateStateStorage.getAddDataKey(privacyGroupId);\n+\n+        if (addDataKey.isPresent()) {\n+          final Optional<ReceiveResponse> receiveResponse =\n+              retrievePayloadFromEnclave(addDataKey.get().toBase64String(), enclaveKey);\n+          if (receiveResponse.isEmpty()) {\n+            return Optional.empty();\n+          }\n+\n+          final Bytes payload =\n+              Bytes.wrap(Base64.getDecoder().decode(receiveResponse.get().getPayload()));\n+          final List<PrivateTransactionWithMetadata> privateTransactionWithMetadataList =\n+              deserializeAddToGroupPayload(payload);\n+\n+          for (final PrivateTransactionWithMetadata privateTx :\n+              privateTransactionWithMetadataList) {\n+            final Hash actualPrivacyMarkerTransactionHash =\n+                privateTx.getPrivateTransactionMetadata().getPrivacyMarkerTransactionHash();\n+\n+            if (expectedPmtHash.equals(actualPrivacyMarkerTransactionHash)) {\n+              return Optional.of(\n+                  new TransactionFromEnclave(\n+                      privateTx.getPrivateTransaction(),\n+                      receiveResponse.get().getPrivacyGroupId()));\n+            }\n+          }\n+        }\n+      }\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private List<PrivateTransactionWithMetadata> deserializeAddToGroupPayload(\n+      final Bytes encodedAddToGroupPayload) {\n+    final ArrayList<PrivateTransactionWithMetadata> deserializedResponse = new ArrayList<>();\n+    final BytesValueRLPInput bytesValueRLPInput =\n+        new BytesValueRLPInput(encodedAddToGroupPayload, false);\n+    final int noOfEntries = bytesValueRLPInput.enterList();\n+    for (int i = 0; i < noOfEntries; i++) {\n+      deserializedResponse.add(PrivateTransactionWithMetadata.readFrom(bytesValueRLPInput));", "originalCommit": "76aeba9d9a4fb75f6152f26675bba3880d66fc62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEzMTg2Nw==", "url": "https://github.com/hyperledger/besu/pull/1032#discussion_r437131867", "bodyText": "Could you share a code sample with this check?", "author": "lucassaldanha", "createdAt": "2020-06-09T04:33:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MjgzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1MDczMA==", "url": "https://github.com/hyperledger/besu/pull/1032#discussion_r437150730", "bodyText": "In this line (220) we could check whether the resulting PrivateTransactinWithMetadata contains the  PMT hash that we are looking for.\nBut now you are using a common method in PrivateTransactionWithMetadata, which makes a lot of sense ...", "author": "pinges", "createdAt": "2020-06-09T05:45:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MjgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NjM4NQ==", "url": "https://github.com/hyperledger/besu/pull/1032#discussion_r435696385", "bodyText": "That code must exist somewhere else. If you really want to deserialise the whole thing (see next comment) please check whether we can reuse the existing code.", "author": "pinges", "createdAt": "2020-06-05T05:24:25Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivateTransactionLocator.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.apache.logging.log4j.LogManager.getLogger;\n+\n+import org.hyperledger.besu.enclave.Enclave;\n+import org.hyperledger.besu.enclave.EnclaveClientException;\n+import org.hyperledger.besu.enclave.types.ReceiveResponse;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.chain.TransactionLocation;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.Transaction;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLPException;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class PrivateTransactionLocator {\n+\n+  private static final Logger LOG = getLogger();\n+\n+  private final Blockchain blockchain;\n+  private final Enclave enclave;\n+  private final PrivateStateStorage privateStateStorage;\n+\n+  public PrivateTransactionLocator(\n+      final Blockchain blockchain,\n+      final Enclave enclave,\n+      final PrivateStateStorage privateStateStorage) {\n+    this.blockchain = blockchain;\n+    this.enclave = enclave;\n+    this.privateStateStorage = privateStateStorage;\n+  }\n+\n+  /**\n+   * Returns a private transaction with extra data (block and pmt information). The private\n+   * transaction is retrieved from the Enclave, either as a single transaction or from an existing\n+   * \"blob\".<br>\n+   * In both cases, we are passing the enclaveKey (public key of the participant) down to the\n+   * Enclave, with the expectation that the Enclave will only return the payload if the matching\n+   * private key of the enclaveKey passed as a parameter is able to be used to decrypt the payload.\n+   *\n+   * <p>This enclaveKey \"validation\" in the Enclave makes retrieving a payload multi-tenancy safe.\n+   *\n+   * @param pmtHash the hash of the PMT associated with the private transaction\n+   * @param enclaveKey participant public key that must match the private key used to decrypt the\n+   *     payload\n+   * @return An executed private transaction\n+   */\n+  public Optional<ExecutedPrivateTransaction> findByPmtHash(\n+      final Hash pmtHash, final String enclaveKey) {\n+    final Optional<TransactionLocation> maybePmtLocation =\n+        blockchain.getTransactionLocation(pmtHash);\n+    if (maybePmtLocation.isEmpty()) {\n+      return Optional.empty();\n+    }\n+\n+    /*\n+     If tx location isn't empty it is safe to assume that the block header and transaction exist.\n+     Therefore, using orElseThrow here makes sense\n+    */\n+    final TransactionLocation pmtLocation = maybePmtLocation.get();\n+    final Transaction pmt = blockchain.getTransactionByHash(pmtHash).orElseThrow();\n+    final BlockHeader blockHeader =\n+        blockchain.getBlockHeader(pmtLocation.getBlockHash()).orElseThrow();\n+    final String payloadKey = readPayloadKeyFromPmt(pmt);\n+\n+    return tryFetchingPrivateTransactionFromEnclave(payloadKey, enclaveKey)\n+        .or(() -> tryFetchingTransactionFromAddBlob(blockHeader.getHash(), pmtHash, enclaveKey))\n+        .map(\n+            tx ->\n+                new ExecutedPrivateTransaction(\n+                    blockHeader,\n+                    pmt,\n+                    pmtLocation,\n+                    tx.getExternalPrivacyGroupId(),\n+                    tx.getPrivateTransaction()));\n+  }\n+\n+  private String readPayloadKeyFromPmt(final Transaction privacyMarkerTx) {\n+    return privacyMarkerTx.getPayload().slice(0, 32).toBase64String();\n+  }\n+\n+  /**\n+   * Retrieves a single private transaction from the Enclave\n+   *\n+   * @param payloadKey unique key identifying the payload\n+   * @param enclaveKey participant public key that must match the private key used to decrypt the\n+   *     payload\n+   * @return an optional containing the private transaction, if found. Or an empty optional if the\n+   *     private transaction couldnt' be found.\n+   */\n+  private Optional<TransactionFromEnclave> tryFetchingPrivateTransactionFromEnclave(\n+      final String payloadKey, final String enclaveKey) {\n+    return retrievePayloadFromEnclave(payloadKey, enclaveKey)\n+        .map(this::readPrivateTransactionFromPayload);\n+  }\n+\n+  private Optional<ReceiveResponse> retrievePayloadFromEnclave(\n+      final String payloadKey, final String enclaveKey) {\n+    try {\n+      return Optional.of(enclave.receive(payloadKey, enclaveKey));\n+    } catch (final EnclaveClientException e) {\n+      // Enclave throws an exception with a 404 status code if the payload isn't found\n+      if (e.getStatusCode() == 404) {\n+        return Optional.empty();\n+      } else {\n+        throw e;\n+      }\n+    }\n+  }\n+\n+  private TransactionFromEnclave readPrivateTransactionFromPayload(\n+      final ReceiveResponse receiveResponse) {\n+    final PrivateTransaction privateTransaction;\n+    final BytesValueRLPInput input =\n+        new BytesValueRLPInput(\n+            Bytes.fromBase64String(new String(receiveResponse.getPayload(), UTF_8)), false);\n+\n+    /*\n+     When using on-chain privacy groups, the payload is a list with the first element being the\n+     private transaction RLP and the second element being the version. This is why we have the\n+     nextIsList() check.\n+    */\n+    try {\n+      input.enterList();\n+      if (input.nextIsList()) {\n+        // private transaction and version (we only read the first element in the list)\n+        privateTransaction = PrivateTransaction.readFrom(input);\n+        input.leaveListLenient();\n+      } else {\n+        // private transaction only (read the whole RLP)\n+        input.reset();\n+        privateTransaction = PrivateTransaction.readFrom(input);\n+      }\n+    } catch (RLPException e) {\n+      LOG.debug(\"Error de-serializing private transaction from enclave\", e);\n+      throw e;\n+    }\n+\n+    return new TransactionFromEnclave(privateTransaction, receiveResponse.getPrivacyGroupId());\n+  }\n+\n+  private Optional<TransactionFromEnclave> tryFetchingTransactionFromAddBlob(\n+      final Bytes32 blockHash, final Hash expectedPmtHash, final String enclaveKey) {\n+    LOG.trace(\"Fetching transaction information from add blob\");\n+\n+    final Optional<PrivacyGroupHeadBlockMap> privacyGroupHeadBlockMapOptional =\n+        privateStateStorage.getPrivacyGroupHeadBlockMap(blockHash);\n+\n+    if (privacyGroupHeadBlockMapOptional.isPresent()) {\n+      final Set<Bytes32> mappedPrivacyGroupIds = privacyGroupHeadBlockMapOptional.get().keySet();\n+\n+      for (final Bytes32 privacyGroupId : mappedPrivacyGroupIds) {\n+        final Optional<Bytes32> addDataKey = privateStateStorage.getAddDataKey(privacyGroupId);\n+\n+        if (addDataKey.isPresent()) {\n+          final Optional<ReceiveResponse> receiveResponse =\n+              retrievePayloadFromEnclave(addDataKey.get().toBase64String(), enclaveKey);\n+          if (receiveResponse.isEmpty()) {\n+            return Optional.empty();\n+          }\n+\n+          final Bytes payload =\n+              Bytes.wrap(Base64.getDecoder().decode(receiveResponse.get().getPayload()));\n+          final List<PrivateTransactionWithMetadata> privateTransactionWithMetadataList =\n+              deserializeAddToGroupPayload(payload);\n+\n+          for (final PrivateTransactionWithMetadata privateTx :\n+              privateTransactionWithMetadataList) {\n+            final Hash actualPrivacyMarkerTransactionHash =\n+                privateTx.getPrivateTransactionMetadata().getPrivacyMarkerTransactionHash();\n+\n+            if (expectedPmtHash.equals(actualPrivacyMarkerTransactionHash)) {\n+              return Optional.of(\n+                  new TransactionFromEnclave(\n+                      privateTx.getPrivateTransaction(),\n+                      receiveResponse.get().getPrivacyGroupId()));\n+            }\n+          }\n+        }\n+      }\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private List<PrivateTransactionWithMetadata> deserializeAddToGroupPayload(", "originalCommit": "76aeba9d9a4fb75f6152f26675bba3880d66fc62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEzNDEzOQ==", "url": "https://github.com/hyperledger/besu/pull/1032#discussion_r437134139", "bodyText": "You are right, it was used in 3 places. I've created a method readListFromPayload on the PrivateTransactionWithMetadata class.", "author": "lucassaldanha", "createdAt": "2020-06-09T04:43:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NjM4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwMTYyOQ==", "url": "https://github.com/hyperledger/besu/pull/1032#discussion_r435701629", "bodyText": "I'm not a big fan of this method, but I can see why you did it this way ...\nAnd it is only used for testing!", "author": "pinges", "createdAt": "2020-06-05T05:44:56Z", "path": "ethereum/core/src/test-support/java/org/hyperledger/besu/ethereum/core/PrivateTransactionDataFixture.java", "diffHunk": "@@ -183,4 +188,17 @@ public static PrivateTransactionMetadata generatePrivateTransactionMetadata() {\n   public static PrivateBlockMetadata generatePrivateBlockMetadata(final int numberOfTransactions) {\n     return new PrivateBlockMetadata(generatePrivateTransactionMetadataList(numberOfTransactions));\n   }\n+\n+  public static Bytes encodePrivateTransaction(", "originalCommit": "76aeba9d9a4fb75f6152f26675bba3880d66fc62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEzMzg4NA==", "url": "https://github.com/hyperledger/besu/pull/1032#discussion_r437133884", "bodyText": "Yeah, it helps to avoid a lot of duplication on the tests.", "author": "lucassaldanha", "createdAt": "2020-06-09T04:42:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwMTYyOQ=="}], "type": "inlineReview"}, {"oid": "82515be9fb2902c3c523e58bcafdd875fc2e47bf", "url": "https://github.com/hyperledger/besu/commit/82515be9fb2902c3c523e58bcafdd875fc2e47bf", "message": "Add onchain privacy group multi-tenancy support to priv_getPrivateTx and priv_getPrivRcpt\n\nSigned-off-by: Lucas Saldanha <lucas.saldanha@consensys.net>", "committedDate": "2020-06-09T05:11:16Z", "type": "commit"}, {"oid": "52fe9dcb46d679a9d81f6af14737eb53467661c8", "url": "https://github.com/hyperledger/besu/commit/52fe9dcb46d679a9d81f6af14737eb53467661c8", "message": "Mapping internal privacy group id\n\nSigned-off-by: Lucas Saldanha <lucas.saldanha@consensys.net>", "committedDate": "2020-06-09T05:11:16Z", "type": "commit"}, {"oid": "f11b558fc262c9bdcabce2d349668e868e32ec1b", "url": "https://github.com/hyperledger/besu/commit/f11b558fc262c9bdcabce2d349668e868e32ec1b", "message": "Refactoring methods\n\nSigned-off-by: Lucas Saldanha <lucas.saldanha@consensys.net>", "committedDate": "2020-06-09T05:11:16Z", "type": "commit"}, {"oid": "ce4ee0edc4d4e621459e113dbe4d235171d6cb23", "url": "https://github.com/hyperledger/besu/commit/ce4ee0edc4d4e621459e113dbe4d235171d6cb23", "message": "Fixing tests\n\nSigned-off-by: Lucas Saldanha <lucas.saldanha@consensys.net>", "committedDate": "2020-06-09T05:11:16Z", "type": "commit"}, {"oid": "f67b8d5de797a5b5baf33e3eaacc6c22eb63579c", "url": "https://github.com/hyperledger/besu/commit/f67b8d5de797a5b5baf33e3eaacc6c22eb63579c", "message": "Fix javadoc\n\nSigned-off-by: Lucas Saldanha <lucas.saldanha@consensys.net>", "committedDate": "2020-06-09T05:11:16Z", "type": "commit"}, {"oid": "a3755d2e0b650b86b80fdd5c87bf9546219cdf10", "url": "https://github.com/hyperledger/besu/commit/a3755d2e0b650b86b80fdd5c87bf9546219cdf10", "message": "PR commebts\n\nSigned-off-by: Lucas Saldanha <lucas.saldanha@consensys.net>", "committedDate": "2020-06-09T05:11:16Z", "type": "commit"}, {"oid": "a3755d2e0b650b86b80fdd5c87bf9546219cdf10", "url": "https://github.com/hyperledger/besu/commit/a3755d2e0b650b86b80fdd5c87bf9546219cdf10", "message": "PR commebts\n\nSigned-off-by: Lucas Saldanha <lucas.saldanha@consensys.net>", "committedDate": "2020-06-09T05:11:16Z", "type": "forcePushed"}]}