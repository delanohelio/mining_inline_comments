{"pr_number": 1422, "pr_title": "Add ATs for on chain privacy with multi tenancy", "pr_createdAt": "2020-10-07T05:32:46Z", "pr_url": "https://github.com/hyperledger/besu/pull/1422", "timeline": [{"oid": "635f3650a508bd2aae2e42e2fe1649b8afc866e7", "url": "https://github.com/hyperledger/besu/commit/635f3650a508bd2aae2e42e2fe1649b8afc866e7", "message": "all ATs working\n\nSigned-off-by: Stefan Pingel <stefan.pingel@consensys.net>", "committedDate": "2020-10-07T04:12:03Z", "type": "commit"}, {"oid": "da07e9f93e4f6b0e51ad22e75ab0c0d805b20696", "url": "https://github.com/hyperledger/besu/commit/da07e9f93e4f6b0e51ad22e75ab0c0d805b20696", "message": "Merge branch 'master' of github.com:hyperledger/besu into addATsForOnChainMultiTenancy", "committedDate": "2020-10-07T04:37:16Z", "type": "commit"}, {"oid": "72d60330f4c902e026bb3365f68112f7e44a2935", "url": "https://github.com/hyperledger/besu/commit/72d60330f4c902e026bb3365f68112f7e44a2935", "message": "add ATs for on-chain privacy with multi-tenancy\n\nSigned-off-by: Stefan Pingel <stefan.pingel@consensys.net>", "committedDate": "2020-10-07T05:27:49Z", "type": "commit"}, {"oid": "d4f0066110af89b59db2a519ada10b0cfb8558c5", "url": "https://github.com/hyperledger/besu/commit/d4f0066110af89b59db2a519ada10b0cfb8558c5", "message": "add ATs for on-chain privacy with multi-tenancy\n\nSigned-off-by: Stefan Pingel <stefan.pingel@consensys.net>", "committedDate": "2020-10-07T05:28:30Z", "type": "commit"}, {"oid": "2d80648c30a861b66be65e31fc873f83908eb541", "url": "https://github.com/hyperledger/besu/commit/2d80648c30a861b66be65e31fc873f83908eb541", "message": "add the right resources\n\nSigned-off-by: Stefan Pingel <stefan.pingel@consensys.net>", "committedDate": "2020-10-07T05:39:05Z", "type": "commit"}, {"oid": "2e6323e7fc5f4ff2081ce302519cecc3d2563779", "url": "https://github.com/hyperledger/besu/commit/2e6323e7fc5f4ff2081ce302519cecc3d2563779", "message": "spotless\n\nSigned-off-by: Stefan Pingel <stefan.pingel@consensys.net>", "committedDate": "2020-10-07T05:43:06Z", "type": "commit"}, {"oid": "4b8f36e8c799c06adb74354deb08acfc5754fd7f", "url": "https://github.com/hyperledger/besu/commit/4b8f36e8c799c06adb74354deb08acfc5754fd7f", "message": "fix spdx headers\n\nSigned-off-by: Stefan Pingel <stefan.pingel@consensys.net>", "committedDate": "2020-10-07T05:51:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3NzAyMw==", "url": "https://github.com/hyperledger/besu/pull/1422#discussion_r501277023", "bodyText": "Why do we need to make this optional? Isn't the idea of the builder that if you don't need this value you just don't call the keyFilePath  method?", "author": "lucassaldanha", "createdAt": "2020-10-07T20:04:47Z", "path": "acceptance-tests/dsl/src/main/java/org/hyperledger/besu/tests/acceptance/dsl/node/configuration/BesuNodeConfigurationBuilder.java", "diffHunk": "@@ -211,8 +211,8 @@ public BesuNodeConfigurationBuilder permissioningConfiguration(\n     return this;\n   }\n \n-  public BesuNodeConfigurationBuilder keyFilePath(final String keyFilePath) {\n-    this.keyFilePath = Optional.of(keyFilePath);\n+  public BesuNodeConfigurationBuilder keyFilePath(final Optional<String> keyFilePath) {", "originalCommit": "4b8f36e8c799c06adb74354deb08acfc5754fd7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3NzQ3NA==", "url": "https://github.com/hyperledger/besu/pull/1422#discussion_r501277474", "bodyText": "And it looks like keyFilePath already starts as an empty.", "author": "lucassaldanha", "createdAt": "2020-10-07T20:05:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3NzAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI4NTYyNw==", "url": "https://github.com/hyperledger/besu/pull/1422#discussion_r501285627", "bodyText": "Have you checked if we have the fields being returned by web3j? If we don't, it might be a good idea to keep the previous comment explaining why we are ignoring these fields.", "author": "lucassaldanha", "createdAt": "2020-10-07T20:20:45Z", "path": "acceptance-tests/dsl/src/main/java/org/hyperledger/besu/tests/acceptance/dsl/privacy/condition/ExpectValidPrivateTransactionReceipt.java", "diffHunk": "@@ -43,15 +43,7 @@ public void verify(final PrivacyNode node) {\n     assertThat(actualReceipt)\n         .usingRecursiveComparison()\n         .ignoringFields(\n-            \"commitmentHash\",\n-            \"logs\",\n-            \"blockHash\",\n-            \"blockNumber\",\n-            \"logsBloom\",\n-            \"transactionIndex\") // TODO: The fields blockHash, blockNumber, logsBloom and\n-        // transactionIndex have to be ignored as the class\n-        // org.web3j.protocol.besu.response.privacy.PrivateTransactionReceipt does not contain these\n-        // fields. Once web3j has been updated these ignores can be removed.\n+            \"commitmentHash\", \"logs\", \"blockHash\", \"blockNumber\", \"logsBloom\", \"transactionIndex\")", "originalCommit": "4b8f36e8c799c06adb74354deb08acfc5754fd7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5NzIwNA==", "url": "https://github.com/hyperledger/besu/pull/1422#discussion_r501397204", "bodyText": "Done", "author": "pinges", "createdAt": "2020-10-08T01:23:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI4NTYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI4ODAxNg==", "url": "https://github.com/hyperledger/besu/pull/1422#discussion_r501288016", "bodyText": "What are we gonna do about this? Does that mean that something is broken?", "author": "lucassaldanha", "createdAt": "2020-10-07T20:25:20Z", "path": "acceptance-tests/tests/src/test/java/org/hyperledger/besu/tests/acceptance/privacy/multitenancy/OnChainMultiTenancyAcceptanceTest.java", "diffHunk": "@@ -0,0 +1,697 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.tests.acceptance.privacy.multitenancy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.tests.acceptance.dsl.node.BesuNode;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyNode;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.account.PrivacyAccountResolver;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.contract.CallPrivateSmartContractFunction;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.transaction.CreateOnChainPrivacyGroupTransaction;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.util.LogFilterJsonParameter;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.perm.PermissioningTransactions;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.privacy.PrivacyRequestFactory;\n+import org.hyperledger.besu.tests.web3j.generated.EventEmitter;\n+import org.hyperledger.besu.tests.web3j.privacy.OnChainPrivacyAcceptanceTestBase;\n+\n+import java.math.BigInteger;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.web3j.crypto.Credentials;\n+import org.web3j.protocol.besu.response.privacy.PrivateTransactionReceipt;\n+import org.web3j.protocol.core.methods.response.EthCall;\n+import org.web3j.utils.Base64String;\n+\n+public class OnChainMultiTenancyAcceptanceTest extends OnChainPrivacyAcceptanceTestBase {\n+\n+  private static final String eventEmitterDeployed =\n+      \"0x6080604052600436106100565763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416633fa4f245811461005b5780636057361d1461008257806367e404ce146100ae575b600080fd5b34801561006757600080fd5b506100706100ec565b60408051918252519081900360200190f35b34801561008e57600080fd5b506100ac600480360360208110156100a557600080fd5b50356100f2565b005b3480156100ba57600080fd5b506100c3610151565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b60025490565b604080513381526020810183905281517fc9db20adedc6cf2b5d25252b101ab03e124902a73fcb12b753f3d1aaa2d8f9f5929181900390910190a16002556001805473ffffffffffffffffffffffffffffffffffffffff191633179055565b60015473ffffffffffffffffffffffffffffffffffffffff169056fea165627a7a72305820c7f729cb24e05c221f5aa913700793994656f233fe2ce3b9fd9a505ea17e8d8a0029\";\n+\n+  private static final PermissioningTransactions permissioningTransactions =\n+      new PermissioningTransactions();\n+  private static final long VALUE_SET = 10L;\n+\n+  private PrivacyNode alice;\n+  private MultiTenancyPrivacyNode aliceMultiTenancyPrivacyNode;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    alice =\n+        privacyBesu.createOnChainPrivacyGroupEnabledMinerNode(\n+            \"node1\", PrivacyAccountResolver.MULTI_TENANCY, Address.PRIVACY, true);\n+    final BesuNode aliceBesu = alice.getBesu();\n+    privacyCluster.startNodes(alice);\n+    final String alice1Token =\n+        aliceBesu.execute(permissioningTransactions.createSuccessfulLogin(\"user\", \"pegasys\"));\n+    aliceBesu.useAuthenticationTokenInHeaderForJsonRpc(alice1Token);\n+    final String alice2Token =\n+        aliceBesu.execute(permissioningTransactions.createSuccessfulLogin(\"user2\", \"Password2\"));\n+    final String alice3Token =\n+        aliceBesu.execute(permissioningTransactions.createSuccessfulLogin(\"user3\", \"Password3\"));\n+    privacyCluster.awaitPeerCount(alice);\n+\n+    final String alice1EnclaveKey = alice.getOrion().getPublicKeys().get(0);\n+    final String alice2EnclaveKey = alice.getOrion().getPublicKeys().get(1);\n+    final String alice3EnclaveKey = alice.getOrion().getPublicKeys().get(2);\n+\n+    aliceMultiTenancyPrivacyNode = new MultiTenancyPrivacyNode(alice);\n+    aliceMultiTenancyPrivacyNode\n+        .addTenantWithToken(alice1EnclaveKey, alice1Token)\n+        .addTenantWithToken(alice2EnclaveKey, alice2Token)\n+        .addTenantWithToken(alice3EnclaveKey, alice3Token);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    privacyCluster.close();\n+  }\n+\n+  @Test\n+  public void createPrivacyGroup() {\n+    createOnChainPrivacyGroup(alice);\n+  }\n+\n+  @Test\n+  public void createPrivacyWithAllTenants() {\n+    final MultiTenancyPrivacyGroup justAlice = new MultiTenancyPrivacyGroup();\n+    justAlice.addNodeWithTenants(\n+        aliceMultiTenancyPrivacyNode, aliceMultiTenancyPrivacyNode.getTenants());\n+    createOnChainPrivacyGroup(justAlice);\n+  }\n+\n+  @Test\n+  public void noAccessWhenNotAMember() {\n+    final MultiTenancyPrivacyGroup twoTenantsFromAlice = new MultiTenancyPrivacyGroup();\n+    final List<String> tenants = aliceMultiTenancyPrivacyNode.getTenants();\n+    final String removedTenant = tenants.remove(tenants.size() - 1);\n+    twoTenantsFromAlice.addNodeWithTenants(aliceMultiTenancyPrivacyNode, tenants);\n+    final String privacyGroupId = createOnChainPrivacyGroup(twoTenantsFromAlice);\n+\n+    final MultiTenancyPrivacyNode multiTenancyPrivacyNode =\n+        twoTenantsFromAlice.getPrivacyNodes().get(0);\n+    final String tenant = tenants.get(0);\n+    final PrivacyNode privacyNode = multiTenancyPrivacyNode.getPrivacyNode();\n+    final BesuNode privacyNodeBesu = privacyNode.getBesu();\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(tenant));\n+    final EventEmitter eventEmitter =\n+        privacyNode.execute(\n+            privateContractTransactions.createSmartContractWithPrivacyGroupId(\n+                EventEmitter.class,\n+                privacyNode.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                tenant,\n+                privacyGroupId));\n+\n+    final String transactionHash = getContractDeploymentCommitmentHash(eventEmitter);\n+\n+    // check that a member can get the transaction receipt\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(tenant));\n+    privacyNode.verify(\n+        privateTransactionVerifier.validPrivateTransactionReceipt(\n+            transactionHash,\n+            (PrivateTransactionReceipt) eventEmitter.getTransactionReceipt().get()));\n+    assertThat(\n+            privacyNode\n+                .execute(\n+                    privacyTransactions.privGetCode(\n+                        privacyGroupId,\n+                        Address.fromHexString(eventEmitter.getContractAddress()),\n+                        \"latest\"))\n+                .toHexString())\n+        .isEqualTo(eventEmitterDeployed);\n+\n+    // check that getting the transaction receipt does not work if you are not a member\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(removedTenant));\n+    privacyNode.verify(\n+        privateTransactionVerifier.noPrivateTransactionReceipt(\n+            transactionHash)); // // TODO: returning null because the RPC is using the enclave key\n+\n+    // check that getting the code of the event emitter does not work when you are not a member\n+    assertThatThrownBy(\n+            () ->\n+                privacyNode.execute(\n+                    privacyTransactions.privGetCode(\n+                        privacyGroupId,\n+                        Address.fromHexString(eventEmitter.getContractAddress()),\n+                        \"latest\")))\n+        .hasMessageContaining(\"Unauthorized\");\n+\n+    final LogFilterJsonParameter filterParameter =\n+        new LogFilterJsonParameter(\n+            \"earliest\",\n+            \"latest\",\n+            List.of(eventEmitter.getContractAddress()),\n+            Collections.emptyList(),\n+            null);\n+\n+    // create a valid filter\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(tenant));\n+    final String filterId =\n+        privacyNode.execute(privacyTransactions.newFilter(privacyGroupId, filterParameter));\n+\n+    //        THIS does not work because I cannot find out what the nonce is \"Unable to determine\n+    // nonce for account in group\"\n+    //        // check that sending a transaction does not work if you are not a member\n+    //\n+    // privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(multiTenancyPrivacyNode.getTokenForTenant(removedTenant));", "originalCommit": "4b8f36e8c799c06adb74354deb08acfc5754fd7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM3NDA2Mg==", "url": "https://github.com/hyperledger/besu/pull/1422#discussion_r501374062", "bodyText": "Done! The way we are using web3j this cannot work", "author": "pinges", "createdAt": "2020-10-07T23:52:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI4ODAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI4OTA0MA==", "url": "https://github.com/hyperledger/besu/pull/1422#discussion_r501289040", "bodyText": "Is this a TODO or just an informative comment?", "author": "lucassaldanha", "createdAt": "2020-10-07T20:27:16Z", "path": "acceptance-tests/tests/src/test/java/org/hyperledger/besu/tests/acceptance/privacy/multitenancy/OnChainMultiTenancyAcceptanceTest.java", "diffHunk": "@@ -0,0 +1,697 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.tests.acceptance.privacy.multitenancy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.tests.acceptance.dsl.node.BesuNode;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyNode;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.account.PrivacyAccountResolver;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.contract.CallPrivateSmartContractFunction;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.transaction.CreateOnChainPrivacyGroupTransaction;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.util.LogFilterJsonParameter;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.perm.PermissioningTransactions;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.privacy.PrivacyRequestFactory;\n+import org.hyperledger.besu.tests.web3j.generated.EventEmitter;\n+import org.hyperledger.besu.tests.web3j.privacy.OnChainPrivacyAcceptanceTestBase;\n+\n+import java.math.BigInteger;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.web3j.crypto.Credentials;\n+import org.web3j.protocol.besu.response.privacy.PrivateTransactionReceipt;\n+import org.web3j.protocol.core.methods.response.EthCall;\n+import org.web3j.utils.Base64String;\n+\n+public class OnChainMultiTenancyAcceptanceTest extends OnChainPrivacyAcceptanceTestBase {\n+\n+  private static final String eventEmitterDeployed =\n+      \"0x6080604052600436106100565763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416633fa4f245811461005b5780636057361d1461008257806367e404ce146100ae575b600080fd5b34801561006757600080fd5b506100706100ec565b60408051918252519081900360200190f35b34801561008e57600080fd5b506100ac600480360360208110156100a557600080fd5b50356100f2565b005b3480156100ba57600080fd5b506100c3610151565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b60025490565b604080513381526020810183905281517fc9db20adedc6cf2b5d25252b101ab03e124902a73fcb12b753f3d1aaa2d8f9f5929181900390910190a16002556001805473ffffffffffffffffffffffffffffffffffffffff191633179055565b60015473ffffffffffffffffffffffffffffffffffffffff169056fea165627a7a72305820c7f729cb24e05c221f5aa913700793994656f233fe2ce3b9fd9a505ea17e8d8a0029\";\n+\n+  private static final PermissioningTransactions permissioningTransactions =\n+      new PermissioningTransactions();\n+  private static final long VALUE_SET = 10L;\n+\n+  private PrivacyNode alice;\n+  private MultiTenancyPrivacyNode aliceMultiTenancyPrivacyNode;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    alice =\n+        privacyBesu.createOnChainPrivacyGroupEnabledMinerNode(\n+            \"node1\", PrivacyAccountResolver.MULTI_TENANCY, Address.PRIVACY, true);\n+    final BesuNode aliceBesu = alice.getBesu();\n+    privacyCluster.startNodes(alice);\n+    final String alice1Token =\n+        aliceBesu.execute(permissioningTransactions.createSuccessfulLogin(\"user\", \"pegasys\"));\n+    aliceBesu.useAuthenticationTokenInHeaderForJsonRpc(alice1Token);\n+    final String alice2Token =\n+        aliceBesu.execute(permissioningTransactions.createSuccessfulLogin(\"user2\", \"Password2\"));\n+    final String alice3Token =\n+        aliceBesu.execute(permissioningTransactions.createSuccessfulLogin(\"user3\", \"Password3\"));\n+    privacyCluster.awaitPeerCount(alice);\n+\n+    final String alice1EnclaveKey = alice.getOrion().getPublicKeys().get(0);\n+    final String alice2EnclaveKey = alice.getOrion().getPublicKeys().get(1);\n+    final String alice3EnclaveKey = alice.getOrion().getPublicKeys().get(2);\n+\n+    aliceMultiTenancyPrivacyNode = new MultiTenancyPrivacyNode(alice);\n+    aliceMultiTenancyPrivacyNode\n+        .addTenantWithToken(alice1EnclaveKey, alice1Token)\n+        .addTenantWithToken(alice2EnclaveKey, alice2Token)\n+        .addTenantWithToken(alice3EnclaveKey, alice3Token);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    privacyCluster.close();\n+  }\n+\n+  @Test\n+  public void createPrivacyGroup() {\n+    createOnChainPrivacyGroup(alice);\n+  }\n+\n+  @Test\n+  public void createPrivacyWithAllTenants() {\n+    final MultiTenancyPrivacyGroup justAlice = new MultiTenancyPrivacyGroup();\n+    justAlice.addNodeWithTenants(\n+        aliceMultiTenancyPrivacyNode, aliceMultiTenancyPrivacyNode.getTenants());\n+    createOnChainPrivacyGroup(justAlice);\n+  }\n+\n+  @Test\n+  public void noAccessWhenNotAMember() {\n+    final MultiTenancyPrivacyGroup twoTenantsFromAlice = new MultiTenancyPrivacyGroup();\n+    final List<String> tenants = aliceMultiTenancyPrivacyNode.getTenants();\n+    final String removedTenant = tenants.remove(tenants.size() - 1);\n+    twoTenantsFromAlice.addNodeWithTenants(aliceMultiTenancyPrivacyNode, tenants);\n+    final String privacyGroupId = createOnChainPrivacyGroup(twoTenantsFromAlice);\n+\n+    final MultiTenancyPrivacyNode multiTenancyPrivacyNode =\n+        twoTenantsFromAlice.getPrivacyNodes().get(0);\n+    final String tenant = tenants.get(0);\n+    final PrivacyNode privacyNode = multiTenancyPrivacyNode.getPrivacyNode();\n+    final BesuNode privacyNodeBesu = privacyNode.getBesu();\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(tenant));\n+    final EventEmitter eventEmitter =\n+        privacyNode.execute(\n+            privateContractTransactions.createSmartContractWithPrivacyGroupId(\n+                EventEmitter.class,\n+                privacyNode.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                tenant,\n+                privacyGroupId));\n+\n+    final String transactionHash = getContractDeploymentCommitmentHash(eventEmitter);\n+\n+    // check that a member can get the transaction receipt\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(tenant));\n+    privacyNode.verify(\n+        privateTransactionVerifier.validPrivateTransactionReceipt(\n+            transactionHash,\n+            (PrivateTransactionReceipt) eventEmitter.getTransactionReceipt().get()));\n+    assertThat(\n+            privacyNode\n+                .execute(\n+                    privacyTransactions.privGetCode(\n+                        privacyGroupId,\n+                        Address.fromHexString(eventEmitter.getContractAddress()),\n+                        \"latest\"))\n+                .toHexString())\n+        .isEqualTo(eventEmitterDeployed);\n+\n+    // check that getting the transaction receipt does not work if you are not a member\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(removedTenant));\n+    privacyNode.verify(\n+        privateTransactionVerifier.noPrivateTransactionReceipt(\n+            transactionHash)); // // TODO: returning null because the RPC is using the enclave key\n+\n+    // check that getting the code of the event emitter does not work when you are not a member\n+    assertThatThrownBy(\n+            () ->\n+                privacyNode.execute(\n+                    privacyTransactions.privGetCode(\n+                        privacyGroupId,\n+                        Address.fromHexString(eventEmitter.getContractAddress()),\n+                        \"latest\")))\n+        .hasMessageContaining(\"Unauthorized\");\n+\n+    final LogFilterJsonParameter filterParameter =\n+        new LogFilterJsonParameter(\n+            \"earliest\",\n+            \"latest\",\n+            List.of(eventEmitter.getContractAddress()),\n+            Collections.emptyList(),\n+            null);\n+\n+    // create a valid filter\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(tenant));\n+    final String filterId =\n+        privacyNode.execute(privacyTransactions.newFilter(privacyGroupId, filterParameter));\n+\n+    //        THIS does not work because I cannot find out what the nonce is \"Unable to determine\n+    // nonce for account in group\"\n+    //        // check that sending a transaction does not work if you are not a member\n+    //\n+    // privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(multiTenancyPrivacyNode.getTokenForTenant(removedTenant));\n+    //        privacyNode.execute(\n+    //                privateContractTransactions.callSmartContractWithPrivacyGroupId(\n+    //                        eventEmitter.getContractAddress(),\n+    //                        eventEmitter.store(BigInteger.valueOf(10L)).encodeFunctionCall(),\n+    //                        privacyNode.getTransactionSigningKey(),\n+    //                        POW_CHAIN_ID,\n+    //                        tenant,\n+    //                        privacyGroupId));\n+\n+    // check that a member can call the contract\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(tenant));\n+    final CallPrivateSmartContractFunction storeTransaction =\n+        privateContractTransactions.callSmartContractWithPrivacyGroupId(\n+            eventEmitter.getContractAddress(),\n+            eventEmitter.store(BigInteger.valueOf(VALUE_SET)).encodeFunctionCall(),\n+            privacyNode.getTransactionSigningKey(),\n+            POW_CHAIN_ID,\n+            tenant,\n+            privacyGroupId);\n+    final String storeTransactionHash = privacyNode.execute(storeTransaction);\n+\n+    privacyNode.execute(privacyTransactions.getPrivateTransactionReceipt(storeTransactionHash));\n+\n+    // check that getting the filter changes works for a member\n+    assertThat(privacyNode.execute(privacyTransactions.getFilterChanges(privacyGroupId, filterId)))\n+        .hasSize(1);\n+\n+    // check that getting the filter changes does not work if you are not a member\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(removedTenant));\n+    assertThatThrownBy(\n+            () ->\n+                privacyNode.execute(privacyTransactions.getFilterChanges(privacyGroupId, filterId)))\n+        .hasMessageContaining(\"Unauthorized\");\n+\n+    // check that getting the filter logs works for a member\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(tenant));\n+    assertThat(privacyNode.execute(privacyTransactions.getFilterLogs(privacyGroupId, filterId)))\n+        .hasSize(3); // create privacy group, deploy event emitter, store on event emitter\n+\n+    // check that getting the filter logs does not work if you are not a member\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(removedTenant));\n+    assertThatThrownBy(\n+            () -> privacyNode.execute(privacyTransactions.getFilterLogs(privacyGroupId, filterId)))\n+        .hasMessageContaining(\"Unauthorized\");\n+\n+    // check that getting the logs works for a member\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(tenant));\n+    assertThat(\n+            privacyNode.execute(privacyTransactions.privGetLogs(privacyGroupId, filterParameter)))\n+        .hasSize(3); // create privacy group, deploy event emitter, store on event emitter\n+\n+    // check that getting the logs does not work if you are not a member\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(removedTenant));\n+    assertThatThrownBy(\n+            () ->\n+                privacyNode.execute(\n+                    privacyTransactions.privGetLogs(privacyGroupId, filterParameter)))\n+        .hasMessageContaining(\"Unauthorized\");\n+\n+    final List<Base64String> base64StringList =\n+        tenants.stream().map(Base64String::wrap).collect(Collectors.toList());\n+\n+    // check that a member can find the on-chain privacy group\n+    privacyNode\n+        .getBesu()\n+        .useAuthenticationTokenInHeaderForJsonRpc(\n+            multiTenancyPrivacyNode.getTokenForTenant(tenant));\n+    final List<PrivacyRequestFactory.OnChainPrivacyGroup> group =\n+        privacyNode.execute(\n+            privacyTransactions.findOnChainPrivacyGroup(Base64String.unwrapList(base64StringList)));\n+    assertThat(group.size()).isEqualTo(1);\n+    assertThat(group.get(0).getMembers()).containsAll(base64StringList).hasSize(2);\n+\n+    // check that when you are not a member you cannot find the privacy group\n+    privacyNode\n+        .getBesu()\n+        .useAuthenticationTokenInHeaderForJsonRpc(\n+            multiTenancyPrivacyNode.getTokenForTenant(removedTenant));\n+    assertThatThrownBy(\n+            () ->\n+                privacyNode.execute(\n+                    privacyTransactions.findOnChainPrivacyGroup(\n+                        Base64String.unwrapList(base64StringList))))\n+        .hasMessageContaining(\"Error finding onchain privacy group\");\n+\n+    // check that a member can do a priv_call\n+    privacyNode\n+        .getBesu()\n+        .useAuthenticationTokenInHeaderForJsonRpc(\n+            multiTenancyPrivacyNode.getTokenForTenant(tenant));\n+    final EthCall readValue =\n+        privacyNode.execute(\n+            privacyTransactions.privCall(\n+                privacyGroupId, eventEmitter, eventEmitter.value().encodeFunctionCall()));\n+    assertThat(new BigInteger(readValue.getValue().substring(2), 16))\n+        .isEqualByComparingTo(BigInteger.valueOf(VALUE_SET));\n+\n+    // check that when you are not a member you cannot do a priv_call\n+    privacyNode\n+        .getBesu()\n+        .useAuthenticationTokenInHeaderForJsonRpc(\n+            multiTenancyPrivacyNode.getTokenForTenant(removedTenant));\n+    assertThatThrownBy(\n+            () ->\n+                privacyNode.execute(\n+                    privacyTransactions.privCall(\n+                        privacyGroupId, eventEmitter, eventEmitter.value().encodeFunctionCall())))\n+        .hasMessageContaining(\"Unauthorized\");\n+\n+    // check that a member can do a priv_getTransaction\n+    privacyNode\n+        .getBesu()\n+        .useAuthenticationTokenInHeaderForJsonRpc(\n+            multiTenancyPrivacyNode.getTokenForTenant(tenant));\n+    final PrivacyRequestFactory.GetPrivateTransactionResponse privTransaction =\n+        privacyNode.execute(privacyTransactions.privGetTransaction(storeTransactionHash));\n+    assertThat(privTransaction.getResult().getPrivacyGroupId()).isEqualTo(privacyGroupId);\n+\n+    // check that when you are not a member you cannot do a priv_getTransaction\n+    privacyNode\n+        .getBesu()\n+        .useAuthenticationTokenInHeaderForJsonRpc(\n+            multiTenancyPrivacyNode.getTokenForTenant(removedTenant));\n+    assertThatThrownBy(\n+            () -> privacyNode.execute(privacyTransactions.privGetTransaction(storeTransactionHash)))\n+        .hasMessageContaining(\n+            \"Expecting actual not to be null\"); // TODO: returning null because the RPC is using the", "originalCommit": "4b8f36e8c799c06adb74354deb08acfc5754fd7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM1NDQzMg==", "url": "https://github.com/hyperledger/besu/pull/1422#discussion_r501354432", "bodyText": "This is informative. Just to show what the response is here when we are not part of the group!", "author": "pinges", "createdAt": "2020-10-07T22:51:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI4OTA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5MjYyMw==", "url": "https://github.com/hyperledger/besu/pull/1422#discussion_r501392623", "bodyText": "It is better to remove the TODO then :)", "author": "lucassaldanha", "createdAt": "2020-10-08T01:03:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI4OTA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQxOTkwMQ==", "url": "https://github.com/hyperledger/besu/pull/1422#discussion_r501419901", "bodyText": "Done", "author": "pinges", "createdAt": "2020-10-08T02:58:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI4OTA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI5MDEwMw==", "url": "https://github.com/hyperledger/besu/pull/1422#discussion_r501290103", "bodyText": "Why do we have these tests commented out? We don't need them or did you forget to uncomment them? :)", "author": "lucassaldanha", "createdAt": "2020-10-07T20:29:21Z", "path": "acceptance-tests/tests/src/test/java/org/hyperledger/besu/tests/acceptance/privacy/multitenancy/OnChainMultiTenancyAcceptanceTest.java", "diffHunk": "@@ -0,0 +1,697 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.tests.acceptance.privacy.multitenancy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.tests.acceptance.dsl.node.BesuNode;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyNode;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.account.PrivacyAccountResolver;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.contract.CallPrivateSmartContractFunction;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.transaction.CreateOnChainPrivacyGroupTransaction;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.util.LogFilterJsonParameter;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.perm.PermissioningTransactions;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.privacy.PrivacyRequestFactory;\n+import org.hyperledger.besu.tests.web3j.generated.EventEmitter;\n+import org.hyperledger.besu.tests.web3j.privacy.OnChainPrivacyAcceptanceTestBase;\n+\n+import java.math.BigInteger;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.web3j.crypto.Credentials;\n+import org.web3j.protocol.besu.response.privacy.PrivateTransactionReceipt;\n+import org.web3j.protocol.core.methods.response.EthCall;\n+import org.web3j.utils.Base64String;\n+\n+public class OnChainMultiTenancyAcceptanceTest extends OnChainPrivacyAcceptanceTestBase {\n+\n+  private static final String eventEmitterDeployed =\n+      \"0x6080604052600436106100565763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416633fa4f245811461005b5780636057361d1461008257806367e404ce146100ae575b600080fd5b34801561006757600080fd5b506100706100ec565b60408051918252519081900360200190f35b34801561008e57600080fd5b506100ac600480360360208110156100a557600080fd5b50356100f2565b005b3480156100ba57600080fd5b506100c3610151565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b60025490565b604080513381526020810183905281517fc9db20adedc6cf2b5d25252b101ab03e124902a73fcb12b753f3d1aaa2d8f9f5929181900390910190a16002556001805473ffffffffffffffffffffffffffffffffffffffff191633179055565b60015473ffffffffffffffffffffffffffffffffffffffff169056fea165627a7a72305820c7f729cb24e05c221f5aa913700793994656f233fe2ce3b9fd9a505ea17e8d8a0029\";\n+\n+  private static final PermissioningTransactions permissioningTransactions =\n+      new PermissioningTransactions();\n+  private static final long VALUE_SET = 10L;\n+\n+  private PrivacyNode alice;\n+  private MultiTenancyPrivacyNode aliceMultiTenancyPrivacyNode;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    alice =\n+        privacyBesu.createOnChainPrivacyGroupEnabledMinerNode(\n+            \"node1\", PrivacyAccountResolver.MULTI_TENANCY, Address.PRIVACY, true);\n+    final BesuNode aliceBesu = alice.getBesu();\n+    privacyCluster.startNodes(alice);\n+    final String alice1Token =\n+        aliceBesu.execute(permissioningTransactions.createSuccessfulLogin(\"user\", \"pegasys\"));\n+    aliceBesu.useAuthenticationTokenInHeaderForJsonRpc(alice1Token);\n+    final String alice2Token =\n+        aliceBesu.execute(permissioningTransactions.createSuccessfulLogin(\"user2\", \"Password2\"));\n+    final String alice3Token =\n+        aliceBesu.execute(permissioningTransactions.createSuccessfulLogin(\"user3\", \"Password3\"));\n+    privacyCluster.awaitPeerCount(alice);\n+\n+    final String alice1EnclaveKey = alice.getOrion().getPublicKeys().get(0);\n+    final String alice2EnclaveKey = alice.getOrion().getPublicKeys().get(1);\n+    final String alice3EnclaveKey = alice.getOrion().getPublicKeys().get(2);\n+\n+    aliceMultiTenancyPrivacyNode = new MultiTenancyPrivacyNode(alice);\n+    aliceMultiTenancyPrivacyNode\n+        .addTenantWithToken(alice1EnclaveKey, alice1Token)\n+        .addTenantWithToken(alice2EnclaveKey, alice2Token)\n+        .addTenantWithToken(alice3EnclaveKey, alice3Token);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    privacyCluster.close();\n+  }\n+\n+  @Test\n+  public void createPrivacyGroup() {\n+    createOnChainPrivacyGroup(alice);\n+  }\n+\n+  @Test\n+  public void createPrivacyWithAllTenants() {\n+    final MultiTenancyPrivacyGroup justAlice = new MultiTenancyPrivacyGroup();\n+    justAlice.addNodeWithTenants(\n+        aliceMultiTenancyPrivacyNode, aliceMultiTenancyPrivacyNode.getTenants());\n+    createOnChainPrivacyGroup(justAlice);\n+  }\n+\n+  @Test\n+  public void noAccessWhenNotAMember() {\n+    final MultiTenancyPrivacyGroup twoTenantsFromAlice = new MultiTenancyPrivacyGroup();\n+    final List<String> tenants = aliceMultiTenancyPrivacyNode.getTenants();\n+    final String removedTenant = tenants.remove(tenants.size() - 1);\n+    twoTenantsFromAlice.addNodeWithTenants(aliceMultiTenancyPrivacyNode, tenants);\n+    final String privacyGroupId = createOnChainPrivacyGroup(twoTenantsFromAlice);\n+\n+    final MultiTenancyPrivacyNode multiTenancyPrivacyNode =\n+        twoTenantsFromAlice.getPrivacyNodes().get(0);\n+    final String tenant = tenants.get(0);\n+    final PrivacyNode privacyNode = multiTenancyPrivacyNode.getPrivacyNode();\n+    final BesuNode privacyNodeBesu = privacyNode.getBesu();\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(tenant));\n+    final EventEmitter eventEmitter =\n+        privacyNode.execute(\n+            privateContractTransactions.createSmartContractWithPrivacyGroupId(\n+                EventEmitter.class,\n+                privacyNode.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                tenant,\n+                privacyGroupId));\n+\n+    final String transactionHash = getContractDeploymentCommitmentHash(eventEmitter);\n+\n+    // check that a member can get the transaction receipt\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(tenant));\n+    privacyNode.verify(\n+        privateTransactionVerifier.validPrivateTransactionReceipt(\n+            transactionHash,\n+            (PrivateTransactionReceipt) eventEmitter.getTransactionReceipt().get()));\n+    assertThat(\n+            privacyNode\n+                .execute(\n+                    privacyTransactions.privGetCode(\n+                        privacyGroupId,\n+                        Address.fromHexString(eventEmitter.getContractAddress()),\n+                        \"latest\"))\n+                .toHexString())\n+        .isEqualTo(eventEmitterDeployed);\n+\n+    // check that getting the transaction receipt does not work if you are not a member\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(removedTenant));\n+    privacyNode.verify(\n+        privateTransactionVerifier.noPrivateTransactionReceipt(\n+            transactionHash)); // // TODO: returning null because the RPC is using the enclave key\n+\n+    // check that getting the code of the event emitter does not work when you are not a member\n+    assertThatThrownBy(\n+            () ->\n+                privacyNode.execute(\n+                    privacyTransactions.privGetCode(\n+                        privacyGroupId,\n+                        Address.fromHexString(eventEmitter.getContractAddress()),\n+                        \"latest\")))\n+        .hasMessageContaining(\"Unauthorized\");\n+\n+    final LogFilterJsonParameter filterParameter =\n+        new LogFilterJsonParameter(\n+            \"earliest\",\n+            \"latest\",\n+            List.of(eventEmitter.getContractAddress()),\n+            Collections.emptyList(),\n+            null);\n+\n+    // create a valid filter\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(tenant));\n+    final String filterId =\n+        privacyNode.execute(privacyTransactions.newFilter(privacyGroupId, filterParameter));\n+\n+    //        THIS does not work because I cannot find out what the nonce is \"Unable to determine\n+    // nonce for account in group\"\n+    //        // check that sending a transaction does not work if you are not a member\n+    //\n+    // privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(multiTenancyPrivacyNode.getTokenForTenant(removedTenant));\n+    //        privacyNode.execute(\n+    //                privateContractTransactions.callSmartContractWithPrivacyGroupId(\n+    //                        eventEmitter.getContractAddress(),\n+    //                        eventEmitter.store(BigInteger.valueOf(10L)).encodeFunctionCall(),\n+    //                        privacyNode.getTransactionSigningKey(),\n+    //                        POW_CHAIN_ID,\n+    //                        tenant,\n+    //                        privacyGroupId));\n+\n+    // check that a member can call the contract\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(tenant));\n+    final CallPrivateSmartContractFunction storeTransaction =\n+        privateContractTransactions.callSmartContractWithPrivacyGroupId(\n+            eventEmitter.getContractAddress(),\n+            eventEmitter.store(BigInteger.valueOf(VALUE_SET)).encodeFunctionCall(),\n+            privacyNode.getTransactionSigningKey(),\n+            POW_CHAIN_ID,\n+            tenant,\n+            privacyGroupId);\n+    final String storeTransactionHash = privacyNode.execute(storeTransaction);\n+\n+    privacyNode.execute(privacyTransactions.getPrivateTransactionReceipt(storeTransactionHash));\n+\n+    // check that getting the filter changes works for a member\n+    assertThat(privacyNode.execute(privacyTransactions.getFilterChanges(privacyGroupId, filterId)))\n+        .hasSize(1);\n+\n+    // check that getting the filter changes does not work if you are not a member\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(removedTenant));\n+    assertThatThrownBy(\n+            () ->\n+                privacyNode.execute(privacyTransactions.getFilterChanges(privacyGroupId, filterId)))\n+        .hasMessageContaining(\"Unauthorized\");\n+\n+    // check that getting the filter logs works for a member\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(tenant));\n+    assertThat(privacyNode.execute(privacyTransactions.getFilterLogs(privacyGroupId, filterId)))\n+        .hasSize(3); // create privacy group, deploy event emitter, store on event emitter\n+\n+    // check that getting the filter logs does not work if you are not a member\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(removedTenant));\n+    assertThatThrownBy(\n+            () -> privacyNode.execute(privacyTransactions.getFilterLogs(privacyGroupId, filterId)))\n+        .hasMessageContaining(\"Unauthorized\");\n+\n+    // check that getting the logs works for a member\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(tenant));\n+    assertThat(\n+            privacyNode.execute(privacyTransactions.privGetLogs(privacyGroupId, filterParameter)))\n+        .hasSize(3); // create privacy group, deploy event emitter, store on event emitter\n+\n+    // check that getting the logs does not work if you are not a member\n+    privacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(removedTenant));\n+    assertThatThrownBy(\n+            () ->\n+                privacyNode.execute(\n+                    privacyTransactions.privGetLogs(privacyGroupId, filterParameter)))\n+        .hasMessageContaining(\"Unauthorized\");\n+\n+    final List<Base64String> base64StringList =\n+        tenants.stream().map(Base64String::wrap).collect(Collectors.toList());\n+\n+    // check that a member can find the on-chain privacy group\n+    privacyNode\n+        .getBesu()\n+        .useAuthenticationTokenInHeaderForJsonRpc(\n+            multiTenancyPrivacyNode.getTokenForTenant(tenant));\n+    final List<PrivacyRequestFactory.OnChainPrivacyGroup> group =\n+        privacyNode.execute(\n+            privacyTransactions.findOnChainPrivacyGroup(Base64String.unwrapList(base64StringList)));\n+    assertThat(group.size()).isEqualTo(1);\n+    assertThat(group.get(0).getMembers()).containsAll(base64StringList).hasSize(2);\n+\n+    // check that when you are not a member you cannot find the privacy group\n+    privacyNode\n+        .getBesu()\n+        .useAuthenticationTokenInHeaderForJsonRpc(\n+            multiTenancyPrivacyNode.getTokenForTenant(removedTenant));\n+    assertThatThrownBy(\n+            () ->\n+                privacyNode.execute(\n+                    privacyTransactions.findOnChainPrivacyGroup(\n+                        Base64String.unwrapList(base64StringList))))\n+        .hasMessageContaining(\"Error finding onchain privacy group\");\n+\n+    // check that a member can do a priv_call\n+    privacyNode\n+        .getBesu()\n+        .useAuthenticationTokenInHeaderForJsonRpc(\n+            multiTenancyPrivacyNode.getTokenForTenant(tenant));\n+    final EthCall readValue =\n+        privacyNode.execute(\n+            privacyTransactions.privCall(\n+                privacyGroupId, eventEmitter, eventEmitter.value().encodeFunctionCall()));\n+    assertThat(new BigInteger(readValue.getValue().substring(2), 16))\n+        .isEqualByComparingTo(BigInteger.valueOf(VALUE_SET));\n+\n+    // check that when you are not a member you cannot do a priv_call\n+    privacyNode\n+        .getBesu()\n+        .useAuthenticationTokenInHeaderForJsonRpc(\n+            multiTenancyPrivacyNode.getTokenForTenant(removedTenant));\n+    assertThatThrownBy(\n+            () ->\n+                privacyNode.execute(\n+                    privacyTransactions.privCall(\n+                        privacyGroupId, eventEmitter, eventEmitter.value().encodeFunctionCall())))\n+        .hasMessageContaining(\"Unauthorized\");\n+\n+    // check that a member can do a priv_getTransaction\n+    privacyNode\n+        .getBesu()\n+        .useAuthenticationTokenInHeaderForJsonRpc(\n+            multiTenancyPrivacyNode.getTokenForTenant(tenant));\n+    final PrivacyRequestFactory.GetPrivateTransactionResponse privTransaction =\n+        privacyNode.execute(privacyTransactions.privGetTransaction(storeTransactionHash));\n+    assertThat(privTransaction.getResult().getPrivacyGroupId()).isEqualTo(privacyGroupId);\n+\n+    // check that when you are not a member you cannot do a priv_getTransaction\n+    privacyNode\n+        .getBesu()\n+        .useAuthenticationTokenInHeaderForJsonRpc(\n+            multiTenancyPrivacyNode.getTokenForTenant(removedTenant));\n+    assertThatThrownBy(\n+            () -> privacyNode.execute(privacyTransactions.privGetTransaction(storeTransactionHash)))\n+        .hasMessageContaining(\n+            \"Expecting actual not to be null\"); // TODO: returning null because the RPC is using the\n+    // enclave key\n+  }\n+\n+  @SuppressWarnings(value = \"unchecked\")\n+  @Test\n+  public void removedMemberCannotGetFilterChanges() {\n+    final MultiTenancyPrivacyGroup allTenantsFromAlice = new MultiTenancyPrivacyGroup();\n+    final List<String> tenants = aliceMultiTenancyPrivacyNode.getTenants();\n+    allTenantsFromAlice.addNodeWithTenants(aliceMultiTenancyPrivacyNode, tenants);\n+    final String privacyGroupId = createOnChainPrivacyGroup(allTenantsFromAlice);\n+    final MultiTenancyPrivacyNode multiTenancyPrivacyNode =\n+        allTenantsFromAlice.getPrivacyNodes().get(0);\n+    final String groupCreatingTenant = allTenantsFromAlice.getGroupCreatingTenant();\n+    final String tenantToBeRemoved =\n+        tenants.stream().filter(t -> !t.equals(groupCreatingTenant)).findFirst().orElseThrow();\n+    final PrivacyNode groupCreatingPrivacyNode = allTenantsFromAlice.getGroupCreatingPrivacyNode();\n+    final BesuNode groupCreatingPrivacyNodeBesu = groupCreatingPrivacyNode.getBesu();\n+    groupCreatingPrivacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(groupCreatingTenant));\n+\n+    final EventEmitter eventEmitter =\n+        groupCreatingPrivacyNode.execute(\n+            privateContractTransactions.createSmartContractWithPrivacyGroupId(\n+                EventEmitter.class,\n+                groupCreatingPrivacyNode.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                groupCreatingTenant,\n+                privacyGroupId));\n+\n+    final LogFilterJsonParameter filterParameter =\n+        new LogFilterJsonParameter(\n+            \"earliest\",\n+            \"latest\",\n+            List.of(eventEmitter.getContractAddress()),\n+            Collections.emptyList(),\n+            null);\n+\n+    final String filterId =\n+        groupCreatingPrivacyNode.execute(\n+            privacyTransactions.newFilter(privacyGroupId, filterParameter));\n+\n+    final CallPrivateSmartContractFunction storeTransaction =\n+        privateContractTransactions.callSmartContractWithPrivacyGroupId(\n+            eventEmitter.getContractAddress(),\n+            eventEmitter.store(BigInteger.valueOf(VALUE_SET)).encodeFunctionCall(),\n+            groupCreatingPrivacyNode.getTransactionSigningKey(),\n+            POW_CHAIN_ID,\n+            groupCreatingTenant,\n+            privacyGroupId);\n+    final String storeTransactionHash = groupCreatingPrivacyNode.execute(storeTransaction);\n+\n+    groupCreatingPrivacyNode.execute(\n+        privacyTransactions.getPrivateTransactionReceipt(storeTransactionHash));\n+\n+    // check that getting the filter changes works for a member\n+    groupCreatingPrivacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(tenantToBeRemoved));\n+\n+    assertThat(\n+            groupCreatingPrivacyNode.execute(\n+                privacyTransactions.getFilterChanges(privacyGroupId, filterId)))\n+        .hasSize(1);\n+\n+    groupCreatingPrivacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(groupCreatingTenant));\n+    final CallPrivateSmartContractFunction store2Transaction =\n+        privateContractTransactions.callSmartContractWithPrivacyGroupId(\n+            eventEmitter.getContractAddress(),\n+            eventEmitter.store(BigInteger.valueOf(VALUE_SET)).encodeFunctionCall(),\n+            groupCreatingPrivacyNode.getTransactionSigningKey(),\n+            POW_CHAIN_ID,\n+            groupCreatingTenant,\n+            privacyGroupId);\n+    final String store2TransactionHash = groupCreatingPrivacyNode.execute(store2Transaction);\n+\n+    groupCreatingPrivacyNode.execute(\n+        privacyTransactions.getPrivateTransactionReceipt(store2TransactionHash));\n+\n+    // now remove from privacy group\n+    final String removeTransactionHash =\n+        removeFromPrivacyGroup(\n+            privacyGroupId,\n+            groupCreatingPrivacyNode,\n+            groupCreatingTenant,\n+            Credentials.create(groupCreatingPrivacyNode.getTransactionSigningKey()),\n+            tenantToBeRemoved);\n+    groupCreatingPrivacyNode.execute(\n+        privacyTransactions.getPrivateTransactionReceipt(removeTransactionHash));\n+\n+    // check that it does not work anymore when member has been removed\n+    groupCreatingPrivacyNodeBesu.useAuthenticationTokenInHeaderForJsonRpc(\n+        multiTenancyPrivacyNode.getTokenForTenant(tenantToBeRemoved));\n+    assertThatThrownBy(\n+            () ->\n+                groupCreatingPrivacyNode.execute(\n+                    privacyTransactions.getFilterChanges(privacyGroupId, filterId)))\n+        .hasMessageContaining(\"Unauthorized\");\n+  }\n+\n+  private String createOnChainPrivacyGroup(final MultiTenancyPrivacyGroup group) {\n+    final List<MultiTenancyPrivacyNode> multiTenancyPrivacyNodes = group.getPrivacyNodes();\n+    final MultiTenancyPrivacyNode groupCreatorMultiTenancyPrivacyNode =\n+        multiTenancyPrivacyNodes.get(0);\n+    final PrivacyNode groupCreatorNode = group.getGroupCreatingPrivacyNode();\n+    final String groupCreatorTenant = group.getGroupCreatingTenant();\n+    final List<String> members = group.getTenants();\n+    final String token = groupCreatorMultiTenancyPrivacyNode.getTokenForTenant(groupCreatorTenant);\n+    final CreateOnChainPrivacyGroupTransaction createTx =\n+        privacyTransactions.createOnChainPrivacyGroup(\n+            groupCreatorNode, groupCreatorTenant, members, token);\n+\n+    final PrivacyRequestFactory.PrivxCreatePrivacyGroupResponse createResponse =\n+        groupCreatorNode.execute(createTx);\n+    final String privacyGroupId = createResponse.getPrivacyGroupId();\n+\n+    final List<Base64String> base64StringList =\n+        members.stream().map(Base64String::wrap).collect(Collectors.toList());\n+    for (final MultiTenancyPrivacyNode mtpn : multiTenancyPrivacyNodes) {\n+      final PrivacyNode privacyNode = mtpn.getPrivacyNode();\n+      for (final String tenant : mtpn.getTenants()) {\n+        if (members.contains(tenant)) {\n+          privacyNode\n+              .getBesu()\n+              .useAuthenticationTokenInHeaderForJsonRpc(mtpn.getTokenForTenant(tenant));\n+          privacyNode.verify(onChainPrivacyGroupExists(privacyGroupId, base64StringList));\n+        }\n+      }\n+    }\n+    groupCreatorNode.getBesu().useAuthenticationTokenInHeaderForJsonRpc(token);\n+    final String commitmentHash =\n+        callGetParticipantsMethodAndReturnCommitmentHash(\n+            privacyGroupId, groupCreatorNode, groupCreatorTenant);\n+    final PrivateTransactionReceipt expectedReceipt =\n+        buildExpectedAddMemberTransactionReceipt(\n+            privacyGroupId, groupCreatorNode, groupCreatorTenant, members.toArray(new String[] {}));\n+\n+    for (final MultiTenancyPrivacyNode mtpn : multiTenancyPrivacyNodes) {\n+      final PrivacyNode privacyNode = mtpn.getPrivacyNode();\n+      for (final String tenant : mtpn.getTenants()) {\n+        if (members.contains(tenant)) {\n+          privacyNode\n+              .getBesu()\n+              .useAuthenticationTokenInHeaderForJsonRpc(mtpn.getTokenForTenant(tenant));\n+          privacyNode.verify(\n+              privateTransactionVerifier.validPrivateTransactionReceipt(\n+                  commitmentHash, expectedReceipt));\n+        }\n+      }\n+    }\n+\n+    return privacyGroupId;\n+  }\n+\n+  private String removeFromPrivacyGroup(\n+      final String privacyGroupId,\n+      final PrivacyNode node,\n+      final String nodeRemovingMember,\n+      final Credentials signer,\n+      final String memberBeingRemoved) {\n+    return node.execute(\n+        privacyTransactions.removeFromPrivacyGroup(\n+            privacyGroupId, nodeRemovingMember, signer, memberBeingRemoved));\n+  }\n+\n+  //  @Test\n+  //  public void privGetPrivateTransactionSuccessShouldReturnExpectedPrivateTransaction()\n+  //      throws JsonProcessingException {\n+  //    final PrivateTransaction validSignedPrivateTransaction =\n+  //        getValidSignedPrivateTransaction(senderAddress);\n+  //\n+  //    receiveEnclaveStub(validSignedPrivateTransaction);\n+  //    retrievePrivacyGroupEnclaveStub();\n+  //    sendEnclaveStub(KEY1);\n+  //\n+  //    final Hash transactionHash =\n+  //        node.execute(\n+  //            privacyTransactions.sendRawTransaction(\n+  //                getRLPOutput(validSignedPrivateTransaction).encoded().toHexString()));\n+  //    node.verify(priv.getSuccessfulTransactionReceipt(transactionHash));\n+  //    node.verify(priv.getPrivateTransaction(transactionHash, validSignedPrivateTransaction));\n+  //  }\n+  //\n+  //  @Test\n+  //  public void privCreatePrivacyGroupSuccessShouldReturnNewId() throws JsonProcessingException {\n+  //    createPrivacyGroupEnclaveStub();\n+  //\n+  //    node.verify(\n+  //        priv.createPrivacyGroup(\n+  //            List.of(KEY1, KEY2, KEY3), \"GroupName\", \"Group description.\", PRIVACY_GROUP_ID));\n+  //  }\n+  //\n+  //  @Test\n+  //  public void privDeletePrivacyGroupSuccessShouldReturnId() throws JsonProcessingException {\n+  //    retrievePrivacyGroupEnclaveStub();\n+  //    deletePrivacyGroupEnclaveStub();\n+  //\n+  //    node.verify(priv.deletePrivacyGroup(PRIVACY_GROUP_ID));\n+  //  }\n+  //\n+  //  @Test\n+  //  public void privFindPrivacyGroupSuccessShouldReturnExpectedGroupMembership()\n+  //      throws JsonProcessingException {\n+  //    final List<PrivacyGroup> groupMembership =\n+  //        List.of(\n+  //            testPrivacyGroup(singletonList(ENCLAVE_KEY), PrivacyGroup.Type.PANTHEON),\n+  //            testPrivacyGroup(singletonList(ENCLAVE_KEY), PrivacyGroup.Type.PANTHEON),\n+  //            testPrivacyGroup(singletonList(ENCLAVE_KEY), PrivacyGroup.Type.PANTHEON));\n+  //\n+  //    findPrivacyGroupEnclaveStub(groupMembership);\n+  //\n+  //    node.verify(priv.findPrivacyGroup(groupMembership.size(), ENCLAVE_KEY));\n+  //  }\n+  //\n+  //  @Test\n+  //  public void eeaSendRawTransactionSuccessShouldReturnPrivateTransactionHash()\n+  //      throws JsonProcessingException {\n+  //    final PrivateTransaction validSignedPrivateTransaction =\n+  //        getValidSignedPrivateTransaction(senderAddress);\n+  //\n+  //    retrievePrivacyGroupEnclaveStub();\n+  //    sendEnclaveStub(KEY1);\n+  //    receiveEnclaveStub(validSignedPrivateTransaction);\n+  //\n+  //    node.verify(\n+  //        priv.eeaSendRawTransaction(\n+  //            getRLPOutput(validSignedPrivateTransaction).encoded().toHexString()));\n+  //  }\n+  //\n+  //  @Test\n+  //  public void privGetTransactionCountSuccessShouldReturnExpectedTransactionCount()\n+  //      throws JsonProcessingException {\n+  //    final PrivateTransaction validSignedPrivateTransaction =\n+  //        getValidSignedPrivateTransaction(senderAddress);\n+  //    final String accountAddress = validSignedPrivateTransaction.getSender().toHexString();\n+  //    final BytesValueRLPOutput rlpOutput = getRLPOutput(validSignedPrivateTransaction);\n+  //\n+  //    retrievePrivacyGroupEnclaveStub();\n+  //    sendEnclaveStub(KEY1);\n+  //    receiveEnclaveStub(validSignedPrivateTransaction);\n+  //\n+  //    node.verify(priv.getTransactionCount(accountAddress, PRIVACY_GROUP_ID, 0));\n+  //    final Hash transactionReceipt =\n+  //        node.execute(privacyTransactions.sendRawTransaction(rlpOutput.encoded().toHexString()));\n+  //\n+  //    node.verify(priv.getSuccessfulTransactionReceipt(transactionReceipt));\n+  //    node.verify(priv.getTransactionCount(accountAddress, PRIVACY_GROUP_ID, 1));\n+  //  }\n+  //\n+  //  @Test\n+  //  public void privDistributeRawTransactionSuccessShouldReturnEnclaveKey()\n+  //      throws JsonProcessingException {\n+  //    final String enclaveResponseKeyBytes = Bytes.wrap(Bytes.fromBase64String(KEY1)).toString();\n+  //\n+  //    retrievePrivacyGroupEnclaveStub();\n+  //    sendEnclaveStub(KEY1);\n+  //\n+  //    node.verify(\n+  //        priv.distributeRawTransaction(\n+  //\n+  // getRLPOutput(getValidSignedPrivateTransaction(senderAddress)).encoded().toHexString(),\n+  //            enclaveResponseKeyBytes));\n+  //  }\n+  //\n+  //  @Test\n+  //  public void privGetTransactionReceiptSuccessShouldReturnTransactionReceiptAfterMined()\n+  //      throws JsonProcessingException {\n+  //    final PrivateTransaction validSignedPrivateTransaction =\n+  //        getValidSignedPrivateTransaction(senderAddress);\n+  //    final BytesValueRLPOutput rlpOutput = getRLPOutput(validSignedPrivateTransaction);\n+  //\n+  //    retrievePrivacyGroupEnclaveStub();\n+  //    sendEnclaveStub(KEY1);\n+  //    receiveEnclaveStub(validSignedPrivateTransaction);\n+  //\n+  //    final Hash transactionReceipt =\n+  //        node.execute(privacyTransactions.sendRawTransaction(rlpOutput.encoded().toHexString()));\n+  //\n+  //    node.verify(priv.getSuccessfulTransactionReceipt(transactionReceipt));\n+  //  }\n+  //\n+  //  @Test\n+  //  public void privGetEeaTransactionCountSuccessShouldReturnExpectedTransactionCount()\n+  //      throws JsonProcessingException {\n+  //    final PrivateTransaction validSignedPrivateTransaction =\n+  //        getValidSignedPrivateTransaction(senderAddress);\n+  //    final String accountAddress = validSignedPrivateTransaction.getSender().toHexString();\n+  //    final String senderAddressBase64 =\n+  // Base64.encode(Bytes.wrap(accountAddress.getBytes(UTF_8)));\n+  //    final BytesValueRLPOutput rlpOutput = getRLPOutput(validSignedPrivateTransaction);\n+  //    final List<PrivacyGroup> groupMembership =\n+  //        List.of(testPrivacyGroup(emptyList(), PrivacyGroup.Type.LEGACY));\n+  //\n+  //    retrievePrivacyGroupEnclaveStub();\n+  //    sendEnclaveStub(KEY1);\n+  //    receiveEnclaveStub(validSignedPrivateTransaction);\n+  //    findPrivacyGroupEnclaveStub(groupMembership);\n+  //\n+  //    node.verify(priv.getTransactionCount(accountAddress, PRIVACY_GROUP_ID, 0));\n+  //    final Hash transactionHash =\n+  //        node.execute(privacyTransactions.sendRawTransaction(rlpOutput.encoded().toHexString()));\n+  //\n+  //    node.verify(priv.getSuccessfulTransactionReceipt(transactionHash));\n+  //\n+  //    final String privateFrom = ENCLAVE_KEY;\n+  //    final String[] privateFor = {senderAddressBase64};\n+  //    node.verify(priv.getEeaTransactionCount(accountAddress, privateFrom, privateFor, 1));\n+  //  }\n+  //\n+  //  private void findPrivacyGroupEnclaveStub(final List<PrivacyGroup> groupMembership)\n+  //      throws JsonProcessingException {\n+  //    final String findGroupResponse = mapper.writeValueAsString(groupMembership);\n+  //    stubFor(post(\"/findPrivacyGroup\").willReturn(ok(findGroupResponse)));\n+  //  }\n+  //\n+  //  private void createPrivacyGroupEnclaveStub() throws JsonProcessingException {\n+  //    final String createGroupResponse =\n+  //        mapper.writeValueAsString(testPrivacyGroup(emptyList(), PrivacyGroup.Type.PANTHEON));\n+  //    stubFor(post(\"/createPrivacyGroup\").willReturn(ok(createGroupResponse)));\n+  //  }\n+  //\n+  //  private void deletePrivacyGroupEnclaveStub() throws JsonProcessingException {\n+  //    final String deleteGroupResponse = mapper.writeValueAsString(PRIVACY_GROUP_ID);\n+  //    stubFor(post(\"/deletePrivacyGroup\").willReturn(ok(deleteGroupResponse)));\n+  //  }\n+  //\n+  //  private void retrievePrivacyGroupEnclaveStub() throws JsonProcessingException {\n+  //    final String retrieveGroupResponse =\n+  //        mapper.writeValueAsString(\n+  //            testPrivacyGroup(List.of(ENCLAVE_KEY), PrivacyGroup.Type.PANTHEON));\n+  //    stubFor(post(\"/retrievePrivacyGroup\").willReturn(ok(retrieveGroupResponse)));\n+  //  }\n+  //\n+  //  private void sendEnclaveStub(final String testKey) throws JsonProcessingException {\n+  //    final String sendResponse = mapper.writeValueAsString(new SendResponse(testKey));\n+  //    stubFor(post(\"/send\").willReturn(ok(sendResponse)));\n+  //  }\n+  //\n+  //  private void receiveEnclaveStub(final PrivateTransaction privTx) throws\n+  // JsonProcessingException {\n+  //    final BytesValueRLPOutput rlpOutput = getRLPOutputForReceiveResponse(privTx);\n+  //    final String senderKey = privTx.getPrivateFrom().toBase64String();\n+  //    final String receiveResponse =\n+  //        mapper.writeValueAsString(\n+  //            new ReceiveResponse(\n+  //                rlpOutput.encoded().toBase64String().getBytes(UTF_8), PRIVACY_GROUP_ID,\n+  // senderKey));\n+  //    stubFor(post(\"/receive\").willReturn(ok(receiveResponse)));\n+  //  }\n+  //\n+  //  private BytesValueRLPOutput getRLPOutputForReceiveResponse(\n+  //      final PrivateTransaction privateTransaction) {\n+  //    final BytesValueRLPOutput bvrlpo = new BytesValueRLPOutput();\n+  //    privateTransaction.writeTo(bvrlpo);\n+  //    return bvrlpo;\n+  //  }\n+  //\n+  //  private BytesValueRLPOutput getRLPOutput(final PrivateTransaction privateTransaction) {\n+  //    final BytesValueRLPOutput bvrlpo = new BytesValueRLPOutput();\n+  //    privateTransaction.writeTo(bvrlpo);\n+  //    return bvrlpo;\n+  //  }\n+  //\n+  //  private PrivacyGroup testPrivacyGroup(\n+  //      final List<String> groupMembers, final PrivacyGroup.Type groupType) {\n+  //    return new PrivacyGroup(PRIVACY_GROUP_ID, groupType, \"test\", \"testGroup\", groupMembers);\n+  //  }\n+  //\n+  //  private static PrivateTransaction getValidSignedPrivateTransaction(final Address\n+  // senderAddress) {\n+  //    return PrivateTransaction.builder()\n+  //        .nonce(0)\n+  //        .gasPrice(Wei.ZERO)\n+  //        .gasLimit(3000000)\n+  //        .to(null)\n+  //        .value(Wei.ZERO)\n+  //        .payload(Bytes.wrap(new byte[] {}))\n+  //        .sender(senderAddress)\n+  //        .chainId(BigInteger.valueOf(2018))\n+  //        .privateFrom(Bytes.fromBase64String(ENCLAVE_KEY))\n+  //        .restriction(Restriction.RESTRICTED)\n+  //        .privacyGroupId(Bytes.fromBase64String(PRIVACY_GROUP_ID))\n+  //        .signAndBuild(TEST_KEY);\n+  //  }", "originalCommit": "4b8f36e8c799c06adb74354deb08acfc5754fd7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5NzI2OA==", "url": "https://github.com/hyperledger/besu/pull/1422#discussion_r501397268", "bodyText": "Done", "author": "pinges", "createdAt": "2020-10-08T01:23:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI5MDEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI5MDUzNg==", "url": "https://github.com/hyperledger/besu/pull/1422#discussion_r501290536", "bodyText": "Remove commented line?", "author": "lucassaldanha", "createdAt": "2020-10-07T20:30:07Z", "path": "acceptance-tests/tests/src/test/java/org/hyperledger/besu/tests/web3j/privacy/OnChainPrivacyAcceptanceTestBase.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.tests.web3j.privacy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.hyperledger.besu.ethereum.privacy.group.OnChainGroupManagement.GET_PARTICIPANTS_METHOD_SIGNATURE;\n+\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.results.Quantity;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyAcceptanceTestBase;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyNode;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.condition.ExpectValidOnChainPrivacyGroupCreated;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.transaction.CreateOnChainPrivacyGroupTransaction;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.privacy.PrivacyRequestFactory;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.web3j.protocol.besu.response.privacy.PrivateTransactionReceipt;\n+import org.web3j.protocol.core.methods.response.TransactionReceipt;\n+import org.web3j.tx.Contract;\n+import org.web3j.utils.Base64String;\n+\n+public class OnChainPrivacyAcceptanceTestBase extends PrivacyAcceptanceTestBase {\n+\n+  protected String createOnChainPrivacyGroup(final PrivacyNode... members) {\n+    final List<String> addresses =\n+        Arrays.asList(members).stream().map(m -> m.getEnclaveKey()).collect(Collectors.toList());\n+    return createOnChainPrivacyGroup(members[0].getEnclaveKey(), addresses, members);\n+  }\n+\n+  /**\n+   * Crete an onchain privacy group. The privacy group id will be randomly generated.\n+   *\n+   * <p>This method also checks that each node member has successfully processed the transaction and\n+   * has the expected list of member for the group.\n+   *\n+   * @param members the list of members of the privacy group. The first member of the list will be\n+   *     the creator of the group.\n+   * @return the id of the privacy group\n+   */\n+  protected String createOnChainPrivacyGroup(\n+      final String privateFrom, final List<String> addresses, final PrivacyNode... members) {\n+\n+    final PrivacyNode groupCreator = members[0];\n+\n+    final CreateOnChainPrivacyGroupTransaction createTx =\n+        privacyTransactions.createOnChainPrivacyGroup(groupCreator, privateFrom, addresses);\n+\n+    final PrivacyRequestFactory.PrivxCreatePrivacyGroupResponse createResponse =\n+        groupCreator.execute(createTx);\n+    final String privacyGroupId = createResponse.getPrivacyGroupId();\n+\n+    final List<Base64String> membersEnclaveKeys =\n+        Arrays.stream(members)\n+            .map(m -> Base64String.wrap(m.getEnclaveKey()))\n+            .collect(Collectors.toList());\n+\n+    for (final PrivacyNode member : members) {\n+      member.verify(onChainPrivacyGroupExists(privacyGroupId, membersEnclaveKeys));\n+    }\n+\n+    final String commitmentHash =\n+        callGetParticipantsMethodAndReturnCommitmentHash(privacyGroupId, groupCreator, privateFrom);\n+    final PrivateTransactionReceipt expectedReceipt =\n+        buildExpectedAddMemberTransactionReceipt(\n+            privacyGroupId, groupCreator, addresses.toArray(new String[] {}));\n+\n+    for (final PrivacyNode member : members) {\n+      member.verify(\n+          privateTransactionVerifier.validPrivateTransactionReceipt(\n+              commitmentHash, expectedReceipt));\n+    }\n+\n+    return privacyGroupId;\n+  }\n+\n+  protected String callGetParticipantsMethodAndReturnCommitmentHash(\n+      final String privacyGroupId, final PrivacyNode groupCreator, final String privateFrom) {\n+    return groupCreator.execute(\n+        privateContractTransactions.callOnChainPermissioningSmartContract(\n+            Address.ONCHAIN_PRIVACY_PROXY.toHexString(),\n+            GET_PARTICIPANTS_METHOD_SIGNATURE.toString(),\n+            //                +\n+            // Bytes.fromBase64String(groupCreator.getEnclaveKey()).toUnprefixedHexString(),", "originalCommit": "4b8f36e8c799c06adb74354deb08acfc5754fd7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5NzQ5MA==", "url": "https://github.com/hyperledger/besu/pull/1422#discussion_r501397490", "bodyText": "Done", "author": "pinges", "createdAt": "2020-10-08T01:24:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI5MDUzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMwNjY4OQ==", "url": "https://github.com/hyperledger/besu/pull/1422#discussion_r501306689", "bodyText": "nit: if we're changing key1pub -> key1pubs, should we do the same ie key1key -> key1keys?", "author": "macfarla", "createdAt": "2020-10-07T20:59:48Z", "path": "testutil/src/main/java/org/hyperledger/orion/testutil/OrionTestHarnessFactory.java", "diffHunk": "@@ -18,36 +18,59 @@\n \n import java.io.IOException;\n import java.nio.file.Path;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n \n public class OrionTestHarnessFactory {\n \n-  public static OrionTestHarness create(final Path tempDir, final OrionKeyConfiguration orionConfig)\n-      throws IOException {\n+  public static OrionTestHarness create(\n+      final Path tempDir, final OrionKeyConfiguration orionConfig) {\n     return create(\n         tempDir,\n-        orionConfig.getPubKeyPath(),\n-        orionConfig.getPrivKeyPath(),\n+        orionConfig.getPubKeyPaths(),\n+        orionConfig.getPrivKeyPaths(),\n         Collections.emptyList());\n   }\n \n   public static OrionTestHarness create(\n       final Path tempDir,\n-      final String pubKeyPath,\n-      final String privKeyPath,\n-      final List<String> othernodes)\n-      throws IOException {\n-    final Path key1pub = copyResource(pubKeyPath, tempDir.resolve(pubKeyPath));\n-    final Path key1key = copyResource(privKeyPath, tempDir.resolve(privKeyPath));\n-\n-    return create(tempDir, key1pub, key1key, othernodes);\n+      final String[] pubKeyPaths,\n+      final String[] privKeyPaths,\n+      final List<String> othernodes) {\n+    final Path[] pubKeys =\n+        Arrays.stream(pubKeyPaths)\n+            .map(\n+                (pk) -> {\n+                  try {\n+                    return copyResource(pk, tempDir.resolve(pk));\n+                  } catch (final IOException e) {\n+                    throw new RuntimeException(e);\n+                  }\n+                })\n+            .toArray(Path[]::new);\n+    final Path[] privKeys =\n+        Arrays.stream(privKeyPaths)\n+            .map(\n+                (pk) -> {\n+                  try {\n+                    return copyResource(pk, tempDir.resolve(pk));\n+                  } catch (final IOException e) {\n+                    throw new RuntimeException(e);\n+                  }\n+                })\n+            .toArray(Path[]::new);\n+\n+    return create(tempDir, pubKeys, privKeys, othernodes);\n   }\n \n   public static OrionTestHarness create(\n-      final Path tempDir, final Path key1pub, final Path key1key, final List<String> othernodes) {\n+      final Path tempDir,\n+      final Path[] key1pubs,\n+      final Path[] key1key,", "originalCommit": "4b8f36e8c799c06adb74354deb08acfc5754fd7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5NzkxMA==", "url": "https://github.com/hyperledger/besu/pull/1422#discussion_r501397910", "bodyText": "Done", "author": "pinges", "createdAt": "2020-10-08T01:26:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMwNjY4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzOTI3NA==", "url": "https://github.com/hyperledger/besu/pull/1422#discussion_r501339274", "bodyText": "justAlice doesn't seem like the right name. Maybe privacyGroup ?", "author": "macfarla", "createdAt": "2020-10-07T22:12:12Z", "path": "acceptance-tests/tests/src/test/java/org/hyperledger/besu/tests/acceptance/privacy/multitenancy/OnChainMultiTenancyAcceptanceTest.java", "diffHunk": "@@ -0,0 +1,697 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.tests.acceptance.privacy.multitenancy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.tests.acceptance.dsl.node.BesuNode;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyNode;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.account.PrivacyAccountResolver;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.contract.CallPrivateSmartContractFunction;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.transaction.CreateOnChainPrivacyGroupTransaction;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.util.LogFilterJsonParameter;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.perm.PermissioningTransactions;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.privacy.PrivacyRequestFactory;\n+import org.hyperledger.besu.tests.web3j.generated.EventEmitter;\n+import org.hyperledger.besu.tests.web3j.privacy.OnChainPrivacyAcceptanceTestBase;\n+\n+import java.math.BigInteger;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.web3j.crypto.Credentials;\n+import org.web3j.protocol.besu.response.privacy.PrivateTransactionReceipt;\n+import org.web3j.protocol.core.methods.response.EthCall;\n+import org.web3j.utils.Base64String;\n+\n+public class OnChainMultiTenancyAcceptanceTest extends OnChainPrivacyAcceptanceTestBase {\n+\n+  private static final String eventEmitterDeployed =\n+      \"0x6080604052600436106100565763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416633fa4f245811461005b5780636057361d1461008257806367e404ce146100ae575b600080fd5b34801561006757600080fd5b506100706100ec565b60408051918252519081900360200190f35b34801561008e57600080fd5b506100ac600480360360208110156100a557600080fd5b50356100f2565b005b3480156100ba57600080fd5b506100c3610151565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b60025490565b604080513381526020810183905281517fc9db20adedc6cf2b5d25252b101ab03e124902a73fcb12b753f3d1aaa2d8f9f5929181900390910190a16002556001805473ffffffffffffffffffffffffffffffffffffffff191633179055565b60015473ffffffffffffffffffffffffffffffffffffffff169056fea165627a7a72305820c7f729cb24e05c221f5aa913700793994656f233fe2ce3b9fd9a505ea17e8d8a0029\";\n+\n+  private static final PermissioningTransactions permissioningTransactions =\n+      new PermissioningTransactions();\n+  private static final long VALUE_SET = 10L;\n+\n+  private PrivacyNode alice;\n+  private MultiTenancyPrivacyNode aliceMultiTenancyPrivacyNode;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    alice =\n+        privacyBesu.createOnChainPrivacyGroupEnabledMinerNode(\n+            \"node1\", PrivacyAccountResolver.MULTI_TENANCY, Address.PRIVACY, true);\n+    final BesuNode aliceBesu = alice.getBesu();\n+    privacyCluster.startNodes(alice);\n+    final String alice1Token =\n+        aliceBesu.execute(permissioningTransactions.createSuccessfulLogin(\"user\", \"pegasys\"));\n+    aliceBesu.useAuthenticationTokenInHeaderForJsonRpc(alice1Token);\n+    final String alice2Token =\n+        aliceBesu.execute(permissioningTransactions.createSuccessfulLogin(\"user2\", \"Password2\"));\n+    final String alice3Token =\n+        aliceBesu.execute(permissioningTransactions.createSuccessfulLogin(\"user3\", \"Password3\"));\n+    privacyCluster.awaitPeerCount(alice);\n+\n+    final String alice1EnclaveKey = alice.getOrion().getPublicKeys().get(0);\n+    final String alice2EnclaveKey = alice.getOrion().getPublicKeys().get(1);\n+    final String alice3EnclaveKey = alice.getOrion().getPublicKeys().get(2);\n+\n+    aliceMultiTenancyPrivacyNode = new MultiTenancyPrivacyNode(alice);\n+    aliceMultiTenancyPrivacyNode\n+        .addTenantWithToken(alice1EnclaveKey, alice1Token)\n+        .addTenantWithToken(alice2EnclaveKey, alice2Token)\n+        .addTenantWithToken(alice3EnclaveKey, alice3Token);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    privacyCluster.close();\n+  }\n+\n+  @Test\n+  public void createPrivacyGroup() {\n+    createOnChainPrivacyGroup(alice);\n+  }\n+\n+  @Test\n+  public void createPrivacyWithAllTenants() {\n+    final MultiTenancyPrivacyGroup justAlice = new MultiTenancyPrivacyGroup();", "originalCommit": "4b8f36e8c799c06adb74354deb08acfc5754fd7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5ODQ3Nw==", "url": "https://github.com/hyperledger/besu/pull/1422#discussion_r501398477", "bodyText": "Done", "author": "pinges", "createdAt": "2020-10-08T01:28:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzOTI3NA=="}], "type": "inlineReview"}, {"oid": "c585e014d518b5432107bb16e2cf86186016f204", "url": "https://github.com/hyperledger/besu/commit/c585e014d518b5432107bb16e2cf86186016f204", "message": "changes after PR comments\n\nSigned-off-by: Stefan Pingel <stefan.pingel@consensys.net>", "committedDate": "2020-10-08T01:55:06Z", "type": "commit"}, {"oid": "18e415a1c49b48b94884e62065e12f7e1ca0c0b2", "url": "https://github.com/hyperledger/besu/commit/18e415a1c49b48b94884e62065e12f7e1ca0c0b2", "message": "Merge branch 'master' into addATsForOnChainMultiTenancy", "committedDate": "2020-10-08T01:56:08Z", "type": "commit"}, {"oid": "55ba9168f46b956b39b75510024c9ce72cd2f48c", "url": "https://github.com/hyperledger/besu/commit/55ba9168f46b956b39b75510024c9ce72cd2f48c", "message": "fix runner\n\nSigned-off-by: Stefan Pingel <stefan.pingel@consensys.net>", "committedDate": "2020-10-08T02:19:52Z", "type": "commit"}, {"oid": "1f959ea601b73f10859a58d22ab37621db706314", "url": "https://github.com/hyperledger/besu/commit/1f959ea601b73f10859a58d22ab37621db706314", "message": "spotless\n\nSigned-off-by: Stefan Pingel <stefan.pingel@consensys.net>", "committedDate": "2020-10-08T02:28:44Z", "type": "commit"}, {"oid": "254db0c823f07045413186a461a6e3fe216f95d9", "url": "https://github.com/hyperledger/besu/commit/254db0c823f07045413186a461a6e3fe216f95d9", "message": "add changelog entry\n\nSigned-off-by: Stefan Pingel <stefan.pingel@consensys.net>", "committedDate": "2020-10-08T03:07:49Z", "type": "commit"}]}