{"pr_number": 1652, "pr_title": "[REFACTOR] Clearly Separate Common MessageFrame Fields", "pr_createdAt": "2020-12-02T15:19:26Z", "pr_url": "https://github.com/hyperledger/besu/pull/1652", "timeline": [{"oid": "6132a395a6b59faf47ee17452bbdb8754d704528", "url": "https://github.com/hyperledger/besu/commit/6132a395a6b59faf47ee17452bbdb8754d704528", "message": "remove redundancy\n\nSigned-off-by: Ratan Rai Sur <ratan.r.sur@gmail.com>", "committedDate": "2020-12-02T15:14:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI2NzE3MA==", "url": "https://github.com/hyperledger/besu/pull/1652#discussion_r534267170", "bodyText": "This winds up creating a new List object for each iteration, and creates a loop that can simply be unrolled to what is originally there.  Yes, it's two more lines of code but a lot less VM work.", "author": "shemnon", "createdAt": "2020-12-02T15:40:43Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/MessageFrame.java", "diffHunk": "@@ -320,9 +320,7 @@ private MessageFrame(\n     this.transactionHash = transactionHash;\n     this.revertReason = revertReason;\n \n-    this.warmedUpAddresses = new HashSet<>();\n-    warmedUpAddresses.add(sender);\n-    warmedUpAddresses.add(contract);\n+    this.warmedUpAddresses = new HashSet<>(List.of(sender, contract));", "originalCommit": "6132a395a6b59faf47ee17452bbdb8754d704528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI2ODYxNw==", "url": "https://github.com/hyperledger/besu/pull/1652#discussion_r534268617", "bodyText": "Sure thing, I'll remove it", "author": "RatanRSur", "createdAt": "2020-12-02T15:42:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI2NzE3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI2OTEwMA==", "url": "https://github.com/hyperledger/besu/pull/1652#discussion_r534269100", "bodyText": "This reduces the readability.  The if block makes it clear that there is one path for contract creation and one for normal transactions.  Without that you need to have deep knowledge of the transactions that a contract creation TX lacks a to field.  I don't mind the common field refactoring but I think the over-use of optional here reduces the accessibility to future maintainers.", "author": "shemnon", "createdAt": "2020-12-02T15:43:13Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/MainnetTransactionProcessor.java", "diffHunk": "@@ -295,77 +296,61 @@ public TransactionProcessingResult processTransaction(\n           intrinsicGas);\n \n       final WorldUpdater worldUpdater = worldState.updater();\n-      final MessageFrame initialFrame;\n       final Deque<MessageFrame> messageFrameStack = new ArrayDeque<>();\n-      final ReturnStack returnStack = new ReturnStack();\n-\n-      if (transaction.isContractCreation()) {\n-        final Address contractAddress =\n-            Address.contractAddress(senderAddress, sender.getNonce() - 1L);\n-\n-        initialFrame =\n-            MessageFrame.builder()\n-                .type(MessageFrame.Type.CONTRACT_CREATION)\n-                .messageFrameStack(messageFrameStack)\n-                .returnStack(returnStack)\n-                .blockchain(blockchain)\n-                .worldState(worldUpdater.updater())\n-                .initialGas(gasAvailable)\n-                .address(contractAddress)\n-                .originator(senderAddress)\n-                .contract(contractAddress)\n-                .contractAccountVersion(createContractAccountVersion)\n-                .gasPrice(transactionGasPrice)\n-                .inputData(Bytes.EMPTY)\n-                .sender(senderAddress)\n-                .value(transaction.getValue())\n-                .apparentValue(transaction.getValue())\n-                .code(new Code(transaction.getPayload()))\n-                .blockHeader(blockHeader)\n-                .depth(0)\n-                .completer(c -> {})\n-                .miningBeneficiary(miningBeneficiary)\n-                .blockHashLookup(blockHashLookup)\n-                .isPersistingPrivateState(isPersistingPrivateState)\n-                .maxStackSize(maxStackSize)\n-                .transactionHash(transaction.getHash())\n-                .privateMetadataUpdater(privateMetadataUpdater)\n-                .build();\n-\n-      } else {\n-        final Address to = transaction.getTo().get();\n-        final Account contract = worldState.get(to);\n-\n-        initialFrame =\n-            MessageFrame.builder()\n-                .type(MessageFrame.Type.MESSAGE_CALL)\n-                .messageFrameStack(messageFrameStack)\n-                .returnStack(returnStack)\n-                .blockchain(blockchain)\n-                .worldState(worldUpdater.updater())\n-                .initialGas(gasAvailable)\n-                .address(to)\n-                .originator(senderAddress)\n-                .contract(to)\n-                .contractAccountVersion(\n-                    contract != null ? contract.getVersion() : Account.DEFAULT_VERSION)\n-                .gasPrice(transactionGasPrice)\n-                .inputData(transaction.getPayload())\n-                .sender(senderAddress)\n-                .value(transaction.getValue())\n-                .apparentValue(transaction.getValue())\n-                .code(new Code(contract != null ? contract.getCode() : Bytes.EMPTY))\n-                .blockHeader(blockHeader)\n-                .depth(0)\n-                .completer(c -> {})\n-                .miningBeneficiary(miningBeneficiary)\n-                .blockHashLookup(blockHashLookup)\n-                .maxStackSize(maxStackSize)\n-                .isPersistingPrivateState(isPersistingPrivateState)\n-                .transactionHash(transaction.getHash())\n-                .privateMetadataUpdater(privateMetadataUpdater)\n-                .build();\n-      }\n+      final MessageFrame.Builder commonMessageFrameBuilder =\n+          MessageFrame.builder()\n+              .messageFrameStack(messageFrameStack)\n+              .maxStackSize(maxStackSize)\n+              .returnStack(new ReturnStack())\n+              .blockchain(blockchain)\n+              .worldState(worldUpdater.updater())\n+              .initialGas(gasAvailable)\n+              .originator(senderAddress)\n+              .gasPrice(transactionGasPrice)\n+              .sender(senderAddress)\n+              .value(transaction.getValue())\n+              .apparentValue(transaction.getValue())\n+              .blockHeader(blockHeader)\n+              .depth(0)\n+              .completer(__ -> {})\n+              .miningBeneficiary(miningBeneficiary)\n+              .blockHashLookup(blockHashLookup)\n+              .isPersistingPrivateState(isPersistingPrivateState)\n+              .transactionHash(transaction.getHash())\n+              .privateMetadataUpdater(privateMetadataUpdater);\n+\n+      final MessageFrame initialFrame =\n+          transaction\n+              .getTo()\n+              .map(\n+                  to -> {\n+                    final Optional<Account> maybeContract = Optional.ofNullable(worldState.get(to));\n+                    return commonMessageFrameBuilder\n+                        .type(MessageFrame.Type.MESSAGE_CALL)\n+                        .address(to)\n+                        .contract(to)\n+                        .contractAccountVersion(\n+                            maybeContract\n+                                .map(AccountState::getVersion)\n+                                .orElse(Account.DEFAULT_VERSION))\n+                        .inputData(transaction.getPayload())\n+                        .code(\n+                            new Code(maybeContract.map(AccountState::getCode).orElse(Bytes.EMPTY)));\n+                  })\n+              .orElseGet(", "originalCommit": "6132a395a6b59faf47ee17452bbdb8754d704528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI3MTUyNQ==", "url": "https://github.com/hyperledger/besu/pull/1652#discussion_r534271525", "bodyText": "Yeah, it's true that the isContractCreation method does help with understanding what's going on. I can change the uncommon part back to the if/else.", "author": "RatanRSur", "createdAt": "2020-12-02T15:46:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI2OTEwMA=="}], "type": "inlineReview"}, {"oid": "ead076cb0fb429b50548c5aa8a519f9b43a09a10", "url": "https://github.com/hyperledger/besu/commit/ead076cb0fb429b50548c5aa8a519f9b43a09a10", "message": "reunroll loop\n\nSigned-off-by: Ratan Rai Sur <ratan.r.sur@gmail.com>", "committedDate": "2020-12-02T15:43:33Z", "type": "commit"}, {"oid": "1a6cade75e7186e0ee63cc3edecc894dc802321d", "url": "https://github.com/hyperledger/besu/commit/1a6cade75e7186e0ee63cc3edecc894dc802321d", "message": "switch back to if/else\n\nSigned-off-by: Ratan Rai Sur <ratan.r.sur@gmail.com>", "committedDate": "2020-12-02T15:50:38Z", "type": "commit"}]}