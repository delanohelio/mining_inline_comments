{"pr_number": 8637, "pr_title": "ISPN-12242 BlockingManager add reentrant blocking scheduler", "pr_createdAt": "2020-08-20T20:15:05Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8637", "timeline": [{"oid": "44be0b50d8c09a9abda7f81310ec8bf607752773", "url": "https://github.com/infinispan/infinispan/commit/44be0b50d8c09a9abda7f81310ec8bf607752773", "message": "ISPN-12242 BlockingManager add reentrant blocking scheduler", "committedDate": "2020-08-20T20:14:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI1NTI1OA==", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r479255258", "bodyText": "IMO this isn't accurate: BlockHound doesn't dictate that this method is blocking, we mark it as blocking in CommonsTestBlockHoundIntegration. I would have preferred something like \"Empty method marked as blocking. BlockHound will throw an exception if this method is called from a non-blocking thread, unless called from an excluded method.\"", "author": "danberindei", "createdAt": "2020-08-28T12:50:24Z", "path": "commons-test/src/main/java/org/infinispan/commons/test/BlockHoundHelper.java", "diffHunk": "@@ -87,4 +87,15 @@ public static Executor ensureNonBlockingExecutor() {\n    public static Executor allowBlockingExecutor() {\n       return BlockHoundHelper::allowBlocking;\n    }\n+\n+   /**\n+    * Helper method that \"blocks\" as dictated by block hound but in actuality does nothing. This is useful to detect", "originalCommit": "44be0b50d8c09a9abda7f81310ec8bf607752773", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzE0MDUzMA==", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r573140530", "bodyText": "I wasn't trying to say that Blockhound dictated this method is blocking but rather this method is blocking per BlockHound guidelines, which is just a registration as such. However, writing that I can see your confusion.", "author": "wburns", "createdAt": "2021-02-09T18:41:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI1NTI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI3MTkzNA==", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r479271934", "bodyText": "I think it would have been better to say \"Wrap a publisher and subscribe to it in a blocking thread. If the returned publisher is subscribed in a non-blocking thread, it will also emit the wrapped publisher's elements on non-blocking threads, otherwise there is no guarantee.\"\nAlthough TBH I'm not sure if it's worth saying anything about the thread where the wrapped publisher's elements are emitted, since the whole point of using this method is that the caller doesn't know/care if it runs in a blocking thread or in a non-blocking thread.", "author": "danberindei", "createdAt": "2020-08-28T13:09:35Z", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingManager.java", "diffHunk": "@@ -174,10 +174,13 @@\n    <V> CompletionStage<V> continueOnNonBlockingThread(CompletionStage<V> delay, Object traceId);\n \n    /**\n-    * Provided a publisher that is known to block when subscribed to, this ensures that the publisher is subscribed\n-    * on the blocking executor and any values published are observed on a non blocking thread. Note that if a\n-    * blocking thread subscribes to the publisher these additional threads are not used and the entire Publisher\n-    * is subscribed and observed on the invoking thread.\n+    * Provided a publisher that is known to block when subscribed to. Thus if the thread that subscribes in a non", "originalCommit": "44be0b50d8c09a9abda7f81310ec8bf607752773", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzE1MTY2MQ==", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r573151661", "bodyText": "They should certainly care. The point of this method is to only do the subscribe and request part in a blocking thread but any published values should be on the non blocking thread. We don't want to expose the blocking thread to the returned Publisher.", "author": "wburns", "createdAt": "2021-02-09T18:58:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI3MTkzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzY1ODY0Nw==", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r573658647", "bodyText": "I would argue they should not care, because the javadoc later says \"If, however, the subscribing thread is a blocking thread no threading changes will be done, which means the publisher will be subscribed to on the invoking thread. In this case values have no guarantee as to which thread they are observed on, dependent solely on how the Publisher publishes them.\"\nNonBlockingStore.publishKeys() doesn't say anything about the observing thread/scheduler either. It only says says subscribing should not block the caller.\nIf the callers do expect values to be observed on a non-blocking thread, then I think we should either call observeOn() when the caller is blocking as well, or assert that the caller thread is non-blocking.", "author": "danberindei", "createdAt": "2021-02-10T11:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI3MTkzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Njk1NjI5NA==", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r576956294", "bodyText": "NonBlockingStore.publishKeys() doesn't say anything about the observing thread/scheduler either. It only says says subscribing should not block the caller.\n\nYes, because the implementors shouldn't care about the thread it is done as long as it doesn't block. The SPI is more for the implementors not the invokers in my book.", "author": "wburns", "createdAt": "2021-02-16T16:24:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI3MTkzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzMzODczNg==", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r577338736", "bodyText": "I agree the SPI javadoc is for store implementors. But if the javadoc doesn't explicitly tell them that the publisher they return must emit its values on a non-blocking thread, they may not see any reason to use BlockingManager.blockingPublisher(), and emit the values on a blocking thread instead. Or they may call BlockingManager.blockingPublisher(), but from a blocking thread, causing the values to be emitted on the same blocking thread.\nThat's why I think it's important for the SPI to be explicit about what kind of thread it expects the result publisher to emit its values on, not just to recommend using BlockingManager.blockingPublisher().\nOTOH if the thread where the values are emitted doesn't matter, then BlockingManager.blockingPublisher() shouldn't make any promises about it either, because stores are its only users (at least for now).", "author": "danberindei", "createdAt": "2021-02-17T05:40:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI3MTkzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzg1MDExNg==", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r577850116", "bodyText": "I agree the SPI javadoc is for store implementors. But if the javadoc doesn't explicitly tell them that the publisher they return must emit its values on a non-blocking thread, they may not see any reason to use BlockingManager.blockingPublisher(), and emit the values on a blocking thread instead. Or they may call BlockingManager.blockingPublisher(), but from a blocking thread, causing the values to be emitted on the same blocking thread.\n\nImplementers can publish on a blocking thread if they want, as long as the invoking thread is a blocking thread. We could be more specific and say don't block the invoking thread if it is invoked in a non blocking thread, but I stayed away from that as it puts a lot of burden on the implementer to understand that. That is why I insulated all of that to the BlockingManager in the first place and the user just uses that if the operation can block and it will transparently handle which thread to subscribe/publish based on the invoking thread and which part of it is blocking.\n\nThat's why I think it's important for the SPI to be explicit about what kind of thread it expects the result publisher to emit its values on, not just to recommend using BlockingManager.blockingPublisher().\n\nI disagree. If the operation can block they should use BlockingManager to isolate the parts that can block and that code will do the right thing.\n\nOTOH if the thread where the values are emitted doesn't matter, then BlockingManager.blockingPublisher() shouldn't make any promises about it either, because stores are its only users (at least for now).\n\nIt does matter, it matters based on the invoking thread, which is what BlockingManager handles for the user. And I foresee other uses of blockingPublisher as that becomes more mainstream in the code.", "author": "wburns", "createdAt": "2021-02-17T18:35:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI3MTkzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTI4MjExOA==", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r579282118", "bodyText": "Implementers can publish on a blocking thread if they want, as long as the invoking thread is a blocking thread.\n\nExcept this requirement is not documented, so implementors will ignore it.\nE.g. in RemoteStore, it seems to be ok for publishEntries() to emit the entries on a remote cache thread, although that means there could be more CPU-bound threads in use than the user set in their configuration (or that we picked based on the number of CPUs).\nBut say someone is writing a store like RemoteStore, only publishEntries() also has to log the entries to a local file before it emits them. According to the javadoc, they could submit the logging to the blocking thread pool and emit the entry on the same thread. remoteCache.publishEntries() does not block, so they don't see any reason to use BlockingManager.blockingPublisher().", "author": "danberindei", "createdAt": "2021-02-19T15:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI3MTkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI3OTY3MA==", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r479279670", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * a {@link CompletionStage} with a value of null which completes on a non-blocking thread. This method is designed\n          \n          \n            \n                * a {@link CompletionStage CompletionStage<Void>} which completes on a non-blocking thread. This method is designed\n          \n      \n    \n    \n  \n\nAlso, I'm not sure what qualifies as a side-effect for a publisher, but the one usage of this method has the same behaviour on Subscription.request(), not just on Publisher.subscribe().", "author": "danberindei", "createdAt": "2020-08-28T13:18:04Z", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingManager.java", "diffHunk": "@@ -186,7 +189,8 @@\n \n    /**\n     * Subscribes to the provided blocking publisher using the the blocking executor, ignoring all elements and returning\n-    * a {@link CompletionStage} with a value of null which completes on a non-blocking thread.\n+    * a {@link CompletionStage} with a value of null which completes on a non-blocking thread. This method is designed", "originalCommit": "44be0b50d8c09a9abda7f81310ec8bf607752773", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzE0NTcyNQ==", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r573145725", "bodyText": "Side effect would be something like doOnNext etc. Also in regards to subscribe vs request that is a bit pedantic as I was assuming they would be the same, especially since we subscribe using Integer.MAX_VALUE For the request. Did you want me to write more info for that?", "author": "wburns", "createdAt": "2021-02-09T18:49:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI3OTY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzY3NTk1Mg==", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r573675952", "bodyText": "I wouldn't add more info, I'd rather remove the \"This method is designed ...\" sentence completely because I don't think it adds much. If doOnNext() qualifies as \"when subscribed\", then I assume anything the publisher does qualifies.\nI would also change the next sentences a bit. Assuming we do need the method to behave differently depending on the caller thread (similar to the blockingPublisher() discussion), we should be upfront about it and say \"If the current thread is X, then Y happens.\" instead of saying Y \"always\" happens and then backtracking on that promise.\nIn general, I would also like it if the javadoc was using the reactive streams terms more precisely, e.g. instead of saying \"everything including subscription, publication and collection of values will be done on the current thread\" I'd say \"the publisher is subscribed on the current thread and the values are not observed on any particular thread\".", "author": "danberindei", "createdAt": "2021-02-10T12:07:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI3OTY3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTM4ODc1Mw==", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r571388753", "bodyText": "BlockingManager thinks the subscribe thread is non-blocking and the blocking executor is actually a mock that doesn't do anything, so I'm not sure how the implementation could make this assert fail.", "author": "danberindei", "createdAt": "2021-02-06T09:03:31Z", "path": "core/src/test/java/org/infinispan/util/concurrent/BlockingManagerTest.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.util.concurrent;\n+\n+import static org.testng.AssertJUnit.assertFalse;\n+import static org.testng.AssertJUnit.assertTrue;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+\n+import org.infinispan.commons.test.BlockHoundHelper;\n+import org.infinispan.test.AbstractInfinispanTest;\n+import org.infinispan.test.Mocks;\n+import org.mockito.Mockito;\n+import org.reactivestreams.Publisher;\n+import org.testng.annotations.Test;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+import io.reactivex.rxjava3.processors.AsyncProcessor;\n+import io.reactivex.rxjava3.processors.UnicastProcessor;\n+import io.reactivex.rxjava3.subscribers.TestSubscriber;\n+\n+@Test(groups = \"unit\", testName = \"util.concurrent.BlockingManagerTest\")\n+public class BlockingManagerTest extends AbstractInfinispanTest {\n+   Executor nonBlockingExecutor;\n+   Executor blockingExecutor;\n+\n+   public void initializeMocks() {\n+      nonBlockingExecutor = Mockito.mock(Executor.class, Mockito.withSettings()\n+            .defaultAnswer(Mocks.runWithExecutorAnswer(BlockHoundHelper.ensureNonBlockingExecutor())));\n+      blockingExecutor = Mockito.mock(Executor.class, Mockito.withSettings()\n+            .defaultAnswer(Mocks.runWithExecutorAnswer(BlockHoundHelper.allowBlockingExecutor())));\n+   }\n+\n+   private BlockingManager createBlockingManager(boolean blockingInvocation) {\n+      initializeMocks();\n+\n+      BlockingManagerImpl blockingManager = new BlockingManagerImpl() {\n+         @Override\n+         protected boolean isCurrentThreadBlocking() {\n+            return blockingInvocation;\n+         }\n+      };\n+\n+      blockingManager.nonBlockingExecutor = nonBlockingExecutor;\n+      blockingManager.blockingExecutor = blockingExecutor;\n+      blockingManager.start();\n+\n+      return blockingManager;\n+   }\n+\n+   public void testBlockingPublishToVoidStageInvokedBlockingThread() {\n+      BlockingManager blockingManager = createBlockingManager(true);\n+\n+      CompletionStage<Void> stage = blockingManager.blockingPublisherToVoidStage(Flowable.fromArray(new Object[] { 1, 2, 3 })\n+            .doOnNext(BlockHoundHelper::blockingConsume), null);\n+      assertTrue(CompletionStages.isCompletedSuccessfully(stage));\n+\n+      // We should not have used any executor as we were a blocking thread already\n+      Mockito.verifyZeroInteractions(nonBlockingExecutor, blockingExecutor);\n+   }\n+\n+   public void testBlockingPublishToVoidStageInvokedNonBlockingThread() {\n+      BlockingManager blockingManager = createBlockingManager(false);\n+\n+      CompletionStage<Void> stage = blockingManager.blockingPublisherToVoidStage(Flowable.just(1)\n+            .doOnNext(BlockHoundHelper::blockingConsume), null);\n+      assertTrue(CompletionStages.isCompletedSuccessfully(stage));\n+\n+      Mockito.verify(blockingExecutor).execute(Mockito.any());\n+      Mockito.verifyZeroInteractions(nonBlockingExecutor);\n+   }\n+\n+   public void testBlockingPublishToVoidStageInvokedNonBlockingThreadCompleteAfterSubscribe() {\n+      BlockingManager blockingManager = createBlockingManager(false);\n+\n+      AsyncProcessor<Object> processor = AsyncProcessor.create();\n+\n+      processor.onNext(1);\n+\n+      CompletionStage<Void> stage = blockingManager.blockingPublisherToVoidStage(processor\n+            .doOnNext(BlockHoundHelper::blockingConsume), null);\n+      assertFalse(CompletionStages.isCompletedSuccessfully(stage));\n+\n+      processor.onComplete();\n+\n+      assertTrue(CompletionStages.isCompletedSuccessfully(stage));\n+\n+      Mockito.verify(blockingExecutor).execute(Mockito.any());\n+      Mockito.verify(nonBlockingExecutor).execute(Mockito.any());\n+   }\n+\n+   public void testBlockingPublisherInvokedBlockingThread() {\n+      BlockingManager blockingManager = createBlockingManager(true);\n+\n+      Publisher<Integer> publisher = blockingManager.blockingPublisher(Flowable.just(1)\n+            .doOnNext(BlockHoundHelper::blockingConsume));\n+\n+      TestSubscriber<Integer> subscriber = TestSubscriber.create();\n+      publisher.subscribe(subscriber);\n+\n+      subscriber.assertComplete();\n+\n+      // We should not have used any executor as we were a blocking thread already\n+      Mockito.verifyZeroInteractions(nonBlockingExecutor, blockingExecutor);\n+   }\n+\n+   public void testBlockingPublisherInvokedBlockingThreadCompleteAfterSubscribe() {\n+      BlockingManager blockingManager = createBlockingManager(true);\n+\n+      AsyncProcessor<Integer> processor = AsyncProcessor.create();\n+\n+      processor.onNext(1);\n+\n+      Publisher<Integer> publisher = blockingManager.blockingPublisher(processor\n+            .doOnNext(BlockHoundHelper::blockingConsume));\n+\n+      TestSubscriber<Integer> subscriber = TestSubscriber.create();\n+      publisher.subscribe(subscriber);\n+\n+      subscriber.assertNotComplete();\n+\n+      processor.onComplete();\n+\n+      subscriber.assertComplete();\n+\n+      // We should not have used any executor as we were a blocking thread already for onNext and onComplete is done on\n+      // the invoking thread as it happened after publish\n+      Mockito.verifyZeroInteractions(nonBlockingExecutor, blockingExecutor);\n+   }\n+\n+   public void testBlockingPublisherInvokedNonBlockingThread() {\n+      BlockingManager blockingManager = createBlockingManager(false);\n+\n+      Publisher<Integer> publisher = blockingManager.blockingPublisher(Flowable.just(1)\n+            .doOnNext(BlockHoundHelper::blockingConsume));\n+\n+      TestSubscriber<Integer> subscriber = TestSubscriber.create();\n+      Flowable.fromPublisher(publisher)\n+            // We should observe any value of returned Publisher from `blockingPublisher` on a non blocking thread\n+            .doOnNext(ignore -> assertTrue(BlockHoundHelper.currentThreadRequiresNonBlocking()))", "originalCommit": "44be0b50d8c09a9abda7f81310ec8bf607752773", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzE1NTM5MA==", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r573155390", "bodyText": "Yeah, that is the point, it thinks the thread is non blocking, thus it submits the publisher to a blocking thread for the subscribe part. Thus we invoke blockingConsume to verify if it is in a blocking thread. Then the returned publisher has the doOnNext to verify that is done in a non blocking thread as we have to publish values on the non blocking thread. I think the confusion is the same as the prior comment above.  #8637 (comment)", "author": "wburns", "createdAt": "2021-02-09T19:04:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTM4ODc1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzY4MjgwMw==", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r573682803", "bodyText": "@wburns I was trying to say that blockingExecutor is just a mock, so it does not run the callback at all, therefore the assertTrue() call can't fail.\nBut I see I was wrong: blockingExecutor not used only as a mock, to verify which methods are being called, it also executes the task as a normal executor would.", "author": "danberindei", "createdAt": "2021-02-10T12:19:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTM4ODc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTM4OTcwNg==", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r571389706", "bodyText": "Is there any particular reason for using AsyncProcessor (compared to e.g. UnicastProcess or PublishProcessor) and for calling processor.onNext(1) before subscribing?", "author": "danberindei", "createdAt": "2021-02-06T09:07:33Z", "path": "core/src/test/java/org/infinispan/util/concurrent/BlockingManagerTest.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.util.concurrent;\n+\n+import static org.testng.AssertJUnit.assertFalse;\n+import static org.testng.AssertJUnit.assertTrue;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+\n+import org.infinispan.commons.test.BlockHoundHelper;\n+import org.infinispan.test.AbstractInfinispanTest;\n+import org.infinispan.test.Mocks;\n+import org.mockito.Mockito;\n+import org.reactivestreams.Publisher;\n+import org.testng.annotations.Test;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+import io.reactivex.rxjava3.processors.AsyncProcessor;\n+import io.reactivex.rxjava3.processors.UnicastProcessor;\n+import io.reactivex.rxjava3.subscribers.TestSubscriber;\n+\n+@Test(groups = \"unit\", testName = \"util.concurrent.BlockingManagerTest\")\n+public class BlockingManagerTest extends AbstractInfinispanTest {\n+   Executor nonBlockingExecutor;\n+   Executor blockingExecutor;\n+\n+   public void initializeMocks() {\n+      nonBlockingExecutor = Mockito.mock(Executor.class, Mockito.withSettings()\n+            .defaultAnswer(Mocks.runWithExecutorAnswer(BlockHoundHelper.ensureNonBlockingExecutor())));\n+      blockingExecutor = Mockito.mock(Executor.class, Mockito.withSettings()\n+            .defaultAnswer(Mocks.runWithExecutorAnswer(BlockHoundHelper.allowBlockingExecutor())));\n+   }\n+\n+   private BlockingManager createBlockingManager(boolean blockingInvocation) {\n+      initializeMocks();\n+\n+      BlockingManagerImpl blockingManager = new BlockingManagerImpl() {\n+         @Override\n+         protected boolean isCurrentThreadBlocking() {\n+            return blockingInvocation;\n+         }\n+      };\n+\n+      blockingManager.nonBlockingExecutor = nonBlockingExecutor;\n+      blockingManager.blockingExecutor = blockingExecutor;\n+      blockingManager.start();\n+\n+      return blockingManager;\n+   }\n+\n+   public void testBlockingPublishToVoidStageInvokedBlockingThread() {\n+      BlockingManager blockingManager = createBlockingManager(true);\n+\n+      CompletionStage<Void> stage = blockingManager.blockingPublisherToVoidStage(Flowable.fromArray(new Object[] { 1, 2, 3 })\n+            .doOnNext(BlockHoundHelper::blockingConsume), null);\n+      assertTrue(CompletionStages.isCompletedSuccessfully(stage));\n+\n+      // We should not have used any executor as we were a blocking thread already\n+      Mockito.verifyZeroInteractions(nonBlockingExecutor, blockingExecutor);\n+   }\n+\n+   public void testBlockingPublishToVoidStageInvokedNonBlockingThread() {\n+      BlockingManager blockingManager = createBlockingManager(false);\n+\n+      CompletionStage<Void> stage = blockingManager.blockingPublisherToVoidStage(Flowable.just(1)\n+            .doOnNext(BlockHoundHelper::blockingConsume), null);\n+      assertTrue(CompletionStages.isCompletedSuccessfully(stage));\n+\n+      Mockito.verify(blockingExecutor).execute(Mockito.any());\n+      Mockito.verifyZeroInteractions(nonBlockingExecutor);\n+   }\n+\n+   public void testBlockingPublishToVoidStageInvokedNonBlockingThreadCompleteAfterSubscribe() {\n+      BlockingManager blockingManager = createBlockingManager(false);\n+\n+      AsyncProcessor<Object> processor = AsyncProcessor.create();", "originalCommit": "44be0b50d8c09a9abda7f81310ec8bf607752773", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzE1NzE0MA==", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r573157140", "bodyText": "Is there any particular reason for using AsyncProcessor (compared to e.g. UnicastProcess or PublishProcessor)\n\nNot in particular, but AsyncProcessor only allows a single value and the test only required one.\n\nand for calling processor.onNext(1) before subscribing?\n\nYes, this matters because if we do onNext before subscribing the subscribe \"thread\" will publish the value, where as if we called onNext afterwards the invoking thread would be the one publishing it.", "author": "wburns", "createdAt": "2021-02-09T19:07:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTM4OTcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzY4MzUzMg==", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r573683532", "bodyText": "@wburns would it make sense to add more tests that call processor.onNext(1) afterwards, to test more scenarios?", "author": "danberindei", "createdAt": "2021-02-10T12:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTM4OTcwNg=="}], "type": "inlineReview"}]}