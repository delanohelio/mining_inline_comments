{"pr_number": 8063, "pr_title": "ISPN-11480 Call EmbeddedCacheManager#stop in shutdown hook", "pr_createdAt": "2020-03-17T16:13:24Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8063", "timeline": [{"oid": "18c89550b3f7dec761fbfc45f7377cf16410fb47", "url": "https://github.com/infinispan/infinispan/commit/18c89550b3f7dec761fbfc45f7377cf16410fb47", "message": "ISPN-11480 StatefulSet rolling upgrade test", "committedDate": "2020-03-17T16:14:11Z", "type": "forcePushed"}, {"oid": "6ef45021b501e5e5aebecd05261f4adef9ef5dda", "url": "https://github.com/infinispan/infinispan/commit/6ef45021b501e5e5aebecd05261f4adef9ef5dda", "message": "ISPN-11485 Enable server logs after shutdownHook has been called", "committedDate": "2020-03-19T10:39:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE0NTI1MA==", "url": "https://github.com/infinispan/infinispan/pull/8063#discussion_r395145250", "bodyText": "A little too many \"in order to\" :)\nI'd say something like\n// Shutdown Log4jk context manually as we set shutdownHook=\"disable\" \n// Log4j's shutdownHook may run concurrently with our shutdownHook,\n// disabling logging before the server has finished stopping.", "author": "danberindei", "createdAt": "2020-03-19T16:11:20Z", "path": "server/runtime/src/main/java/org/infinispan/server/Server.java", "diffHunk": "@@ -408,12 +409,15 @@ private void localShutdown(ExitStatus exitStatus) {\n       }\n       // Shutdown the protocol servers in parallel\n       protocolServers.values().parallelStream().forEach(ProtocolServer::stop);\n-      cacheManagers.values().forEach(cm -> SecurityActions.stopCacheManager(cm));\n+      cacheManagers.values().forEach(SecurityActions::stopCacheManager);\n       this.status = ComponentStatus.TERMINATED;\n       // Don't wait for the scheduler to finish\n       if (scheduler != null) {\n          scheduler.shutdown();\n       }\n+      // Shutdown Log4jk context manually as we set shutdownHook=\"disable\" in order to disable the default Log4j\n+      // shutdownHook being registered in order to allow logging during server shutdown", "originalCommit": "6ef45021b501e5e5aebecd05261f4adef9ef5dda", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE0NzU2OA==", "url": "https://github.com/infinispan/infinispan/pull/8063#discussion_r395147568", "bodyText": "The comment seems superfluous now.\nMaybe we should call waitForClusterToForm(CACHE_NAME) before starting the joiner, too?", "author": "danberindei", "createdAt": "2020-03-19T16:14:31Z", "path": "core/src/test/java/org/infinispan/statetransfer/StatefulSetRollingUpgradeTest.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.infinispan.statetransfer;\n+\n+import static org.infinispan.commons.test.CommonsTestingUtil.tmpDirectory;\n+import static org.infinispan.test.fwk.TestCacheManagerFactory.createClusteredCacheManager;\n+\n+import java.io.File;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.partitionhandling.PartitionHandling;\n+import org.infinispan.test.MultipleCacheManagersTest;\n+import org.infinispan.test.fwk.CleanupAfterMethod;\n+import org.infinispan.test.fwk.TransportFlags;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Start cluster (A,B) redeploy after upgrade. Rolling upgrades always occur in the order B,A and A does not restart\n+ * until B has completed successfully.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+@CleanupAfterMethod\n+@Test(groups = \"functional\", testName = \"statetransfer.StateTransferRollingUpgradeTest\")\n+public class StatefulSetRollingUpgradeTest extends MultipleCacheManagersTest {\n+\n+   private static final String CACHE_NAME = \"testCache\";\n+   private static final int NUM_ROLLING_UPGRADES = 4;\n+\n+   private int numNodes;\n+\n+   @Override\n+   public Object[] factory() {\n+      return new Object[]{\n+            new StatefulSetRollingUpgradeTest().setNumNodes(2),\n+            new StatefulSetRollingUpgradeTest().setNumNodes(3),\n+            new StatefulSetRollingUpgradeTest().setNumNodes(4),\n+            new StatefulSetRollingUpgradeTest().setNumNodes(5)\n+      };\n+   }\n+\n+   private StatefulSetRollingUpgradeTest setNumNodes(int numNodes) {\n+      this.numNodes = numNodes;\n+      return this;\n+   }\n+\n+   @Override\n+   protected String[] parameterNames() {\n+      return new String[]{\"nodes\"};\n+   }\n+\n+   @Override\n+   protected Object[] parameterValues() {\n+      return new Object[]{numNodes};\n+   }\n+\n+   @Override\n+   protected void createCacheManagers() throws Throwable {\n+      cacheManagers = IntStream.range(0, numNodes).boxed().map(ignore -> (EmbeddedCacheManager) null).collect(Collectors.toList());\n+      Util.recursiveFileRemove(tmpDirectory(this.getClass().getSimpleName()));\n+\n+      for (int id = 0; id < numNodes; id++)\n+         createStatefulCacheManager(id);\n+\n+      waitForClusterToForm(CACHE_NAME);\n+   }\n+\n+   public void testStateTransferRestart() {\n+      for (int i = 0; i < NUM_ROLLING_UPGRADES; i++) {\n+         for (int j = numNodes - 1; j > -1; j--) {\n+            // Stop the cache manager in the same manner as via the ShutdownHook", "originalCommit": "6ef45021b501e5e5aebecd05261f4adef9ef5dda", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE0ODQ5OQ==", "url": "https://github.com/infinispan/infinispan/pull/8063#discussion_r395148499", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Test(groups = \"functional\", testName = \"statetransfer.StateTransferRollingUpgradeTest\")\n          \n          \n            \n            @Test(groups = \"functional\", testName = \"statetransfer.StatefulSetRollingUpgradeTest\")", "author": "danberindei", "createdAt": "2020-03-19T16:15:49Z", "path": "core/src/test/java/org/infinispan/statetransfer/StatefulSetRollingUpgradeTest.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.infinispan.statetransfer;\n+\n+import static org.infinispan.commons.test.CommonsTestingUtil.tmpDirectory;\n+import static org.infinispan.test.fwk.TestCacheManagerFactory.createClusteredCacheManager;\n+\n+import java.io.File;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.partitionhandling.PartitionHandling;\n+import org.infinispan.test.MultipleCacheManagersTest;\n+import org.infinispan.test.fwk.CleanupAfterMethod;\n+import org.infinispan.test.fwk.TransportFlags;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Start cluster (A,B) redeploy after upgrade. Rolling upgrades always occur in the order B,A and A does not restart\n+ * until B has completed successfully.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+@CleanupAfterMethod\n+@Test(groups = \"functional\", testName = \"statetransfer.StateTransferRollingUpgradeTest\")", "originalCommit": "6ef45021b501e5e5aebecd05261f4adef9ef5dda", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "254780e774836b8e121ec9bd355f34553db2cabd", "url": "https://github.com/infinispan/infinispan/commit/254780e774836b8e121ec9bd355f34553db2cabd", "message": "ISPN-11480 Call EmbeddedCacheManager#stop in shutdown hook", "committedDate": "2020-03-20T13:23:06Z", "type": "commit"}, {"oid": "98950eebf8fd1182f9bab1697076f759ca9266e9", "url": "https://github.com/infinispan/infinispan/commit/98950eebf8fd1182f9bab1697076f759ca9266e9", "message": "ISPN-11480 StatefulSet rolling upgrade test", "committedDate": "2020-03-20T13:43:00Z", "type": "commit"}, {"oid": "47aed3e6a0a8f1e6ce915351422aa0d1e0f5bbe6", "url": "https://github.com/infinispan/infinispan/commit/47aed3e6a0a8f1e6ce915351422aa0d1e0f5bbe6", "message": "ISPN-11485 Enable server logs after shutdownHook has been called", "committedDate": "2020-03-20T13:43:00Z", "type": "commit"}, {"oid": "47aed3e6a0a8f1e6ce915351422aa0d1e0f5bbe6", "url": "https://github.com/infinispan/infinispan/commit/47aed3e6a0a8f1e6ce915351422aa0d1e0f5bbe6", "message": "ISPN-11485 Enable server logs after shutdownHook has been called", "committedDate": "2020-03-20T13:43:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEyNjA0Ng==", "url": "https://github.com/infinispan/infinispan/pull/8063#discussion_r398126046", "bodyText": "Guess I never knew we required log4j in the server.", "author": "wburns", "createdAt": "2020-03-25T19:49:14Z", "path": "server/runtime/src/main/java/org/infinispan/server/Server.java", "diffHunk": "@@ -409,12 +410,16 @@ private void localShutdown(ExitStatus exitStatus) {\n       }\n       // Shutdown the protocol servers in parallel\n       protocolServers.values().parallelStream().forEach(ProtocolServer::stop);\n-      cacheManagers.values().forEach(cm -> SecurityActions.stopCacheManager(cm));\n+      cacheManagers.values().forEach(SecurityActions::stopCacheManager);\n       this.status = ComponentStatus.TERMINATED;\n       // Don't wait for the scheduler to finish\n       if (scheduler != null) {\n          scheduler.shutdown();\n       }\n+      // Shutdown Log4jk context manually as we set shutdownHook=\"disable\"\n+      // Log4j's shutdownHook may run concurrently with our shutdownHook,\n+      // disabling logging before the server has finished stopping.\n+      LogManager.shutdown();", "originalCommit": "47aed3e6a0a8f1e6ce915351422aa0d1e0f5bbe6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}