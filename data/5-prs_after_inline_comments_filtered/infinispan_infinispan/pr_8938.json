{"pr_number": 8938, "pr_title": "ISPN-12261 Protocol Management", "pr_createdAt": "2020-12-15T14:26:00Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8938", "timeline": [{"oid": "181df780b61d9b4a3335ca8db4f524f3ca38b687", "url": "https://github.com/infinispan/infinispan/commit/181df780b61d9b4a3335ca8db4f524f3ca38b687", "message": "ISPN-12261 Protocol Management", "committedDate": "2020-12-16T11:02:05Z", "type": "forcePushed"}, {"oid": "2408978e15ae1deba20fc08529597f14b4fec2e2", "url": "https://github.com/infinispan/infinispan/commit/2408978e15ae1deba20fc08529597f14b4fec2e2", "message": "ISPN-12261 Protocol Management", "committedDate": "2020-12-16T12:40:41Z", "type": "forcePushed"}, {"oid": "3f1b28a1bd71e8b344e342e2005f10d464e757e2", "url": "https://github.com/infinispan/infinispan/commit/3f1b28a1bd71e8b344e342e2005f10d464e757e2", "message": "ISPN-12261 Protocol Management", "committedDate": "2020-12-16T12:51:00Z", "type": "forcePushed"}, {"oid": "6cb122cdc2d048827e3b28ba3b1361b2e98fa378", "url": "https://github.com/infinispan/infinispan/commit/6cb122cdc2d048827e3b28ba3b1361b2e98fa378", "message": "ISPN-12261 Protocol Management", "committedDate": "2020-12-16T16:52:18Z", "type": "forcePushed"}, {"oid": "30d4fbf64aa4da7cf717f7bf6ee00f387c217406", "url": "https://github.com/infinispan/infinispan/commit/30d4fbf64aa4da7cf717f7bf6ee00f387c217406", "message": "ISPN-12261 Protocol Management", "committedDate": "2020-12-16T20:19:01Z", "type": "forcePushed"}, {"oid": "a01bb78a64610ff3155c8ce66b7f29397f8d30d7", "url": "https://github.com/infinispan/infinispan/commit/a01bb78a64610ff3155c8ce66b7f29397f8d30d7", "message": "ISPN-12261 Protocol Management", "committedDate": "2020-12-21T12:36:16Z", "type": "forcePushed"}, {"oid": "e352773301aaed7019f536c498b37ae2cbbb6ca3", "url": "https://github.com/infinispan/infinispan/commit/e352773301aaed7019f536c498b37ae2cbbb6ca3", "message": "ISPN-12261 Protocol Management", "committedDate": "2020-12-21T16:35:51Z", "type": "forcePushed"}, {"oid": "56fcb8b29b563fc34e729682a008950210a4625f", "url": "https://github.com/infinispan/infinispan/commit/56fcb8b29b563fc34e729682a008950210a4625f", "message": "ISPN-12261 Protocol Management", "committedDate": "2020-12-22T08:26:52Z", "type": "forcePushed"}, {"oid": "da7c9a851cd8548afb943a7de7b0791a6d79a692", "url": "https://github.com/infinispan/infinispan/commit/da7c9a851cd8548afb943a7de7b0791a6d79a692", "message": "ISPN-12261 Protocol Management", "committedDate": "2020-12-22T08:44:46Z", "type": "forcePushed"}, {"oid": "a2d125f430d2f812627b2d2d6cf89567dcfd86a2", "url": "https://github.com/infinispan/infinispan/commit/a2d125f430d2f812627b2d2d6cf89567dcfd86a2", "message": "ISPN-12261 Protocol Management", "committedDate": "2020-12-22T11:13:15Z", "type": "forcePushed"}, {"oid": "2fa0de52b7c0fb0ca6f996f5e088e621c44ef6a9", "url": "https://github.com/infinispan/infinispan/commit/2fa0de52b7c0fb0ca6f996f5e088e621c44ef6a9", "message": "ISPN-12261 Protocol Management", "committedDate": "2020-12-22T14:33:18Z", "type": "forcePushed"}, {"oid": "7a444f66bcb5a8416e3b0fd7a46174b2e656f640", "url": "https://github.com/infinispan/infinispan/commit/7a444f66bcb5a8416e3b0fd7a46174b2e656f640", "message": "ISPN-12261 Protocol Management", "committedDate": "2020-12-22T17:18:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAxMTMzNw==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r548011337", "bodyText": "replace ALLOW->ACCEPT", "author": "wfink", "createdAt": "2020-12-23T15:24:51Z", "path": "cli/src/main/java/org/infinispan/cli/logging/Messages.java", "diffHunk": "@@ -237,4 +237,7 @@\n \n    @Message(value = \"Confirm the credential: \")\n    String credentialToolCredentialConfirm();\n+\n+   @Message(value = \"Filter rule '%s' is not in the format [ALLOW|REJECT]/{CIDR}\")", "originalCommit": "7a444f66bcb5a8416e3b0fd7a46174b2e656f640", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAxMTQ0Mw==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r548011443", "bodyText": "ALLOW will not work, also the help mention ACCEPT (same as netty) I would use that\nchange it to ACCEPT will work for me if use CLI like this \"server connector ipfilter set REST-rest-default --rules='ACCEPT/192.168.27.50/16'\"", "author": "wfink", "createdAt": "2020-12-23T15:25:06Z", "path": "client/rest-client/src/main/java/org/infinispan/client/rest/IpFilterRule.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package org.infinispan.client.rest;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+public class IpFilterRule {\n+   public enum RuleType {\n+      ALLOW,", "originalCommit": "7a444f66bcb5a8416e3b0fd7a46174b2e656f640", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAxMTY3MA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r548011670", "bodyText": "replace ALLOW->ACCEPT", "author": "wfink", "createdAt": "2020-12-23T15:25:36Z", "path": "cli/src/main/java/org/infinispan/cli/commands/rest/Connector.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.infinispan.cli.commands.rest;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandException;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Option;\n+import org.aesh.command.option.OptionList;\n+import org.infinispan.cli.activators.ConnectionActivator;\n+import org.infinispan.cli.commands.CliCommand;\n+import org.infinispan.cli.completers.ConnectorCompleter;\n+import org.infinispan.cli.completers.IpFilterRuleCompleter;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.logging.Messages;\n+import org.infinispan.cli.resources.Resource;\n+import org.infinispan.client.rest.IpFilterRule;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+@GroupCommandDefinition(name = Connector.CMD, description = \"Performs operations on protocol connectors\", activator = ConnectionActivator.class, groupCommands = {Connector.Ls.class, Connector.Describe.class, Connector.Start.class, Connector.Stop.class, Connector.IpFilter.class})\n+public class Connector extends CliCommand {\n+\n+   public static final String CMD = \"connector\";\n+   public static final String TYPE = \"type\";\n+   public static final String NAME = \"name\";\n+\n+   @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+   protected boolean help;\n+\n+   @Override\n+   public boolean isHelp() {\n+      return help;\n+   }\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+      // This command serves only to wrap the sub-commands\n+      invocation.println(invocation.getHelpInfo());\n+      return CommandResult.FAILURE;\n+   }\n+\n+   @CommandDefinition(name = \"ls\", description = \"Lists connectors\", activator = ConnectionActivator.class)\n+   public static class Ls extends RestCliCommand {\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connectorNames();\n+      }\n+   }\n+\n+   @CommandDefinition(name = \"describe\", description = \"Describes a connector\", activator = ConnectionActivator.class)\n+   public static class Describe extends RestCliCommand {\n+\n+      @Argument(required = true, completer = ConnectorCompleter.class)\n+      String name;\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connector(name);\n+      }\n+   }\n+\n+   @CommandDefinition(name = \"start\", description = \"Starts a connector\", activator = ConnectionActivator.class)\n+   public static class Start extends RestCliCommand {\n+\n+      @Argument(required = true, completer = ConnectorCompleter.class)\n+      String name;\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connectorStart(name);\n+      }\n+   }\n+\n+   @CommandDefinition(name = \"stop\", description = \"Stops a connector\", activator = ConnectionActivator.class)\n+   public static class Stop extends RestCliCommand {\n+\n+      @Argument(required = true, completer = ConnectorCompleter.class)\n+      String name;\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connectorStop(name);\n+      }\n+   }\n+\n+   @GroupCommandDefinition(name = \"ipfilter\", description = \"Manages connector IP filters\", activator = ConnectionActivator.class, groupCommands = {IpFilter.Ls.class, IpFilter.Clear.class, IpFilter.Set.class})\n+   public static class IpFilter extends CliCommand {\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      protected boolean isHelp() {\n+         return false;\n+      }\n+\n+      @Override\n+      protected CommandResult exec(ContextAwareCommandInvocation invocation) throws CommandException {\n+         return CommandResult.SUCCESS;\n+      }\n+\n+      @CommandDefinition(name = \"ls\", description = \"List all IP filters on a connector\", activator = ConnectionActivator.class)\n+      public static class Ls extends RestCliCommand {\n+\n+         @Argument(required = true, completer = ConnectorCompleter.class)\n+         String name;\n+\n+         @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+         protected boolean help;\n+\n+         @Override\n+         public boolean isHelp() {\n+            return help;\n+         }\n+\n+         @Override\n+         protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+            return client.server().connectorIpFilters(name);\n+         }\n+      }\n+\n+      @CommandDefinition(name = \"clear\", description = \"Removes all IP Filters from a connector\", activator = ConnectionActivator.class)\n+      public static class Clear extends RestCliCommand {\n+\n+         @Argument(required = true, completer = ConnectorCompleter.class)\n+         String name;\n+\n+         @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+         protected boolean help;\n+\n+         @Override\n+         public boolean isHelp() {\n+            return help;\n+         }\n+\n+         @Override\n+         protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+            return client.server().connectorIpFiltersClear(name);\n+         }\n+      }\n+\n+      @CommandDefinition(name = \"set\", description = \"Sets IP Filters on a connector\", activator = ConnectionActivator.class)\n+      public static class Set extends RestCliCommand {\n+\n+         @Argument(required = true, completer = ConnectorCompleter.class)\n+         String name;\n+\n+         @OptionList(description = \"One or more filter rules as \\\"[ALLOW|REJECT]/CIDR\\\"\", completer = IpFilterRuleCompleter.class, required = true)", "originalCommit": "7a444f66bcb5a8416e3b0fd7a46174b2e656f640", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAxMTc3OA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r548011778", "bodyText": "replace ALLOW->ACCEPT", "author": "wfink", "createdAt": "2020-12-23T15:25:48Z", "path": "cli/src/main/java/org/infinispan/cli/completers/IpFilterRuleCompleter.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package org.infinispan.cli.completers;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+public class IpFilterRuleCompleter extends EnumCompleter {\n+\n+   public enum IpFilterType {\n+      ALLOW,", "originalCommit": "7a444f66bcb5a8416e3b0fd7a46174b2e656f640", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ba24e8bcb3758e745ea3a8704516396b32521515", "url": "https://github.com/infinispan/infinispan/commit/ba24e8bcb3758e745ea3a8704516396b32521515", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-01-07T08:52:58Z", "type": "forcePushed"}, {"oid": "6f1b0acece57a34f3384413dad5a67cfa3b90413", "url": "https://github.com/infinispan/infinispan/commit/6f1b0acece57a34f3384413dad5a67cfa3b90413", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-01-07T09:22:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyMzQxOQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r553423419", "bodyText": "This line will cause a checkstyle error as it is unused", "author": "wfink", "createdAt": "2021-01-07T16:05:35Z", "path": "cli/src/main/java/org/infinispan/cli/commands/CLI.java", "diffHunk": "@@ -39,6 +39,7 @@\n import org.infinispan.cli.commands.rest.Backup;\n import org.infinispan.cli.commands.rest.Cas;\n import org.infinispan.cli.commands.rest.ClearCache;\n+import org.infinispan.cli.commands.rest.Connector;", "originalCommit": "6f1b0acece57a34f3384413dad5a67cfa3b90413", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5794bf693ddb1de3736206d3d5c9fedac106b7f1", "url": "https://github.com/infinispan/infinispan/commit/5794bf693ddb1de3736206d3d5c9fedac106b7f1", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-01-07T16:07:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM1NTU4Nw==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r557355587", "bodyText": "It seems like we have a discrepancy between our xml and CLI.\nThe CLI allows ip-filters  defined per connectors to be updated, however it's not possible to update those defined globally under <endpoints><ip-filter>\nShould we have a root endpoints command/rest endpoint to allow this level of configuration?\nSo the CLI would be as follows:\n$ cli.sh endpoints status hotrod\n$ cli.sh endpoints stop hotrod\n$ cli.sh endpoints start hotrod\n$ cli.sh endpoints ipfilter set .... # global filters\n$ cli.sh endpoints ipfilter --connector=hotrod set .... # hotrod specific filters\n\nI think this would need the rest endpoint to be updated to the following to allow for this flexibility:\n/v2/server/endpoints/ip-filter # global\n/v2/server/endpoints/connectors/{connector}\n/v2/server/endpoints/connectors/{connector}/ip-filter # connector specific\n\nThis would also have the advantage of allowing configuration at the endpoints level to be exposed in the future.", "author": "ryanemerson", "createdAt": "2021-01-14T12:20:45Z", "path": "cli/src/main/java/org/infinispan/cli/commands/rest/Connector.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.infinispan.cli.commands.rest;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandException;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Option;\n+import org.aesh.command.option.OptionList;\n+import org.infinispan.cli.activators.ConnectionActivator;\n+import org.infinispan.cli.commands.CliCommand;\n+import org.infinispan.cli.completers.ConnectorCompleter;\n+import org.infinispan.cli.completers.IpFilterRuleCompleter;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.logging.Messages;\n+import org.infinispan.cli.resources.Resource;\n+import org.infinispan.client.rest.IpFilterRule;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+@GroupCommandDefinition(name = Connector.CMD, description = \"Performs operations on protocol connectors\", activator = ConnectionActivator.class, groupCommands = {Connector.Ls.class, Connector.Describe.class, Connector.Start.class, Connector.Stop.class, Connector.IpFilter.class})\n+public class Connector extends CliCommand {", "originalCommit": "bf101e171fee1309245b3bc4934ced4b5ae9c97b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA4ODcwMQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r560088701", "bodyText": "Internal connector naming is what matters. In a default server:\n[\"REST-rest-default\",\"HotRod-hotrod-default\",\"endpoint-default\"]\n[bespin-13557@cluster//containers/default]> server connector describe endpoint-default \n{\n  \"name\" : \"endpoint-default\",\n  \"ip-filter-rules\" : [  ],\n  \"host\" : \"localhost\",\n  \"port\" : 11222,\n  \"local-connections\" : 1,\n  \"global-connections\" : 1,\n  \"io-threads\" : 16,\n  \"pending-tasks\" : 0,\n  \"total-bytes-read\" : 0,\n  \"total-bytes-written\" : 0,\n  \"send-buffer-size\" : 0,\n  \"receive-buffer-size\" : 0,\n  \"enabled\" : true\n}", "author": "tristantarrant", "createdAt": "2021-01-19T10:54:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM1NTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDEwNTQwMw==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r560105403", "bodyText": "Argh I see. For me it's counter-intuitive for the \"endpoint-default\" to be accessed via the \"connector\" field in the CLI, when <ip-filter> is a child of <endpoint> in the xml.\nAlso utilising the REST endpoint of /v2/server/connectors opposed to /v2/server/endpoints/ limits us if we add any additional child elements under <endpoints> that we want to expose in the future.", "author": "ryanemerson", "createdAt": "2021-01-19T11:22:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM1NTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjE1NjQ4MA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r566156480", "bodyText": "Well, the single port endpoint is a connector that multiplexes other connectors. Also, a hotrod connector assigned to a different socket binding, i.e. not part of a single port, is conceptually a top-level connector, even though it needs to be \"housed\" inside the endpoint element in the XML (something I'm not particularly fond of)", "author": "tristantarrant", "createdAt": "2021-01-28T14:54:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM1NTU4Nw=="}], "type": "inlineReview"}, {"oid": "65b1dcdbdbcf70702186b4dfd9ca19f114296b74", "url": "https://github.com/infinispan/infinispan/commit/65b1dcdbdbcf70702186b4dfd9ca19f114296b74", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-01-29T12:37:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAxNjk1Mg==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r568016952", "bodyText": "shouldn't we fail if null? All invocations of getServerStateManager expect it to be non-null.", "author": "pruivo", "createdAt": "2021-02-01T17:43:59Z", "path": "server/core/src/main/java/org/infinispan/server/core/AbstractProtocolServer.java", "diffHunk": "@@ -100,11 +101,10 @@ public void start(C configuration, EmbeddedCacheManager cacheManager) {\n       this.cacheManager = cacheManager;\n \n       BasicComponentRegistry bcr = SecurityActions.getGlobalComponentRegistry(cacheManager).getComponent(BasicComponentRegistry.class.getName());\n-      cacheIgnore = bcr.getComponent(CacheIgnoreManager.class).running();\n-      if (cacheIgnore == null) {\n-         throw new IllegalStateException(\"CacheIgnoreManager is a required component\");\n+      ComponentRef<ServerStateManager> stateManagerComponentRef = bcr.getComponent(ServerStateManager.class);\n+      if (stateManagerComponentRef != null) {", "originalCommit": "65b1dcdbdbcf70702186b4dfd9ca19f114296b74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU5MjU1MQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r568592551", "bodyText": "Because it's an optional component that only exists in the full server.", "author": "tristantarrant", "createdAt": "2021-02-02T13:17:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAxNjk1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAyNzQ3OA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r568027478", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since 12.0\n          \n          \n            \n             * @since 12.1", "author": "pruivo", "createdAt": "2021-02-01T17:59:52Z", "path": "cli/src/main/java/org/infinispan/cli/commands/rest/Connector.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.infinispan.cli.commands.rest;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandException;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Option;\n+import org.aesh.command.option.OptionList;\n+import org.infinispan.cli.activators.ConnectionActivator;\n+import org.infinispan.cli.commands.CliCommand;\n+import org.infinispan.cli.completers.ConnectorCompleter;\n+import org.infinispan.cli.completers.IpFilterRuleCompleter;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.logging.Messages;\n+import org.infinispan.cli.resources.Resource;\n+import org.infinispan.client.rest.IpFilterRule;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0", "originalCommit": "65b1dcdbdbcf70702186b4dfd9ca19f114296b74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAzMDQ0NA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r568030444", "bodyText": "shouldn't be failure? or maybe remove ls command and list the ip filter rules here.", "author": "pruivo", "createdAt": "2021-02-01T18:04:53Z", "path": "cli/src/main/java/org/infinispan/cli/commands/rest/Connector.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.infinispan.cli.commands.rest;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandException;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Option;\n+import org.aesh.command.option.OptionList;\n+import org.infinispan.cli.activators.ConnectionActivator;\n+import org.infinispan.cli.commands.CliCommand;\n+import org.infinispan.cli.completers.ConnectorCompleter;\n+import org.infinispan.cli.completers.IpFilterRuleCompleter;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.logging.Messages;\n+import org.infinispan.cli.resources.Resource;\n+import org.infinispan.client.rest.IpFilterRule;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+@GroupCommandDefinition(name = Connector.CMD, description = \"Performs operations on protocol connectors\", activator = ConnectionActivator.class, groupCommands = {Connector.Ls.class, Connector.Describe.class, Connector.Start.class, Connector.Stop.class, Connector.IpFilter.class})\n+public class Connector extends CliCommand {\n+\n+   public static final String CMD = \"connector\";\n+   public static final String TYPE = \"type\";\n+   public static final String NAME = \"name\";\n+\n+   @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+   protected boolean help;\n+\n+   @Override\n+   public boolean isHelp() {\n+      return help;\n+   }\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+      // This command serves only to wrap the sub-commands\n+      invocation.println(invocation.getHelpInfo());\n+      return CommandResult.FAILURE;\n+   }\n+\n+   @CommandDefinition(name = \"ls\", description = \"Lists connectors\", activator = ConnectionActivator.class)\n+   public static class Ls extends RestCliCommand {\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connectorNames();\n+      }\n+   }\n+\n+   @CommandDefinition(name = \"describe\", description = \"Describes a connector\", activator = ConnectionActivator.class)\n+   public static class Describe extends RestCliCommand {\n+\n+      @Argument(required = true, completer = ConnectorCompleter.class)\n+      String name;\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connector(name);\n+      }\n+   }\n+\n+   @CommandDefinition(name = \"start\", description = \"Starts a connector\", activator = ConnectionActivator.class)\n+   public static class Start extends RestCliCommand {\n+\n+      @Argument(required = true, completer = ConnectorCompleter.class)\n+      String name;\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connectorStart(name);\n+      }\n+   }\n+\n+   @CommandDefinition(name = \"stop\", description = \"Stops a connector\", activator = ConnectionActivator.class)\n+   public static class Stop extends RestCliCommand {\n+\n+      @Argument(required = true, completer = ConnectorCompleter.class)\n+      String name;\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connectorStop(name);\n+      }\n+   }\n+\n+   @GroupCommandDefinition(name = \"ipfilter\", description = \"Manages connector IP filters\", activator = ConnectionActivator.class, groupCommands = {IpFilter.Ls.class, IpFilter.Clear.class, IpFilter.Set.class})\n+   public static class IpFilter extends CliCommand {\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      protected boolean isHelp() {\n+         return false;\n+      }\n+\n+      @Override\n+      protected CommandResult exec(ContextAwareCommandInvocation invocation) throws CommandException {\n+         return CommandResult.SUCCESS;", "originalCommit": "65b1dcdbdbcf70702186b4dfd9ca19f114296b74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAzMDY3NQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r568030675", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     return false;\n          \n          \n            \n                     return help;", "author": "pruivo", "createdAt": "2021-02-01T18:05:14Z", "path": "cli/src/main/java/org/infinispan/cli/commands/rest/Connector.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.infinispan.cli.commands.rest;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandException;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Option;\n+import org.aesh.command.option.OptionList;\n+import org.infinispan.cli.activators.ConnectionActivator;\n+import org.infinispan.cli.commands.CliCommand;\n+import org.infinispan.cli.completers.ConnectorCompleter;\n+import org.infinispan.cli.completers.IpFilterRuleCompleter;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.logging.Messages;\n+import org.infinispan.cli.resources.Resource;\n+import org.infinispan.client.rest.IpFilterRule;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+@GroupCommandDefinition(name = Connector.CMD, description = \"Performs operations on protocol connectors\", activator = ConnectionActivator.class, groupCommands = {Connector.Ls.class, Connector.Describe.class, Connector.Start.class, Connector.Stop.class, Connector.IpFilter.class})\n+public class Connector extends CliCommand {\n+\n+   public static final String CMD = \"connector\";\n+   public static final String TYPE = \"type\";\n+   public static final String NAME = \"name\";\n+\n+   @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+   protected boolean help;\n+\n+   @Override\n+   public boolean isHelp() {\n+      return help;\n+   }\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+      // This command serves only to wrap the sub-commands\n+      invocation.println(invocation.getHelpInfo());\n+      return CommandResult.FAILURE;\n+   }\n+\n+   @CommandDefinition(name = \"ls\", description = \"Lists connectors\", activator = ConnectionActivator.class)\n+   public static class Ls extends RestCliCommand {\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connectorNames();\n+      }\n+   }\n+\n+   @CommandDefinition(name = \"describe\", description = \"Describes a connector\", activator = ConnectionActivator.class)\n+   public static class Describe extends RestCliCommand {\n+\n+      @Argument(required = true, completer = ConnectorCompleter.class)\n+      String name;\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connector(name);\n+      }\n+   }\n+\n+   @CommandDefinition(name = \"start\", description = \"Starts a connector\", activator = ConnectionActivator.class)\n+   public static class Start extends RestCliCommand {\n+\n+      @Argument(required = true, completer = ConnectorCompleter.class)\n+      String name;\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connectorStart(name);\n+      }\n+   }\n+\n+   @CommandDefinition(name = \"stop\", description = \"Stops a connector\", activator = ConnectionActivator.class)\n+   public static class Stop extends RestCliCommand {\n+\n+      @Argument(required = true, completer = ConnectorCompleter.class)\n+      String name;\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connectorStop(name);\n+      }\n+   }\n+\n+   @GroupCommandDefinition(name = \"ipfilter\", description = \"Manages connector IP filters\", activator = ConnectionActivator.class, groupCommands = {IpFilter.Ls.class, IpFilter.Clear.class, IpFilter.Set.class})\n+   public static class IpFilter extends CliCommand {\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      protected boolean isHelp() {\n+         return false;", "originalCommit": "65b1dcdbdbcf70702186b4dfd9ca19f114296b74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAzMTIzMQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r568031231", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since 12.0\n          \n          \n            \n             * @since 12.1", "author": "pruivo", "createdAt": "2021-02-01T18:06:07Z", "path": "cli/src/main/java/org/infinispan/cli/completers/ConnectorCompleter.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package org.infinispan.cli.completers;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+\n+import org.infinispan.cli.Context;\n+import org.infinispan.cli.connection.Connection;\n+\n+/**\n+ * A {@link org.aesh.command.completer.OptionCompleter} for protocol connectors.\n+ *\n+ * @author Tristan Tarrant\n+ * @since 12.0", "originalCommit": "65b1dcdbdbcf70702186b4dfd9ca19f114296b74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAzMjI5MQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r568032291", "bodyText": "why not using org.infinispan.client.rest.IpFilterRule.RuleType?", "author": "pruivo", "createdAt": "2021-02-01T18:07:48Z", "path": "cli/src/main/java/org/infinispan/cli/completers/IpFilterRuleCompleter.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package org.infinispan.cli.completers;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+public class IpFilterRuleCompleter extends EnumCompleter {\n+\n+   public enum IpFilterType {", "originalCommit": "65b1dcdbdbcf70702186b4dfd9ca19f114296b74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTIyNjg1MA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r569226850", "bodyText": "@tristantarrant ^", "author": "pruivo", "createdAt": "2021-02-03T08:43:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAzMjI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAzMzk4Nw==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r568033987", "bodyText": "why the container? we don't support multiple containers and the connector has no association with connectors/enpoints.", "author": "pruivo", "createdAt": "2021-02-01T18:10:22Z", "path": "cli/src/main/java/org/infinispan/cli/connection/Connection.java", "diffHunk": "@@ -73,6 +73,8 @@\n \n    Collection<String> getBackupNames(String container) throws IOException;\n \n+   Collection<String> getConnectorNames(String container) throws IOException;", "originalCommit": "65b1dcdbdbcf70702186b4dfd9ca19f114296b74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU4NTQ5Nw==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r568585497", "bodyText": "ok", "author": "tristantarrant", "createdAt": "2021-02-02T13:05:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAzMzk4Nw=="}], "type": "inlineReview"}, {"oid": "f476645ce61e3d28725670d9af7a802e05128b6d", "url": "https://github.com/infinispan/infinispan/commit/f476645ce61e3d28725670d9af7a802e05128b6d", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-02T13:13:01Z", "type": "forcePushed"}, {"oid": "80223cd5311920a152cae117aa34da458383d002", "url": "https://github.com/infinispan/infinispan/commit/80223cd5311920a152cae117aa34da458383d002", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-02T13:17:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI0NTk1Ng==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r569245956", "bodyText": "why not using composition? IMO, there is no reason to copy & maintain this code\npublic final class IpSubnetFilterRule implements IpFilterRule {\n\n   private final IpSubnetFilterRule filterRule;\n   private final String cidr;\n\n   public IpSubnetFilterRule(String cidr, IpFilterRuleType ruleType) {\n      int sep = cidr.indexOf('/');\n      if (sep < 0) {\n         throw new IllegalArgumentException(cidr);\n      }\n      this.filterRule = new IpSubnetFilterRule(cidr.substring(0, sep), Integer.parseInt(cidr.substring(sep + 1)), ruleType);\n      this.cidr = cidr;\n   }", "author": "pruivo", "createdAt": "2021-02-03T09:12:06Z", "path": "server/core/src/main/java/org/infinispan/server/core/transport/IpSubnetFilterRule.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package org.infinispan.server.core.transport;\n+\n+import java.math.BigInteger;\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.Objects;\n+\n+import io.netty.handler.ipfilter.IpFilterRule;\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.SocketUtils;\n+\n+/**\n+ * This differs from Netty's equivalent {@link io.netty.handler.ipfilter.IpSubnetFilterRule} in that it parses CIDR", "originalCommit": "80223cd5311920a152cae117aa34da458383d002", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI1NDQzNA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r569254434", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * <li>stopped protocol servers</li>\n          \n          \n            \n             * <li>protocol servers</li>", "author": "pruivo", "createdAt": "2021-02-03T09:24:31Z", "path": "server/runtime/src/main/java/org/infinispan/server/state/ServerStateManagerImpl.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package org.infinispan.server.state;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.globalstate.GlobalConfigurationManager;\n+import org.infinispan.globalstate.ScopeFilter;\n+import org.infinispan.globalstate.ScopedState;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryModified;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryModifiedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.security.AuthorizationPermission;\n+import org.infinispan.server.Server;\n+import org.infinispan.server.core.ProtocolServer;\n+import org.infinispan.server.core.ServerStateManager;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+import org.infinispan.server.core.transport.Transport;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * Manages cluster-wide server state for a given {@link EmbeddedCacheManager}. This handles:\n+ * <ul>\n+ * <li>ignored caches</li>\n+ * <li>stopped protocol servers</li>", "originalCommit": "80223cd5311920a152cae117aa34da458383d002", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI1NDUyNg==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r569254526", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since 10.0\n          \n          \n            \n             * @since 12.1", "author": "pruivo", "createdAt": "2021-02-03T09:24:41Z", "path": "server/runtime/src/main/java/org/infinispan/server/state/ServerStateManagerImpl.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package org.infinispan.server.state;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.globalstate.GlobalConfigurationManager;\n+import org.infinispan.globalstate.ScopeFilter;\n+import org.infinispan.globalstate.ScopedState;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryModified;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryModifiedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.security.AuthorizationPermission;\n+import org.infinispan.server.Server;\n+import org.infinispan.server.core.ProtocolServer;\n+import org.infinispan.server.core.ServerStateManager;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+import org.infinispan.server.core.transport.Transport;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * Manages cluster-wide server state for a given {@link EmbeddedCacheManager}. This handles:\n+ * <ul>\n+ * <li>ignored caches</li>\n+ * <li>stopped protocol servers</li>\n+ * <li>ip filters</li>\n+ * </ul>\n+ *\n+ * @since 10.0", "originalCommit": "80223cd5311920a152cae117aa34da458383d002", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI1OTI3Nw==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r569259277", "bodyText": "can be final", "author": "pruivo", "createdAt": "2021-02-03T09:31:07Z", "path": "server/runtime/src/main/java/org/infinispan/server/state/ServerStateManagerImpl.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package org.infinispan.server.state;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.globalstate.GlobalConfigurationManager;\n+import org.infinispan.globalstate.ScopeFilter;\n+import org.infinispan.globalstate.ScopedState;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryModified;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryModifiedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.security.AuthorizationPermission;\n+import org.infinispan.server.Server;\n+import org.infinispan.server.core.ProtocolServer;\n+import org.infinispan.server.core.ServerStateManager;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+import org.infinispan.server.core.transport.Transport;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * Manages cluster-wide server state for a given {@link EmbeddedCacheManager}. This handles:\n+ * <ul>\n+ * <li>ignored caches</li>\n+ * <li>stopped protocol servers</li>\n+ * <li>ip filters</li>\n+ * </ul>\n+ *\n+ * @since 10.0\n+ */\n+public final class ServerStateManagerImpl implements ServerStateManager {\n+   private static final String CONNECTOR_STATE_SCOPE = \"connector-state\";\n+   private static final String CONNECTOR_IPFILTER_SCOPE = \"connector-ipfilter\";\n+   private static final ScopedState IGNORED_CACHES_KEY = new ScopedState(\"ignored-caches\", \"ignored-caches\");\n+\n+   private final EmbeddedCacheManager cacheManager;\n+   private final Server server;\n+   private Cache<ScopedState, Object> cache;", "originalCommit": "80223cd5311920a152cae117aa34da458383d002", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI2MDI5MA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r569260290", "bodyText": "fields can be removed. they are only accessed in the contructor.", "author": "pruivo", "createdAt": "2021-02-03T09:32:37Z", "path": "server/runtime/src/main/java/org/infinispan/server/state/ServerStateManagerImpl.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package org.infinispan.server.state;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.globalstate.GlobalConfigurationManager;\n+import org.infinispan.globalstate.ScopeFilter;\n+import org.infinispan.globalstate.ScopedState;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryModified;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryModifiedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.security.AuthorizationPermission;\n+import org.infinispan.server.Server;\n+import org.infinispan.server.core.ProtocolServer;\n+import org.infinispan.server.core.ServerStateManager;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+import org.infinispan.server.core.transport.Transport;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * Manages cluster-wide server state for a given {@link EmbeddedCacheManager}. This handles:\n+ * <ul>\n+ * <li>ignored caches</li>\n+ * <li>stopped protocol servers</li>\n+ * <li>ip filters</li>\n+ * </ul>\n+ *\n+ * @since 10.0\n+ */\n+public final class ServerStateManagerImpl implements ServerStateManager {\n+   private static final String CONNECTOR_STATE_SCOPE = \"connector-state\";\n+   private static final String CONNECTOR_IPFILTER_SCOPE = \"connector-ipfilter\";\n+   private static final ScopedState IGNORED_CACHES_KEY = new ScopedState(\"ignored-caches\", \"ignored-caches\");\n+\n+   private final EmbeddedCacheManager cacheManager;\n+   private final Server server;\n+   private Cache<ScopedState, Object> cache;\n+   private final IgnoredCaches ignored = new IgnoredCaches();\n+   private final IgnoredCachesListener ignoredCacheListener = new IgnoredCachesListener();\n+   private final ConnectorStateListener connectorStateListener = new ConnectorStateListener();\n+   private final ConnectorIpFilterListener connectorIpFilterListener = new ConnectorIpFilterListener();", "originalCommit": "80223cd5311920a152cae117aa34da458383d002", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI2MjE3OA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r569262178", "bodyText": "since this is stored in a Set, it would be better to implement equals/hashCode", "author": "pruivo", "createdAt": "2021-02-03T09:35:25Z", "path": "server/runtime/src/main/java/org/infinispan/server/state/ServerStateManagerImpl.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package org.infinispan.server.state;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.globalstate.GlobalConfigurationManager;\n+import org.infinispan.globalstate.ScopeFilter;\n+import org.infinispan.globalstate.ScopedState;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryModified;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryModifiedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.security.AuthorizationPermission;\n+import org.infinispan.server.Server;\n+import org.infinispan.server.core.ProtocolServer;\n+import org.infinispan.server.core.ServerStateManager;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+import org.infinispan.server.core.transport.Transport;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * Manages cluster-wide server state for a given {@link EmbeddedCacheManager}. This handles:\n+ * <ul>\n+ * <li>ignored caches</li>\n+ * <li>stopped protocol servers</li>\n+ * <li>ip filters</li>\n+ * </ul>\n+ *\n+ * @since 10.0\n+ */\n+public final class ServerStateManagerImpl implements ServerStateManager {\n+   private static final String CONNECTOR_STATE_SCOPE = \"connector-state\";\n+   private static final String CONNECTOR_IPFILTER_SCOPE = \"connector-ipfilter\";\n+   private static final ScopedState IGNORED_CACHES_KEY = new ScopedState(\"ignored-caches\", \"ignored-caches\");\n+\n+   private final EmbeddedCacheManager cacheManager;\n+   private final Server server;\n+   private Cache<ScopedState, Object> cache;\n+   private final IgnoredCaches ignored = new IgnoredCaches();\n+   private final IgnoredCachesListener ignoredCacheListener = new IgnoredCachesListener();\n+   private final ConnectorStateListener connectorStateListener = new ConnectorStateListener();\n+   private final ConnectorIpFilterListener connectorIpFilterListener = new ConnectorIpFilterListener();\n+   private volatile boolean hasIgnores;\n+\n+   public ServerStateManagerImpl(Server server, EmbeddedCacheManager cacheManager, GlobalConfigurationManager configurationManager) {\n+      this.server = server;\n+      this.cacheManager = cacheManager;\n+      this.cache = configurationManager.getStateCache();\n+\n+      GlobalComponentRegistry registry = SecurityActions.getGlobalComponentRegistry(cacheManager);\n+      SerializationContextRegistry serializationContextRegistry = registry.getComponent(SerializationContextRegistry.class);\n+      serializationContextRegistry.addContextInitializer(SerializationContextRegistry.MarshallerType.PERSISTENCE, new PersistenceContextInitializerImpl());\n+\n+      updateLocalIgnoredCaches((IgnoredCaches) cache.get(IGNORED_CACHES_KEY));\n+\n+      // Register the listeners which will react on\n+      cache.addListener(ignoredCacheListener, new ScopeFilter(IGNORED_CACHES_KEY.getScope()), null);\n+      cache.addListener(connectorStateListener, new ScopeFilter(CONNECTOR_STATE_SCOPE), null);\n+      cache.addListener(connectorIpFilterListener, new ScopeFilter(CONNECTOR_IPFILTER_SCOPE), null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> unignoreCache(String cacheName) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      synchronized (this) {\n+         ignored.caches.remove(cacheName);\n+         hasIgnores = !ignored.caches.isEmpty();\n+         return cache.putAsync(IGNORED_CACHES_KEY, ignored).thenApply(r -> null);\n+      }\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> ignoreCache(String cacheName) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      synchronized (this) {\n+         ignored.caches.add(cacheName);\n+         hasIgnores = !ignored.caches.isEmpty();\n+         return cache.putAsync(IGNORED_CACHES_KEY, ignored).thenApply(r -> null);\n+      }\n+   }\n+\n+   @Override\n+   public Set<String> getIgnoredCaches() {\n+      return Collections.unmodifiableSet(ignored.caches);\n+   }\n+\n+   @Override\n+   public boolean isCacheIgnored(String cacheName) {\n+      return hasIgnores && ignored.caches.contains(cacheName);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Boolean> connectorStart(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.removeAsync(new ScopedState(CONNECTOR_STATE_SCOPE, name), true).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> connectorStop(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.putAsync(new ScopedState(CONNECTOR_STATE_SCOPE, name), true).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Boolean> connectorStatus(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return CompletableFuture.completedFuture(server.getProtocolServers().get(name).getTransport().isRunning());\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> setConnectorIpFilterRule(String name, Collection<IpSubnetFilterRule> filterRule) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      IpFilterRules ipFilterRules = new IpFilterRules();\n+      filterRule.forEach(r -> ipFilterRules.rules.add(new IpFilterRule(r)));\n+      return cache.putAsync(new ScopedState(CONNECTOR_IPFILTER_SCOPE, name), ipFilterRules).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> clearConnectorIpFilterRules(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.removeAsync(new ScopedState(CONNECTOR_IPFILTER_SCOPE, name)).thenApply(v -> null);\n+   }\n+\n+   private void updateLocalIgnoredCaches(IgnoredCaches ignored) {\n+      if (ignored != null) {\n+         synchronized (this) {\n+            this.ignored.caches.clear();\n+            this.ignored.caches.addAll(ignored.caches);\n+            hasIgnores = !this.ignored.caches.isEmpty();\n+         }\n+      }\n+   }\n+\n+   @Listener(observation = Listener.Observation.POST)\n+   private final class IgnoredCachesListener {\n+      @CacheEntryCreated\n+      public void created(CacheEntryCreatedEvent<ScopedState, IgnoredCaches> e) {\n+         if (!e.isOriginLocal()) {\n+            updateLocalIgnoredCaches(e.getValue());\n+         }\n+      }\n+\n+      @CacheEntryModified\n+      public void modified(CacheEntryModifiedEvent<ScopedState, IgnoredCaches> e) {\n+         if (!e.isOriginLocal()) {\n+            updateLocalIgnoredCaches(e.getValue());\n+         }\n+      }\n+   }\n+\n+   @Listener(observation = Listener.Observation.POST)\n+   private final class ConnectorStateListener {\n+      @CacheEntryCreated\n+      public void created(CacheEntryCreatedEvent<ScopedState, Boolean> e) {\n+         // stop the connector\n+         server.getProtocolServers().get(e.getKey().getName()).getTransport().stop();\n+      }\n+\n+      @CacheEntryRemoved\n+      public void removed(CacheEntryRemovedEvent<ScopedState, Boolean> e) {\n+         // start the connector\n+         server.getProtocolServers().get(e.getKey().getName()).getTransport().start();\n+      }\n+   }\n+\n+   @Listener(observation = Listener.Observation.POST)\n+   private final class ConnectorIpFilterListener {\n+      @CacheEntryCreated\n+      @CacheEntryModified\n+      public CompletionStage<Void> modified(CacheEntryEvent<ScopedState, IpFilterRules> e) {\n+         String connector = e.getKey().getName();\n+         ProtocolServer protocolServer = server.getProtocolServers().get(connector);\n+         List<IpSubnetFilterRule> rules = protocolServer.getConfiguration().ipfilter().rules();\n+         rules.clear();\n+         for (IpFilterRule rule : e.getValue().rules) {\n+            rules.add(new IpSubnetFilterRule(rule.cidr, IpFilterRuleType.valueOf(rule.type)));\n+         }\n+         Transport transport = protocolServer.getTransport();\n+         if (transport != null) {\n+            return transport.applyIpFilterRules(rules).thenApply(v -> {\n+               Server.log.connectorIpFilterSet(connector, rules);\n+               return v;\n+            });\n+         } else {\n+            return CompletableFutures.completedExceptionFuture(Server.log.noConnectorTransport(connector));\n+         }\n+      }\n+\n+      @CacheEntryRemoved\n+      public void removed(CacheEntryRemovedEvent<ScopedState, IpFilterRules> e) {\n+         String connector = e.getKey().getName();\n+         server.getProtocolServers().get(connector).getConfiguration().ipfilter().rules().clear();\n+         Server.log.connectorIpFilterCleared(connector);\n+      }\n+   }\n+\n+   @ProtoTypeId(ProtoStreamTypeIds.IGNORED_CACHES)\n+   static final class IgnoredCaches {\n+\n+      @ProtoField(number = 1, collectionImplementation = HashSet.class)\n+      final Set<String> caches;\n+\n+      IgnoredCaches() {\n+         this(ConcurrentHashMap.newKeySet());\n+      }\n+\n+      @ProtoFactory\n+      IgnoredCaches(Set<String> caches) {\n+         // ProtoStream cannot use KeySetView directly as it does not have a zero args constructor\n+         this.caches = ConcurrentHashMap.newKeySet(caches.size());\n+         this.caches.addAll(caches);\n+      }\n+   }\n+\n+   @ProtoTypeId(ProtoStreamTypeIds.IP_FILTER_RULE)\n+   static final class IpFilterRule {", "originalCommit": "80223cd5311920a152cae117aa34da458383d002", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI2MzA2Mw==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r569263063", "bodyText": "not used. revert?", "author": "pruivo", "createdAt": "2021-02-03T09:36:35Z", "path": "server/runtime/src/main/java/org/infinispan/server/tasks/admin/ServerAdminOperationsHandler.java", "diffHunk": "@@ -14,7 +15,7 @@\n  **/\n public class ServerAdminOperationsHandler extends AdminOperationsHandler {\n \n-   public ServerAdminOperationsHandler(ConfigurationBuilderHolder defaultsHolder) {\n+   public ServerAdminOperationsHandler(Server server, ConfigurationBuilderHolder defaultsHolder) {", "originalCommit": "80223cd5311920a152cae117aa34da458383d002", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI2MzM0Ng==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r569263346", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since 12.0\n          \n          \n            \n             * @since 12.1", "author": "pruivo", "createdAt": "2021-02-03T09:37:00Z", "path": "server/runtime/src/main/java/org/infinispan/server/state/SecurityActions.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package org.infinispan.server.state;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.security.AuthorizationPermission;\n+import org.infinispan.security.Security;\n+import org.infinispan.security.actions.GetGlobalComponentRegistryAction;\n+import org.infinispan.security.impl.AuthorizationHelper;\n+\n+/**\n+ * SecurityActions for the org.infinispan.server.state package.\n+ * <p>\n+ * Do not move. Do not change class and method visibility to avoid being called from other {@link\n+ * java.security.CodeSource}s, thus granting privilege escalation to external code.\n+ *\n+ * @author Tristan Tarrant <tristan@infinispan.org>\n+ * @since 12.0", "originalCommit": "80223cd5311920a152cae117aa34da458383d002", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI2MzU2NQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r569263565", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since 12.0\n          \n          \n            \n             * @since 12.1", "author": "pruivo", "createdAt": "2021-02-03T09:37:18Z", "path": "server/runtime/src/main/java/org/infinispan/server/state/PersistenceContextInitializer.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package org.infinispan.server.state;\n+\n+import org.infinispan.protostream.SerializationContextInitializer;\n+import org.infinispan.protostream.annotations.AutoProtoSchemaBuilder;\n+\n+/**\n+ * Interface used to initialise a {@link org.infinispan.protostream.SerializationContext} using the specified Pojos,\n+ * Marshaller implementations and provided .proto schemas.\n+ *\n+ * @author Tristan Tarrant\n+ * @since 12.0", "originalCommit": "80223cd5311920a152cae117aa34da458383d002", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI2ODU2Mw==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r569268563", "bodyText": "hmmm... shouldn't copy the rules from template?", "author": "pruivo", "createdAt": "2021-02-03T09:44:12Z", "path": "server/core/src/main/java/org/infinispan/server/core/configuration/IpFilterConfigurationBuilder.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package org.infinispan.server.core.configuration;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.infinispan.commons.configuration.Builder;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * IpFilterConfigurationBuilder.\n+ *\n+ * @author Tristan Tarrant\n+ * @since 12.0\n+ */\n+public class IpFilterConfigurationBuilder<T extends ProtocolServerConfiguration, S extends ProtocolServerConfigurationChildBuilder<T, S>>\n+      extends AbstractProtocolServerConfigurationChildBuilder<T, S>\n+      implements Builder<IpFilterConfiguration> {\n+\n+   List<IpSubnetFilterRule> rules = new ArrayList<>();\n+\n+   public IpFilterConfigurationBuilder(ProtocolServerConfigurationChildBuilder<T, S> builder) {\n+      super(builder);\n+   }\n+\n+   public IpFilterConfigurationBuilder allowFrom(String rule) {\n+      rules.add(new IpSubnetFilterRule(rule, IpFilterRuleType.ACCEPT));\n+      return this;\n+   }\n+\n+   public IpFilterConfigurationBuilder rejectFrom(String rule) {\n+      rules.add(new IpSubnetFilterRule(rule, IpFilterRuleType.REJECT));\n+      return this;\n+   }\n+\n+   @Override\n+   public void validate() {\n+   }\n+\n+   @Override\n+   public IpFilterConfiguration create() {\n+      return new IpFilterConfiguration(rules);\n+   }\n+\n+   @Override\n+   public IpFilterConfigurationBuilder read(IpFilterConfiguration template) {\n+      return this;", "originalCommit": "80223cd5311920a152cae117aa34da458383d002", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e2e61a2f37f9186590143712259e23ef790a0038", "url": "https://github.com/infinispan/infinispan/commit/e2e61a2f37f9186590143712259e23ef790a0038", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-03T16:28:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA3ODE4MQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570078181", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               public IpFilterConfigurationBuilder allowFrom(String rule) {\n          \n          \n            \n               public IpFilterConfigurationBuilder<T, S> allowFrom(String rule) {", "author": "pruivo", "createdAt": "2021-02-04T09:39:51Z", "path": "server/core/src/main/java/org/infinispan/server/core/configuration/IpFilterConfigurationBuilder.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package org.infinispan.server.core.configuration;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.infinispan.commons.configuration.Builder;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * IpFilterConfigurationBuilder.\n+ *\n+ * @author Tristan Tarrant\n+ * @since 12.1\n+ */\n+public class IpFilterConfigurationBuilder<T extends ProtocolServerConfiguration, S extends ProtocolServerConfigurationChildBuilder<T, S>>\n+      extends AbstractProtocolServerConfigurationChildBuilder<T, S>\n+      implements Builder<IpFilterConfiguration> {\n+\n+   List<IpSubnetFilterRule> rules = new ArrayList<>();\n+\n+   public IpFilterConfigurationBuilder(ProtocolServerConfigurationChildBuilder<T, S> builder) {\n+      super(builder);\n+   }\n+\n+   public IpFilterConfigurationBuilder allowFrom(String rule) {", "originalCommit": "e2e61a2f37f9186590143712259e23ef790a0038", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA3ODI4Ng==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570078286", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               public IpFilterConfigurationBuilder rejectFrom(String rule) {\n          \n          \n            \n               public IpFilterConfigurationBuilder<T, S> rejectFrom(String rule) {", "author": "pruivo", "createdAt": "2021-02-04T09:39:58Z", "path": "server/core/src/main/java/org/infinispan/server/core/configuration/IpFilterConfigurationBuilder.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package org.infinispan.server.core.configuration;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.infinispan.commons.configuration.Builder;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * IpFilterConfigurationBuilder.\n+ *\n+ * @author Tristan Tarrant\n+ * @since 12.1\n+ */\n+public class IpFilterConfigurationBuilder<T extends ProtocolServerConfiguration, S extends ProtocolServerConfigurationChildBuilder<T, S>>\n+      extends AbstractProtocolServerConfigurationChildBuilder<T, S>\n+      implements Builder<IpFilterConfiguration> {\n+\n+   List<IpSubnetFilterRule> rules = new ArrayList<>();\n+\n+   public IpFilterConfigurationBuilder(ProtocolServerConfigurationChildBuilder<T, S> builder) {\n+      super(builder);\n+   }\n+\n+   public IpFilterConfigurationBuilder allowFrom(String rule) {\n+      rules.add(IpSubnetFilterRule.from(rule, IpFilterRuleType.ACCEPT));\n+      return this;\n+   }\n+\n+   public IpFilterConfigurationBuilder rejectFrom(String rule) {", "originalCommit": "e2e61a2f37f9186590143712259e23ef790a0038", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA3ODQzMA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570078430", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               public IpFilterConfigurationBuilder read(IpFilterConfiguration template) {\n          \n          \n            \n               public IpFilterConfigurationBuilder<T, S> read(IpFilterConfiguration template) {", "author": "pruivo", "createdAt": "2021-02-04T09:40:07Z", "path": "server/core/src/main/java/org/infinispan/server/core/configuration/IpFilterConfigurationBuilder.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package org.infinispan.server.core.configuration;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.infinispan.commons.configuration.Builder;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * IpFilterConfigurationBuilder.\n+ *\n+ * @author Tristan Tarrant\n+ * @since 12.1\n+ */\n+public class IpFilterConfigurationBuilder<T extends ProtocolServerConfiguration, S extends ProtocolServerConfigurationChildBuilder<T, S>>\n+      extends AbstractProtocolServerConfigurationChildBuilder<T, S>\n+      implements Builder<IpFilterConfiguration> {\n+\n+   List<IpSubnetFilterRule> rules = new ArrayList<>();\n+\n+   public IpFilterConfigurationBuilder(ProtocolServerConfigurationChildBuilder<T, S> builder) {\n+      super(builder);\n+   }\n+\n+   public IpFilterConfigurationBuilder allowFrom(String rule) {\n+      rules.add(IpSubnetFilterRule.from(rule, IpFilterRuleType.ACCEPT));\n+      return this;\n+   }\n+\n+   public IpFilterConfigurationBuilder rejectFrom(String rule) {\n+      rules.add(IpSubnetFilterRule.from(rule, IpFilterRuleType.REJECT));\n+      return this;\n+   }\n+\n+   @Override\n+   public void validate() {\n+   }\n+\n+   @Override\n+   public IpFilterConfiguration create() {\n+      return new IpFilterConfiguration(rules);\n+   }\n+\n+   @Override\n+   public IpFilterConfigurationBuilder read(IpFilterConfiguration template) {", "originalCommit": "e2e61a2f37f9186590143712259e23ef790a0038", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA3ODY4NQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570078685", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               List<IpSubnetFilterRule> rules = new ArrayList<>();\n          \n          \n            \n               private final List<IpSubnetFilterRule> rules = new ArrayList<>();", "author": "pruivo", "createdAt": "2021-02-04T09:40:30Z", "path": "server/core/src/main/java/org/infinispan/server/core/configuration/IpFilterConfigurationBuilder.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package org.infinispan.server.core.configuration;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.infinispan.commons.configuration.Builder;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * IpFilterConfigurationBuilder.\n+ *\n+ * @author Tristan Tarrant\n+ * @since 12.1\n+ */\n+public class IpFilterConfigurationBuilder<T extends ProtocolServerConfiguration, S extends ProtocolServerConfigurationChildBuilder<T, S>>\n+      extends AbstractProtocolServerConfigurationChildBuilder<T, S>\n+      implements Builder<IpFilterConfiguration> {\n+\n+   List<IpSubnetFilterRule> rules = new ArrayList<>();", "originalCommit": "e2e61a2f37f9186590143712259e23ef790a0038", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA3OTI3MQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570079271", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  this.ipfilter = ipfilter;\n          \n          \n            \n                  this.ipfilter = ipFilter;", "author": "pruivo", "createdAt": "2021-02-04T09:41:19Z", "path": "server/core/src/main/java/org/infinispan/server/core/configuration/ProtocolServerConfiguration.java", "diffHunk": "@@ -63,10 +63,12 @@ public static AttributeSet attributeDefinitionSet() {\n    protected final AttributeSet attributes;\n \n    protected final SslConfiguration ssl;\n+   protected final IpFilterConfiguration ipfilter;\n \n-   protected ProtocolServerConfiguration(AttributeSet attributes, SslConfiguration ssl) {\n+   protected ProtocolServerConfiguration(AttributeSet attributes, SslConfiguration ssl, IpFilterConfiguration ipfilter) {\n       this.attributes = attributes.checkProtection();\n       this.ssl = ssl;\n+      this.ipfilter = ipfilter;", "originalCommit": "e2e61a2f37f9186590143712259e23ef790a0038", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA3OTU0MA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570079540", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               public IpFilterConfiguration ipfilter() {\n          \n          \n            \n               public IpFilterConfiguration ipFilter() {", "author": "pruivo", "createdAt": "2021-02-04T09:41:43Z", "path": "server/core/src/main/java/org/infinispan/server/core/configuration/ProtocolServerConfiguration.java", "diffHunk": "@@ -121,6 +123,10 @@ public SslConfiguration ssl() {\n       return ssl;\n    }\n \n+   public IpFilterConfiguration ipfilter() {", "originalCommit": "e2e61a2f37f9186590143712259e23ef790a0038", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA4MDM0MQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570080341", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  this.ipFilter = new IpFilterConfigurationBuilder(this);\n          \n          \n            \n                  this.ipFilter = new IpFilterConfigurationBuilder<>(this);", "author": "pruivo", "createdAt": "2021-02-04T09:42:47Z", "path": "server/core/src/main/java/org/infinispan/server/core/configuration/ProtocolServerConfigurationBuilder.java", "diffHunk": "@@ -26,10 +26,12 @@\n    private static final Log log = LogFactory.getLog(ProtocolServerConfigurationBuilder.class, Log.class);\n    protected final AttributeSet attributes;\n    protected final SslConfigurationBuilder<T, S> ssl;\n+   protected final IpFilterConfigurationBuilder<T, S> ipFilter;\n \n    protected ProtocolServerConfigurationBuilder(int port, AttributeSet attributes) {\n       this.attributes = attributes;\n       this.ssl = new SslConfigurationBuilder(this);\n+      this.ipFilter = new IpFilterConfigurationBuilder(this);", "originalCommit": "e2e61a2f37f9186590143712259e23ef790a0038", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA4MDczMg==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570080732", "bodyText": "method's name \"should\" be ipFilter IMO\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               public IpFilterConfigurationBuilder ipRules() {\n          \n          \n            \n               public IpFilterConfigurationBuilder<T, S> ipFilter() { {\n          \n      \n    \n    \n  \n\nshould ProtocolServerConfigurationChildBuilder have this method as well?", "author": "pruivo", "createdAt": "2021-02-04T09:43:21Z", "path": "server/core/src/main/java/org/infinispan/server/core/configuration/ProtocolServerConfigurationBuilder.java", "diffHunk": "@@ -109,6 +111,10 @@ public SslConfigurationBuilder ssl() {\n       return ssl;\n    }\n \n+   public IpFilterConfigurationBuilder ipRules() {", "originalCommit": "e2e61a2f37f9186590143712259e23ef790a0038", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA4NDEwNg==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570084106", "bodyText": "well, I have a \"smaller\" implementation in mind:\npublic class InfinispanIpSubnetFilterRule implements IpFilterRule {\n\n   private final IpSubnetFilterRule filterRule;\n   private final String cidr;\n\n   public InfinispanIpSubnetFilterRule(String cidr, IpFilterRuleType ruleType) {\n      int sep = cidr.indexOf('/');\n      if (sep < 0) {\n         throw new IllegalArgumentException(cidr);\n      }\n      this.filterRule = new IpSubnetFilterRule(cidr.substring(0, sep), Integer.parseInt(cidr.substring(sep + 1)), ruleType);\n      this.cidr = cidr;\n   }\n\n   public String cidr() {\n      return cidr;\n   }\n\n   @Override\n   public boolean matches(InetSocketAddress inetSocketAddress) {\n      return filterRule.matches(inetSocketAddress);\n   }\n\n   @Override\n   public IpFilterRuleType ruleType() {\n      return filterRule.ruleType();\n   }\n}", "author": "pruivo", "createdAt": "2021-02-04T09:47:52Z", "path": "server/core/src/main/java/org/infinispan/server/core/transport/IpSubnetFilterRule.java", "diffHunk": "@@ -0,0 +1,189 @@\n+package org.infinispan.server.core.transport;\n+\n+import java.math.BigInteger;\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.Objects;\n+\n+import io.netty.handler.ipfilter.IpFilterRule;\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.SocketUtils;\n+\n+/**\n+ * This differs from Netty's equivalent {@link io.netty.handler.ipfilter.IpSubnetFilterRule} in that it parses CIDR\n+ * addresses\n+ *\n+ * @author Tristan Tarrant\n+ * @since 12.1\n+ */\n+public abstract class IpSubnetFilterRule implements IpFilterRule {", "originalCommit": "e2e61a2f37f9186590143712259e23ef790a0038", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDE4MTgxMQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570181811", "bodyText": "Not sure how that improves things :)", "author": "tristantarrant", "createdAt": "2021-02-04T12:23:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA4NDEwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDgyMzY0MQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570823641", "bodyText": "it doesn't. But this code seems copied from netty. Any bugfixes and/or improvements made by them, we won't get them.", "author": "pruivo", "createdAt": "2021-02-05T09:14:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA4NDEwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA4NTQ0OQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570085449", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               private final RuleBasedIpFilter iprulesHandler;\n          \n          \n            \n               private final RuleBasedIpFilter ipRulesHandler;", "author": "pruivo", "createdAt": "2021-02-04T09:49:37Z", "path": "server/core/src/main/java/org/infinispan/server/core/transport/NettyChannelInitializer.java", "diffHunk": "@@ -28,19 +28,24 @@\n    protected final NettyTransport transport;\n    protected final ChannelOutboundHandler encoder;\n    protected final ChannelInboundHandler decoder;\n+   private final RuleBasedIpFilter iprulesHandler;", "originalCommit": "e2e61a2f37f9186590143712259e23ef790a0038", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA4NTY1MA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570085650", "bodyText": "shouldn't the ip filter be the first one?", "author": "pruivo", "createdAt": "2021-02-04T09:49:53Z", "path": "server/core/src/main/java/org/infinispan/server/core/transport/NettyChannelInitializer.java", "diffHunk": "@@ -28,19 +28,24 @@\n    protected final NettyTransport transport;\n    protected final ChannelOutboundHandler encoder;\n    protected final ChannelInboundHandler decoder;\n+   private final RuleBasedIpFilter iprulesHandler;\n+   private final StatsChannelHandler statsHandler;\n \n    public NettyChannelInitializer(ProtocolServer<A> server, NettyTransport transport, ChannelOutboundHandler encoder, ChannelInboundHandler decoder) {\n       this.server = server;\n       this.transport = transport;\n       this.encoder = encoder;\n       this.decoder = decoder;\n+      this.statsHandler = transport != null ? new StatsChannelHandler(transport) : null;\n+      this.iprulesHandler = new RuleBasedIpFilter(server.getConfiguration().ipfilter());\n    }\n \n    @Override\n    public void initializeChannel(Channel ch) throws Exception {\n       ChannelPipeline pipeline = ch.pipeline();\n-      if(transport != null) {\n-         pipeline.addLast(\"stats\", new StatsChannelHandler(transport));\n+      pipeline.addLast(\"iprules\", iprulesHandler);", "originalCommit": "e2e61a2f37f9186590143712259e23ef790a0038", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDE3MDUzMQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570170531", "bodyText": "It effectively is the first, because everything else is added afterwards", "author": "tristantarrant", "createdAt": "2021-02-04T12:03:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA4NTY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA5MDUwNA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570090504", "bodyText": "it is duplicated from line 182. remove this one.", "author": "pruivo", "createdAt": "2021-02-04T09:56:30Z", "path": "server/runtime/src/main/java/org/infinispan/server/Server.java", "diffHunk": "@@ -177,12 +179,13 @@\n    private volatile ComponentStatus status;\n    private ServerConfiguration serverConfiguration;\n    private Extensions extensions;\n-   private CacheIgnoreManager cacheIgnoreManager;\n+   private ServerStateManager serverStateManager;\n    private ScheduledExecutorService scheduler;\n    private TaskManager taskManager;\n    private ServerInitialContextFactoryBuilder initialContextFactoryBuilder;\n    private BlockingManager blockingManager;\n    private BackupManager backupManager;\n+   private ServerStateManager stateManager;", "originalCommit": "e2e61a2f37f9186590143712259e23ef790a0038", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a97afee7c723090b819040498a361d878f1f7607", "url": "https://github.com/infinispan/infinispan/commit/a97afee7c723090b819040498a361d878f1f7607", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-04T12:18:07Z", "type": "forcePushed"}, {"oid": "ecac734d29caa0e086d779c6df22a5a18ff5bb94", "url": "https://github.com/infinispan/infinispan/commit/ecac734d29caa0e086d779c6df22a5a18ff5bb94", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-05T09:24:35Z", "type": "forcePushed"}, {"oid": "70e9b0d34ab99bd874ced60f0cbdc1e6ccfd4699", "url": "https://github.com/infinispan/infinispan/commit/70e9b0d34ab99bd874ced60f0cbdc1e6ccfd4699", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-05T10:02:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDgzMDAwMw==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570830003", "bodyText": "revert?", "author": "pruivo", "createdAt": "2021-02-05T09:24:02Z", "path": "server/core/src/main/java/org/infinispan/server/core/configuration/SniConfiguration.java", "diffHunk": "@@ -9,7 +9,8 @@\n /**\n  * @since 10.0\n  */\n-public class SniConfiguration implements ConfigurationInfo {\n+public class", "originalCommit": "a97afee7c723090b819040498a361d878f1f7607", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg0MDg0OQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570840849", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  }).addListener(new ChannelGroupFutureListener() {\n          \n          \n            \n                     @Override\n          \n          \n            \n                     public void operationComplete(ChannelGroupFuture channelFutures) {\n          \n          \n            \n                        closed.complete(null);\n          \n          \n            \n                     }\n          \n          \n            \n                  });\n          \n          \n            \n                  }).addListener((ChannelGroupFutureListener) channelFutures -> closed.complete(null));", "author": "pruivo", "createdAt": "2021-02-05T09:41:06Z", "path": "server/core/src/main/java/org/infinispan/server/core/transport/NettyTransport.java", "diffHunk": "@@ -276,6 +319,25 @@ public void updateTotalBytesRead(int bytes) {\n       connectionStats.incrementTotalBytesRead(bytes);\n    }\n \n+   @Override\n+   public CompletionStage<Void> applyIpFilterRules(List<IpSubnetFilterRule> rules) {\n+      CompletableFuture<Void> closed = new CompletableFuture<>();\n+      acceptedChannels.close(channel -> {\n+         for (IpFilterRule rule : rules) {\n+            if (rule.matches((InetSocketAddress) channel.remoteAddress())) {\n+               return rule.ruleType() == IpFilterRuleType.REJECT;\n+            }\n+         }\n+         return false;\n+      }).addListener(new ChannelGroupFutureListener() {\n+         @Override\n+         public void operationComplete(ChannelGroupFuture channelFutures) {\n+            closed.complete(null);\n+         }\n+      });", "originalCommit": "ecac734d29caa0e086d779c6df22a5a18ff5bb94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg0MTM3OQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570841379", "bodyText": "volatile? group with other fields?", "author": "pruivo", "createdAt": "2021-02-05T09:42:01Z", "path": "server/core/src/main/java/org/infinispan/server/core/transport/NettyTransport.java", "diffHunk": "@@ -60,14 +84,15 @@ private static boolean isIsLog4jAvailable() {\n       }\n    }\n \n+   private boolean running;", "originalCommit": "ecac734d29caa0e086d779c6df22a5a18ff5bb94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDk0NDQwMQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570944401", "bodyText": "it is only changed in synchronized methods.", "author": "tristantarrant", "createdAt": "2021-02-05T12:48:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg0MTM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTAzNDEyNg==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r571034126", "bodyText": "isRunning() method isn't protected. it may return stale value.", "author": "pruivo", "createdAt": "2021-02-05T15:07:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg0MTM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg0NTQ4NQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570845485", "bodyText": "I've noticed rules() is a simple ArrayList. You could get a ConcurrentModificationException if you are unlucky and a thread is iteration while other is updating the rules.", "author": "pruivo", "createdAt": "2021-02-05T09:48:21Z", "path": "server/core/src/main/java/org/infinispan/server/core/transport/RuleBasedIpFilter.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.infinispan.server.core.transport;\n+\n+import java.net.InetSocketAddress;\n+\n+import org.infinispan.server.core.configuration.IpFilterConfiguration;\n+import org.infinispan.server.core.logging.Log;\n+\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.ipfilter.AbstractRemoteAddressFilter;\n+import io.netty.handler.ipfilter.IpFilterRule;\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+@Sharable\n+public class RuleBasedIpFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+   private final IpFilterConfiguration rules;\n+\n+   public RuleBasedIpFilter(IpFilterConfiguration rules) {\n+      this.rules = rules;\n+   }\n+\n+   @Override\n+   protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) throws Exception {\n+      for (IpFilterRule rule : rules.rules()) {", "originalCommit": "ecac734d29caa0e086d779c6df22a5a18ff5bb94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg0NzQ0Mw==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570847443", "bodyText": "remove cacheManagerName and remove the parameter from getServerStateManager().\nIt is not used anywhere, no need to waste CPU cycles for nothing.", "author": "pruivo", "createdAt": "2021-02-05T09:51:33Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ServerResource.java", "diffHunk": "@@ -91,15 +107,132 @@ public Invocations getInvocations() {\n       DefaultCacheManager cacheManager = invocationHelper.getServer().getCacheManager(cacheManagerName);\n \n       if (cacheManager == null) return notFoundResponseFuture();\n-      CacheIgnoreManager ignoreManager = invocationHelper.getServer().getIgnoreManager(cacheManagerName);\n-      Set<String> ignored = ignoreManager.getIgnoredCaches();\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager(cacheManagerName);\n+      Set<String> ignored = serverStateManager.getIgnoredCaches();\n       return asJsonResponseFuture(Json.make(ignored));\n    }\n \n    private CompletionStage<RestResponse> cacheManagers(RestRequest restRequest) {\n       return asJsonResponseFuture(Json.make(invocationHelper.getServer().cacheManagerNames()));\n    }\n \n+   private CompletionStage<RestResponse> connectorStartStop(RestRequest restRequest) {\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder().status(NO_CONTENT);\n+      String connectorName = restRequest.variables().get(\"connector\");\n+\n+      ProtocolServer connector = invocationHelper.getServer().getProtocolServers().get(connectorName);\n+      if (connector == null) return completedFuture(builder.status(NOT_FOUND).build());\n+      if (connector.getTransport() == null) return completedFuture(builder.status(BAD_REQUEST).entity(\"Connector has no transport\").build());\n+\n+      String cacheManagerName = invocationHelper.getServer().cacheManagerNames().iterator().next();\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager(cacheManagerName);\n+\n+      switch (restRequest.getAction()) {\n+         case \"start\":\n+            return serverStateManager.connectorStart(connectorName).thenApply(r -> builder.build());\n+         case \"stop\":\n+            return serverStateManager.connectorStop(connectorName).thenApply(r -> builder.build());\n+      }\n+      return completedFuture(builder.status(BAD_REQUEST).build());\n+   }\n+\n+   private CompletionStage<RestResponse> connectorStatus(RestRequest restRequest) {\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      String connectorName = restRequest.variables().get(\"connector\");\n+\n+      ProtocolServer connector = getProtocolServer(restRequest);\n+      if (connector == null) return completedFuture(builder.status(NOT_FOUND).build());\n+\n+      String cacheManagerName = invocationHelper.getServer().cacheManagerNames().iterator().next();", "originalCommit": "ecac734d29caa0e086d779c6df22a5a18ff5bb94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg0OTU4MA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570849580", "bodyText": "shouldn't authorization be checked before?\nfollowing the code, I found only serverStateManager.connectorStatus() checks for ADMIN and it is only invoked when there is a Transport.", "author": "pruivo", "createdAt": "2021-02-05T09:54:59Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ServerResource.java", "diffHunk": "@@ -91,15 +107,132 @@ public Invocations getInvocations() {\n       DefaultCacheManager cacheManager = invocationHelper.getServer().getCacheManager(cacheManagerName);\n \n       if (cacheManager == null) return notFoundResponseFuture();\n-      CacheIgnoreManager ignoreManager = invocationHelper.getServer().getIgnoreManager(cacheManagerName);\n-      Set<String> ignored = ignoreManager.getIgnoredCaches();\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager(cacheManagerName);\n+      Set<String> ignored = serverStateManager.getIgnoredCaches();\n       return asJsonResponseFuture(Json.make(ignored));\n    }\n \n    private CompletionStage<RestResponse> cacheManagers(RestRequest restRequest) {\n       return asJsonResponseFuture(Json.make(invocationHelper.getServer().cacheManagerNames()));\n    }\n \n+   private CompletionStage<RestResponse> connectorStartStop(RestRequest restRequest) {\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder().status(NO_CONTENT);\n+      String connectorName = restRequest.variables().get(\"connector\");\n+\n+      ProtocolServer connector = invocationHelper.getServer().getProtocolServers().get(connectorName);\n+      if (connector == null) return completedFuture(builder.status(NOT_FOUND).build());\n+      if (connector.getTransport() == null) return completedFuture(builder.status(BAD_REQUEST).entity(\"Connector has no transport\").build());\n+\n+      String cacheManagerName = invocationHelper.getServer().cacheManagerNames().iterator().next();\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager(cacheManagerName);\n+\n+      switch (restRequest.getAction()) {\n+         case \"start\":\n+            return serverStateManager.connectorStart(connectorName).thenApply(r -> builder.build());\n+         case \"stop\":\n+            return serverStateManager.connectorStop(connectorName).thenApply(r -> builder.build());\n+      }\n+      return completedFuture(builder.status(BAD_REQUEST).build());\n+   }\n+\n+   private CompletionStage<RestResponse> connectorStatus(RestRequest restRequest) {\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      String connectorName = restRequest.variables().get(\"connector\");\n+\n+      ProtocolServer connector = getProtocolServer(restRequest);", "originalCommit": "ecac734d29caa0e086d779c6df22a5a18ff5bb94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg1MTYyNg==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570851626", "bodyText": "ps. manually check authz at the beginning for other connector's related methods?", "author": "pruivo", "createdAt": "2021-02-05T09:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg0OTU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg5NjI1Nw==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570896257", "bodyText": "I think we should add authz as part of the REST invocation framework so that we can declare required permissions and avoid checking them in the code. /cc @gustavonalle", "author": "tristantarrant", "createdAt": "2021-02-05T11:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg0OTU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg1MTE3Mw==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570851173", "bodyText": "connectorStatus() is non blocking & local only operation.\nActually, it only does transport.isRunning() which you have access here.", "author": "pruivo", "createdAt": "2021-02-05T09:57:24Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ServerResource.java", "diffHunk": "@@ -91,15 +107,132 @@ public Invocations getInvocations() {\n       DefaultCacheManager cacheManager = invocationHelper.getServer().getCacheManager(cacheManagerName);\n \n       if (cacheManager == null) return notFoundResponseFuture();\n-      CacheIgnoreManager ignoreManager = invocationHelper.getServer().getIgnoreManager(cacheManagerName);\n-      Set<String> ignored = ignoreManager.getIgnoredCaches();\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager(cacheManagerName);\n+      Set<String> ignored = serverStateManager.getIgnoredCaches();\n       return asJsonResponseFuture(Json.make(ignored));\n    }\n \n    private CompletionStage<RestResponse> cacheManagers(RestRequest restRequest) {\n       return asJsonResponseFuture(Json.make(invocationHelper.getServer().cacheManagerNames()));\n    }\n \n+   private CompletionStage<RestResponse> connectorStartStop(RestRequest restRequest) {\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder().status(NO_CONTENT);\n+      String connectorName = restRequest.variables().get(\"connector\");\n+\n+      ProtocolServer connector = invocationHelper.getServer().getProtocolServers().get(connectorName);\n+      if (connector == null) return completedFuture(builder.status(NOT_FOUND).build());\n+      if (connector.getTransport() == null) return completedFuture(builder.status(BAD_REQUEST).entity(\"Connector has no transport\").build());\n+\n+      String cacheManagerName = invocationHelper.getServer().cacheManagerNames().iterator().next();\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager(cacheManagerName);\n+\n+      switch (restRequest.getAction()) {\n+         case \"start\":\n+            return serverStateManager.connectorStart(connectorName).thenApply(r -> builder.build());\n+         case \"stop\":\n+            return serverStateManager.connectorStop(connectorName).thenApply(r -> builder.build());\n+      }\n+      return completedFuture(builder.status(BAD_REQUEST).build());\n+   }\n+\n+   private CompletionStage<RestResponse> connectorStatus(RestRequest restRequest) {\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      String connectorName = restRequest.variables().get(\"connector\");\n+\n+      ProtocolServer connector = getProtocolServer(restRequest);\n+      if (connector == null) return completedFuture(builder.status(NOT_FOUND).build());\n+\n+      String cacheManagerName = invocationHelper.getServer().cacheManagerNames().iterator().next();\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager(cacheManagerName);\n+\n+      Json info = Json.object()\n+            .set(\"name\", connectorName)\n+            .set(\"ip-filter-rules\", ipFilterRulesAsJson(connector));\n+      Transport transport = connector.getTransport();\n+      if (transport != null) {\n+         info.set(\"host\", transport.getHostName())\n+               .set(\"port\", transport.getPort())\n+               .set(\"local-connections\", transport.getNumberOfLocalConnections())\n+               .set(\"global-connections\", transport.getNumberOfGlobalConnections())\n+               .set(\"io-threads\", transport.getNumberIOThreads())\n+               .set(\"pending-tasks\", transport.getPendingTasks())\n+               .set(\"total-bytes-read\", transport.getTotalBytesRead())\n+               .set(\"total-bytes-written\", transport.getTotalBytesWritten())\n+               .set(\"send-buffer-size\", transport.getSendBufferSize())\n+               .set(\"receive-buffer-size\", transport.getReceiveBufferSize());\n+         return serverStateManager.connectorStatus(connectorName).thenApply(b -> builder.contentType(APPLICATION_JSON).entity(info.set(\"enabled\", b)).build());", "originalCommit": "ecac734d29caa0e086d779c6df22a5a18ff5bb94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg1NzQyNg==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570857426", "bodyText": "why no returning 200?", "author": "pruivo", "createdAt": "2021-02-05T10:07:37Z", "path": "server/tests/src/test/java/org/infinispan/server/functional/ProtocolManagementIT.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package org.infinispan.server.functional;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+\n+import java.io.IOException;\n+import java.net.ConnectException;\n+import java.net.SocketException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+\n+import org.infinispan.client.rest.IpFilterRule;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.commons.test.Exceptions;\n+import org.infinispan.server.network.NetworkAddress;\n+import org.infinispan.server.test.core.ServerRunMode;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerRuleBuilder;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+public class ProtocolManagementIT {\n+\n+   @ClassRule\n+   public static InfinispanServerRule SERVERS =\n+         InfinispanServerRuleBuilder.config(\"configuration/MultiEndpointClusteredServerTest.xml\")\n+               .runMode(ServerRunMode.EMBEDDED)\n+               .numServers(2)\n+               .property(\"infinispan.bind.address\", \"0.0.0.0\")\n+               .build();\n+\n+   @Rule\n+   public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+   @Test\n+   public void testIpFilter() throws IOException {\n+      NetworkAddress loopback = NetworkAddress.loopback(\"loopback\");\n+      RestClientConfigurationBuilder loopbackBuilder = new RestClientConfigurationBuilder();\n+      loopbackBuilder.addServer().host(loopback.getAddress().getHostAddress()).port(11222);\n+      RestClient loopbackClient = SERVER_TEST.rest().withClientConfiguration(loopbackBuilder).get();\n+      assertEquals(200, sync(loopbackClient.server().connectorNames()).getStatus());\n+\n+      NetworkAddress siteLocal = NetworkAddress.siteLocal(\"sitelocal\");\n+      RestClientConfigurationBuilder siteLocalBuilder0 = new RestClientConfigurationBuilder();\n+      siteLocalBuilder0.addServer().host(siteLocal.getAddress().getHostAddress()).port(11222);\n+      RestClient siteLocalClient0 = SERVER_TEST.rest().withClientConfiguration(siteLocalBuilder0).get();\n+      assertEquals(200, sync(siteLocalClient0.server().connectorNames()).getStatus());\n+\n+      RestClientConfigurationBuilder siteLocalBuilder1 = new RestClientConfigurationBuilder();\n+      siteLocalBuilder1.addServer().host(siteLocal.getAddress().getHostAddress()).port(11322);\n+      RestClient siteLocalClient1 = SERVER_TEST.rest().withClientConfiguration(siteLocalBuilder1).get();\n+      RestResponse response = sync(siteLocalClient1.server().connectorNames());\n+      assertEquals(200, response.getStatus());\n+\n+      List<IpFilterRule> rules = new ArrayList<>();\n+      rules.add(new IpFilterRule(IpFilterRule.RuleType.REJECT, siteLocal.cidr()));\n+      assertEquals(204, sync(loopbackClient.server().connectorIpFilterSet(\"endpoint-default\", rules)).getStatus());", "originalCommit": "70e9b0d34ab99bd874ced60f0cbdc1e6ccfd4699", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDk1MjU5NQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570952595", "bodyText": "Because the response is empty \"ok\" response", "author": "tristantarrant", "createdAt": "2021-02-05T13:03:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg1NzQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg1ODM5MQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570858391", "bodyText": "find and replace 12.0 => 12.1 in all new classes? :)", "author": "pruivo", "createdAt": "2021-02-05T10:09:04Z", "path": "server/tests/src/test/java/org/infinispan/server/functional/ProtocolManagementIT.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package org.infinispan.server.functional;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+\n+import java.io.IOException;\n+import java.net.ConnectException;\n+import java.net.SocketException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+\n+import org.infinispan.client.rest.IpFilterRule;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.commons.test.Exceptions;\n+import org.infinispan.server.network.NetworkAddress;\n+import org.infinispan.server.test.core.ServerRunMode;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerRuleBuilder;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0", "originalCommit": "70e9b0d34ab99bd874ced60f0cbdc1e6ccfd4699", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg2NzM1MQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570867351", "bodyText": "ipv6 testing?", "author": "pruivo", "createdAt": "2021-02-05T10:24:08Z", "path": "server/core/src/test/java/org/infinispan/server/core/configuration/IpSubnetFilterRuleTest.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package org.infinispan.server.core.configuration;\n+\n+import static org.testng.AssertJUnit.assertFalse;\n+import static org.testng.AssertJUnit.assertTrue;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+import org.testng.annotations.Test;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+@Test(groups = \"unit\", testName = \"server.configuration.IpSubnetFilterRuleTest\")\n+public class IpSubnetFilterRuleTest {\n+   public void testIpSubnetFilterRule() throws UnknownHostException {\n+      IpSubnetFilterRule rule = new IpSubnetFilterRule(\"192.168.0.0/16\", IpFilterRuleType.ACCEPT);\n+      assertTrue(rule.matches(new InetSocketAddress(InetAddress.getByName(\"192.168.0.1\"), 11222)));\n+      assertFalse(rule.matches(new InetSocketAddress(InetAddress.getByName(\"10.11.12.13\"), 11222)));\n+      rule = new IpSubnetFilterRule(\"/0\", IpFilterRuleType.REJECT);\n+      assertTrue(rule.matches(new InetSocketAddress(InetAddress.getByName(\"192.168.0.1\"), 11222)));\n+      assertTrue(rule.matches(new InetSocketAddress(InetAddress.getByName(\"10.11.12.13\"), 11222)));", "originalCommit": "70e9b0d34ab99bd874ced60f0cbdc1e6ccfd4699", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg2OTEwNg==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570869106", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class IpFilterRuleCompleter extends EnumCompleter {\n          \n          \n            \n            public class IpFilterRuleCompleter extends EnumCompleter<IpFilterRule.RuleType> {", "author": "pruivo", "createdAt": "2021-02-05T10:27:11Z", "path": "cli/src/main/java/org/infinispan/cli/completers/IpFilterRuleCompleter.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package org.infinispan.cli.completers;\n+\n+import org.infinispan.client.rest.IpFilterRule;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+public class IpFilterRuleCompleter extends EnumCompleter {", "originalCommit": "70e9b0d34ab99bd874ced60f0cbdc1e6ccfd4699", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e20c592825560ae342b939ea66d1654d6d02e432", "url": "https://github.com/infinispan/infinispan/commit/e20c592825560ae342b939ea66d1654d6d02e432", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-05T10:29:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg4ODk4OQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570888989", "bodyText": "needs a toString() for logging\n[org.infinispan.SECURITY] ISPN005052: Rejected connection from '/192.168.2.100:38462' using rule 'org.infinispan.server.core.transport.IpSubnetFilterRule@40b979ac'", "author": "pruivo", "createdAt": "2021-02-05T11:02:21Z", "path": "server/core/src/main/java/org/infinispan/server/core/transport/IpSubnetFilterRule.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.infinispan.server.core.transport;\n+\n+import java.net.InetSocketAddress;\n+\n+import io.netty.handler.ipfilter.IpFilterRule;\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+import io.netty.util.internal.ObjectUtil;\n+\n+/**\n+ * This differs from Netty's equivalent {@link io.netty.handler.ipfilter.IpSubnetFilterRule} in that it parses CIDR\n+ * addresses\n+ *\n+ * @author Tristan Tarrant\n+ * @since 12.1\n+ */\n+public class IpSubnetFilterRule implements IpFilterRule {\n+   private final io.netty.handler.ipfilter.IpSubnetFilterRule rule;\n+   private final String cidr;\n+\n+   public IpSubnetFilterRule(String cidr, IpFilterRuleType type) {\n+      ObjectUtil.checkNotNull(cidr, \"cidr\");\n+      ObjectUtil.checkNotNull(type, \"type\");\n+\n+      int sep = cidr.indexOf('/');\n+      if (sep < 0) {\n+         throw new IllegalArgumentException(cidr);\n+      }\n+      this.cidr = cidr;\n+      this.rule = new io.netty.handler.ipfilter.IpSubnetFilterRule(cidr.substring(0, sep), Integer.parseInt(cidr.substring(sep + 1)), type);\n+   }\n+\n+   public String cidr() {\n+      return cidr;\n+   }\n+\n+   @Override\n+   public boolean matches(InetSocketAddress inetSocketAddress) {\n+      return rule.matches(inetSocketAddress);\n+   }\n+\n+   @Override\n+   public IpFilterRuleType ruleType() {\n+      return rule.ruleType();\n+   }\n+}", "originalCommit": "e20c592825560ae342b939ea66d1654d6d02e432", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg5Njc1NA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570896754", "bodyText": "[usability]\nyou should put an empty list instead of removing the entry\nUse case:\n\nconfigure IP-filter in infinispan.xml\nstart server1\nclear IP-filter in server1\nstart server2 (same config as infinispan.xml)\n\nserver2 contains the IP-filter configured in infinispan.xml instead of disabled IP-filter.", "author": "pruivo", "createdAt": "2021-02-05T11:17:16Z", "path": "server/runtime/src/main/java/org/infinispan/server/state/ServerStateManagerImpl.java", "diffHunk": "@@ -0,0 +1,284 @@\n+package org.infinispan.server.state;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.globalstate.GlobalConfigurationManager;\n+import org.infinispan.globalstate.ScopeFilter;\n+import org.infinispan.globalstate.ScopedState;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryModified;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryModifiedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.security.AuthorizationPermission;\n+import org.infinispan.server.Server;\n+import org.infinispan.server.core.ProtocolServer;\n+import org.infinispan.server.core.ServerStateManager;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+import org.infinispan.server.core.transport.Transport;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * Manages cluster-wide server state for a given {@link EmbeddedCacheManager}. This handles:\n+ * <ul>\n+ * <li>ignored caches</li>\n+ * <li>protocol servers</li>\n+ * <li>ip filters</li>\n+ * </ul>\n+ *\n+ * @since 12.1\n+ */\n+public final class ServerStateManagerImpl implements ServerStateManager {\n+   private static final String CONNECTOR_STATE_SCOPE = \"connector-state\";\n+   private static final String CONNECTOR_IPFILTER_SCOPE = \"connector-ipfilter\";\n+   private static final ScopedState IGNORED_CACHES_KEY = new ScopedState(\"ignored-caches\", \"ignored-caches\");\n+\n+   private final EmbeddedCacheManager cacheManager;\n+   private final Server server;\n+   private final Cache<ScopedState, Object> cache;\n+   private final IgnoredCaches ignored = new IgnoredCaches();\n+   private volatile boolean hasIgnores;\n+\n+   public ServerStateManagerImpl(Server server, EmbeddedCacheManager cacheManager, GlobalConfigurationManager configurationManager) {\n+      this.server = server;\n+      this.cacheManager = cacheManager;\n+      this.cache = configurationManager.getStateCache();\n+\n+      GlobalComponentRegistry registry = SecurityActions.getGlobalComponentRegistry(cacheManager);\n+      SerializationContextRegistry serializationContextRegistry = registry.getComponent(SerializationContextRegistry.class);\n+      serializationContextRegistry.addContextInitializer(SerializationContextRegistry.MarshallerType.PERSISTENCE, new PersistenceContextInitializerImpl());\n+\n+      updateLocalIgnoredCaches((IgnoredCaches) cache.get(IGNORED_CACHES_KEY));\n+\n+      // Register the listeners which will react on\n+      cache.addListener(new IgnoredCachesListener(), new ScopeFilter(IGNORED_CACHES_KEY.getScope()), null);\n+      cache.addListener(new ConnectorStateListener(), new ScopeFilter(CONNECTOR_STATE_SCOPE), null);\n+      cache.addListener(new ConnectorIpFilterListener(), new ScopeFilter(CONNECTOR_IPFILTER_SCOPE), null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> unignoreCache(String cacheName) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      synchronized (this) {\n+         ignored.caches.remove(cacheName);\n+         hasIgnores = !ignored.caches.isEmpty();\n+         return cache.putAsync(IGNORED_CACHES_KEY, ignored).thenApply(r -> null);\n+      }\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> ignoreCache(String cacheName) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      synchronized (this) {\n+         ignored.caches.add(cacheName);\n+         hasIgnores = !ignored.caches.isEmpty();\n+         return cache.putAsync(IGNORED_CACHES_KEY, ignored).thenApply(r -> null);\n+      }\n+   }\n+\n+   @Override\n+   public Set<String> getIgnoredCaches() {\n+      return Collections.unmodifiableSet(ignored.caches);\n+   }\n+\n+   @Override\n+   public boolean isCacheIgnored(String cacheName) {\n+      return hasIgnores && ignored.caches.contains(cacheName);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Boolean> connectorStart(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.removeAsync(new ScopedState(CONNECTOR_STATE_SCOPE, name), true).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> connectorStop(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.putAsync(new ScopedState(CONNECTOR_STATE_SCOPE, name), true).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Boolean> connectorStatus(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return CompletableFuture.completedFuture(server.getProtocolServers().get(name).getTransport().isRunning());\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> setConnectorIpFilterRule(String name, Collection<IpSubnetFilterRule> filterRule) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      IpFilterRules ipFilterRules = new IpFilterRules();\n+      filterRule.forEach(r -> ipFilterRules.rules.add(new IpFilterRule(r)));\n+      return cache.putAsync(new ScopedState(CONNECTOR_IPFILTER_SCOPE, name), ipFilterRules).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> clearConnectorIpFilterRules(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.removeAsync(new ScopedState(CONNECTOR_IPFILTER_SCOPE, name)).thenApply(v -> null);", "originalCommit": "e20c592825560ae342b939ea66d1654d6d02e432", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f48ca50d2c04a93cfbc8c8b969885de6b73e2ae0", "url": "https://github.com/infinispan/infinispan/commit/f48ca50d2c04a93cfbc8c8b969885de6b73e2ae0", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-05T13:49:29Z", "type": "forcePushed"}, {"oid": "34418711aa48c3bb072f467428f32ad986f42c9a", "url": "https://github.com/infinispan/infinispan/commit/34418711aa48c3bb072f467428f32ad986f42c9a", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-05T14:00:47Z", "type": "forcePushed"}, {"oid": "4311422a4c4acd8f37a79a55f61118d4928888a5", "url": "https://github.com/infinispan/infinispan/commit/4311422a4c4acd8f37a79a55f61118d4928888a5", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-05T15:12:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTAzOTIyOA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r571039228", "bodyText": "can be removed. we no longer remove the key from the cache.", "author": "pruivo", "createdAt": "2021-02-05T15:15:15Z", "path": "server/runtime/src/main/java/org/infinispan/server/state/ServerStateManagerImpl.java", "diffHunk": "@@ -0,0 +1,278 @@\n+package org.infinispan.server.state;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.globalstate.GlobalConfigurationManager;\n+import org.infinispan.globalstate.ScopeFilter;\n+import org.infinispan.globalstate.ScopedState;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryModified;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryModifiedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.security.AuthorizationPermission;\n+import org.infinispan.server.Server;\n+import org.infinispan.server.core.ProtocolServer;\n+import org.infinispan.server.core.ServerStateManager;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+import org.infinispan.server.core.transport.Transport;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * Manages cluster-wide server state for a given {@link EmbeddedCacheManager}. This handles:\n+ * <ul>\n+ * <li>ignored caches</li>\n+ * <li>protocol servers</li>\n+ * <li>ip filters</li>\n+ * </ul>\n+ *\n+ * @since 12.1\n+ */\n+public final class ServerStateManagerImpl implements ServerStateManager {\n+   private static final String CONNECTOR_STATE_SCOPE = \"connector-state\";\n+   private static final String CONNECTOR_IPFILTER_SCOPE = \"connector-ipfilter\";\n+   private static final ScopedState IGNORED_CACHES_KEY = new ScopedState(\"ignored-caches\", \"ignored-caches\");\n+\n+   private final EmbeddedCacheManager cacheManager;\n+   private final Server server;\n+   private final Cache<ScopedState, Object> cache;\n+   private final IgnoredCaches ignored = new IgnoredCaches();\n+   private volatile boolean hasIgnores;\n+\n+   public ServerStateManagerImpl(Server server, EmbeddedCacheManager cacheManager, GlobalConfigurationManager configurationManager) {\n+      this.server = server;\n+      this.cacheManager = cacheManager;\n+      this.cache = configurationManager.getStateCache();\n+\n+      updateLocalIgnoredCaches((IgnoredCaches) cache.get(IGNORED_CACHES_KEY));\n+\n+      // Register the listeners which will react on\n+      cache.addListener(new IgnoredCachesListener(), new ScopeFilter(IGNORED_CACHES_KEY.getScope()), null);\n+      cache.addListener(new ConnectorStateListener(), new ScopeFilter(CONNECTOR_STATE_SCOPE), null);\n+      cache.addListener(new ConnectorIpFilterListener(), new ScopeFilter(CONNECTOR_IPFILTER_SCOPE), null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> unignoreCache(String cacheName) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      synchronized (this) {\n+         ignored.caches.remove(cacheName);\n+         hasIgnores = !ignored.caches.isEmpty();\n+         return cache.putAsync(IGNORED_CACHES_KEY, ignored).thenApply(r -> null);\n+      }\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> ignoreCache(String cacheName) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      synchronized (this) {\n+         ignored.caches.add(cacheName);\n+         hasIgnores = !ignored.caches.isEmpty();\n+         return cache.putAsync(IGNORED_CACHES_KEY, ignored).thenApply(r -> null);\n+      }\n+   }\n+\n+   @Override\n+   public Set<String> getIgnoredCaches() {\n+      return Collections.unmodifiableSet(ignored.caches);\n+   }\n+\n+   @Override\n+   public boolean isCacheIgnored(String cacheName) {\n+      return hasIgnores && ignored.caches.contains(cacheName);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Boolean> connectorStart(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.removeAsync(new ScopedState(CONNECTOR_STATE_SCOPE, name), true).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> connectorStop(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.putAsync(new ScopedState(CONNECTOR_STATE_SCOPE, name), true).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Boolean> connectorStatus(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return CompletableFuture.completedFuture(server.getProtocolServers().get(name).getTransport().isRunning());\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> setConnectorIpFilterRule(String name, Collection<IpSubnetFilterRule> filterRule) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      IpFilterRules ipFilterRules = new IpFilterRules();\n+      filterRule.forEach(r -> ipFilterRules.rules.add(new IpFilterRule(r)));\n+      return cache.putAsync(new ScopedState(CONNECTOR_IPFILTER_SCOPE, name), ipFilterRules).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> clearConnectorIpFilterRules(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.putAsync(new ScopedState(CONNECTOR_IPFILTER_SCOPE, name), new IpFilterRules()).thenApply(v -> null);\n+   }\n+\n+   private void updateLocalIgnoredCaches(IgnoredCaches ignored) {\n+      if (ignored != null) {\n+         synchronized (this) {\n+            this.ignored.caches.clear();\n+            this.ignored.caches.addAll(ignored.caches);\n+            hasIgnores = !this.ignored.caches.isEmpty();\n+         }\n+      }\n+   }\n+\n+   @Listener(observation = Listener.Observation.POST)\n+   private final class IgnoredCachesListener {\n+      @CacheEntryCreated\n+      public void created(CacheEntryCreatedEvent<ScopedState, IgnoredCaches> e) {\n+         if (!e.isOriginLocal()) {\n+            updateLocalIgnoredCaches(e.getValue());\n+         }\n+      }\n+\n+      @CacheEntryModified\n+      public void modified(CacheEntryModifiedEvent<ScopedState, IgnoredCaches> e) {\n+         if (!e.isOriginLocal()) {\n+            updateLocalIgnoredCaches(e.getValue());\n+         }\n+      }\n+   }\n+\n+   @Listener(observation = Listener.Observation.POST)\n+   private final class ConnectorStateListener {\n+      @CacheEntryCreated\n+      public void created(CacheEntryCreatedEvent<ScopedState, Boolean> e) {\n+         // stop the connector\n+         server.getProtocolServers().get(e.getKey().getName()).getTransport().stop();\n+      }\n+\n+      @CacheEntryRemoved\n+      public void removed(CacheEntryRemovedEvent<ScopedState, Boolean> e) {\n+         // start the connector\n+         server.getProtocolServers().get(e.getKey().getName()).getTransport().start();\n+      }\n+   }\n+\n+   @Listener(observation = Listener.Observation.POST)\n+   private final class ConnectorIpFilterListener {\n+      @CacheEntryCreated\n+      @CacheEntryModified\n+      public CompletionStage<Void> modified(CacheEntryEvent<ScopedState, IpFilterRules> e) {\n+         String connector = e.getKey().getName();\n+         ProtocolServer protocolServer = server.getProtocolServers().get(connector);\n+         List<IpSubnetFilterRule> rules = new ArrayList<>(e.getValue().rules.size());\n+                  for (IpFilterRule rule : e.getValue().rules) {\n+            rules.add(new IpSubnetFilterRule(rule.cidr, IpFilterRuleType.valueOf(rule.type)));\n+         }\n+         protocolServer.getConfiguration().ipFilter().rules(rules);\n+         Transport transport = protocolServer.getTransport();\n+         if (transport != null) {\n+            return transport.applyIpFilterRules(rules).thenApply(v -> {\n+               Server.log.connectorIpFilterSet(connector, rules);\n+               return v;\n+            });\n+         } else {\n+            return CompletableFutures.completedExceptionFuture(Server.log.noConnectorTransport(connector));\n+         }\n+      }\n+\n+      @CacheEntryRemoved\n+      public void removed(CacheEntryRemovedEvent<ScopedState, IpFilterRules> e) {\n+         String connector = e.getKey().getName();\n+         server.getProtocolServers().get(connector).getConfiguration().ipFilter().rules().clear();", "originalCommit": "4311422a4c4acd8f37a79a55f61118d4928888a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTA0MjIyMw==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r571042223", "bodyText": "Done", "author": "tristantarrant", "createdAt": "2021-02-05T15:19:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTAzOTIyOA=="}], "type": "inlineReview"}, {"oid": "2525a10bb343d6f110dbb34acfffda31c5ac6a35", "url": "https://github.com/infinispan/infinispan/commit/2525a10bb343d6f110dbb34acfffda31c5ac6a35", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-05T15:19:13Z", "type": "forcePushed"}, {"oid": "95a3cf2e49f3b986177aba40713f7ab5668a8abb", "url": "https://github.com/infinispan/infinispan/commit/95a3cf2e49f3b986177aba40713f7ab5668a8abb", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-09T08:36:09Z", "type": "forcePushed"}, {"oid": "4dfc550da0365f1d8ce51d935a1314b8de1a28c3", "url": "https://github.com/infinispan/infinispan/commit/4dfc550da0365f1d8ce51d935a1314b8de1a28c3", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-09T12:20:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzAyMDE2MA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573020160", "bodyText": "IDE says it is not needed anymore", "author": "pruivo", "createdAt": "2021-02-09T16:10:39Z", "path": "server/core/src/main/java/org/infinispan/server/core/transport/RuleBasedIpFilter.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package org.infinispan.server.core.transport;\n+\n+import java.net.InetSocketAddress;\n+\n+import org.infinispan.server.core.configuration.IpFilterConfiguration;\n+import org.infinispan.server.core.logging.Log;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.handler.ipfilter.IpFilterRule;\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * This class provides the functionality to either accept or reject new {@link Channel}s based on their IP address.\n+ * <p>\n+ * You should inherit from this class if you would like to implement your own IP-based filter. Basically you have to\n+ * implement {@link #accept(ChannelHandlerContext, InetSocketAddress)} to decided whether you want to accept or reject a\n+ * connection from the remote address.\n+ *\n+ * @since 12.1\n+ */\n+@Sharable\n+public class RuleBasedIpFilter extends ChannelInboundHandlerAdapter {\n+   private final IpFilterConfiguration rules;\n+\n+   public RuleBasedIpFilter(IpFilterConfiguration rules) {\n+      this.rules = rules;\n+   }\n+\n+   @Override\n+   public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+      if (evt instanceof ChannelHandoverEvent) {\n+         processRules(ctx);\n+      }\n+   }\n+\n+   protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) throws Exception {\n+      for (IpFilterRule rule : rules.rules()) {\n+         if (rule.matches(remoteAddress)) {\n+            if (rule.ruleType() == IpFilterRuleType.REJECT) {\n+               Log.SECURITY.ipFilterConnectionRejection(remoteAddress, rule);\n+            }\n+            return rule.ruleType() == IpFilterRuleType.ACCEPT;\n+         }\n+      }\n+      return true;\n+   }\n+\n+   @Override\n+   public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+      processRules(ctx);\n+      ctx.fireChannelRegistered();\n+   }\n+\n+   @Override\n+   public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+      if (!processRules(ctx)) {\n+         throw new IllegalStateException(\"cannot determine to accept or reject a channel: \" + ctx.channel());\n+      } else {\n+         ctx.fireChannelActive();\n+      }\n+   }\n+\n+   private boolean processRules(ChannelHandlerContext ctx) throws Exception {\n+      @SuppressWarnings(\"unchecked\")", "originalCommit": "4dfc550da0365f1d8ce51d935a1314b8de1a28c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzAyMDkwNg==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573020906", "bodyText": "nit: move the instance to upper class?", "author": "pruivo", "createdAt": "2021-02-09T16:11:33Z", "path": "server/core/src/main/java/org/infinispan/server/core/transport/RuleBasedIpFilter.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package org.infinispan.server.core.transport;\n+\n+import java.net.InetSocketAddress;\n+\n+import org.infinispan.server.core.configuration.IpFilterConfiguration;\n+import org.infinispan.server.core.logging.Log;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.handler.ipfilter.IpFilterRule;\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * This class provides the functionality to either accept or reject new {@link Channel}s based on their IP address.\n+ * <p>\n+ * You should inherit from this class if you would like to implement your own IP-based filter. Basically you have to\n+ * implement {@link #accept(ChannelHandlerContext, InetSocketAddress)} to decided whether you want to accept or reject a\n+ * connection from the remote address.\n+ *\n+ * @since 12.1\n+ */\n+@Sharable\n+public class RuleBasedIpFilter extends ChannelInboundHandlerAdapter {\n+   private final IpFilterConfiguration rules;\n+\n+   public RuleBasedIpFilter(IpFilterConfiguration rules) {\n+      this.rules = rules;\n+   }\n+\n+   @Override\n+   public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+      if (evt instanceof ChannelHandoverEvent) {\n+         processRules(ctx);\n+      }\n+   }\n+\n+   protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) throws Exception {\n+      for (IpFilterRule rule : rules.rules()) {\n+         if (rule.matches(remoteAddress)) {\n+            if (rule.ruleType() == IpFilterRuleType.REJECT) {\n+               Log.SECURITY.ipFilterConnectionRejection(remoteAddress, rule);\n+            }\n+            return rule.ruleType() == IpFilterRuleType.ACCEPT;\n+         }\n+      }\n+      return true;\n+   }\n+\n+   @Override\n+   public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+      processRules(ctx);\n+      ctx.fireChannelRegistered();\n+   }\n+\n+   @Override\n+   public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+      if (!processRules(ctx)) {\n+         throw new IllegalStateException(\"cannot determine to accept or reject a channel: \" + ctx.channel());\n+      } else {\n+         ctx.fireChannelActive();\n+      }\n+   }\n+\n+   private boolean processRules(ChannelHandlerContext ctx) throws Exception {\n+      @SuppressWarnings(\"unchecked\")\n+      InetSocketAddress remoteAddress = (InetSocketAddress) ctx.channel().remoteAddress();\n+\n+      // If the remote address is not available yet, defer the decision.\n+      if (remoteAddress == null) {\n+         return false;\n+      }\n+\n+      // No need to keep this handler in the pipeline anymore because the decision is going to be made now.\n+      // Also, this will prevent the subsequent events from being handled by this handler.\n+      ctx.pipeline().remove(this);\n+\n+      if (!accept(ctx, remoteAddress)) {\n+         ctx.close();\n+      }\n+\n+      return true;\n+   }\n+\n+   public static class ChannelHandoverEvent {\n+      public static final ChannelHandoverEvent INSTANCE = new ChannelHandoverEvent();", "originalCommit": "4dfc550da0365f1d8ce51d935a1314b8de1a28c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzAyNDA2MQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573024061", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return new SinglePortRouterConfiguration(attributes.protect(), sslConfigurationBuilder.create(), new IpFilterConfiguration(new ArrayList<>()));\n          \n          \n            \n                        return new SinglePortRouterConfiguration(attributes.protect(), sslConfigurationBuilder.create(), new IpFilterConfiguration(Collections.emptyList()));", "author": "pruivo", "createdAt": "2021-02-09T16:15:44Z", "path": "server/router/src/main/java/org/infinispan/server/router/configuration/builder/SinglePortRouterBuilder.java", "diffHunk": "@@ -58,7 +55,7 @@ else if (keystorePath != null) {\n             attributes.attribute(ProtocolServerConfiguration.RECV_BUF_SIZE).set(receiveBufferSize);\n             attributes.attribute(ProtocolServerConfiguration.SEND_BUF_SIZE).set(sendBufferSize);\n             attributes.attribute(ProtocolServerConfiguration.WORKER_THREADS).set(1);\n-            return new SinglePortRouterConfiguration(attributes.protect(), sslConfigurationBuilder.create());\n+            return new SinglePortRouterConfiguration(attributes.protect(), sslConfigurationBuilder.create(), new IpFilterConfiguration(new ArrayList<>()));", "originalCommit": "4dfc550da0365f1d8ce51d935a1314b8de1a28c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzAyODY1MA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573028650", "bodyText": "remove System.out.println()?", "author": "pruivo", "createdAt": "2021-02-09T16:21:31Z", "path": "server/tests/src/test/java/org/infinispan/server/functional/ProtocolManagementIT.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package org.infinispan.server.functional;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+import java.io.IOException;\n+import java.net.ConnectException;\n+import java.net.SocketException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+\n+import org.infinispan.client.hotrod.RemoteCacheManager;\n+import org.infinispan.client.hotrod.configuration.ClientIntelligence;\n+import org.infinispan.client.hotrod.configuration.ConfigurationBuilder;\n+import org.infinispan.client.hotrod.exceptions.TransportException;\n+import org.infinispan.client.rest.IpFilterRule;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.commons.test.Exceptions;\n+import org.infinispan.server.network.NetworkAddress;\n+import org.infinispan.server.test.core.ServerRunMode;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerRuleBuilder;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.1\n+ **/\n+public class ProtocolManagementIT {\n+\n+   @ClassRule\n+   public static InfinispanServerRule SERVERS =\n+         InfinispanServerRuleBuilder.config(\"configuration/MultiEndpointClusteredServerTest.xml\")\n+               .runMode(ServerRunMode.EMBEDDED)\n+               .numServers(2)\n+               .property(\"infinispan.bind.address\", \"0.0.0.0\")\n+               .build();\n+\n+   @Rule\n+   public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+   @Test\n+   public void testIpFilter() throws IOException {\n+      NetworkAddress loopback = NetworkAddress.loopback(\"loopback\");\n+      RestClientConfigurationBuilder loopbackBuilder = new RestClientConfigurationBuilder();\n+      loopbackBuilder.addServer().host(loopback.getAddress().getHostAddress()).port(11222);\n+      RestClient loopbackClient = SERVER_TEST.rest().withClientConfiguration(loopbackBuilder).get();\n+      assertEquals(200, sync(loopbackClient.server().connectorNames()).getStatus());\n+\n+      NetworkAddress siteLocal = NetworkAddress.siteLocal(\"sitelocal\");\n+      RestClientConfigurationBuilder siteLocalBuilder0 = new RestClientConfigurationBuilder();\n+      siteLocalBuilder0.addServer().host(siteLocal.getAddress().getHostAddress()).port(11222);\n+      RestClient siteLocalClient0 = SERVER_TEST.rest().withClientConfiguration(siteLocalBuilder0).get();\n+      assertEquals(200, sync(siteLocalClient0.server().connectorNames()).getStatus());\n+\n+      RestClientConfigurationBuilder siteLocalBuilder1 = new RestClientConfigurationBuilder();\n+      siteLocalBuilder1.addServer().host(siteLocal.getAddress().getHostAddress()).port(11322);\n+      RestClient siteLocalClient1 = SERVER_TEST.rest().withClientConfiguration(siteLocalBuilder1).get();\n+      RestResponse response = sync(siteLocalClient1.server().connectorNames());\n+      System.out.println(response.getBody());", "originalCommit": "4dfc550da0365f1d8ce51d935a1314b8de1a28c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzAyOTAyMw==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573029023", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  Exceptions.expectException(TransportException.class, () -> siteLocalRemoteCacheManager.getCacheNames());\n          \n          \n            \n                  Exceptions.expectException(TransportException.class, siteLocalRemoteCacheManager::getCacheNames);", "author": "pruivo", "createdAt": "2021-02-09T16:22:02Z", "path": "server/tests/src/test/java/org/infinispan/server/functional/ProtocolManagementIT.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package org.infinispan.server.functional;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+import java.io.IOException;\n+import java.net.ConnectException;\n+import java.net.SocketException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+\n+import org.infinispan.client.hotrod.RemoteCacheManager;\n+import org.infinispan.client.hotrod.configuration.ClientIntelligence;\n+import org.infinispan.client.hotrod.configuration.ConfigurationBuilder;\n+import org.infinispan.client.hotrod.exceptions.TransportException;\n+import org.infinispan.client.rest.IpFilterRule;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.commons.test.Exceptions;\n+import org.infinispan.server.network.NetworkAddress;\n+import org.infinispan.server.test.core.ServerRunMode;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerRuleBuilder;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.1\n+ **/\n+public class ProtocolManagementIT {\n+\n+   @ClassRule\n+   public static InfinispanServerRule SERVERS =\n+         InfinispanServerRuleBuilder.config(\"configuration/MultiEndpointClusteredServerTest.xml\")\n+               .runMode(ServerRunMode.EMBEDDED)\n+               .numServers(2)\n+               .property(\"infinispan.bind.address\", \"0.0.0.0\")\n+               .build();\n+\n+   @Rule\n+   public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+   @Test\n+   public void testIpFilter() throws IOException {\n+      NetworkAddress loopback = NetworkAddress.loopback(\"loopback\");\n+      RestClientConfigurationBuilder loopbackBuilder = new RestClientConfigurationBuilder();\n+      loopbackBuilder.addServer().host(loopback.getAddress().getHostAddress()).port(11222);\n+      RestClient loopbackClient = SERVER_TEST.rest().withClientConfiguration(loopbackBuilder).get();\n+      assertEquals(200, sync(loopbackClient.server().connectorNames()).getStatus());\n+\n+      NetworkAddress siteLocal = NetworkAddress.siteLocal(\"sitelocal\");\n+      RestClientConfigurationBuilder siteLocalBuilder0 = new RestClientConfigurationBuilder();\n+      siteLocalBuilder0.addServer().host(siteLocal.getAddress().getHostAddress()).port(11222);\n+      RestClient siteLocalClient0 = SERVER_TEST.rest().withClientConfiguration(siteLocalBuilder0).get();\n+      assertEquals(200, sync(siteLocalClient0.server().connectorNames()).getStatus());\n+\n+      RestClientConfigurationBuilder siteLocalBuilder1 = new RestClientConfigurationBuilder();\n+      siteLocalBuilder1.addServer().host(siteLocal.getAddress().getHostAddress()).port(11322);\n+      RestClient siteLocalClient1 = SERVER_TEST.rest().withClientConfiguration(siteLocalBuilder1).get();\n+      RestResponse response = sync(siteLocalClient1.server().connectorNames());\n+      System.out.println(response.getBody());\n+      assertEquals(200, response.getStatus());\n+\n+      List<IpFilterRule> rules = new ArrayList<>();\n+      rules.add(new IpFilterRule(IpFilterRule.RuleType.REJECT, siteLocal.cidr()));\n+      assertEquals(204, sync(loopbackClient.server().connectorIpFilterSet(\"endpoint-default\", rules)).getStatus());\n+      Exceptions.expectException(RuntimeException.class, ExecutionException.class, SocketException.class, () -> sync(siteLocalClient0.server().connectorNames()));\n+      Exceptions.expectException(RuntimeException.class, ExecutionException.class, SocketException.class, () -> sync(siteLocalClient1.server().connectorNames()));\n+      assertEquals(204, sync(loopbackClient.server().connectorIpFiltersClear(\"endpoint-default\")).getStatus());\n+      assertEquals(200, sync(siteLocalClient0.server().connectorNames()).getStatus());\n+      assertEquals(200, sync(siteLocalClient1.server().connectorNames()).getStatus());\n+\n+      // Apply the filter just on the Hot Rod endpoint\n+      assertEquals(204, sync(loopbackClient.server().connectorIpFilterSet(\"HotRod-hotrod\", rules)).getStatus());\n+      ConfigurationBuilder hotRodSiteLocalBuilder = new ConfigurationBuilder();\n+      hotRodSiteLocalBuilder.addServer().host(siteLocal.getAddress().getHostAddress()).port(11222).clientIntelligence(ClientIntelligence.BASIC);\n+      RemoteCacheManager siteLocalRemoteCacheManager = SERVER_TEST.hotrod().withClientConfiguration(hotRodSiteLocalBuilder).createRemoteCacheManager();\n+      Exceptions.expectException(TransportException.class, () -> siteLocalRemoteCacheManager.getCacheNames());", "originalCommit": "4dfc550da0365f1d8ce51d935a1314b8de1a28c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d42cf755eab86314647f0718e0a8a04d2f2f72a4", "url": "https://github.com/infinispan/infinispan/commit/d42cf755eab86314647f0718e0a8a04d2f2f72a4", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-10T14:25:54Z", "type": "forcePushed"}, {"oid": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c", "url": "https://github.com/infinispan/infinispan/commit/49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-10T14:32:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk4NjEwMQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573986101", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  pipeline.addLast(new AccessControlFilter(restServerConfiguration, false));\n          \n          \n            \n                  pipeline.addLast(new AccessControlFilter<>(restServerConfiguration, false));", "author": "pruivo", "createdAt": "2021-02-10T18:48:13Z", "path": "server/rest/src/main/java/org/infinispan/rest/ALPNHandler.java", "diffHunk": "@@ -78,9 +80,12 @@ public void configurePipeline(ChannelPipeline pipeline, String protocol) {\n    /**\n     * Configure the handlers that should be used for both HTTP 1.1 and HTTP 2.0\n     */\n-   private void addCommonsHandlers(ChannelPipeline pipeline) {\n+   private void addCommonHandlers(ChannelPipeline pipeline) {\n+      // Handles IP filtering for the HTTP connector\n+      RestServerConfiguration restServerConfiguration = restServer.getConfiguration();\n+      pipeline.addLast(new AccessControlFilter(restServerConfiguration, false));", "originalCommit": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk4OTA0Ng==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573989046", "bodyText": "nit: remove extra line", "author": "pruivo", "createdAt": "2021-02-10T18:52:07Z", "path": "server/rest/src/main/java/org/infinispan/rest/NettyRestRequest.java", "diffHunk": "@@ -44,10 +45,12 @@\n    private final String path;\n    private final ContentSource contentSource;\n    private final String context;\n+   private final InetSocketAddress remoteAddress;\n    private String action;\n    private Subject subject;\n    private Map<String, String> variables;\n \n+", "originalCommit": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk5MDM0OQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573990349", "bodyText": "offtopic:\nthere is a bug in setSubject() method. It should be this.subject = principal", "author": "pruivo", "createdAt": "2021-02-10T18:54:09Z", "path": "server/rest/src/main/java/org/infinispan/rest/framework/impl/SimpleRequest.java", "diffHunk": "@@ -1,5 +1,6 @@\n package org.infinispan.rest.framework.impl;\n \n+import java.net.InetSocketAddress;", "originalCommit": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk5NTQzOA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573995438", "bodyText": "suggestion: add the rule to the message?", "author": "pruivo", "createdAt": "2021-02-10T19:00:58Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ServerResource.java", "diffHunk": "@@ -91,15 +109,142 @@ public Invocations getInvocations() {\n       DefaultCacheManager cacheManager = invocationHelper.getServer().getCacheManager(cacheManagerName);\n \n       if (cacheManager == null) return notFoundResponseFuture();\n-      CacheIgnoreManager ignoreManager = invocationHelper.getServer().getIgnoreManager(cacheManagerName);\n-      Set<String> ignored = ignoreManager.getIgnoredCaches();\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager();\n+      Set<String> ignored = serverStateManager.getIgnoredCaches();\n       return asJsonResponseFuture(Json.make(ignored));\n    }\n \n    private CompletionStage<RestResponse> cacheManagers(RestRequest restRequest) {\n       return asJsonResponseFuture(Json.make(invocationHelper.getServer().cacheManagerNames()));\n    }\n \n+   private CompletionStage<RestResponse> connectorStartStop(RestRequest restRequest) {\n+      SecurityActions.checkPermission(invocationHelper, restRequest, AuthorizationPermission.ADMIN);\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder().status(NO_CONTENT);\n+      String connectorName = restRequest.variables().get(\"connector\");\n+      ProtocolServer connector = invocationHelper.getServer().getProtocolServers().get(connectorName);\n+      if (connector == null) return completedFuture(builder.status(NOT_FOUND).build());\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager();\n+      switch (restRequest.getAction()) {\n+         case \"start\":\n+            return serverStateManager.connectorStart(connectorName).thenApply(r -> builder.build());\n+         case \"stop\":\n+            if (connector.equals(invocationHelper.getProtocolServer()) || connector.equals(invocationHelper.getProtocolServer().getEnclosingProtocolServer())) {\n+               return completedFuture(builder.status(CONFLICT).entity(\"Connector matches request address\").build());\n+            } else {\n+               return serverStateManager.connectorStop(connectorName).thenApply(r -> builder.build());\n+            }\n+      }\n+      return completedFuture(builder.status(BAD_REQUEST).build());\n+   }\n+\n+   private CompletionStage<RestResponse> connectorStatus(RestRequest restRequest) {\n+      SecurityActions.checkPermission(invocationHelper, restRequest, AuthorizationPermission.ADMIN);\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      String connectorName = restRequest.variables().get(\"connector\");\n+\n+      ProtocolServer connector = getProtocolServer(restRequest);\n+      if (connector == null) return completedFuture(builder.status(NOT_FOUND).build());\n+\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager();\n+\n+      Json info = Json.object()\n+            .set(\"name\", connectorName)\n+            .set(\"enabled\", connector.getConfiguration().isEnabled())\n+            .set(\"ip-filter-rules\", ipFilterRulesAsJson(connector));\n+      Transport transport = connector.getTransport();\n+      if (transport != null) {\n+         info.set(\"host\", transport.getHostName())\n+               .set(\"port\", transport.getPort())\n+               .set(\"local-connections\", transport.getNumberOfLocalConnections())\n+               .set(\"global-connections\", transport.getNumberOfGlobalConnections())\n+               .set(\"io-threads\", transport.getNumberIOThreads())\n+               .set(\"pending-tasks\", transport.getPendingTasks())\n+               .set(\"total-bytes-read\", transport.getTotalBytesRead())\n+               .set(\"total-bytes-written\", transport.getTotalBytesWritten())\n+               .set(\"send-buffer-size\", transport.getSendBufferSize())\n+               .set(\"receive-buffer-size\", transport.getReceiveBufferSize());\n+         return serverStateManager.connectorStatus(connectorName).thenApply(b -> builder.contentType(APPLICATION_JSON).entity(info.set(\"enabled\", b)).build());\n+      } else {\n+         return completedFuture(builder.contentType(APPLICATION_JSON).entity(info).build());\n+      }\n+   }\n+\n+   private CompletionStage<RestResponse> connectorIpFilterList(RestRequest restRequest) {\n+      SecurityActions.checkPermission(invocationHelper, restRequest, AuthorizationPermission.ADMIN);\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      ProtocolServer connector = getProtocolServer(restRequest);\n+      if (connector == null) return completedFuture(builder.status(NOT_FOUND).build());\n+\n+      return completedFuture(addEntityAsJson(ipFilterRulesAsJson(connector), builder).build());\n+   }\n+\n+   private Json ipFilterRulesAsJson(ProtocolServer connector) {\n+      Collection<IpSubnetFilterRule> rules = connector.getConfiguration().ipFilter().rules();\n+      Json array = Json.array();\n+      for (IpSubnetFilterRule rule : rules) {\n+         array.add(Json.object().set(\"type\", rule.ruleType().name().toLowerCase()).set(\"from\", rule.cidr()));\n+      }\n+      return array;\n+   }\n+\n+   private ProtocolServer getProtocolServer(RestRequest restRequest) {\n+      String connectorName = restRequest.variables().get(\"connector\");\n+      return invocationHelper.getServer().getProtocolServers().get(connectorName);\n+   }\n+\n+   private CompletionStage<RestResponse> connectorIpFilterClear(RestRequest restRequest) {\n+      SecurityActions.checkPermission(invocationHelper, restRequest, AuthorizationPermission.ADMIN);\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder().status(NO_CONTENT);\n+\n+      String connectorName = restRequest.variables().get(\"connector\");\n+      ProtocolServer connector = invocationHelper.getServer().getProtocolServers().get(connectorName);\n+      if (connector == null) return completedFuture(builder.status(NOT_FOUND).build());\n+\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager();\n+      return serverStateManager.clearConnectorIpFilterRules(connectorName).thenApply(r -> builder.build());\n+   }\n+\n+   private CompletionStage<RestResponse> listConnectors(RestRequest restRequest) {\n+      SecurityActions.checkPermission(invocationHelper, restRequest, AuthorizationPermission.ADMIN);\n+      return asJsonResponseFuture(Json.make(invocationHelper.getServer().getProtocolServers().keySet()));\n+   }\n+\n+   private CompletionStage<RestResponse> connectorIpFilterSet(RestRequest restRequest) {\n+      SecurityActions.checkPermission(invocationHelper, restRequest, AuthorizationPermission.ADMIN);\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder().status(NO_CONTENT);\n+\n+      String connectorName = restRequest.variables().get(\"connector\");\n+      ProtocolServer connector = invocationHelper.getServer().getProtocolServers().get(connectorName);\n+      if (connector == null) return completedFuture(builder.status(NOT_FOUND).build());\n+\n+      Json json = Json.read(restRequest.contents().asString());\n+      if (!json.isArray()) {\n+         return completedFuture(builder.status(BAD_REQUEST).build());\n+      }\n+      List<Json> list = json.asJsonList();\n+      List<IpSubnetFilterRule> rules = new ArrayList<>(list.size());\n+      for (Json o : list) {\n+         if (!o.has(\"type\") || !o.has(\"cidr\")) {\n+            return completedFuture(builder.status(BAD_REQUEST).build());\n+         } else {\n+            rules.add(new IpSubnetFilterRule(o.at(\"cidr\").asString(), IpFilterRuleType.valueOf(o.at(\"type\").asString())));\n+         }\n+      }\n+      // Verify that none of the REJECT rules match the address from which the request was made\n+      if (connector.equals(invocationHelper.getProtocolServer()) || connector.equals(invocationHelper.getProtocolServer().getEnclosingProtocolServer())) {\n+         for (IpSubnetFilterRule rule : rules) {\n+            if (rule.ruleType() == IpFilterRuleType.REJECT && rule.matches(restRequest.getRemoteAddress())) {\n+               return completedFuture(builder.status(CONFLICT).entity(\"Reject rule matches request address\").build());", "originalCommit": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk5NzE2Mw==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573997163", "bodyText": "IDE reports this is not used. and it should be used :)", "author": "pruivo", "createdAt": "2021-02-10T19:03:37Z", "path": "server/runtime/src/main/java/org/infinispan/server/logging/Log.java", "diffHunk": "@@ -200,4 +202,23 @@\n \n    @Message(value = \"Encryption cannot be configured without a security realm\", id = 80053)\n    CacheConfigurationException encryptionWithoutSecurityRealm();\n+\n+   @LogMessage(level = Logger.Level.INFO)\n+   @Message(value = \"Connector '%s': IP Filter cleared\", id = 80054)\n+   void connectorIpFilterCleared(String connector);", "originalCommit": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk5NzI3NQ==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573997275", "bodyText": "can be removed now :)", "author": "pruivo", "createdAt": "2021-02-10T19:03:47Z", "path": "server/runtime/src/main/java/org/infinispan/server/logging/Log.java", "diffHunk": "@@ -200,4 +202,23 @@\n \n    @Message(value = \"Encryption cannot be configured without a security realm\", id = 80053)\n    CacheConfigurationException encryptionWithoutSecurityRealm();\n+\n+   @LogMessage(level = Logger.Level.INFO)\n+   @Message(value = \"Connector '%s': IP Filter cleared\", id = 80054)\n+   void connectorIpFilterCleared(String connector);\n+\n+   @LogMessage(level = Logger.Level.INFO)\n+   @Message(value = \"Connector '%s': IP Filter set: %s\", id = 80055)\n+   void connectorIpFilterSet(String connector, List<IpSubnetFilterRule> rules);\n+\n+   @Message(value = \"Connector '%s' cannot be configured since it has no transport\", id = 80056)\n+   IllegalArgumentException noConnectorTransport(String connector);", "originalCommit": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk5OTY4Mg==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573999682", "bodyText": "can be simplified for the case where rules.isEmpty(): (I think)\n\nset an empty list protocolServer.getConfiguration().ipFilter().rules(Collections.emptyList());\nlog it: log.connectorIpFilterCleared()", "author": "pruivo", "createdAt": "2021-02-10T19:07:28Z", "path": "server/runtime/src/main/java/org/infinispan/server/state/ServerStateManagerImpl.java", "diffHunk": "@@ -0,0 +1,290 @@\n+package org.infinispan.server.state;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.globalstate.GlobalConfigurationManager;\n+import org.infinispan.globalstate.ScopeFilter;\n+import org.infinispan.globalstate.ScopedState;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryModified;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryModifiedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.security.AuthorizationPermission;\n+import org.infinispan.server.Server;\n+import org.infinispan.server.core.ProtocolServer;\n+import org.infinispan.server.core.ServerStateManager;\n+import org.infinispan.server.core.transport.CompositeChannelMatcher;\n+import org.infinispan.server.core.transport.IpFilterRuleChannelMatcher;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+import org.infinispan.server.core.transport.Transport;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * Manages cluster-wide server state for a given {@link EmbeddedCacheManager}. This handles:\n+ * <ul>\n+ * <li>ignored caches</li>\n+ * <li>protocol servers</li>\n+ * <li>ip filters</li>\n+ * </ul>\n+ *\n+ * @since 12.1\n+ */\n+public final class ServerStateManagerImpl implements ServerStateManager {\n+   private static final String CONNECTOR_STATE_SCOPE = \"connector-state\";\n+   private static final String CONNECTOR_IPFILTER_SCOPE = \"connector-ipfilter\";\n+   private static final ScopedState IGNORED_CACHES_KEY = new ScopedState(\"ignored-caches\", \"ignored-caches\");\n+\n+   private final EmbeddedCacheManager cacheManager;\n+   private final Server server;\n+   private final Cache<ScopedState, Object> cache;\n+   private final IgnoredCaches ignored = new IgnoredCaches();\n+   private volatile boolean hasIgnores;\n+\n+   public ServerStateManagerImpl(Server server, EmbeddedCacheManager cacheManager, GlobalConfigurationManager configurationManager) {\n+      this.server = server;\n+      this.cacheManager = cacheManager;\n+      this.cache = configurationManager.getStateCache();\n+\n+      updateLocalIgnoredCaches((IgnoredCaches) cache.get(IGNORED_CACHES_KEY));\n+\n+      // Register the listeners which will react on\n+      cache.addListener(new IgnoredCachesListener(), new ScopeFilter(IGNORED_CACHES_KEY.getScope()), null);\n+      cache.addListener(new ConnectorStateListener(), new ScopeFilter(CONNECTOR_STATE_SCOPE), null);\n+      cache.addListener(new ConnectorIpFilterListener(), new ScopeFilter(CONNECTOR_IPFILTER_SCOPE), null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> unignoreCache(String cacheName) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      synchronized (this) {\n+         ignored.caches.remove(cacheName);\n+         hasIgnores = !ignored.caches.isEmpty();\n+         return cache.putAsync(IGNORED_CACHES_KEY, ignored).thenApply(r -> null);\n+      }\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> ignoreCache(String cacheName) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      synchronized (this) {\n+         ignored.caches.add(cacheName);\n+         hasIgnores = !ignored.caches.isEmpty();\n+         return cache.putAsync(IGNORED_CACHES_KEY, ignored).thenApply(r -> null);\n+      }\n+   }\n+\n+   @Override\n+   public Set<String> getIgnoredCaches() {\n+      return Collections.unmodifiableSet(ignored.caches);\n+   }\n+\n+   @Override\n+   public boolean isCacheIgnored(String cacheName) {\n+      return hasIgnores && ignored.caches.contains(cacheName);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Boolean> connectorStart(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.removeAsync(new ScopedState(CONNECTOR_STATE_SCOPE, name), true).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> connectorStop(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.putAsync(new ScopedState(CONNECTOR_STATE_SCOPE, name), true).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Boolean> connectorStatus(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return CompletableFuture.completedFuture(server.getProtocolServers().get(name).getTransport().isRunning());\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> setConnectorIpFilterRule(String name, Collection<IpSubnetFilterRule> filterRule) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      IpFilterRules ipFilterRules = new IpFilterRules();\n+      filterRule.forEach(r -> ipFilterRules.rules.add(new IpFilterRule(r)));\n+      return cache.putAsync(new ScopedState(CONNECTOR_IPFILTER_SCOPE, name), ipFilterRules).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> clearConnectorIpFilterRules(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.putAsync(new ScopedState(CONNECTOR_IPFILTER_SCOPE, name), new IpFilterRules()).thenApply(v -> null);\n+   }\n+\n+   private void updateLocalIgnoredCaches(IgnoredCaches ignored) {\n+      if (ignored != null) {\n+         synchronized (this) {\n+            this.ignored.caches.clear();\n+            this.ignored.caches.addAll(ignored.caches);\n+            hasIgnores = !this.ignored.caches.isEmpty();\n+         }\n+      }\n+   }\n+\n+   private CompletionStage<Void> updateIpFilters(String connector, Collection<IpFilterRule> rules) {\n+      ProtocolServer protocolServer = server.getProtocolServers().get(connector);\n+      List<IpSubnetFilterRule> localRules = new ArrayList<>(rules.size());", "originalCommit": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDAyMjYwNw==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r574022607", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return context.getConnection().getConnectorNames();\n          \n          \n            \n                  try {\n          \n          \n            \n                     return context.getConnection().getConnectorNames();\n          \n          \n            \n                  } catch (Exception e) {\n          \n          \n            \n                     return Collections.emptyList();\n          \n          \n            \n                  }\n          \n      \n    \n    \n  \n\nI would put a try-catch block to avoid adding the exception stack trace to the console. Example:\n[pedro-laptop-3-52395@cluster//containers/default]> server connector ipfilter ls java.nio.file.AccessDeniedException: The user is not allowed to access the server resource: ISPN000287: Unauthorized access: subject 'Subject with principal(s): [pedro, RolePrincipal{name='reader'}]' lacks 'ADMIN' permission\n\tat org.infinispan.cli.connection.rest.RestConnection.handleResponseStatus(RestConnection.java:163)\n\tat org.infinispan.cli.connection.rest.RestConnection.parseBody(RestConnection.java:129)\n\tat org.infinispan.cli.connection.rest.RestConnection.getConnectorNames(RestConnection.java:372)", "author": "pruivo", "createdAt": "2021-02-10T19:42:07Z", "path": "cli/src/main/java/org/infinispan/cli/completers/ConnectorCompleter.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package org.infinispan.cli.completers;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+\n+import org.infinispan.cli.Context;\n+\n+/**\n+ * A {@link org.aesh.command.completer.OptionCompleter} for protocol connectors.\n+ *\n+ * @author Tristan Tarrant\n+ * @since 12.1\n+ */\n+public class ConnectorCompleter extends ListCompleter {\n+   @Override\n+   Collection<String> getAvailableItems(Context context) throws IOException {\n+      return context.getConnection().getConnectorNames();", "originalCommit": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1792819261e25201c5643ad25e720b9eb30e8c92", "url": "https://github.com/infinispan/infinispan/commit/1792819261e25201c5643ad25e720b9eb30e8c92", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-11T09:56:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTExMDMwNA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r575110304", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Informational Scripting messages. These start from 12500 so as not to overlap with the logging\n          \n          \n            \n             * Informational Rest Server messages. These start from 12500 so as not to overlap with the logging\n          \n      \n    \n    \n  \n\nis there a document with the Message's ids? Some Messages classes have ids, other don't, others have messages with and without id (org.infinispan.util.logging.events.Messages).", "author": "pruivo", "createdAt": "2021-02-12T10:02:55Z", "path": "server/rest/src/main/java/org/infinispan/rest/logging/Messages.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package org.infinispan.rest.logging;\n+\n+import org.jboss.logging.annotations.Message;\n+import org.jboss.logging.annotations.MessageBundle;\n+\n+/**\n+ * Informational Scripting messages. These start from 12500 so as not to overlap with the logging", "originalCommit": "1792819261e25201c5643ad25e720b9eb30e8c92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzcxODQzNA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r577718434", "bodyText": "They use the same ranges as the logging ids and those are defined in the contribution guide", "author": "tristantarrant", "createdAt": "2021-02-17T15:42:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTExMDMwNA=="}], "type": "inlineReview"}, {"oid": "6a3a1ce90502eaa9eb3b3d82e47a299185cf823e", "url": "https://github.com/infinispan/infinispan/commit/6a3a1ce90502eaa9eb3b3d82e47a299185cf823e", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-17T15:32:56Z", "type": "forcePushed"}, {"oid": "cbf47b3e1b397499eb681ca2cda993ea1323bdd8", "url": "https://github.com/infinispan/infinispan/commit/cbf47b3e1b397499eb681ca2cda993ea1323bdd8", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-18T09:02:25Z", "type": "forcePushed"}, {"oid": "c79ab8be652337c56ac75950b820f86ba2b6c375", "url": "https://github.com/infinispan/infinispan/commit/c79ab8be652337c56ac75950b820f86ba2b6c375", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-19T07:48:52Z", "type": "forcePushed"}, {"oid": "9e658a0482276de09b9e553e714b5f0aede3b151", "url": "https://github.com/infinispan/infinispan/commit/9e658a0482276de09b9e553e714b5f0aede3b151", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-19T09:49:24Z", "type": "forcePushed"}, {"oid": "12867910bf5bcbbc88e33f4c08bf6c8f17e1b264", "url": "https://github.com/infinispan/infinispan/commit/12867910bf5bcbbc88e33f4c08bf6c8f17e1b264", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-22T07:23:22Z", "type": "forcePushed"}, {"oid": "678b19cfdbfc8c55c9163081ac11d7bff682d061", "url": "https://github.com/infinispan/infinispan/commit/678b19cfdbfc8c55c9163081ac11d7bff682d061", "message": "fixup! WIP", "committedDate": "2021-02-22T20:47:32Z", "type": "forcePushed"}, {"oid": "2bed264624caaef64695aecc9a85e0b94128616b", "url": "https://github.com/infinispan/infinispan/commit/2bed264624caaef64695aecc9a85e0b94128616b", "message": "fixup! WIP", "committedDate": "2021-02-23T12:39:12Z", "type": "forcePushed"}, {"oid": "1880e0fd956aa084a6f7276720d6c0d5f75caaa6", "url": "https://github.com/infinispan/infinispan/commit/1880e0fd956aa084a6f7276720d6c0d5f75caaa6", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-24T09:35:28Z", "type": "forcePushed"}, {"oid": "ee1e8eda3c10d22805958d703255ec117a406b32", "url": "https://github.com/infinispan/infinispan/commit/ee1e8eda3c10d22805958d703255ec117a406b32", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-24T09:46:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTgyMDIzNA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r581820234", "bodyText": "findAddress() may return null.\nyou may want to throw new IOException(\"No matching addresses found\"); if that is the case.", "author": "pruivo", "createdAt": "2021-02-24T10:00:17Z", "path": "server/runtime/src/main/java/org/infinispan/server/network/NetworkAddress.java", "diffHunk": "@@ -97,6 +131,11 @@ public static NetworkAddress matchHost(String name, String regex) throws IOExcep\n       return new NetworkAddress(name, findAddress(a -> a.getHostName().matches(regex)));\n    }\n \n+   public static NetworkAddress match(String name, Predicate<NetworkInterface> ifMatcher, Predicate<InetAddress> addressMatcher) throws IOException {\n+      NetworkInterface networkInterface = findInterface(ifMatcher);\n+      return new NetworkAddress(name, findAddress(networkInterface, addressMatcher));", "originalCommit": "ee1e8eda3c10d22805958d703255ec117a406b32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTg0Nzk5Mw==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r581847993", "bodyText": "report() test is missing.", "author": "pruivo", "createdAt": "2021-02-24T10:38:34Z", "path": "server/tests/src/test/java/org/infinispan/server/security/authorization/AbstractAuthorization.java", "diffHunk": "@@ -263,29 +264,50 @@ public void testRestNonAdminsMustNotModifyLoggers() {\n    }\n \n    @Test\n-   public void testRestNonAdminsMustNotObtainReport() {\n+   public void testRestAdminsShoudleBeAbleToAdminServer() {\n+      RestClientConfigurationBuilder adminConfig = restBuilders.get(\"admin\");\n+      assertEquals(204, sync(getServerTest().rest().withClientConfiguration(adminConfig).get().server().connectorStop(\"endpoint-alternate-1\")).getStatus());", "originalCommit": "ee1e8eda3c10d22805958d703255ec117a406b32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkzNTQwNA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r581935404", "bodyText": "That's because for report to work, we need to have the report.sh script available and that is not true currently for these integration tests. I'll look into it as part of my authz work", "author": "tristantarrant", "createdAt": "2021-02-24T12:55:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTg0Nzk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTg1MDExMg==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r581850112", "bodyText": "nit, all this asserts could be in the single method:\nprivate void checkAdminServer(int status, String user) {\n  RestClientConfigurationBuilder adminConfig = restBuilders.get(user);\n  assertEquals(status, ....);\n  ... \n}", "author": "pruivo", "createdAt": "2021-02-24T10:41:24Z", "path": "server/tests/src/test/java/org/infinispan/server/security/authorization/AbstractAuthorization.java", "diffHunk": "@@ -263,29 +264,50 @@ public void testRestNonAdminsMustNotModifyLoggers() {\n    }\n \n    @Test\n-   public void testRestNonAdminsMustNotObtainReport() {\n+   public void testRestAdminsShoudleBeAbleToAdminServer() {\n+      RestClientConfigurationBuilder adminConfig = restBuilders.get(\"admin\");\n+      assertEquals(204, sync(getServerTest().rest().withClientConfiguration(adminConfig).get().server().connectorStop(\"endpoint-alternate-1\")).getStatus());\n+      assertEquals(204, sync(getServerTest().rest().withClientConfiguration(adminConfig).get().server().connectorStart(\"endpoint-alternate-1\")).getStatus());", "originalCommit": "ee1e8eda3c10d22805958d703255ec117a406b32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTg1MTExNA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r581851114", "bodyText": "ps. maybe ^ can be done in another PR. the ignore cache tests aren't checking if the admin can do the task or not (same for xsite as reported by Katia).\nps2. org.infinispan.server.test.core.Common#assertStatus() could be used instead of asserEquals()  :)", "author": "pruivo", "createdAt": "2021-02-24T10:42:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTg1MDExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTkzNTY4MA==", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r581935680", "bodyText": "Yes, let's defer to my current authz work", "author": "tristantarrant", "createdAt": "2021-02-24T12:56:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTg1MDExMg=="}], "type": "inlineReview"}, {"oid": "d4e8175b31c1eb8154816a6ea9199f5895e52c73", "url": "https://github.com/infinispan/infinispan/commit/d4e8175b31c1eb8154816a6ea9199f5895e52c73", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-24T12:54:20Z", "type": "forcePushed"}, {"oid": "3315c371e4024f51b1b14992009505cb99fb700a", "url": "https://github.com/infinispan/infinispan/commit/3315c371e4024f51b1b14992009505cb99fb700a", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-24T14:09:41Z", "type": "commit"}, {"oid": "3315c371e4024f51b1b14992009505cb99fb700a", "url": "https://github.com/infinispan/infinispan/commit/3315c371e4024f51b1b14992009505cb99fb700a", "message": "ISPN-12261 Protocol Management", "committedDate": "2021-02-24T14:09:41Z", "type": "forcePushed"}]}