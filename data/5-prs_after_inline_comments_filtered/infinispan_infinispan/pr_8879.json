{"pr_number": 8879, "pr_title": "ISPN-12477 Remove IRAC sender thread", "pr_createdAt": "2020-11-23T16:10:39Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8879", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0NDA0Nw==", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535344047", "bodyText": "We should be able to utilize the segment from the command if it is a single key command. Otherwise we will have to calculate the segment for each command. Sadly multi put doesn't yet have this optimization.", "author": "wburns", "createdAt": "2020-12-03T15:40:22Z", "path": "core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java", "diffHunk": "@@ -134,4 +146,12 @@ private Object handleClearReturn(InvocationContext ctx, ClearCommand rCommand, O\n          return localTx.getModifications().stream();\n       }\n    }\n+\n+   public Stream<?> keysFromMods(Stream<WriteCommand> modifications) {\n+      return modifications\n+            .filter(WriteCommand::isSuccessful)\n+            .filter(BaseBackupInterceptor::backupToRemoteSite)\n+            .flatMap(BaseBackupInterceptor::keyStream)\n+            .filter(this::isWriteOwner);", "originalCommit": "dda8a648db53be74a8f1da359109f8b322779b58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0NDg4OQ==", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535344889", "bodyText": "We again calculate the segment for the key here too. Is there a better way we can share the segment down the line?", "author": "wburns", "createdAt": "2020-12-03T15:41:08Z", "path": "core/src/main/java/org/infinispan/interceptors/xsite/OptimisticBackupInterceptor.java", "diffHunk": "@@ -44,13 +44,13 @@ public Object visitCommitCommand(TxInvocationContext ctx, CommitCommand command)\n \n       return invokeNextThenApply(ctx, command, (rCtx, rCommand, rv) -> {\n          //we need to track the keys only after it is applied in the local node!\n-         iracManager.trackKeysFromTransaction(getModificationsFrom(rCommand), rCommand.getGlobalTransaction());\n+         keysFromMods(getModificationsFrom(rCommand)).forEach(key -> iracManager.trackUpdatedKey(getSegment(key), key, rCommand.getGlobalTransaction()));", "originalCommit": "dda8a648db53be74a8f1da359109f8b322779b58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ2NDI5OA==", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535464298", "bodyText": "probably aggregating the key&segment in some data class.\nyeah, I think it would be possible.", "author": "pruivo", "createdAt": "2020-12-03T18:08:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0NDg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0NTI1Nw==", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535345257", "bodyText": "Same here about segment being recalculated.", "author": "wburns", "createdAt": "2020-12-03T15:41:29Z", "path": "core/src/main/java/org/infinispan/interceptors/xsite/PessimisticBackupInterceptor.java", "diffHunk": "@@ -40,7 +40,8 @@ public Object visitPrepareCommand(TxInvocationContext ctx, PrepareCommand comman\n \n       return invokeNextThenApply(ctx, command, (rCtx, rCommand, rv) -> {\n          //for async, all nodes need to keep track of the updates keys after it is applied locally.\n-         iracManager.trackKeysFromTransaction(Arrays.stream(rCommand.getModifications()), rCommand.getGlobalTransaction());\n+         keysFromMods(Arrays.stream(rCommand.getModifications()))\n+               .forEach(key -> iracManager.trackUpdatedKey(getSegment(key), key, rCommand.getGlobalTransaction()));", "originalCommit": "dda8a648db53be74a8f1da359109f8b322779b58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0NjQ1Mw==", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535346453", "bodyText": "It seems we can remove backoffSleep now?", "author": "wburns", "createdAt": "2020-12-03T15:42:34Z", "path": "core/src/main/java/org/infinispan/util/ExponentialBackOff.java", "diffHunk": "@@ -50,4 +58,12 @@ public void reset() {\n     */\n    void reset();\n \n+   /**\n+    * Same as {@link #backoffSleep()} but it returns a {@link CompletionStage} which is completed after the back-off", "originalCommit": "dda8a648db53be74a8f1da359109f8b322779b58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ2NDY2MA==", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535464660", "bodyText": "I'm free to ideas... I can keep it or remove it. it isn't used anymore.", "author": "pruivo", "createdAt": "2020-12-03T18:09:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0NjQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1MzUyNQ==", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535353525", "bodyText": "I assume the use of thenCompose(this) is to avoid the lambda allocation?", "author": "wburns", "createdAt": "2020-12-03T15:49:10Z", "path": "core/src/main/java/org/infinispan/xsite/irac/IracExecutor.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package org.infinispan.xsite.irac;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.util.ExponentialBackOff;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+import org.infinispan.util.concurrent.WithinThreadExecutor;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+\n+/**\n+ * Executes the \"IRAC\" sending task in a single thread.\n+ * <p>\n+ * This executor makes sure no more than one task is running at the same time. Also, it avoids \"queueing\" multiple tasks\n+ * by queuing at most one. This is possible because the task does the same thing: iterator over pending updates and send\n+ * them to the remote site.\n+ * <p>\n+ * In addition, it iteracts with the {@link ExponentialBackOff} to add delays in case of network failures.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12\n+ */\n+public class IracExecutor implements Function<Void, CompletionStage<Void>> {\n+\n+   private static final Log log = LogFactory.getLog(IracExecutor.class);\n+\n+   private final WrappedRunnable runnable;\n+   private volatile CompletableFuture<Void> lastRunnable;\n+   private volatile Executor executor;\n+   private volatile ExponentialBackOff backOff;\n+   final AtomicBoolean hasPendingRunnable;\n+   private volatile boolean backOffEnabled;\n+\n+\n+   public IracExecutor(Supplier<CompletionStage<Void>> runnable) {\n+      this.runnable = new WrappedRunnable(Objects.requireNonNull(runnable));\n+      this.lastRunnable = CompletableFutures.completedNull();\n+      this.executor = new WithinThreadExecutor();\n+      this.hasPendingRunnable = new AtomicBoolean();\n+   }\n+\n+   public void setExecutor(Executor executor) {\n+      this.executor = Objects.requireNonNull(executor);\n+   }\n+\n+   public void setBackOff(ExponentialBackOff backOff) {\n+      this.backOff = Objects.requireNonNull(backOff);\n+   }\n+\n+   /**\n+    * Executes, in a new thread, or queues the task.\n+    */\n+   public void run() {\n+      if (hasPendingRunnable.compareAndSet(false, true)) {\n+         if (backOffEnabled) {\n+            //noinspection NonAtomicOperationOnVolatileField\n+            lastRunnable = lastRunnable.thenCompose(this).thenComposeAsync(runnable, executor);", "originalCommit": "dda8a648db53be74a8f1da359109f8b322779b58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ2NDkyOQ==", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535464929", "bodyText": "yes. it adds the backoff completion stage to the chain.", "author": "pruivo", "createdAt": "2020-12-03T18:09:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1MzUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1NDc4MA==", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535354780", "bodyText": "Maybe I am misreading but doesn't this mean you can run another task at the same time if IracExecutor#run is invoked while runnable supplier is being invoked and the stage has not been completed? Or what is the definition of a task in the class javadoc header?", "author": "wburns", "createdAt": "2020-12-03T15:50:13Z", "path": "core/src/main/java/org/infinispan/xsite/irac/IracExecutor.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package org.infinispan.xsite.irac;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.util.ExponentialBackOff;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+import org.infinispan.util.concurrent.WithinThreadExecutor;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+\n+/**\n+ * Executes the \"IRAC\" sending task in a single thread.\n+ * <p>\n+ * This executor makes sure no more than one task is running at the same time. Also, it avoids \"queueing\" multiple tasks\n+ * by queuing at most one. This is possible because the task does the same thing: iterator over pending updates and send\n+ * them to the remote site.\n+ * <p>\n+ * In addition, it iteracts with the {@link ExponentialBackOff} to add delays in case of network failures.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12\n+ */\n+public class IracExecutor implements Function<Void, CompletionStage<Void>> {\n+\n+   private static final Log log = LogFactory.getLog(IracExecutor.class);\n+\n+   private final WrappedRunnable runnable;\n+   private volatile CompletableFuture<Void> lastRunnable;\n+   private volatile Executor executor;\n+   private volatile ExponentialBackOff backOff;\n+   final AtomicBoolean hasPendingRunnable;\n+   private volatile boolean backOffEnabled;\n+\n+\n+   public IracExecutor(Supplier<CompletionStage<Void>> runnable) {\n+      this.runnable = new WrappedRunnable(Objects.requireNonNull(runnable));\n+      this.lastRunnable = CompletableFutures.completedNull();\n+      this.executor = new WithinThreadExecutor();\n+      this.hasPendingRunnable = new AtomicBoolean();\n+   }\n+\n+   public void setExecutor(Executor executor) {\n+      this.executor = Objects.requireNonNull(executor);\n+   }\n+\n+   public void setBackOff(ExponentialBackOff backOff) {\n+      this.backOff = Objects.requireNonNull(backOff);\n+   }\n+\n+   /**\n+    * Executes, in a new thread, or queues the task.\n+    */\n+   public void run() {\n+      if (hasPendingRunnable.compareAndSet(false, true)) {\n+         if (backOffEnabled) {\n+            //noinspection NonAtomicOperationOnVolatileField\n+            lastRunnable = lastRunnable.thenCompose(this).thenComposeAsync(runnable, executor);\n+         } else {\n+            //noinspection NonAtomicOperationOnVolatileField\n+            lastRunnable = lastRunnable.thenComposeAsync(runnable, executor);\n+         }\n+      }\n+   }\n+\n+   public void enableBackOff() {\n+      backOffEnabled = true;\n+   }\n+\n+   public void disableBackOff() {\n+      backOffEnabled = false;\n+      backOff.reset();\n+   }\n+\n+   /**\n+    * Used by {@link CompletableFuture#thenComposeAsync(Function, Executor)}, it adds the {@link ExponentialBackOff}\n+    * delay.\n+    *\n+    * @param unused Unused value.\n+    * @return The {@link CompletionStage} from {@link ExponentialBackOff#asyncBackOff()}.\n+    */\n+   @Override\n+   public CompletionStage<Void> apply(Void unused) {\n+      return backOff.asyncBackOff();\n+   }\n+\n+   private class WrappedRunnable implements Function<Void, CompletionStage<Void>> {\n+      private final Supplier<CompletionStage<Void>> runnable;\n+\n+      private WrappedRunnable(Supplier<CompletionStage<Void>> runnable) {\n+         this.runnable = runnable;\n+      }\n+\n+      /**\n+       * Use by {@link CompletableFuture#thenComposeAsync(Function, Executor)}, executes the task and returns the {@link\n+       * CompletionStage} return by it.\n+       *\n+       * @param unused Unused value.\n+       * @return The {@link CompletionStage} from the task.\n+       */\n+      @Override\n+      public CompletionStage<Void> apply(Void unused) {\n+         hasPendingRunnable.set(false);", "originalCommit": "dda8a648db53be74a8f1da359109f8b322779b58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ3NTg0OQ==", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535475849", "bodyText": "The task is \"iterate over all pending keys and send the update to the remote site\" (not sure how to call it or if you have a better name)\nSo, my idea was to keep the chain of \"thenCompose\" smaller a possible and have a single task pending in \"thenCompose\". When hasPendingRunnable is false, a write operation is able to \"queue\" the task. When this task starts executing, it sets it to false and allows the next write operation to queue.\nnot sure If I was clear... it is late and my brain is lagging :/", "author": "pruivo", "createdAt": "2020-12-03T18:22:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1NDc4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgwNzE3OQ==", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r537807179", "bodyText": "Okay I see you are enqueuing as a chained stage and only allowing chaining if the most recent chain has started running/completed.", "author": "wburns", "createdAt": "2020-12-07T20:24:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1NDc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM2MjE3OA==", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535362178", "bodyText": "This class really reminds me of the AggregateCompletionStage. Is there no way we can use that instead of adding more aggregation logic?", "author": "wburns", "createdAt": "2020-12-03T15:58:54Z", "path": "core/src/main/java/org/infinispan/xsite/irac/IracResponseCollector.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package org.infinispan.xsite.irac;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.BiConsumer;\n+\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.infinispan.xsite.status.DefaultTakeOfflineManager;\n+\n+import net.jcip.annotations.GuardedBy;\n+\n+/**\n+ * A response collector for a single key update.\n+ * <p>\n+ * This class extends {@link CompletableFuture}. It is completed when all sites involved in the updated have replied (or\n+ * timed-out). There are 3 possible outcomes enumerated by {@link Result}.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12\n+ */\n+public class IracResponseCollector extends CompletableFuture<IracResponseCollector.Result> implements BiConsumer<Void, Throwable> {", "originalCommit": "dda8a648db53be74a8f1da359109f8b322779b58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ3MDg1Ng==", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535470856", "bodyText": "I kind of copied it. But I needed special logic to merge the values from the remote sites.", "author": "pruivo", "createdAt": "2020-12-03T18:16:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM2MjE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5ODkzOA==", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535398938", "bodyText": "Can't this be the non blocking executor? Or does something block in DefaultIracManager#run?", "author": "wburns", "createdAt": "2020-12-03T16:44:50Z", "path": "core/src/main/java/org/infinispan/xsite/irac/DefaultIracManager.java", "diffHunk": "@@ -73,115 +69,66 @@\n  * @since 11.0\n  */\n @Scope(Scopes.NAMED_CACHE)\n-public class DefaultIracManager implements IracManager, Runnable {\n+public class DefaultIracManager implements IracManager {\n \n    private static final Log log = LogFactory.getLog(DefaultIracManager.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    @Inject RpcManager rpcManager;\n-   @Inject Configuration config;\n    @Inject TakeOfflineManager takeOfflineManager;\n    @Inject ClusteringDependentLogic clusteringDependentLogic;\n    @Inject CommandsFactory commandsFactory;\n    @Inject IracVersionGenerator iracVersionGenerator;\n \n-   private final Map<Object, Object> updatedKeys;\n-   private final Semaphore senderNotifier;\n-   private volatile ExponentialBackOff backOff;\n+   private final Map<Object, State> updatedKeys;\n+   private final Collection<XSiteBackup> asyncBackups;\n+   private final IracExecutor iracExecutor;\n    private volatile boolean hasClear;\n-   private volatile Collection<XSiteBackup> asyncBackups;\n-   private volatile Thread sender;\n-   private volatile boolean running;\n \n-   public DefaultIracManager() {\n+   public DefaultIracManager(Configuration config) {\n       this.updatedKeys = new ConcurrentHashMap<>();\n-      this.senderNotifier = new Semaphore(0);\n-      this.backOff = new ExponentialBackOffImpl();\n+      this.iracExecutor = new IracExecutor(this::run);\n+      this.asyncBackups = asyncBackups(config);\n    }\n \n-   private static Collection<XSiteBackup> asyncBackups(Configuration config, String localSiteName) {\n+   private static Collection<XSiteBackup> asyncBackups(Configuration config) {\n       return config.sites().asyncBackupsStream()\n-            .filter(bc -> !localSiteName.equals(bc.site()))\n             .map(bc -> new XSiteBackup(bc.site(), true, bc.replicationTimeout())) //convert to sync\n             .collect(Collectors.toList());\n    }\n \n-   private static Stream<?> keyStream(WriteCommand command) {\n-      return command.getAffectedKeys().stream();\n-   }\n-\n-   private static boolean backupToRemoteSite(WriteCommand command) {\n-      return !command.hasAnyFlag(FlagBitSets.SKIP_XSITE_BACKUP);\n-   }\n-\n    private static IntSet newIntSet(Address ignored) {\n       return IntSets.mutableEmptySet();\n    }\n \n+   @Inject\n+   public void inject(@ComponentName(KnownComponentNames.TIMEOUT_SCHEDULE_EXECUTOR) ScheduledExecutorService executorService,\n+                      @ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor blockingExecutor) {", "originalCommit": "dda8a648db53be74a8f1da359109f8b322779b58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ2Nzk0OQ==", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535467949", "bodyText": "It peeks the DataContainer & Persistence (if enabled). I didn't want to do a special case for when persistence is disabled :)\n(ps. also, can block in JGroups' Flow Control)", "author": "pruivo", "createdAt": "2020-12-03T18:13:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5ODkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU1MjYxNA==", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535552614", "bodyText": "The former two are fine (data container peek is non blocking and persistence uses a blocking thread if needed). And sadly JGroups blocking is something that can just happen atm, not much we can do. I would propose making this the non blocking executor though.", "author": "wburns", "createdAt": "2020-12-03T20:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5ODkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5ODYzOQ==", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r536198639", "bodyText": "If we have persistence, the non-blocking thread will iterate over all keys and trigger a persistence.load() to send the key/value to the remote site.\nWouldn't it spawn a new blocking thread for each key? if it would, would it be ok?", "author": "pruivo", "createdAt": "2020-12-04T15:54:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5ODkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5OTcwOA==", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r536199708", "bodyText": "Oh you are manually iterating? And not using keySet or Publisher or anything?", "author": "wburns", "createdAt": "2020-12-04T15:55:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5ODkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxNTIzNw==", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r536215237", "bodyText": "It is a ConcurrentHashMap. It contains the keys changes.", "author": "pruivo", "createdAt": "2020-12-04T16:18:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5ODkzOA=="}], "type": "inlineReview"}, {"oid": "eb4b6894ddbda4743a5888fce41bad28f7bc1f33", "url": "https://github.com/infinispan/infinispan/commit/eb4b6894ddbda4743a5888fce41bad28f7bc1f33", "message": "ISPN-12477 Remove IRAC sender thread", "committedDate": "2020-12-04T16:50:17Z", "type": "forcePushed"}, {"oid": "80bb1afd5221e67ddbd7c10781a96a4888fb1173", "url": "https://github.com/infinispan/infinispan/commit/80bb1afd5221e67ddbd7c10781a96a4888fb1173", "message": "ISPN-12477 Remove IRAC sender thread", "committedDate": "2020-12-09T10:24:28Z", "type": "commit"}, {"oid": "80bb1afd5221e67ddbd7c10781a96a4888fb1173", "url": "https://github.com/infinispan/infinispan/commit/80bb1afd5221e67ddbd7c10781a96a4888fb1173", "message": "ISPN-12477 Remove IRAC sender thread", "committedDate": "2020-12-09T10:24:28Z", "type": "forcePushed"}]}