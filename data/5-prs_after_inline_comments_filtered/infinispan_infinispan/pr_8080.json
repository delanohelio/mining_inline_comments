{"pr_number": 8080, "pr_title": "ISPN-11489 PersistenceManagerImpl thread checks need to be updated", "pr_createdAt": "2020-03-23T18:01:54Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8080", "timeline": [{"oid": "a805ad9530f40f97f550ea3e3a741c8863e3984f", "url": "https://github.com/infinispan/infinispan/commit/a805ad9530f40f97f550ea3e3a741c8863e3984f", "message": "ISPN-11482 Provide way for ClusterExecutor to use non blocking thread\n\n* Make sure cluster executor is running on a blocking thread", "committedDate": "2020-03-25T15:22:04Z", "type": "forcePushed"}, {"oid": "1d2ba55cfaae5c6a324c61ec78f22848883b4790", "url": "https://github.com/infinispan/infinispan/commit/1d2ba55cfaae5c6a324c61ec78f22848883b4790", "message": "ISPN-11482 Provide way for ClusterExecutor to use non blocking thread\n\n* Make sure cluster executor is running on a blocking thread", "committedDate": "2020-03-25T15:23:21Z", "type": "forcePushed"}, {"oid": "510a274eb56939c85cfac364299a8bc28013576c", "url": "https://github.com/infinispan/infinispan/commit/510a274eb56939c85cfac364299a8bc28013576c", "message": "ISPN-11482 Provide way for ClusterExecutor to use non blocking thread\n\n* Make sure cluster executor is running on a blocking thread", "committedDate": "2020-03-25T15:35:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4NjY4NA==", "url": "https://github.com/infinispan/infinispan/pull/8080#discussion_r399086684", "bodyText": "And now the comment makes sense :P", "author": "danberindei", "createdAt": "2020-03-27T07:52:21Z", "path": "core/src/main/java/org/infinispan/manager/impl/ReplicableRunnableCommand.java", "diffHunk": "@@ -57,6 +57,6 @@ public boolean isReturnValueExpected() {\n    @Override\n    public boolean canBlock() {\n       // These commands can be arbitrary user commands - so be careful about them blocking\n-      return false;\n+      return true;", "originalCommit": "510a274eb56939c85cfac364299a8bc28013576c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4OTMwNw==", "url": "https://github.com/infinispan/infinispan/pull/8080#discussion_r399089307", "bodyText": "We should probably use DefaultThreadFactory", "author": "danberindei", "createdAt": "2020-03-27T07:58:29Z", "path": "core/src/main/java/org/infinispan/persistence/manager/StartThreadAction.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package org.infinispan.persistence.manager;\n+\n+import java.security.PrivilegedAction;\n+\n+/**\n+ * StartThreadAction.\n+ *\n+ * @author William Burns\n+ * @since 11.0\n+ */\n+public class StartThreadAction implements PrivilegedAction<Void> {\n+\n+   private final Runnable task;\n+   private final String threadName;\n+\n+   public StartThreadAction(Runnable task, String threadName) {\n+      this.task = task;\n+      this.threadName = threadName;\n+   }\n+\n+   @Override\n+   public Void run() {\n+      Thread thread = new Thread(task, threadName);", "originalCommit": "510a274eb56939c85cfac364299a8bc28013576c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI4NzExNw==", "url": "https://github.com/infinispan/infinispan/pull/8080#discussion_r399287117", "bodyText": "Actually it's temporary, so no need to make it fancy.", "author": "danberindei", "createdAt": "2020-03-27T14:03:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4OTMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTExMjc4OQ==", "url": "https://github.com/infinispan/infinispan/pull/8080#discussion_r399112789", "bodyText": "This is definitely worth a comment. Does RxJava guarantee that it will request a new thread from the scheduler only once, on the thread that subscribes to the Flowable, or could it be on a non-blocking thread when using continueOnCPUExecutor?\nI was thinking of a different workaround: check whether the caller thread is a blocking thread once, at the beginning of every method, and pass that information in order to avoid submitting a task to the blocking executor and submitting a task to the non-blocking executor (if we switched to a non-blocking thread in the middle of the bulk operation, we'd need a new blocking thread for the next blocking task).", "author": "danberindei", "createdAt": "2020-03-27T08:48:33Z", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -181,7 +181,13 @@ public void start() {\n       advancedListener = new AdvancedPurgeListener<>(expirationManager.wired());\n       preloaded = false;\n       enabled = configuration.persistence().usingStores();\n-      blockingScheduler = Schedulers.from(blockingExecutor);\n+      blockingScheduler = Schedulers.from(task -> {\n+         if (isCurrentThreadBlocking()) {\n+            SecurityActions.startThread(task, \"persistence-bulk-blocking-operation\");", "originalCommit": "510a274eb56939c85cfac364299a8bc28013576c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI0NjQyNQ==", "url": "https://github.com/infinispan/infinispan/pull/8080#discussion_r399246425", "bodyText": "This is definitely worth a comment. Does RxJava guarantee that it will request a new thread from the scheduler only once, on the thread that subscribes to the Flowable, or could it be on a non-blocking thread when using continueOnCPUExecutor?\n\nThis is standard rxjava stuff with schedulers and how reactive streams work. You only subscribe to the publisher once, thus only one blocking thread is in use. Observation is also only a single thread at a time (processing a queue) However a non blocking thread will never subscribe to a flowable as it is only on publishing of a value.\nThe only way subscription will happen concurrently is if you use the parallel method or flatMap with subscribeOn in the resulting Publishers.\n\nI was thinking of a different workaround: check whether the caller thread is a blocking thread once, at the beginning of every method, and pass that information in order to avoid submitting a task to the blocking executor and submitting a task to the non-blocking executor (if we switched to a non-blocking thread in the middle of the bulk operation, we'd need a new blocking thread for the next blocking task).\n\nThis is actually what I have in my pending work.\nAlso you don't \"switch\" between blocking threads, there would only be one. And you don't \"switch\" to a non blocking thread in the middle. It is only publishing of a value, so it is only operators below that. You can think of it this way that subscribeOn allows a different thread to process all operators until it is fully published or it runs into a subscribeOn. In the latter it just passes the value to a queue to be processed by the other thread. And note observeOn will only allow 1 thread to be processing at a time per Publisher. Everything is per publisher.", "author": "wburns", "createdAt": "2020-03-27T13:00:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTExMjc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI2MzQyNw==", "url": "https://github.com/infinispan/infinispan/pull/8080#discussion_r399263427", "bodyText": "The only way subscription will happen concurrently is if you use the parallel method or flatMap with subscribeOn in the resulting Publishers.\n\nYeah, that's what I was thinking about. What if the caller does use parallel?\n\nThis is actually what I have in my pending work.\n\nOk then :)", "author": "danberindei", "createdAt": "2020-03-27T13:28:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTExMjc4OQ=="}], "type": "inlineReview"}, {"oid": "9a9484b397b3f475cd8643dea1a8011ad7ba6f85", "url": "https://github.com/infinispan/infinispan/commit/9a9484b397b3f475cd8643dea1a8011ad7ba6f85", "message": "ISPN-11443 PersistenceManagerImpl thread checks need to be updated\n\n* Now run inline for blocking threads", "committedDate": "2020-03-27T13:37:40Z", "type": "commit"}, {"oid": "57f2f060458c495a7bad6d40d2a85f15cacc69ab", "url": "https://github.com/infinispan/infinispan/commit/57f2f060458c495a7bad6d40d2a85f15cacc69ab", "message": "ISPN-11489 TransactionCoordinator updated for non blocking\n\n* Revert to invoking xa based ops on calling thread", "committedDate": "2020-03-27T13:37:40Z", "type": "commit"}, {"oid": "d37f7117021d6e24ed9c60d49dd3361261b6bb05", "url": "https://github.com/infinispan/infinispan/commit/d37f7117021d6e24ed9c60d49dd3361261b6bb05", "message": "ISPN-11482 Provide way for ClusterExecutor to use non blocking thread\n\n* Make sure cluster executor is running on a blocking thread", "committedDate": "2020-03-27T13:37:40Z", "type": "commit"}, {"oid": "d37f7117021d6e24ed9c60d49dd3361261b6bb05", "url": "https://github.com/infinispan/infinispan/commit/d37f7117021d6e24ed9c60d49dd3361261b6bb05", "message": "ISPN-11482 Provide way for ClusterExecutor to use non blocking thread\n\n* Make sure cluster executor is running on a blocking thread", "committedDate": "2020-03-27T13:37:40Z", "type": "forcePushed"}]}