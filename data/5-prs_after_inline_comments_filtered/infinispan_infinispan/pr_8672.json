{"pr_number": 8672, "pr_title": "ISPN-12250 Add exponential back-off for cross-site network failures", "pr_createdAt": "2020-09-04T14:12:09Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8672", "timeline": [{"oid": "8ae78df7508e39d4e87414531421664665db72eb", "url": "https://github.com/infinispan/infinispan/commit/8ae78df7508e39d4e87414531421664665db72eb", "message": "ISPN-12250 Add exponential back-off for cross-site network failures", "committedDate": "2020-09-04T14:13:08Z", "type": "forcePushed"}, {"oid": "d8689815a1dcb68bed021e6239dff1700926a6d2", "url": "https://github.com/infinispan/infinispan/commit/d8689815a1dcb68bed021e6239dff1700926a6d2", "message": "ISPN-12250 Add exponential back-off for cross-site network failures", "committedDate": "2020-09-07T13:15:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEyODk3Mw==", "url": "https://github.com/infinispan/infinispan/pull/8672#discussion_r487128973", "bodyText": "I am not a fan of this. Can we not instead use the TIMEOUT_SCHEDULE_EXECUTOR executor to do this? Or is it required to stay in the invoking thread for preserveOrder ?", "author": "wburns", "createdAt": "2020-09-11T15:40:01Z", "path": "core/src/main/java/org/infinispan/util/ExponentialBackOff.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package org.infinispan.util;\n+\n+import org.infinispan.commons.util.Experimental;\n+\n+/**\n+ * Interface to implement an exponential back-off algorithm that retries the request based on the result of the remote\n+ * operation.\n+ * <p>\n+ * Currently only used for IRAC, this interface contains 2 methods: {@link #backoffSleep()} which should be invoked if\n+ * the request needs to be retried and {@link #reset()}, invoked when a request is \"successful\", which resets the\n+ * state.\n+ * <p>\n+ * The interface may me changed in the future to include async methods.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12.0\n+ */\n+@Experimental\n+public interface ExponentialBackOff {\n+\n+   /**\n+    * Disabled exponential back-off algorithm. It does nothing.\n+    */\n+   ExponentialBackOff NO_OP = new ExponentialBackOff() {\n+      @Override\n+      public void backoffSleep() {\n+         //no-op\n+      }\n+\n+      @Override\n+      public void reset() {\n+         //no-op\n+      }\n+   };\n+\n+   /**\n+    * It blocks the thread for a certain amount of time before retries the request.\n+    * <p>\n+    * The method is blocking and should be invoked when a request needs to be retried. It blocks the thread for a", "originalCommit": "d8689815a1dcb68bed021e6239dff1700926a6d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2MDUyNQ==", "url": "https://github.com/infinispan/infinispan/pull/8672#discussion_r487160525", "bodyText": "this is on the sending. IRAC has a dedicated thread looping through the changed keys. Sleep if fine here since the thread isn't used for anything else.", "author": "pruivo", "createdAt": "2020-09-11T16:36:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEyODk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUzMDc0MQ==", "url": "https://github.com/infinispan/infinispan/pull/8672#discussion_r494530741", "bodyText": "Okay, tbh I was even going to discuss possibly removing the IRAC thread at some point and just submit as needed and/or use the scheduled executor so we don't need an additional thread. However it isn't worth it to do in this PR it seems.", "author": "wburns", "createdAt": "2020-09-24T18:33:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEyODk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg0MjUyNQ==", "url": "https://github.com/infinispan/infinispan/pull/8672#discussion_r494842525", "bodyText": "My idea is to use the BlockingManager directly. Use one BlockingThread to send the requests (since they may involve persistence) could save some thread spawning. Also, I need to avoid spawning a thread if a batch is in progress. Something like this:\n\nSpawn single BlockThread and block more thread spawning\nSend all the requests and return the thread to BlockingManager\nWhen all requests finish, spawn a BlockThread to handle the replies\na. if not more keys to send, allow thread spawning and return the thread to BlockingManager\nb. else, send the next batch (goto 2)", "author": "pruivo", "createdAt": "2020-09-25T08:49:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEyODk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEyOTIwOA==", "url": "https://github.com/infinispan/infinispan/pull/8672#discussion_r487129208", "bodyText": "I wouldn't mention that it is used by IRAC in the comments.", "author": "wburns", "createdAt": "2020-09-11T15:40:25Z", "path": "core/src/main/java/org/infinispan/util/ExponentialBackOff.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package org.infinispan.util;\n+\n+import org.infinispan.commons.util.Experimental;\n+\n+/**\n+ * Interface to implement an exponential back-off algorithm that retries the request based on the result of the remote\n+ * operation.\n+ * <p>\n+ * Currently only used for IRAC, this interface contains 2 methods: {@link #backoffSleep()} which should be invoked if", "originalCommit": "d8689815a1dcb68bed021e6239dff1700926a6d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzMDU3MQ==", "url": "https://github.com/infinispan/infinispan/pull/8672#discussion_r487130571", "bodyText": "Should be able to be package private?", "author": "wburns", "createdAt": "2020-09-11T15:42:43Z", "path": "core/src/main/java/org/infinispan/util/ExponentialBackOffImpl.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package org.infinispan.util;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+\n+/**\n+ * The default {@link ExponentialBackOff} implementation for IRAC (asynchronous cross-site replication).\n+ * <p>\n+ * An exponential back-off implementation with min interval of 500 ms and a maximum of 300'000 ms (5 min). It uses a\n+ * multiplier of 2 (each timeslot will be increase + 100% for each consecutive retry) and the final wait time is\n+ * randomized, +- 50% of the timeslot.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12.0\n+ */\n+public class ExponentialBackOffImpl implements ExponentialBackOff {\n+\n+   private static final Log log = LogFactory.getLog(ExponentialBackOffImpl.class);\n+   private static final boolean trace = log.isTraceEnabled();\n+\n+   //TODO currently only used by IRAC. If required, make it configurable (those 4 constants) to cover other uses cases.\n+   //multiplier value (2 == +100% per retry)\n+   private static final double MULTIPLIER = 2;\n+   //initial interval value in milliseconds\n+   private static final int INITIAL_INTERVAL_MILLIS = 500;\n+   //maximum back off time in milliseconds (300 seconds == 5 min)\n+   private static final int MAX_INTERVAL_MILLIS = 300_000;\n+   //randomization factor (0.5 == 50% below and 50% above the retry interval).\n+   private static final double RANDOMIZATION_FACTOR = 0.5;\n+\n+   //the current retry timeout. If a retry occurs, it will wait for this time +- RANDOMIZATION_FACTOR (%)\n+   private int currentIntervalMillis;\n+\n+   public ExponentialBackOffImpl() {\n+      this.currentIntervalMillis = INITIAL_INTERVAL_MILLIS;\n+   }\n+\n+   public long nextBackOffMillis() {", "originalCommit": "d8689815a1dcb68bed021e6239dff1700926a6d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "84bd7939c7147689216ebab8ad1c3d2f48d08dfe", "url": "https://github.com/infinispan/infinispan/commit/84bd7939c7147689216ebab8ad1c3d2f48d08dfe", "message": "ISPN-12250 Add exponential back-off for cross-site network failures", "committedDate": "2020-09-11T17:32:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUzNDU5Nw==", "url": "https://github.com/infinispan/infinispan/pull/8672#discussion_r494534597", "bodyText": "Maybe include the sleep duration in the trace message.", "author": "wburns", "createdAt": "2020-09-24T18:40:39Z", "path": "core/src/main/java/org/infinispan/util/ExponentialBackOffImpl.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package org.infinispan.util;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+\n+/**\n+ * The default {@link ExponentialBackOff} implementation for IRAC (asynchronous cross-site replication).\n+ * <p>\n+ * An exponential back-off implementation with min interval of 500 ms and a maximum of 300'000 ms (5 min). It uses a\n+ * multiplier of 2 (each timeslot will be increase + 100% for each consecutive retry) and the final wait time is\n+ * randomized, +- 50% of the timeslot.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12.0\n+ */\n+public class ExponentialBackOffImpl implements ExponentialBackOff {\n+\n+   private static final Log log = LogFactory.getLog(ExponentialBackOffImpl.class);\n+   private static final boolean trace = log.isTraceEnabled();\n+\n+   //TODO currently only used by IRAC. If required, make it configurable (those 4 constants) to cover other uses cases.\n+   //multiplier value (2 == +100% per retry)\n+   private static final double MULTIPLIER = 2;\n+   //initial interval value in milliseconds\n+   private static final int INITIAL_INTERVAL_MILLIS = 500;\n+   //maximum back off time in milliseconds (300 seconds == 5 min)\n+   private static final int MAX_INTERVAL_MILLIS = 300_000;\n+   //randomization factor (0.5 == 50% below and 50% above the retry interval).\n+   private static final double RANDOMIZATION_FACTOR = 0.5;\n+\n+   //the current retry timeout. If a retry occurs, it will wait for this time +- RANDOMIZATION_FACTOR (%)\n+   private int currentIntervalMillis;\n+\n+   public ExponentialBackOffImpl() {\n+      this.currentIntervalMillis = INITIAL_INTERVAL_MILLIS;\n+   }\n+\n+   long nextBackOffMillis() {\n+      //public for unit test purposes.\n+      if (currentIntervalMillis >= MAX_INTERVAL_MILLIS) {\n+         if (trace) {\n+            log.tracef(\"Next backoff time %s ms\", MAX_INTERVAL_MILLIS);\n+         }\n+         return MAX_INTERVAL_MILLIS;\n+      }\n+      int randomIntervalMillis = getRandomValueFromInterval();\n+      incrementCurrentInterval();\n+      if (trace) {\n+         log.tracef(\"Next backoff time %s ms\", randomIntervalMillis);\n+      }\n+      return Math.min(randomIntervalMillis, MAX_INTERVAL_MILLIS);\n+   }\n+\n+   @Override\n+   public void backoffSleep() throws InterruptedException {\n+      if (trace) {\n+         log.trace(\"backing-off...\");", "originalCommit": "84bd7939c7147689216ebab8ad1c3d2f48d08dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg0MjY1Nw==", "url": "https://github.com/infinispan/infinispan/pull/8672#discussion_r494842657", "bodyText": "done!", "author": "pruivo", "createdAt": "2020-09-25T08:49:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUzNDU5Nw=="}], "type": "inlineReview"}, {"oid": "3a8bc823e9b73221357cbd5e3fb51225c7ce3c8e", "url": "https://github.com/infinispan/infinispan/commit/3a8bc823e9b73221357cbd5e3fb51225c7ce3c8e", "message": "ISPN-12250 Add exponential back-off for cross-site network failures", "committedDate": "2020-09-25T08:50:16Z", "type": "commit"}, {"oid": "3a8bc823e9b73221357cbd5e3fb51225c7ce3c8e", "url": "https://github.com/infinispan/infinispan/commit/3a8bc823e9b73221357cbd5e3fb51225c7ce3c8e", "message": "ISPN-12250 Add exponential back-off for cross-site network failures", "committedDate": "2020-09-25T08:50:16Z", "type": "forcePushed"}]}