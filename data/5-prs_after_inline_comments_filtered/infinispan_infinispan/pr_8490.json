{"pr_number": 8490, "pr_title": "ISPN-11151 - Migrating some remote tests from jdg-functional-tests to upstream", "pr_createdAt": "2020-06-18T00:01:20Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8490", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyMTk0Mg==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r442121942", "bodyText": "Ideally we shouldn't be adding SQL to the src/main files just for use in test cases. This SQL is part of the standard, so it should run on all DBs, i.e. no need to override this SQL on a per DB level, so I think you should just use this directly in your test TableManipulation class.", "author": "ryanemerson", "createdAt": "2020-06-18T10:17:21Z", "path": "persistence/jdbc/src/main/java/org/infinispan/persistence/jdbc/impl/table/AbstractTableManager.java", "diffHunk": "@@ -294,18 +298,36 @@ protected String initSelectIdRowSql() {\n       return String.format(\"SELECT %s FROM %s WHERE %s = ?\", config.idColumnName(), tableName, config.idColumnName());\n    }\n \n+   protected String initSelectIdRowSqlWithLike() {\n+      return String.format(\"SELECT %s FROM %s WHERE %s LIKE ?\", config.idColumnName(), tableName, config.idColumnName());\n+   }\n+\n    @Override\n    public String getSelectIdRowSql() {\n       return selectIdRowSql;\n    }\n \n+   @Override\n+   public String getSelectIdRowSqlWithLike() {\n+      return selectIdRowSqlWithLike;\n+   }\n+\n    protected String initCountNonExpiredRowsSql() {\n       return \"SELECT COUNT(*) FROM \" + tableName +\n             \" WHERE \" + config.timestampColumnName() + \" < 0 OR \" + config.timestampColumnName() + \" > ?\";\n    }\n \n+   protected String initCountRowsSql() {\n+      return \"SELECT COUNT(*) FROM \" + tableName;\n+   }\n+\n    @Override\n    public String getCountNonExpiredRowsSql() {\n+      return countNonExpiredRowsSql;\n+   }\n+\n+   @Override\n+   public String getCountRowsSql() {", "originalCommit": "dfa7fd4d14e73ddbc9eeff5ec4e80ccb976ef5ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyMjM4OA==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r442522388", "bodyText": "@ryanemerson updated", "author": "gustavolira", "createdAt": "2020-06-18T21:51:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyMTk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyMjM4OA==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r442122388", "bodyText": "Should also just be in the test TableManipulation class.", "author": "ryanemerson", "createdAt": "2020-06-18T10:18:03Z", "path": "persistence/jdbc/src/main/java/org/infinispan/persistence/jdbc/impl/table/AbstractTableManager.java", "diffHunk": "@@ -294,18 +298,36 @@ protected String initSelectIdRowSql() {\n       return String.format(\"SELECT %s FROM %s WHERE %s = ?\", config.idColumnName(), tableName, config.idColumnName());\n    }\n \n+   protected String initSelectIdRowSqlWithLike() {\n+      return String.format(\"SELECT %s FROM %s WHERE %s LIKE ?\", config.idColumnName(), tableName, config.idColumnName());\n+   }\n+\n    @Override\n    public String getSelectIdRowSql() {\n       return selectIdRowSql;\n    }\n \n+   @Override\n+   public String getSelectIdRowSqlWithLike() {", "originalCommit": "dfa7fd4d14e73ddbc9eeff5ec4e80ccb976ef5ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyNDM2Mg==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r442124362", "bodyText": "You need to make sure the resources returned by TableManipulation are always closed after a test has finished ... this is probably the cause of the ThreadLeakChecker failures.", "author": "ryanemerson", "createdAt": "2020-06-18T10:21:44Z", "path": "server/tests/src/test/java/org/infinispan/server/persistence/TableManipulation.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.infinispan.server.persistence;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+\n+import org.infinispan.commons.marshall.ProtoStreamMarshaller;\n+import org.infinispan.commons.marshall.WrappedByteArray;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.configuration.JdbcStringBasedStoreConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.configuration.PooledConnectionFactoryConfiguration;\n+import org.infinispan.persistence.jdbc.configuration.PooledConnectionFactoryConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.connectionfactory.ConnectionFactory;\n+import org.infinispan.persistence.jdbc.impl.connectionfactory.PooledConnectionFactory;\n+import org.infinispan.persistence.jdbc.impl.table.TableManager;\n+import org.infinispan.persistence.jdbc.impl.table.TableManagerFactory;\n+import org.infinispan.persistence.keymappers.DefaultTwoWayKey2StringMapper;\n+\n+public class TableManipulation {\n+\n+   private String cacheName;\n+   private ConnectionFactory connectionFactory;\n+   private Connection connection;\n+   private PooledConnectionFactoryConfigurationBuilder persistenceConfiguration;\n+   private ConfigurationBuilder configurationBuilder;\n+\n+   public TableManipulation(String cacheName, PooledConnectionFactoryConfigurationBuilder persistenceConfiguration, ConfigurationBuilder configurationBuilder) {\n+      this.cacheName = cacheName;\n+      this.persistenceConfiguration = persistenceConfiguration;\n+      this.configurationBuilder = configurationBuilder;\n+   }\n+\n+   private ConnectionFactory getConnectionFactory() {", "originalCommit": "dfa7fd4d14e73ddbc9eeff5ec4e80ccb976ef5ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyMzM5Ng==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r442523396", "bodyText": "@ryanemerson I fixed some ThreadLeakChecker but there's one ThreadLeak that is still happening, I don't know why it's happening.", "author": "gustavolira", "createdAt": "2020-06-18T21:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyNDM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwMjMxNg==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r442702316", "bodyText": "@wburns Can you remember what was leaking the agroal connection on your PR before?", "author": "ryanemerson", "createdAt": "2020-06-19T08:19:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyNDM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg4Mjc4OA==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r442882788", "bodyText": "Mine was a bug in the start method of the PersistenceManagerImpl, I highly doubt it is related and it shouldn't be able to resurface now.\nhttps://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java#L198", "author": "wburns", "createdAt": "2020-06-19T14:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyNDM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1MDYxNg==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443150616", "bodyText": "@ryanemerson I removed the dependency from TableManager and fixed all thread leaker", "author": "gustavolira", "createdAt": "2020-06-20T18:31:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyNDM2Mg=="}], "type": "inlineReview"}, {"oid": "409291e150cceddca7ab64dd5b8de2ccd3b56a70", "url": "https://github.com/infinispan/infinispan/commit/409291e150cceddca7ab64dd5b8de2ccd3b56a70", "message": "ISPN-11151 - Migrating some remote jdbc-cachestore tests from jdg-functional-tests to upstream", "committedDate": "2020-06-18T21:50:19Z", "type": "forcePushed"}, {"oid": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0", "url": "https://github.com/infinispan/infinispan/commit/9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0", "message": "ISPN-11151 - Migrating some remote jdbc-cachestore tests from jdg-functional-tests to upstream", "committedDate": "2020-06-20T18:20:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2MDYwNA==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443460604", "bodyText": "This method is never used", "author": "ryanemerson", "createdAt": "2020-06-22T10:21:45Z", "path": "persistence/jdbc/src/main/java/org/infinispan/persistence/jdbc/impl/table/AbstractTableManager.java", "diffHunk": "@@ -294,6 +294,10 @@ protected String initSelectIdRowSql() {\n       return String.format(\"SELECT %s FROM %s WHERE %s = ?\", config.idColumnName(), tableName, config.idColumnName());\n    }\n \n+   protected String initSelectIdRowSqlWithLike() {", "originalCommit": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2MDkzNA==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443460934", "bodyText": "As this will be the only change to the production files, I think we should revert it.", "author": "ryanemerson", "createdAt": "2020-06-22T10:22:25Z", "path": "persistence/jdbc/src/main/java/org/infinispan/persistence/jdbc/impl/table/AbstractTableManager.java", "diffHunk": "@@ -72,7 +72,7 @@\n       this.selectIdRowSql = initSelectIdRowSql();\n       this.deleteRowSql = initDeleteRowSql();\n       this.loadAllRowsSql = initLoadAllRowsSql();\n-      this.countRowsSql = initCountNonExpiredRowsSql();\n+      this.countNonExpiredRowsSql = initCountNonExpiredRowsSql();", "originalCommit": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2NDI3OA==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443464278", "bodyText": "This method is always called after directly after the instance is created, e.g. new JdbcConfigurationUtil().createPersistenceConfiguration() ... why not just add these params to the constructor so that we can just do:\nnew JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, false).setEviction() etc.", "author": "ryanemerson", "createdAt": "2020-06-22T10:28:54Z", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcConfigurationUtil.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package org.infinispan.server.persistence;\n+\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.configuration.JdbcStringBasedStoreConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.configuration.PooledConnectionFactoryConfigurationBuilder;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.util.concurrent.IsolationLevel;\n+\n+public class JdbcConfigurationUtil {\n+\n+    private PooledConnectionFactoryConfigurationBuilder persistenceConfiguration;\n+    private ConfigurationBuilder configurationBuilder;\n+    private CacheMode cacheMode;\n+\n+    public JdbcConfigurationUtil(CacheMode cacheMode) {\n+        configurationBuilder = new ConfigurationBuilder();\n+        this.cacheMode = cacheMode;\n+    }\n+\n+    public JdbcConfigurationUtil createPersistenceConfiguration(Database database, boolean passivation, boolean preload) {", "originalCommit": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2NTc2Mg==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443465762", "bodyText": "Why is this change required?", "author": "ryanemerson", "createdAt": "2020-06-22T10:31:42Z", "path": "server/testdriver/junit4/src/main/java/org/infinispan/server/test/junit4/InfinispanServerRule.java", "diffHunk": "@@ -78,8 +78,8 @@ public void evaluate() throws Throwable {\n             } finally {\n                InfinispanServerRule.this.after(testName);\n                if (manageServer && testServer.isDriverInitialized()) {\n-                  testServer.afterListeners();\n                   testServer.getDriver().stop(testName);\n+                  testServer.afterListeners();", "originalCommit": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2MjAzOA==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443662038", "bodyText": "@ryanemerson Without this change we will receive SocketTimeoutException: connect timed out a lot", "author": "gustavolira", "createdAt": "2020-06-22T15:55:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2NTc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2NjIwMA==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443466200", "bodyText": "These changes seem fine, but do they belong in this commit? They aren't related to JDBC.", "author": "ryanemerson", "createdAt": "2020-06-22T10:32:36Z", "path": "server/tests/src/test/java/org/infinispan/server/functional/MemcachedOperations.java", "diffHunk": "@@ -28,4 +33,37 @@ public void testMemcachedOperations() {\n       cache.set(\"k1\", 0, \"v1\");\n       assertEquals(\"v1\", cache.get(\"k1\"));\n    }\n+\n+   @Test", "originalCommit": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2Njc4Nw==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443466787", "bodyText": "Again this seems fine, but it isn't related to the current commit and Jira ticket. If you want to add this test, create a new Jira and add as a separate commit please.", "author": "ryanemerson", "createdAt": "2020-06-22T10:33:50Z", "path": "server/tests/src/test/java/org/infinispan/server/functional/RestOperations.java", "diffHunk": "@@ -73,6 +74,19 @@ public void testRestOperations() {\n       assertEquals(protocol, response.getProtocol());\n    }\n \n+   @Test\n+   public void testPutWithTimeToLive() throws InterruptedException {\n+      RestClientConfigurationBuilder builder = new RestClientConfigurationBuilder();\n+      builder.protocol(protocol);\n+      RestClient client = SERVER_TEST.rest().withClientConfiguration(builder).create();\n+      RestCacheClient cache = client.cache(SERVER_TEST.getMethodName());\n+      sync(cache.post(\"k1\", \"v1\", 1, 1));\n+      assertEquals(HttpResponseStatus.OK.code(), sync(cache.get(\"k1\")).getStatus());\n+      Thread.sleep(2000);\n+      assertEquals(HttpResponseStatus.NOT_FOUND.code(), sync(cache.get(\"k1\")).getStatus());", "originalCommit": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2NzY3Ng==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443467676", "bodyText": "< ... same for the other for loops.", "author": "ryanemerson", "createdAt": "2020-06-22T10:35:32Z", "path": "server/tests/src/test/java/org/infinispan/server/persistence/AsyncJdbcStringBasedCacheStore.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class AsyncJdbcStringBasedCacheStore {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    public AsyncJdbcStringBasedCacheStore(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPutRemove() throws Exception {\n+        int numEntries = 10;\n+        String keyPrefix = \"testPutRemove-k-\";\n+        String valuePrefix = \"testPutRemove-k-\";\n+\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC)\n+                .createPersistenceConfiguration(database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder());\n+\n+        // test PUT operation\n+        for (int i = 0; i != numEntries; i++) {", "originalCommit": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ3MjczMw==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443472733", "bodyText": "This isn't testing that preload works, as it is just checking the cache size which will include the loaders. Instead you should assert that the entry is in-memory by doing cache.withFlags(Flag.SKIP_CACHE_LOAD).size()", "author": "ryanemerson", "createdAt": "2020-06-22T10:46:17Z", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivationDisabled.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == false --all cache entries should always be also in the cache store\n+ * preload == true --after server restart, all entries should appear in the cache immediately\n+ * purge == false --all entries should remain in the cache store after server  * restart\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivationDisabled {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivationDisabled(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testFailoverWithPassivationDisabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC)\n+                .createPersistenceConfiguration(database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder());\n+\n+        cache.put(\"k1\", \"v1\");\n+        cache.put(\"k2\", \"v2\");\n+        // test passivation==false, database should contain all entries which are in the cache\n+        assertNotNull(table.getValueByKey(\"k1\"));\n+        assertNotNull(table.getValueByKey(\"k2\"));\n+\n+        SERVERS.getServerDriver().stop(0);\n+        SERVERS.getServerDriver().restart(0);\n+\n+        assertNotNull(table.getValueByKey(\"k1\"));\n+        assertNotNull(table.getValueByKey(\"k2\"));\n+        assertEquals(\"v1\", cache.get(\"k1\"));\n+        assertEquals(\"v2\", cache.get(\"k2\"));\n+        //when the entry is removed from the cache, it should be also removed from the cache store (the store\n+        //and the cache are the same sets of keys)\n+        cache.remove(\"k1\");\n+        assertNull(table.getValueByKey(\"k1\"));\n+        cache.clear();\n+        table.releaseConnection();\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPreloadWithoutPurge() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC)\n+                .createPersistenceConfiguration(database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder());\n+\n+        cache.clear();\n+        cache.put(\"k1\", \"v1\");\n+        cache.put(\"k2\", \"v2\");\n+\n+        assertNotNull(table.getValueByKey(\"k1\"));\n+        assertNotNull(table.getValueByKey(\"k2\"));\n+\n+        SERVERS.getServerDriver().stop(0);\n+        SERVERS.getServerDriver().restart(0);\n+\n+        // test preload==true, entries should be immediately in the cache after restart\n+        assertEquals(2, cache.size());", "originalCommit": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ3MzM3NA==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443473374", "bodyText": "It's probably worth ensuring that the key is not in-memory first, so assertNull(cache.withFlags(Flag.SKIP_CACHE_LOAD).get(\"k1\") followed by assertEquals(\"v1\", cache.get(\"k1\"));", "author": "ryanemerson", "createdAt": "2020-06-22T10:47:41Z", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivationDisabled.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == false --all cache entries should always be also in the cache store\n+ * preload == true --after server restart, all entries should appear in the cache immediately\n+ * purge == false --all entries should remain in the cache store after server  * restart\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivationDisabled {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivationDisabled(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testFailoverWithPassivationDisabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC)\n+                .createPersistenceConfiguration(database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder());\n+\n+        cache.put(\"k1\", \"v1\");\n+        cache.put(\"k2\", \"v2\");\n+        // test passivation==false, database should contain all entries which are in the cache\n+        assertNotNull(table.getValueByKey(\"k1\"));\n+        assertNotNull(table.getValueByKey(\"k2\"));\n+\n+        SERVERS.getServerDriver().stop(0);\n+        SERVERS.getServerDriver().restart(0);\n+\n+        assertNotNull(table.getValueByKey(\"k1\"));\n+        assertNotNull(table.getValueByKey(\"k2\"));\n+        assertEquals(\"v1\", cache.get(\"k1\"));", "originalCommit": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ3NDgzMQ==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443474831", "bodyText": "If we adapt this to implements AutoCloseable, we can move the releaseConnection logic to the stop() implementation and then just do the following when using the code:\ntry (TableManipulation tm = new TableManipulation(..)) {\n // Test logic\n}", "author": "ryanemerson", "createdAt": "2020-06-22T10:50:43Z", "path": "server/tests/src/test/java/org/infinispan/server/persistence/TableManipulation.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package org.infinispan.server.persistence;\n+\n+import java.sql.Connection;\n+import java.sql.Driver;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.Enumeration;\n+\n+import org.infinispan.commons.marshall.ProtoStreamMarshaller;\n+import org.infinispan.commons.marshall.WrappedByteArray;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.JdbcUtil;\n+import org.infinispan.persistence.jdbc.configuration.PooledConnectionFactoryConfiguration;\n+import org.infinispan.persistence.jdbc.configuration.PooledConnectionFactoryConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.connectionfactory.ConnectionFactory;\n+import org.infinispan.persistence.jdbc.impl.connectionfactory.PooledConnectionFactory;\n+import org.infinispan.persistence.keymappers.DefaultTwoWayKey2StringMapper;\n+\n+import com.mysql.cj.jdbc.AbandonedConnectionCleanupThread;\n+\n+public class TableManipulation {", "originalCommit": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ3NjE0OQ==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443476149", "bodyText": "There's no need todo this via REST. We can just utilise Flag.SKIP_CACHE_LOAD.", "author": "ryanemerson", "createdAt": "2020-06-22T10:53:11Z", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivationEnabled.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == true --cache entries should get to the cache store only when evicted\n+ * preload == false --after server restart, entries should NOT be preloaded to the cache\n+ * purge == false --all entries should remain in the cache store after server restart\n+ * (must be false so that we can test preload)\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivationEnabled {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivationEnabled(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPassivateAfterEviction() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC)\n+                .createPersistenceConfiguration(database, true, false)\n+                .setEvition()\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder());\n+\n+        cache.put(\"k1\", \"v1\");\n+        cache.put(\"k2\", \"v2\");\n+        //not yet in store (eviction size=2)\n+        assertTrue(table.getValueByKey(\"k1\") == null);\n+        assertTrue(table.getValueByKey(\"k2\") == null);\n+        cache.put(\"k3\", \"v3\");\n+        assertEquals(\"v3\", cache.get(\"k3\"));\n+        ///now some key is evicted and stored in store\n+        assertTrue(2 == getNumberOfEntriesInMemory(cache.getName()));\n+        assertEquals(1, table.countAllRows());\n+        assertNotNull(table.getValueByKey(\"k1\"));\n+        table.releaseConnection();\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testSoftRestartWithoutPreload() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC)\n+                .createPersistenceConfiguration(database, true, false)\n+                .setEvition()\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder());\n+\n+        cache.put(\"k1\", \"v1\");\n+        cache.put(\"k2\", \"v2\");\n+        //not yet in store (eviction.max-entries=2, LRU)\n+        assertTrue(table.getValueByKey(\"k1\") == null);\n+        assertTrue(table.getValueByKey(\"k2\") == null);\n+        cache.put(\"k3\", \"v3\");\n+        //now some key is evicted and stored in store\n+        assertTrue(2 == getNumberOfEntriesInMemory(cache.getName()));\n+        assertEquals(1, table.countAllRows());\n+        SERVERS.getServerDriver().stop(0);\n+        SERVERS.getServerDriver().restart(0); //soft stop should store all entries from cache to store\n+\n+        // test preload==false\n+        assertEquals(0, getNumberOfEntriesInMemory(cache.getName()));\n+        // test purge==false, entries should remain in the database after restart\n+        assertEquals(3, table.countAllRows());\n+        assertEquals(\"v1\", cache.get(\"k1\"));\n+        table.releaseConnection();\n+    }\n+\n+    /**\n+     * This test differs from the preceding expecting 1 entry in the DB\n+     * after fail-over instead of 3 when doing soft\n+     * restart.\n+     */\n+    @Test(timeout = 600000)\n+    public void testFailoverWithoutPreload() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC)\n+                .createPersistenceConfiguration(database, true, false)\n+                .setEvition()\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder());\n+\n+        cache.put(\"k1\", \"v1\");\n+        cache.put(\"k2\", \"v2\");\n+        assertTrue(table.getValueByKey(\"k1\") == null);\n+        assertTrue(table.getValueByKey(\"k2\") == null);\n+        cache.put(\"k3\", \"v3\");\n+        assertTrue(2 == getNumberOfEntriesInMemory(cache.getName()));\n+        assertEquals(1, table.countAllRows());\n+        SERVERS.getServerDriver().kill(0);\n+        SERVERS.getServerDriver().restart(0);\n+        assertEquals(0, getNumberOfEntriesInMemory(cache.getName()));\n+        assertEquals(1, table.countAllRows());\n+        assertEquals(\"v1\", cache.get(\"k1\"));\n+        table.releaseConnection();\n+    }\n+\n+    private int getNumberOfEntriesInMemory(String cacheName) throws JsonProcessingException {", "originalCommit": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ3ODk1MA==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443478950", "bodyText": "I think we should consolidate the two JdbcStringBasedCacheStorePassivation* tests into a single JdbcStringBasedCacheStore test. We can then just use the method names to distinguish the preload enabled/disabled tests.", "author": "ryanemerson", "createdAt": "2020-06-22T10:58:58Z", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivationEnabled.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == true --cache entries should get to the cache store only when evicted\n+ * preload == false --after server restart, entries should NOT be preloaded to the cache\n+ * purge == false --all entries should remain in the cache store after server restart\n+ * (must be false so that we can test preload)\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivationEnabled {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivationEnabled(String databaseType) {", "originalCommit": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2adf6b70779c02b06b42cf3a7feefe5f61f4f71d", "url": "https://github.com/infinispan/infinispan/commit/2adf6b70779c02b06b42cf3a7feefe5f61f4f71d", "message": "ISPN-11151 - Migrating some remote jdbc-cachestore tests from jdg-functional-tests to upstream", "committedDate": "2020-06-22T16:49:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMDQ2Mg==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443710462", "bodyText": "<", "author": "ryanemerson", "createdAt": "2020-06-22T17:16:46Z", "path": "server/tests/src/test/java/org/infinispan/server/persistence/AsyncJdbcStringBasedCacheStore.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class AsyncJdbcStringBasedCacheStore {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    public AsyncJdbcStringBasedCacheStore(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPutRemove() throws Exception {\n+        int numEntries = 10;\n+        String keyPrefix = \"testPutRemove-k-\";\n+        String valuePrefix = \"testPutRemove-k-\";\n+\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            // test PUT operation\n+            for (int i = 0; i < numEntries; i++) {\n+                cache.putAsync(keyPrefix+i, valuePrefix+i).toCompletableFuture().get();\n+            }\n+\n+            assertCountRow(table.countAllRows(), numEntries);\n+            for (int i = 0; i != numEntries; i++) {", "originalCommit": "2adf6b70779c02b06b42cf3a7feefe5f61f4f71d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMTIzNg==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443711236", "bodyText": "This is failing checkstyle.", "author": "ryanemerson", "createdAt": "2020-06-22T17:18:08Z", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.Flag;\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == false --all cache entries should always be also in the cache store\n+ * preload == true --after server restart, all entries should appear in the cache immediately\n+ * purge == false --all entries should remain in the cache store after server  * restart\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivation {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivation(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testFailoverWithPassivationDisabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+            // test passivation==false, database should contain all entries which are in the cache\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+            assertNull(cache.withFlags(Flag.SKIP_CACHE_LOAD).get(\"k3\"));\n+            assertEquals(\"v1\", cache.get(\"k1\"));\n+            assertEquals(\"v2\", cache.get(\"k2\"));\n+            //when the entry is removed from the cache, it should be also removed from the cache store (the store\n+            //and the cache are the same sets of keys)\n+            cache.remove(\"k1\");\n+            assertNull(table.getValueByKey(\"k1\"));\n+            cache.clear();\n+        }\n+\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPreloadWithoutPurgePassivationFalse() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.clear();\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            // test preload==true, entries should be immediately in the cache after restart\n+            assertEquals(2, cache.size());\n+            // test purge==false, entries should remain in the database after restart\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+        }\n+;", "originalCommit": "2adf6b70779c02b06b42cf3a7feefe5f61f4f71d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMjE0NQ==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443712145", "bodyText": "Lots of empty lines where you've added the try() {} blocks, can you remove please.", "author": "ryanemerson", "createdAt": "2020-06-22T17:19:56Z", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.Flag;\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == false --all cache entries should always be also in the cache store\n+ * preload == true --after server restart, all entries should appear in the cache immediately\n+ * purge == false --all entries should remain in the cache store after server  * restart\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivation {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivation(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testFailoverWithPassivationDisabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+            // test passivation==false, database should contain all entries which are in the cache\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+            assertNull(cache.withFlags(Flag.SKIP_CACHE_LOAD).get(\"k3\"));\n+            assertEquals(\"v1\", cache.get(\"k1\"));\n+            assertEquals(\"v2\", cache.get(\"k2\"));\n+            //when the entry is removed from the cache, it should be also removed from the cache store (the store\n+            //and the cache are the same sets of keys)\n+            cache.remove(\"k1\");\n+            assertNull(table.getValueByKey(\"k1\"));\n+            cache.clear();\n+        }\n+", "originalCommit": "2adf6b70779c02b06b42cf3a7feefe5f61f4f71d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMzM3MA==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443713370", "bodyText": "This test is identical to the contents of testSoftRestartWithoutPreloadPassivationEnabled AFAICT, except it does not have the restart. testSoftRestartWithoutPreloadPassivationEnabled should be sufficient`", "author": "ryanemerson", "createdAt": "2020-06-22T17:22:03Z", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.Flag;\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == false --all cache entries should always be also in the cache store\n+ * preload == true --after server restart, all entries should appear in the cache immediately\n+ * purge == false --all entries should remain in the cache store after server  * restart\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivation {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivation(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testFailoverWithPassivationDisabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+            // test passivation==false, database should contain all entries which are in the cache\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+            assertNull(cache.withFlags(Flag.SKIP_CACHE_LOAD).get(\"k3\"));\n+            assertEquals(\"v1\", cache.get(\"k1\"));\n+            assertEquals(\"v2\", cache.get(\"k2\"));\n+            //when the entry is removed from the cache, it should be also removed from the cache store (the store\n+            //and the cache are the same sets of keys)\n+            cache.remove(\"k1\");\n+            assertNull(table.getValueByKey(\"k1\"));\n+            cache.clear();\n+        }\n+\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPreloadWithoutPurgePassivationFalse() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.clear();\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            // test preload==true, entries should be immediately in the cache after restart\n+            assertEquals(2, cache.size());\n+            // test purge==false, entries should remain in the database after restart\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+        }\n+;\n+    }\n+\n+    /*\n+     * This should verify that DefaultTwoWayKey2StringMapper on server side can work with ByteArrayKey which\n+     * is always produced by HotRod client regardless of type of key being stored in a cache.\n+     */\n+    @Test(timeout = 600000)\n+    public void testStoreDataWithHotRodClientPassivationFalse() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<Object, Object> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            Double doubleKey = 10.0;\n+            Double doubleValue = 20.0;\n+\n+            assertEquals(0, cache.size());\n+            assertTrue(table.countAllRows() == 0);\n+            cache.put(doubleKey, doubleValue);\n+            // test passivation==false, database should contain all entries which are in the cache\n+            assertEquals(1, table.countAllRows());\n+            assertEquals(doubleValue, cache.get(doubleKey));\n+        }\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPassivateAfterEvictionPassivationEnabled() throws Exception {", "originalCommit": "2adf6b70779c02b06b42cf3a7feefe5f61f4f71d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxNzUzOA==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443717538", "bodyText": "testDefaultTwoWayKey2StringMapper? That way the test name reflects what we're trying to test.", "author": "ryanemerson", "createdAt": "2020-06-22T17:29:48Z", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.Flag;\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == false --all cache entries should always be also in the cache store\n+ * preload == true --after server restart, all entries should appear in the cache immediately\n+ * purge == false --all entries should remain in the cache store after server  * restart\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivation {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivation(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testFailoverWithPassivationDisabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+            // test passivation==false, database should contain all entries which are in the cache\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+            assertNull(cache.withFlags(Flag.SKIP_CACHE_LOAD).get(\"k3\"));\n+            assertEquals(\"v1\", cache.get(\"k1\"));\n+            assertEquals(\"v2\", cache.get(\"k2\"));\n+            //when the entry is removed from the cache, it should be also removed from the cache store (the store\n+            //and the cache are the same sets of keys)\n+            cache.remove(\"k1\");\n+            assertNull(table.getValueByKey(\"k1\"));\n+            cache.clear();\n+        }\n+\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPreloadWithoutPurgePassivationFalse() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.clear();\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            // test preload==true, entries should be immediately in the cache after restart\n+            assertEquals(2, cache.size());\n+            // test purge==false, entries should remain in the database after restart\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+        }\n+;\n+    }\n+\n+    /*\n+     * This should verify that DefaultTwoWayKey2StringMapper on server side can work with ByteArrayKey which\n+     * is always produced by HotRod client regardless of type of key being stored in a cache.\n+     */\n+    @Test(timeout = 600000)\n+    public void testStoreDataWithHotRodClientPassivationFalse() throws Exception {", "originalCommit": "2adf6b70779c02b06b42cf3a7feefe5f61f4f71d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxNzg5Mg==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443717892", "bodyText": "The default behaviour is for purge = false; passivation = false, so I think testPreload() is sufficient.", "author": "ryanemerson", "createdAt": "2020-06-22T17:30:27Z", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.Flag;\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == false --all cache entries should always be also in the cache store\n+ * preload == true --after server restart, all entries should appear in the cache immediately\n+ * purge == false --all entries should remain in the cache store after server  * restart\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivation {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivation(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testFailoverWithPassivationDisabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+            // test passivation==false, database should contain all entries which are in the cache\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+            assertNull(cache.withFlags(Flag.SKIP_CACHE_LOAD).get(\"k3\"));\n+            assertEquals(\"v1\", cache.get(\"k1\"));\n+            assertEquals(\"v2\", cache.get(\"k2\"));\n+            //when the entry is removed from the cache, it should be also removed from the cache store (the store\n+            //and the cache are the same sets of keys)\n+            cache.remove(\"k1\");\n+            assertNull(table.getValueByKey(\"k1\"));\n+            cache.clear();\n+        }\n+\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPreloadWithoutPurgePassivationFalse() throws Exception {", "originalCommit": "2adf6b70779c02b06b42cf3a7feefe5f61f4f71d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxNzk3OQ==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443717979", "bodyText": "testFailover()", "author": "ryanemerson", "createdAt": "2020-06-22T17:30:37Z", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.Flag;\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == false --all cache entries should always be also in the cache store\n+ * preload == true --after server restart, all entries should appear in the cache immediately\n+ * purge == false --all entries should remain in the cache store after server  * restart\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivation {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivation(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testFailoverWithPassivationDisabled() throws Exception {", "originalCommit": "2adf6b70779c02b06b42cf3a7feefe5f61f4f71d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxODg2Mg==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443718862", "bodyText": "Btw we should not have a timeout on any test, testng listener will handle that.", "author": "wburns", "createdAt": "2020-06-22T17:32:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxNzk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxODMzNg==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443718336", "bodyText": "testSoftRestartWithPassivation", "author": "ryanemerson", "createdAt": "2020-06-22T17:31:17Z", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.Flag;\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == false --all cache entries should always be also in the cache store\n+ * preload == true --after server restart, all entries should appear in the cache immediately\n+ * purge == false --all entries should remain in the cache store after server  * restart\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivation {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivation(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testFailoverWithPassivationDisabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+            // test passivation==false, database should contain all entries which are in the cache\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+            assertNull(cache.withFlags(Flag.SKIP_CACHE_LOAD).get(\"k3\"));\n+            assertEquals(\"v1\", cache.get(\"k1\"));\n+            assertEquals(\"v2\", cache.get(\"k2\"));\n+            //when the entry is removed from the cache, it should be also removed from the cache store (the store\n+            //and the cache are the same sets of keys)\n+            cache.remove(\"k1\");\n+            assertNull(table.getValueByKey(\"k1\"));\n+            cache.clear();\n+        }\n+\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPreloadWithoutPurgePassivationFalse() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.clear();\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            // test preload==true, entries should be immediately in the cache after restart\n+            assertEquals(2, cache.size());\n+            // test purge==false, entries should remain in the database after restart\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+        }\n+;\n+    }\n+\n+    /*\n+     * This should verify that DefaultTwoWayKey2StringMapper on server side can work with ByteArrayKey which\n+     * is always produced by HotRod client regardless of type of key being stored in a cache.\n+     */\n+    @Test(timeout = 600000)\n+    public void testStoreDataWithHotRodClientPassivationFalse() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<Object, Object> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            Double doubleKey = 10.0;\n+            Double doubleValue = 20.0;\n+\n+            assertEquals(0, cache.size());\n+            assertTrue(table.countAllRows() == 0);\n+            cache.put(doubleKey, doubleValue);\n+            // test passivation==false, database should contain all entries which are in the cache\n+            assertEquals(1, table.countAllRows());\n+            assertEquals(doubleValue, cache.get(doubleKey));\n+        }\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPassivateAfterEvictionPassivationEnabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, true, false)\n+              .setEvition()\n+              .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+            //not yet in store (eviction size=2)\n+            assertTrue(table.getValueByKey(\"k1\") == null);\n+            assertTrue(table.getValueByKey(\"k2\") == null);\n+            cache.put(\"k3\", \"v3\");\n+            assertEquals(\"v3\", cache.get(\"k3\"));\n+            ///now some key is evicted and stored in store\n+            assertTrue(2 == getNumberOfEntriesInMemory(cache.getName()));\n+            assertEquals(1, table.countAllRows());\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+        }\n+\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testSoftRestartWithoutPreloadPassivationEnabled() throws Exception {", "originalCommit": "2adf6b70779c02b06b42cf3a7feefe5f61f4f71d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxODY1OA==", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443718658", "bodyText": "testFailoverWithPassivation", "author": "ryanemerson", "createdAt": "2020-06-22T17:31:55Z", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.Flag;\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == false --all cache entries should always be also in the cache store\n+ * preload == true --after server restart, all entries should appear in the cache immediately\n+ * purge == false --all entries should remain in the cache store after server  * restart\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivation {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivation(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testFailoverWithPassivationDisabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+            // test passivation==false, database should contain all entries which are in the cache\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+            assertNull(cache.withFlags(Flag.SKIP_CACHE_LOAD).get(\"k3\"));\n+            assertEquals(\"v1\", cache.get(\"k1\"));\n+            assertEquals(\"v2\", cache.get(\"k2\"));\n+            //when the entry is removed from the cache, it should be also removed from the cache store (the store\n+            //and the cache are the same sets of keys)\n+            cache.remove(\"k1\");\n+            assertNull(table.getValueByKey(\"k1\"));\n+            cache.clear();\n+        }\n+\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPreloadWithoutPurgePassivationFalse() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.clear();\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            // test preload==true, entries should be immediately in the cache after restart\n+            assertEquals(2, cache.size());\n+            // test purge==false, entries should remain in the database after restart\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+        }\n+;\n+    }\n+\n+    /*\n+     * This should verify that DefaultTwoWayKey2StringMapper on server side can work with ByteArrayKey which\n+     * is always produced by HotRod client regardless of type of key being stored in a cache.\n+     */\n+    @Test(timeout = 600000)\n+    public void testStoreDataWithHotRodClientPassivationFalse() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<Object, Object> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            Double doubleKey = 10.0;\n+            Double doubleValue = 20.0;\n+\n+            assertEquals(0, cache.size());\n+            assertTrue(table.countAllRows() == 0);\n+            cache.put(doubleKey, doubleValue);\n+            // test passivation==false, database should contain all entries which are in the cache\n+            assertEquals(1, table.countAllRows());\n+            assertEquals(doubleValue, cache.get(doubleKey));\n+        }\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPassivateAfterEvictionPassivationEnabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, true, false)\n+              .setEvition()\n+              .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+            //not yet in store (eviction size=2)\n+            assertTrue(table.getValueByKey(\"k1\") == null);\n+            assertTrue(table.getValueByKey(\"k2\") == null);\n+            cache.put(\"k3\", \"v3\");\n+            assertEquals(\"v3\", cache.get(\"k3\"));\n+            ///now some key is evicted and stored in store\n+            assertTrue(2 == getNumberOfEntriesInMemory(cache.getName()));\n+            assertEquals(1, table.countAllRows());\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+        }\n+\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testSoftRestartWithoutPreloadPassivationEnabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, true, false)\n+              .setEvition()\n+              .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+            //not yet in store (eviction.max-entries=2, LRU)\n+            assertTrue(table.getValueByKey(\"k1\") == null);\n+            assertTrue(table.getValueByKey(\"k2\") == null);\n+            cache.put(\"k3\", \"v3\");\n+            //now some key is evicted and stored in store\n+            assertTrue(2 == getNumberOfEntriesInMemory(cache.getName()));\n+            assertEquals(1, table.countAllRows());\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0); //soft stop should store all entries from cache to store\n+\n+            // test preload==false\n+            assertEquals(0, getNumberOfEntriesInMemory(cache.getName()));\n+            // test purge==false, entries should remain in the database after restart\n+            assertEquals(3, table.countAllRows());\n+            assertEquals(\"v1\", cache.get(\"k1\"));\n+        }\n+\n+    }\n+\n+    /**\n+     * This test differs from the preceding expecting 1 entry in the DB\n+     * after fail-over instead of 3 when doing soft\n+     * restart.\n+     */\n+    @Test(timeout = 600000)\n+    public void testFailoverWithoutPreloadPassivationEnabled() throws Exception {", "originalCommit": "2adf6b70779c02b06b42cf3a7feefe5f61f4f71d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6ba1f50ce8ed68e6f50faebfb14960e6417e7f89", "url": "https://github.com/infinispan/infinispan/commit/6ba1f50ce8ed68e6f50faebfb14960e6417e7f89", "message": "ISPN-11151 - Migrating some remote jdbc-cachestore tests from jdg-functional-tests to upstream", "committedDate": "2020-06-22T17:34:57Z", "type": "forcePushed"}, {"oid": "3dcfb25525f07f8c7fd115cdf9220e0b6062c48f", "url": "https://github.com/infinispan/infinispan/commit/3dcfb25525f07f8c7fd115cdf9220e0b6062c48f", "message": "ISPN-11151 - Migrating some remote jdbc-cachestore tests from jdg-functional-tests to upstream", "committedDate": "2020-06-22T17:48:58Z", "type": "commit"}, {"oid": "3dcfb25525f07f8c7fd115cdf9220e0b6062c48f", "url": "https://github.com/infinispan/infinispan/commit/3dcfb25525f07f8c7fd115cdf9220e0b6062c48f", "message": "ISPN-11151 - Migrating some remote jdbc-cachestore tests from jdg-functional-tests to upstream", "committedDate": "2020-06-22T17:48:58Z", "type": "forcePushed"}]}