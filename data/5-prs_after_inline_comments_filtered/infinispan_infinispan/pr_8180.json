{"pr_number": 8180, "pr_title": "ISPN-11611 Add internal metadata to persistence", "pr_createdAt": "2020-04-08T09:51:55Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8180", "timeline": [{"oid": "2deb8329ca43d4d4d7293622f4be10093d7ee0af", "url": "https://github.com/infinispan/infinispan/commit/2deb8329ca43d4d4d7293622f4be10093d7ee0af", "message": "ISPN-11611 Add internal metadata to persistence", "committedDate": "2020-04-08T17:04:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1MzQwMA==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406053400", "bodyText": "Unnecessary cast to InternalCacheEntry and should be MarshallableEntry<?, ?>", "author": "ryanemerson", "createdAt": "2020-04-09T08:49:56Z", "path": "core/src/main/java/org/infinispan/eviction/impl/PassivationManagerImpl.java", "diffHunk": "@@ -72,10 +71,9 @@ private boolean isL1Key(Object key) {\n       return distributionManager != null && !distributionManager.getCacheTopology().isWriteOwner(key);\n    }\n \n-   private CompletionStage<Boolean> doPassivate(Object key, CacheEntry<?, ?> entry) {\n+   private CompletionStage<Boolean> doPassivate(Object key, InternalCacheEntry<?, ?> entry) {\n       if (trace) log.tracef(\"Passivating entry %s\", toStr(key));\n-         MarshallableEntry<?, ?> marshalledEntry = marshalledEntryFactory.create(key, entry.getValue(), entry.getMetadata(),\n-               entry.getCreated(), entry.getLastUsed());\n+      MarshallableEntry marshalledEntry = marshalledEntryFactory.create((InternalCacheEntry) entry);", "originalCommit": "2deb8329ca43d4d4d7293622f4be10093d7ee0af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE0Mzc1Mg==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406143752", "bodyText": "the cast is necessary for some weird reason that I fail to understand.\nIf you don't cast, java will invoke org.infinispan.persistence.spi.MarshallableEntryFactory#create(java.lang.Object)", "author": "pruivo", "createdAt": "2020-04-09T11:39:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1MzQwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1MzY3OA==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406053678", "bodyText": "Unnecessary cast to InternalCacheEntry", "author": "ryanemerson", "createdAt": "2020-04-09T08:50:26Z", "path": "core/src/main/java/org/infinispan/eviction/impl/PassivationManagerImpl.java", "diffHunk": "@@ -120,10 +118,7 @@ public void passivateAll() throws PersistenceException {\n       }\n \n       int count = container.sizeIncludingExpired();\n-      Iterable<MarshallableEntry> iterable = () -> new IteratorMapper<>(container.iterator(), e -> {\n-         return marshalledEntryFactory.create(e.getKey(), e.getValue(), e.getMetadata(), e.getExpiryTime(),\n-                                              e.getLastUsed());\n-      });\n+      Iterable<MarshallableEntry> iterable = () -> new IteratorMapper<>(container.iterator(), e -> marshalledEntryFactory.create((InternalCacheEntry) e));", "originalCommit": "2deb8329ca43d4d4d7293622f4be10093d7ee0af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1NjQ0OQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406056449", "bodyText": "We can avoid some of the unchecked call warnings:\n      InternalCacheValue<?> sv = entryFactory.getValueFromCtx(key, ctx);\n      return sv != null ? marshalledEntryFactory.create(key, sv) : null;", "author": "ryanemerson", "createdAt": "2020-04-09T08:55:11Z", "path": "core/src/main/java/org/infinispan/interceptors/impl/CacheWriterInterceptor.java", "diffHunk": "@@ -501,7 +501,7 @@ public int getNumberOfPersistedEntries() {\n \n    MarshallableEntry marshalledEntry(InvocationContext ctx, Object key) {\n       InternalCacheValue sv = entryFactory.getValueFromCtx(key, ctx);\n-      return sv != null ? marshalledEntryFactory.create(key, sv.getValue(), sv.getMetadata(), sv.getCreated(), sv.getLastUsed()) : null;\n+      return sv != null ? marshalledEntryFactory.create(key, sv) : null;", "originalCommit": "2deb8329ca43d4d4d7293622f4be10093d7ee0af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1ODc5OA==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406058798", "bodyText": "Changing the MarshallableEntryFactory variable to:\nprivate final MarshallableEntryFactory<?, ?> marshalledEntryFactory;\nWe can quickly update the usages to be MarshallableEntry<?, ?> and CacheEntry<?, ?> throughout the class.", "author": "ryanemerson", "createdAt": "2020-04-09T08:58:59Z", "path": "core/src/main/java/org/infinispan/interceptors/impl/TxBatchUpdater.java", "diffHunk": "@@ -178,7 +178,7 @@ private Object visitModify(InvocationContext ctx, FlagAffectedCommand command, O\n             if (generateStatistics) putCount++;\n             InternalCacheValue sv = entryFactory.getValueFromCtx(key, ctx);\n             if (sv != null) {\n-               MarshallableEntry me = marshalledEntryFactory.create(key, sv.getValue(), sv.getMetadata(), sv.getCreated(), sv.getLastUsed());\n+               MarshallableEntry me = marshalledEntryFactory.create(key, sv);", "originalCommit": "2deb8329ca43d4d4d7293622f4be10093d7ee0af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA2NTE5MQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406065191", "bodyText": "Unnecessary whitespace", "author": "ryanemerson", "createdAt": "2020-04-09T09:10:17Z", "path": "core/src/main/java/org/infinispan/persistence/file/SingleFileStore.java", "diffHunk": "@@ -510,14 +518,35 @@ public boolean delete(Object key) {\n       if (loadValue) {\n          valueBb = factory.newByteBuffer(data, fe.keyLen, fe.dataLen);\n       }\n-      if (loadMetadata && fe.metadataLen > 0) {\n-         int metaLength = fe.metadataLen - TIMESTAMP_BYTES;\n-         metadataBb = factory.newByteBuffer(data, fe.keyLen + fe.dataLen, metaLength);\n-         ByteBuffer buffer = ByteBuffer.wrap(data, fe.keyLen + fe.dataLen + metaLength, TIMESTAMP_BYTES);\n+      if (loadMetadata) {\n+         long created = -1;\n+         long lastUsed = -1;\n+         org.infinispan.commons.io.ByteBuffer metadataBb = null;\n+         org.infinispan.commons.io.ByteBuffer internalMetadataBb = null;\n+\n+         int offset = fe.keyLen + fe.dataLen;\n+         if (fe.metadataLen > 0) {\n+            int metaLength = fe.metadataLen - TIMESTAMP_BYTES;\n+            metadataBb = factory.newByteBuffer(data, offset, metaLength);\n+\n+            offset += metaLength;\n \n-         long created = fe.expiryTime > 0 ? buffer.getLong() : -1;\n-         long lastUsed = fe.expiryTime > 0 ? buffer.getLong() : -1;\n-         return entryFactory.create(keyBb, valueBb, metadataBb, created, lastUsed);\n+            ByteBuffer buffer = ByteBuffer.wrap(data, offset, TIMESTAMP_BYTES);\n+\n+\n+", "originalCommit": "2deb8329ca43d4d4d7293622f4be10093d7ee0af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA3NjMwNA==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406076304", "bodyText": "This won't be compatible with a 10.1.x SingleFileStore. To keep the FileEntry compatible, we could alter the MAGIC array to determine which version we're reading from.\nFor example:\nprivate static final byte[] MAGIC_10.1.x = new byte[]{'F', 'C', 'S', '1'};\nprivate static final byte[] MAGIC = new byte[]{'F', 'C', 'S', '2'};\nWe then pass boolean readInternalMetadata to rebuildIndex() and handle accordingly.\nObviously we would need a test with the 10.1.x bytes to ensure this works correctly.\n\\cc @wburns", "author": "ryanemerson", "createdAt": "2020-04-09T09:29:09Z", "path": "core/src/main/java/org/infinispan/persistence/file/SingleFileStore.java", "diffHunk": "@@ -196,11 +197,12 @@ private void rebuildIndex() throws Exception {\n          int keyLen = buf.getInt();\n          int dataLen = buf.getInt();\n          int metadataLen = buf.getInt();\n+         int internalMetadataLen = buf.getInt();", "originalCommit": "2deb8329ca43d4d4d7293622f4be10093d7ee0af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjExMTM2Mg==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406111362", "bodyText": "I agree the MAGIC should be changed... but does it need to be backward compatible?\nisn't that the StoreMigrator's job?", "author": "pruivo", "createdAt": "2020-04-09T10:31:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA3NjMwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjExMzYxOQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406113619", "bodyText": "The StoreMigrator is a get out of jail, not quite for free, card. The long term goal is to get so that we can do rolling upgrades seamlessly in kubernetes, so we need to avoid any manual steps.", "author": "ryanemerson", "createdAt": "2020-04-09T10:36:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA3NjMwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3MTIwMw==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406171203", "bodyText": "oh... that was unexpected...\nSingleFileStore can be fixed but the remaining stores (RocksDB, JDBC, SIFS, JPA) are probably broken. there is no \"magic\" or \"version\" field there :/", "author": "pruivo", "createdAt": "2020-04-09T12:33:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA3NjMwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NzQyMQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406177421", "bodyText": "@pruivo we can relatively easy add a new column family for metadata in RocksDB, and a metadata table in JDBC/JPA. For SIFS we may need a breaking change.", "author": "danberindei", "createdAt": "2020-04-09T12:45:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA3NjMwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE5NDEyNA==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406194124", "bodyText": "@danberindei not sure if it is going to work. JDBC and RockDB store the MarshalledValue as byte[]. I guess protostream will fail to unmarshall it because it expects to have another field...\nAbout JPA, my knowledge is -infinity. I just copy what others did\n@Lob\n@Column(length = 65535)\nprivate byte[] internalMetadata;", "author": "pruivo", "createdAt": "2020-04-09T13:14:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA3NjMwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIwODU0OQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406208549", "bodyText": "My bad, I was only thinking about the missing magic/version fields, so was using \"metadata\" as \"information about the store itself\", not as in \"information about the entries\".\nI'm not very familiar with JPA either, but for JDBC/RocksDB it should be fairly easy to check when opening a store if the new table/column family exists or not.\nHowever, this doesn't completely solve our problem, we also have to migrate the existing entries, or we wouldn't be able to change the version of the store, and we wouldn't be able to store the internal metadata.", "author": "danberindei", "createdAt": "2020-04-09T13:35:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA3NjMwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMyODEwNw==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406328107", "bodyText": "@pruivo @danberindei  For store implementations that use MarshalledValueImpl to store the value, i.e. Jdbc & Rocksdb, we should be ok because you have added the internal metadata there. The way Protobuf/ProtoStream works, if a field is missing from the old bytes, then it just isn't read and so in MarshalledValueImpl we can just set the internal metadata to null. So there shouldn't be any additional logic in the store itself AFAICT.", "author": "ryanemerson", "createdAt": "2020-04-09T16:30:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA3NjMwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMyODQ0MA==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406328440", "bodyText": "About JPA, my knowledge is -infinity. I just copy what others did\n\nThat's what we all do \ud83d\ude06", "author": "ryanemerson", "createdAt": "2020-04-09T16:30:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA3NjMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA3NzE2Ng==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406077166", "bodyText": "Nitpick, but can we inline like elsewhere.", "author": "ryanemerson", "createdAt": "2020-04-09T09:30:27Z", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -145,6 +141,10 @@\n    @Inject Transport transport;\n    @Inject @ComponentName(NON_BLOCKING_EXECUTOR)\n    ExecutorService nonBlockingExecutor;\n+   @Inject\n+   ComponentRef<InvocationHelper> invocationHelper;\n+   @Inject\n+   ComponentRef<CommandsFactory> commandsFactory;", "originalCommit": "2deb8329ca43d4d4d7293622f4be10093d7ee0af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA3OTk4NQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406079985", "bodyText": "JPA is still a dark art to me. Will this have any impact on backwards compatibility? Or will the new field simply not be set if it does not exist?", "author": "ryanemerson", "createdAt": "2020-04-09T09:35:27Z", "path": "persistence/jpa/src/main/java/org/infinispan/persistence/jpa/impl/MetadataEntity.java", "diffHunk": "@@ -39,6 +39,9 @@\n    private long lastUsed;\n    @Version\n    private int version;\n+   @Lob\n+   @Column(length = 65535)\n+   private byte[] internalMetadata;", "originalCommit": "2deb8329ca43d4d4d7293622f4be10093d7ee0af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA4MDk1Nw==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406080957", "bodyText": "Why is this change necessary?", "author": "ryanemerson", "createdAt": "2020-04-09T09:37:15Z", "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -309,25 +309,21 @@ public void deleteBatch(Iterable<Object> keys) {\n \n     private void putExpireDbData(ExpiryEntry entry) throws InterruptedException, RocksDBException, IOException,\n        ClassNotFoundException {\n-        try {\n-            final byte[] expiryBytes = marshall(entry.expiry);\n-            final byte[] existingBytes = expiredDb.get(expiryBytes);\n-\n-            if (existingBytes != null) {\n-                // in the case of collision make the value a List ...\n-                final Object existing = unmarshall(existingBytes);\n-                if (existing instanceof ExpiryBucket) {\n-                    ((ExpiryBucket) existing).entries.add(entry.keyBytes);\n-                    expiredDb.put(expiryBytes, marshall(existing));\n-                } else {\n-                    ExpiryBucket bucket = new ExpiryBucket(existingBytes, entry.keyBytes);\n-                    expiredDb.put(expiryBytes, marshall(bucket));\n-                }\n+        final byte[] expiryBytes = marshall(entry.expiry);\n+        final byte[] existingBytes = expiredDb.get(expiryBytes);\n+\n+        if (existingBytes != null) {\n+            // in the case of collision make the value a List ...\n+            final Object existing = unmarshall(existingBytes);\n+            if (existing instanceof ExpiryBucket) {\n+                ((ExpiryBucket) existing).entries.add(entry.keyBytes);\n+                expiredDb.put(expiryBytes, marshall(existing));\n             } else {\n-                expiredDb.put(expiryBytes, entry.keyBytes);\n+                ExpiryBucket bucket = new ExpiryBucket(existingBytes, entry.keyBytes);\n+                expiredDb.put(expiryBytes, marshall(bucket));\n             }\n-        } catch (IOException | InterruptedException | RocksDBException | ClassNotFoundException e) {\n-            throw e;\n+        } else {\n+            expiredDb.put(expiryBytes, entry.keyBytes);", "originalCommit": "2deb8329ca43d4d4d7293622f4be10093d7ee0af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE2MTk2NQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406161965", "bodyText": "no, but catching an exception just to throw it, is a waste of bytecodes :P", "author": "pruivo", "createdAt": "2020-04-09T12:16:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA4MDk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA5MTY2NQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406091665", "bodyText": "Like the SFS this won't be backwards compatible as the HEADER_SIZE has changed, however in this case we can't workaround this using the MAGIC array as it does not exist. So I think we might need to add a magic field, and read accordingly depending on whether it is/isn't present.", "author": "ryanemerson", "createdAt": "2020-04-09T09:55:51Z", "path": "persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/EntryHeader.java", "diffHunk": "@@ -23,6 +24,7 @@ public EntryHeader(ByteBuffer buffer) {\n       this.keyLength = buffer.getShort();\n       this.metadataLength = buffer.getShort();\n       this.valueLength = buffer.getInt();\n+      this.internalMetadataLength = buffer.getInt();", "originalCommit": "2deb8329ca43d4d4d7293622f4be10093d7ee0af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIwOTg0NQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406209845", "bodyText": "I would prefer adding the version information as a separate file, so we can easily check if the version information exists and default to the 10.1 layout (or migrate in-place to the 11+ layout).", "author": "danberindei", "createdAt": "2020-04-09T13:37:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA5MTY2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMyOTM5MQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406329391", "bodyText": "A separate file makes sense.", "author": "ryanemerson", "createdAt": "2020-04-09T16:32:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA5MTY2NQ=="}], "type": "inlineReview"}, {"oid": "2d987312072d97521f826944a8dc29d04103faeb", "url": "https://github.com/infinispan/infinispan/commit/2d987312072d97521f826944a8dc29d04103faeb", "message": "ISPN-11611 Add internal metadata to persistence", "committedDate": "2020-04-09T13:57:26Z", "type": "forcePushed"}, {"oid": "dbc950b0e4bac66be391e5651b2e3c42d76522cd", "url": "https://github.com/infinispan/infinispan/commit/dbc950b0e4bac66be391e5651b2e3c42d76522cd", "message": "Fix SIFS", "committedDate": "2020-04-13T15:49:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyODI3Nw==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r408028277", "bodyText": "Don't forget \ud83d\ude42", "author": "ryanemerson", "createdAt": "2020-04-14T10:21:28Z", "path": "commons/all/src/main/java/org/infinispan/commons/io/EmptyByteBuffer.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package org.infinispan.commons.io;\n+\n+import org.infinispan.commons.util.Util;\n+\n+/**\n+ * //TODO document this!", "originalCommit": "dbc950b0e4bac66be391e5651b2e3c42d76522cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzOTY2Mg==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r408039662", "bodyText": "ops...", "author": "pruivo", "createdAt": "2020-04-14T10:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyODI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyOTA2NQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r408029065", "bodyText": "HEADER_SIZE_10_1 and HEADER_SIZE_11_0 would be more informative.", "author": "ryanemerson", "createdAt": "2020-04-14T10:22:45Z", "path": "persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/EntryHeader.java", "diffHunk": "@@ -7,26 +7,33 @@\n  */\n public class EntryHeader {\n    static final int MAGIC = 0xBE11A61C;\n-   static final boolean useMagic = false;\n-   static final int HEADER_SIZE = 28 + (useMagic ? 4 : 0);\n+   //no magic neither no internal metadata\n+   static final int OLD_HEADER_SIZE = 24;\n+   static final int HEADER_SIZE = 32;", "originalCommit": "dbc950b0e4bac66be391e5651b2e3c42d76522cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzOTYxMg==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r408039612", "bodyText": "ack", "author": "pruivo", "createdAt": "2020-04-14T10:41:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyOTA2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzMTE0Mg==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r408031142", "bodyText": "I would prefer to avoid writing MAGIC per header if possilbe. However, if we can't avoid that we should at least store it as a single byte. useMagic was only ever used for testing, so we don't have to worry about the compatibility of this field as it was never used in production.", "author": "ryanemerson", "createdAt": "2020-04-14T10:26:21Z", "path": "persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/EntryHeader.java", "diffHunk": "@@ -53,12 +60,26 @@ public long expiryTime() {\n       return expiration;\n    }\n \n+   public int getHeaderLength() {\n+      return headerLength;\n+   }\n+\n    @Override\n    public String toString() {\n       return String.format(\"[keyLength=%d, valueLength=%d, metadataLength=%d, internalMetadataLength=%d,seqId=%d, expiration=%d]\", keyLength, valueLength, metadataLength, internalMetadataLength, seqId, expiration);\n    }\n \n    public int totalLength() {\n-      return keyLength + metadataLength + internalMetadataLength + valueLength + HEADER_SIZE;\n+      return keyLength + metadataLength + internalMetadataLength + valueLength + headerLength;\n+   }\n+\n+   public static void writeHeader(ByteBuffer buf, short keyLength, short metadataLength, int valueLength, int internalMetadataLength, long seqId, long expiration) {\n+      buf.putInt(EntryHeader.MAGIC);", "originalCommit": "dbc950b0e4bac66be391e5651b2e3c42d76522cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA0MjEzNw==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r408042137", "bodyText": "I'll change to byte.\nIMO, it is better to keep a magic number per entry. If I understand correctly, SIFS only appends the keys changes to a new file; So, if the format changes in the future, we don't need any migration during startup.", "author": "pruivo", "createdAt": "2020-04-14T10:46:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzMTE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzNTE1MQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r408035151", "bodyText": "What if the user is migrating a store from the existing version of Infinispan, i.e. 11.x?", "author": "ryanemerson", "createdAt": "2020-04-14T10:33:47Z", "path": "tools/src/main/java/org/infinispan/tools/store/migrator/file/SoftIndexFileStoreIterator.java", "diffHunk": "@@ -85,7 +85,7 @@ public MarshallableEntry next() {\n                      byte[] serializedValue = EntryRecord.readValue(handle, header, offset);\n \n                      offset += header.totalLength();\n-                     if (EntryRecord.readEntryHeader(handle, offset) == null) {\n+                     if (EntryRecord.readOldEntryHeader(handle, offset) == null) {", "originalCommit": "3209115ecc0fd3e6ef5b08b035a6a091fe984279", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA0NDMyNA==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r408044324", "bodyText": "no sure If I understand what you mean... migrating for 11.0 to 11.x?\nThe filenames changed with this PR and the FileProvider only searches for old file names, i.e. the file names previous to this PR.\nAfter this PR, the users don't need to migrate anything. We have the magic number per entry so we are able to read anything.", "author": "pruivo", "createdAt": "2020-04-14T10:50:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzNTE1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEwMTM3OQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r408101379", "bodyText": "no sure If I understand what you mean... migrating for 11.0 to 11.x?\n\nYes. Currently it's possible to migrate from one store implementation to another, e.g. SIFS -> RocksDB, within the latest Infinispan version.\nYou can determine the version of the source store via StoreProperties#getMajorVersion and call readOldEntryHeader if < 11", "author": "ryanemerson", "createdAt": "2020-04-14T12:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzNTE1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODExMTIwNg==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r408111206", "bodyText": "ok!\nI wasn't aware of that. I need to update SFS too since it is only parsing the old format.", "author": "pruivo", "createdAt": "2020-04-14T12:52:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzNTE1MQ=="}], "type": "inlineReview"}, {"oid": "1536ecf1815069237237e414f40b36ab7b2ca7f8", "url": "https://github.com/infinispan/infinispan/commit/1536ecf1815069237237e414f40b36ab7b2ca7f8", "message": "ISPN-11611 Add internal metadata to persistence", "committedDate": "2020-04-14T10:53:45Z", "type": "forcePushed"}, {"oid": "d4256abeb22908a556288a7e490dd7e3e1a76e9d", "url": "https://github.com/infinispan/infinispan/commit/d4256abeb22908a556288a7e490dd7e3e1a76e9d", "message": "ISPN-11611 Add internal metadata to persistence", "committedDate": "2020-04-14T10:57:54Z", "type": "forcePushed"}, {"oid": "65a8334a2def849f1ba8b1014adfac88a9622f0e", "url": "https://github.com/infinispan/infinispan/commit/65a8334a2def849f1ba8b1014adfac88a9622f0e", "message": "ISPN-11611 Add internal metadata to persistence", "committedDate": "2020-04-14T14:33:54Z", "type": "forcePushed"}, {"oid": "3bf8d3ce459065f2271d528e55268741267ca84b", "url": "https://github.com/infinispan/infinispan/commit/3bf8d3ce459065f2271d528e55268741267ca84b", "message": "ISPN-11611 Add internal metadata to persistence", "committedDate": "2020-04-14T15:36:01Z", "type": "forcePushed"}, {"oid": "22777f3968555493613fe5097d08a3d6385c9cb7", "url": "https://github.com/infinispan/infinispan/commit/22777f3968555493613fe5097d08a3d6385c9cb7", "message": "ISPN-11611 Add internal metadata to persistence", "committedDate": "2020-04-20T08:40:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI0MzkyNA==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r411243924", "bodyText": "Can we replace this with a EMPTY_INSTANCE field in ByteBufferImpl? So:\npublic static final ByteBufferImpl EMPTY_INSTANCE = new ByteBufferImpl(Util.EMPTY_BYTE_ARRAY);\n...\n   @Override\n   public ByteBufferImpl copy() {\n      if (this == EMPTY_INSTANCE)\n          return this;\n      byte[] new_buf = buf != null ? new byte[length] : null;\n      int new_length = new_buf != null ? new_buf.length : 0;\n      if (new_buf != null)\n         System.arraycopy(buf, offset, new_buf, 0, length);\n      return new ByteBufferImpl(new_buf, 0, new_length);\n   }\nPolymorphism introduces headaches on the Protostream marshalling side, so avoiding unnecessary cases like this will make our marshalling code much cleaner as I only have to handle one ByteBuffer implementation.", "author": "ryanemerson", "createdAt": "2020-04-20T09:49:10Z", "path": "commons/all/src/main/java/org/infinispan/commons/io/EmptyByteBuffer.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package org.infinispan.commons.io;\n+\n+import org.infinispan.commons.util.Util;\n+\n+/**\n+ * An empty {@link ByteBuffer} implementation.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+public class EmptyByteBuffer implements ByteBuffer {", "originalCommit": "22777f3968555493613fe5097d08a3d6385c9cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI0NjgwNQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r411246805", "bodyText": "If we have EMPTY_INSTANCE in ByteBufferImpl we can create a static create method in that class that can be used throughout our code.\npublic static ByteBuffer create(byte[] array) {\n    return array == null || array.length == 0 ? EMPTY_INSTANCE : new ByteBufferImpl(array);\n}", "author": "ryanemerson", "createdAt": "2020-04-20T09:53:41Z", "path": "core/src/main/java/org/infinispan/marshall/persistence/impl/MarshalledValueImpl.java", "diffHunk": "@@ -21,21 +22,27 @@\n @ProtoTypeId(ProtoStreamTypeIds.MARSHALLED_VALUE_IMPL)\n public class MarshalledValueImpl implements MarshalledValue {\n \n-   static final MarshalledValue EMPTY = new MarshalledValueImpl((ByteBuffer) null, null, -1, -1);\n+   static final MarshalledValue EMPTY = new MarshalledValueImpl(null, null, null, -1, -1);\n \n    private final ByteBuffer valueBytes;\n    private final ByteBuffer metadataBytes;\n+   private final ByteBuffer internalMetadataBytes;\n    private final long created;\n    private final long lastUsed;\n \n+   private static ByteBuffer wrap(byte[] array) {\n+      return array == null || array.length == 0 ? EmptyByteBuffer.INSTANCE : new ByteBufferImpl(array);\n+   }", "originalCommit": "22777f3968555493613fe5097d08a3d6385c9cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI0NzM3Ng==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r411247376", "bodyText": "name attribute is redundant as the proto name will already be \"internalMetadata\"", "author": "ryanemerson", "createdAt": "2020-04-20T09:54:32Z", "path": "core/src/main/java/org/infinispan/marshall/persistence/impl/MarshalledValueImpl.java", "diffHunk": "@@ -62,6 +69,11 @@ public long getLastUsed() {\n       return lastUsed;\n    }\n \n+   @ProtoField(number = 5, name = \"internalMetadata\")\n+   byte[] getInternalMetadata() {", "originalCommit": "22777f3968555493613fe5097d08a3d6385c9cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI1NzI0Nw==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r411257247", "bodyText": "I don't think these static methods simplify things. arrayLength and bufferLenth are only called once as well. I would prefer just to keep the checks inline.", "author": "ryanemerson", "createdAt": "2020-04-20T10:10:17Z", "path": "persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/EntryRecord.java", "diffHunk": "@@ -117,17 +150,31 @@ private static int read(FileProvider.Handle handle, ByteBuffer buffer, long posi\n       return read;\n    }\n \n+   private static int arrayLength(byte[] array) {\n+      return array == null ? 0 : array.length;\n+   }\n+\n+   private static short arrayLengthAsShort(byte[] array) {\n+      return array == null ? 0 : (short) array.length;\n+   }\n+\n+   private static int bufferLength(org.infinispan.commons.io.ByteBuffer byteBuffer) {\n+      return byteBuffer == null ? 0 : byteBuffer.getLength();\n+   }\n+\n+   private static short bufferLengthAsShort(org.infinispan.commons.io.ByteBuffer byteBuffer) {\n+      return byteBuffer == null ? 0 : (short) byteBuffer.getLength();\n+   }", "originalCommit": "22777f3968555493613fe5097d08a3d6385c9cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI1ODkwMQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r411258901", "bodyText": "I think this log and a message indicating that the migration has sucessfully completed should be info the same as in SFS.", "author": "ryanemerson", "createdAt": "2020-04-20T10:13:05Z", "path": "persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/SoftIndexFileStore.java", "diffHunk": "@@ -163,40 +164,93 @@ public void start() {\n       compactor.setIndex(index);\n       startIndex();\n       final AtomicLong maxSeqId = new AtomicLong(0);\n-      if (index.isLoaded()) {\n-         log.debug(\"Not building the index - loaded from persisted state\");\n-      } else if (configuration.purgeOnStartup()) {\n-         log.debug(\"Not building the index - purge will be executed\");\n+      boolean migrateData = false;\n+\n+      if (!configuration.purgeOnStartup()) {\n+         // we don't destroy the data on startup\n+         // get the old files\n+         FileProvider oldFileProvider = new FileProvider(getDataLocation(), configuration.openFilesLimit(), \"\");\n+         if (oldFileProvider.hasFiles()) {\n+            log.debug(\"Migrate old format to new format.\");", "originalCommit": "22777f3968555493613fe5097d08a3d6385c9cb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI3ODk3Mw==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r411278973", "bodyText": "should the log message be in the class logger or under PERSISTENCE logger?", "author": "pruivo", "createdAt": "2020-04-20T10:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI1ODkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI4MTUwOQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r411281509", "bodyText": "Good question. I think PERSISTENCE. The same applies for SFS", "author": "ryanemerson", "createdAt": "2020-04-20T10:52:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI1ODkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI2MDg5MQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r411260891", "bodyText": "Nitpick. Single line comment", "author": "ryanemerson", "createdAt": "2020-04-20T10:16:22Z", "path": "persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/SoftIndexFileStore.java", "diffHunk": "@@ -163,40 +164,93 @@ public void start() {\n       compactor.setIndex(index);\n       startIndex();\n       final AtomicLong maxSeqId = new AtomicLong(0);\n-      if (index.isLoaded()) {\n-         log.debug(\"Not building the index - loaded from persisted state\");\n-      } else if (configuration.purgeOnStartup()) {\n-         log.debug(\"Not building the index - purge will be executed\");\n+      boolean migrateData = false;\n+\n+      if (!configuration.purgeOnStartup()) {\n+         // we don't destroy the data on startup\n+         // get the old files\n+         FileProvider oldFileProvider = new FileProvider(getDataLocation(), configuration.openFilesLimit(), \"\");\n+         if (oldFileProvider.hasFiles()) {\n+            log.debug(\"Migrate old format to new format.\");\n+            migrateFromOldFormat(oldFileProvider);\n+            migrateData = true;\n+         } else if (index.isLoaded()) {\n+            log.debug(\"Not building the index - loaded from persisted state\");\n+         } else {\n+            log.debug(\"Building the index\");\n+            buildIndex(maxSeqId);\n+         }\n       } else {\n-         log.debug(\"Building the index\");\n+         log.debug(\"Not building the index - purge will be executed\");\n+      }\n+      if (!migrateData) {\n+         logAppender.setSeqId(maxSeqId.get() + 1);\n+      }\n+   }\n \n-         Flowable<Integer> filePublisher = filePublisher();\n-         CompletionStage<Void> stage = handleFilePublisher(filePublisher.doAfterNext(compactor::completeFile), false, false,\n-               (file, offset, size, serializedKey, entryMetadata, serializedValue, seqId, expiration) -> {\n-                  long prevSeqId;\n-                  while (seqId > (prevSeqId = maxSeqId.get()) && !maxSeqId.compareAndSet(prevSeqId, seqId)) {\n+   private void migrateFromOldFormat(FileProvider oldFileProvider) {\n+      try {\n+         index.clear();\n+      } catch (IOException e) {\n+         throw new PersistenceException(e);\n+      }\n+      long lastIndex = -1;\n+      try(CloseableIterator<Integer> it = oldFileProvider.getFileIterator()) {\n+         while (it.hasNext()) {\n+            int fileId = it.next();\n+            try (FileProvider.Handle handle = oldFileProvider.getFile(fileId)) {\n+               int offset = 0;\n+               while (true) {\n+                  EntryHeader header = EntryRecord.readOldEntryHeader(handle, offset);\n+                  if (header == null) {\n+                     //end of file. go to next one\n+                     break;\n                   }\n-                  Object key = marshaller.objectFromByteBuffer(serializedKey);\n-                  if (trace) {\n-                     log.tracef(\"Loaded %d:%d (seqId %d, expiration %d)\", file, offset, seqId, expiration);\n+                  MarshallableEntry<Object, Object> entry = readEntry(handle, header, offset, null);\n+                  // entry is null if expired or removed (tombstone)\n+                  // in both case, we can ignore it.", "originalCommit": "22777f3968555493613fe5097d08a3d6385c9cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fd70260bb7d7b9944e75d7281f1696b4d193ed94", "url": "https://github.com/infinispan/infinispan/commit/fd70260bb7d7b9944e75d7281f1696b4d193ed94", "message": "Try fix SIFS store", "committedDate": "2020-04-21T10:16:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc3Nzc5NQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412777795", "bodyText": "Why is this necessary? Can't we just use tmpDirectory(Class<?> test)?", "author": "ryanemerson", "createdAt": "2020-04-22T08:25:54Z", "path": "commons-test/src/main/java/org/infinispan/commons/test/CommonsTestingUtil.java", "diffHunk": "@@ -47,6 +47,17 @@ public static String tmpDirectory() {\n       return System.getProperty(\"infinispan.test.tmpdir\", System.getProperty(\"java.io.tmpdir\"));\n    }\n \n+   /**\n+    * Creates a path to a unique (per test) temporary directory. The directory is created in the platform's temp\n+    * directory (set by {@code java.io.tmpdir}).\n+    *\n+    * @param test test that requires this directory.\n+    * @return an absolute path\n+    */\n+   public static String javaTmpDirectory(Class<?> test) {", "originalCommit": "9279238abaeb47d6ba267cd76d33ba86d7e31dbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxMjg5Ng==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412812896", "bodyText": "This is for the JPA store.\nThe path has to be set in persistence.xml but the tmpDirectory() method uses infinispan.test.tmpdir. If infinispan.test.tmpdir is not set, it falls back to java.io.tmpdir.\nIf I use infinispan.test.tmpdir and it was not set, the DB will point to the incorrect location.", "author": "pruivo", "createdAt": "2020-04-22T09:14:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc3Nzc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc3OTk0OQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412779949", "bodyText": "Can be:\nreturn ByteBufferImpl.create(b, offset, length);`", "author": "ryanemerson", "createdAt": "2020-04-22T08:28:43Z", "path": "commons/all/src/main/java/org/infinispan/commons/io/ByteBufferFactoryImpl.java", "diffHunk": "@@ -8,6 +8,6 @@\n \n    @Override\n    public ByteBuffer newByteBuffer(byte[] b, int offset, int length) {\n-      return new ByteBufferImpl(b, offset, length);\n+      return b == null || b.length == 0 || length == 0 ? ByteBufferImpl.EMPTY_INSTANCE : new ByteBufferImpl(b, offset, length);", "originalCommit": "9279238abaeb47d6ba267cd76d33ba86d7e31dbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxMzkxMg==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412813912", "bodyText": "there is no ByteBufferImpl.create(b, offset, length); method. Are you suggesting creating one?", "author": "pruivo", "createdAt": "2020-04-22T09:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc3OTk0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg0ODA1OA==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412848058", "bodyText": "Sorry, I was thinking there was. But yeah lets add ByteBufferImpl.create(b, offset, length), that way all of the logic around EMPTY_INSTANCE is in one place and ByteBufferImpl.create(b) impl can just call the overloaded method.", "author": "ryanemerson", "createdAt": "2020-04-22T10:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc3OTk0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg5NjEzNA==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412896134", "bodyText": "done!\nI changed PersistenceMarshallerImpl a little since it was allocating and copying the array twice.", "author": "pruivo", "createdAt": "2020-04-22T11:22:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc3OTk0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk1NDk3MQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412954971", "bodyText": "Good spot, thanks", "author": "ryanemerson", "createdAt": "2020-04-22T12:52:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc3OTk0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc4NDc5Mg==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412784792", "bodyText": "Nitpick. Unnecessary empty line", "author": "ryanemerson", "createdAt": "2020-04-22T08:35:16Z", "path": "core/src/test/java/org/infinispan/persistence/file/SingleFileStoreCompatibilityTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package org.infinispan.persistence.file;\n+\n+import java.io.File;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+\n+import org.infinispan.commons.test.CommonsTestingUtil;\n+import org.infinispan.commons.util.FileLookupFactory;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.persistence.PersistenceCompatibilityTest;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Tests if {@link SingleFileStore} can migrate data from Infinispan 10.1.x.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+@Test(groups = \"functional\", testName = \"persistence.file.SingleFileStoreCompatibilityTest\")\n+public class SingleFileStoreCompatibilityTest extends PersistenceCompatibilityTest<String> {\n+\n+   private static final String DATA_10_1 = \"10_1_x_sfs_data/sfs-store-cache.dat\";\n+   private String tmpDirectory;\n+\n+", "originalCommit": "9279238abaeb47d6ba267cd76d33ba86d7e31dbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxNDI5Ng==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412814296", "bodyText": "\ud83d\udc4d", "author": "pruivo", "createdAt": "2020-04-22T09:16:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc4NDc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc4NjQ3NQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412786475", "bodyText": "We can pass this to the constructor of PersistenceCompatibilityTest so that we don't have to override setup and teardown in all of the tests.", "author": "ryanemerson", "createdAt": "2020-04-22T08:37:37Z", "path": "core/src/test/java/org/infinispan/persistence/file/SingleFileStoreCompatibilityTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package org.infinispan.persistence.file;\n+\n+import java.io.File;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+\n+import org.infinispan.commons.test.CommonsTestingUtil;\n+import org.infinispan.commons.util.FileLookupFactory;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.persistence.PersistenceCompatibilityTest;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Tests if {@link SingleFileStore} can migrate data from Infinispan 10.1.x.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+@Test(groups = \"functional\", testName = \"persistence.file.SingleFileStoreCompatibilityTest\")\n+public class SingleFileStoreCompatibilityTest extends PersistenceCompatibilityTest<String> {\n+\n+   private static final String DATA_10_1 = \"10_1_x_sfs_data/sfs-store-cache.dat\";\n+   private String tmpDirectory;", "originalCommit": "9279238abaeb47d6ba267cd76d33ba86d7e31dbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxNjQ1Ng==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412816456", "bodyText": "\ud83d\udc4d", "author": "pruivo", "createdAt": "2020-04-22T09:19:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc4NjQ3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc4NzY0NQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412787645", "bodyText": "We can set the Global persistent location here:\nbuilder.globalState().persistentLocation(CommonsTestingUtil.tmpDirectory())\nThat way not all of the tests have to override amendGlobalConfigurationBuilder and it should not negatively effect the JPA and JDBC tests that don't need it.", "author": "ryanemerson", "createdAt": "2020-04-22T08:39:16Z", "path": "core/src/test/java/org/infinispan/persistence/PersistenceCompatibilityTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.infinispan.persistence;\n+\n+import static org.infinispan.persistence.PersistenceUtil.getQualifiedLocation;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNull;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.util.FileLookupFactory;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.test.SingleCacheManagerTest;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Base compatibility test for cache stores.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+@Test(groups = \"functional\")\n+public abstract class PersistenceCompatibilityTest<T> extends SingleCacheManagerTest {\n+\n+   private static final int NUMBER_KEYS = 10;\n+   private final KeyValueWrapper<String, String, T> valueWrapper;\n+\n+   protected PersistenceCompatibilityTest(KeyValueWrapper<String, String, T> valueWrapper) {\n+      this.valueWrapper = valueWrapper;\n+   }\n+\n+   private static String key(int index) {\n+      return \"key-\" + index;\n+   }\n+\n+   private static String value(int index) {\n+      return \"value-\" + index;\n+   }\n+\n+   protected static void copyFile(String file_10_1, Path location, String fileName) throws IOException {\n+      InputStream is = FileLookupFactory.newInstance()\n+            .lookupFile(file_10_1, Thread.currentThread().getContextClassLoader());\n+      File f = new File(location.toFile(), fileName);\n+      Files.copy(is, f.toPath(), StandardCopyOption.REPLACE_EXISTING);\n+   }\n+\n+   @Test\n+   public void testReadWriteFrom101() throws Exception {\n+      // 10 keys\n+      // even keys stored, odd keys removed\n+      beforeStartCache();\n+      Cache<String, T> cache = cacheManager.getCache(cacheName());\n+\n+      for (int i = 0; i < NUMBER_KEYS; ++i) {\n+         String key = key(i);\n+         if (i % 2 != 0) {\n+            assertNull(\"Expected null value for key \" + key, cache.get(key));\n+         } else {\n+            assertEquals(\"Wrong value read for key \" + key, value(i), valueWrapper.unwrap(cache.get(key)));\n+         }\n+      }\n+\n+      for (int i = 0; i < NUMBER_KEYS; ++i) {\n+         if (i % 2 != 0) {\n+            String key = key(i);\n+            cache.put(key, valueWrapper.wrap(key, value(i)));\n+         }\n+      }\n+\n+      for (int i = 0; i < NUMBER_KEYS; ++i) {\n+         String key = key(i);\n+         assertEquals(\"Wrong value read for key \" + key, value(i), valueWrapper.unwrap(cache.get(key)));\n+      }\n+\n+   }\n+\n+   protected abstract void beforeStartCache() throws Exception;\n+\n+   @Override\n+   protected EmbeddedCacheManager createCacheManager() throws Exception {\n+      GlobalConfigurationBuilder builder = new GlobalConfigurationBuilder().nonClusteredDefault();", "originalCommit": "9279238abaeb47d6ba267cd76d33ba86d7e31dbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxNjYwNA==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412816604", "bodyText": "\ud83d\udc4d", "author": "pruivo", "createdAt": "2020-04-22T09:19:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc4NzY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5NTg5OQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412795899", "bodyText": "It would be good to have the prefix values as constants, e.g. 10_1_PREFIX = \"\", 11_0_PREFIX=\"ispn.\"", "author": "ryanemerson", "createdAt": "2020-04-22T08:50:27Z", "path": "persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/SoftIndexFileStore.java", "diffHunk": "@@ -150,7 +151,7 @@ public void start() {\n       temporaryTable = new TemporaryTable(configuration.indexQueueLength() * configuration.indexSegments());\n       storeQueue = new SyncProcessingQueue<>();\n       indexQueue = new IndexQueue(configuration.indexSegments(), configuration.indexQueueLength());\n-      fileProvider = new FileProvider(getDataLocation(), configuration.openFilesLimit());\n+      fileProvider = new FileProvider(getDataLocation(), configuration.openFilesLimit(), \"ispn.\");", "originalCommit": "9279238abaeb47d6ba267cd76d33ba86d7e31dbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxNzQzNA==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412817434", "bodyText": "\ud83d\udc4d", "author": "pruivo", "createdAt": "2020-04-22T09:20:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5NTg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5NjQ4OQ==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412796489", "bodyText": "We should use the statements you introduced in Log.java", "author": "ryanemerson", "createdAt": "2020-04-22T08:51:13Z", "path": "persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/SoftIndexFileStore.java", "diffHunk": "@@ -163,40 +164,95 @@ public void start() {\n       compactor.setIndex(index);\n       startIndex();\n       final AtomicLong maxSeqId = new AtomicLong(0);\n-      if (index.isLoaded()) {\n-         log.debug(\"Not building the index - loaded from persisted state\");\n-      } else if (configuration.purgeOnStartup()) {\n-         log.debug(\"Not building the index - purge will be executed\");\n+      boolean migrateData = false;\n+\n+      if (!configuration.purgeOnStartup()) {\n+         // we don't destroy the data on startup\n+         // get the old files\n+         FileProvider oldFileProvider = new FileProvider(getDataLocation(), configuration.openFilesLimit(), \"\");\n+         if (oldFileProvider.hasFiles()) {\n+            org.infinispan.util.logging.Log.PERSISTENCE.info(\"Migrating data new format...\");", "originalCommit": "9279238abaeb47d6ba267cd76d33ba86d7e31dbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5NzM0Nw==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412797347", "bodyText": "The code will be a lot cleaner if we statically import PERSISTENCE log.", "author": "ryanemerson", "createdAt": "2020-04-22T08:52:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5NjQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxOTI0Mw==", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412819243", "bodyText": "\ud83d\udc4d", "author": "pruivo", "createdAt": "2020-04-22T09:23:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5NjQ4OQ=="}], "type": "inlineReview"}, {"oid": "78875fb7e2282eef53d37f30f80c6e57bb3410c0", "url": "https://github.com/infinispan/infinispan/commit/78875fb7e2282eef53d37f30f80c6e57bb3410c0", "message": "ISPN-11611 Add internal metadata to persistence", "committedDate": "2020-04-23T10:47:49Z", "type": "forcePushed"}, {"oid": "3f192aa916f4786495667e2483d6bc4ec7ef836e", "url": "https://github.com/infinispan/infinispan/commit/3f192aa916f4786495667e2483d6bc4ec7ef836e", "message": "ISPN-11611 Add internal metadata to persistence", "committedDate": "2020-04-23T14:45:29Z", "type": "commit"}, {"oid": "3f192aa916f4786495667e2483d6bc4ec7ef836e", "url": "https://github.com/infinispan/infinispan/commit/3f192aa916f4786495667e2483d6bc4ec7ef836e", "message": "ISPN-11611 Add internal metadata to persistence", "committedDate": "2020-04-23T14:45:29Z", "type": "forcePushed"}]}