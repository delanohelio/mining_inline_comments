{"pr_number": 8410, "pr_title": "ISPN-11937 JDBCStringBasedStore needs test around a rollback occurring", "pr_createdAt": "2020-05-29T17:29:33Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8410", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg3NzY3Mw==", "url": "https://github.com/infinispan/infinispan/pull/8410#discussion_r433877673", "bodyText": "I think this could be clearer. How about:\n\"Store %s cannot be configured to be transactional as it does not contain the TRANSACTIONAL characteristic\" ?", "author": "ryanemerson", "createdAt": "2020-06-02T13:33:18Z", "path": "core/src/main/java/org/infinispan/util/logging/Log.java", "diffHunk": "@@ -2023,4 +2023,7 @@ CacheConfigurationException storeConfiguredHasBothReadAndWriteOnly(String storeC\n    @LogMessage(level = WARN)\n    @Message(value = \"ClusterLoader has been deprecated and will be removed in a future version with no direct replacement\", id = 595)\n    void warnUsingDeprecatedClusterLoader();\n+\n+   @Message(value = \"Store %s cannot be configured to be transactional as the implementation characteristic doesn't support it\", id = 596)", "originalCommit": "46633a32fdeb4eb13647dc3703eb132a174079be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwOTU0MA==", "url": "https://github.com/infinispan/infinispan/pull/8410#discussion_r433909540", "bodyText": "Sure.", "author": "wburns", "createdAt": "2020-06-02T14:13:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg3NzY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg3OTE4MQ==", "url": "https://github.com/infinispan/infinispan/pull/8410#discussion_r433879181", "bodyText": "Can we have this at the top of the class so it's not necessary to scroll to see the parameters.", "author": "ryanemerson", "createdAt": "2020-06-02T13:35:25Z", "path": "persistence/jdbc/src/test/java/org/infinispan/persistence/jdbc/stringbased/JdbcStringBasedStoreTxFunctionalTest.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package org.infinispan.persistence.jdbc.stringbased;\n+\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNull;\n+\n+import java.lang.reflect.Method;\n+\n+import javax.transaction.NotSupportedException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.persistence.jdbc.configuration.JdbcStringBasedStoreConfigurationBuilder;\n+import org.infinispan.persistence.spi.PersistenceException;\n+import org.infinispan.test.fwk.TestCacheManagerFactory;\n+import org.infinispan.transaction.TransactionMode;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+\n+@Test(groups = {\"functional\", \"smoke\"}, testName = \"persistence.jdbc.stringbased.JdbcStringBasedStoreTxFunctionalTest\")\n+public class JdbcStringBasedStoreTxFunctionalTest extends JdbcStringBasedStoreFunctionalTest {\n+   private boolean transactionalConfig;\n+   private boolean sharedConfig;\n+\n+   JdbcStringBasedStoreTxFunctionalTest transactionalConfig(boolean transactionalConfig) {\n+      this.transactionalConfig = transactionalConfig;\n+      return this;\n+   }\n+\n+   JdbcStringBasedStoreTxFunctionalTest sharedConfig(boolean sharedConfig) {\n+      this.sharedConfig = sharedConfig;\n+      return this;\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getDefaultCacheConfiguration() {\n+      ConfigurationBuilder configurationBuilder = super.getDefaultCacheConfiguration();\n+      configurationBuilder.transaction().transactionMode(TransactionMode.TRANSACTIONAL);\n+      if (sharedConfig) {\n+         // Shared requires a clustered config, even though we have a single node\n+         configurationBuilder.clustering().cacheMode(CacheMode.REPL_SYNC);\n+      }\n+      return configurationBuilder;\n+   }\n+\n+   @Override\n+   protected void modifyJdbcConfiguration(JdbcStringBasedStoreConfigurationBuilder builder) {\n+      builder.transactional(transactionalConfig);\n+      builder.shared(sharedConfig);\n+   }\n+\n+   @Override\n+   protected EmbeddedCacheManager createCacheManager(boolean start, GlobalConfigurationBuilder global,\n+         ConfigurationBuilder cb) {\n+      // Make sure defaults are transactional as well for created configs\n+      if (transactionalConfig) {\n+         cb.transaction().transactionMode(TransactionMode.TRANSACTIONAL);\n+      }\n+      if (sharedConfig) {\n+         ConfigurationBuilderHolder holder = new ConfigurationBuilderHolder(Thread.currentThread().getContextClassLoader(), global);\n+         if (cb != null) {\n+            String defaultName = JdbcStringBasedStoreTxFunctionalTest.class.getName() + \"-default\";\n+            global.defaultCacheName(defaultName);\n+            holder.newConfigurationBuilder(defaultName).read(cb.build());\n+         }\n+         global.transport().defaultTransport();\n+         return TestCacheManagerFactory.createClusteredCacheManager(start, holder);\n+      } else {\n+         return super.createCacheManager(start, global, cb);\n+      }\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      return new Object[]{\n+            new JdbcStringBasedStoreTxFunctionalTest().transactionalConfig(true).sharedConfig(false),\n+            new JdbcStringBasedStoreTxFunctionalTest().transactionalConfig(false).sharedConfig(false),\n+            new JdbcStringBasedStoreTxFunctionalTest().transactionalConfig(true).sharedConfig(true),\n+            new JdbcStringBasedStoreTxFunctionalTest().transactionalConfig(false).sharedConfig(true),\n+      };\n+   }", "originalCommit": "46633a32fdeb4eb13647dc3703eb132a174079be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwOTYwMQ==", "url": "https://github.com/infinispan/infinispan/pull/8410#discussion_r433909601", "bodyText": "Okay.", "author": "wburns", "createdAt": "2020-06-02T14:13:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg3OTE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg4MDU4NQ==", "url": "https://github.com/infinispan/infinispan/pull/8410#discussion_r433880585", "bodyText": "We should probably assert on a configuration exception in this case.", "author": "ryanemerson", "createdAt": "2020-06-02T13:37:27Z", "path": "persistence/jdbc/src/test/java/org/infinispan/persistence/jdbc/stringbased/JdbcStringBasedStoreTxFunctionalTest.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package org.infinispan.persistence.jdbc.stringbased;\n+\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNull;\n+\n+import java.lang.reflect.Method;\n+\n+import javax.transaction.NotSupportedException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.persistence.jdbc.configuration.JdbcStringBasedStoreConfigurationBuilder;\n+import org.infinispan.persistence.spi.PersistenceException;\n+import org.infinispan.test.fwk.TestCacheManagerFactory;\n+import org.infinispan.transaction.TransactionMode;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+\n+@Test(groups = {\"functional\", \"smoke\"}, testName = \"persistence.jdbc.stringbased.JdbcStringBasedStoreTxFunctionalTest\")\n+public class JdbcStringBasedStoreTxFunctionalTest extends JdbcStringBasedStoreFunctionalTest {\n+   private boolean transactionalConfig;\n+   private boolean sharedConfig;\n+\n+   JdbcStringBasedStoreTxFunctionalTest transactionalConfig(boolean transactionalConfig) {\n+      this.transactionalConfig = transactionalConfig;\n+      return this;\n+   }\n+\n+   JdbcStringBasedStoreTxFunctionalTest sharedConfig(boolean sharedConfig) {\n+      this.sharedConfig = sharedConfig;\n+      return this;\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getDefaultCacheConfiguration() {\n+      ConfigurationBuilder configurationBuilder = super.getDefaultCacheConfiguration();\n+      configurationBuilder.transaction().transactionMode(TransactionMode.TRANSACTIONAL);\n+      if (sharedConfig) {\n+         // Shared requires a clustered config, even though we have a single node\n+         configurationBuilder.clustering().cacheMode(CacheMode.REPL_SYNC);\n+      }\n+      return configurationBuilder;\n+   }\n+\n+   @Override\n+   protected void modifyJdbcConfiguration(JdbcStringBasedStoreConfigurationBuilder builder) {\n+      builder.transactional(transactionalConfig);\n+      builder.shared(sharedConfig);\n+   }\n+\n+   @Override\n+   protected EmbeddedCacheManager createCacheManager(boolean start, GlobalConfigurationBuilder global,\n+         ConfigurationBuilder cb) {\n+      // Make sure defaults are transactional as well for created configs\n+      if (transactionalConfig) {\n+         cb.transaction().transactionMode(TransactionMode.TRANSACTIONAL);\n+      }\n+      if (sharedConfig) {\n+         ConfigurationBuilderHolder holder = new ConfigurationBuilderHolder(Thread.currentThread().getContextClassLoader(), global);\n+         if (cb != null) {\n+            String defaultName = JdbcStringBasedStoreTxFunctionalTest.class.getName() + \"-default\";\n+            global.defaultCacheName(defaultName);\n+            holder.newConfigurationBuilder(defaultName).read(cb.build());\n+         }\n+         global.transport().defaultTransport();\n+         return TestCacheManagerFactory.createClusteredCacheManager(start, holder);\n+      } else {\n+         return super.createCacheManager(start, global, cb);\n+      }\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      return new Object[]{\n+            new JdbcStringBasedStoreTxFunctionalTest().transactionalConfig(true).sharedConfig(false),\n+            new JdbcStringBasedStoreTxFunctionalTest().transactionalConfig(false).sharedConfig(false),\n+            new JdbcStringBasedStoreTxFunctionalTest().transactionalConfig(true).sharedConfig(true),\n+            new JdbcStringBasedStoreTxFunctionalTest().transactionalConfig(false).sharedConfig(true),\n+      };\n+   }\n+\n+   @Override\n+   protected String parameters() {\n+      return \" [transactionalConfig=\" + transactionalConfig + \", sharedConfig=\" + sharedConfig + \"]\";\n+   }\n+\n+   @Override\n+   public void testRemoveCacheWithPassivation() {\n+      // Shared and purgeOnStartup don't mix\n+      // Transactional and passivation don't mix\n+      if (!sharedConfig && !transactionalConfig) {", "originalCommit": "46633a32fdeb4eb13647dc3703eb132a174079be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxNDQwNw==", "url": "https://github.com/infinispan/infinispan/pull/8410#discussion_r433914407", "bodyText": "This is the wrong place to do that imo, but I can add it here. The only reason this was needed is because the super class does some funky tests that aren't the best fit for this.", "author": "wburns", "createdAt": "2020-06-02T14:19:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg4MDU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg4MDYyNg==", "url": "https://github.com/infinispan/infinispan/pull/8410#discussion_r433880626", "bodyText": "We should probably assert on a configuration exception in this case.", "author": "ryanemerson", "createdAt": "2020-06-02T13:37:30Z", "path": "persistence/jdbc/src/test/java/org/infinispan/persistence/jdbc/stringbased/JdbcStringBasedStoreTxFunctionalTest.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package org.infinispan.persistence.jdbc.stringbased;\n+\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNull;\n+\n+import java.lang.reflect.Method;\n+\n+import javax.transaction.NotSupportedException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.persistence.jdbc.configuration.JdbcStringBasedStoreConfigurationBuilder;\n+import org.infinispan.persistence.spi.PersistenceException;\n+import org.infinispan.test.fwk.TestCacheManagerFactory;\n+import org.infinispan.transaction.TransactionMode;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+\n+@Test(groups = {\"functional\", \"smoke\"}, testName = \"persistence.jdbc.stringbased.JdbcStringBasedStoreTxFunctionalTest\")\n+public class JdbcStringBasedStoreTxFunctionalTest extends JdbcStringBasedStoreFunctionalTest {\n+   private boolean transactionalConfig;\n+   private boolean sharedConfig;\n+\n+   JdbcStringBasedStoreTxFunctionalTest transactionalConfig(boolean transactionalConfig) {\n+      this.transactionalConfig = transactionalConfig;\n+      return this;\n+   }\n+\n+   JdbcStringBasedStoreTxFunctionalTest sharedConfig(boolean sharedConfig) {\n+      this.sharedConfig = sharedConfig;\n+      return this;\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getDefaultCacheConfiguration() {\n+      ConfigurationBuilder configurationBuilder = super.getDefaultCacheConfiguration();\n+      configurationBuilder.transaction().transactionMode(TransactionMode.TRANSACTIONAL);\n+      if (sharedConfig) {\n+         // Shared requires a clustered config, even though we have a single node\n+         configurationBuilder.clustering().cacheMode(CacheMode.REPL_SYNC);\n+      }\n+      return configurationBuilder;\n+   }\n+\n+   @Override\n+   protected void modifyJdbcConfiguration(JdbcStringBasedStoreConfigurationBuilder builder) {\n+      builder.transactional(transactionalConfig);\n+      builder.shared(sharedConfig);\n+   }\n+\n+   @Override\n+   protected EmbeddedCacheManager createCacheManager(boolean start, GlobalConfigurationBuilder global,\n+         ConfigurationBuilder cb) {\n+      // Make sure defaults are transactional as well for created configs\n+      if (transactionalConfig) {\n+         cb.transaction().transactionMode(TransactionMode.TRANSACTIONAL);\n+      }\n+      if (sharedConfig) {\n+         ConfigurationBuilderHolder holder = new ConfigurationBuilderHolder(Thread.currentThread().getContextClassLoader(), global);\n+         if (cb != null) {\n+            String defaultName = JdbcStringBasedStoreTxFunctionalTest.class.getName() + \"-default\";\n+            global.defaultCacheName(defaultName);\n+            holder.newConfigurationBuilder(defaultName).read(cb.build());\n+         }\n+         global.transport().defaultTransport();\n+         return TestCacheManagerFactory.createClusteredCacheManager(start, holder);\n+      } else {\n+         return super.createCacheManager(start, global, cb);\n+      }\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      return new Object[]{\n+            new JdbcStringBasedStoreTxFunctionalTest().transactionalConfig(true).sharedConfig(false),\n+            new JdbcStringBasedStoreTxFunctionalTest().transactionalConfig(false).sharedConfig(false),\n+            new JdbcStringBasedStoreTxFunctionalTest().transactionalConfig(true).sharedConfig(true),\n+            new JdbcStringBasedStoreTxFunctionalTest().transactionalConfig(false).sharedConfig(true),\n+      };\n+   }\n+\n+   @Override\n+   protected String parameters() {\n+      return \" [transactionalConfig=\" + transactionalConfig + \", sharedConfig=\" + sharedConfig + \"]\";\n+   }\n+\n+   @Override\n+   public void testRemoveCacheWithPassivation() {\n+      // Shared and purgeOnStartup don't mix\n+      // Transactional and passivation don't mix\n+      if (!sharedConfig && !transactionalConfig) {\n+         super.testRemoveCacheWithPassivation();\n+      }\n+   }\n+\n+   @Override\n+   public void testStoreByteArrays(Method m) throws PersistenceException {\n+      // Shared and purgeOnStartup don't mix\n+      // Transactional and passivation don't mix\n+      if (!sharedConfig && !transactionalConfig) {\n+         super.testStoreByteArrays(m);\n+      }\n+   }", "originalCommit": "46633a32fdeb4eb13647dc3703eb132a174079be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxMTQ1Mg==", "url": "https://github.com/infinispan/infinispan/pull/8410#discussion_r433911452", "bodyText": "It is the same as the other test. I don't think it is necessary to do it twice.", "author": "wburns", "createdAt": "2020-06-02T14:15:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg4MDYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg4MTY1MQ==", "url": "https://github.com/infinispan/infinispan/pull/8410#discussion_r433881651", "bodyText": "Shouldn't we also check that \"rollback-test\" key is not present in the store after rollback when the store is transactional?", "author": "ryanemerson", "createdAt": "2020-06-02T13:38:43Z", "path": "persistence/jdbc/src/test/java/org/infinispan/persistence/jdbc/stringbased/JdbcStringBasedStoreTxFunctionalTest.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package org.infinispan.persistence.jdbc.stringbased;\n+\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNull;\n+\n+import java.lang.reflect.Method;\n+\n+import javax.transaction.NotSupportedException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.persistence.jdbc.configuration.JdbcStringBasedStoreConfigurationBuilder;\n+import org.infinispan.persistence.spi.PersistenceException;\n+import org.infinispan.test.fwk.TestCacheManagerFactory;\n+import org.infinispan.transaction.TransactionMode;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+\n+@Test(groups = {\"functional\", \"smoke\"}, testName = \"persistence.jdbc.stringbased.JdbcStringBasedStoreTxFunctionalTest\")\n+public class JdbcStringBasedStoreTxFunctionalTest extends JdbcStringBasedStoreFunctionalTest {\n+   private boolean transactionalConfig;\n+   private boolean sharedConfig;\n+\n+   JdbcStringBasedStoreTxFunctionalTest transactionalConfig(boolean transactionalConfig) {\n+      this.transactionalConfig = transactionalConfig;\n+      return this;\n+   }\n+\n+   JdbcStringBasedStoreTxFunctionalTest sharedConfig(boolean sharedConfig) {\n+      this.sharedConfig = sharedConfig;\n+      return this;\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getDefaultCacheConfiguration() {\n+      ConfigurationBuilder configurationBuilder = super.getDefaultCacheConfiguration();\n+      configurationBuilder.transaction().transactionMode(TransactionMode.TRANSACTIONAL);\n+      if (sharedConfig) {\n+         // Shared requires a clustered config, even though we have a single node\n+         configurationBuilder.clustering().cacheMode(CacheMode.REPL_SYNC);\n+      }\n+      return configurationBuilder;\n+   }\n+\n+   @Override\n+   protected void modifyJdbcConfiguration(JdbcStringBasedStoreConfigurationBuilder builder) {\n+      builder.transactional(transactionalConfig);\n+      builder.shared(sharedConfig);\n+   }\n+\n+   @Override\n+   protected EmbeddedCacheManager createCacheManager(boolean start, GlobalConfigurationBuilder global,\n+         ConfigurationBuilder cb) {\n+      // Make sure defaults are transactional as well for created configs\n+      if (transactionalConfig) {\n+         cb.transaction().transactionMode(TransactionMode.TRANSACTIONAL);\n+      }\n+      if (sharedConfig) {\n+         ConfigurationBuilderHolder holder = new ConfigurationBuilderHolder(Thread.currentThread().getContextClassLoader(), global);\n+         if (cb != null) {\n+            String defaultName = JdbcStringBasedStoreTxFunctionalTest.class.getName() + \"-default\";\n+            global.defaultCacheName(defaultName);\n+            holder.newConfigurationBuilder(defaultName).read(cb.build());\n+         }\n+         global.transport().defaultTransport();\n+         return TestCacheManagerFactory.createClusteredCacheManager(start, holder);\n+      } else {\n+         return super.createCacheManager(start, global, cb);\n+      }\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      return new Object[]{\n+            new JdbcStringBasedStoreTxFunctionalTest().transactionalConfig(true).sharedConfig(false),\n+            new JdbcStringBasedStoreTxFunctionalTest().transactionalConfig(false).sharedConfig(false),\n+            new JdbcStringBasedStoreTxFunctionalTest().transactionalConfig(true).sharedConfig(true),\n+            new JdbcStringBasedStoreTxFunctionalTest().transactionalConfig(false).sharedConfig(true),\n+      };\n+   }\n+\n+   @Override\n+   protected String parameters() {\n+      return \" [transactionalConfig=\" + transactionalConfig + \", sharedConfig=\" + sharedConfig + \"]\";\n+   }\n+\n+   @Override\n+   public void testRemoveCacheWithPassivation() {\n+      // Shared and purgeOnStartup don't mix\n+      // Transactional and passivation don't mix\n+      if (!sharedConfig && !transactionalConfig) {\n+         super.testRemoveCacheWithPassivation();\n+      }\n+   }\n+\n+   @Override\n+   public void testStoreByteArrays(Method m) throws PersistenceException {\n+      // Shared and purgeOnStartup don't mix\n+      // Transactional and passivation don't mix\n+      if (!sharedConfig && !transactionalConfig) {\n+         super.testStoreByteArrays(m);\n+      }\n+   }\n+\n+   public void testRollback() throws SystemException, NotSupportedException {\n+      String cacheName = \"testRollback\";\n+      ConfigurationBuilder cb = getDefaultCacheConfiguration();\n+      createCacheStoreConfig(cb.persistence(), false);\n+      cacheManager.defineConfiguration(cacheName, cb.build());\n+\n+      Cache<String, Object> cache = cacheManager.getCache(cacheName);\n+\n+      String key = \"rollback-test\";\n+      assertNull(cache.get(key));\n+\n+      TransactionManager manager = cache.getAdvancedCache().getTransactionManager();\n+\n+      String value = \"the-value\";\n+      manager.begin();\n+      cache.put(key, value);\n+      assertEquals(value, cache.get(key));\n+      manager.rollback();\n+\n+      assertNull(cache.get(key));", "originalCommit": "46633a32fdeb4eb13647dc3703eb132a174079be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxMjk0NA==", "url": "https://github.com/infinispan/infinispan/pull/8410#discussion_r433912944", "bodyText": "I personally don't think it is worth it. The cache.get should be doing that already. None of the rest of the tests in this class hierarchy go directly at the store either.", "author": "wburns", "createdAt": "2020-06-02T14:17:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg4MTY1MQ=="}], "type": "inlineReview"}, {"oid": "3187ccdce1b43e98557e3aa78fd074b504362cac", "url": "https://github.com/infinispan/infinispan/commit/3187ccdce1b43e98557e3aa78fd074b504362cac", "message": "ISPN-11937 JDBCStringBasedStore needs test around a rollback occurring", "committedDate": "2020-06-02T14:55:10Z", "type": "commit"}, {"oid": "3187ccdce1b43e98557e3aa78fd074b504362cac", "url": "https://github.com/infinispan/infinispan/commit/3187ccdce1b43e98557e3aa78fd074b504362cac", "message": "ISPN-11937 JDBCStringBasedStore needs test around a rollback occurring", "committedDate": "2020-06-02T14:55:10Z", "type": "forcePushed"}]}