{"pr_number": 8500, "pr_title": "ISPN-12044 CLI performance tool", "pr_createdAt": "2020-06-24T13:59:10Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8500", "timeline": [{"oid": "e46b1c87b689975e121f66f1f43a407f6001149c", "url": "https://github.com/infinispan/infinispan/commit/e46b1c87b689975e121f66f1f43a407f6001149c", "message": "ISPN-12044 CLI performance tool", "committedDate": "2020-09-03T12:58:48Z", "type": "forcePushed"}, {"oid": "6a46e750bd29ddd3a0558ae594326100815967db", "url": "https://github.com/infinispan/infinispan/commit/6a46e750bd29ddd3a0558ae594326100815967db", "message": "ISPN-12044 CLI performance tool", "committedDate": "2020-09-28T10:04:39Z", "type": "forcePushed"}, {"oid": "dd179b264c26629ff272732ccbaacddd2b426788", "url": "https://github.com/infinispan/infinispan/commit/dd179b264c26629ff272732ccbaacddd2b426788", "message": "ISPN-12044 CLI performance tool", "committedDate": "2020-09-28T11:33:50Z", "type": "forcePushed"}, {"oid": "c0ccb1825f72adc57e9f7cf0f85c79b3a781b0c9", "url": "https://github.com/infinispan/infinispan/commit/c0ccb1825f72adc57e9f7cf0f85c79b3a781b0c9", "message": "ISPN-12044 CLI performance tool", "committedDate": "2020-09-30T12:07:51Z", "type": "forcePushed"}, {"oid": "24ecbade987871fc34d8cc70a8d6725e74807b86", "url": "https://github.com/infinispan/infinispan/commit/24ecbade987871fc34d8cc70a8d6725e74807b86", "message": "ISPN-12044 CLI performance tool", "committedDate": "2020-09-30T13:53:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwNzkwMQ==", "url": "https://github.com/infinispan/infinispan/pull/8500#discussion_r498307901", "bodyText": "a bit hard to read, we can avoid the timeout.convertTo to be called twice", "author": "karesti", "createdAt": "2020-10-01T14:53:46Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/benchmark/BenchmarkOutputFormat.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package org.infinispan.cli.benchmark;\n+\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.infra.BenchmarkParams;\n+import org.openjdk.jmh.infra.IterationParams;\n+import org.openjdk.jmh.results.BenchmarkResult;\n+import org.openjdk.jmh.results.IterationResult;\n+import org.openjdk.jmh.results.Result;\n+import org.openjdk.jmh.results.RunResult;\n+import org.openjdk.jmh.results.format.ResultFormatFactory;\n+import org.openjdk.jmh.results.format.ResultFormatType;\n+import org.openjdk.jmh.runner.IterationType;\n+import org.openjdk.jmh.runner.format.OutputFormat;\n+import org.openjdk.jmh.runner.options.TimeValue;\n+import org.openjdk.jmh.runner.options.VerboseMode;\n+import org.openjdk.jmh.util.Utils;\n+\n+public class BenchmarkOutputFormat implements OutputFormat {\n+\n+   final VerboseMode verbose;\n+   final PrintStream out;\n+\n+   public BenchmarkOutputFormat(PrintStream out, VerboseMode verbose) {\n+      this.out = out;\n+      this.verbose = verbose;\n+   }\n+\n+   @Override\n+   public void print(String s) {\n+      out.print(s);\n+   }\n+\n+   @Override\n+   public void println(String s) {\n+      out.println(s);\n+   }\n+\n+   @Override\n+   public void flush() {\n+      out.flush();\n+   }\n+\n+   @Override\n+   public void verbosePrintln(String s) {\n+      if (verbose == VerboseMode.EXTRA) {\n+         out.println(s);\n+      }\n+   }\n+\n+   @Override\n+   public void write(int b) {\n+      out.write(b);\n+   }\n+\n+   @Override\n+   public void write(byte[] b) {\n+      out.write(b, 0, b.length);\n+   }\n+\n+   @Override\n+   public void close() {\n+   }\n+\n+   @Override\n+   public void startBenchmark(BenchmarkParams params) {\n+      IterationParams warmup = params.getWarmup();\n+      if (warmup.getCount() > 0) {\n+         out.println(\"# Warmup: \" + warmup.getCount() + \" iterations, \" +\n+               warmup.getTime() + \" each\" +\n+               (warmup.getBatchSize() <= 1 ? \"\" : \", \" + warmup.getBatchSize() + \" calls per op\"));\n+      } else {\n+         out.println(\"# Warmup: <none>\");\n+      }\n+\n+      IterationParams measurement = params.getMeasurement();\n+      if (measurement.getCount() > 0) {\n+         out.println(\"# Measurement: \" + measurement.getCount() + \" iterations, \" +\n+               measurement.getTime() + \" each\" +\n+               (measurement.getBatchSize() <= 1 ? \"\" : \", \" + measurement.getBatchSize() + \" calls per op\"));\n+      } else {\n+         out.println(\"# Measurement: <none>\");\n+      }\n+\n+      TimeValue timeout = params.getTimeout();\n+      boolean timeoutWarning = (timeout.convertTo(TimeUnit.NANOSECONDS) <= measurement.getTime().convertTo(TimeUnit.NANOSECONDS)) ||", "originalCommit": "24ecbade987871fc34d8cc70a8d6725e74807b86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI4MzA2NA==", "url": "https://github.com/infinispan/infinispan/pull/8500#discussion_r500283064", "bodyText": "@karesti most of the code in this class is copied from JMH and I'd rather not mess around with it too much in case we need to resynchronize it in the future. Unfortunately subclassing was not an option.", "author": "tristantarrant", "createdAt": "2020-10-06T13:36:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwNzkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwOTQ1OQ==", "url": "https://github.com/infinispan/infinispan/pull/8500#discussion_r498309459", "bodyText": "too much spaces?", "author": "karesti", "createdAt": "2020-10-01T14:55:43Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/benchmark/BenchmarkOutputFormat.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package org.infinispan.cli.benchmark;\n+\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.infra.BenchmarkParams;\n+import org.openjdk.jmh.infra.IterationParams;\n+import org.openjdk.jmh.results.BenchmarkResult;\n+import org.openjdk.jmh.results.IterationResult;\n+import org.openjdk.jmh.results.Result;\n+import org.openjdk.jmh.results.RunResult;\n+import org.openjdk.jmh.results.format.ResultFormatFactory;\n+import org.openjdk.jmh.results.format.ResultFormatType;\n+import org.openjdk.jmh.runner.IterationType;\n+import org.openjdk.jmh.runner.format.OutputFormat;\n+import org.openjdk.jmh.runner.options.TimeValue;\n+import org.openjdk.jmh.runner.options.VerboseMode;\n+import org.openjdk.jmh.util.Utils;\n+\n+public class BenchmarkOutputFormat implements OutputFormat {\n+\n+   final VerboseMode verbose;\n+   final PrintStream out;\n+\n+   public BenchmarkOutputFormat(PrintStream out, VerboseMode verbose) {\n+      this.out = out;\n+      this.verbose = verbose;\n+   }\n+\n+   @Override\n+   public void print(String s) {\n+      out.print(s);\n+   }\n+\n+   @Override\n+   public void println(String s) {\n+      out.println(s);\n+   }\n+\n+   @Override\n+   public void flush() {\n+      out.flush();\n+   }\n+\n+   @Override\n+   public void verbosePrintln(String s) {\n+      if (verbose == VerboseMode.EXTRA) {\n+         out.println(s);\n+      }\n+   }\n+\n+   @Override\n+   public void write(int b) {\n+      out.write(b);\n+   }\n+\n+   @Override\n+   public void write(byte[] b) {\n+      out.write(b, 0, b.length);\n+   }\n+\n+   @Override\n+   public void close() {\n+   }\n+\n+   @Override\n+   public void startBenchmark(BenchmarkParams params) {\n+      IterationParams warmup = params.getWarmup();\n+      if (warmup.getCount() > 0) {\n+         out.println(\"# Warmup: \" + warmup.getCount() + \" iterations, \" +\n+               warmup.getTime() + \" each\" +\n+               (warmup.getBatchSize() <= 1 ? \"\" : \", \" + warmup.getBatchSize() + \" calls per op\"));\n+      } else {\n+         out.println(\"# Warmup: <none>\");\n+      }\n+\n+      IterationParams measurement = params.getMeasurement();\n+      if (measurement.getCount() > 0) {\n+         out.println(\"# Measurement: \" + measurement.getCount() + \" iterations, \" +\n+               measurement.getTime() + \" each\" +\n+               (measurement.getBatchSize() <= 1 ? \"\" : \", \" + measurement.getBatchSize() + \" calls per op\"));\n+      } else {\n+         out.println(\"# Measurement: <none>\");\n+      }\n+\n+      TimeValue timeout = params.getTimeout();\n+      boolean timeoutWarning = (timeout.convertTo(TimeUnit.NANOSECONDS) <= measurement.getTime().convertTo(TimeUnit.NANOSECONDS)) ||\n+            (timeout.convertTo(TimeUnit.NANOSECONDS) <= warmup.getTime().convertTo(TimeUnit.NANOSECONDS));\n+      out.println(\"# Timeout: \" + timeout + \" per iteration\" + (timeoutWarning ? \", ***WARNING: The timeout might be too low!***\" : \"\"));\n+\n+      out.print(\"# Threads: \" + params.getThreads() + \" \" + getThreadsString(params.getThreads()));\n+\n+      if (!params.getThreadGroupLabels().isEmpty()) {\n+         int[] tg = params.getThreadGroups();\n+\n+         List<String> labels = new ArrayList<>(params.getThreadGroupLabels());\n+         String[] ss = new String[tg.length];\n+         for (int cnt = 0; cnt < tg.length; cnt++) {\n+            ss[cnt] = tg[cnt] + \"x \\\"\" + labels.get(cnt) + \"\\\"\";\n+         }\n+\n+         int groupCount = params.getThreads() / Utils.sum(tg);\n+         out.print(\" (\" + groupCount + \" \" + getGroupsString(groupCount) + \"; \" + Utils.join(ss, \", \") + \" in each group)\");\n+      }\n+\n+      out.println(params.shouldSynchIterations() ?\n+            \", will synchronize iterations\" :\n+            (params.getMode() == Mode.SingleShotTime) ? \"\" : \", ***WARNING: Synchronize iterations are disabled!***\");\n+\n+\n+      out.println(\"# Benchmark mode: \" + params.getMode().longLabel());\n+      out.println(\"# Benchmark: \" + params.getBenchmark());\n+      if (!params.getParamsKeys().isEmpty()) {\n+         String s = \"\";\n+         boolean isFirst = true;\n+         for (String k : params.getParamsKeys()) {\n+            if (isFirst) {\n+               isFirst = false;\n+            } else {\n+               s += \", \";\n+            }\n+            s += k + \" = \" + params.getParam(k);\n+         }\n+         out.println(\"# Parameters: (\" + s + \")\");\n+      }\n+   }\n+\n+   @Override\n+   public void iteration(BenchmarkParams benchmarkParams, IterationParams params, int iteration) {\n+      switch (params.getType()) {\n+         case WARMUP:\n+            out.print(String.format(\"Warmup    %3d: \", iteration));", "originalCommit": "24ecbade987871fc34d8cc70a8d6725e74807b86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwOTczMQ==", "url": "https://github.com/infinispan/infinispan/pull/8500#discussion_r498309731", "bodyText": "why is this 'iteration' instead of 'Measurement' ?", "author": "karesti", "createdAt": "2020-10-01T14:56:06Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/benchmark/BenchmarkOutputFormat.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package org.infinispan.cli.benchmark;\n+\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.infra.BenchmarkParams;\n+import org.openjdk.jmh.infra.IterationParams;\n+import org.openjdk.jmh.results.BenchmarkResult;\n+import org.openjdk.jmh.results.IterationResult;\n+import org.openjdk.jmh.results.Result;\n+import org.openjdk.jmh.results.RunResult;\n+import org.openjdk.jmh.results.format.ResultFormatFactory;\n+import org.openjdk.jmh.results.format.ResultFormatType;\n+import org.openjdk.jmh.runner.IterationType;\n+import org.openjdk.jmh.runner.format.OutputFormat;\n+import org.openjdk.jmh.runner.options.TimeValue;\n+import org.openjdk.jmh.runner.options.VerboseMode;\n+import org.openjdk.jmh.util.Utils;\n+\n+public class BenchmarkOutputFormat implements OutputFormat {\n+\n+   final VerboseMode verbose;\n+   final PrintStream out;\n+\n+   public BenchmarkOutputFormat(PrintStream out, VerboseMode verbose) {\n+      this.out = out;\n+      this.verbose = verbose;\n+   }\n+\n+   @Override\n+   public void print(String s) {\n+      out.print(s);\n+   }\n+\n+   @Override\n+   public void println(String s) {\n+      out.println(s);\n+   }\n+\n+   @Override\n+   public void flush() {\n+      out.flush();\n+   }\n+\n+   @Override\n+   public void verbosePrintln(String s) {\n+      if (verbose == VerboseMode.EXTRA) {\n+         out.println(s);\n+      }\n+   }\n+\n+   @Override\n+   public void write(int b) {\n+      out.write(b);\n+   }\n+\n+   @Override\n+   public void write(byte[] b) {\n+      out.write(b, 0, b.length);\n+   }\n+\n+   @Override\n+   public void close() {\n+   }\n+\n+   @Override\n+   public void startBenchmark(BenchmarkParams params) {\n+      IterationParams warmup = params.getWarmup();\n+      if (warmup.getCount() > 0) {\n+         out.println(\"# Warmup: \" + warmup.getCount() + \" iterations, \" +\n+               warmup.getTime() + \" each\" +\n+               (warmup.getBatchSize() <= 1 ? \"\" : \", \" + warmup.getBatchSize() + \" calls per op\"));\n+      } else {\n+         out.println(\"# Warmup: <none>\");\n+      }\n+\n+      IterationParams measurement = params.getMeasurement();\n+      if (measurement.getCount() > 0) {\n+         out.println(\"# Measurement: \" + measurement.getCount() + \" iterations, \" +\n+               measurement.getTime() + \" each\" +\n+               (measurement.getBatchSize() <= 1 ? \"\" : \", \" + measurement.getBatchSize() + \" calls per op\"));\n+      } else {\n+         out.println(\"# Measurement: <none>\");\n+      }\n+\n+      TimeValue timeout = params.getTimeout();\n+      boolean timeoutWarning = (timeout.convertTo(TimeUnit.NANOSECONDS) <= measurement.getTime().convertTo(TimeUnit.NANOSECONDS)) ||\n+            (timeout.convertTo(TimeUnit.NANOSECONDS) <= warmup.getTime().convertTo(TimeUnit.NANOSECONDS));\n+      out.println(\"# Timeout: \" + timeout + \" per iteration\" + (timeoutWarning ? \", ***WARNING: The timeout might be too low!***\" : \"\"));\n+\n+      out.print(\"# Threads: \" + params.getThreads() + \" \" + getThreadsString(params.getThreads()));\n+\n+      if (!params.getThreadGroupLabels().isEmpty()) {\n+         int[] tg = params.getThreadGroups();\n+\n+         List<String> labels = new ArrayList<>(params.getThreadGroupLabels());\n+         String[] ss = new String[tg.length];\n+         for (int cnt = 0; cnt < tg.length; cnt++) {\n+            ss[cnt] = tg[cnt] + \"x \\\"\" + labels.get(cnt) + \"\\\"\";\n+         }\n+\n+         int groupCount = params.getThreads() / Utils.sum(tg);\n+         out.print(\" (\" + groupCount + \" \" + getGroupsString(groupCount) + \"; \" + Utils.join(ss, \", \") + \" in each group)\");\n+      }\n+\n+      out.println(params.shouldSynchIterations() ?\n+            \", will synchronize iterations\" :\n+            (params.getMode() == Mode.SingleShotTime) ? \"\" : \", ***WARNING: Synchronize iterations are disabled!***\");\n+\n+\n+      out.println(\"# Benchmark mode: \" + params.getMode().longLabel());\n+      out.println(\"# Benchmark: \" + params.getBenchmark());\n+      if (!params.getParamsKeys().isEmpty()) {\n+         String s = \"\";\n+         boolean isFirst = true;\n+         for (String k : params.getParamsKeys()) {\n+            if (isFirst) {\n+               isFirst = false;\n+            } else {\n+               s += \", \";\n+            }\n+            s += k + \" = \" + params.getParam(k);\n+         }\n+         out.println(\"# Parameters: (\" + s + \")\");\n+      }\n+   }\n+\n+   @Override\n+   public void iteration(BenchmarkParams benchmarkParams, IterationParams params, int iteration) {\n+      switch (params.getType()) {\n+         case WARMUP:\n+            out.print(String.format(\"Warmup    %3d: \", iteration));\n+            break;\n+         case MEASUREMENT:\n+            out.print(String.format(\"Iteration %3d: \", iteration));", "originalCommit": "24ecbade987871fc34d8cc70a8d6725e74807b86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxMDkyOA==", "url": "https://github.com/infinispan/infinispan/pull/8500#discussion_r498310928", "bodyText": "there are extra {", "author": "karesti", "createdAt": "2020-10-01T14:57:36Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/benchmark/BenchmarkOutputFormat.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package org.infinispan.cli.benchmark;\n+\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.infra.BenchmarkParams;\n+import org.openjdk.jmh.infra.IterationParams;\n+import org.openjdk.jmh.results.BenchmarkResult;\n+import org.openjdk.jmh.results.IterationResult;\n+import org.openjdk.jmh.results.Result;\n+import org.openjdk.jmh.results.RunResult;\n+import org.openjdk.jmh.results.format.ResultFormatFactory;\n+import org.openjdk.jmh.results.format.ResultFormatType;\n+import org.openjdk.jmh.runner.IterationType;\n+import org.openjdk.jmh.runner.format.OutputFormat;\n+import org.openjdk.jmh.runner.options.TimeValue;\n+import org.openjdk.jmh.runner.options.VerboseMode;\n+import org.openjdk.jmh.util.Utils;\n+\n+public class BenchmarkOutputFormat implements OutputFormat {\n+\n+   final VerboseMode verbose;\n+   final PrintStream out;\n+\n+   public BenchmarkOutputFormat(PrintStream out, VerboseMode verbose) {\n+      this.out = out;\n+      this.verbose = verbose;\n+   }\n+\n+   @Override\n+   public void print(String s) {\n+      out.print(s);\n+   }\n+\n+   @Override\n+   public void println(String s) {\n+      out.println(s);\n+   }\n+\n+   @Override\n+   public void flush() {\n+      out.flush();\n+   }\n+\n+   @Override\n+   public void verbosePrintln(String s) {\n+      if (verbose == VerboseMode.EXTRA) {\n+         out.println(s);\n+      }\n+   }\n+\n+   @Override\n+   public void write(int b) {\n+      out.write(b);\n+   }\n+\n+   @Override\n+   public void write(byte[] b) {\n+      out.write(b, 0, b.length);\n+   }\n+\n+   @Override\n+   public void close() {\n+   }\n+\n+   @Override\n+   public void startBenchmark(BenchmarkParams params) {\n+      IterationParams warmup = params.getWarmup();\n+      if (warmup.getCount() > 0) {\n+         out.println(\"# Warmup: \" + warmup.getCount() + \" iterations, \" +\n+               warmup.getTime() + \" each\" +\n+               (warmup.getBatchSize() <= 1 ? \"\" : \", \" + warmup.getBatchSize() + \" calls per op\"));\n+      } else {\n+         out.println(\"# Warmup: <none>\");\n+      }\n+\n+      IterationParams measurement = params.getMeasurement();\n+      if (measurement.getCount() > 0) {\n+         out.println(\"# Measurement: \" + measurement.getCount() + \" iterations, \" +\n+               measurement.getTime() + \" each\" +\n+               (measurement.getBatchSize() <= 1 ? \"\" : \", \" + measurement.getBatchSize() + \" calls per op\"));\n+      } else {\n+         out.println(\"# Measurement: <none>\");\n+      }\n+\n+      TimeValue timeout = params.getTimeout();\n+      boolean timeoutWarning = (timeout.convertTo(TimeUnit.NANOSECONDS) <= measurement.getTime().convertTo(TimeUnit.NANOSECONDS)) ||\n+            (timeout.convertTo(TimeUnit.NANOSECONDS) <= warmup.getTime().convertTo(TimeUnit.NANOSECONDS));\n+      out.println(\"# Timeout: \" + timeout + \" per iteration\" + (timeoutWarning ? \", ***WARNING: The timeout might be too low!***\" : \"\"));\n+\n+      out.print(\"# Threads: \" + params.getThreads() + \" \" + getThreadsString(params.getThreads()));\n+\n+      if (!params.getThreadGroupLabels().isEmpty()) {\n+         int[] tg = params.getThreadGroups();\n+\n+         List<String> labels = new ArrayList<>(params.getThreadGroupLabels());\n+         String[] ss = new String[tg.length];\n+         for (int cnt = 0; cnt < tg.length; cnt++) {\n+            ss[cnt] = tg[cnt] + \"x \\\"\" + labels.get(cnt) + \"\\\"\";\n+         }\n+\n+         int groupCount = params.getThreads() / Utils.sum(tg);\n+         out.print(\" (\" + groupCount + \" \" + getGroupsString(groupCount) + \"; \" + Utils.join(ss, \", \") + \" in each group)\");\n+      }\n+\n+      out.println(params.shouldSynchIterations() ?\n+            \", will synchronize iterations\" :\n+            (params.getMode() == Mode.SingleShotTime) ? \"\" : \", ***WARNING: Synchronize iterations are disabled!***\");\n+\n+\n+      out.println(\"# Benchmark mode: \" + params.getMode().longLabel());\n+      out.println(\"# Benchmark: \" + params.getBenchmark());\n+      if (!params.getParamsKeys().isEmpty()) {\n+         String s = \"\";\n+         boolean isFirst = true;\n+         for (String k : params.getParamsKeys()) {\n+            if (isFirst) {\n+               isFirst = false;\n+            } else {\n+               s += \", \";\n+            }\n+            s += k + \" = \" + params.getParam(k);\n+         }\n+         out.println(\"# Parameters: (\" + s + \")\");\n+      }\n+   }\n+\n+   @Override\n+   public void iteration(BenchmarkParams benchmarkParams, IterationParams params, int iteration) {\n+      switch (params.getType()) {\n+         case WARMUP:\n+            out.print(String.format(\"Warmup    %3d: \", iteration));\n+            break;\n+         case MEASUREMENT:\n+            out.print(String.format(\"Iteration %3d: \", iteration));\n+            break;\n+         default:\n+            throw new IllegalStateException(\"Unknown iteration type: \" + params.getType());\n+      }\n+      out.flush();\n+   }\n+\n+   protected static String getThreadsString(int t) {\n+      if (t > 1) {\n+         return \"threads\";\n+      } else {\n+         return \"thread\";\n+      }\n+   }\n+\n+   protected static String getGroupsString(int g) {\n+      if (g > 1) {\n+         return \"groups\";\n+      } else {\n+         return \"group\";\n+      }\n+   }\n+\n+   @Override\n+   public void iterationResult(BenchmarkParams benchmParams, IterationParams params, int iteration, IterationResult data) {\n+      StringBuilder sb = new StringBuilder();\n+      sb.append(data.getPrimaryResult().toString());\n+\n+      if (params.getType() == IterationType.MEASUREMENT) {\n+         int prefixLen = String.format(\"Iteration %3d: \", iteration).length();\n+\n+         Map<String, Result> secondary = data.getSecondaryResults();\n+         if (!secondary.isEmpty()) {\n+            sb.append(\"\\n\");\n+\n+            int maxKeyLen = 0;\n+            for (Map.Entry<String, Result> res : secondary.entrySet()) {\n+               maxKeyLen = Math.max(maxKeyLen, res.getKey().length());\n+            }\n+\n+            for (Map.Entry<String, Result> res : secondary.entrySet()) {\n+               sb.append(String.format(\"%\" + prefixLen + \"s\", \"\"));\n+               sb.append(String.format(\"  %-\" + (maxKeyLen + 1) + \"s %s\", res.getKey() + \":\", res.getValue()));\n+               sb.append(\"\\n\");\n+            }\n+         }\n+      }\n+\n+      out.print(String.format(\"%s%n\", sb.toString()));\n+      out.flush();\n+   }\n+\n+   @Override\n+   public void endBenchmark(BenchmarkResult result) {\n+      out.println();\n+      if (result != null) {\n+         {", "originalCommit": "24ecbade987871fc34d8cc70a8d6725e74807b86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxNDEyMw==", "url": "https://github.com/infinispan/infinispan/pull/8500#discussion_r498314123", "bodyText": "cm variable name related to cacheManager but the RestClient returns a restClient. I would rename this to avoid confusion with the HotrodBenchmark", "author": "karesti", "createdAt": "2020-10-01T15:01:53Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/benchmark/HttpBenchmark.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.infinispan.cli.benchmark;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.infinispan.client.rest.RestCacheClient;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestEntity;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.RestURI;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+@State(Scope.Thread)\n+public class HttpBenchmark {\n+   private static final long BIG_DELAY_NANOS = TimeUnit.DAYS.toNanos(1);\n+   RestClient cm;\n+   RestCacheClient cache;\n+\n+   @Param(\"http://127.0.0.1\")\n+   public String uri;\n+\n+   @Param(\"benchmark\")\n+   public String cacheName;\n+\n+   @Param(\"\")\n+   public String cacheTemplate;\n+\n+   @Param(\"16\")\n+   public int keySize;\n+\n+   @Param(\"1000\")\n+   public int valueSize;\n+\n+   @Param(\"1000\")\n+   public int keySetSize;\n+\n+   RestEntity value;\n+   List<String> keySet;\n+   AtomicInteger nextIndex;\n+\n+   @Setup\n+   public void setup() {\n+      RestURI uri = RestURI.create(this.uri);\n+      RestClientConfigurationBuilder builder = uri.toConfigurationBuilder();\n+      cm = RestClient.forConfiguration(builder.build());", "originalCommit": "24ecbade987871fc34d8cc70a8d6725e74807b86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxNTE1Mw==", "url": "https://github.com/infinispan/infinispan/pull/8500#discussion_r498315153", "bodyText": "same here, it's not a cache but the restCacheClient", "author": "karesti", "createdAt": "2020-10-01T15:03:21Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/benchmark/HttpBenchmark.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.infinispan.cli.benchmark;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.infinispan.client.rest.RestCacheClient;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestEntity;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.RestURI;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+@State(Scope.Thread)\n+public class HttpBenchmark {\n+   private static final long BIG_DELAY_NANOS = TimeUnit.DAYS.toNanos(1);\n+   RestClient cm;\n+   RestCacheClient cache;\n+\n+   @Param(\"http://127.0.0.1\")\n+   public String uri;\n+\n+   @Param(\"benchmark\")\n+   public String cacheName;\n+\n+   @Param(\"\")\n+   public String cacheTemplate;\n+\n+   @Param(\"16\")\n+   public int keySize;\n+\n+   @Param(\"1000\")\n+   public int valueSize;\n+\n+   @Param(\"1000\")\n+   public int keySetSize;\n+\n+   RestEntity value;\n+   List<String> keySet;\n+   AtomicInteger nextIndex;\n+\n+   @Setup\n+   public void setup() {\n+      RestURI uri = RestURI.create(this.uri);\n+      RestClientConfigurationBuilder builder = uri.toConfigurationBuilder();\n+      cm = RestClient.forConfiguration(builder.build());\n+      cache = cm.cache(cacheName);\n+      if (uncheckedAwait(cache.exists()).getStatus() == 404) {", "originalCommit": "24ecbade987871fc34d8cc70a8d6725e74807b86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8d84604b3c95f4f478482cf36bc8d8938b54d03d", "url": "https://github.com/infinispan/infinispan/commit/8d84604b3c95f4f478482cf36bc8d8938b54d03d", "message": "ISPN-12044 CLI performance tool", "committedDate": "2020-10-06T13:11:38Z", "type": "forcePushed"}, {"oid": "f20908ea4ed03acd1dfcfccc73782a92c2cc7b6d", "url": "https://github.com/infinispan/infinispan/commit/f20908ea4ed03acd1dfcfccc73782a92c2cc7b6d", "message": "ISPN-12044 CLI performance tool", "committedDate": "2020-10-06T13:48:51Z", "type": "forcePushed"}, {"oid": "9113943070a3de1190f969db4b64fdd1983ba042", "url": "https://github.com/infinispan/infinispan/commit/9113943070a3de1190f969db4b64fdd1983ba042", "message": "ISPN-12051 REST URI configuration", "committedDate": "2020-10-12T07:20:33Z", "type": "commit"}, {"oid": "242fcf73fcac3bf5be1bd3702b10c566faff84cc", "url": "https://github.com/infinispan/infinispan/commit/242fcf73fcac3bf5be1bd3702b10c566faff84cc", "message": "ISPN-12044 CLI performance tool", "committedDate": "2020-10-12T07:20:43Z", "type": "forcePushed"}, {"oid": "d58203d0fe105e4eac07abf73745229a32b0bd30", "url": "https://github.com/infinispan/infinispan/commit/d58203d0fe105e4eac07abf73745229a32b0bd30", "message": "ISPN-12044 CLI performance tool", "committedDate": "2020-10-12T07:23:39Z", "type": "commit"}, {"oid": "d58203d0fe105e4eac07abf73745229a32b0bd30", "url": "https://github.com/infinispan/infinispan/commit/d58203d0fe105e4eac07abf73745229a32b0bd30", "message": "ISPN-12044 CLI performance tool", "committedDate": "2020-10-12T07:23:39Z", "type": "forcePushed"}]}