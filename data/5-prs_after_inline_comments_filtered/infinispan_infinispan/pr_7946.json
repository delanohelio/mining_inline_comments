{"pr_number": 7946, "pr_title": "ISPN-11341 Client requests go to wrong server with binary storage", "pr_createdAt": "2020-02-25T08:02:50Z", "pr_url": "https://github.com/infinispan/infinispan/pull/7946", "timeline": [{"oid": "dcc248aa4d73439700045e781a8241cc7250ab16", "url": "https://github.com/infinispan/infinispan/commit/dcc248aa4d73439700045e781a8241cc7250ab16", "message": "ISPN-11341 Detect client and server segment mismatch and fallback to tracking only keys", "committedDate": "2020-02-25T09:09:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1OTk1NQ==", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385759955", "bodyText": "I would add the keys directly to ReplKeyTracker. You are creating a new HashSet here and when you instantiate the ReplKeyTracker.", "author": "pruivo", "createdAt": "2020-02-28T15:30:32Z", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/SegmentKeyTracker.java", "diffHunk": "@@ -40,20 +42,38 @@ public SegmentKeyTracker(DataFormat dataFormat, SegmentConsistentHash segmentCon\n       segmentStream.forEach(i -> keysPerSegment.set(i, new HashSet<>()));\n    }\n \n+   private Set<WrappedByteArray> drainKeys() {\n+      Set<WrappedByteArray> trackedKeys = new HashSet<>();", "originalCommit": "dcc248aa4d73439700045e781a8241cc7250ab16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3MjQ4OA==", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385772488", "bodyText": "Since you mentioned...I think I can remove this repl tracker altogether", "author": "gustavonalle", "createdAt": "2020-02-28T15:51:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1OTk1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjI2NTE1NQ==", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r386265155", "bodyText": "... and you can use keyOnlyTracker directly :) instead of creating a new HashSet.", "author": "pruivo", "createdAt": "2020-03-02T09:01:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1OTk1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjI2NjAzOA==", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r386266038", "bodyText": "sure, forgot to remove it", "author": "gustavonalle", "createdAt": "2020-03-02T09:03:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1OTk1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjI3OTE4MQ==", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r386279181", "bodyText": "changed", "author": "gustavonalle", "createdAt": "2020-03-02T09:30:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1OTk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2MDYyOA==", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385760628", "bodyText": "not sure how this class is used but... can we have an NPE here?\nyou are setting trackSegments before instantiating keyOnlyTracker", "author": "pruivo", "createdAt": "2020-02-28T15:31:31Z", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/SegmentKeyTracker.java", "diffHunk": "@@ -40,20 +42,38 @@ public SegmentKeyTracker(DataFormat dataFormat, SegmentConsistentHash segmentCon\n       segmentStream.forEach(i -> keysPerSegment.set(i, new HashSet<>()));\n    }\n \n+   private Set<WrappedByteArray> drainKeys() {\n+      Set<WrappedByteArray> trackedKeys = new HashSet<>();\n+      for (int i = 0; i < keysPerSegment.length(); i++) {\n+         Set<WrappedByteArray> keys = keysPerSegment.get(i);\n+         if (keys != null) trackedKeys.addAll(keys);\n+         keysPerSegment.set(i, null);\n+      }\n+\n+      return trackedKeys;\n+   }\n+\n    public boolean track(byte[] key, short status, ClassWhiteList whitelist) {\n+      if (!trackSegments) {\n+         return keyOnlyTracker.track(key, status, whitelist);", "originalCommit": "dcc248aa4d73439700045e781a8241cc7250ab16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3NDUxNw==", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385774517", "bodyText": "This class is not supposed to be called by more than 1 thread, it's involved for each iteration result read from the server", "author": "gustavonalle", "createdAt": "2020-02-28T15:54:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2MDYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2MjQ0Nw==", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385762447", "bodyText": "nitpick: if (trackeSegments && finishedSegments != null)", "author": "pruivo", "createdAt": "2020-02-28T15:34:24Z", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/SegmentKeyTracker.java", "diffHunk": "@@ -66,11 +86,13 @@ public boolean track(byte[] key, short status, ClassWhiteList whitelist) {\n    }\n \n    public void segmentsFinished(byte[] finishedSegments) {\n-      if (finishedSegments != null) {\n-         BitSet bitSet = BitSet.valueOf(finishedSegments);\n-         if (trace)\n-            log.tracef(\"Removing completed segments %s\", bitSet);\n-         bitSet.stream().forEach(seg -> keysPerSegment.set(seg, null));\n+      if (trackSegments) {", "originalCommit": "dcc248aa4d73439700045e781a8241cc7250ab16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2NDA3OQ==", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385764079", "bodyText": "any reason to use AtomicInteger? a boolean would be enough IMO :)", "author": "pruivo", "createdAt": "2020-02-28T15:37:06Z", "path": "client/hotrod-client/src/test/java/org/infinispan/client/hotrod/StorageRoutingTest.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package org.infinispan.client.hotrod;\n+\n+import static org.infinispan.configuration.cache.StorageType.BINARY;\n+import static org.infinispan.configuration.cache.StorageType.OBJECT;\n+import static org.infinispan.configuration.cache.StorageType.OFF_HEAP;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.infinispan.client.hotrod.test.FixedServerBalancing;\n+import org.infinispan.client.hotrod.test.MultiHotRodServersTest;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.cache.StorageType;\n+import org.infinispan.server.hotrod.HotRodServer;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Tests that the Hot Rod client can correctly route requests to a server using different {@link StorageType}.\n+ *\n+ * @since 11.0\n+ */\n+@Test(groups = \"functional\", testName = \"client.hotrod.StorageRoutingTest\")\n+public class StorageRoutingTest extends MultiHotRodServersTest {\n+\n+   private static final int CLUSTER_SIZE = 3;\n+\n+   protected StorageType storageType;\n+   private Object key;\n+\n+   public Object[] factory() {\n+      String stringKey = \"key\";\n+      byte[] byteArrayKey = new byte[]{1, 2, 3};\n+\n+      return new Object[]{\n+            new StorageRoutingTest().withStorageType(OBJECT).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(OBJECT).withKey(byteArrayKey),\n+            new StorageRoutingTest().withStorageType(OFF_HEAP).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(OFF_HEAP).withKey(byteArrayKey),\n+            new StorageRoutingTest().withStorageType(BINARY).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(BINARY).withKey(byteArrayKey)\n+      };\n+   }\n+\n+   protected String[] parameterNames() {\n+      return new String[]{\"storage\", \"key\"};\n+   }\n+\n+   protected Object[] parameterValues() {\n+      return new Object[]{storageType, key};\n+   }\n+\n+   private StorageRoutingTest withStorageType(StorageType storageType) {\n+      this.storageType = storageType;\n+      return this;\n+   }\n+\n+   private StorageRoutingTest withKey(Object key) {\n+      this.key = key;\n+      return this;\n+   }\n+\n+   @Override\n+   protected void createCacheManagers() throws Throwable {\n+      ConfigurationBuilder cfgBuilder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      cfgBuilder.jmxStatistics().enable();\n+      cfgBuilder.clustering().hash().numOwners(1);\n+      cfgBuilder.memory().storageType(storageType);\n+      createHotRodServers(CLUSTER_SIZE, cfgBuilder);\n+      waitForClusterToForm();\n+   }\n+\n+   @Override\n+   protected org.infinispan.client.hotrod.configuration.ConfigurationBuilder createHotRodClientConfigurationBuilder(HotRodServer hotRodServer) {\n+      org.infinispan.client.hotrod.configuration.ConfigurationBuilder hotRodClientConfigurationBuilder = super.createHotRodClientConfigurationBuilder(hotRodServer);\n+      hotRodClientConfigurationBuilder.balancingStrategy(() -> new FixedServerBalancing(hotRodServer));\n+      return hotRodClientConfigurationBuilder;\n+   }\n+\n+   @Test\n+   public void shouldContactKeyOwnerForPutGet() {\n+      String value = \"value\";\n+      RemoteCache<Object, String> remoteCache = clients.get(0).getCache();\n+      remoteCache.put(key, value);\n+\n+      assertEquals(remoteCache.get(key), \"value\");\n+\n+      assertCorrectServerContacted();\n+   }\n+\n+   private void assertCorrectServerContacted() {\n+      AtomicInteger storedIn = new AtomicInteger(-1);", "originalCommit": "dcc248aa4d73439700045e781a8241cc7250ab16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3MTY4Nw==", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385771687", "bodyText": "conciseness only", "author": "gustavonalle", "createdAt": "2020-02-28T15:49:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2NDA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3NTcyNQ==", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385775725", "bodyText": "ah! I missed the last assert assertEquals(storeServer, retrieveServer, ...) just ignore my comment.", "author": "pruivo", "createdAt": "2020-02-28T15:56:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2NDA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2NzgzMw==", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385767833", "bodyText": "I'm not sure I understand why you use the FixedServerBalancing. Isn't it force the requests to go to this server?", "author": "pruivo", "createdAt": "2020-02-28T15:43:08Z", "path": "client/hotrod-client/src/test/java/org/infinispan/client/hotrod/StorageRoutingTest.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package org.infinispan.client.hotrod;\n+\n+import static org.infinispan.configuration.cache.StorageType.BINARY;\n+import static org.infinispan.configuration.cache.StorageType.OBJECT;\n+import static org.infinispan.configuration.cache.StorageType.OFF_HEAP;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.infinispan.client.hotrod.test.FixedServerBalancing;\n+import org.infinispan.client.hotrod.test.MultiHotRodServersTest;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.cache.StorageType;\n+import org.infinispan.server.hotrod.HotRodServer;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Tests that the Hot Rod client can correctly route requests to a server using different {@link StorageType}.\n+ *\n+ * @since 11.0\n+ */\n+@Test(groups = \"functional\", testName = \"client.hotrod.StorageRoutingTest\")\n+public class StorageRoutingTest extends MultiHotRodServersTest {\n+\n+   private static final int CLUSTER_SIZE = 3;\n+\n+   protected StorageType storageType;\n+   private Object key;\n+\n+   public Object[] factory() {\n+      String stringKey = \"key\";\n+      byte[] byteArrayKey = new byte[]{1, 2, 3};\n+\n+      return new Object[]{\n+            new StorageRoutingTest().withStorageType(OBJECT).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(OBJECT).withKey(byteArrayKey),\n+            new StorageRoutingTest().withStorageType(OFF_HEAP).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(OFF_HEAP).withKey(byteArrayKey),\n+            new StorageRoutingTest().withStorageType(BINARY).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(BINARY).withKey(byteArrayKey)\n+      };\n+   }\n+\n+   protected String[] parameterNames() {\n+      return new String[]{\"storage\", \"key\"};\n+   }\n+\n+   protected Object[] parameterValues() {\n+      return new Object[]{storageType, key};\n+   }\n+\n+   private StorageRoutingTest withStorageType(StorageType storageType) {\n+      this.storageType = storageType;\n+      return this;\n+   }\n+\n+   private StorageRoutingTest withKey(Object key) {\n+      this.key = key;\n+      return this;\n+   }\n+\n+   @Override\n+   protected void createCacheManagers() throws Throwable {\n+      ConfigurationBuilder cfgBuilder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      cfgBuilder.jmxStatistics().enable();\n+      cfgBuilder.clustering().hash().numOwners(1);\n+      cfgBuilder.memory().storageType(storageType);\n+      createHotRodServers(CLUSTER_SIZE, cfgBuilder);\n+      waitForClusterToForm();\n+   }\n+\n+   @Override\n+   protected org.infinispan.client.hotrod.configuration.ConfigurationBuilder createHotRodClientConfigurationBuilder(HotRodServer hotRodServer) {\n+      org.infinispan.client.hotrod.configuration.ConfigurationBuilder hotRodClientConfigurationBuilder = super.createHotRodClientConfigurationBuilder(hotRodServer);\n+      hotRodClientConfigurationBuilder.balancingStrategy(() -> new FixedServerBalancing(hotRodServer));", "originalCommit": "dcc248aa4d73439700045e781a8241cc7250ab16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3MDk4MA==", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385770980", "bodyText": "I want to have a client connecting to a specific sever to be able to read local statistics and do the test assertions", "author": "gustavonalle", "createdAt": "2020-02-28T15:48:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2NzgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3NjI3MA==", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385776270", "bodyText": "The test is verifying that, for a certain server, if the entry was both stored and retrieved from it", "author": "gustavonalle", "createdAt": "2020-02-28T15:57:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2NzgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3ODExMQ==", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385778111", "bodyText": "makes sense now \ud83d\udc4d", "author": "pruivo", "createdAt": "2020-02-28T16:00:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2NzgzMw=="}], "type": "inlineReview"}, {"oid": "5c2141b3c9579d9d378940016183c550a06f0ecf", "url": "https://github.com/infinispan/infinispan/commit/5c2141b3c9579d9d378940016183c550a06f0ecf", "message": "ISPN-11341 Detect client and server segment mismatch and fallback to tracking only keys", "committedDate": "2020-03-02T08:20:26Z", "type": "forcePushed"}, {"oid": "ed2dc11d5bb244e5af162eb4e3a1b636ad3d0a03", "url": "https://github.com/infinispan/infinispan/commit/ed2dc11d5bb244e5af162eb4e3a1b636ad3d0a03", "message": "ISPN-11341 Detect client and server segment mismatch and fallback to tracking only keys", "committedDate": "2020-03-02T08:21:30Z", "type": "forcePushed"}, {"oid": "9f2f85a7ab07e47446b897806ed4c9be3c0b9084", "url": "https://github.com/infinispan/infinispan/commit/9f2f85a7ab07e47446b897806ed4c9be3c0b9084", "message": "ISPN-11341 Reproducer", "committedDate": "2020-03-02T09:20:09Z", "type": "commit"}, {"oid": "8db9ae27cafe4810fa905f16b4297887bab92198", "url": "https://github.com/infinispan/infinispan/commit/8db9ae27cafe4810fa905f16b4297887bab92198", "message": "ISPN-11341 Turn BINARY as a no-op when cache started by the server", "committedDate": "2020-03-02T09:20:09Z", "type": "commit"}, {"oid": "6ddcbfe63c0e345b0dd585a5778de00c647ead0a", "url": "https://github.com/infinispan/infinispan/commit/6ddcbfe63c0e345b0dd585a5778de00c647ead0a", "message": "ISPN-11341 Detect client and server segment mismatch and fallback to tracking only keys", "committedDate": "2020-03-02T09:24:39Z", "type": "commit"}, {"oid": "6ddcbfe63c0e345b0dd585a5778de00c647ead0a", "url": "https://github.com/infinispan/infinispan/commit/6ddcbfe63c0e345b0dd585a5778de00c647ead0a", "message": "ISPN-11341 Detect client and server segment mismatch and fallback to tracking only keys", "committedDate": "2020-03-02T09:24:39Z", "type": "forcePushed"}]}