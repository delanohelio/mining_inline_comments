{"pr_number": 8586, "pr_title": "ISPN-12156 Security Realm identity caching", "pr_createdAt": "2020-07-24T11:45:46Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8586", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYwMzMxNA==", "url": "https://github.com/infinispan/infinispan/pull/8586#discussion_r463603314", "bodyText": "Isn't 16 kind of small?", "author": "danberindei", "createdAt": "2020-07-31T13:14:44Z", "path": "server/runtime/src/main/java/org/infinispan/server/configuration/security/RealmConfiguration.java", "diffHunk": "@@ -15,9 +15,11 @@\n  */\n public class RealmConfiguration implements ConfigurationInfo {\n    static final AttributeDefinition<String> NAME = AttributeDefinition.builder(\"name\", null, String.class).build();\n+   static final AttributeDefinition<Integer> CACHE_MAX_SIZE = AttributeDefinition.builder(\"cacheMaxSize\", 16).build();", "originalCommit": "386282d2f300871ae09c2b373059609ce4a0de36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc0NDU5MQ==", "url": "https://github.com/infinispan/infinispan/pull/8586#discussion_r467744591", "bodyText": "It seems so. If I understand it correctly, this cache is mapped 1:1 to user credentials in the realm. If the entries are small, we could maybe up this number?", "author": "gustavonalle", "createdAt": "2020-08-10T08:05:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYwMzMxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU4OTIwOA==", "url": "https://github.com/infinispan/infinispan/pull/8586#discussion_r483589208", "bodyText": "To be honest, I was thinking that many systems will only have a handful of application users, but I guess it won't hurt to raise this. 256 ?", "author": "tristantarrant", "createdAt": "2020-09-04T12:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYwMzMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYwNzgxOQ==", "url": "https://github.com/infinispan/infinispan/pull/8586#discussion_r463607819", "bodyText": "I know it's not our API but I feel like it merits a comment, seeing the result of build() unused is puzzling.", "author": "danberindei", "createdAt": "2020-07-31T13:23:33Z", "path": "server/runtime/src/main/java/org/infinispan/server/configuration/security/RealmConfigurationBuilder.java", "diffHunk": "@@ -157,4 +179,35 @@ SSLContext getSSLContext() {\n    public void addFeature(ServerSecurityRealm.Feature feature) {\n       features.add(feature);\n    }\n+\n+   private SecurityRealm cacheable(SecurityRealm realm) {\n+      int maxEntries = attributes.attribute(CACHE_MAX_SIZE).get();\n+      if (maxEntries > 0 && realm instanceof CacheableSecurityRealm) {\n+         if (cache == null) {\n+            cache = new LRURealmIdentityCache(maxEntries, attributes.attribute(CACHE_LIFESPAN).get());\n+         }\n+         if (realm instanceof ModifiableSecurityRealm) {\n+            return new CachingModifiableSecurityRealm((CacheableSecurityRealm) realm, cache);\n+         } else {\n+            return new CachingSecurityRealm((CacheableSecurityRealm) realm, cache);\n+         }\n+      } else {\n+         return realm;\n+      }\n+   }\n+\n+   public void addRealm(String realmName, SecurityRealm realm) {\n+      addRealm(realmName, realm, null);\n+   }\n+\n+   public void addRealm(String realmName, SecurityRealm realm, Consumer<SecurityDomain.RealmBuilder> realmBuilderConsumer) {\n+      SecurityDomain.RealmBuilder realmBuilder = domainBuilder.addRealm(realmName, cacheable(realm));\n+      if (realmBuilderConsumer != null) {\n+         realmBuilderConsumer.accept(realmBuilder);\n+      }\n+      realmBuilder.build();", "originalCommit": "386282d2f300871ae09c2b373059609ce4a0de36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc0NTkxNQ==", "url": "https://github.com/infinispan/infinispan/pull/8586#discussion_r467745915", "bodyText": "What is the reason for this change?", "author": "gustavonalle", "createdAt": "2020-08-10T08:08:12Z", "path": "server/tests/src/test/java/org/infinispan/server/security/authentication/RestAuthentication.java", "diffHunk": "@@ -78,7 +78,7 @@ public void testStaticResourcesAnonymously() {\n \n    @Test\n    public void testRestReadWrite() {\n-      RestClientConfigurationBuilder builder = new RestClientConfigurationBuilder();\n+      RestClientConfigurationBuilder builder = new RestClientConfigurationBuilder().socketTimeout(100_000).connectionTimeout(100_000);", "originalCommit": "386282d2f300871ae09c2b373059609ce4a0de36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8b2bda78d63760fed87dacb59676eec337d4c131", "url": "https://github.com/infinispan/infinispan/commit/8b2bda78d63760fed87dacb59676eec337d4c131", "message": "ISPN-12156 Security Realm identity caching", "committedDate": "2020-09-04T12:41:45Z", "type": "forcePushed"}, {"oid": "47de697f3d97431632c42c2689c2a18e51fefc18", "url": "https://github.com/infinispan/infinispan/commit/47de697f3d97431632c42c2689c2a18e51fefc18", "message": "ISPN-12156 Security Realm identity caching", "committedDate": "2020-09-04T15:47:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE5NDg5Mg==", "url": "https://github.com/infinispan/infinispan/pull/8586#discussion_r510194892", "bodyText": "Missing isTraceEnabled() (in getAttributes() as well)", "author": "danberindei", "createdAt": "2020-10-22T14:12:03Z", "path": "server/runtime/src/main/java/org/infinispan/server/security/realm/CachingSecurityRealm.java", "diffHunk": "@@ -0,0 +1,304 @@\n+package org.infinispan.server.security.realm;\n+\n+import static org.wildfly.common.Assert.checkNotNullParam;\n+import static org.infinispan.server.Server.log;\n+\n+import java.security.Principal;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n+\n+import org.wildfly.security.auth.SupportLevel;\n+import org.wildfly.security.auth.realm.CacheableSecurityRealm;\n+import org.wildfly.security.auth.server.IdentityCredentials;\n+import org.wildfly.security.auth.server.RealmIdentity;\n+import org.wildfly.security.auth.server.RealmUnavailableException;\n+import org.wildfly.security.auth.server.SecurityRealm;\n+import org.wildfly.security.auth.server.event.RealmEvent;\n+import org.wildfly.security.authz.Attributes;\n+import org.wildfly.security.authz.AuthorizationIdentity;\n+import org.wildfly.security.cache.RealmIdentityCache;\n+import org.wildfly.security.credential.Credential;\n+import org.wildfly.security.credential.PasswordCredential;\n+import org.wildfly.security.evidence.Evidence;\n+import org.wildfly.security.evidence.PasswordGuessEvidence;\n+import org.wildfly.security.password.Password;\n+import org.wildfly.security.password.interfaces.ClearPassword;\n+\n+/**\n+ * <p>A wrapper class that provides caching capabilities for a {@link SecurityRealm} and its identities.\n+ *\n+ * @author <a href=\"mailto:psilva@redhat.com\">Pedro Igor</a>\n+ */\n+public class CachingSecurityRealm implements SecurityRealm {\n+\n+   private final CacheableSecurityRealm realm;\n+   private final RealmIdentityCache cache;\n+\n+   /**\n+    * Creates a new instance.\n+    *\n+    * @param realm the {@link SecurityRealm} whose {@link RealmIdentity} should be cached.\n+    * @param cache the {@link RealmIdentityCache} instance\n+    */\n+   public CachingSecurityRealm(CacheableSecurityRealm realm, RealmIdentityCache cache) {\n+      this.realm = checkNotNullParam(\"realm\", realm);\n+      this.cache = checkNotNullParam(\"cache\", cache);\n+\n+      if (realm instanceof CacheableSecurityRealm) {\n+         CacheableSecurityRealm cacheable = (CacheableSecurityRealm) realm;\n+         cacheable.registerIdentityChangeListener(this::removeFromCache);\n+      } else {\n+         throw new IllegalArgumentException(realm.toString());\n+      }\n+   }\n+\n+   @Override\n+   public RealmIdentity getRealmIdentity(Principal principal) throws RealmUnavailableException {\n+      RealmIdentity cached = cache.get(principal);\n+\n+      if (cached != null) {\n+         log.tracef(\"Returning cached RealmIdentity for '%s'\", principal);\n+         return cached;\n+      }\n+\n+      RealmIdentity realmIdentity = getCacheableRealm().getRealmIdentity(principal);\n+\n+      if (!realmIdentity.exists()) {\n+         log.tracef(\"RealmIdentity for '%s' does not exist, skipping cache.'\", principal);\n+         return realmIdentity;\n+      }\n+\n+      RealmIdentity cachedIdentity = new RealmIdentity() {\n+         final RealmIdentity identity = realmIdentity;\n+\n+         AuthorizationIdentity authorizationIdentity = null;\n+         Attributes attributes = null;\n+         IdentityCredentials credentials = IdentityCredentials.NONE;\n+         int verifiedEvidenceHash;\n+\n+         @Override\n+         public Principal getRealmIdentityPrincipal() {\n+            return identity.getRealmIdentityPrincipal();\n+         }\n+\n+         @Override\n+         public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName, final AlgorithmParameterSpec parameterSpec) throws RealmUnavailableException {\n+            if (credentials.contains(credentialType, algorithmName, parameterSpec)) {\n+               if (log.isTraceEnabled()) {\n+                  log.tracef(\"getCredentialAcquireSupport credentialType='%s' with algorithmName='%' known for pincipal='%s'\", credentialType.getName(), algorithmName, principal.getName());\n+               }\n+               return credentials.getCredentialAcquireSupport(credentialType, algorithmName, parameterSpec);\n+            }\n+            Credential credential = identity.getCredential(credentialType, algorithmName, parameterSpec);\n+            if (credential != null) {\n+               if (log.isTraceEnabled()) {\n+                  log.tracef(\"getCredentialAcquireSupport Credential for credentialType='%s' with algorithmName='%' obtained from identity - caching for principal='%s'\",\n+                        credentialType.getName(), algorithmName, principal.getName());\n+               }\n+               credentials = credentials.withCredential(credential);\n+            }\n+            return credentials.getCredentialAcquireSupport(credentialType, algorithmName, parameterSpec);\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(Class<C> credentialType) throws RealmUnavailableException {\n+            if (credentials.contains(credentialType)) {\n+               if (log.isTraceEnabled()) {\n+                  log.tracef(\"getCredential credentialType='%s' cached, returning cached credential for principal='%s'\", credentialType.getName(), principal.getName());\n+               }\n+               return credentials.getCredential(credentialType);\n+            }\n+            Credential credential = identity.getCredential(credentialType);\n+            if (credential != null) {\n+               if (log.isTraceEnabled()) {\n+                  log.tracef(\"getCredential credentialType='%s' obtained from identity - caching for principal='%s'\", credentialType.getName(), principal.getName());\n+               }\n+               credentials = credentials.withCredential(credential);\n+            }\n+            return credentials.getCredential(credentialType);\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(Class<C> credentialType, String algorithmName) throws RealmUnavailableException {\n+            if (credentials.contains(credentialType, algorithmName)) {\n+               if (log.isTraceEnabled()) {\n+                  log.tracef(\"getCredential credentialType='%s' with algorithmName='%' cached, returning cached credential for principal='%s'\", credentialType.getName(), algorithmName, principal.getName());\n+               }\n+               return credentials.getCredential(credentialType, algorithmName);\n+            }\n+            Credential credential = identity.getCredential(credentialType, algorithmName);\n+            if (credential != null) {\n+               if (log.isTraceEnabled()) {\n+                  log.tracef(\"getCredential credentialType='%s' with algorithmName='%' obtained from identity - caching.\", credentialType.getName(), algorithmName);\n+               }\n+               credentials = credentials.withCredential(credential);\n+            }\n+            return credentials.getCredential(credentialType, algorithmName);\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(final Class<C> credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) throws RealmUnavailableException {\n+            if (credentials.contains(credentialType, algorithmName, parameterSpec)) {\n+               if (log.isTraceEnabled()) {\n+                  log.tracef(\"getCredential credentialType='%s' with algorithmName='%s' cached, returning cached credential for principal='%s'\", credentialType.getName(), algorithmName, principal.getName());\n+               }\n+               return credentials.getCredential(credentialType, algorithmName, parameterSpec);\n+            }\n+            Credential credential = identity.getCredential(credentialType, algorithmName, parameterSpec);\n+            if (credential != null) {\n+               if (log.isTraceEnabled()) {\n+                  log.tracef(\"getCredential credentialType='%s' with algorithmName='%s' obtained from identity - caching for principal='%s'\", credentialType.getName(), algorithmName, principal.getName());\n+               }\n+               credentials = credentials.withCredential(credential);\n+            }\n+            return credentials.getCredential(credentialType, algorithmName, parameterSpec);\n+         }\n+\n+         @Override\n+         public void updateCredential(Credential credential) throws RealmUnavailableException {\n+            log.tracef(\"updateCredential For principal='%s'\", principal);\n+            try {\n+               identity.updateCredential(credential);\n+            } finally {\n+               removeFromCache(identity.getRealmIdentityPrincipal());\n+            }\n+         }\n+\n+         @Override\n+         public SupportLevel getEvidenceVerifySupport(Class<? extends Evidence> evidenceType, String algorithmName) throws RealmUnavailableException {\n+            if (PasswordGuessEvidence.class.isAssignableFrom(evidenceType)) {\n+               if (credentials.canVerify(evidenceType, algorithmName)) {\n+                  if (log.isTraceEnabled()) {\n+                     log.tracef(\"getEvidenceVerifySupport evidenceType='%s' with algorithmName='%' can verify from cache for principal='%s'\", evidenceType.getName(), algorithmName, principal.getName());\n+                  }\n+                  return SupportLevel.SUPPORTED;\n+               }\n+               Credential credential = identity.getCredential(PasswordCredential.class);\n+               if (credential != null) {\n+                  if (log.isTraceEnabled()) {\n+                     log.tracef(\"getEvidenceVerifySupport evidenceType='%s' with algorithmName='%' credential obtained from identity and cached for principal='%s'\",\n+                           evidenceType.getName(), algorithmName, principal.getName());\n+                  }\n+                  credentials = credentials.withCredential(credential);\n+                  if (credential.canVerify(evidenceType, algorithmName)) {\n+                     return SupportLevel.SUPPORTED;\n+                  }\n+               }\n+            }\n+            if (log.isTraceEnabled()) {\n+               log.tracef(\"getEvidenceVerifySupport evidenceType='%s' with algorithmName='%' falling back to direct support of identity for principal='%s'\",\n+                     evidenceType.getName(), algorithmName, principal.getName());\n+            }\n+            return identity.getEvidenceVerifySupport(evidenceType, algorithmName);\n+         }\n+\n+         @Override\n+         public boolean verifyEvidence(Evidence evidence) throws RealmUnavailableException {\n+            if (evidence instanceof PasswordGuessEvidence) {\n+               char[] guess = ((PasswordGuessEvidence) evidence).getGuess();\n+               int evidenceHash = Arrays.hashCode(guess);\n+               if (evidenceHash == verifiedEvidenceHash) {\n+                  return true;\n+               }\n+               if (credentials.canVerify(evidence)) {\n+                  log.tracef(\"verifyEvidence For principal='%s' using cached credential\", principal);\n+                  return credentials.verify(evidence);\n+               }\n+               Credential credential = identity.getCredential(PasswordCredential.class);\n+               if (credential != null) {\n+                  log.tracef(\"verifyEvidence Credential obtained from identity and cached for principal='%s'\", principal);\n+                  credentials = credentials.withCredential(credential);\n+                  if (credential.canVerify(evidence)) {\n+                     boolean res = credential.verify(evidence);\n+                     if (res) {\n+                        verifiedEvidenceHash = evidenceHash;\n+                     }\n+                     return res;\n+                  }\n+               }\n+               Password password = ClearPassword.createRaw(ClearPassword.ALGORITHM_CLEAR, guess);\n+               log.tracef(\"verifyEvidence Falling back to direct support of identity for principal='%s'\", principal);\n+               if (identity.verifyEvidence(evidence)) {\n+                  credentials = credentials.withCredential(new PasswordCredential(password));\n+                  return true;\n+               }\n+               return false;\n+            }\n+            return identity.verifyEvidence(evidence);\n+         }\n+\n+         @Override\n+         public boolean exists() throws RealmUnavailableException {\n+            return true; // non-existing identities will not be wrapped\n+         }\n+\n+         @Override\n+         public AuthorizationIdentity getAuthorizationIdentity() throws RealmUnavailableException {\n+            if (authorizationIdentity == null) {\n+               log.tracef(\"getAuthorizationIdentity Caching AuthorizationIdentity for principal='%s'\", principal);", "originalCommit": "47de697f3d97431632c42c2689c2a18e51fefc18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM0NTg2OQ==", "url": "https://github.com/infinispan/infinispan/pull/8586#discussion_r510345869", "bodyText": "Seems this is unused?", "author": "wburns", "createdAt": "2020-10-22T17:44:49Z", "path": "server/rest/src/main/java/org/infinispan/rest/RestRequestHandler.java", "diffHunk": "@@ -124,6 +131,19 @@ public void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) thr\n       });\n    }\n \n+   private boolean matchAuthorizationHeader(String authz, String cached) {", "originalCommit": "47de697f3d97431632c42c2689c2a18e51fefc18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "126c95663fa2c12d04a6814f671d35342d68bcfc", "url": "https://github.com/infinispan/infinispan/commit/126c95663fa2c12d04a6814f671d35342d68bcfc", "message": "ISPN-12156 Security Realm identity caching", "committedDate": "2020-11-30T09:54:06Z", "type": "forcePushed"}, {"oid": "4eb35cde6275655b99cba94885d35363c3251303", "url": "https://github.com/infinispan/infinispan/commit/4eb35cde6275655b99cba94885d35363c3251303", "message": "ISPN-12156 Security Realm identity caching", "committedDate": "2020-11-30T10:18:40Z", "type": "forcePushed"}, {"oid": "9f1a6bd1f2c92fb21a73841e9f9b2d1452ddfee6", "url": "https://github.com/infinispan/infinispan/commit/9f1a6bd1f2c92fb21a73841e9f9b2d1452ddfee6", "message": "ISPN-12156 Security Realm identity caching", "committedDate": "2020-12-17T11:08:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMzNzEyNA==", "url": "https://github.com/infinispan/infinispan/pull/8586#discussion_r547337124", "bodyText": "Cast is not needed", "author": "danberindei", "createdAt": "2020-12-22T15:21:02Z", "path": "server/runtime/src/main/java/org/infinispan/server/security/realm/CachingSecurityRealm.java", "diffHunk": "@@ -0,0 +1,322 @@\n+package org.infinispan.server.security.realm;\n+\n+import static org.wildfly.common.Assert.checkNotNullParam;\n+import static org.infinispan.server.Server.log;\n+\n+import java.security.Principal;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n+\n+import org.wildfly.security.auth.SupportLevel;\n+import org.wildfly.security.auth.realm.CacheableSecurityRealm;\n+import org.wildfly.security.auth.server.IdentityCredentials;\n+import org.wildfly.security.auth.server.RealmIdentity;\n+import org.wildfly.security.auth.server.RealmUnavailableException;\n+import org.wildfly.security.auth.server.SecurityRealm;\n+import org.wildfly.security.auth.server.event.RealmEvent;\n+import org.wildfly.security.authz.Attributes;\n+import org.wildfly.security.authz.AuthorizationIdentity;\n+import org.wildfly.security.cache.RealmIdentityCache;\n+import org.wildfly.security.credential.Credential;\n+import org.wildfly.security.credential.PasswordCredential;\n+import org.wildfly.security.evidence.Evidence;\n+import org.wildfly.security.evidence.PasswordGuessEvidence;\n+import org.wildfly.security.password.Password;\n+import org.wildfly.security.password.interfaces.ClearPassword;\n+\n+/**\n+ * <p>A wrapper class that provides caching capabilities for a {@link SecurityRealm} and its identities.\n+ *\n+ * @author <a href=\"mailto:psilva@redhat.com\">Pedro Igor</a>\n+ */\n+public class CachingSecurityRealm implements SecurityRealm {\n+\n+   private final CacheableSecurityRealm realm;\n+   private final RealmIdentityCache cache;\n+\n+   /**\n+    * Creates a new instance.\n+    *\n+    * @param realm the {@link SecurityRealm} whose {@link RealmIdentity} should be cached.\n+    * @param cache the {@link RealmIdentityCache} instance\n+    */\n+   public CachingSecurityRealm(CacheableSecurityRealm realm, RealmIdentityCache cache) {\n+      this.realm = checkNotNullParam(\"realm\", realm);\n+      this.cache = checkNotNullParam(\"cache\", cache);\n+\n+      if (realm instanceof CacheableSecurityRealm) {\n+         CacheableSecurityRealm cacheable = (CacheableSecurityRealm) realm;", "originalCommit": "9f1a6bd1f2c92fb21a73841e9f9b2d1452ddfee6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM0MTc2MQ==", "url": "https://github.com/infinispan/infinispan/pull/8586#discussion_r547341761", "bodyText": "So it's not enough to cache the RealmIdentity, we also have to cache the AuthorizationIdentity and IdentityCredentials?", "author": "danberindei", "createdAt": "2020-12-22T15:29:07Z", "path": "server/runtime/src/main/java/org/infinispan/server/security/realm/CachingSecurityRealm.java", "diffHunk": "@@ -0,0 +1,322 @@\n+package org.infinispan.server.security.realm;\n+\n+import static org.wildfly.common.Assert.checkNotNullParam;\n+import static org.infinispan.server.Server.log;\n+\n+import java.security.Principal;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n+\n+import org.wildfly.security.auth.SupportLevel;\n+import org.wildfly.security.auth.realm.CacheableSecurityRealm;\n+import org.wildfly.security.auth.server.IdentityCredentials;\n+import org.wildfly.security.auth.server.RealmIdentity;\n+import org.wildfly.security.auth.server.RealmUnavailableException;\n+import org.wildfly.security.auth.server.SecurityRealm;\n+import org.wildfly.security.auth.server.event.RealmEvent;\n+import org.wildfly.security.authz.Attributes;\n+import org.wildfly.security.authz.AuthorizationIdentity;\n+import org.wildfly.security.cache.RealmIdentityCache;\n+import org.wildfly.security.credential.Credential;\n+import org.wildfly.security.credential.PasswordCredential;\n+import org.wildfly.security.evidence.Evidence;\n+import org.wildfly.security.evidence.PasswordGuessEvidence;\n+import org.wildfly.security.password.Password;\n+import org.wildfly.security.password.interfaces.ClearPassword;\n+\n+/**\n+ * <p>A wrapper class that provides caching capabilities for a {@link SecurityRealm} and its identities.\n+ *\n+ * @author <a href=\"mailto:psilva@redhat.com\">Pedro Igor</a>\n+ */\n+public class CachingSecurityRealm implements SecurityRealm {\n+\n+   private final CacheableSecurityRealm realm;\n+   private final RealmIdentityCache cache;\n+\n+   /**\n+    * Creates a new instance.\n+    *\n+    * @param realm the {@link SecurityRealm} whose {@link RealmIdentity} should be cached.\n+    * @param cache the {@link RealmIdentityCache} instance\n+    */\n+   public CachingSecurityRealm(CacheableSecurityRealm realm, RealmIdentityCache cache) {\n+      this.realm = checkNotNullParam(\"realm\", realm);\n+      this.cache = checkNotNullParam(\"cache\", cache);\n+\n+      if (realm instanceof CacheableSecurityRealm) {\n+         CacheableSecurityRealm cacheable = (CacheableSecurityRealm) realm;\n+         cacheable.registerIdentityChangeListener(this::removeFromCache);\n+      } else {\n+         throw new IllegalArgumentException(realm.toString());\n+      }\n+   }\n+\n+   @Override\n+   public RealmIdentity getRealmIdentity(Principal principal) throws RealmUnavailableException {\n+      RealmIdentity cached = cache.get(principal);\n+\n+      if (cached != null) {\n+         if(log.isTraceEnabled()) {\n+            log.tracef(\"Returning cached RealmIdentity for '%s'\", principal);\n+         }\n+         return cached;\n+      }\n+\n+      RealmIdentity realmIdentity = getCacheableRealm().getRealmIdentity(principal);\n+\n+      if (!realmIdentity.exists()) {\n+         if(log.isTraceEnabled()) {\n+            log.tracef(\"RealmIdentity for '%s' does not exist, skipping cache.'\", principal);\n+         }\n+         return realmIdentity;\n+      }\n+\n+      RealmIdentity cachedIdentity = new RealmIdentity() {\n+         final RealmIdentity identity = realmIdentity;\n+\n+         AuthorizationIdentity authorizationIdentity = null;\n+         Attributes attributes = null;\n+         IdentityCredentials credentials = IdentityCredentials.NONE;\n+         int verifiedEvidenceHash;", "originalCommit": "9f1a6bd1f2c92fb21a73841e9f9b2d1452ddfee6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fb20b5be12a632ee59c2442466767892a2a9fdb6", "url": "https://github.com/infinispan/infinispan/commit/fb20b5be12a632ee59c2442466767892a2a9fdb6", "message": "ISPN-12156 Security Realm identity caching", "committedDate": "2020-12-22T16:21:56Z", "type": "forcePushed"}, {"oid": "c4a5884b1947f1df33a6c2de6b17923b1de869c9", "url": "https://github.com/infinispan/infinispan/commit/c4a5884b1947f1df33a6c2de6b17923b1de869c9", "message": "ISPN-12156 Security Realm identity caching", "committedDate": "2020-12-22T16:37:33Z", "type": "commit"}, {"oid": "c4a5884b1947f1df33a6c2de6b17923b1de869c9", "url": "https://github.com/infinispan/infinispan/commit/c4a5884b1947f1df33a6c2de6b17923b1de869c9", "message": "ISPN-12156 Security Realm identity caching", "committedDate": "2020-12-22T16:37:33Z", "type": "forcePushed"}]}