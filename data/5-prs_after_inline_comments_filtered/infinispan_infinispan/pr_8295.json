{"pr_number": 8295, "pr_title": "ISPN-11700 User tool inside CLI", "pr_createdAt": "2020-05-08T15:17:06Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8295", "timeline": [{"oid": "16922ef883ad6810f98d56c2b5b3aa08832582dd", "url": "https://github.com/infinispan/infinispan/commit/16922ef883ad6810f98d56c2b5b3aa08832582dd", "message": "ISPN-11700 User tool inside CLI\n\n* convert the CLI launcher to be a command. This enables non-interactive mode\n* add a deprecation message in the user-tool.[sh|bat] scripts", "committedDate": "2020-05-08T15:18:19Z", "type": "forcePushed"}, {"oid": "9735c9a89ffc63609f7b5568ba3dc2f6161f7ec2", "url": "https://github.com/infinispan/infinispan/commit/9735c9a89ffc63609f7b5568ba3dc2f6161f7ec2", "message": "ISPN-11700 User tool inside CLI\n\n* convert the CLI launcher to be a command. This enables non-interactive mode\n* add a deprecation message in the user-tool.[sh|bat] scripts", "committedDate": "2020-05-08T16:06:44Z", "type": "forcePushed"}, {"oid": "c0e68397c3699490066a32d38497883d86c3a756", "url": "https://github.com/infinispan/infinispan/commit/c0e68397c3699490066a32d38497883d86c3a756", "message": "ISPN-11700 User tool inside CLI\n\n* convert the CLI launcher to be a command. This enables non-interactive mode\n* add a deprecation message in the user-tool.[sh|bat] scripts", "committedDate": "2020-05-09T13:46:03Z", "type": "forcePushed"}, {"oid": "601565f28b341e1a53eb76f6597e4b7c4eb3938c", "url": "https://github.com/infinispan/infinispan/commit/601565f28b341e1a53eb76f6597e4b7c4eb3938c", "message": "ISPN-11700 User tool inside CLI\n\n* convert the CLI launcher to be a command. This enables non-interactive mode\n* add a deprecation message in the user-tool.[sh|bat] scripts", "committedDate": "2020-05-11T15:39:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM5NDUxMA==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r425394510", "bodyText": "nitpick: remove", "author": "pruivo", "createdAt": "2020-05-14T19:57:03Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/Context.java", "diffHunk": "@@ -66,4 +66,6 @@\n    void setConsole(ReadlineConsole console);\n \n    CommandRegistry<? extends CommandInvocation> getRegistry();\n+", "originalCommit": "601565f28b341e1a53eb76f6597e4b7c4eb3938c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQwMzE4MQ==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r425403181", "bodyText": "isn't it going to replace the Provider in position 1?\nAlso, I don't see any use of this class.", "author": "pruivo", "createdAt": "2020-05-14T20:13:56Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/SecurityActions.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package org.infinispan.cli;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.security.Provider;\n+\n+/**\n+ * SecurityActions for the org.infinispan.cli package.\n+ * <p>\n+ * Do not move. Do not change class and method visibility to avoid being called from other {@link\n+ * java.security.CodeSource}s, thus granting privilege escalation to external code.\n+ *\n+ * @author Tristan Tarrant <tristan@infinispan.org>\n+ * @since 11.0\n+ */\n+final class SecurityActions {\n+   private static <T> T doPrivileged(PrivilegedAction<T> action) {\n+      if (System.getSecurityManager() != null) {\n+         return AccessController.doPrivileged(action);\n+      } else {\n+         return action.run();\n+      }\n+   }\n+\n+   static void addSecurityProvider(Provider provider) {\n+      doPrivileged(() -> {\n+               if (java.security.Security.getProvider(provider.getName()) == null) {\n+                  java.security.Security.insertProviderAt(provider, 1);", "originalCommit": "601565f28b341e1a53eb76f6597e4b7c4eb3938c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQwODQ3MQ==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r425408471", "bodyText": "is this supposed to continue executing after showing the version?", "author": "pruivo", "createdAt": "2020-05-14T20:23:56Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/CLI.java", "diffHunk": "@@ -0,0 +1,247 @@\n+package org.infinispan.cli.commands;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.security.KeyStore;\n+\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+import org.aesh.AeshRuntimeRunner;\n+import org.aesh.command.AeshCommandRuntimeBuilder;\n+import org.aesh.command.Command;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.impl.completer.FileOptionCompleter;\n+import org.aesh.command.impl.registry.AeshCommandRegistryBuilder;\n+import org.aesh.command.invocation.CommandInvocation;\n+import org.aesh.command.option.Option;\n+import org.aesh.command.registry.CommandRegistry;\n+import org.aesh.command.registry.CommandRegistryException;\n+import org.aesh.command.settings.SettingsBuilder;\n+import org.aesh.command.shell.Shell;\n+import org.aesh.io.Resource;\n+import org.aesh.readline.ReadlineConsole;\n+import org.infinispan.cli.Context;\n+import org.infinispan.cli.activators.ContextAwareCommandActivatorProvider;\n+import org.infinispan.cli.completers.ContextAwareCompleterInvocationProvider;\n+import org.infinispan.cli.impl.AeshDelegatingShell;\n+import org.infinispan.cli.impl.CliCommandNotFoundHandler;\n+import org.infinispan.cli.impl.CliRuntimeRunner;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocationProvider;\n+import org.infinispan.cli.impl.ContextAwareQuitHandler;\n+import org.infinispan.cli.impl.ContextImpl;\n+import org.infinispan.cli.impl.SSLContextSettings;\n+import org.infinispan.cli.util.ZeroSecurityHostnameVerifier;\n+import org.infinispan.cli.util.ZeroSecurityTrustManager;\n+import org.infinispan.commons.util.ServiceFinder;\n+import org.wildfly.security.keystore.KeyStoreUtil;\n+import org.wildfly.security.provider.util.ProviderUtil;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+@GroupCommandDefinition(\n+      name = CLI.CMD,\n+      description = \"\",\n+      groupCommands = {\n+            Add.class,\n+            Cache.class,\n+            Cas.class,\n+            Cd.class,\n+            Clear.class,\n+            ClearCache.class,\n+            Connect.class,\n+            Container.class,\n+            Counter.class,\n+            Create.class,\n+            Describe.class,\n+            Disconnect.class,\n+            Drop.class,\n+            Echo.class,\n+            Encoding.class,\n+            Get.class,\n+            Ls.class,\n+            Patch.class,\n+            Put.class,\n+            Query.class,\n+            Remove.class,\n+            Replace.class,\n+            Reset.class,\n+            Run.class,\n+            Schema.class,\n+            Shutdown.class,\n+            Site.class,\n+            User.class,\n+            Version.class\n+      })\n+public class CLI extends CliCommand {\n+   public static final String CMD = \"cli\";\n+\n+   @Option(completer = FileOptionCompleter.class, shortName = 't', name = \"truststore\", description = \"A truststore to use when connecting to SSL/TLS-enabled servers\")\n+   Resource truststore;\n+\n+   @Option(shortName = 's', name = \"truststore-password\", description = \"The password for the truststore\")\n+   String truststorePassword;\n+\n+   @Option(shortName = 'v', hasValue = false, description = \"Shows version information\")\n+   boolean version;\n+\n+   @Option(hasValue = false, description = \"Whether to trust all certificates\", name = \"trustall\")\n+   boolean trustAll;\n+\n+   @Option(completer = FileOptionCompleter.class, shortName = 'f', description = \"File for batch mode\")\n+   Resource file;\n+\n+   @Option(shortName = 'c', description = \"A connection URL. Use '-' to connect to http://localhost:11222\")\n+   String connect;\n+\n+   private Context context;\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+      if (help) {\n+         invocation.println(invocation.getHelpInfo());\n+         return CommandResult.SUCCESS;\n+      }\n+      if (version) {\n+         invocation.printf(\"%s CLI %s\\n\", org.infinispan.commons.util.Version.getBrandName(), org.infinispan.commons.util.Version.getVersion());\n+         invocation.printf(\"Copyright (C) Red Hat Inc. and/or its affiliates and other contributors\\n\");\n+         invocation.printf(\"License Apache License, v. 2.0. http://www.apache.org/licenses/LICENSE-2.0\\n\");", "originalCommit": "601565f28b341e1a53eb76f6597e4b7c4eb3938c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQxMDAxOA==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r425410018", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     invocation.printf(\"%s CLI %s\\n\", org.infinispan.commons.util.Version.getBrandName(), org.infinispan.commons.util.Version.getVersion());\n          \n          \n            \n                     invocation.printf(\"%s CLI %s\\n\", org.infinispan.commons.util.Version.getBrandName(), org.infinispan.commons.util.Version.getBrandVersion());", "author": "pruivo", "createdAt": "2020-05-14T20:26:52Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/CLI.java", "diffHunk": "@@ -0,0 +1,247 @@\n+package org.infinispan.cli.commands;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.security.KeyStore;\n+\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+import org.aesh.AeshRuntimeRunner;\n+import org.aesh.command.AeshCommandRuntimeBuilder;\n+import org.aesh.command.Command;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.impl.completer.FileOptionCompleter;\n+import org.aesh.command.impl.registry.AeshCommandRegistryBuilder;\n+import org.aesh.command.invocation.CommandInvocation;\n+import org.aesh.command.option.Option;\n+import org.aesh.command.registry.CommandRegistry;\n+import org.aesh.command.registry.CommandRegistryException;\n+import org.aesh.command.settings.SettingsBuilder;\n+import org.aesh.command.shell.Shell;\n+import org.aesh.io.Resource;\n+import org.aesh.readline.ReadlineConsole;\n+import org.infinispan.cli.Context;\n+import org.infinispan.cli.activators.ContextAwareCommandActivatorProvider;\n+import org.infinispan.cli.completers.ContextAwareCompleterInvocationProvider;\n+import org.infinispan.cli.impl.AeshDelegatingShell;\n+import org.infinispan.cli.impl.CliCommandNotFoundHandler;\n+import org.infinispan.cli.impl.CliRuntimeRunner;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocationProvider;\n+import org.infinispan.cli.impl.ContextAwareQuitHandler;\n+import org.infinispan.cli.impl.ContextImpl;\n+import org.infinispan.cli.impl.SSLContextSettings;\n+import org.infinispan.cli.util.ZeroSecurityHostnameVerifier;\n+import org.infinispan.cli.util.ZeroSecurityTrustManager;\n+import org.infinispan.commons.util.ServiceFinder;\n+import org.wildfly.security.keystore.KeyStoreUtil;\n+import org.wildfly.security.provider.util.ProviderUtil;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+@GroupCommandDefinition(\n+      name = CLI.CMD,\n+      description = \"\",\n+      groupCommands = {\n+            Add.class,\n+            Cache.class,\n+            Cas.class,\n+            Cd.class,\n+            Clear.class,\n+            ClearCache.class,\n+            Connect.class,\n+            Container.class,\n+            Counter.class,\n+            Create.class,\n+            Describe.class,\n+            Disconnect.class,\n+            Drop.class,\n+            Echo.class,\n+            Encoding.class,\n+            Get.class,\n+            Ls.class,\n+            Patch.class,\n+            Put.class,\n+            Query.class,\n+            Remove.class,\n+            Replace.class,\n+            Reset.class,\n+            Run.class,\n+            Schema.class,\n+            Shutdown.class,\n+            Site.class,\n+            User.class,\n+            Version.class\n+      })\n+public class CLI extends CliCommand {\n+   public static final String CMD = \"cli\";\n+\n+   @Option(completer = FileOptionCompleter.class, shortName = 't', name = \"truststore\", description = \"A truststore to use when connecting to SSL/TLS-enabled servers\")\n+   Resource truststore;\n+\n+   @Option(shortName = 's', name = \"truststore-password\", description = \"The password for the truststore\")\n+   String truststorePassword;\n+\n+   @Option(shortName = 'v', hasValue = false, description = \"Shows version information\")\n+   boolean version;\n+\n+   @Option(hasValue = false, description = \"Whether to trust all certificates\", name = \"trustall\")\n+   boolean trustAll;\n+\n+   @Option(completer = FileOptionCompleter.class, shortName = 'f', description = \"File for batch mode\")\n+   Resource file;\n+\n+   @Option(shortName = 'c', description = \"A connection URL. Use '-' to connect to http://localhost:11222\")\n+   String connect;\n+\n+   private Context context;\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+      if (help) {\n+         invocation.println(invocation.getHelpInfo());\n+         return CommandResult.SUCCESS;\n+      }\n+      if (version) {\n+         invocation.printf(\"%s CLI %s\\n\", org.infinispan.commons.util.Version.getBrandName(), org.infinispan.commons.util.Version.getVersion());", "originalCommit": "601565f28b341e1a53eb76f6597e4b7c4eb3938c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f0249907987231774fe03acc3647f33278868ad8", "url": "https://github.com/infinispan/infinispan/commit/f0249907987231774fe03acc3647f33278868ad8", "message": "ISPN-11838 Native CLI", "committedDate": "2020-05-15T13:35:25Z", "type": "forcePushed"}, {"oid": "fffda63dbb83ab653197c281f0d0f08be74fb270", "url": "https://github.com/infinispan/infinispan/commit/fffda63dbb83ab653197c281f0d0f08be74fb270", "message": "ISPN-11838 Native CLI", "committedDate": "2020-05-15T13:37:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk2ODMwMg==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r425968302", "bodyText": "all these changes just to fix the native compilation? :(", "author": "pruivo", "createdAt": "2020-05-15T18:12:24Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/Abort.java", "diffHunk": "@@ -17,6 +18,14 @@\n \n    public static final String CMD = \"abort\";\n \n+   @Option(shortName = 'h', hasValue = false)", "originalCommit": "fffda63dbb83ab653197c281f0d0f08be74fb270", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5NDY0NA==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r426394644", "bodyText": "Unfortunately I have not found a way to make inheritance work. Method visibility, allow all fields, etc: none worked for me.", "author": "tristantarrant", "createdAt": "2020-05-18T06:29:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk2ODMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwNTQ3Ng==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r426005476", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  @Option(description = \"Whether the password should be stored in plain text\", name = \"plain-text\")\n          \n          \n            \n                  @Option(description = \"Whether the password should be stored in plain text\", name = \"plain-text\", hasValue = false)\n          \n      \n    \n    \n  \n\nhasValue=false is missing\n[disconnected]> user modify b -p c --plain-text\nOption plain-text was specified, but no value was given.", "author": "pruivo", "createdAt": "2020-05-15T19:28:40Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/User.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package org.infinispan.cli.commands;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.util.List;\n+\n+import org.aesh.command.Command;\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandException;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Option;\n+import org.aesh.command.option.OptionList;\n+import org.aesh.readline.Prompt;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.user.UserTool;\n+import org.kohsuke.MetaInfServices;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+@MetaInfServices(Command.class)\n+@GroupCommandDefinition(name = User.CMD, description = \"User operations\", groupCommands = {User.Create.class, User.Describe.class, User.Remove.class, User.Modify.class, User.Ls.class})\n+public class User extends CliCommand {\n+\n+   public static final String CMD = \"user\";\n+\n+   @Option(shortName = 'h', hasValue = false)\n+   protected boolean help;\n+\n+   @Override\n+   public boolean isHelp() {\n+      return help;\n+   }\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+      // This command serves only to wrap the sub-commands\n+      invocation.println(invocation.getHelpInfo());\n+      return CommandResult.FAILURE;\n+   }\n+\n+   @CommandDefinition(name = Create.CMD, description = \"Creates a user\", aliases = \"add\")\n+   public static class Create extends CliCommand {\n+      public static final String CMD = \"create\";\n+\n+      @Argument(description = \"The username for the user\")\n+      String username;\n+\n+      @Option(description = \"The password for the user\", shortName = 'p')\n+      String password;\n+\n+      @Option(description = \"The realm \", defaultValue = UserTool.DEFAULT_REALM_NAME, shortName = 'r')\n+      String realm;\n+\n+      @OptionList(description = \"The algorithms used to encrypt the password\", shortName = 'a')\n+      List<String> algorithms;\n+\n+      @OptionList(description = \"The groups the user should belong to\", shortName = 'g')\n+      List<String> groups;\n+\n+      @Option(description = \"Whether the password should be stored in plain text (not recommended)\", name = \"plain-text\", hasValue = false)\n+      boolean plainText;\n+\n+      @Option(description = \"The path of the users.properties file\", name = \"users-file\", shortName = 'f')\n+      String usersFile;\n+\n+      @Option(description = \"The path of the groups.properties file\", name = \"groups-file\", shortName = 'w')\n+      String groupsFile;\n+\n+      @Option(description = \"The server root\", defaultValue = \"server\", name = \"server-root\", shortName= 's')\n+      String serverRoot;\n+\n+      @Option(shortName = 'h', hasValue = false)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      public CommandResult exec(ContextAwareCommandInvocation invocation) throws CommandException {\n+         UserTool userTool = new UserTool(serverRoot, usersFile, groupsFile);\n+         try {\n+            while (username == null || username.isEmpty()) {\n+               username = invocation.getShell().readLine(MSG.userToolUsername());\n+            }\n+         } catch (InterruptedException e) {\n+            return CommandResult.FAILURE;\n+         }\n+\n+         if (password == null) { // Get the password interactively\n+            try {\n+               while (password == null || password.isEmpty()) {\n+                  password = invocation.getShell().readLine(new Prompt(MSG.userToolPassword(), '*'));\n+               }\n+               String confirm = null;\n+               while (confirm == null || !confirm.equals(password)) {\n+                  confirm = invocation.getShell().readLine(new Prompt(MSG.userToolPasswordConfirm(), '*'));\n+               }\n+            } catch (InterruptedException e) {\n+               return CommandResult.FAILURE;\n+            }\n+         }\n+         userTool.createUser(username, password, realm, plainText, groups, algorithms);\n+         return CommandResult.SUCCESS;\n+      }\n+   }\n+\n+   @CommandDefinition(name = Describe.CMD, description = \"Describes a user\")\n+   public static class Describe extends CliCommand {\n+      public static final String CMD = \"describe\";\n+\n+      @Argument(description = \"The username for the user\", required = true)\n+      String username;\n+\n+      @Option(description = \"The path of the users.properties file\", name = \"users-file\", shortName = 'f')\n+      String usersFile;\n+\n+      @Option(description = \"The path of the groups.properties file\", name = \"groups-file\", shortName = 'w')\n+      String groupsFile;\n+\n+      @Option(description = \"The server root\", defaultValue = \"server\", name = \"server-root\", shortName= 's')\n+      String serverRoot;\n+\n+      @Option(shortName = 'h', hasValue = false)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      public CommandResult exec(ContextAwareCommandInvocation invocation) throws CommandException {\n+         UserTool userTool = new UserTool(serverRoot, usersFile, groupsFile);\n+         invocation.getShell().writeln(userTool.describeUser(username));\n+         return CommandResult.SUCCESS;\n+      }\n+   }\n+\n+   @CommandDefinition(name = Remove.CMD, description = \"Removes a user\", aliases = \"rm\")\n+   public static class Remove extends CliCommand {\n+      public static final String CMD = \"remove\";\n+\n+      @Argument(description = \"The username for the user\", required = true)\n+      String username;\n+\n+      @Option(description = \"The path of the users.properties file\", name = \"users-file\", shortName = 'f')\n+      String usersFile;\n+\n+      @Option(description = \"The path of the groups.properties file\", name = \"groups-file\", shortName = 'w')\n+      String groupsFile;\n+\n+      @Option(description = \"The server root\", defaultValue = \"server\", name = \"server-root\", shortName= 's')\n+      String serverRoot;\n+\n+      @Option(shortName = 'h', hasValue = false)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      public CommandResult exec(ContextAwareCommandInvocation invocation) throws CommandException {\n+         UserTool userTool = new UserTool(serverRoot, usersFile, groupsFile);\n+         userTool.removeUser(username);\n+         return CommandResult.SUCCESS;\n+      }\n+   }\n+\n+   @CommandDefinition(name = Modify.CMD, description = \"Modifies a user\")\n+   public static class Modify extends CliCommand {\n+      public static final String CMD = \"modify\";\n+\n+      @Argument(description = \"The username for the user\", required = true)\n+      String username;\n+\n+      @Option(description = \"The password for the user\", shortName = 'p')\n+      String password;\n+\n+      @Option(description = \"The realm \", defaultValue = UserTool.DEFAULT_REALM_NAME, shortName = 'r')\n+      String realm;\n+\n+      @OptionList(description = \"The algorithms used to encrypt the password\", shortName = 'a')\n+      List<String> algorithms;\n+\n+      @OptionList(description = \"The groups the user should belong to\", shortName = 'g')\n+      List<String> groups;\n+\n+      @Option(description = \"Whether the password should be stored in plain text\", name = \"plain-text\")", "originalCommit": "fffda63dbb83ab653197c281f0d0f08be74fb270", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMTU3NQ==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r426011575", "bodyText": "can you fix the algorithm in this PR?\nif you mix clear and encrypted passwords you can't login with some users:\n[disconnected]> user create test -p test\n[disconnected]> user create unsecure -p weak --plain-text \n[disconnected]> connect -u test -p test\nThe supplied credentials are invalid \n[null]> connect -u unsecure -p weak                # where the \"null\" comes from!?\n[pedro-laptop-3-17779@cluster//containers/default]> \n\nmay I suggest to have the \"algorithm\" per user? like <user>:<type>:<password> where type can be 0 (==clear) or 1 (==encrypted)\nProbably work for another PR...", "author": "pruivo", "createdAt": "2020-05-15T19:42:53Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/user/UserTool.java", "diffHunk": "@@ -0,0 +1,252 @@\n+package org.infinispan.cli.user;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+\n+import org.wildfly.common.iteration.ByteIterator;\n+import org.wildfly.security.password.Password;\n+import org.wildfly.security.password.PasswordFactory;\n+import org.wildfly.security.password.WildFlyElytronPasswordProvider;\n+import org.wildfly.security.password.interfaces.DigestPassword;\n+import org.wildfly.security.password.interfaces.ScramDigestPassword;\n+import org.wildfly.security.password.spec.BasicPasswordSpecEncoding;\n+import org.wildfly.security.password.spec.DigestPasswordAlgorithmSpec;\n+import org.wildfly.security.password.spec.EncryptablePasswordSpec;\n+import org.wildfly.security.password.spec.IteratedSaltedPasswordAlgorithmSpec;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 10.0\n+ **/\n+public class UserTool {\n+   public static final String DEFAULT_USERS_PROPERTIES_FILE = \"users.properties\";\n+   public static final String DEFAULT_GROUPS_PROPERTIES_FILE = \"groups.properties\";\n+   public static final String DEFAULT_REALM_NAME = \"default\";\n+   public static final String DEFAULT_SERVER_ROOT = \"server\";\n+\n+   private static final List<String> DEFAULT_ALGORITHMS = Arrays.asList(\n+         ScramDigestPassword.ALGORITHM_SCRAM_SHA_1,\n+         ScramDigestPassword.ALGORITHM_SCRAM_SHA_256,\n+         ScramDigestPassword.ALGORITHM_SCRAM_SHA_384,\n+         ScramDigestPassword.ALGORITHM_SCRAM_SHA_512,\n+         DigestPassword.ALGORITHM_DIGEST_MD5,\n+         DigestPassword.ALGORITHM_DIGEST_SHA,\n+         DigestPassword.ALGORITHM_DIGEST_SHA_256,\n+         DigestPassword.ALGORITHM_DIGEST_SHA_384,\n+         DigestPassword.ALGORITHM_DIGEST_SHA_512\n+   );\n+\n+   private final Path serverRoot;\n+   private final Path usersFile;\n+   private final Path groupsFile;\n+   private Properties users = new Properties();\n+   private Properties groups = new Properties();\n+   private String realm = DEFAULT_REALM_NAME;\n+   private Boolean plainText = false;\n+\n+   public UserTool(String serverRoot) {\n+      this(serverRoot, DEFAULT_USERS_PROPERTIES_FILE, DEFAULT_GROUPS_PROPERTIES_FILE);\n+   }\n+\n+   public UserTool(String serverRoot, String usersFile, String groupsFile) {\n+      this(serverRoot != null ? Paths.get(serverRoot) : null,\n+            usersFile != null ? Paths.get(usersFile) : null,\n+            groupsFile != null ? Paths.get(groupsFile) : null);\n+   }\n+\n+   public UserTool(Path serverRoot, Path usersFile, Path groupsFile) {\n+      installSecurityProvider();\n+      if (serverRoot != null && serverRoot.isAbsolute()) {\n+         this.serverRoot = serverRoot;\n+      } else {\n+         String serverHome = System.getProperty(\"infinispan.server.home.path\");\n+         Path serverHomePath = serverHome == null ? Paths.get(\"\") : Paths.get(serverHome);\n+         if (serverRoot == null) {\n+            this.serverRoot = serverHomePath.resolve(\"server\");\n+         } else {\n+            this.serverRoot = serverHomePath.resolve(serverRoot);\n+         }\n+      }\n+\n+      if (usersFile == null) {\n+         this.usersFile = this.serverRoot.resolve(\"conf\").resolve(DEFAULT_USERS_PROPERTIES_FILE);\n+      } else if (usersFile.isAbsolute()) {\n+         this.usersFile = usersFile;\n+      } else {\n+         this.usersFile = this.serverRoot.resolve(\"conf\").resolve(usersFile);\n+      }\n+      if (groupsFile == null) {\n+         this.groupsFile = this.serverRoot.resolve(\"conf\").resolve(DEFAULT_GROUPS_PROPERTIES_FILE);\n+      } else if (groupsFile.isAbsolute()) {\n+         this.groupsFile = groupsFile;\n+      } else {\n+         this.groupsFile = this.serverRoot.resolve(\"conf\").resolve(groupsFile);\n+      }\n+      load();\n+   }\n+\n+   private void installSecurityProvider() {\n+      WildFlyElytronPasswordProvider instance = WildFlyElytronPasswordProvider.getInstance();\n+      if (java.security.Security.getProvider(instance.getName()) == null) {\n+         java.security.Security.insertProviderAt(instance, 1);\n+      }\n+   }\n+\n+   private void load() {\n+      if (Files.exists(usersFile)) {\n+         try (Reader reader = Files.newBufferedReader(usersFile)) {\n+            users.load(reader);\n+            // TODO: detect REALM_NAME and ALGORITHM", "originalCommit": "fffda63dbb83ab653197c281f0d0f08be74fb270", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU0NjU0NQ==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r426546545", "bodyText": "No, I've made it so that you cannot add encrypted users to a clear-text password file and vice-versa. I've also added an encrypt-all subcommand which converts a clear-text file to encrypted in one fell swoop", "author": "tristantarrant", "createdAt": "2020-05-18T11:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMTU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxNDQwNQ==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r426014405", "bodyText": "can we have autocompletion?", "author": "pruivo", "createdAt": "2020-05-15T19:49:01Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/User.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package org.infinispan.cli.commands;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.util.List;\n+\n+import org.aesh.command.Command;\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandException;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Option;\n+import org.aesh.command.option.OptionList;\n+import org.aesh.readline.Prompt;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.user.UserTool;\n+import org.kohsuke.MetaInfServices;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+@MetaInfServices(Command.class)\n+@GroupCommandDefinition(name = User.CMD, description = \"User operations\", groupCommands = {User.Create.class, User.Describe.class, User.Remove.class, User.Modify.class, User.Ls.class})\n+public class User extends CliCommand {\n+\n+   public static final String CMD = \"user\";\n+\n+   @Option(shortName = 'h', hasValue = false)\n+   protected boolean help;\n+\n+   @Override\n+   public boolean isHelp() {\n+      return help;\n+   }\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+      // This command serves only to wrap the sub-commands\n+      invocation.println(invocation.getHelpInfo());\n+      return CommandResult.FAILURE;\n+   }\n+\n+   @CommandDefinition(name = Create.CMD, description = \"Creates a user\", aliases = \"add\")\n+   public static class Create extends CliCommand {\n+      public static final String CMD = \"create\";\n+\n+      @Argument(description = \"The username for the user\")\n+      String username;\n+\n+      @Option(description = \"The password for the user\", shortName = 'p')\n+      String password;\n+\n+      @Option(description = \"The realm \", defaultValue = UserTool.DEFAULT_REALM_NAME, shortName = 'r')\n+      String realm;\n+\n+      @OptionList(description = \"The algorithms used to encrypt the password\", shortName = 'a')", "originalCommit": "fffda63dbb83ab653197c281f0d0f08be74fb270", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxODE0Ng==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r426018146", "bodyText": "this may be a stupid question, but... are all the \"default\" algorithms supported?\n[disconnected]> user create test2 -a scram-sha-1 -p test2\n[disconnected]> connect -u test2 -p test2\nThe supplied credentials are invalid", "author": "pruivo", "createdAt": "2020-05-15T19:57:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxNDQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU4MDk2MQ==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r426580961", "bodyText": "Added completer.\nThe CLI uses the HTTP authentication mechs. SCRAM* mechs are for Hot Rod only", "author": "tristantarrant", "createdAt": "2020-05-18T12:15:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxNDQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAyMjYxNQ==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r426022615", "bodyText": "wdyt of splitting this subcommand in 2?\n\none for change password (set new password, encrypt with new algorithm)\nanother one for groups (add or remove groups)", "author": "pruivo", "createdAt": "2020-05-15T20:07:39Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/User.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package org.infinispan.cli.commands;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.util.List;\n+\n+import org.aesh.command.Command;\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandException;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Option;\n+import org.aesh.command.option.OptionList;\n+import org.aesh.readline.Prompt;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.user.UserTool;\n+import org.kohsuke.MetaInfServices;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+@MetaInfServices(Command.class)\n+@GroupCommandDefinition(name = User.CMD, description = \"User operations\", groupCommands = {User.Create.class, User.Describe.class, User.Remove.class, User.Modify.class, User.Ls.class})\n+public class User extends CliCommand {\n+\n+   public static final String CMD = \"user\";\n+\n+   @Option(shortName = 'h', hasValue = false)\n+   protected boolean help;\n+\n+   @Override\n+   public boolean isHelp() {\n+      return help;\n+   }\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+      // This command serves only to wrap the sub-commands\n+      invocation.println(invocation.getHelpInfo());\n+      return CommandResult.FAILURE;\n+   }\n+\n+   @CommandDefinition(name = Create.CMD, description = \"Creates a user\", aliases = \"add\")\n+   public static class Create extends CliCommand {\n+      public static final String CMD = \"create\";\n+\n+      @Argument(description = \"The username for the user\")\n+      String username;\n+\n+      @Option(description = \"The password for the user\", shortName = 'p')\n+      String password;\n+\n+      @Option(description = \"The realm \", defaultValue = UserTool.DEFAULT_REALM_NAME, shortName = 'r')\n+      String realm;\n+\n+      @OptionList(description = \"The algorithms used to encrypt the password\", shortName = 'a')\n+      List<String> algorithms;\n+\n+      @OptionList(description = \"The groups the user should belong to\", shortName = 'g')\n+      List<String> groups;\n+\n+      @Option(description = \"Whether the password should be stored in plain text (not recommended)\", name = \"plain-text\", hasValue = false)\n+      boolean plainText;\n+\n+      @Option(description = \"The path of the users.properties file\", name = \"users-file\", shortName = 'f')\n+      String usersFile;\n+\n+      @Option(description = \"The path of the groups.properties file\", name = \"groups-file\", shortName = 'w')\n+      String groupsFile;\n+\n+      @Option(description = \"The server root\", defaultValue = \"server\", name = \"server-root\", shortName= 's')\n+      String serverRoot;\n+\n+      @Option(shortName = 'h', hasValue = false)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      public CommandResult exec(ContextAwareCommandInvocation invocation) throws CommandException {\n+         UserTool userTool = new UserTool(serverRoot, usersFile, groupsFile);\n+         try {\n+            while (username == null || username.isEmpty()) {\n+               username = invocation.getShell().readLine(MSG.userToolUsername());\n+            }\n+         } catch (InterruptedException e) {\n+            return CommandResult.FAILURE;\n+         }\n+\n+         if (password == null) { // Get the password interactively\n+            try {\n+               while (password == null || password.isEmpty()) {\n+                  password = invocation.getShell().readLine(new Prompt(MSG.userToolPassword(), '*'));\n+               }\n+               String confirm = null;\n+               while (confirm == null || !confirm.equals(password)) {\n+                  confirm = invocation.getShell().readLine(new Prompt(MSG.userToolPasswordConfirm(), '*'));\n+               }\n+            } catch (InterruptedException e) {\n+               return CommandResult.FAILURE;\n+            }\n+         }\n+         userTool.createUser(username, password, realm, plainText, groups, algorithms);\n+         return CommandResult.SUCCESS;\n+      }\n+   }\n+\n+   @CommandDefinition(name = Describe.CMD, description = \"Describes a user\")\n+   public static class Describe extends CliCommand {\n+      public static final String CMD = \"describe\";\n+\n+      @Argument(description = \"The username for the user\", required = true)\n+      String username;\n+\n+      @Option(description = \"The path of the users.properties file\", name = \"users-file\", shortName = 'f')\n+      String usersFile;\n+\n+      @Option(description = \"The path of the groups.properties file\", name = \"groups-file\", shortName = 'w')\n+      String groupsFile;\n+\n+      @Option(description = \"The server root\", defaultValue = \"server\", name = \"server-root\", shortName= 's')\n+      String serverRoot;\n+\n+      @Option(shortName = 'h', hasValue = false)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      public CommandResult exec(ContextAwareCommandInvocation invocation) throws CommandException {\n+         UserTool userTool = new UserTool(serverRoot, usersFile, groupsFile);\n+         invocation.getShell().writeln(userTool.describeUser(username));\n+         return CommandResult.SUCCESS;\n+      }\n+   }\n+\n+   @CommandDefinition(name = Remove.CMD, description = \"Removes a user\", aliases = \"rm\")\n+   public static class Remove extends CliCommand {\n+      public static final String CMD = \"remove\";\n+\n+      @Argument(description = \"The username for the user\", required = true)\n+      String username;\n+\n+      @Option(description = \"The path of the users.properties file\", name = \"users-file\", shortName = 'f')\n+      String usersFile;\n+\n+      @Option(description = \"The path of the groups.properties file\", name = \"groups-file\", shortName = 'w')\n+      String groupsFile;\n+\n+      @Option(description = \"The server root\", defaultValue = \"server\", name = \"server-root\", shortName= 's')\n+      String serverRoot;\n+\n+      @Option(shortName = 'h', hasValue = false)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      public CommandResult exec(ContextAwareCommandInvocation invocation) throws CommandException {\n+         UserTool userTool = new UserTool(serverRoot, usersFile, groupsFile);\n+         userTool.removeUser(username);\n+         return CommandResult.SUCCESS;\n+      }\n+   }\n+\n+   @CommandDefinition(name = Modify.CMD, description = \"Modifies a user\")\n+   public static class Modify extends CliCommand {", "originalCommit": "fffda63dbb83ab653197c281f0d0f08be74fb270", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU0NTg4OA==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r426545888", "bodyText": "Good idea: I've done that.\nuser password will change a user's password\nuser groups will change the groups", "author": "tristantarrant", "createdAt": "2020-05-18T11:06:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAyMjYxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAyMzEzOQ==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r426023139", "bodyText": "can it fail if password and groups are null? (so, no change)", "author": "pruivo", "createdAt": "2020-05-15T20:09:00Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/User.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package org.infinispan.cli.commands;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.util.List;\n+\n+import org.aesh.command.Command;\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandException;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Option;\n+import org.aesh.command.option.OptionList;\n+import org.aesh.readline.Prompt;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.user.UserTool;\n+import org.kohsuke.MetaInfServices;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+@MetaInfServices(Command.class)\n+@GroupCommandDefinition(name = User.CMD, description = \"User operations\", groupCommands = {User.Create.class, User.Describe.class, User.Remove.class, User.Modify.class, User.Ls.class})\n+public class User extends CliCommand {\n+\n+   public static final String CMD = \"user\";\n+\n+   @Option(shortName = 'h', hasValue = false)\n+   protected boolean help;\n+\n+   @Override\n+   public boolean isHelp() {\n+      return help;\n+   }\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+      // This command serves only to wrap the sub-commands\n+      invocation.println(invocation.getHelpInfo());\n+      return CommandResult.FAILURE;\n+   }\n+\n+   @CommandDefinition(name = Create.CMD, description = \"Creates a user\", aliases = \"add\")\n+   public static class Create extends CliCommand {\n+      public static final String CMD = \"create\";\n+\n+      @Argument(description = \"The username for the user\")\n+      String username;\n+\n+      @Option(description = \"The password for the user\", shortName = 'p')\n+      String password;\n+\n+      @Option(description = \"The realm \", defaultValue = UserTool.DEFAULT_REALM_NAME, shortName = 'r')\n+      String realm;\n+\n+      @OptionList(description = \"The algorithms used to encrypt the password\", shortName = 'a')\n+      List<String> algorithms;\n+\n+      @OptionList(description = \"The groups the user should belong to\", shortName = 'g')\n+      List<String> groups;\n+\n+      @Option(description = \"Whether the password should be stored in plain text (not recommended)\", name = \"plain-text\", hasValue = false)\n+      boolean plainText;\n+\n+      @Option(description = \"The path of the users.properties file\", name = \"users-file\", shortName = 'f')\n+      String usersFile;\n+\n+      @Option(description = \"The path of the groups.properties file\", name = \"groups-file\", shortName = 'w')\n+      String groupsFile;\n+\n+      @Option(description = \"The server root\", defaultValue = \"server\", name = \"server-root\", shortName= 's')\n+      String serverRoot;\n+\n+      @Option(shortName = 'h', hasValue = false)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      public CommandResult exec(ContextAwareCommandInvocation invocation) throws CommandException {\n+         UserTool userTool = new UserTool(serverRoot, usersFile, groupsFile);\n+         try {\n+            while (username == null || username.isEmpty()) {\n+               username = invocation.getShell().readLine(MSG.userToolUsername());\n+            }\n+         } catch (InterruptedException e) {\n+            return CommandResult.FAILURE;\n+         }\n+\n+         if (password == null) { // Get the password interactively\n+            try {\n+               while (password == null || password.isEmpty()) {\n+                  password = invocation.getShell().readLine(new Prompt(MSG.userToolPassword(), '*'));\n+               }\n+               String confirm = null;\n+               while (confirm == null || !confirm.equals(password)) {\n+                  confirm = invocation.getShell().readLine(new Prompt(MSG.userToolPasswordConfirm(), '*'));\n+               }\n+            } catch (InterruptedException e) {\n+               return CommandResult.FAILURE;\n+            }\n+         }\n+         userTool.createUser(username, password, realm, plainText, groups, algorithms);\n+         return CommandResult.SUCCESS;\n+      }\n+   }\n+\n+   @CommandDefinition(name = Describe.CMD, description = \"Describes a user\")\n+   public static class Describe extends CliCommand {\n+      public static final String CMD = \"describe\";\n+\n+      @Argument(description = \"The username for the user\", required = true)\n+      String username;\n+\n+      @Option(description = \"The path of the users.properties file\", name = \"users-file\", shortName = 'f')\n+      String usersFile;\n+\n+      @Option(description = \"The path of the groups.properties file\", name = \"groups-file\", shortName = 'w')\n+      String groupsFile;\n+\n+      @Option(description = \"The server root\", defaultValue = \"server\", name = \"server-root\", shortName= 's')\n+      String serverRoot;\n+\n+      @Option(shortName = 'h', hasValue = false)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      public CommandResult exec(ContextAwareCommandInvocation invocation) throws CommandException {\n+         UserTool userTool = new UserTool(serverRoot, usersFile, groupsFile);\n+         invocation.getShell().writeln(userTool.describeUser(username));\n+         return CommandResult.SUCCESS;\n+      }\n+   }\n+\n+   @CommandDefinition(name = Remove.CMD, description = \"Removes a user\", aliases = \"rm\")\n+   public static class Remove extends CliCommand {\n+      public static final String CMD = \"remove\";\n+\n+      @Argument(description = \"The username for the user\", required = true)\n+      String username;\n+\n+      @Option(description = \"The path of the users.properties file\", name = \"users-file\", shortName = 'f')\n+      String usersFile;\n+\n+      @Option(description = \"The path of the groups.properties file\", name = \"groups-file\", shortName = 'w')\n+      String groupsFile;\n+\n+      @Option(description = \"The server root\", defaultValue = \"server\", name = \"server-root\", shortName= 's')\n+      String serverRoot;\n+\n+      @Option(shortName = 'h', hasValue = false)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      public CommandResult exec(ContextAwareCommandInvocation invocation) throws CommandException {\n+         UserTool userTool = new UserTool(serverRoot, usersFile, groupsFile);\n+         userTool.removeUser(username);\n+         return CommandResult.SUCCESS;\n+      }\n+   }\n+\n+   @CommandDefinition(name = Modify.CMD, description = \"Modifies a user\")\n+   public static class Modify extends CliCommand {\n+      public static final String CMD = \"modify\";\n+\n+      @Argument(description = \"The username for the user\", required = true)\n+      String username;\n+\n+      @Option(description = \"The password for the user\", shortName = 'p')\n+      String password;\n+\n+      @Option(description = \"The realm \", defaultValue = UserTool.DEFAULT_REALM_NAME, shortName = 'r')\n+      String realm;\n+\n+      @OptionList(description = \"The algorithms used to encrypt the password\", shortName = 'a')\n+      List<String> algorithms;\n+\n+      @OptionList(description = \"The groups the user should belong to\", shortName = 'g')\n+      List<String> groups;\n+\n+      @Option(description = \"Whether the password should be stored in plain text\", name = \"plain-text\")\n+      boolean plainText;\n+\n+      @Option(description = \"The path of the users.properties file\", name = \"users-file\", shortName = 'f')\n+      String usersFile;\n+\n+      @Option(description = \"The path of the groups.properties file\", name = \"groups-file\", shortName = 'w')\n+      String groupsFile;\n+\n+      @Option(description = \"The server root\", defaultValue = \"server\", name = \"server-root\", shortName= 's')\n+      String serverRoot;\n+\n+      @Option(shortName = 'h', hasValue = false)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      public CommandResult exec(ContextAwareCommandInvocation invocation) throws CommandException {\n+         UserTool userTool = new UserTool(serverRoot, usersFile, groupsFile);", "originalCommit": "fffda63dbb83ab653197c281f0d0f08be74fb270", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU4MTQwMQ==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r426581401", "bodyText": "Splitting the command makes this moot", "author": "tristantarrant", "createdAt": "2020-05-18T12:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAyMzEzOQ=="}], "type": "inlineReview"}, {"oid": "b55d42b45c259641c6eee9fbdae40e6fa7586840", "url": "https://github.com/infinispan/infinispan/commit/b55d42b45c259641c6eee9fbdae40e6fa7586840", "message": "ISPN-11838 Native CLI", "committedDate": "2020-05-18T11:04:04Z", "type": "forcePushed"}, {"oid": "714cc4f74379295aace14074dbecfd21630d2174", "url": "https://github.com/infinispan/infinispan/commit/714cc4f74379295aace14074dbecfd21630d2174", "message": "ISPN-11838 Native CLI", "committedDate": "2020-05-18T11:12:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3OTM4Mg==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r426779382", "bodyText": "shouldn't be Encryption.ENCRYPTED?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     store(realm, encryption);\n          \n          \n            \n                     store(realm, Encryption.ENCRYPTED);", "author": "pruivo", "createdAt": "2020-05-18T17:18:06Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/user/UserTool.java", "diffHunk": "@@ -0,0 +1,370 @@\n+package org.infinispan.cli.user;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Properties;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.cli.logging.Messages;\n+import org.wildfly.common.iteration.ByteIterator;\n+import org.wildfly.common.iteration.CodePointIterator;\n+import org.wildfly.security.password.Password;\n+import org.wildfly.security.password.PasswordFactory;\n+import org.wildfly.security.password.WildFlyElytronPasswordProvider;\n+import org.wildfly.security.password.interfaces.DigestPassword;\n+import org.wildfly.security.password.interfaces.ScramDigestPassword;\n+import org.wildfly.security.password.spec.BasicPasswordSpecEncoding;\n+import org.wildfly.security.password.spec.DigestPasswordAlgorithmSpec;\n+import org.wildfly.security.password.spec.EncryptablePasswordSpec;\n+import org.wildfly.security.password.spec.IteratedSaltedPasswordAlgorithmSpec;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 10.0\n+ **/\n+public class UserTool {\n+   public static final String DEFAULT_USERS_PROPERTIES_FILE = \"users.properties\";\n+   public static final String DEFAULT_GROUPS_PROPERTIES_FILE = \"groups.properties\";\n+   public static final String DEFAULT_REALM_NAME = \"default\";\n+   public static final String DEFAULT_SERVER_ROOT = \"server\";\n+\n+   private static final String COMMENT_PREFIX1 = \"#\";\n+   private static final String COMMENT_PREFIX2 = \"!\";\n+   private static final String REALM_COMMENT_PREFIX = \"$REALM_NAME=\";\n+   private static final String COMMENT_SUFFIX = \"$\";\n+   private static final String ALGORITHM_COMMENT_PREFIX = \"$ALGORITHM=\";\n+\n+\n+   public static final List<String> DEFAULT_ALGORITHMS = Arrays.asList(\n+         ScramDigestPassword.ALGORITHM_SCRAM_SHA_1,\n+         ScramDigestPassword.ALGORITHM_SCRAM_SHA_256,\n+         ScramDigestPassword.ALGORITHM_SCRAM_SHA_384,\n+         ScramDigestPassword.ALGORITHM_SCRAM_SHA_512,\n+         DigestPassword.ALGORITHM_DIGEST_MD5,\n+         DigestPassword.ALGORITHM_DIGEST_SHA,\n+         DigestPassword.ALGORITHM_DIGEST_SHA_256,\n+         DigestPassword.ALGORITHM_DIGEST_SHA_384,\n+         DigestPassword.ALGORITHM_DIGEST_SHA_512\n+   );\n+\n+   private final Path serverRoot;\n+   private final Path usersFile;\n+   private final Path groupsFile;\n+   private Properties users = new Properties();\n+   private Properties groups = new Properties();\n+   private String realm = null;\n+   private Encryption encryption = Encryption.DEFAULT;\n+\n+   public UserTool(String serverRoot) {\n+      this(serverRoot, DEFAULT_USERS_PROPERTIES_FILE, DEFAULT_GROUPS_PROPERTIES_FILE);\n+   }\n+\n+   public UserTool(String serverRoot, String usersFile, String groupsFile) {\n+      this(serverRoot != null ? Paths.get(serverRoot) : null,\n+            usersFile != null ? Paths.get(usersFile) : null,\n+            groupsFile != null ? Paths.get(groupsFile) : null);\n+   }\n+\n+   public UserTool(Path serverRoot, Path usersFile, Path groupsFile) {\n+      installSecurityProvider();\n+      if (serverRoot != null && serverRoot.isAbsolute()) {\n+         this.serverRoot = serverRoot;\n+      } else {\n+         String serverHome = System.getProperty(\"infinispan.server.home.path\");\n+         Path serverHomePath = serverHome == null ? Paths.get(\"\") : Paths.get(serverHome);\n+         if (serverRoot == null) {\n+            this.serverRoot = serverHomePath.resolve(\"server\");\n+         } else {\n+            this.serverRoot = serverHomePath.resolve(serverRoot);\n+         }\n+      }\n+\n+      if (usersFile == null) {\n+         this.usersFile = this.serverRoot.resolve(\"conf\").resolve(DEFAULT_USERS_PROPERTIES_FILE);\n+      } else if (usersFile.isAbsolute()) {\n+         this.usersFile = usersFile;\n+      } else {\n+         this.usersFile = this.serverRoot.resolve(\"conf\").resolve(usersFile);\n+      }\n+      if (groupsFile == null) {\n+         this.groupsFile = this.serverRoot.resolve(\"conf\").resolve(DEFAULT_GROUPS_PROPERTIES_FILE);\n+      } else if (groupsFile.isAbsolute()) {\n+         this.groupsFile = groupsFile;\n+      } else {\n+         this.groupsFile = this.serverRoot.resolve(\"conf\").resolve(groupsFile);\n+      }\n+      load();\n+   }\n+\n+   private void installSecurityProvider() {\n+      WildFlyElytronPasswordProvider instance = WildFlyElytronPasswordProvider.getInstance();\n+      if (java.security.Security.getProvider(instance.getName()) == null) {\n+         java.security.Security.insertProviderAt(instance, 1);\n+      }\n+   }\n+\n+\n+   public void reload() {\n+      this.realm = null;\n+      this.encryption = Encryption.DEFAULT;\n+      load();\n+   }\n+\n+   private void load() {\n+      if (Files.exists(usersFile)) {\n+         try (BufferedReader reader = Files.newBufferedReader(usersFile, StandardCharsets.UTF_8)) {\n+            String currentLine;\n+            while ((currentLine = reader.readLine()) != null) {\n+               final String trimmed = currentLine.trim();\n+               if (trimmed.startsWith(COMMENT_PREFIX1) && trimmed.contains(REALM_COMMENT_PREFIX)) {\n+                  // this is the line that contains the realm name.\n+                  int start = trimmed.indexOf(REALM_COMMENT_PREFIX) + REALM_COMMENT_PREFIX.length();\n+                  int end = trimmed.indexOf(COMMENT_SUFFIX, start);\n+                  if (end > -1) {\n+                     realm = trimmed.substring(start, end);\n+                  }\n+               } else if (trimmed.startsWith(COMMENT_PREFIX1) && trimmed.contains(ALGORITHM_COMMENT_PREFIX)) {\n+                  // this is the line that contains the algorithm name.\n+                  int start = trimmed.indexOf(ALGORITHM_COMMENT_PREFIX) + ALGORITHM_COMMENT_PREFIX.length();\n+                  int end = trimmed.indexOf(COMMENT_SUFFIX, start);\n+                  if (end > -1) {\n+                     encryption = Encryption.valueOf(trimmed.substring(start, end).toUpperCase());\n+                  }\n+               } else {\n+                  if (!(trimmed.startsWith(COMMENT_PREFIX1) || trimmed.startsWith(COMMENT_PREFIX2))) {\n+                     String username = null;\n+                     StringBuilder builder = new StringBuilder();\n+\n+                     CodePointIterator it = CodePointIterator.ofString(trimmed);\n+                     while (it.hasNext()) {\n+                        int cp = it.next();\n+                        if (cp == '\\\\' && it.hasNext()) { // escape\n+                           //might be regular escape of regex like characters \\\\t \\\\! or unicode \\\\uxxxx\n+                           int marker = it.next();\n+                           if (marker != 'u') {\n+                              builder.appendCodePoint(marker);\n+                           } else {\n+                              StringBuilder hex = new StringBuilder();\n+                              try {\n+                                 hex.appendCodePoint(it.next());\n+                                 hex.appendCodePoint(it.next());\n+                                 hex.appendCodePoint(it.next());\n+                                 hex.appendCodePoint(it.next());\n+                                 builder.appendCodePoint((char) Integer.parseInt(hex.toString(), 16));\n+                              } catch (NoSuchElementException nsee) {\n+                                 throw Messages.MSG.invalidUnicodeSequence(hex.toString(), nsee);\n+                              }\n+                           }\n+                        } else if (username == null && (cp == '=' || cp == ':')) { // username-password delimiter\n+                           username = builder.toString().trim();\n+                           builder = new StringBuilder();\n+                        } else {\n+                           builder.appendCodePoint(cp);\n+                        }\n+                     }\n+                     if (username != null) { // end of line and delimiter was read\n+                        users.setProperty(username, builder.toString());\n+                     }\n+                  }\n+               }\n+            }\n+         } catch (IOException e) {\n+            throw MSG.userToolIOError(usersFile, e);\n+         }\n+      }\n+      if (Files.exists(groupsFile)) {\n+         try (Reader reader = Files.newBufferedReader(groupsFile)) {\n+            groups.load(reader);\n+         } catch (IOException e) {\n+            throw MSG.userToolIOError(groupsFile, e);\n+         }\n+      }\n+   }\n+\n+   private void store() {\n+      store(this.realm, this.encryption);\n+   }\n+\n+   private void store(String realm, Encryption encryption) {\n+      encryption = checkAlgorithm(encryption);\n+      if (realm == null) {\n+         realm = this.realm;\n+      }\n+      try (Writer writer = Files.newBufferedWriter(usersFile, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         users.store(writer, REALM_COMMENT_PREFIX + realm + COMMENT_SUFFIX + \"\\n\" + ALGORITHM_COMMENT_PREFIX + (encryption == Encryption.CLEAR ? \"clear\" : \"encrypted\") + COMMENT_SUFFIX);\n+      } catch (IOException e) {\n+         throw MSG.userToolIOError(usersFile, e);\n+      }\n+      try (Writer writer = Files.newBufferedWriter(groupsFile, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         groups.store(writer, null);\n+      } catch (IOException e) {\n+         throw MSG.userToolIOError(groupsFile, e);\n+      }\n+   }\n+\n+   private Encryption checkAlgorithm(Encryption encryption) {\n+      if (encryption == Encryption.DEFAULT) {\n+         // Not forcing anything, use what the current user.properties file specifies or the default\n+         return this.encryption;\n+      } else {\n+         if (this.encryption == Encryption.DEFAULT) {\n+            // We can override the default\n+            return encryption;\n+         } else if (this.encryption == encryption) {\n+            // Compatible\n+            return encryption;\n+         } else {\n+            throw MSG.userToolIncompatibleEncrypyion(encryption, this.encryption);\n+         }\n+      }\n+   }\n+\n+   public String checkRealm(String realm) {\n+      if (realm == null) {\n+         return this.realm == null ? DEFAULT_REALM_NAME : this.realm;\n+      } else {\n+         if (this.realm == null || this.realm.equals(realm)) {\n+            return realm;\n+         } else {\n+            throw MSG.userToolWrongRealm(realm, this.realm);\n+         }\n+      }\n+   }\n+\n+   public void createUser(String username, String password, String realm, Encryption encryption, List<String> userGroups, List<String> algorithms) {\n+      if (users.containsKey(username)) {\n+         throw MSG.userToolUserExists(username);\n+      }\n+      realm = checkRealm(realm);\n+      users.put(username, Encryption.CLEAR.equals(encryption) ? password : encryptPassword(username, realm, password, algorithms));\n+      groups.put(username, userGroups != null ? String.join(\",\", userGroups) : \"\");\n+      store(realm, encryption);\n+   }\n+\n+   public String describeUser(String username) {\n+      if (users.containsKey(username)) {\n+         String[] userGroups = groups.containsKey(username) ? groups.getProperty(username).trim().split(\"\\\\s*,\\\\s*\") : new String[]{};\n+         return MSG.userDescribe(username, realm, userGroups);\n+      } else {\n+         throw MSG.userToolNoSuchUser(username);\n+      }\n+   }\n+\n+   public void removeUser(String username) {\n+      users.remove(username);\n+      groups.remove(username);\n+      store();\n+   }\n+\n+   public void modifyUser(String username, String password, String realm, Encryption encryption, List<String> userGroups, List<String> algorithms) {\n+      if (!users.containsKey(username)) {\n+         throw MSG.userToolNoSuchUser(username);\n+      } else {\n+         realm = checkRealm(realm);\n+         if (password != null) { // change password\n+            users.put(username, Encryption.CLEAR.equals(encryption) ? password : encryptPassword(username, realm, password, algorithms));\n+         }\n+         if (userGroups != null) { // change groups\n+            groups.put(username, String.join(\",\", userGroups));\n+         }\n+         store(realm, encryption);\n+      }\n+   }\n+\n+   public void encryptAll(List<String> algorithms) {\n+      if (this.encryption == Encryption.CLEAR) {\n+         users.replaceAll((u, p) -> encryptPassword((String) u, realm, (String) p, algorithms));\n+         store(realm, encryption);", "originalCommit": "714cc4f74379295aace14074dbecfd21630d2174", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc4Mjc4Mw==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r426782783", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               private Encryption checkAlgorithm(Encryption encryption) {\n          \n          \n            \n               private Encryption checkEncryption(Encryption encryption) {", "author": "pruivo", "createdAt": "2020-05-18T17:24:20Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/user/UserTool.java", "diffHunk": "@@ -0,0 +1,370 @@\n+package org.infinispan.cli.user;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Properties;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.cli.logging.Messages;\n+import org.wildfly.common.iteration.ByteIterator;\n+import org.wildfly.common.iteration.CodePointIterator;\n+import org.wildfly.security.password.Password;\n+import org.wildfly.security.password.PasswordFactory;\n+import org.wildfly.security.password.WildFlyElytronPasswordProvider;\n+import org.wildfly.security.password.interfaces.DigestPassword;\n+import org.wildfly.security.password.interfaces.ScramDigestPassword;\n+import org.wildfly.security.password.spec.BasicPasswordSpecEncoding;\n+import org.wildfly.security.password.spec.DigestPasswordAlgorithmSpec;\n+import org.wildfly.security.password.spec.EncryptablePasswordSpec;\n+import org.wildfly.security.password.spec.IteratedSaltedPasswordAlgorithmSpec;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 10.0\n+ **/\n+public class UserTool {\n+   public static final String DEFAULT_USERS_PROPERTIES_FILE = \"users.properties\";\n+   public static final String DEFAULT_GROUPS_PROPERTIES_FILE = \"groups.properties\";\n+   public static final String DEFAULT_REALM_NAME = \"default\";\n+   public static final String DEFAULT_SERVER_ROOT = \"server\";\n+\n+   private static final String COMMENT_PREFIX1 = \"#\";\n+   private static final String COMMENT_PREFIX2 = \"!\";\n+   private static final String REALM_COMMENT_PREFIX = \"$REALM_NAME=\";\n+   private static final String COMMENT_SUFFIX = \"$\";\n+   private static final String ALGORITHM_COMMENT_PREFIX = \"$ALGORITHM=\";\n+\n+\n+   public static final List<String> DEFAULT_ALGORITHMS = Arrays.asList(\n+         ScramDigestPassword.ALGORITHM_SCRAM_SHA_1,\n+         ScramDigestPassword.ALGORITHM_SCRAM_SHA_256,\n+         ScramDigestPassword.ALGORITHM_SCRAM_SHA_384,\n+         ScramDigestPassword.ALGORITHM_SCRAM_SHA_512,\n+         DigestPassword.ALGORITHM_DIGEST_MD5,\n+         DigestPassword.ALGORITHM_DIGEST_SHA,\n+         DigestPassword.ALGORITHM_DIGEST_SHA_256,\n+         DigestPassword.ALGORITHM_DIGEST_SHA_384,\n+         DigestPassword.ALGORITHM_DIGEST_SHA_512\n+   );\n+\n+   private final Path serverRoot;\n+   private final Path usersFile;\n+   private final Path groupsFile;\n+   private Properties users = new Properties();\n+   private Properties groups = new Properties();\n+   private String realm = null;\n+   private Encryption encryption = Encryption.DEFAULT;\n+\n+   public UserTool(String serverRoot) {\n+      this(serverRoot, DEFAULT_USERS_PROPERTIES_FILE, DEFAULT_GROUPS_PROPERTIES_FILE);\n+   }\n+\n+   public UserTool(String serverRoot, String usersFile, String groupsFile) {\n+      this(serverRoot != null ? Paths.get(serverRoot) : null,\n+            usersFile != null ? Paths.get(usersFile) : null,\n+            groupsFile != null ? Paths.get(groupsFile) : null);\n+   }\n+\n+   public UserTool(Path serverRoot, Path usersFile, Path groupsFile) {\n+      installSecurityProvider();\n+      if (serverRoot != null && serverRoot.isAbsolute()) {\n+         this.serverRoot = serverRoot;\n+      } else {\n+         String serverHome = System.getProperty(\"infinispan.server.home.path\");\n+         Path serverHomePath = serverHome == null ? Paths.get(\"\") : Paths.get(serverHome);\n+         if (serverRoot == null) {\n+            this.serverRoot = serverHomePath.resolve(\"server\");\n+         } else {\n+            this.serverRoot = serverHomePath.resolve(serverRoot);\n+         }\n+      }\n+\n+      if (usersFile == null) {\n+         this.usersFile = this.serverRoot.resolve(\"conf\").resolve(DEFAULT_USERS_PROPERTIES_FILE);\n+      } else if (usersFile.isAbsolute()) {\n+         this.usersFile = usersFile;\n+      } else {\n+         this.usersFile = this.serverRoot.resolve(\"conf\").resolve(usersFile);\n+      }\n+      if (groupsFile == null) {\n+         this.groupsFile = this.serverRoot.resolve(\"conf\").resolve(DEFAULT_GROUPS_PROPERTIES_FILE);\n+      } else if (groupsFile.isAbsolute()) {\n+         this.groupsFile = groupsFile;\n+      } else {\n+         this.groupsFile = this.serverRoot.resolve(\"conf\").resolve(groupsFile);\n+      }\n+      load();\n+   }\n+\n+   private void installSecurityProvider() {\n+      WildFlyElytronPasswordProvider instance = WildFlyElytronPasswordProvider.getInstance();\n+      if (java.security.Security.getProvider(instance.getName()) == null) {\n+         java.security.Security.insertProviderAt(instance, 1);\n+      }\n+   }\n+\n+\n+   public void reload() {\n+      this.realm = null;\n+      this.encryption = Encryption.DEFAULT;\n+      load();\n+   }\n+\n+   private void load() {\n+      if (Files.exists(usersFile)) {\n+         try (BufferedReader reader = Files.newBufferedReader(usersFile, StandardCharsets.UTF_8)) {\n+            String currentLine;\n+            while ((currentLine = reader.readLine()) != null) {\n+               final String trimmed = currentLine.trim();\n+               if (trimmed.startsWith(COMMENT_PREFIX1) && trimmed.contains(REALM_COMMENT_PREFIX)) {\n+                  // this is the line that contains the realm name.\n+                  int start = trimmed.indexOf(REALM_COMMENT_PREFIX) + REALM_COMMENT_PREFIX.length();\n+                  int end = trimmed.indexOf(COMMENT_SUFFIX, start);\n+                  if (end > -1) {\n+                     realm = trimmed.substring(start, end);\n+                  }\n+               } else if (trimmed.startsWith(COMMENT_PREFIX1) && trimmed.contains(ALGORITHM_COMMENT_PREFIX)) {\n+                  // this is the line that contains the algorithm name.\n+                  int start = trimmed.indexOf(ALGORITHM_COMMENT_PREFIX) + ALGORITHM_COMMENT_PREFIX.length();\n+                  int end = trimmed.indexOf(COMMENT_SUFFIX, start);\n+                  if (end > -1) {\n+                     encryption = Encryption.valueOf(trimmed.substring(start, end).toUpperCase());\n+                  }\n+               } else {\n+                  if (!(trimmed.startsWith(COMMENT_PREFIX1) || trimmed.startsWith(COMMENT_PREFIX2))) {\n+                     String username = null;\n+                     StringBuilder builder = new StringBuilder();\n+\n+                     CodePointIterator it = CodePointIterator.ofString(trimmed);\n+                     while (it.hasNext()) {\n+                        int cp = it.next();\n+                        if (cp == '\\\\' && it.hasNext()) { // escape\n+                           //might be regular escape of regex like characters \\\\t \\\\! or unicode \\\\uxxxx\n+                           int marker = it.next();\n+                           if (marker != 'u') {\n+                              builder.appendCodePoint(marker);\n+                           } else {\n+                              StringBuilder hex = new StringBuilder();\n+                              try {\n+                                 hex.appendCodePoint(it.next());\n+                                 hex.appendCodePoint(it.next());\n+                                 hex.appendCodePoint(it.next());\n+                                 hex.appendCodePoint(it.next());\n+                                 builder.appendCodePoint((char) Integer.parseInt(hex.toString(), 16));\n+                              } catch (NoSuchElementException nsee) {\n+                                 throw Messages.MSG.invalidUnicodeSequence(hex.toString(), nsee);\n+                              }\n+                           }\n+                        } else if (username == null && (cp == '=' || cp == ':')) { // username-password delimiter\n+                           username = builder.toString().trim();\n+                           builder = new StringBuilder();\n+                        } else {\n+                           builder.appendCodePoint(cp);\n+                        }\n+                     }\n+                     if (username != null) { // end of line and delimiter was read\n+                        users.setProperty(username, builder.toString());\n+                     }\n+                  }\n+               }\n+            }\n+         } catch (IOException e) {\n+            throw MSG.userToolIOError(usersFile, e);\n+         }\n+      }\n+      if (Files.exists(groupsFile)) {\n+         try (Reader reader = Files.newBufferedReader(groupsFile)) {\n+            groups.load(reader);\n+         } catch (IOException e) {\n+            throw MSG.userToolIOError(groupsFile, e);\n+         }\n+      }\n+   }\n+\n+   private void store() {\n+      store(this.realm, this.encryption);\n+   }\n+\n+   private void store(String realm, Encryption encryption) {\n+      encryption = checkAlgorithm(encryption);\n+      if (realm == null) {\n+         realm = this.realm;\n+      }\n+      try (Writer writer = Files.newBufferedWriter(usersFile, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         users.store(writer, REALM_COMMENT_PREFIX + realm + COMMENT_SUFFIX + \"\\n\" + ALGORITHM_COMMENT_PREFIX + (encryption == Encryption.CLEAR ? \"clear\" : \"encrypted\") + COMMENT_SUFFIX);\n+      } catch (IOException e) {\n+         throw MSG.userToolIOError(usersFile, e);\n+      }\n+      try (Writer writer = Files.newBufferedWriter(groupsFile, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         groups.store(writer, null);\n+      } catch (IOException e) {\n+         throw MSG.userToolIOError(groupsFile, e);\n+      }\n+   }\n+\n+   private Encryption checkAlgorithm(Encryption encryption) {", "originalCommit": "714cc4f74379295aace14074dbecfd21630d2174", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc4NjU1Mw==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r426786553", "bodyText": "well, you could have paid the cost of reading the file twice instead of writing / copying the parser.", "author": "pruivo", "createdAt": "2020-05-18T17:31:02Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/user/UserTool.java", "diffHunk": "@@ -0,0 +1,370 @@\n+package org.infinispan.cli.user;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Properties;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.cli.logging.Messages;\n+import org.wildfly.common.iteration.ByteIterator;\n+import org.wildfly.common.iteration.CodePointIterator;\n+import org.wildfly.security.password.Password;\n+import org.wildfly.security.password.PasswordFactory;\n+import org.wildfly.security.password.WildFlyElytronPasswordProvider;\n+import org.wildfly.security.password.interfaces.DigestPassword;\n+import org.wildfly.security.password.interfaces.ScramDigestPassword;\n+import org.wildfly.security.password.spec.BasicPasswordSpecEncoding;\n+import org.wildfly.security.password.spec.DigestPasswordAlgorithmSpec;\n+import org.wildfly.security.password.spec.EncryptablePasswordSpec;\n+import org.wildfly.security.password.spec.IteratedSaltedPasswordAlgorithmSpec;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 10.0\n+ **/\n+public class UserTool {\n+   public static final String DEFAULT_USERS_PROPERTIES_FILE = \"users.properties\";\n+   public static final String DEFAULT_GROUPS_PROPERTIES_FILE = \"groups.properties\";\n+   public static final String DEFAULT_REALM_NAME = \"default\";\n+   public static final String DEFAULT_SERVER_ROOT = \"server\";\n+\n+   private static final String COMMENT_PREFIX1 = \"#\";\n+   private static final String COMMENT_PREFIX2 = \"!\";\n+   private static final String REALM_COMMENT_PREFIX = \"$REALM_NAME=\";\n+   private static final String COMMENT_SUFFIX = \"$\";\n+   private static final String ALGORITHM_COMMENT_PREFIX = \"$ALGORITHM=\";\n+\n+\n+   public static final List<String> DEFAULT_ALGORITHMS = Arrays.asList(\n+         ScramDigestPassword.ALGORITHM_SCRAM_SHA_1,\n+         ScramDigestPassword.ALGORITHM_SCRAM_SHA_256,\n+         ScramDigestPassword.ALGORITHM_SCRAM_SHA_384,\n+         ScramDigestPassword.ALGORITHM_SCRAM_SHA_512,\n+         DigestPassword.ALGORITHM_DIGEST_MD5,\n+         DigestPassword.ALGORITHM_DIGEST_SHA,\n+         DigestPassword.ALGORITHM_DIGEST_SHA_256,\n+         DigestPassword.ALGORITHM_DIGEST_SHA_384,\n+         DigestPassword.ALGORITHM_DIGEST_SHA_512\n+   );\n+\n+   private final Path serverRoot;\n+   private final Path usersFile;\n+   private final Path groupsFile;\n+   private Properties users = new Properties();\n+   private Properties groups = new Properties();\n+   private String realm = null;\n+   private Encryption encryption = Encryption.DEFAULT;\n+\n+   public UserTool(String serverRoot) {\n+      this(serverRoot, DEFAULT_USERS_PROPERTIES_FILE, DEFAULT_GROUPS_PROPERTIES_FILE);\n+   }\n+\n+   public UserTool(String serverRoot, String usersFile, String groupsFile) {\n+      this(serverRoot != null ? Paths.get(serverRoot) : null,\n+            usersFile != null ? Paths.get(usersFile) : null,\n+            groupsFile != null ? Paths.get(groupsFile) : null);\n+   }\n+\n+   public UserTool(Path serverRoot, Path usersFile, Path groupsFile) {\n+      installSecurityProvider();\n+      if (serverRoot != null && serverRoot.isAbsolute()) {\n+         this.serverRoot = serverRoot;\n+      } else {\n+         String serverHome = System.getProperty(\"infinispan.server.home.path\");\n+         Path serverHomePath = serverHome == null ? Paths.get(\"\") : Paths.get(serverHome);\n+         if (serverRoot == null) {\n+            this.serverRoot = serverHomePath.resolve(\"server\");\n+         } else {\n+            this.serverRoot = serverHomePath.resolve(serverRoot);\n+         }\n+      }\n+\n+      if (usersFile == null) {\n+         this.usersFile = this.serverRoot.resolve(\"conf\").resolve(DEFAULT_USERS_PROPERTIES_FILE);\n+      } else if (usersFile.isAbsolute()) {\n+         this.usersFile = usersFile;\n+      } else {\n+         this.usersFile = this.serverRoot.resolve(\"conf\").resolve(usersFile);\n+      }\n+      if (groupsFile == null) {\n+         this.groupsFile = this.serverRoot.resolve(\"conf\").resolve(DEFAULT_GROUPS_PROPERTIES_FILE);\n+      } else if (groupsFile.isAbsolute()) {\n+         this.groupsFile = groupsFile;\n+      } else {\n+         this.groupsFile = this.serverRoot.resolve(\"conf\").resolve(groupsFile);\n+      }\n+      load();\n+   }\n+\n+   private void installSecurityProvider() {\n+      WildFlyElytronPasswordProvider instance = WildFlyElytronPasswordProvider.getInstance();\n+      if (java.security.Security.getProvider(instance.getName()) == null) {\n+         java.security.Security.insertProviderAt(instance, 1);\n+      }\n+   }\n+\n+\n+   public void reload() {\n+      this.realm = null;\n+      this.encryption = Encryption.DEFAULT;\n+      load();\n+   }\n+\n+   private void load() {\n+      if (Files.exists(usersFile)) {\n+         try (BufferedReader reader = Files.newBufferedReader(usersFile, StandardCharsets.UTF_8)) {\n+            String currentLine;\n+            while ((currentLine = reader.readLine()) != null) {\n+               final String trimmed = currentLine.trim();\n+               if (trimmed.startsWith(COMMENT_PREFIX1) && trimmed.contains(REALM_COMMENT_PREFIX)) {\n+                  // this is the line that contains the realm name.\n+                  int start = trimmed.indexOf(REALM_COMMENT_PREFIX) + REALM_COMMENT_PREFIX.length();\n+                  int end = trimmed.indexOf(COMMENT_SUFFIX, start);\n+                  if (end > -1) {\n+                     realm = trimmed.substring(start, end);\n+                  }\n+               } else if (trimmed.startsWith(COMMENT_PREFIX1) && trimmed.contains(ALGORITHM_COMMENT_PREFIX)) {\n+                  // this is the line that contains the algorithm name.\n+                  int start = trimmed.indexOf(ALGORITHM_COMMENT_PREFIX) + ALGORITHM_COMMENT_PREFIX.length();\n+                  int end = trimmed.indexOf(COMMENT_SUFFIX, start);\n+                  if (end > -1) {\n+                     encryption = Encryption.valueOf(trimmed.substring(start, end).toUpperCase());\n+                  }\n+               } else {\n+                  if (!(trimmed.startsWith(COMMENT_PREFIX1) || trimmed.startsWith(COMMENT_PREFIX2))) {", "originalCommit": "714cc4f74379295aace14074dbecfd21630d2174", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA2NzY5Mg==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r427067692", "bodyText": "You mean one pass to find the comments and then use the standard properties loader ? True, but that code is what the actual realm loader uses, so it's tested and I feel safer :)", "author": "tristantarrant", "createdAt": "2020-05-19T06:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc4NjU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc5MDU3OA==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r426790578", "bodyText": "suggestion: add options to set the user/password so users could do:\n./bin/cli.sh -c - -u <user> -p <pass> [-f commands.cli]\nwdyt?", "author": "pruivo", "createdAt": "2020-05-18T17:38:41Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/CLI.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package org.infinispan.cli.commands;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.security.KeyStore;\n+\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+import org.aesh.AeshRuntimeRunner;\n+import org.aesh.command.AeshCommandRuntimeBuilder;\n+import org.aesh.command.Command;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.impl.completer.FileOptionCompleter;\n+import org.aesh.command.impl.registry.AeshCommandRegistryBuilder;\n+import org.aesh.command.invocation.CommandInvocation;\n+import org.aesh.command.option.Option;\n+import org.aesh.command.registry.CommandRegistry;\n+import org.aesh.command.registry.CommandRegistryException;\n+import org.aesh.command.settings.SettingsBuilder;\n+import org.aesh.command.shell.Shell;\n+import org.aesh.io.Resource;\n+import org.aesh.readline.ReadlineConsole;\n+import org.infinispan.cli.Context;\n+import org.infinispan.cli.activators.ContextAwareCommandActivatorProvider;\n+import org.infinispan.cli.completers.ContextAwareCompleterInvocationProvider;\n+import org.infinispan.cli.impl.AeshDelegatingShell;\n+import org.infinispan.cli.impl.CliCommandNotFoundHandler;\n+import org.infinispan.cli.impl.CliRuntimeRunner;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocationProvider;\n+import org.infinispan.cli.impl.ContextAwareQuitHandler;\n+import org.infinispan.cli.impl.ContextImpl;\n+import org.infinispan.cli.impl.DefaultShell;\n+import org.infinispan.cli.impl.SSLContextSettings;\n+import org.infinispan.cli.util.ZeroSecurityHostnameVerifier;\n+import org.infinispan.cli.util.ZeroSecurityTrustManager;\n+import org.infinispan.commons.util.ServiceFinder;\n+import org.wildfly.security.keystore.KeyStoreUtil;\n+import org.wildfly.security.provider.util.ProviderUtil;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+@GroupCommandDefinition(\n+      name = CLI.CMD,\n+      description = \"\",\n+      groupCommands = {\n+            Add.class,\n+            Cache.class,\n+            Cas.class,\n+            Cd.class,\n+            Clear.class,\n+            ClearCache.class,\n+            Connect.class,\n+            Container.class,\n+            Counter.class,\n+            Create.class,\n+            Describe.class,\n+            Disconnect.class,\n+            Drop.class,\n+            Echo.class,\n+            Encoding.class,\n+            Get.class,\n+            Ls.class,\n+            Patch.class,\n+            Put.class,\n+            Query.class,\n+            Remove.class,\n+            Replace.class,\n+            Reset.class,\n+            Run.class,\n+            Schema.class,\n+            Shutdown.class,\n+            Site.class,\n+            User.class,\n+            Version.class\n+      })\n+public class CLI extends CliCommand {\n+   public static final String CMD = \"cli\";\n+\n+   private Context context;\n+\n+   @Option(completer = FileOptionCompleter.class, shortName = 't', name = \"truststore\", description = \"A truststore to use when connecting to SSL/TLS-enabled servers\")\n+   Resource truststore;\n+\n+   @Option(shortName = 's', name = \"truststore-password\", description = \"The password for the truststore\")\n+   String truststorePassword;\n+\n+   @Option(shortName = 'v', hasValue = false, description = \"Shows version information\")\n+   boolean version;\n+\n+   @Option(hasValue = false, description = \"Whether to trust all certificates\", name = \"trustall\")\n+   boolean trustAll;\n+\n+   @Option(completer = FileOptionCompleter.class, shortName = 'f', description = \"File for batch mode\")\n+   Resource file;\n+\n+   @Option(shortName = 'c', description = \"A connection URL. Use '-' to connect to http://localhost:11222\")\n+   String connect;\n+\n+   @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+   protected boolean help;\n+\n+   @Override\n+   public boolean isHelp() {\n+      return help;\n+   }\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+      if (help) {\n+         invocation.println(invocation.getHelpInfo());\n+         return CommandResult.SUCCESS;\n+      }\n+      if (version) {\n+         invocation.printf(\"%s CLI %s\\n\", org.infinispan.commons.util.Version.getBrandName(), org.infinispan.commons.util.Version.getBrandVersion());\n+         invocation.printf(\"Copyright (C) Red Hat Inc. and/or its affiliates and other contributors\\n\");\n+         invocation.printf(\"License Apache License, v. 2.0. http://www.apache.org/licenses/LICENSE-2.0\\n\");\n+         return CommandResult.SUCCESS;\n+      }\n+\n+      context = invocation.getContext();\n+\n+      if (truststore != null) {\n+         try (FileInputStream f = new FileInputStream(truststore.getAbsolutePath())) {\n+            KeyStore keyStore = KeyStoreUtil.loadKeyStore(ProviderUtil.INSTALLED_PROVIDERS, null, f, truststore.getAbsolutePath(), truststorePassword.toCharArray());\n+            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+            trustManagerFactory.init(keyStore);\n+            SSLContextSettings sslContext = SSLContextSettings.getInstance(\"TLS\", null, trustManagerFactory.getTrustManagers(), null, null);\n+            context.setSslContext(sslContext);\n+         } catch (Exception e) {\n+            invocation.getShell().writeln(MSG.keyStoreError(truststore.getAbsolutePath(), e));\n+            return CommandResult.FAILURE;\n+         }\n+      } else if (trustAll) {\n+         SSLContextSettings sslContext = SSLContextSettings.getInstance(\"TLS\", null, new TrustManager[]{new ZeroSecurityTrustManager()}, null, new ZeroSecurityHostnameVerifier());\n+         context.setSslContext(sslContext);\n+      }\n+\n+      if (connect != null) {\n+         context.connect(null, connect);", "originalCommit": "714cc4f74379295aace14074dbecfd21630d2174", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA2ODgzNw==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r427068837", "bodyText": "Yet one more way to do cli.sh -c http://user:pass@localhost:11222 ?", "author": "tristantarrant", "createdAt": "2020-05-19T06:52:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc5MDU3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc5ODkyOA==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r426798928", "bodyText": "probably a limitation of aesh, but you can't use user groups -g <group> <user>\n[disconnected]> user groups -g abc pedro\nThe username for the user is required for this command.\n[disconnected]> user groups pedro -g abc", "author": "pruivo", "createdAt": "2020-05-18T17:54:21Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/User.java", "diffHunk": "@@ -0,0 +1,350 @@\n+package org.infinispan.cli.commands;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.util.List;\n+\n+import org.aesh.command.Command;\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandException;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Option;\n+import org.aesh.command.option.OptionList;\n+import org.aesh.readline.Prompt;\n+import org.infinispan.cli.completers.EncryptionAlgorithmCompleter;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.user.UserTool;\n+import org.kohsuke.MetaInfServices;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+@MetaInfServices(Command.class)\n+@GroupCommandDefinition(name = User.CMD, description = \"User operations\", groupCommands = {User.Create.class, User.Describe.class, User.Remove.class, User.Password.class, User.Groups.class, User.Ls.class, User.Encrypt.class})\n+public class User extends CliCommand {\n+\n+   public static final String CMD = \"user\";\n+\n+   @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+   protected boolean help;\n+\n+   @Override\n+   public boolean isHelp() {\n+      return help;\n+   }\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+      // This command serves only to wrap the sub-commands\n+      invocation.println(invocation.getHelpInfo());\n+      return CommandResult.FAILURE;\n+   }\n+\n+   static String getPasswordInteractively(ContextAwareCommandInvocation invocation) throws InterruptedException {\n+      String password = null;\n+      while (password == null || password.isEmpty()) {\n+         password = invocation.getShell().readLine(new Prompt(MSG.userToolPassword(), '*'));\n+      }\n+      String confirm = null;\n+      while (confirm == null || !confirm.equals(password)) {\n+         confirm = invocation.getShell().readLine(new Prompt(MSG.userToolPasswordConfirm(), '*'));\n+      }\n+      return password;\n+   }\n+\n+   @CommandDefinition(name = Create.CMD, description = \"Creates a user\", aliases = \"add\")\n+   public static class Create extends CliCommand {\n+      public static final String CMD = \"create\";\n+\n+      @Argument(description = \"The username for the user\")\n+      String username;\n+\n+      @Option(description = \"The password for the user\", shortName = 'p')\n+      String password;\n+\n+      @Option(description = \"The realm \", defaultValue = UserTool.DEFAULT_REALM_NAME, shortName = 'r')\n+      String realm;\n+\n+      @OptionList(description = \"The algorithms used to encrypt the password\", shortName = 'a', completer = EncryptionAlgorithmCompleter.class)\n+      List<String> algorithms;\n+\n+      @OptionList(description = \"The groups the user should belong to\", shortName = 'g')\n+      List<String> groups;\n+\n+      @Option(description = \"Whether the password should be stored in plain text (not recommended)\", name = \"plain-text\", hasValue = false)\n+      boolean plainText;\n+\n+      @Option(description = \"The path of the users.properties file\", name = \"users-file\", shortName = 'f')\n+      String usersFile;\n+\n+      @Option(description = \"The path of the groups.properties file\", name = \"groups-file\", shortName = 'w')\n+      String groupsFile;\n+\n+      @Option(description = \"The server root\", defaultValue = \"server\", name = \"server-root\", shortName = 's')\n+      String serverRoot;\n+\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      public CommandResult exec(ContextAwareCommandInvocation invocation) throws CommandException {\n+         UserTool userTool = new UserTool(serverRoot, usersFile, groupsFile);\n+         try {\n+            while (username == null || username.isEmpty()) {\n+               username = invocation.getShell().readLine(MSG.userToolUsername());\n+            }\n+         } catch (InterruptedException e) {\n+            return CommandResult.FAILURE;\n+         }\n+\n+         if (password == null) { // Get the password interactively\n+            try {\n+               password = getPasswordInteractively(invocation);\n+            } catch (InterruptedException e) {\n+               return CommandResult.FAILURE;\n+            }\n+         }\n+         userTool.createUser(username, password, realm, UserTool.Encryption.valueOf(plainText), groups, algorithms);\n+         return CommandResult.SUCCESS;\n+      }\n+   }\n+\n+   @CommandDefinition(name = Describe.CMD, description = \"Describes a user\")\n+   public static class Describe extends CliCommand {\n+      public static final String CMD = \"describe\";\n+\n+      @Argument(description = \"The username for the user\", required = true)\n+      String username;\n+\n+      @Option(description = \"The path of the users.properties file\", name = \"users-file\", shortName = 'f')\n+      String usersFile;\n+\n+      @Option(description = \"The path of the groups.properties file\", name = \"groups-file\", shortName = 'w')\n+      String groupsFile;\n+\n+      @Option(description = \"The server root\", defaultValue = \"server\", name = \"server-root\", shortName = 's')\n+      String serverRoot;\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      public CommandResult exec(ContextAwareCommandInvocation invocation) throws CommandException {\n+         UserTool userTool = new UserTool(serverRoot, usersFile, groupsFile);\n+         invocation.getShell().writeln(userTool.describeUser(username));\n+         return CommandResult.SUCCESS;\n+      }\n+   }\n+\n+   @CommandDefinition(name = Remove.CMD, description = \"Removes a user\", aliases = \"rm\")\n+   public static class Remove extends CliCommand {\n+      public static final String CMD = \"remove\";\n+\n+      @Argument(description = \"The username for the user\", required = true)\n+      String username;\n+\n+      @Option(description = \"The path of the users.properties file\", name = \"users-file\", shortName = 'f')\n+      String usersFile;\n+\n+      @Option(description = \"The path of the groups.properties file\", name = \"groups-file\", shortName = 'w')\n+      String groupsFile;\n+\n+      @Option(description = \"The server root\", defaultValue = \"server\", name = \"server-root\", shortName = 's')\n+      String serverRoot;\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      public CommandResult exec(ContextAwareCommandInvocation invocation) throws CommandException {\n+         UserTool userTool = new UserTool(serverRoot, usersFile, groupsFile);\n+         userTool.removeUser(username);\n+         return CommandResult.SUCCESS;\n+      }\n+   }\n+\n+   @CommandDefinition(name = Password.CMD, description = \"Changes a user's password\")\n+   public static class Password extends CliCommand {\n+      public static final String CMD = \"password\";\n+\n+      @Argument(description = \"The username for the user\", required = true)\n+      String username;\n+\n+      @Option(description = \"The password for the user\", shortName = 'p')\n+      String password;\n+\n+      @Option(description = \"The realm \", defaultValue = UserTool.DEFAULT_REALM_NAME, shortName = 'r')\n+      String realm;\n+\n+      @OptionList(description = \"The algorithms used to encrypt the password\", shortName = 'a', completer = EncryptionAlgorithmCompleter.class)\n+      List<String> algorithms;\n+\n+      @Option(description = \"Whether the password should be stored in plain text\", name = \"plain-text\", hasValue = false)\n+      boolean plainText;\n+\n+      @Option(description = \"The path of the users.properties file\", name = \"users-file\", shortName = 'f')\n+      String usersFile;\n+\n+      @Option(description = \"The path of the groups.properties file\", name = \"groups-file\", shortName = 'w')\n+      String groupsFile;\n+\n+      @Option(description = \"The server root\", defaultValue = \"server\", name = \"server-root\", shortName = 's')\n+      String serverRoot;\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+         if (password == null) { // Get the password interactively\n+            try {\n+               password = getPasswordInteractively(invocation);\n+            } catch (InterruptedException e) {\n+               return CommandResult.FAILURE;\n+            }\n+         }\n+         UserTool userTool = new UserTool(serverRoot, usersFile, groupsFile);\n+         userTool.modifyUser(username, password, realm, UserTool.Encryption.valueOf(plainText), null, algorithms);\n+         return CommandResult.SUCCESS;\n+      }\n+   }\n+\n+   @CommandDefinition(name = Groups.CMD, description = \"Sets a user's groups\")", "originalCommit": "714cc4f74379295aace14074dbecfd21630d2174", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA2OTEzNA==", "url": "https://github.com/infinispan/infinispan/pull/8295#discussion_r427069134", "bodyText": "That looks like a bug", "author": "tristantarrant", "createdAt": "2020-05-19T06:53:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc5ODkyOA=="}], "type": "inlineReview"}, {"oid": "75c6ec94b434f1a75baefbf991a7e25c98993d88", "url": "https://github.com/infinispan/infinispan/commit/75c6ec94b434f1a75baefbf991a7e25c98993d88", "message": "ISPN-11838 Native CLI", "committedDate": "2020-05-19T06:35:31Z", "type": "forcePushed"}, {"oid": "c8c25f33ac14af0809c42ab4f8d2b8f279f095d5", "url": "https://github.com/infinispan/infinispan/commit/c8c25f33ac14af0809c42ab4f8d2b8f279f095d5", "message": "ISPN-11838 Native CLI", "committedDate": "2020-05-19T06:45:58Z", "type": "forcePushed"}, {"oid": "b7c90b02cfff9c203a97e6aad22609f488c85813", "url": "https://github.com/infinispan/infinispan/commit/b7c90b02cfff9c203a97e6aad22609f488c85813", "message": "ISPN-11838 Native CLI", "committedDate": "2020-05-19T14:59:37Z", "type": "forcePushed"}, {"oid": "0a6de03129620cbd9cf61ae79f358b154b8b3730", "url": "https://github.com/infinispan/infinispan/commit/0a6de03129620cbd9cf61ae79f358b154b8b3730", "message": "ISPN-11838 Native CLI", "committedDate": "2020-05-19T16:12:11Z", "type": "forcePushed"}, {"oid": "cfa4b5ce523e39196f0b3a0bb2fbc50ee705229c", "url": "https://github.com/infinispan/infinispan/commit/cfa4b5ce523e39196f0b3a0bb2fbc50ee705229c", "message": "ISPN-11700 User tool inside CLI\n\n* convert the CLI launcher to be a command. This enables non-interactive mode\n* add a deprecation message in the user-tool.[sh|bat] scripts", "committedDate": "2020-05-19T16:32:04Z", "type": "commit"}, {"oid": "15666529e52acb1cc400c6772c14d13e9cadee27", "url": "https://github.com/infinispan/infinispan/commit/15666529e52acb1cc400c6772c14d13e9cadee27", "message": "ISPN-11838 Native CLI", "committedDate": "2020-05-19T16:32:05Z", "type": "commit"}, {"oid": "15666529e52acb1cc400c6772c14d13e9cadee27", "url": "https://github.com/infinispan/infinispan/commit/15666529e52acb1cc400c6772c14d13e9cadee27", "message": "ISPN-11838 Native CLI", "committedDate": "2020-05-19T16:32:05Z", "type": "forcePushed"}]}