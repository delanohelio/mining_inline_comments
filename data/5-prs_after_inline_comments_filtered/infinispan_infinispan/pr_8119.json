{"pr_number": 8119, "pr_title": "ISPN-11543 Add BlockingHandler to simplify running blocking operations", "pr_createdAt": "2020-03-27T21:11:53Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8119", "timeline": [{"oid": "184c864f2c16a5f32b0e45f1cab0776c66d9b735", "url": "https://github.com/infinispan/infinispan/commit/184c864f2c16a5f32b0e45f1cab0776c66d9b735", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block", "committedDate": "2020-03-30T21:10:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI2Mzg4MA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r410263880", "bodyText": "Should only be if stage is also complete.", "author": "wburns", "createdAt": "2020-04-17T14:33:32Z", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.commons.executors.BlockingResource;\n+import org.infinispan.commons.executors.NonBlockingResource;\n+import org.infinispan.executors.LimitedExecutor;\n+import org.infinispan.factories.KnownComponentNames;\n+import org.infinispan.factories.annotations.ComponentName;\n+import org.infinispan.factories.annotations.Inject;\n+import org.infinispan.factories.annotations.Start;\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.Flowable;\n+import io.reactivex.Scheduler;\n+import io.reactivex.schedulers.Schedulers;\n+\n+@Scope(Scopes.GLOBAL)\n+public class BlockingHandler {\n+   private static final Log log = LogFactory.getLog(MethodHandles.lookup().lookupClass());\n+   private static final boolean trace = log.isTraceEnabled();\n+\n+   @Inject @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR)\n+   Executor nonBlockingExecutor;\n+   // This should eventually be the only reference to blocking executor\n+   @SuppressWarnings(\"checkstyle:RegexpSinglelineJava\")\n+   @Inject @ComponentName(KnownComponentNames.BLOCKING_EXECUTOR)\n+   Executor blockingExecutor;\n+\n+   Scheduler blockingScheduler;\n+   Scheduler nonBlockingScheduler;\n+\n+   @Start\n+   protected void start() {\n+      blockingScheduler = Schedulers.from(blockingExecutor);\n+      nonBlockingScheduler = Schedulers.from(nonBlockingExecutor);\n+   }\n+\n+   public CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked run on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         try {\n+            runnable.run();\n+            return CompletableFutures.completedNull();\n+         } catch (Throwable t) {\n+            return CompletableFutures.completedExceptionFuture(t);\n+         }\n+      }\n+      CompletionStage<Void> stage;\n+      if (trace) {\n+         log.tracef(\"Submitting blocking run operation %s to blocking thread\", traceId);\n+         stage = CompletableFuture.runAsync(() -> {\n+            log.tracef(\"Running blocking run operation %s\", traceId);\n+            runnable.run();\n+         }, blockingExecutor);\n+      } else {\n+         stage = CompletableFuture.runAsync(runnable, blockingExecutor);\n+      }\n+      return continueOnNonBlockingThread(stage, traceId);\n+   }\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   public <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked supply on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         try {\n+            return CompletableFuture.completedFuture(supplier.get());\n+         } catch (Throwable t) {\n+            return CompletableFutures.completedExceptionFuture(t);\n+         }\n+      }\n+      CompletionStage<V> stage;\n+      if (trace) {\n+         log.tracef(\"Submitting blocking supply operation %s to blocking thread\", traceId);\n+         stage = CompletableFuture.supplyAsync(() -> {\n+            log.tracef(\"Running blocking supply operation %s\", traceId);\n+            return supplier.get();\n+         }, blockingExecutor);\n+      } else {\n+         stage = CompletableFuture.supplyAsync(supplier, blockingExecutor);\n+      }\n+      return continueOnNonBlockingThread(stage, traceId);\n+   }\n+\n+   /**\n+    * Similar to CompletionStage#handle\n+    * @param stage\n+    * @param function\n+    * @param traceId\n+    * @param <I>\n+    * @param <O>\n+    * @return\n+    */\n+   public <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n+         BiFunction<? super I, Throwable, ? extends O> function, Object traceId) {\n+      if (isCurrentThreadBlocking()) {", "originalCommit": "2a5f5a744eb8d19e6da70590206047c8f02d0fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI2Mzk2NA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r410263964", "bodyText": "Should only be if stage is also complete. Or maybe it should join the stage if not complete?", "author": "wburns", "createdAt": "2020-04-17T14:33:40Z", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.commons.executors.BlockingResource;\n+import org.infinispan.commons.executors.NonBlockingResource;\n+import org.infinispan.executors.LimitedExecutor;\n+import org.infinispan.factories.KnownComponentNames;\n+import org.infinispan.factories.annotations.ComponentName;\n+import org.infinispan.factories.annotations.Inject;\n+import org.infinispan.factories.annotations.Start;\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.Flowable;\n+import io.reactivex.Scheduler;\n+import io.reactivex.schedulers.Schedulers;\n+\n+@Scope(Scopes.GLOBAL)\n+public class BlockingHandler {\n+   private static final Log log = LogFactory.getLog(MethodHandles.lookup().lookupClass());\n+   private static final boolean trace = log.isTraceEnabled();\n+\n+   @Inject @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR)\n+   Executor nonBlockingExecutor;\n+   // This should eventually be the only reference to blocking executor\n+   @SuppressWarnings(\"checkstyle:RegexpSinglelineJava\")\n+   @Inject @ComponentName(KnownComponentNames.BLOCKING_EXECUTOR)\n+   Executor blockingExecutor;\n+\n+   Scheduler blockingScheduler;\n+   Scheduler nonBlockingScheduler;\n+\n+   @Start\n+   protected void start() {\n+      blockingScheduler = Schedulers.from(blockingExecutor);\n+      nonBlockingScheduler = Schedulers.from(nonBlockingExecutor);\n+   }\n+\n+   public CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked run on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         try {\n+            runnable.run();\n+            return CompletableFutures.completedNull();\n+         } catch (Throwable t) {\n+            return CompletableFutures.completedExceptionFuture(t);\n+         }\n+      }\n+      CompletionStage<Void> stage;\n+      if (trace) {\n+         log.tracef(\"Submitting blocking run operation %s to blocking thread\", traceId);\n+         stage = CompletableFuture.runAsync(() -> {\n+            log.tracef(\"Running blocking run operation %s\", traceId);\n+            runnable.run();\n+         }, blockingExecutor);\n+      } else {\n+         stage = CompletableFuture.runAsync(runnable, blockingExecutor);\n+      }\n+      return continueOnNonBlockingThread(stage, traceId);\n+   }\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   public <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked supply on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         try {\n+            return CompletableFuture.completedFuture(supplier.get());\n+         } catch (Throwable t) {\n+            return CompletableFutures.completedExceptionFuture(t);\n+         }\n+      }\n+      CompletionStage<V> stage;\n+      if (trace) {\n+         log.tracef(\"Submitting blocking supply operation %s to blocking thread\", traceId);\n+         stage = CompletableFuture.supplyAsync(() -> {\n+            log.tracef(\"Running blocking supply operation %s\", traceId);\n+            return supplier.get();\n+         }, blockingExecutor);\n+      } else {\n+         stage = CompletableFuture.supplyAsync(supplier, blockingExecutor);\n+      }\n+      return continueOnNonBlockingThread(stage, traceId);\n+   }\n+\n+   /**\n+    * Similar to CompletionStage#handle\n+    * @param stage\n+    * @param function\n+    * @param traceId\n+    * @param <I>\n+    * @param <O>\n+    * @return\n+    */\n+   public <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n+         BiFunction<? super I, Throwable, ? extends O> function, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked handle on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         return stage.handle(function);\n+      }\n+      return continueOnNonBlockingThread(stage.handleAsync(function, blockingExecutor), traceId);\n+   }\n+\n+   /**\n+    * Similar to CompletionStage#thenApply\n+    * @param stage\n+    * @param function\n+    * @param traceId\n+    * @param <I>\n+    * @param <O>\n+    * @return\n+    */\n+   public <I, O> CompletionStage<O> thenApplyBlocking(CompletionStage<? extends I> stage,\n+         Function<? super I, ? extends O> function, Object traceId) {\n+      if (isCurrentThreadBlocking()) {", "originalCommit": "2a5f5a744eb8d19e6da70590206047c8f02d0fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI3MDgyMw==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r410270823", "bodyText": "Thinking the latter.", "author": "wburns", "createdAt": "2020-04-17T14:44:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI2Mzk2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI2NDAxNw==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r410264017", "bodyText": "Should only be if stage is also complete.", "author": "wburns", "createdAt": "2020-04-17T14:33:44Z", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.commons.executors.BlockingResource;\n+import org.infinispan.commons.executors.NonBlockingResource;\n+import org.infinispan.executors.LimitedExecutor;\n+import org.infinispan.factories.KnownComponentNames;\n+import org.infinispan.factories.annotations.ComponentName;\n+import org.infinispan.factories.annotations.Inject;\n+import org.infinispan.factories.annotations.Start;\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.Flowable;\n+import io.reactivex.Scheduler;\n+import io.reactivex.schedulers.Schedulers;\n+\n+@Scope(Scopes.GLOBAL)\n+public class BlockingHandler {\n+   private static final Log log = LogFactory.getLog(MethodHandles.lookup().lookupClass());\n+   private static final boolean trace = log.isTraceEnabled();\n+\n+   @Inject @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR)\n+   Executor nonBlockingExecutor;\n+   // This should eventually be the only reference to blocking executor\n+   @SuppressWarnings(\"checkstyle:RegexpSinglelineJava\")\n+   @Inject @ComponentName(KnownComponentNames.BLOCKING_EXECUTOR)\n+   Executor blockingExecutor;\n+\n+   Scheduler blockingScheduler;\n+   Scheduler nonBlockingScheduler;\n+\n+   @Start\n+   protected void start() {\n+      blockingScheduler = Schedulers.from(blockingExecutor);\n+      nonBlockingScheduler = Schedulers.from(nonBlockingExecutor);\n+   }\n+\n+   public CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked run on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         try {\n+            runnable.run();\n+            return CompletableFutures.completedNull();\n+         } catch (Throwable t) {\n+            return CompletableFutures.completedExceptionFuture(t);\n+         }\n+      }\n+      CompletionStage<Void> stage;\n+      if (trace) {\n+         log.tracef(\"Submitting blocking run operation %s to blocking thread\", traceId);\n+         stage = CompletableFuture.runAsync(() -> {\n+            log.tracef(\"Running blocking run operation %s\", traceId);\n+            runnable.run();\n+         }, blockingExecutor);\n+      } else {\n+         stage = CompletableFuture.runAsync(runnable, blockingExecutor);\n+      }\n+      return continueOnNonBlockingThread(stage, traceId);\n+   }\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   public <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked supply on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         try {\n+            return CompletableFuture.completedFuture(supplier.get());\n+         } catch (Throwable t) {\n+            return CompletableFutures.completedExceptionFuture(t);\n+         }\n+      }\n+      CompletionStage<V> stage;\n+      if (trace) {\n+         log.tracef(\"Submitting blocking supply operation %s to blocking thread\", traceId);\n+         stage = CompletableFuture.supplyAsync(() -> {\n+            log.tracef(\"Running blocking supply operation %s\", traceId);\n+            return supplier.get();\n+         }, blockingExecutor);\n+      } else {\n+         stage = CompletableFuture.supplyAsync(supplier, blockingExecutor);\n+      }\n+      return continueOnNonBlockingThread(stage, traceId);\n+   }\n+\n+   /**\n+    * Similar to CompletionStage#handle\n+    * @param stage\n+    * @param function\n+    * @param traceId\n+    * @param <I>\n+    * @param <O>\n+    * @return\n+    */\n+   public <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n+         BiFunction<? super I, Throwable, ? extends O> function, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked handle on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         return stage.handle(function);\n+      }\n+      return continueOnNonBlockingThread(stage.handleAsync(function, blockingExecutor), traceId);\n+   }\n+\n+   /**\n+    * Similar to CompletionStage#thenApply\n+    * @param stage\n+    * @param function\n+    * @param traceId\n+    * @param <I>\n+    * @param <O>\n+    * @return\n+    */\n+   public <I, O> CompletionStage<O> thenApplyBlocking(CompletionStage<? extends I> stage,\n+         Function<? super I, ? extends O> function, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked handle on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         return stage.thenApply(function);\n+      }\n+      return continueOnNonBlockingThread(stage.thenApplyAsync(function, blockingExecutor), traceId);\n+   }\n+\n+   /**\n+    *\n+    * @param stage\n+    * @param biConsumer\n+    * @param traceId\n+    * @param <V>\n+    * @return\n+    */\n+   public <V> CompletionStage<V> whenCompleteBlocking(CompletionStage<V> stage,\n+         BiConsumer<? super V, ? super Throwable> biConsumer, Object traceId) {\n+      if (isCurrentThreadBlocking()) {", "originalCommit": "2a5f5a744eb8d19e6da70590206047c8f02d0fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI3MTE4NQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r410271185", "bodyText": "I am not sure about the inclusion of isCurrentThreadNonBlocking() here.", "author": "wburns", "createdAt": "2020-04-17T14:44:48Z", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.commons.executors.BlockingResource;\n+import org.infinispan.commons.executors.NonBlockingResource;\n+import org.infinispan.executors.LimitedExecutor;\n+import org.infinispan.factories.KnownComponentNames;\n+import org.infinispan.factories.annotations.ComponentName;\n+import org.infinispan.factories.annotations.Inject;\n+import org.infinispan.factories.annotations.Start;\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.Flowable;\n+import io.reactivex.Scheduler;\n+import io.reactivex.schedulers.Schedulers;\n+\n+@Scope(Scopes.GLOBAL)\n+public class BlockingHandler {\n+   private static final Log log = LogFactory.getLog(MethodHandles.lookup().lookupClass());\n+   private static final boolean trace = log.isTraceEnabled();\n+\n+   @Inject @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR)\n+   Executor nonBlockingExecutor;\n+   // This should eventually be the only reference to blocking executor\n+   @SuppressWarnings(\"checkstyle:RegexpSinglelineJava\")\n+   @Inject @ComponentName(KnownComponentNames.BLOCKING_EXECUTOR)\n+   Executor blockingExecutor;\n+\n+   Scheduler blockingScheduler;\n+   Scheduler nonBlockingScheduler;\n+\n+   @Start\n+   protected void start() {\n+      blockingScheduler = Schedulers.from(blockingExecutor);\n+      nonBlockingScheduler = Schedulers.from(nonBlockingExecutor);\n+   }\n+\n+   public CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked run on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         try {\n+            runnable.run();\n+            return CompletableFutures.completedNull();\n+         } catch (Throwable t) {\n+            return CompletableFutures.completedExceptionFuture(t);\n+         }\n+      }\n+      CompletionStage<Void> stage;\n+      if (trace) {\n+         log.tracef(\"Submitting blocking run operation %s to blocking thread\", traceId);\n+         stage = CompletableFuture.runAsync(() -> {\n+            log.tracef(\"Running blocking run operation %s\", traceId);\n+            runnable.run();\n+         }, blockingExecutor);\n+      } else {\n+         stage = CompletableFuture.runAsync(runnable, blockingExecutor);\n+      }\n+      return continueOnNonBlockingThread(stage, traceId);\n+   }\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   public <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked supply on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         try {\n+            return CompletableFuture.completedFuture(supplier.get());\n+         } catch (Throwable t) {\n+            return CompletableFutures.completedExceptionFuture(t);\n+         }\n+      }\n+      CompletionStage<V> stage;\n+      if (trace) {\n+         log.tracef(\"Submitting blocking supply operation %s to blocking thread\", traceId);\n+         stage = CompletableFuture.supplyAsync(() -> {\n+            log.tracef(\"Running blocking supply operation %s\", traceId);\n+            return supplier.get();\n+         }, blockingExecutor);\n+      } else {\n+         stage = CompletableFuture.supplyAsync(supplier, blockingExecutor);\n+      }\n+      return continueOnNonBlockingThread(stage, traceId);\n+   }\n+\n+   /**\n+    * Similar to CompletionStage#handle\n+    * @param stage\n+    * @param function\n+    * @param traceId\n+    * @param <I>\n+    * @param <O>\n+    * @return\n+    */\n+   public <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n+         BiFunction<? super I, Throwable, ? extends O> function, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked handle on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         return stage.handle(function);\n+      }\n+      return continueOnNonBlockingThread(stage.handleAsync(function, blockingExecutor), traceId);\n+   }\n+\n+   /**\n+    * Similar to CompletionStage#thenApply\n+    * @param stage\n+    * @param function\n+    * @param traceId\n+    * @param <I>\n+    * @param <O>\n+    * @return\n+    */\n+   public <I, O> CompletionStage<O> thenApplyBlocking(CompletionStage<? extends I> stage,\n+         Function<? super I, ? extends O> function, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked handle on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         return stage.thenApply(function);\n+      }\n+      return continueOnNonBlockingThread(stage.thenApplyAsync(function, blockingExecutor), traceId);\n+   }\n+\n+   /**\n+    *\n+    * @param stage\n+    * @param biConsumer\n+    * @param traceId\n+    * @param <V>\n+    * @return\n+    */\n+   public <V> CompletionStage<V> whenCompleteBlocking(CompletionStage<V> stage,\n+         BiConsumer<? super V, ? super Throwable> biConsumer, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked whenComplete on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         return stage.whenComplete(biConsumer);\n+      }\n+      return continueOnNonBlockingThread(stage.whenCompleteAsync(biConsumer, blockingExecutor), traceId);\n+   }\n+\n+   /**\n+    * When the provided stage is complete, continue the completion chain of the returned CompletionStage on the\n+    * supplied executor. If tracing is enabled a trace message is printed using the object as an identifier to more\n+    * easily track the transition between threads.\n+    * <p>\n+    * This method is useful when an asynchronous computation completes and you do not want to run further processing\n+    * on the thread that returned it. An example may be that some blocking operation is performed on a special blocking\n+    * thread pool. However when the blocking operation completes we will want to continue the processing of that result\n+    * in a thread pool that is for computational tasks.\n+    * <p>\n+    * If the supplied stage is already completed when invoking this command, this will return an already completed\n+    * stage, which means any additional dependent stages will run in the invoking thread.\n+    * @param <V> return value type of the supplied stage\n+    * @param delay the stage to delay the continuation until complete\n+    * @param traceId the id to print when tracing is enabled\n+    * @return a CompletionStage that when depended upon will run any callback in the supplied executor\n+    */\n+   public <V> CompletionStage<V> continueOnNonBlockingThread(CompletionStage<V> delay, Object traceId) {\n+      if (CompletionStages.isCompletedSuccessfully(delay) && isCurrentThreadNonBlocking()) {", "originalCommit": "2a5f5a744eb8d19e6da70590206047c8f02d0fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d0534e4b41e5ca5422540005957dc7dce1526a82", "url": "https://github.com/infinispan/infinispan/commit/d0534e4b41e5ca5422540005957dc7dce1526a82", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block", "committedDate": "2020-04-17T18:26:14Z", "type": "forcePushed"}, {"oid": "2d30d88a6415b95e9c344fc4d9a724d7dbf10477", "url": "https://github.com/infinispan/infinispan/commit/2d30d88a6415b95e9c344fc4d9a724d7dbf10477", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block", "committedDate": "2020-04-17T19:54:19Z", "type": "forcePushed"}, {"oid": "255d3766f0b327e70d3f0790c0594fac2b9325a3", "url": "https://github.com/infinispan/infinispan/commit/255d3766f0b327e70d3f0790c0594fac2b9325a3", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block", "committedDate": "2020-04-20T17:16:00Z", "type": "forcePushed"}, {"oid": "297094aeb62968af80379ea9e7aed0f635900133", "url": "https://github.com/infinispan/infinispan/commit/297094aeb62968af80379ea9e7aed0f635900133", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block", "committedDate": "2020-04-20T17:23:55Z", "type": "forcePushed"}, {"oid": "eb4088f58c883681070c4a11082632e51068b03b", "url": "https://github.com/infinispan/infinispan/commit/eb4088f58c883681070c4a11082632e51068b03b", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block", "committedDate": "2020-04-20T17:32:00Z", "type": "forcePushed"}, {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "url": "https://github.com/infinispan/infinispan/commit/4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block", "committedDate": "2020-04-22T15:12:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE4MzY1NA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r412183654", "bodyText": "Since this is in the loom source directory, I assume it will return false for a build of OpenJDK 15 without Loom, which would make the name misleading.", "author": "danberindei", "createdAt": "2020-04-21T13:27:50Z", "path": "commons/loom/src/main/java/org/infinispan/commons/jdkspecific/JREVersion.java", "diffHunk": "@@ -0,0 +1,9 @@\n+package org.infinispan.commons.jdkspecific;\n+\n+public class JREVersion {\n+   private JREVersion() { }\n+\n+   public static boolean isJava15OrNewer() {\n+      return true;", "originalCommit": "eb4088f58c883681070c4a11082632e51068b03b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk2OTQ0OQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413969449", "bodyText": "Yeah, I deleted this class. You must have been looking at an outdated commit :)", "author": "wburns", "createdAt": "2020-04-23T17:03:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE4MzY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4NDU0Mw==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413684543", "bodyText": "Is this related to BlockingHandler? To me reading the built-in stacks once in readElement seems more natural, although I'd like it even more if we didn't actually read the default stacks until they are referenced in the transport or in an inline stack.", "author": "danberindei", "createdAt": "2020-04-23T10:03:53Z", "path": "core/src/main/java/org/infinispan/configuration/parsing/Parser.java", "diffHunk": "@@ -105,15 +105,19 @@\n    public Parser() {\n    }\n \n+   private void addJGroupsDefaultStacksIfNeeded(final XMLExtendedStreamReader reader, final ConfigurationBuilderHolder holder) {\n+      if (holder.getJGroupsStack(BuiltinJGroupsChannelConfigurator.TCP_STACK_NAME) == null) {", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3MTcwNw==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413971707", "bodyText": "It isn't directly related. I will create a JIRA for it separate it out. This was found because adding a new cache starts up the parser and reads these darn stack files every time. I wasn't sure how to actually fix it, and this is a nice easy way I thought (should make startup time without clustering even faster as well).", "author": "wburns", "createdAt": "2020-04-23T17:06:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4NDU0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU1NjA2Mg==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r414556062", "bodyText": "You mean starting a new DefaultCacheManager, right? If we start the parser every time we add a cache in an existing manager, that's another bug that needs to be fixed.", "author": "danberindei", "createdAt": "2020-04-24T12:58:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4NDU0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU1ODA4Nw==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r414558087", "bodyText": "Nope. But I might be mixing words, it might have been just that it ran the parser, not started. Either way it parses these jgroups files every time.", "author": "wburns", "createdAt": "2020-04-24T13:02:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4NDU0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY1NjcwMw==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r414656703", "bodyText": "I don't know what the difference between running and starting the parser is, I assumed you were talking about readElement().\nI put a breakpoint in readElement() and we definitely don't hit that when we use the programmatic configuration to create a cache, but we hit it when we create a cache via the admin API, because the configuration that gets replicated is a full <infinispan/> XML. Maybe that's what you were seeing?", "author": "danberindei", "createdAt": "2020-04-24T15:17:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4NDU0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyMTYyOA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r415721628", "bodyText": "That's why it's good to create the JIRA before the PR :P", "author": "danberindei", "createdAt": "2020-04-27T11:10:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4NDU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc2NzYxOA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413767618", "bodyText": "resolveConflicts() is not public API, so it can be changed to return CompletionStage.\nBut I don't see any advantage in using the BlockingExecutor interface here instead of the more familiar Executor.", "author": "danberindei", "createdAt": "2020-04-23T12:20:32Z", "path": "core/src/main/java/org/infinispan/conflict/impl/DefaultConflictManager.java", "diffHunk": "@@ -249,7 +245,9 @@ public void resolveConflicts(EntryMergePolicy<K, V> mergePolicy) {\n       } else {\n          localizedTopology = distributionManager.createLocalizedCacheTopology(topology);\n       }\n-      conflictFuture = CompletableFuture.runAsync(() -> doResolveConflicts(localizedTopology, entryMergePolicy, preferredNodes), resolutionExecutor);\n+      conflictFuture = resolutionExecutor.execute(() -> doResolveConflicts(localizedTopology, entryMergePolicy, preferredNodes),\n+            localizedTopology.getTopologyId())\n+            .toCompletableFuture();", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3MjU4MQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413972581", "bodyText": "The important part is that the returned Stage never runs chained methods on a blocking thread, unless the invoking thread is blocking.", "author": "wburns", "createdAt": "2020-04-23T17:07:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc2NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAxMTY1Ng==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r414011656", "bodyText": "Also I can't change conflictFuture to a stage as we cancel it possibly.", "author": "wburns", "createdAt": "2020-04-23T18:05:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc2NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2NjA5Mw==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r414566093", "bodyText": "The important part is that the returned Stage never runs chained methods on a blocking thread, unless the invoking thread is blocking.\n\nFair enough, without it you'd have to call continueOnNonBlockingThread(). TBT I was thinking of removing LimitedExecutor and removing its usages with ActionSequencer, and this new interface interferes with my plans :)\n\nAlso I can't change conflictFuture to a stage as we cancel it possibly.\n\nCancelling the CompletableFuture doesn't do anything to cancel the actual conflict resolution, so I fear cancellation is broken anyway /cc @ryanemerson .", "author": "danberindei", "createdAt": "2020-04-24T13:14:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc2NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2ODgzMA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r414568830", "bodyText": "The important part is that the returned Stage never runs chained methods on a blocking thread, unless the invoking thread is blocking.\n\nFair enough, without it you'd have to call continueOnNonBlockingThread().\n\nYeah the problem I have is that this will be forgotten somewhere. Where as by banning the use of blocking executor and requiring blocking manager, means it won't  be messed up. I am trying to take a hard stance to catching these things before they become problems, by using checkstyle and block hound.\n\nTBT I was thinking of removing LimitedExecutor and removing its usages with ActionSequencer, and this new interface interferes with my plans :)\n\nI think we can still do that. I am more than fine removing BlockingExecutor as needed. I had ideas of that a while back, but never looked into it.", "author": "wburns", "createdAt": "2020-04-24T13:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc2NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc1NDUwNA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r415754504", "bodyText": "True, it's not public API so it's not that hard to change.", "author": "danberindei", "createdAt": "2020-04-27T12:04:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc2NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc1ODQwOA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r415758408", "bodyText": "I created https://issues.redhat.com/browse/ISPN-11718 for the conflict resolution cancellation.", "author": "danberindei", "createdAt": "2020-04-27T12:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc2NzYxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc2ODQxMQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413768411", "bodyText": "Comment doesn't sound right, now that there is no if statement.", "author": "danberindei", "createdAt": "2020-04-23T12:21:41Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java", "diffHunk": "@@ -158,13 +155,8 @@ public boolean isEnabled() {\n \n    @Override\n    public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry, long currentTime) {\n-      if (persistenceManager.hasWriter()) {\n-         // If entry was expired and we have store this can block - so fire in separate thread to remove the entry\n-         blockingExecutor.submit(() -> entryExpiredInMemorySync(entry, currentTime));\n-      } else {\n-         // This shouldn't block as there are no stores (other than the lock acquisition on the Map and notification)\n-         entryExpiredInMemory(entry, currentTime, false);\n-      }\n+      // This shouldn't block as there are no stores (other than the lock acquisition on the Map and notification)", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3MjczMw==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413972733", "bodyText": "Sure, I can fix it.", "author": "wburns", "createdAt": "2020-04-23T17:08:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc2ODQxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxNTI2Mw==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413815263", "bodyText": "I'm not sure about the name, because it's definitely not the identifier of a single event. Maybe batchIdentifier is better?\nSame in the other methods, in ClusterEventManager and its implementations.", "author": "danberindei", "createdAt": "2020-04-23T13:55:29Z", "path": "core/src/main/java/org/infinispan/notifications/cachelistener/CacheNotifierImpl.java", "diffHunk": "@@ -414,7 +414,7 @@ int extractSegment(FlagAffectedCommand command, Object key) {\n             && (command == null || !command.hasAnyFlag(FlagBitSets.PUT_FOR_STATE_TRANSFER))) {\n          EventImpl<K, V> e = EventImpl.createEvent(cache.wired(), CACHE_ENTRY_CREATED);\n          boolean isLocalNodePrimaryOwner = isLocalNodePrimaryOwner(key);\n-         boolean sendEvents = !ctx.isInTxScope();\n+         Object eventIdentifier = ctx.isInTxScope() ? null : Thread.currentThread();", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3Mzc1Ng==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413973756", "bodyText": "Okay.", "author": "wburns", "createdAt": "2020-04-23T17:09:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxNTI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxNzIwOA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413817208", "bodyText": "I think this could be better phrased by using a common terminology. I wouldn't know what \"signal through the current thread\" or \"in the same caller\" mean unless I already knew what addEvents does, but then I wouldn't need a comment here.\nThe comment did make me curious though, because it says with 10 registered listeners, all of them are notified about a put(K, V) in the same batch (I think!), but it doesn't say what happens when the operation is putAll() and it updates 10 entries with 10 registered listeners.", "author": "danberindei", "createdAt": "2020-04-23T13:57:54Z", "path": "core/src/main/java/org/infinispan/notifications/cachelistener/cluster/RemoteClusterListener.java", "diffHunk": "@@ -109,14 +109,17 @@ public Address getOwnerAddress() {\n          if (trace) {\n             log.tracef(\"Passing Event to manager %s to send to %s\", event, origin);\n          }\n-         eventManager.addEvents(origin, id, Collections.singleton(ClusterEvent.fromEvent(event)), sync);\n+         // For non tx events we signal through the current thread as we notify in the same caller for all events", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3ODA0Mw==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413978043", "bodyText": "I can clarify it should really be single notification, not single operation. Because putAll does N notifications. If we add a bulk notification method, we can consolidate them, but that would have to be for another day.", "author": "wburns", "createdAt": "2020-04-23T17:16:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxNzIwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgyMzExMw==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413823113", "bodyText": "Missing @param in javadoc", "author": "danberindei", "createdAt": "2020-04-23T14:04:38Z", "path": "core/src/main/java/org/infinispan/notifications/cachelistener/cluster/ClusterEventManager.java", "diffHunk": "@@ -4,28 +4,27 @@\n import java.util.UUID;\n import java.util.concurrent.CompletionStage;\n \n-import org.infinispan.commons.CacheException;\n import org.infinispan.remoting.transport.Address;\n \n public interface ClusterEventManager<K, V> {\n    /**\n     * Adds additional cluster events that need to be sent remotely for an event originating locally.\n-    * These events are not sent at time of registering but rather after the {@link ClusterEventManager#sendEvents()} is invoked.\n+    * These events are not sent at time of registering but rather after the {@link ClusterEventManager#sendEvents(Object)} is invoked.\n     * These events are gathered on a per thread basis and batched to reduce number of RPCs required.\n     * @param target The target node this event was meant for\n     * @param identifier The cluster listener that is identified for these events\n     * @param events The events that were generated\n     * @param sync Whether these events need to be sent synchronously or not\n     */\n-   void addEvents(Address target, UUID identifier, Collection<ClusterEvent<K, V>> events, boolean sync);\n+   void addEvents(Object eventIdentifier, Address target, UUID identifier, Collection<ClusterEvent<K, V>> events, boolean sync);", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3NDQ3NA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413974474", "bodyText": "Sure", "author": "wburns", "createdAt": "2020-04-23T17:10:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgyMzExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgzMDU4Mg==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413830582", "bodyText": "Is it even possible to resume in another way?\nAlso would you mind moving all the fields to the top and the inner classes at the bottom? I get light-headed when I see them out of order like this ;)", "author": "danberindei", "createdAt": "2020-04-23T14:12:52Z", "path": "core/src/main/java/org/infinispan/notifications/impl/AbstractListenerImpl.java", "diffHunk": "@@ -119,9 +120,8 @@ public AbstractInvocationBuilder setSubject(Subject subject) {\n    // Processor used to handle async listener notifications.\n    @Inject @ComponentName(KnownComponentNames.ASYNC_NOTIFICATION_EXECUTOR)\n    protected Executor asyncProcessor;\n-   // Make sure all listeners resume on this executor\n-   @Inject @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR)\n-   ExecutorService nonBlockingExecutor;\n+   // Make sure all listeners resume using this", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3ODg1MQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413978851", "bodyText": "I can just remove the comment and move the variables up.", "author": "wburns", "createdAt": "2020-04-23T17:17:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgzMDU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg5MTA4OA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413891088", "bodyText": "This comment made more sense before, with the explicit call to subscribeOn, but now it looks out of place.", "author": "danberindei", "createdAt": "2020-04-23T15:22:00Z", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -881,48 +831,28 @@ private void writeToAllNonTxStoresSync(MarshallableEntry marshalledEntry, int se\n \n       int id = getNextTraceNumber(\"Submitting persistence async operation of id %d to write a batch\");\n \n-      boolean hasSemaphore = false;\n-\n-      AggregateCompletionStage<Void> aggregateCompletionStage = CompletionStages.aggregateCompletionStage();\n-      storesMutex.readLock().lock();\n+      acquireReadLock();\n       try {\n          checkStoreAvailability();\n-         try {\n-            // We have to acquire semaphore as our operation will escape the storesMutex lock boundaries\n-            // as the flowables are subscribed on the persistence thread pool. Thus we have to retain the publisher\n-            // semaphore until after all the stores have completed their operations\n-            publisherSemaphore.acquire();\n-         } catch (InterruptedException e) {\n-            throw new PersistenceException(e);\n-         }\n-         hasSemaphore = true;\n-         //noinspection unchecked\n-         nonTxWriters.stream()\n-               .filter(writer -> !(writer instanceof FlagAffectedStore) || FlagAffectedStore.class.cast(writer).shouldWrite(flags))\n-               .filter(writer -> predicate.test(getStoreConfig(writer)))\n-               .map(writer -> {\n-                  Flowable<MarshallableEntry> flowable = Flowable.fromIterable(entries);\n-                  if (trace) {\n-                     // Note this trace message will be on the persistence thread as it is subscribed below\n-                     flowable = flowable.doOnSubscribe(s -> log.tracef(\"Continuing write batch for id %d\", id));\n-                  }\n-                  // Subscribing on the persistence scheduler here forces this invocation to be async\n-                  return writer.bulkUpdate(flowable.subscribeOn(blockingScheduler));\n-               })\n-               .forEach(aggregateCompletionStage::dependsOn);\n-      } catch (Throwable t) {\n-         if (hasSemaphore) {\n-            publisherSemaphore.release();\n-         }\n-         throw t;\n+         return Flowable.using(publisherSemaphoreCallable,\n+               semaphore -> Flowable.fromIterable(nonTxWriters)\n+                     .filter(writer -> !(writer instanceof FlagAffectedStore) || FlagAffectedStore.class.cast(writer).shouldWrite(flags))\n+                     .filter(writer -> predicate.test(getStoreConfig(writer)))\n+                     .map(writer -> {\n+                        Flowable<MarshallableEntry> flowable = Flowable.fromIterable(entries);\n+                        if (trace) {\n+                           // Note this trace message will be on the persistence thread as it is subscribed below\n+                           flowable = flowable.doOnSubscribe(s -> log.tracef(\"Continuing write batch for id %d\", id));\n+                        }\n+                        // Subscribing on the persistence scheduler here forces this invocation to be async", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3OTA0OQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413979049", "bodyText": "I can update it.", "author": "wburns", "createdAt": "2020-04-23T17:17:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg5MTA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg5NjU1OA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413896558", "bodyText": "\"only runs a task\" doesn't sound very convincing to me, because that task could be a bulk operation using lots of CPU. \"This is an approved use\" is also kind of contradicted by the \"To be removed\" comment on the next line :)", "author": "danberindei", "createdAt": "2020-04-23T15:28:37Z", "path": "core/src/main/java/org/infinispan/remoting/inboundhandler/BasePerCacheInboundInvocationHandler.java", "diffHunk": "@@ -52,6 +52,10 @@\n    public static final String MBEAN_COMPONENT_NAME = \"InboundInvocationHandler\";\n    private static final int NO_TOPOLOGY_COMMAND = Integer.MIN_VALUE;\n \n+   // This is an approved use of blocking executor due to the fact that it only runs a task", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3OTM4OA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413979388", "bodyText": "I will refactor this as mentioned in prior comment.", "author": "wburns", "createdAt": "2020-04-23T17:17:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg5NjU1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAzMDkyNw==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r414030927", "bodyText": "Actually this one does have to stay until we fix https://issues.redhat.com/browse/ISPN-11483, since we have to invoke the checkForReadyTasks method. But this PR will make that one possible :)", "author": "wburns", "createdAt": "2020-04-23T18:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg5NjU1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2ODM4Nw==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r414568387", "bodyText": "Is it an allowed use if it's supposed to be removed, though?", "author": "danberindei", "createdAt": "2020-04-24T13:17:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg5NjU1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2OTUxOA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r414569518", "bodyText": "If the comment is the thing bothering you I can remove it in this PR.... It will be removed very soon either way as I have to fix the other JIRAs that these talk about, which are my next steps.", "author": "wburns", "createdAt": "2020-04-24T13:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg5NjU1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU3MTc1NQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r414571755", "bodyText": "Well actually I won't be fixing the xsite blocking soon.", "author": "wburns", "createdAt": "2020-04-24T13:22:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg5NjU1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU3MjQ5Mg==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r414572492", "bodyText": "I have removed those comments so we don't have to keep talking about this :)", "author": "wburns", "createdAt": "2020-04-24T13:23:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg5NjU1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMjMzNA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413902334", "bodyText": "Why a \"handler\" and not a \"manager\"? Especially since it has a handleBlocking method, it gives the impression that handleBlocking is the \"main\" method and the others are just extras.", "author": "danberindei", "createdAt": "2020-04-23T15:35:38Z", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3OTU2MA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413979560", "bodyText": "Sure, I can rename it. I am not too picky ;)", "author": "wburns", "createdAt": "2020-04-23T17:18:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMjMzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkyNTY2NA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413925664", "bodyText": "The first sentence mentions \"blocking operation\" and \"correct manner\" but they're just names without any meaning at this point. I'd say \"blocking task\", because \"task\" is more familiar when coupled with \"executor\", maybe\nRuns tasks on the blocking executor and returns a {@code CompletionStage} or {@code Publisher} that continues on the non-blocking executor, similar to {@code stage.handleAsync(callback, blockingExecutor).whenCompleteAsync(NOOP, nonBlockingExecutor)}.\n<p>\nIf the current thread is blocking, it blocks until the task may run, runs the task in the current thread, and returns a completed {@code CompletionStage}, so it <em>does not</em> continue the execution on the non-blocking executor.", "author": "danberindei", "createdAt": "2020-04-23T16:04:43Z", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk4MDA1Mw==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413980053", "bodyText": "Sure, I can actually add some more details about this.", "author": "wburns", "createdAt": "2020-04-23T17:18:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkyNTY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkyNzYwNg==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413927606", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * Invokes the provided runnable in a blocking thread and returns the result eventually.\n          \n          \n            \n                * Replacement for {@code CompletableFuture.runAsync()} that invokes the {@code Runnable} in a blocking thread (if the current thread is non-blocking) or in the current thread (if the current thread is blocking).", "author": "danberindei", "createdAt": "2020-04-23T16:07:09Z", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {\n+   /**\n+    * Invokes the provided runnable in a blocking thread and returns the result eventually.", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk4MDI0OQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413980249", "bodyText": "\ud83d\udc4d", "author": "wburns", "createdAt": "2020-04-23T17:19:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkyNzYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkyODA1OQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413928059", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId);\n          \n          \n            \n               CompletionStage<Void> runBlocking(Runnable runnable, Object traceId);", "author": "danberindei", "createdAt": "2020-04-23T16:07:43Z", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {\n+   /**\n+    * Invokes the provided runnable in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread and if the returned\n+    * stage is not yet complete will perform any chained stages in a non blocking thread.\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed on the invoking thread and will return\n+    * only when the operation has completed, and does not require any additional threads.\n+    * @param runnable blocking operation that runs something\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @return a stage that is completed after the runnable is done or throws an exception\n+    */\n+   CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId);", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk4MDQ0MQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413980441", "bodyText": "Sure", "author": "wburns", "createdAt": "2020-04-23T17:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkyODA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkyODE5Mw==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413928193", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId);\n          \n          \n            \n               <V> CompletionStage<V> supplyBlocking(Supplier<V> supplier, Object traceId);", "author": "danberindei", "createdAt": "2020-04-23T16:07:54Z", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {\n+   /**\n+    * Invokes the provided runnable in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread and if the returned\n+    * stage is not yet complete will perform any chained stages in a non blocking thread.\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed on the invoking thread and will return\n+    * only when the operation has completed, and does not require any additional threads.\n+    * @param runnable blocking operation that runs something\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @return a stage that is completed after the runnable is done or throws an exception\n+    */\n+   CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId);\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId);", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk4MDQ3Mg==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413980472", "bodyText": "Sure", "author": "wburns", "createdAt": "2020-04-23T17:19:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkyODE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkyODQwOQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413928409", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * Invokes the provided supplier in a blocking thread and returns the result eventually.\n          \n          \n            \n                * Replacement for {@code CompletableFuture.supplyAsync()} that invokes the {@code Supplier} in a blocking thread (if the current thread is non-blocking) or in the current thread (if the current thread is blocking).", "author": "danberindei", "createdAt": "2020-04-23T16:08:12Z", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {\n+   /**\n+    * Invokes the provided runnable in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread and if the returned\n+    * stage is not yet complete will perform any chained stages in a non blocking thread.\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed on the invoking thread and will return\n+    * only when the operation has completed, and does not require any additional threads.\n+    * @param runnable blocking operation that runs something\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @return a stage that is completed after the runnable is done or throws an exception\n+    */\n+   CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId);\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk4MDU4MQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413980581", "bodyText": "\ud83d\udc4d", "author": "wburns", "createdAt": "2020-04-23T17:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkyODQwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkzNjIxNg==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413936216", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * Replacement for {@link CompletionStage#handle(BiFunction)} when the function is blocking to ensure the operation\n          \n          \n            \n                * Replacement for {@link CompletionStage#handle(BiFunction)} that invokes the {@code BiFunction} in a blocking thread (if the current thread is non-blocking or the given stage is not done yet) or in the current thread (if the current thread is blocking and the stage is done).", "author": "danberindei", "createdAt": "2020-04-23T16:18:18Z", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {\n+   /**\n+    * Invokes the provided runnable in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread and if the returned\n+    * stage is not yet complete will perform any chained stages in a non blocking thread.\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed on the invoking thread and will return\n+    * only when the operation has completed, and does not require any additional threads.\n+    * @param runnable blocking operation that runs something\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @return a stage that is completed after the runnable is done or throws an exception\n+    */\n+   CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId);\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#handle(BiFunction)} when the function is blocking to ensure the operation", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk4MDY1MA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413980650", "bodyText": "\ud83d\udc4d", "author": "wburns", "createdAt": "2020-04-23T17:19:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkzNjIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkzNjU4Ng==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413936586", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * Replacement for {@link CompletionStage#thenApply(Function)} when the function is blocking to ensure the operation\n          \n          \n            \n                * Replacement for {@link CompletionStage#thenApply(Function)} that invokes the {@code Function} in a blocking thread (if the current thread is non-blocking or the given stage is not done yet) or in the current thread (if the current thread is blocking and the stage is done).", "author": "danberindei", "createdAt": "2020-04-23T16:18:48Z", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {\n+   /**\n+    * Invokes the provided runnable in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread and if the returned\n+    * stage is not yet complete will perform any chained stages in a non blocking thread.\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed on the invoking thread and will return\n+    * only when the operation has completed, and does not require any additional threads.\n+    * @param runnable blocking operation that runs something\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @return a stage that is completed after the runnable is done or throws an exception\n+    */\n+   CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId);\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#handle(BiFunction)} when the function is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to handle\n+    * @param function the blocking function\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <I> input value type to the function\n+    * @param <O> output value type after being transformed via function\n+    * @return a stage that when complete will contain the value returned from the function or a throwable\n+    */\n+   <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n+         BiFunction<? super I, Throwable, ? extends O> function, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#thenApply(Function)} when the function is blocking to ensure the operation", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk4MDY4MA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413980680", "bodyText": "\ud83d\udc4d", "author": "wburns", "createdAt": "2020-04-23T17:19:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkzNjU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkzNzMxOQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413937319", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * Replacement for {@link CompletionStage#whenComplete(BiConsumer)} when the consumer is blocking to ensure the operation\n          \n          \n            \n                * Replacement for {@link CompletionStage#whenComplete(BiConsumer)} that invokes the {@code BiConsumer} in a blocking thread (if the current thread is non-blocking or the given stage is not done yet) or in the current thread (if the current thread is blocking and the stage is done).", "author": "danberindei", "createdAt": "2020-04-23T16:19:45Z", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {\n+   /**\n+    * Invokes the provided runnable in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread and if the returned\n+    * stage is not yet complete will perform any chained stages in a non blocking thread.\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed on the invoking thread and will return\n+    * only when the operation has completed, and does not require any additional threads.\n+    * @param runnable blocking operation that runs something\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @return a stage that is completed after the runnable is done or throws an exception\n+    */\n+   CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId);\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#handle(BiFunction)} when the function is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to handle\n+    * @param function the blocking function\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <I> input value type to the function\n+    * @param <O> output value type after being transformed via function\n+    * @return a stage that when complete will contain the value returned from the function or a throwable\n+    */\n+   <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n+         BiFunction<? super I, Throwable, ? extends O> function, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#thenApply(Function)} when the function is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to apply\n+    * @param function the blocking function\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <I> input value type to the function\n+    * @param <O> output value type after being transformed via function\n+    * @return a stage that when complete will contain the value returned from the function or a throwable\n+    */\n+   <I, O> CompletionStage<O> thenApplyBlocking(CompletionStage<? extends I> stage,\n+         Function<? super I, ? extends O> function, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#whenComplete(BiConsumer)} when the consumer is blocking to ensure the operation", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk4MDc0MQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413980741", "bodyText": "\ud83d\udc4d", "author": "wburns", "createdAt": "2020-04-23T17:19:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkzNzMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkzODMwMA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413938300", "bodyText": "Feels like there's something missing after \"any values published will be\"", "author": "danberindei", "createdAt": "2020-04-23T16:21:07Z", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {\n+   /**\n+    * Invokes the provided runnable in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread and if the returned\n+    * stage is not yet complete will perform any chained stages in a non blocking thread.\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed on the invoking thread and will return\n+    * only when the operation has completed, and does not require any additional threads.\n+    * @param runnable blocking operation that runs something\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @return a stage that is completed after the runnable is done or throws an exception\n+    */\n+   CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId);\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#handle(BiFunction)} when the function is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to handle\n+    * @param function the blocking function\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <I> input value type to the function\n+    * @param <O> output value type after being transformed via function\n+    * @return a stage that when complete will contain the value returned from the function or a throwable\n+    */\n+   <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n+         BiFunction<? super I, Throwable, ? extends O> function, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#thenApply(Function)} when the function is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to apply\n+    * @param function the blocking function\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <I> input value type to the function\n+    * @param <O> output value type after being transformed via function\n+    * @return a stage that when complete will contain the value returned from the function or a throwable\n+    */\n+   <I, O> CompletionStage<O> thenApplyBlocking(CompletionStage<? extends I> stage,\n+         Function<? super I, ? extends O> function, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#whenComplete(BiConsumer)} when the consumer is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to apply\n+    * @param biConsumer the blocking biConsumer\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> stage value type\n+    * @return a stage that is complete when the biConsumer is but retains the results from the original stage\n+    */\n+   <V> CompletionStage<V> whenCompleteBlocking(CompletionStage<V> stage,\n+         BiConsumer<? super V, ? super Throwable> biConsumer, Object traceId);\n+\n+   /**\n+    * When the provided stage is complete, continue the completion chain of the returned CompletionStage on the\n+    * supplied executor. If tracing is enabled a trace message is printed using the object as an identifier to more\n+    * easily track the transition between threads.\n+    * <p>\n+    * This method is useful when an asynchronous computation completes and you do not want to run further processing\n+    * on the thread that returned it. An example may be that some blocking operation is performed on a special blocking\n+    * thread pool. However when the blocking operation completes we will want to continue the processing of that result\n+    * in a thread pool that is for computational tasks.\n+    * <p>\n+    * If the supplied stage is already completed when invoking this command, this will return an already completed\n+    * stage, which means any additional dependent stages will run in the invoking thread.\n+    * @param <V> return value type of the supplied stage\n+    * @param delay the stage to delay the continuation until complete\n+    * @param traceId the id to print when tracing is enabled\n+    * @return a CompletionStage that when depended upon will run any callback in the supplied executor\n+    */\n+   <V> CompletionStage<V> continueOnNonBlockingThread(CompletionStage<V> delay, Object traceId);\n+\n+   /**\n+    * Provided a publisher that is known to block, this will ensure that the publisher is subscribed on the\n+    * blocking thread and any values published will be on a non blocking thread. Note that if a blocking thread", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk4MTIzMw==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413981233", "bodyText": "observed :)", "author": "wburns", "createdAt": "2020-04-23T17:20:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkzODMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkzOTQyMQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413939421", "bodyText": "Is \"these threads\" right, or should it be \"an additional thread\"?", "author": "danberindei", "createdAt": "2020-04-23T16:22:32Z", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {\n+   /**\n+    * Invokes the provided runnable in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread and if the returned\n+    * stage is not yet complete will perform any chained stages in a non blocking thread.\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed on the invoking thread and will return\n+    * only when the operation has completed, and does not require any additional threads.\n+    * @param runnable blocking operation that runs something\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @return a stage that is completed after the runnable is done or throws an exception\n+    */\n+   CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId);\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#handle(BiFunction)} when the function is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to handle\n+    * @param function the blocking function\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <I> input value type to the function\n+    * @param <O> output value type after being transformed via function\n+    * @return a stage that when complete will contain the value returned from the function or a throwable\n+    */\n+   <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n+         BiFunction<? super I, Throwable, ? extends O> function, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#thenApply(Function)} when the function is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to apply\n+    * @param function the blocking function\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <I> input value type to the function\n+    * @param <O> output value type after being transformed via function\n+    * @return a stage that when complete will contain the value returned from the function or a throwable\n+    */\n+   <I, O> CompletionStage<O> thenApplyBlocking(CompletionStage<? extends I> stage,\n+         Function<? super I, ? extends O> function, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#whenComplete(BiConsumer)} when the consumer is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to apply\n+    * @param biConsumer the blocking biConsumer\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> stage value type\n+    * @return a stage that is complete when the biConsumer is but retains the results from the original stage\n+    */\n+   <V> CompletionStage<V> whenCompleteBlocking(CompletionStage<V> stage,\n+         BiConsumer<? super V, ? super Throwable> biConsumer, Object traceId);\n+\n+   /**\n+    * When the provided stage is complete, continue the completion chain of the returned CompletionStage on the\n+    * supplied executor. If tracing is enabled a trace message is printed using the object as an identifier to more\n+    * easily track the transition between threads.\n+    * <p>\n+    * This method is useful when an asynchronous computation completes and you do not want to run further processing\n+    * on the thread that returned it. An example may be that some blocking operation is performed on a special blocking\n+    * thread pool. However when the blocking operation completes we will want to continue the processing of that result\n+    * in a thread pool that is for computational tasks.\n+    * <p>\n+    * If the supplied stage is already completed when invoking this command, this will return an already completed\n+    * stage, which means any additional dependent stages will run in the invoking thread.\n+    * @param <V> return value type of the supplied stage\n+    * @param delay the stage to delay the continuation until complete\n+    * @param traceId the id to print when tracing is enabled\n+    * @return a CompletionStage that when depended upon will run any callback in the supplied executor\n+    */\n+   <V> CompletionStage<V> continueOnNonBlockingThread(CompletionStage<V> delay, Object traceId);\n+\n+   /**\n+    * Provided a publisher that is known to block, this will ensure that the publisher is subscribed on the\n+    * blocking thread and any values published will be on a non blocking thread. Note that if a blocking thread\n+    * subscribes to the publisher these threads will not be used and thus the entire Publisher is subscribed and", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk4MTQzNQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413981435", "bodyText": "I can reword this.", "author": "wburns", "createdAt": "2020-04-23T17:20:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkzOTQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk0MTg3NQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413941875", "bodyText": "-1, it's not such a big deal to inject the non-blocking executor separately.\nOtherwise we shouldn't call it BlockingHandler IMO, it would need a name with Executor in it instead.", "author": "danberindei", "createdAt": "2020-04-23T16:25:40Z", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {\n+   /**\n+    * Invokes the provided runnable in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread and if the returned\n+    * stage is not yet complete will perform any chained stages in a non blocking thread.\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed on the invoking thread and will return\n+    * only when the operation has completed, and does not require any additional threads.\n+    * @param runnable blocking operation that runs something\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @return a stage that is completed after the runnable is done or throws an exception\n+    */\n+   CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId);\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#handle(BiFunction)} when the function is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to handle\n+    * @param function the blocking function\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <I> input value type to the function\n+    * @param <O> output value type after being transformed via function\n+    * @return a stage that when complete will contain the value returned from the function or a throwable\n+    */\n+   <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n+         BiFunction<? super I, Throwable, ? extends O> function, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#thenApply(Function)} when the function is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to apply\n+    * @param function the blocking function\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <I> input value type to the function\n+    * @param <O> output value type after being transformed via function\n+    * @return a stage that when complete will contain the value returned from the function or a throwable\n+    */\n+   <I, O> CompletionStage<O> thenApplyBlocking(CompletionStage<? extends I> stage,\n+         Function<? super I, ? extends O> function, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#whenComplete(BiConsumer)} when the consumer is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to apply\n+    * @param biConsumer the blocking biConsumer\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> stage value type\n+    * @return a stage that is complete when the biConsumer is but retains the results from the original stage\n+    */\n+   <V> CompletionStage<V> whenCompleteBlocking(CompletionStage<V> stage,\n+         BiConsumer<? super V, ? super Throwable> biConsumer, Object traceId);\n+\n+   /**\n+    * When the provided stage is complete, continue the completion chain of the returned CompletionStage on the\n+    * supplied executor. If tracing is enabled a trace message is printed using the object as an identifier to more\n+    * easily track the transition between threads.\n+    * <p>\n+    * This method is useful when an asynchronous computation completes and you do not want to run further processing\n+    * on the thread that returned it. An example may be that some blocking operation is performed on a special blocking\n+    * thread pool. However when the blocking operation completes we will want to continue the processing of that result\n+    * in a thread pool that is for computational tasks.\n+    * <p>\n+    * If the supplied stage is already completed when invoking this command, this will return an already completed\n+    * stage, which means any additional dependent stages will run in the invoking thread.\n+    * @param <V> return value type of the supplied stage\n+    * @param delay the stage to delay the continuation until complete\n+    * @param traceId the id to print when tracing is enabled\n+    * @return a CompletionStage that when depended upon will run any callback in the supplied executor\n+    */\n+   <V> CompletionStage<V> continueOnNonBlockingThread(CompletionStage<V> delay, Object traceId);\n+\n+   /**\n+    * Provided a publisher that is known to block, this will ensure that the publisher is subscribed on the\n+    * blocking thread and any values published will be on a non blocking thread. Note that if a blocking thread\n+    * subscribes to the publisher these threads will not be used and thus the entire Publisher is subscribed and\n+    * observed on the invoking thread, unless the caller changes this.\n+    * @param publisher the publisher that when subscribed to will block\n+    * @param <V> the published entry types\n+    * @return publisher that will not block the current thread\n+    */\n+   <V> Publisher<V> blockingPublisher(Publisher<V> publisher);\n+\n+   /**\n+    * Provides a {@link BlockingExecutor} which is limited to the provided concurrency amount.\n+    * @param name name of the limited blocking executor\n+    * @param concurrency maximum amount of concurrent operations to be performed via the returned executor\n+    * @return a blocking executor limited in the amount of concurrent invocations\n+    */\n+   BlockingExecutor limitedBlockingExecutor(String name, int concurrency);\n+\n+   /**\n+    * Retrieves the non blocking executor for use if needed.\n+    * @return executor that runs on non blocking threads\n+    */\n+   Executor getNonBlockingExecutor();", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk0NTMzOA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413945338", "bodyText": "Feels kind of artificial, to keep using BLOCKING_EXECUTOR without injecting it and triggering the checkstyle error.", "author": "danberindei", "createdAt": "2020-04-23T16:30:07Z", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {\n+   /**\n+    * Invokes the provided runnable in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread and if the returned\n+    * stage is not yet complete will perform any chained stages in a non blocking thread.\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed on the invoking thread and will return\n+    * only when the operation has completed, and does not require any additional threads.\n+    * @param runnable blocking operation that runs something\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @return a stage that is completed after the runnable is done or throws an exception\n+    */\n+   CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId);\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#handle(BiFunction)} when the function is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to handle\n+    * @param function the blocking function\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <I> input value type to the function\n+    * @param <O> output value type after being transformed via function\n+    * @return a stage that when complete will contain the value returned from the function or a throwable\n+    */\n+   <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n+         BiFunction<? super I, Throwable, ? extends O> function, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#thenApply(Function)} when the function is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to apply\n+    * @param function the blocking function\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <I> input value type to the function\n+    * @param <O> output value type after being transformed via function\n+    * @return a stage that when complete will contain the value returned from the function or a throwable\n+    */\n+   <I, O> CompletionStage<O> thenApplyBlocking(CompletionStage<? extends I> stage,\n+         Function<? super I, ? extends O> function, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#whenComplete(BiConsumer)} when the consumer is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to apply\n+    * @param biConsumer the blocking biConsumer\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> stage value type\n+    * @return a stage that is complete when the biConsumer is but retains the results from the original stage\n+    */\n+   <V> CompletionStage<V> whenCompleteBlocking(CompletionStage<V> stage,\n+         BiConsumer<? super V, ? super Throwable> biConsumer, Object traceId);\n+\n+   /**\n+    * When the provided stage is complete, continue the completion chain of the returned CompletionStage on the\n+    * supplied executor. If tracing is enabled a trace message is printed using the object as an identifier to more\n+    * easily track the transition between threads.\n+    * <p>\n+    * This method is useful when an asynchronous computation completes and you do not want to run further processing\n+    * on the thread that returned it. An example may be that some blocking operation is performed on a special blocking\n+    * thread pool. However when the blocking operation completes we will want to continue the processing of that result\n+    * in a thread pool that is for computational tasks.\n+    * <p>\n+    * If the supplied stage is already completed when invoking this command, this will return an already completed\n+    * stage, which means any additional dependent stages will run in the invoking thread.\n+    * @param <V> return value type of the supplied stage\n+    * @param delay the stage to delay the continuation until complete\n+    * @param traceId the id to print when tracing is enabled\n+    * @return a CompletionStage that when depended upon will run any callback in the supplied executor\n+    */\n+   <V> CompletionStage<V> continueOnNonBlockingThread(CompletionStage<V> delay, Object traceId);\n+\n+   /**\n+    * Provided a publisher that is known to block, this will ensure that the publisher is subscribed on the\n+    * blocking thread and any values published will be on a non blocking thread. Note that if a blocking thread\n+    * subscribes to the publisher these threads will not be used and thus the entire Publisher is subscribed and\n+    * observed on the invoking thread, unless the caller changes this.\n+    * @param publisher the publisher that when subscribed to will block\n+    * @param <V> the published entry types\n+    * @return publisher that will not block the current thread\n+    */\n+   <V> Publisher<V> blockingPublisher(Publisher<V> publisher);\n+\n+   /**\n+    * Provides a {@link BlockingExecutor} which is limited to the provided concurrency amount.\n+    * @param name name of the limited blocking executor\n+    * @param concurrency maximum amount of concurrent operations to be performed via the returned executor\n+    * @return a blocking executor limited in the amount of concurrent invocations\n+    */\n+   BlockingExecutor limitedBlockingExecutor(String name, int concurrency);", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk4Mjk3NA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413982974", "bodyText": "Nope, not quite. The returned Executor resumes a given task on a non blocking thread, unless the task was submitted by a blocking thread. And is a replacement when wanting to use a LimitedExecutor, but the tasks you submit to it can block.", "author": "wburns", "createdAt": "2020-04-23T17:23:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk0NTMzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU3MzE5Mg==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r414573192", "bodyText": "It feels artificial to me because we only need to replace the usage of LimitedExecutor to avoid the checkstyle error. It's also more \"limited\" than the original LimitedExecutor, which could run a task that does some blocking stuff and then some non-blocking stuff, releasing the permit only when the non-blocking stuff was done.", "author": "danberindei", "createdAt": "2020-04-24T13:24:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk0NTMzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU4MzYxOA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r414583618", "bodyText": "It feels artificial to me because we only need to replace the usage of LimitedExecutor to avoid the checkstyle error.\n\nThis doesn't just \"avoid\" the checkstyle. This ensures that the LimitedExecutor is used in a way to not leak the blocking threads after it is invoked. That is the entire point of anything with BlockingManager or any object produced from it.\n\nIt's also more \"limited\" than the original LimitedExecutor, which could run a task that does some blocking stuff and then some non-blocking stuff, releasing the permit only when the non-blocking stuff was done.\n\nThis doesn't replace the LimitedExecutor. This is only to use the LimitedExecutor with blocking threads to ensure they don't escape.\nAnd I am guessing you are referring to the Supplier invocation with a CompletionStage? There is no reason we can't change the BlockingManager over time if needed too :)", "author": "wburns", "createdAt": "2020-04-24T13:39:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk0NTMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk0NjYyMg==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413946622", "bodyText": "Could be private", "author": "danberindei", "createdAt": "2020-04-23T16:31:48Z", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandlerImpl.java", "diffHunk": "@@ -0,0 +1,235 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.commons.executors.BlockingResource;\n+import org.infinispan.executors.LimitedExecutor;\n+import org.infinispan.factories.KnownComponentNames;\n+import org.infinispan.factories.annotations.ComponentName;\n+import org.infinispan.factories.annotations.Inject;\n+import org.infinispan.factories.annotations.Start;\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.Flowable;\n+import io.reactivex.Scheduler;\n+import io.reactivex.schedulers.Schedulers;\n+\n+@Scope(Scopes.GLOBAL)\n+public class BlockingHandlerImpl implements BlockingHandler {\n+   private static final Log log = LogFactory.getLog(MethodHandles.lookup().lookupClass());\n+   private static final boolean trace = log.isTraceEnabled();\n+\n+   @Inject @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR)\n+   Executor nonBlockingExecutor;\n+   // This should eventually be the only reference to blocking executor\n+   @SuppressWarnings(\"checkstyle:RegexpSinglelineJava\")\n+   @Inject @ComponentName(KnownComponentNames.BLOCKING_EXECUTOR)\n+   Executor blockingExecutor;\n+\n+   Scheduler blockingScheduler;\n+   Scheduler nonBlockingScheduler;", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk4MjE2Nw==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413982167", "bodyText": "Yeah, I actually changed this on a dependent branch, hehe.", "author": "wburns", "createdAt": "2020-04-23T17:21:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk0NjYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1MTczNA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413951734", "bodyText": "It was only deprecated in 11, we can't remove it so soon.", "author": "danberindei", "createdAt": "2020-04-23T16:38:30Z", "path": "core/src/main/java/org/infinispan/util/concurrent/CompletionStages.java", "diffHunk": "@@ -126,45 +125,6 @@ public static boolean isCompletedSuccessfully(CompletionStage<?> stage) {\n       return aggregateCompletionStage != null ? aggregateCompletionStage.freeze() : CompletableFutures.completedNull();\n    }\n \n-   /**\n-    * When the provided stage is complete, continue the completion chain of the returned CompletionStage on the\n-    * supplied executor. If tracing is enabled a trace message is printed using the object as an identifier to more\n-    * easily track the transition between threads.\n-    * <p>\n-    * This method is useful when an asynchronous computation completes and you do not want to run further processing\n-    * on the thread that returned it. An example may be that some blocking operation is performed on a special blocking\n-    * thread pool. However when the blocking operation completes we will want to continue the processing of that result\n-    * in a thread pool that is for computational tasks.\n-    * <p>\n-    * If the supplied stage is already completed when invoking this command, this will return an already completed\n-    * stage, which means any additional dependent stages will run in the invoking thread.\n-    * @param <V> return value type of the supplied stage\n-    * @param delay the stage to delay the continuation until complete\n-    * @param continuationExecutor the executor to run any further completion chain methods on\n-    * @param traceId the id to print when tracing is enabled\n-    * @return a CompletionStage that when depended upon will run any callback in the supplied executor\n-    * @deprecated This method is to be removed and replaced with a component to handle thread continuations in a better manner", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3MzU5MA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413973590", "bodyText": "It is actually an private package, so it should be fine.", "author": "wburns", "createdAt": "2020-04-23T17:09:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1MTczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1Mjk2Nw==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413952967", "bodyText": "I'm guessing this needs to be reverted", "author": "danberindei", "createdAt": "2020-04-23T16:40:21Z", "path": "core/src/test/java/org/infinispan/xsite/CacheOperationsTest.java", "diffHunk": "@@ -36,14 +36,14 @@\n    @Factory\n    public Object[] factory() {\n       return new Object[] {\n-            new CacheOperationsTest().cacheMode(CacheMode.DIST_SYNC).transactional(false),\n-            new CacheOperationsTest().cacheMode(CacheMode.REPL_SYNC).transactional(false),\n+//            new CacheOperationsTest().cacheMode(CacheMode.DIST_SYNC).transactional(false),\n+//            new CacheOperationsTest().cacheMode(CacheMode.REPL_SYNC).transactional(false),", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk4MzA2NQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413983065", "bodyText": "Yeah, oops :)", "author": "wburns", "createdAt": "2020-04-23T17:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1Mjk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NjIwNg==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413956206", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               public <T> CompletableFuture<T> runTask(String taskName, TaskContext context, BlockingHandler blockingHandler) {\n          \n          \n            \n               public <T> CompletionStage<T> runTask(String taskName, TaskContext context, BlockingHandler blockingHandler) {", "author": "danberindei", "createdAt": "2020-04-23T16:44:54Z", "path": "server/core/src/main/java/org/infinispan/server/core/admin/AdminOperationsHandler.java", "diffHunk": "@@ -41,9 +41,9 @@ public String getName() {\n    }\n \n    @Override\n-   public <T> CompletableFuture<T> runTask(String taskName, TaskContext context, Executor executor) {\n+   public <T> CompletableFuture<T> runTask(String taskName, TaskContext context, BlockingHandler blockingHandler) {", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk4MzM1Nw==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413983357", "bodyText": "Sure. I didn't scan through the various ones to see if they could be updated. I will take a glance through and if they are private change the return type.", "author": "wburns", "createdAt": "2020-04-23T17:23:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NjIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NzMwNQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413957305", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               CompletableFuture<Void> asyncCompleteLocalTransaction(AdvancedCache<?, ?> cache, long timeout) {\n          \n          \n            \n               CompletionStage<Void> asyncCompleteLocalTransaction(AdvancedCache<?, ?> cache, long timeout) {", "author": "danberindei", "createdAt": "2020-04-23T16:46:25Z", "path": "server/hotrod/src/main/java/org/infinispan/server/hotrod/tx/operation/CommitTransactionOperation.java", "diffHunk": "@@ -150,8 +150,7 @@ CacheRpcCommand buildForwardCommand(ByteString cacheName, long timeout) {\n \n    @Override\n    CompletableFuture<Void> asyncCompleteLocalTransaction(AdvancedCache<?, ?> cache, long timeout) {", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk4NTQxMQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413985411", "bodyText": "\ud83d\udc4d", "author": "wburns", "createdAt": "2020-04-23T17:26:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NzMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NzUwNA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413957504", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               CompletableFuture<Void> asyncCompleteLocalTransaction(AdvancedCache<?, ?> cache, long timeout) {\n          \n          \n            \n               CompletionStage<Void> asyncCompleteLocalTransaction(AdvancedCache<?, ?> cache, long timeout) {", "author": "danberindei", "createdAt": "2020-04-23T16:46:42Z", "path": "server/hotrod/src/main/java/org/infinispan/server/hotrod/tx/operation/RollbackTransactionOperation.java", "diffHunk": "@@ -143,8 +143,7 @@ CacheRpcCommand buildForwardCommand(ByteString cacheName, long timeout) {\n \n    @Override\n    CompletableFuture<Void> asyncCompleteLocalTransaction(AdvancedCache<?, ?> cache, long timeout) {", "originalCommit": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk4NTQzMw==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413985433", "bodyText": "\ud83d\udc4d", "author": "wburns", "createdAt": "2020-04-23T17:26:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NzUwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc4MTYyNQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r415781625", "bodyText": "Was there an issue with CompletionStage here?", "author": "danberindei", "createdAt": "2020-04-27T12:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NzUwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg3MTMwMQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r415871301", "bodyText": "Nope, I updated the parent one and missed this one.", "author": "wburns", "createdAt": "2020-04-27T14:40:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NzUwNA=="}], "type": "inlineReview"}, {"oid": "89fc8237aa21b19c5f2f2c020499e91f56835d60", "url": "https://github.com/infinispan/infinispan/commit/89fc8237aa21b19c5f2f2c020499e91f56835d60", "message": "rework comments", "committedDate": "2020-04-23T19:21:18Z", "type": "forcePushed"}, {"oid": "21d42d4e2e030a29eea0cf5fb426c4628a22904b", "url": "https://github.com/infinispan/infinispan/commit/21d42d4e2e030a29eea0cf5fb426c4628a22904b", "message": "ISPN-11543 Jgroups Stacks should be initailized lazily", "committedDate": "2020-04-23T19:23:04Z", "type": "forcePushed"}, {"oid": "eeefdb2aeae749f85050fe19aebf3e5b9c3b801a", "url": "https://github.com/infinispan/infinispan/commit/eeefdb2aeae749f85050fe19aebf3e5b9c3b801a", "message": "ISPN-11543 JGroups Stacks should be initailized lazily", "committedDate": "2020-04-23T19:25:41Z", "type": "forcePushed"}, {"oid": "d2f32657ed9bd068b88e73347f8946d7bee51630", "url": "https://github.com/infinispan/infinispan/commit/d2f32657ed9bd068b88e73347f8946d7bee51630", "message": "ISPN-11703 JGroups Stacks should be initailized lazily", "committedDate": "2020-04-23T19:32:27Z", "type": "forcePushed"}, {"oid": "7a1122b64b8d7e693e821c92db8e5bc91d9569cb", "url": "https://github.com/infinispan/infinispan/commit/7a1122b64b8d7e693e821c92db8e5bc91d9569cb", "message": "ISPN-11703 JGroups Stacks should be initailized lazily", "committedDate": "2020-04-24T12:33:25Z", "type": "forcePushed"}, {"oid": "ee3a49233b2c8d17f44939cd611d6fdf816a4908", "url": "https://github.com/infinispan/infinispan/commit/ee3a49233b2c8d17f44939cd611d6fdf816a4908", "message": "ISPN-11703 JGroups Stacks should be initailized lazily", "committedDate": "2020-04-24T12:37:41Z", "type": "forcePushed"}, {"oid": "848294324297c6c1a40d61db698b07ea1978fb06", "url": "https://github.com/infinispan/infinispan/commit/848294324297c6c1a40d61db698b07ea1978fb06", "message": "ISPN-11703 JGroups Stacks should be initailized lazily", "committedDate": "2020-04-24T13:12:26Z", "type": "forcePushed"}, {"oid": "9e6611547638951b23317604865d30d1e114288c", "url": "https://github.com/infinispan/infinispan/commit/9e6611547638951b23317604865d30d1e114288c", "message": "ISPN-11703 JGroups Stacks should be initailized lazily", "committedDate": "2020-04-24T13:17:11Z", "type": "forcePushed"}, {"oid": "1e6cc8a71dffccf49972ee582914416ab79c1f11", "url": "https://github.com/infinispan/infinispan/commit/1e6cc8a71dffccf49972ee582914416ab79c1f11", "message": "ISPN-11703 JGroups Stacks should be initailized lazily", "committedDate": "2020-04-24T13:23:20Z", "type": "forcePushed"}, {"oid": "5769af44281c4d77c3c8dd52d3fa64109a3bcc0d", "url": "https://github.com/infinispan/infinispan/commit/5769af44281c4d77c3c8dd52d3fa64109a3bcc0d", "message": "ISPN-11703 JGroups Stacks should be initialized lazily", "committedDate": "2020-04-24T13:36:14Z", "type": "forcePushed"}, {"oid": "acaa9896edc84be5fdf2ddfa76ed6fee417b2a82", "url": "https://github.com/infinispan/infinispan/commit/acaa9896edc84be5fdf2ddfa76ed6fee417b2a82", "message": "ISPN-11703 JGroups Stacks should be initialized lazily", "committedDate": "2020-04-24T15:01:41Z", "type": "forcePushed"}, {"oid": "be49a9674065e5131300c074d8a2f50090b00593", "url": "https://github.com/infinispan/infinispan/commit/be49a9674065e5131300c074d8a2f50090b00593", "message": "ISPN-11703 JGroups Stacks should be initialized lazily", "committedDate": "2020-04-24T16:55:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc1OTUwMA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r415759500", "bodyText": "Join lines please", "author": "danberindei", "createdAt": "2020-04-27T12:12:54Z", "path": "core/src/main/java/org/infinispan/globalstate/impl/GlobalConfigurationManagerImpl.java", "diffHunk": "@@ -54,8 +52,8 @@\n    @Inject ConfigurationManager configurationManager;\n    @Inject InternalCacheRegistry internalCacheRegistry;\n    @Inject GlobalComponentRegistry globalComponentRegistry;\n-   @Inject @ComponentName(KnownComponentNames.BLOCKING_EXECUTOR)\n-   ExecutorService blockingExecutor;\n+   @Inject\n+   BlockingManager blockingManager;", "originalCommit": "be49a9674065e5131300c074d8a2f50090b00593", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg4ODUzOQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r415888539", "bodyText": "Done", "author": "wburns", "createdAt": "2020-04-27T15:00:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc1OTUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc2MTMyNQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r415761325", "bodyText": "Join lines please", "author": "danberindei", "createdAt": "2020-04-27T12:16:00Z", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -141,8 +136,8 @@\n    @Inject CacheNotifier cacheNotifier;\n    @Inject KeyPartitioner keyPartitioner;\n    @Inject Transport transport;\n-   @Inject @ComponentName(NON_BLOCKING_EXECUTOR)\n-   ExecutorService nonBlockingExecutor;\n+   @Inject\n+   BlockingManager handler;", "originalCommit": "be49a9674065e5131300c074d8a2f50090b00593", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg4ODU4MQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r415888581", "bodyText": "Done", "author": "wburns", "createdAt": "2020-04-27T15:00:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc2MTMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc3NjExNw==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r415776117", "bodyText": "I didn't notice this before, are we assuming that the listeners are blocking?\nUpdate: Never mind, I see now that counters don't have a non-blocking listener interface, and our internal implementation potentially blocks when the event queue is full.", "author": "danberindei", "createdAt": "2020-04-27T12:38:36Z", "path": "counter/src/main/java/org/infinispan/counter/impl/listener/CounterManagerNotificationManager.java", "diffHunk": "@@ -69,15 +67,15 @@ public CounterManagerNotificationManager() {\n    }\n \n    /**\n-    * The executor to use where the user's {@link CounterListener} is invoked.\n+    * The blockingManager to use where the user's {@link CounterListener} is invoked.\n     *\n-    * @param asyncExecutor The {@link Executor} implementation.\n+    * @param blockingManager The {@link BlockingManager} to use.\n     */\n-   public void useExecutor(Executor asyncExecutor) {\n-      if (asyncExecutor == null) {\n+   public void useBlockingManager(BlockingManager blockingManager) {\n+      if (blockingManager == null) {\n          return;\n       }\n-      userListenerExecutor = new LimitedExecutor(\"counter-listener\", asyncExecutor, 1);\n+      userListenerExecutor = blockingManager.limitedBlockingExecutor(\"counter-listener\", 1);", "originalCommit": "be49a9674065e5131300c074d8a2f50090b00593", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg3MDQ4NA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r415870484", "bodyText": "Yeah, the counter listener hasn't been updated to support non blocking.\nI have created https://issues.redhat.com/browse/ISPN-11720", "author": "wburns", "createdAt": "2020-04-27T14:40:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc3NjExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc4Mjk1OQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r415782959", "bodyText": "IMO rollbackOldTransaction should return CompletionStage", "author": "danberindei", "createdAt": "2020-04-27T12:48:45Z", "path": "server/hotrod/src/main/java/org/infinispan/server/hotrod/tx/table/GlobalTxTable.java", "diffHunk": "@@ -257,8 +254,9 @@ private void onOngoingTransaction(CacheXid cacheXid, TxState state) {\n             //local transaction doesn't exists.\n             onTransactionCompleted(cacheXid);\n          } else {\n-            blockingExecutor.execute(\n-                  () -> rollbackOldTransaction(cacheXid, state, () -> completeLocal(txTable, cacheXid, tx, false)));\n+            blockingManager.runBlocking(\n+                  () -> rollbackOldTransaction(cacheXid, state, () -> completeLocal(txTable, cacheXid, tx, false)),", "originalCommit": "be49a9674065e5131300c074d8a2f50090b00593", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg4NjE1NQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r415886155", "bodyText": "Hrmm... yeah interesting. This will actually change the behavior to wait for the rollback to complete. However I noticed that line 248 also doesn't wait. I think I will create a JIRA for someone to look into this separately, since I am not familiar with it and don't want it to hold this up.\nhttps://issues.redhat.com/browse/ISPN-11722", "author": "wburns", "createdAt": "2020-04-27T14:57:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc4Mjk1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTkwMDM3OQ==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r415900379", "bodyText": "Ok", "author": "danberindei", "createdAt": "2020-04-27T15:14:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc4Mjk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc4NDUyNg==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r415784526", "bodyText": "I'd rather declare the variable as CompletionStage here and use CompletionStages.join() on the next line.", "author": "danberindei", "createdAt": "2020-04-27T12:51:02Z", "path": "tasks/manager/src/test/java/org/infinispan/tasks/TaskManagerTest.java", "diffHunk": "@@ -58,7 +58,7 @@ public void testStoredEngines() {\n \n    public void testRunTask() throws InterruptedException, ExecutionException {\n       memoryLogger.reset();\n-      CompletableFuture<String> okTask = taskManager.runTask(DummyTaskTypes.SUCCESSFUL_TASK.name(), new TaskContext().logEvent(true));\n+      CompletableFuture<String> okTask = taskManager.<String>runTask(DummyTaskTypes.SUCCESSFUL_TASK.name(), new TaskContext().logEvent(true)).toCompletableFuture();", "originalCommit": "be49a9674065e5131300c074d8a2f50090b00593", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg4NjMwMA==", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r415886300", "bodyText": "Sure", "author": "wburns", "createdAt": "2020-04-27T14:57:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc4NDUyNg=="}], "type": "inlineReview"}, {"oid": "fce778164ae0f1778e38036d7f10afec5673e923", "url": "https://github.com/infinispan/infinispan/commit/fce778164ae0f1778e38036d7f10afec5673e923", "message": "ISPN-11703 JGroups Stacks should be initialized lazily", "committedDate": "2020-04-27T15:01:05Z", "type": "forcePushed"}, {"oid": "28e7ca18036ec676d6ffd73a66991e04ebf9c6fb", "url": "https://github.com/infinispan/infinispan/commit/28e7ca18036ec676d6ffd73a66991e04ebf9c6fb", "message": "ISPN-11703 JGroups Stacks should be initialized lazily", "committedDate": "2020-04-27T15:04:38Z", "type": "forcePushed"}, {"oid": "d15b615796e4d9de732e166f1e720df30982939f", "url": "https://github.com/infinispan/infinispan/commit/d15b615796e4d9de732e166f1e720df30982939f", "message": "ISPN-11543 Add BlockingHandler to simplify running blocking operations", "committedDate": "2020-04-27T15:49:33Z", "type": "commit"}, {"oid": "7b4cfc8a065fd5dd703bc4a73a2cbe9799bd6ec3", "url": "https://github.com/infinispan/infinispan/commit/7b4cfc8a065fd5dd703bc4a73a2cbe9799bd6ec3", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block", "committedDate": "2020-04-27T15:49:33Z", "type": "commit"}, {"oid": "3519e557c5671cac5b9bf508d7a36fe87a9f3a18", "url": "https://github.com/infinispan/infinispan/commit/3519e557c5671cac5b9bf508d7a36fe87a9f3a18", "message": "ISPN-11703 JGroups Stacks should be initialized lazily", "committedDate": "2020-04-27T15:49:33Z", "type": "commit"}, {"oid": "3519e557c5671cac5b9bf508d7a36fe87a9f3a18", "url": "https://github.com/infinispan/infinispan/commit/3519e557c5671cac5b9bf508d7a36fe87a9f3a18", "message": "ISPN-11703 JGroups Stacks should be initialized lazily", "committedDate": "2020-04-27T15:49:33Z", "type": "forcePushed"}]}