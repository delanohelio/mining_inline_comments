{"pr_number": 8417, "pr_title": "ISPN-10373 Rework put map and simplify batch", "pr_createdAt": "2020-06-02T06:07:54Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8417", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg4OTAwOA==", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r433889008", "bodyText": "No longer exists.", "author": "ryanemerson", "createdAt": "2020-06-02T13:48:42Z", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -997,84 +1008,35 @@ private boolean shouldPerformTransactionOperation(StoreStatus storeStatus, Predi\n     * <p>\n     * The {@link HandleFlowables} is provided for the sole reason of allowing reuse of this method by different callers.\n     * @param ctx the transactional context with modifications", "originalCommit": "76b48006e6a9ce53f8912bcf11fda4a5c3192144", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg4OTE5NA==", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r433889194", "bodyText": "Javadoc for mvccEntryFlowable missing.", "author": "ryanemerson", "createdAt": "2020-06-02T13:48:58Z", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -997,84 +1008,35 @@ private boolean shouldPerformTransactionOperation(StoreStatus storeStatus, Predi\n     * <p>\n     * The {@link HandleFlowables} is provided for the sole reason of allowing reuse of this method by different callers.\n     * @param ctx the transactional context with modifications\n-    * @param commandKeyPredicate predicate to test if a key/command combination should be written\n     * @param flowableHandler callback handler that actually should subscribe to the underlying store\n     * @param <K> key type\n     * @param <V> value type\n     * @return a stage that when complete will contain how many write operations were done\n     */\n-   private <K, V> CompletionStage<Long> batchOperation(TxInvocationContext<AbstractCacheTransaction> ctx,\n-         BiPredicate<WriteCommand, Object> commandKeyPredicate, HandleFlowables<K, V> flowableHandler) {\n+   private <K, V> CompletionStage<Long> batchOperation(Flowable<MVCCEntry<K, V>> mvccEntryFlowable, InvocationContext ctx,", "originalCommit": "76b48006e6a9ce53f8912bcf11fda4a5c3192144", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwMzAyMA==", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r433903020", "bodyText": "Wiith the various if (segmented) and if (shared) branches, this is now very difficult to read. Can we divide this further so that we have a createWriteFlowable(Flowable<MarshallableEntry<K, V>> entryWriteFlowable, boolean shared, boolean segmented) and equivalent createRemoveFlowable methods, containing their respective trace logs.", "author": "ryanemerson", "createdAt": "2020-06-02T14:05:20Z", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -997,84 +1008,35 @@ private boolean shouldPerformTransactionOperation(StoreStatus storeStatus, Predi\n     * <p>\n     * The {@link HandleFlowables} is provided for the sole reason of allowing reuse of this method by different callers.\n     * @param ctx the transactional context with modifications\n-    * @param commandKeyPredicate predicate to test if a key/command combination should be written\n     * @param flowableHandler callback handler that actually should subscribe to the underlying store\n     * @param <K> key type\n     * @param <V> value type\n     * @return a stage that when complete will contain how many write operations were done\n     */\n-   private <K, V> CompletionStage<Long> batchOperation(TxInvocationContext<AbstractCacheTransaction> ctx,\n-         BiPredicate<WriteCommand, Object> commandKeyPredicate, HandleFlowables<K, V> flowableHandler) {\n+   private <K, V> CompletionStage<Long> batchOperation(Flowable<MVCCEntry<K, V>> mvccEntryFlowable, InvocationContext ctx,\n+         HandleFlowables<K, V> flowableHandler) {\n       return Single.using(\n             this::acquireReadLock,\n             ignore -> {\n                checkStoreAvailability();\n                if (trace) {\n                   log.trace(\"Writing batch to stores\");\n                }\n-               int size = stores.size();\n-               if (size == 0) {\n-                  return Single.just(0L);\n-               }\n-\n-               Flowable<MVCCEntry<K, V>> mvccEntryFlowable = Flowable.fromIterable(ctx.getCacheTransaction().getAllModifications())\n-                     .filter(writeCommand -> !writeCommand.hasAnyFlag(FlagBitSets.SKIP_CACHE_STORE))\n-                     .concatMap(writeCommand -> {\n-                        if (writeCommand instanceof DataWriteCommand) {\n-                           Object key = ((DataWriteCommand) writeCommand).getKey();\n-                           MVCCEntry<K, V> entry = acquireKeyFromContext(ctx, writeCommand, key, commandKeyPredicate);\n-                           return entry != null ? Flowable.just(entry) : Flowable.empty();\n-                        } else {\n-                           // Assume multiple key command\n-                           return Flowable.fromIterable(writeCommand.getAffectedKeys())\n-                                 .concatMapMaybe(key -> {\n-                                    MVCCEntry<K, V> entry = acquireKeyFromContext(ctx, writeCommand, key, commandKeyPredicate);\n-                                    // We use an empty Flowable to symbolize a miss - which is filtered by ofType just below\n-                                    return entry != null ? Maybe.just(entry) : Maybe.empty();\n-                                 });\n-                        }\n-                     });\n-               // We split the original source into possibly multiple, depending upon how many stores there are\n-               ConnectableFlowable<MVCCEntry<K, V>> connectableFlowable = mvccEntryFlowable.publish();\n-\n-               // We may have multiple stores - don't publish anything until this value goes back to 0\n-               AtomicInteger pendingConnects = new AtomicInteger(size);\n-               if (trace) {\n-                  log.tracef(\"Will wait for %s subscriptions of stores\", size);\n-               }\n \n                return Flowable.fromIterable(stores)", "originalCommit": "76b48006e6a9ce53f8912bcf11fda4a5c3192144", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk0MzkxOA==", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r433943918", "bodyText": "Sure", "author": "wburns", "createdAt": "2020-06-02T15:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwMzAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwODc2NA==", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r433908764", "bodyText": "It's not from this PR, but can we break this into a CompletionStage<Void> var that is passed to fromCompletionStage. It is very difficult to read atm.", "author": "ryanemerson", "createdAt": "2020-06-02T14:12:09Z", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -1109,21 +1084,38 @@ private boolean shouldPerformTransactionOperation(StoreStatus storeStatus, Predi\n                               });\n \n                         AtomicLong writeCount = new AtomicLong();\n-                        entryWriteFlowable = entryWriteFlowable.doOnNext(me -> writeCount.incrementAndGet());\n \n                         Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable;\n \n                         if (segmented) {\n+                           // Note the writeCount includes entries that aren't written due to being shared\n+                           // at this point\n+                           entryWriteFlowable = entryWriteFlowable.doOnNext(obj -> writeCount.incrementAndGet());\n                            writeFlowable = entryWriteFlowable\n                                  .groupBy(me -> keyPartitioner.getSegment(me.getKey()))\n                                  .map(SegmentPublisherWrapper::wrap);\n+                           if (shared) {\n+                              // The writeCount will be decremented for each grouping of values ignored\n+                              writeFlowable = filterSharedSegments(writeFlowable, writeCount);\n+                           }\n                         } else {\n+                           if (shared) {\n+                              entryWriteFlowable = entryWriteFlowable.filter(me ->\n+                                    distributionManager.getCacheTopology().getDistribution(me.getKey()).isPrimary());\n+                           }\n+                           entryWriteFlowable = entryWriteFlowable.doOnNext(obj -> writeCount.incrementAndGet());\n                            writeFlowable = Flowable.just(SingleSegmentPublisher.singleSegment(entryWriteFlowable));\n                         }\n \n                         if (trace) {\n-                           removeFlowable = removeFlowable.doOnSubscribe(sub ->\n+                           writeFlowable = writeFlowable.doOnSubscribe(sub ->\n                               log.tracef(\"Store %s has subscribed to write batch\", storeStatus.store));\n+                           writeFlowable = writeFlowable.map(sp -> {\n+                              int segment = sp.getSegment();\n+                              return SingleSegmentPublisher.singleSegment(segment, Flowable.fromPublisher(sp)\n+                                    .doOnNext(me -> log.tracef(\"Emitting entry %s for write to segment %s\",\n+                                          me, segment)));\n+                           });\n                         }\n \n                         return Single.fromCompletionStage(flowableHandler.handleFlowables(storeStatus.store(),", "originalCommit": "76b48006e6a9ce53f8912bcf11fda4a5c3192144", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk0NDMzMw==", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r433944333", "bodyText": "Okay.", "author": "wburns", "createdAt": "2020-06-02T15:00:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwODc2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwOTU5Ng==", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r433909596", "bodyText": "Is there a better way of doing this? I don't have an alternative suggestion but this smells funny.", "author": "ryanemerson", "createdAt": "2020-06-02T14:13:15Z", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -1136,9 +1128,59 @@ private boolean shouldPerformTransactionOperation(StoreStatus storeStatus, Predi\n       ).toCompletionStage();\n    }\n \n-   private <K, V> MVCCEntry<K, V> acquireKeyFromContext(InvocationContext ctx, WriteCommand command, Object key,\n-         BiPredicate<WriteCommand, Object> commandKeyPredicate) {\n-      if (commandKeyPredicate.test(command, key)) {\n+   private <I> Flowable<NonBlockingStore.SegmentedPublisher<I>> filterSharedSegments(\n+         Flowable<NonBlockingStore.SegmentedPublisher<I>> flowable, AtomicLong writeCount) {\n+      return flowable.filter(sp -> {\n+         if (distributionManager.getCacheTopology().getSegmentDistribution(sp.getSegment()).isPrimary()) {\n+            return true;\n+         }\n+         // Way to ensure the filtered groups are still subscribed and the values are not counted\n+         Flowable.fromPublisher(sp)\n+               .count()\n+               .subscribe(ignoredCount -> {\n+                  if (writeCount != null) {\n+                     writeCount.addAndGet(-ignoredCount);\n+                  }\n+               });", "originalCommit": "76b48006e6a9ce53f8912bcf11fda4a5c3192144", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3f780e777290fdeb283e01591a59e6f294b0226e", "url": "https://github.com/infinispan/infinispan/commit/3f780e777290fdeb283e01591a59e6f294b0226e", "message": "Rework comments", "committedDate": "2020-06-02T15:23:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5MjU1OQ==", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r434592559", "bodyText": "variable can just be flowable to reduce verbosity now that it's within the createRemoveFlowable method.", "author": "ryanemerson", "createdAt": "2020-06-03T14:04:29Z", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -1109,36 +1054,139 @@ private boolean shouldPerformTransactionOperation(StoreStatus storeStatus, Predi\n                               });\n \n                         AtomicLong writeCount = new AtomicLong();\n-                        entryWriteFlowable = entryWriteFlowable.doOnNext(me -> writeCount.incrementAndGet());\n-\n-                        Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable;\n \n-                        if (segmented) {\n-                           writeFlowable = entryWriteFlowable\n-                                 .groupBy(me -> keyPartitioner.getSegment(me.getKey()))\n-                                 .map(SegmentPublisherWrapper::wrap);\n-                        } else {\n-                           writeFlowable = Flowable.just(SingleSegmentPublisher.singleSegment(entryWriteFlowable));\n-                        }\n+                        Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable =\n+                              createWriteFlowable(entryWriteFlowable, shared, segmented, writeCount, storeStatus);\n \n-                        if (trace) {\n-                           removeFlowable = removeFlowable.doOnSubscribe(sub ->\n-                              log.tracef(\"Store %s has subscribed to write batch\", storeStatus.store));\n-                        }\n+                        CompletionStage<Void> storeBatchStage = flowableHandler.handleFlowables(storeStatus.store(),\n+                              segmentCount(segmented), removeFlowable, writeFlowable);\n \n-                        return Single.fromCompletionStage(flowableHandler.handleFlowables(storeStatus.store(),\n-                              segmentCount(segmented), removeFlowable, writeFlowable)\n-                              .thenApply(ignore2 -> writeCount.get()));\n-                     }).first(0L);\n+                        return Single.fromCompletionStage(storeBatchStage)\n+                              .map(ignore2 -> writeCount.get());\n+                        // Only take the last element for the count - ensures all stores are completed\n+                     }).last(0L);\n \n             },\n             this::releaseReadLock\n       ).toCompletionStage();\n    }\n \n-   private <K, V> MVCCEntry<K, V> acquireKeyFromContext(InvocationContext ctx, WriteCommand command, Object key,\n-         BiPredicate<WriteCommand, Object> commandKeyPredicate) {\n-      if (commandKeyPredicate.test(command, key)) {\n+   <K> Flowable<NonBlockingStore.SegmentedPublisher<K>> createRemoveFlowable(Flowable<K> keyRemoveFlowable,\n+         boolean shared, boolean segmented, StoreStatus storeStatus) {\n+      Flowable<NonBlockingStore.SegmentedPublisher<K>> removeFlowable;", "originalCommit": "3f780e777290fdeb283e01591a59e6f294b0226e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5MzQ5NQ==", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r434593495", "bodyText": "I didn't say this before, but let's pass the keyRemoveFlowable in this method and just pass flowableToUse from batchOperation. That way the logic is in a single method.", "author": "ryanemerson", "createdAt": "2020-06-03T14:05:44Z", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -1109,36 +1054,139 @@ private boolean shouldPerformTransactionOperation(StoreStatus storeStatus, Predi\n                               });\n \n                         AtomicLong writeCount = new AtomicLong();\n-                        entryWriteFlowable = entryWriteFlowable.doOnNext(me -> writeCount.incrementAndGet());\n-\n-                        Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable;\n \n-                        if (segmented) {\n-                           writeFlowable = entryWriteFlowable\n-                                 .groupBy(me -> keyPartitioner.getSegment(me.getKey()))\n-                                 .map(SegmentPublisherWrapper::wrap);\n-                        } else {\n-                           writeFlowable = Flowable.just(SingleSegmentPublisher.singleSegment(entryWriteFlowable));\n-                        }\n+                        Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable =\n+                              createWriteFlowable(entryWriteFlowable, shared, segmented, writeCount, storeStatus);\n \n-                        if (trace) {\n-                           removeFlowable = removeFlowable.doOnSubscribe(sub ->\n-                              log.tracef(\"Store %s has subscribed to write batch\", storeStatus.store));\n-                        }\n+                        CompletionStage<Void> storeBatchStage = flowableHandler.handleFlowables(storeStatus.store(),\n+                              segmentCount(segmented), removeFlowable, writeFlowable);\n \n-                        return Single.fromCompletionStage(flowableHandler.handleFlowables(storeStatus.store(),\n-                              segmentCount(segmented), removeFlowable, writeFlowable)\n-                              .thenApply(ignore2 -> writeCount.get()));\n-                     }).first(0L);\n+                        return Single.fromCompletionStage(storeBatchStage)\n+                              .map(ignore2 -> writeCount.get());\n+                        // Only take the last element for the count - ensures all stores are completed\n+                     }).last(0L);\n \n             },\n             this::releaseReadLock\n       ).toCompletionStage();\n    }\n \n-   private <K, V> MVCCEntry<K, V> acquireKeyFromContext(InvocationContext ctx, WriteCommand command, Object key,\n-         BiPredicate<WriteCommand, Object> commandKeyPredicate) {\n-      if (commandKeyPredicate.test(command, key)) {\n+   <K> Flowable<NonBlockingStore.SegmentedPublisher<K>> createRemoveFlowable(Flowable<K> keyRemoveFlowable,", "originalCommit": "3f780e777290fdeb283e01591a59e6f294b0226e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5ODg4NA==", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r434598884", "bodyText": "If we pass shared to the method, this will make the code easier to read IMO. e.g.:\n   private <I> Flowable<NonBlockingStore.SegmentedPublisher<I>> filterSharedSegments(\n         Flowable<NonBlockingStore.SegmentedPublisher<I>> flowable, boolean shared) {\n      if (!shared)\n         return flowable;\n\n      return flowable.map(sp -> {\n         DistributionInfo distribution = distributionManager.getCacheTopology().getSegmentDistribution(sp.getSegment());\n         if (distribution.isPrimary()) {\n            return sp;\n         }\n         // Unfortunately we need to still need to subscribe to the publisher even though we don't want\n         // the store to use its values. Thus we just return them an empty SegmentPublisher.\n         return SingleSegmentPublisher.singleSegment(sp.getSegment(), Flowable.fromPublisher(sp).take(0));\n      });\n   }", "author": "ryanemerson", "createdAt": "2020-06-03T14:12:51Z", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -1109,36 +1054,139 @@ private boolean shouldPerformTransactionOperation(StoreStatus storeStatus, Predi\n                               });\n \n                         AtomicLong writeCount = new AtomicLong();\n-                        entryWriteFlowable = entryWriteFlowable.doOnNext(me -> writeCount.incrementAndGet());\n-\n-                        Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable;\n \n-                        if (segmented) {\n-                           writeFlowable = entryWriteFlowable\n-                                 .groupBy(me -> keyPartitioner.getSegment(me.getKey()))\n-                                 .map(SegmentPublisherWrapper::wrap);\n-                        } else {\n-                           writeFlowable = Flowable.just(SingleSegmentPublisher.singleSegment(entryWriteFlowable));\n-                        }\n+                        Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable =\n+                              createWriteFlowable(entryWriteFlowable, shared, segmented, writeCount, storeStatus);\n \n-                        if (trace) {\n-                           removeFlowable = removeFlowable.doOnSubscribe(sub ->\n-                              log.tracef(\"Store %s has subscribed to write batch\", storeStatus.store));\n-                        }\n+                        CompletionStage<Void> storeBatchStage = flowableHandler.handleFlowables(storeStatus.store(),\n+                              segmentCount(segmented), removeFlowable, writeFlowable);\n \n-                        return Single.fromCompletionStage(flowableHandler.handleFlowables(storeStatus.store(),\n-                              segmentCount(segmented), removeFlowable, writeFlowable)\n-                              .thenApply(ignore2 -> writeCount.get()));\n-                     }).first(0L);\n+                        return Single.fromCompletionStage(storeBatchStage)\n+                              .map(ignore2 -> writeCount.get());\n+                        // Only take the last element for the count - ensures all stores are completed\n+                     }).last(0L);\n \n             },\n             this::releaseReadLock\n       ).toCompletionStage();\n    }\n \n-   private <K, V> MVCCEntry<K, V> acquireKeyFromContext(InvocationContext ctx, WriteCommand command, Object key,\n-         BiPredicate<WriteCommand, Object> commandKeyPredicate) {\n-      if (commandKeyPredicate.test(command, key)) {\n+   <K> Flowable<NonBlockingStore.SegmentedPublisher<K>> createRemoveFlowable(Flowable<K> keyRemoveFlowable,\n+         boolean shared, boolean segmented, StoreStatus storeStatus) {\n+      Flowable<NonBlockingStore.SegmentedPublisher<K>> removeFlowable;\n+      if (segmented) {\n+         removeFlowable = keyRemoveFlowable\n+               .groupBy(keyPartitioner::getSegment)\n+               .map(SegmentPublisherWrapper::wrap);\n+         if (shared) {", "originalCommit": "3f780e777290fdeb283e01591a59e6f294b0226e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYwMjEzNQ==", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r434602135", "bodyText": "Is there a real cost to changing this to:\nelse {\n         entryWriteFlowable = entryWriteFlowable\n               .filter(me -> !shared || distributionManager.getCacheTopology().getDistribution(me.getKey()).isPrimary())\n               .doOnNext(obj -> writeCount.incrementAndGet());\n         writeFlowable = Flowable.just(SingleSegmentPublisher.singleSegment(entryWriteFlowable));\n      }\nThe same approach can be taken with createRemoveFlowable.", "author": "ryanemerson", "createdAt": "2020-06-03T14:17:13Z", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -1109,36 +1054,139 @@ private boolean shouldPerformTransactionOperation(StoreStatus storeStatus, Predi\n                               });\n \n                         AtomicLong writeCount = new AtomicLong();\n-                        entryWriteFlowable = entryWriteFlowable.doOnNext(me -> writeCount.incrementAndGet());\n-\n-                        Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable;\n \n-                        if (segmented) {\n-                           writeFlowable = entryWriteFlowable\n-                                 .groupBy(me -> keyPartitioner.getSegment(me.getKey()))\n-                                 .map(SegmentPublisherWrapper::wrap);\n-                        } else {\n-                           writeFlowable = Flowable.just(SingleSegmentPublisher.singleSegment(entryWriteFlowable));\n-                        }\n+                        Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable =\n+                              createWriteFlowable(entryWriteFlowable, shared, segmented, writeCount, storeStatus);\n \n-                        if (trace) {\n-                           removeFlowable = removeFlowable.doOnSubscribe(sub ->\n-                              log.tracef(\"Store %s has subscribed to write batch\", storeStatus.store));\n-                        }\n+                        CompletionStage<Void> storeBatchStage = flowableHandler.handleFlowables(storeStatus.store(),\n+                              segmentCount(segmented), removeFlowable, writeFlowable);\n \n-                        return Single.fromCompletionStage(flowableHandler.handleFlowables(storeStatus.store(),\n-                              segmentCount(segmented), removeFlowable, writeFlowable)\n-                              .thenApply(ignore2 -> writeCount.get()));\n-                     }).first(0L);\n+                        return Single.fromCompletionStage(storeBatchStage)\n+                              .map(ignore2 -> writeCount.get());\n+                        // Only take the last element for the count - ensures all stores are completed\n+                     }).last(0L);\n \n             },\n             this::releaseReadLock\n       ).toCompletionStage();\n    }\n \n-   private <K, V> MVCCEntry<K, V> acquireKeyFromContext(InvocationContext ctx, WriteCommand command, Object key,\n-         BiPredicate<WriteCommand, Object> commandKeyPredicate) {\n-      if (commandKeyPredicate.test(command, key)) {\n+   <K> Flowable<NonBlockingStore.SegmentedPublisher<K>> createRemoveFlowable(Flowable<K> keyRemoveFlowable,\n+         boolean shared, boolean segmented, StoreStatus storeStatus) {\n+      Flowable<NonBlockingStore.SegmentedPublisher<K>> removeFlowable;\n+      if (segmented) {\n+         removeFlowable = keyRemoveFlowable\n+               .groupBy(keyPartitioner::getSegment)\n+               .map(SegmentPublisherWrapper::wrap);\n+         if (shared) {\n+            removeFlowable = filterSharedSegments(removeFlowable);\n+         }\n+      } else {\n+         if (shared) {\n+            keyRemoveFlowable = keyRemoveFlowable.filter(k ->\n+                  distributionManager.getCacheTopology().getDistribution(k).isPrimary());\n+         }\n+         removeFlowable = Flowable.just(SingleSegmentPublisher.singleSegment(keyRemoveFlowable));\n+      }\n+\n+      if (trace) {\n+         removeFlowable = removeFlowable.doOnSubscribe(sub ->\n+               log.tracef(\"Store %s has subscribed to remove batch\", storeStatus.store));\n+         removeFlowable = removeFlowable.map(sp -> {\n+            int segment = sp.getSegment();\n+            return SingleSegmentPublisher.singleSegment(segment, Flowable.fromPublisher(sp)\n+                  .doOnNext(keyToRemove -> log.tracef(\"Emitting key %s for removal from segment %s\",\n+                        keyToRemove, segment)));\n+         });\n+      }\n+\n+      return removeFlowable;\n+   }\n+\n+   <K, V> Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> createWriteFlowable(\n+         Flowable<MarshallableEntry<K, V>> entryWriteFlowable, boolean shared, boolean segmented,\n+         AtomicLong writeCount, StoreStatus storeStatus) {\n+      Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable;\n+      if (segmented) {\n+         // Note the writeCount includes entries that aren't written due to being shared\n+         // at this point\n+         entryWriteFlowable = entryWriteFlowable.doOnNext(obj -> writeCount.incrementAndGet());\n+         writeFlowable = entryWriteFlowable\n+               .groupBy(me -> keyPartitioner.getSegment(me.getKey()))\n+               .map(SegmentPublisherWrapper::wrap);\n+         if (shared) {\n+            // The writeCount will be decremented for each grouping of values ignored\n+            writeFlowable = filterSharedSegments(writeFlowable);\n+         }\n+      } else {\n+         if (shared) {\n+            entryWriteFlowable = entryWriteFlowable.filter(me ->\n+                  distributionManager.getCacheTopology().getDistribution(me.getKey()).isPrimary());\n+         }", "originalCommit": "3f780e777290fdeb283e01591a59e6f294b0226e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTE4Ng==", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r434955186", "bodyText": "Hard to say, you have the extra lambda allocation and will have to invoke it for every entry in the write or remove. I would say we just leave it how it is personally.", "author": "wburns", "createdAt": "2020-06-04T02:21:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYwMjEzNQ=="}], "type": "inlineReview"}, {"oid": "60b009d2b43119fd3c1942f6043a181e8fb8e71e", "url": "https://github.com/infinispan/infinispan/commit/60b009d2b43119fd3c1942f6043a181e8fb8e71e", "message": "second review comments", "committedDate": "2020-06-03T16:58:02Z", "type": "forcePushed"}, {"oid": "9de23e3114254fec0d73e0d434eb44b12be64476", "url": "https://github.com/infinispan/infinispan/commit/9de23e3114254fec0d73e0d434eb44b12be64476", "message": "second review comments", "committedDate": "2020-06-04T02:40:53Z", "type": "forcePushed"}, {"oid": "36071445e349c041b27fa09154ec1b35dff7f15b", "url": "https://github.com/infinispan/infinispan/commit/36071445e349c041b27fa09154ec1b35dff7f15b", "message": "second review comments", "committedDate": "2020-06-04T04:22:44Z", "type": "forcePushed"}, {"oid": "9562e65d68e9ea1c7742b4e5cb2e26d670f513d4", "url": "https://github.com/infinispan/infinispan/commit/9562e65d68e9ea1c7742b4e5cb2e26d670f513d4", "message": "ISPN-10373 Store/Loader Non blocking SPI\n\n* Rework putMap to iterate once\n* Rework batch to use separate subscription per store\n** Allows each store to use different threads", "committedDate": "2020-06-04T16:14:23Z", "type": "commit"}, {"oid": "9562e65d68e9ea1c7742b4e5cb2e26d670f513d4", "url": "https://github.com/infinispan/infinispan/commit/9562e65d68e9ea1c7742b4e5cb2e26d670f513d4", "message": "ISPN-10373 Store/Loader Non blocking SPI\n\n* Rework putMap to iterate once\n* Rework batch to use separate subscription per store\n** Allows each store to use different threads", "committedDate": "2020-06-04T16:14:23Z", "type": "forcePushed"}]}