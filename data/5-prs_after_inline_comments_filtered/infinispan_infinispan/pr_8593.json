{"pr_number": 8593, "pr_title": "ISPN-11992 Convert RemoteStore to use new SPI | Segmentation support", "pr_createdAt": "2020-07-24T20:30:43Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8593", "timeline": [{"oid": "06962e1414c8bbb61a3e2cba354a090b88f1fd2d", "url": "https://github.com/infinispan/infinispan/commit/06962e1414c8bbb61a3e2cba354a090b88f1fd2d", "message": "fix some tests with segmentation", "committedDate": "2020-07-27T17:24:32Z", "type": "forcePushed"}, {"oid": "e502b6565f3756083dd5d3b397f673a59a28f95c", "url": "https://github.com/infinispan/infinispan/commit/e502b6565f3756083dd5d3b397f673a59a28f95c", "message": "ISPN-12174 Custom Store cannot configure segmented via xml", "committedDate": "2020-07-29T14:36:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg2NjcxNw==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462866717", "bodyText": "CacheModes need uncommenting \ud83d\ude42", "author": "ryanemerson", "createdAt": "2020-07-30T09:21:50Z", "path": "core/src/test/java/org/infinispan/persistence/ClusterCacheLoaderTest.java", "diffHunk": "@@ -22,7 +22,7 @@\n  * @author Mircea.Markus@jboss.com\n  */\n @Test(groups = \"functional\", testName = \"persistence.ClusterCacheLoaderTest\")\n-@InCacheMode({ CacheMode.INVALIDATION_SYNC, CacheMode.DIST_SYNC, CacheMode.REPL_SYNC, CacheMode.SCATTERED_SYNC })\n+@InCacheMode({ CacheMode.INVALIDATION_SYNC/*, CacheMode.DIST_SYNC, CacheMode.REPL_SYNC, CacheMode.SCATTERED_SYNC*/ })", "originalCommit": "e502b6565f3756083dd5d3b397f673a59a28f95c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3NTAyMg==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462975022", "bodyText": "Yes, forgot to put them back in.", "author": "wburns", "createdAt": "2020-07-30T12:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg2NjcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg2ODczNw==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462868737", "bodyText": "Is it blocking?", "author": "ryanemerson", "createdAt": "2020-07-30T09:25:23Z", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,199 +72,244 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassWhiteList whiteList = ctx.getCache().getCacheManager().getClassWhiteList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), whiteList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               // TODO: I believe this is blocking...\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();", "originalCommit": "e502b6565f3756083dd5d3b397f673a59a28f95c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3NDg1OQ==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462974859", "bodyText": "No :) - I forgot to remove the TODO.", "author": "wburns", "createdAt": "2020-07-30T12:55:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg2ODczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3MDExOA==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462870118", "bodyText": "Do these debug statements really add much as we will throw an exception below if the configuration is not valid.\nIf we remove the logs we can simplify this to a one-liner:\nboolean segmentsMatch = numSegments == null ? false : numSegments == segmentCount;", "author": "ryanemerson", "createdAt": "2020-07-30T09:27:52Z", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,199 +72,244 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassWhiteList whiteList = ctx.getCache().getCacheManager().getClassWhiteList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), whiteList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               // TODO: I believe this is blocking...\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();\n+               boolean segmentsMatch;\n+               if (numSegments == null) {\n+                  log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments was not found from the remote cache\", cacheName);\n+                  segmentsMatch = false;\n+               } else {\n+                  segmentsMatch = numSegments == segmentCount;\n+                  if (segmentsMatch) {\n+                     log.debugf(\"Remote Store for cache %s can support segmentation as the number of segments matched the remote cache\", cacheName);\n+                  } else {\n+                     log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments %d do not match the remote cache %d\",\n+                           cacheName, segmentCount, numSegments);\n+                  }", "originalCommit": "e502b6565f3756083dd5d3b397f673a59a28f95c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3NDczMA==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462974730", "bodyText": "We don't always throw an exception below, so that is why I have debug statements so they can be seen.", "author": "wburns", "createdAt": "2020-07-30T12:54:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3MDExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3MTY5NA==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462871694", "bodyText": "Nitpick, but if we return early we can reduce the nesting:\nif (metadataValue == null)\n    return null;\n\nMetadata metadata = new EmbeddedMetadata.Builder()...", "author": "ryanemerson", "createdAt": "2020-07-30T09:30:37Z", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,199 +72,244 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassWhiteList whiteList = ctx.getCache().getCacheManager().getClassWhiteList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), whiteList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               // TODO: I believe this is blocking...\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();\n+               boolean segmentsMatch;\n+               if (numSegments == null) {\n+                  log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments was not found from the remote cache\", cacheName);\n+                  segmentsMatch = false;\n+               } else {\n+                  segmentsMatch = numSegments == segmentCount;\n+                  if (segmentsMatch) {\n+                     log.debugf(\"Remote Store for cache %s can support segmentation as the number of segments matched the remote cache\", cacheName);\n+                  } else {\n+                     log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments %d do not match the remote cache %d\",\n+                           cacheName, segmentCount, numSegments);\n+                  }\n+               }\n+               if (!segmentsMatch && configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualSegments(segmentCount, numSegments);\n+               }\n+               if ((supportsSegmentation = localKeyStorageType.equals(serverKeyStorageType))) {\n+                  if (localKeyStorageType.isBinary()) {\n+                     dataFormatBuilder.keyType(localKeyStorageType);\n+                     // Make sure when the media types match that we don't marshall the value\n+                     dataFormatBuilder.keyMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.keyType(marshaller.mediaType());\n+                     dataFormatBuilder.keyMarshaller(marshaller);\n+                  }\n+               } else if (configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualMediaTypes(localKeyStorageType, serverKeyStorageType);\n+               }\n+               // We store MarshalledEntry instances for the values when raw values is not set, instead of the stored value\n+               if (!configuration.rawValues()) {\n+                  localValueStorageType = MediaType.APPLICATION_OBJECT;\n+               }\n+               if (localValueStorageType.equals(serverValueStorageType)) {\n+                  if (localValueStorageType.isBinary()) {\n+                     dataFormatBuilder.valueType(localValueStorageType);\n+                     dataFormatBuilder.valueMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.valueType(marshaller.mediaType());\n+                     dataFormatBuilder.valueMarshaller(marshaller);\n+                  }\n+               }\n+               DataFormat dataFormat = dataFormatBuilder.build();\n+               log.fatalf(\"Data format is %s\", dataFormat);\n+               remoteCache = remoteCache.withDataFormat(dataFormat);\n+            });\n    }\n \n    @Override\n-   public void stop() throws PersistenceException {\n-      remoteCacheManager.stop();\n+   public Set<Characteristic> characteristics() {\n+      Set<Characteristic> characteristics = EnumSet.of(Characteristic.BULK_READ, Characteristic.EXPIRATION,\n+            Characteristic.SHAREABLE);\n+      if (supportsSegmentation) {\n+         characteristics.add(Characteristic.SEGMENTABLE);\n+      }\n+      return characteristics;\n    }\n \n    @Override\n-   public boolean isAvailable() {\n-      try {\n-         PingResponse pr = ((RemoteCacheImpl) remoteCache).ping();\n-         return pr.isSuccess();\n-      } catch (Exception e) {\n-         return false;\n-      }\n+   public CompletionStage<Void> stop() {\n+      return blockingManager.runBlocking(() -> remoteCacheManager.stop(), \"RemoteStore-stop\");\n    }\n \n    @Override\n-   public MarshallableEntry<K, V> get(int segment, Object key) {\n-      return loadEntry(key);\n+   public CompletionStage<Boolean> isAvailable() {\n+      return remoteCache.ping()\n+            .handle((v, t) -> t == null && v.isSuccess());\n    }\n \n    @Override\n-   public MarshallableEntry<K, V> loadEntry(Object key) throws PersistenceException {\n+   public CompletionStage<MarshallableEntry<K, V>> load(int segment, Object key) {\n       if (configuration.rawValues()) {\n          Object unwrappedKey;\n          if (key instanceof WrappedByteArray) {\n             unwrappedKey = ((WrappedByteArray) key).getBytes();\n          } else {\n             unwrappedKey = key;\n          }\n-         MetadataValue<?> value = remoteCache.getWithMetadata(unwrappedKey);\n-         if (value != null) {\n-            Metadata metadata = new EmbeddedMetadata.Builder()\n-                  .version(new NumericVersion(value.getVersion()))\n-                  .lifespan(value.getLifespan(), TimeUnit.SECONDS)\n-                  .maxIdle(value.getMaxIdle(), TimeUnit.SECONDS).build();\n-            long created = value.getCreated();\n-            long lastUsed = value.getLastUsed();\n-            Object realValue = value.getValue();\n-            if (realValue instanceof byte[]) {\n-               realValue = new WrappedByteArray((byte[]) realValue);\n+         CompletableFuture<MetadataValue<Object>> valueStage = remoteCache.getWithMetadataAsync(unwrappedKey);\n+         return valueStage.thenApply(metadataValue -> {\n+            if (metadataValue != null) {", "originalCommit": "e502b6565f3756083dd5d3b397f673a59a28f95c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3NDMwNQ==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462974305", "bodyText": "Sure, I didn't notice the code was like that before \ud83d\udc4d", "author": "wburns", "createdAt": "2020-07-30T12:54:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3MTY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3NDQyMA==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462874420", "bodyText": "wrap(realValue)?", "author": "ryanemerson", "createdAt": "2020-07-30T09:35:16Z", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,199 +72,244 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassWhiteList whiteList = ctx.getCache().getCacheManager().getClassWhiteList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), whiteList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               // TODO: I believe this is blocking...\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();\n+               boolean segmentsMatch;\n+               if (numSegments == null) {\n+                  log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments was not found from the remote cache\", cacheName);\n+                  segmentsMatch = false;\n+               } else {\n+                  segmentsMatch = numSegments == segmentCount;\n+                  if (segmentsMatch) {\n+                     log.debugf(\"Remote Store for cache %s can support segmentation as the number of segments matched the remote cache\", cacheName);\n+                  } else {\n+                     log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments %d do not match the remote cache %d\",\n+                           cacheName, segmentCount, numSegments);\n+                  }\n+               }\n+               if (!segmentsMatch && configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualSegments(segmentCount, numSegments);\n+               }\n+               if ((supportsSegmentation = localKeyStorageType.equals(serverKeyStorageType))) {\n+                  if (localKeyStorageType.isBinary()) {\n+                     dataFormatBuilder.keyType(localKeyStorageType);\n+                     // Make sure when the media types match that we don't marshall the value\n+                     dataFormatBuilder.keyMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.keyType(marshaller.mediaType());\n+                     dataFormatBuilder.keyMarshaller(marshaller);\n+                  }\n+               } else if (configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualMediaTypes(localKeyStorageType, serverKeyStorageType);\n+               }\n+               // We store MarshalledEntry instances for the values when raw values is not set, instead of the stored value\n+               if (!configuration.rawValues()) {\n+                  localValueStorageType = MediaType.APPLICATION_OBJECT;\n+               }\n+               if (localValueStorageType.equals(serverValueStorageType)) {\n+                  if (localValueStorageType.isBinary()) {\n+                     dataFormatBuilder.valueType(localValueStorageType);\n+                     dataFormatBuilder.valueMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.valueType(marshaller.mediaType());\n+                     dataFormatBuilder.valueMarshaller(marshaller);\n+                  }\n+               }\n+               DataFormat dataFormat = dataFormatBuilder.build();\n+               log.fatalf(\"Data format is %s\", dataFormat);\n+               remoteCache = remoteCache.withDataFormat(dataFormat);\n+            });\n    }\n \n    @Override\n-   public void stop() throws PersistenceException {\n-      remoteCacheManager.stop();\n+   public Set<Characteristic> characteristics() {\n+      Set<Characteristic> characteristics = EnumSet.of(Characteristic.BULK_READ, Characteristic.EXPIRATION,\n+            Characteristic.SHAREABLE);\n+      if (supportsSegmentation) {\n+         characteristics.add(Characteristic.SEGMENTABLE);\n+      }\n+      return characteristics;\n    }\n \n    @Override\n-   public boolean isAvailable() {\n-      try {\n-         PingResponse pr = ((RemoteCacheImpl) remoteCache).ping();\n-         return pr.isSuccess();\n-      } catch (Exception e) {\n-         return false;\n-      }\n+   public CompletionStage<Void> stop() {\n+      return blockingManager.runBlocking(() -> remoteCacheManager.stop(), \"RemoteStore-stop\");\n    }\n \n    @Override\n-   public MarshallableEntry<K, V> get(int segment, Object key) {\n-      return loadEntry(key);\n+   public CompletionStage<Boolean> isAvailable() {\n+      return remoteCache.ping()\n+            .handle((v, t) -> t == null && v.isSuccess());\n    }\n \n    @Override\n-   public MarshallableEntry<K, V> loadEntry(Object key) throws PersistenceException {\n+   public CompletionStage<MarshallableEntry<K, V>> load(int segment, Object key) {\n       if (configuration.rawValues()) {\n          Object unwrappedKey;\n          if (key instanceof WrappedByteArray) {\n             unwrappedKey = ((WrappedByteArray) key).getBytes();\n          } else {\n             unwrappedKey = key;\n          }\n-         MetadataValue<?> value = remoteCache.getWithMetadata(unwrappedKey);\n-         if (value != null) {\n-            Metadata metadata = new EmbeddedMetadata.Builder()\n-                  .version(new NumericVersion(value.getVersion()))\n-                  .lifespan(value.getLifespan(), TimeUnit.SECONDS)\n-                  .maxIdle(value.getMaxIdle(), TimeUnit.SECONDS).build();\n-            long created = value.getCreated();\n-            long lastUsed = value.getLastUsed();\n-            Object realValue = value.getValue();\n-            if (realValue instanceof byte[]) {\n-               realValue = new WrappedByteArray((byte[]) realValue);\n+         CompletableFuture<MetadataValue<Object>> valueStage = remoteCache.getWithMetadataAsync(unwrappedKey);\n+         return valueStage.thenApply(metadataValue -> {\n+            if (metadataValue != null) {\n+               Metadata metadata = new EmbeddedMetadata.Builder()\n+                     .version(new NumericVersion(metadataValue.getVersion()))\n+                     .lifespan(metadataValue.getLifespan(), TimeUnit.SECONDS)\n+                     .maxIdle(metadataValue.getMaxIdle(), TimeUnit.SECONDS).build();\n+               long created = metadataValue.getCreated();\n+               long lastUsed = metadataValue.getLastUsed();\n+               Object realValue = metadataValue.getValue();\n+               if (realValue instanceof byte[]) {\n+                  realValue = new WrappedByteArray((byte[]) realValue);\n+               }", "originalCommit": "e502b6565f3756083dd5d3b397f673a59a28f95c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3NjAzNw==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462876037", "bodyText": "We should probably add a static unwrap method, as this code is repeated several times. We can then use a method reference here.", "author": "ryanemerson", "createdAt": "2020-07-30T09:38:14Z", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -319,45 +363,46 @@ private Object getValue(MarshallableEntry entry) {\n    }\n \n    @Override\n-   public CompletionStage<Void> bulkUpdate(Publisher<MarshallableEntry<? extends K, ? extends V>> publisher) {\n-      return Flowable.fromPublisher(publisher)\n-            .buffer(configuration.maxBatchSize())\n-            // TODO: this is blocking - when the full non blocking SPI is introduced this needs to chain returns\n-            // of the putAll to ensure that only a single batch is sent at a time\n-            .doOnNext(entries -> remoteCache.putAll(entries.stream().collect(Collectors.toMap(this::getKey, this::getValue))))\n-            .doOnError(PersistenceException::new)\n-            .ignoreElements()\n+   public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n+         Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n+      Completable removeCompletable = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp), publisherCount)\n+            .map(key -> key instanceof WrappedByteArray ? ((WrappedByteArray) key).getBytes() : key)", "originalCommit": "e502b6565f3756083dd5d3b397f673a59a28f95c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3Mzg0Mw==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462973843", "bodyText": "Okay.", "author": "wburns", "createdAt": "2020-07-30T12:53:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3NjAzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3ODU5MQ==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462878591", "bodyText": "In this PR?", "author": "ryanemerson", "createdAt": "2020-07-30T09:42:36Z", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/internal/RemoteStoreBlockHoundIntegration.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.infinispan.persistence.remote.internal;\n+\n+import org.kohsuke.MetaInfServices;\n+\n+import reactor.blockhound.BlockHound;\n+import reactor.blockhound.integration.BlockHoundIntegration;\n+\n+@MetaInfServices\n+public class RemoteStoreBlockHoundIntegration implements BlockHoundIntegration {\n+   @Override\n+   public void applyTo(BlockHound.Builder builder) {\n+      // TODO: this needs to be moved to the client hotrod module when it adds BlockHound\n+      builder.allowBlockingCallsInside(\"org.infinispan.client.hotrod.impl.transport.netty.ChannelInitializer\", \"initSsl\");", "originalCommit": "e502b6565f3756083dd5d3b397f673a59a28f95c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3MzYzNQ==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462973635", "bodyText": "No, we should do that in a separate one. However I can add a URL to the JIRA (and create if there isn't one).", "author": "wburns", "createdAt": "2020-07-30T12:53:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3ODU5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3OTY0NQ==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462879645", "bodyText": "Remove?", "author": "ryanemerson", "createdAt": "2020-07-30T09:44:33Z", "path": "persistence/remote/src/test/java/org/infinispan/persistence/remote/RemoteStoreTest.java", "diffHunk": "@@ -38,45 +44,101 @@\n  * @since 4.1\n  */\n @Test(testName = \"persistence.remote.RemoteStoreTest\", groups = \"functional\")\n-public class RemoteStoreTest extends BaseStoreTest {\n+public class RemoteStoreTest extends BaseNonBlockingStoreTest {\n \n    private static final String REMOTE_CACHE = \"remote-cache\";\n    private EmbeddedCacheManager localCacheManager;\n+   private AdvancedCache<Object, Object> localCache;\n    private HotRodServer hrServer;\n+   private boolean segmented;\n+   private MediaType cacheMediaType;\n+   private boolean isRawValues;\n+\n+   private ProtoStreamMarshaller marshaller = new ProtoStreamMarshaller(ProtobufUtil.newSerializationContext());\n+\n+   public RemoteStoreTest segmented(boolean segmented) {\n+      this.segmented = segmented;\n+      return this;\n+   }\n+\n+   public RemoteStoreTest cacheMediaType(MediaType cacheMediaType) {\n+      this.cacheMediaType = cacheMediaType;\n+      return this;\n+   }\n+\n+   public RemoteStoreTest rawValues(boolean isRawValues) {\n+      this.isRawValues = isRawValues;\n+      return this;\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      return new Object[] {\n+            new RemoteStoreTest().segmented(false).cacheMediaType(MediaType.APPLICATION_OBJECT).rawValues(true),\n+            new RemoteStoreTest().segmented(false).cacheMediaType(MediaType.APPLICATION_OBJECT).rawValues(false),\n+            new RemoteStoreTest().segmented(false).cacheMediaType(MediaType.APPLICATION_PROTOSTREAM).rawValues(true),\n+            new RemoteStoreTest().segmented(false).cacheMediaType(MediaType.APPLICATION_PROTOSTREAM).rawValues(false),\n+            new RemoteStoreTest().segmented(true).cacheMediaType(MediaType.APPLICATION_OBJECT).rawValues(true),\n+            new RemoteStoreTest().segmented(true).cacheMediaType(MediaType.APPLICATION_OBJECT).rawValues(false),\n+            new RemoteStoreTest().segmented(true).cacheMediaType(MediaType.APPLICATION_PROTOSTREAM).rawValues(true),\n+            new RemoteStoreTest().segmented(true).cacheMediaType(MediaType.APPLICATION_PROTOSTREAM).rawValues(false),\n+      };\n+   }\n \n    @Override\n-   protected AdvancedLoadWriteStore createStore() {\n-      ConfigurationBuilder localBuilder = TestCacheManagerFactory.getDefaultCacheConfiguration(false);\n-      localBuilder.memory().evictionType(EvictionType.COUNT).size(WRITE_DELETE_BATCH_MAX_ENTRIES).expiration().wakeUpInterval(10L);\n+   protected String parameters() {\n+      return \"[\" + segmented + \", \" + cacheMediaType + \", \" + isRawValues + \"]\";\n+   }\n+\n+   @Override\n+   protected Configuration buildConfig(ConfigurationBuilder cb) {\n+      cb.memory().maxCount(WRITE_DELETE_BATCH_MAX_ENTRIES)\n+            .expiration().wakeUpInterval(10L);\n+\n+      // Unfortunately BaseNonBlockingStore stops and restarts the store, which can start a second hrServer - prevent that\n+      if (hrServer == null) {\n+         GlobalConfigurationBuilder globalConfig = new GlobalConfigurationBuilder().clusteredDefault();\n+         globalConfig.defaultCacheName(REMOTE_CACHE);\n+\n+         ConfigurationBuilder configurationBuilder = hotRodCacheConfiguration(cb);\n+         configurationBuilder.encoding().mediaType(cacheMediaType.toString());\n+         configurationBuilder.clustering().cacheMode(CacheMode.DIST_SYNC);\n+         localCacheManager = TestCacheManagerFactory.createClusteredCacheManager(\n+               globalConfig, configurationBuilder);\n+         TestingUtil.replaceComponent(localCacheManager, TimeService.class, timeService, true);\n+\n+         localCache = (AdvancedCache<Object, Object>) localCacheManager.getCache(REMOTE_CACHE).getAdvancedCache()\n+               .withMediaType(MediaType.APPLICATION_OBJECT_TYPE, MediaType.APPLICATION_OBJECT_TYPE);\n+         keyPartitioner = localCache.getAdvancedCache().getComponentRegistry().getComponent(KeyPartitioner.class);\n+\n+         hrServer = HotRodClientTestingUtil.startHotRodServer(localCacheManager);\n+         // In case if the server has to unmarshall the value, make sure to use the same marshaller\n+//         hrServer.setMarshaller(getMarshaller());", "originalCommit": "e502b6565f3756083dd5d3b397f673a59a28f95c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3Mzc4OA==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462973788", "bodyText": "Sure, I was more testing to see if it was needed, which it obviously isn't :)", "author": "wburns", "createdAt": "2020-07-30T12:53:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3OTY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk1ODUxMA==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462958510", "bodyText": "CacheTopologyInfo is accessible from RemoteCache.getCacheTopologyInfo(), so this is going to break backwards compatibility.", "author": "danberindei", "createdAt": "2020-07-30T12:25:28Z", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/CacheTopologyInfo.java", "diffHunk": "@@ -15,7 +15,7 @@\n    /**\n     * @return The number of configured segments for the cache.\n     */\n-   int getNumSegments();\n+   Integer getNumSegments();", "originalCommit": "e502b6565f3756083dd5d3b397f673a59a28f95c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3MjQ0Mg==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462972442", "bodyText": "It was already broken, I didn't change the underlying code. Just the API definition. So the only thing I broke is binary compatibility as it already threw a NPE before :)", "author": "wburns", "createdAt": "2020-07-30T12:51:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk1ODUxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3ODg2Ng==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462978866", "bodyText": "https://github.com/infinispan/infinispan/blob/master/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/CacheTopologyInfoImpl.java#L15", "author": "wburns", "createdAt": "2020-07-30T13:02:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk1ODUxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAwOTE2Mw==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r463009163", "bodyText": "IIUC it was only broken for LOCAL caches, which aren't used that much on the server, no?", "author": "danberindei", "createdAt": "2020-07-30T13:48:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk1ODUxMA=="}], "type": "inlineReview"}, {"oid": "0e898323311376a9aee0b42ed1ff32aa6d22af24", "url": "https://github.com/infinispan/infinispan/commit/0e898323311376a9aee0b42ed1ff32aa6d22af24", "message": "rework comments", "committedDate": "2020-07-30T13:45:49Z", "type": "forcePushed"}, {"oid": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001", "url": "https://github.com/infinispan/infinispan/commit/4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001", "message": "rework comments", "committedDate": "2020-08-05T18:20:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIxODg4MQ==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r466218881", "bodyText": "unnecessary additional brackets", "author": "ryanemerson", "createdAt": "2020-08-06T08:00:55Z", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,228 +72,257 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassAllowList allowList = ctx.getCache().getCacheManager().getClassAllowList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), allowList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();\n+               boolean segmentsMatch;\n+               if (numSegments == null) {\n+                  log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments was not found from the remote cache\", cacheName);\n+                  segmentsMatch = false;\n+               } else {\n+                  segmentsMatch = numSegments == segmentCount;\n+                  if (segmentsMatch) {\n+                     log.debugf(\"Remote Store for cache %s can support segmentation as the number of segments matched the remote cache\", cacheName);\n+                  } else {\n+                     log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments %d do not match the remote cache %d\",\n+                           cacheName, segmentCount, numSegments);\n+                  }\n+               }\n+               if (!segmentsMatch && configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualSegments(segmentCount, numSegments);\n+               }\n+               if ((supportsSegmentation = localKeyStorageType.equals(serverKeyStorageType))) {", "originalCommit": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0NTMwNw==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r467045307", "bodyText": "Technically, they are needed as I am assigning a variable in there. Dan doesn't like these and usually makes me move them to a different line :D", "author": "wburns", "createdAt": "2020-08-07T13:37:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIxODg4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyMDgxNw==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r466220817", "bodyText": "I think this needs to be debugf \ud83d\ude42", "author": "ryanemerson", "createdAt": "2020-08-06T08:04:19Z", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,228 +72,257 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassAllowList allowList = ctx.getCache().getCacheManager().getClassAllowList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), allowList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();\n+               boolean segmentsMatch;\n+               if (numSegments == null) {\n+                  log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments was not found from the remote cache\", cacheName);\n+                  segmentsMatch = false;\n+               } else {\n+                  segmentsMatch = numSegments == segmentCount;\n+                  if (segmentsMatch) {\n+                     log.debugf(\"Remote Store for cache %s can support segmentation as the number of segments matched the remote cache\", cacheName);\n+                  } else {\n+                     log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments %d do not match the remote cache %d\",\n+                           cacheName, segmentCount, numSegments);\n+                  }\n+               }\n+               if (!segmentsMatch && configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualSegments(segmentCount, numSegments);\n+               }\n+               if ((supportsSegmentation = localKeyStorageType.equals(serverKeyStorageType))) {\n+                  if (localKeyStorageType.isBinary()) {\n+                     dataFormatBuilder.keyType(localKeyStorageType);\n+                     // Make sure when the media types match that we don't marshall the value\n+                     dataFormatBuilder.keyMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.keyType(marshaller.mediaType());\n+                     dataFormatBuilder.keyMarshaller(marshaller);\n+                  }\n+               } else if (configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualMediaTypes(localKeyStorageType, serverKeyStorageType);\n+               }\n+               // We store MarshalledEntry instances for the values when raw values is not set, instead of the stored value\n+               if (!configuration.rawValues()) {\n+                  localValueStorageType = MediaType.APPLICATION_OBJECT;\n+               }\n+               if (localValueStorageType.equals(serverValueStorageType)) {\n+                  if (localValueStorageType.isBinary()) {\n+                     dataFormatBuilder.valueType(localValueStorageType);\n+                     dataFormatBuilder.valueMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.valueType(marshaller.mediaType());\n+                     dataFormatBuilder.valueMarshaller(marshaller);\n+                  }\n+               }\n+               DataFormat dataFormat = dataFormatBuilder.build();\n+               log.fatalf(\"Data format is %s\", dataFormat);", "originalCommit": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0NTUyMg==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r467045522", "bodyText": "Yea, this was only here for testing purposes. Let me change this, I might just remove.", "author": "wburns", "createdAt": "2020-08-07T13:37:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyMDgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyNTA0OQ==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r466225049", "bodyText": "We can reduce the verbosity of this and keep the logic in one place by adding a couple of methods that are then used for setting both key/value types and marshaller:\n               if ((supportsSegmentation = localKeyStorageType.equals(serverKeyStorageType))) {\n                  dataFormatBuilder.keyType(getMediaType(localKeyStorageType, marshaller));\n                  dataFormatBuilder.keyMarshaller(getMarshaller(localKeyStorageType, marshaller));\n               } else if (configuration.segmented()) {\n                  throw log.segmentationRequiresEqualMediaTypes(localKeyStorageType, serverKeyStorageType);\n               }\n               // We store MarshalledEntry instances for the values when raw values is not set, instead of the stored value\n               if (!configuration.rawValues()) {\n                  localValueStorageType = MediaType.APPLICATION_OBJECT;\n               }\n               if (localValueStorageType.equals(serverValueStorageType)) {\n                  dataFormatBuilder.valueType(getMediaType(localKeyStorageType, marshaller));\n                  dataFormatBuilder.valueMarshaller(getMarshaller(localKeyStorageType, marshaller));\n               }\n...\n   private MediaType getMediaType(MediaType local, Marshaller marshaller) {\n      return local.isBinary() ? local : marshaller.mediaType();\n   }\n\n   private Marshaller getMarshaller(MediaType local, Marshaller marshaller) {\n      return local.isBinary() ? IdentityMarshaller.INSTANCE : marshaller;\n   }\nOr we could just have the ternary operator inline.", "author": "ryanemerson", "createdAt": "2020-08-06T08:11:28Z", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,228 +72,257 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassAllowList allowList = ctx.getCache().getCacheManager().getClassAllowList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), allowList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();\n+               boolean segmentsMatch;\n+               if (numSegments == null) {\n+                  log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments was not found from the remote cache\", cacheName);\n+                  segmentsMatch = false;\n+               } else {\n+                  segmentsMatch = numSegments == segmentCount;\n+                  if (segmentsMatch) {\n+                     log.debugf(\"Remote Store for cache %s can support segmentation as the number of segments matched the remote cache\", cacheName);\n+                  } else {\n+                     log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments %d do not match the remote cache %d\",\n+                           cacheName, segmentCount, numSegments);\n+                  }\n+               }\n+               if (!segmentsMatch && configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualSegments(segmentCount, numSegments);\n+               }\n+               if ((supportsSegmentation = localKeyStorageType.equals(serverKeyStorageType))) {\n+                  if (localKeyStorageType.isBinary()) {\n+                     dataFormatBuilder.keyType(localKeyStorageType);\n+                     // Make sure when the media types match that we don't marshall the value\n+                     dataFormatBuilder.keyMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.keyType(marshaller.mediaType());\n+                     dataFormatBuilder.keyMarshaller(marshaller);\n+                  }", "originalCommit": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk5NzQxOQ==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r467997419", "bodyText": "Hrmm, sure I can do this.", "author": "wburns", "createdAt": "2020-08-10T15:39:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyNTA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAwMDEyOQ==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r468000129", "bodyText": "Unfortunately, this leads to a bit of a weird logic in that getMediaType takes a marshaller that is itself dependent upon getMarshaller as we don't want to ever use the media type from IdentityMarshaller. I will play this a bit more.", "author": "wburns", "createdAt": "2020-08-10T15:41:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyNTA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAzMzg5MA==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r468033890", "bodyText": "I have changed it to ternary, which while doesn't consolidate the 2 branches think it makes the code a bit more straight forward that they are dependent upon each other.", "author": "wburns", "createdAt": "2020-08-10T16:35:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyNTA0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyNjY0Nw==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r466226647", "bodyText": "Nitpick, but unnecessary variable as the declaration is longer than the actual method call. I would just call thenApply directly.", "author": "ryanemerson", "createdAt": "2020-08-06T08:14:19Z", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,228 +72,257 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassAllowList allowList = ctx.getCache().getCacheManager().getClassAllowList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), allowList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();\n+               boolean segmentsMatch;\n+               if (numSegments == null) {\n+                  log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments was not found from the remote cache\", cacheName);\n+                  segmentsMatch = false;\n+               } else {\n+                  segmentsMatch = numSegments == segmentCount;\n+                  if (segmentsMatch) {\n+                     log.debugf(\"Remote Store for cache %s can support segmentation as the number of segments matched the remote cache\", cacheName);\n+                  } else {\n+                     log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments %d do not match the remote cache %d\",\n+                           cacheName, segmentCount, numSegments);\n+                  }\n+               }\n+               if (!segmentsMatch && configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualSegments(segmentCount, numSegments);\n+               }\n+               if ((supportsSegmentation = localKeyStorageType.equals(serverKeyStorageType))) {\n+                  if (localKeyStorageType.isBinary()) {\n+                     dataFormatBuilder.keyType(localKeyStorageType);\n+                     // Make sure when the media types match that we don't marshall the value\n+                     dataFormatBuilder.keyMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.keyType(marshaller.mediaType());\n+                     dataFormatBuilder.keyMarshaller(marshaller);\n+                  }\n+               } else if (configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualMediaTypes(localKeyStorageType, serverKeyStorageType);\n+               }\n+               // We store MarshalledEntry instances for the values when raw values is not set, instead of the stored value\n+               if (!configuration.rawValues()) {\n+                  localValueStorageType = MediaType.APPLICATION_OBJECT;\n+               }\n+               if (localValueStorageType.equals(serverValueStorageType)) {\n+                  if (localValueStorageType.isBinary()) {\n+                     dataFormatBuilder.valueType(localValueStorageType);\n+                     dataFormatBuilder.valueMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.valueType(marshaller.mediaType());\n+                     dataFormatBuilder.valueMarshaller(marshaller);\n+                  }\n+               }\n+               DataFormat dataFormat = dataFormatBuilder.build();\n+               log.fatalf(\"Data format is %s\", dataFormat);\n+               remoteCache = remoteCache.withDataFormat(dataFormat);\n+            });\n    }\n \n    @Override\n-   public void stop() throws PersistenceException {\n-      remoteCacheManager.stop();\n+   public Set<Characteristic> characteristics() {\n+      Set<Characteristic> characteristics = EnumSet.of(Characteristic.BULK_READ, Characteristic.EXPIRATION,\n+            Characteristic.SHAREABLE);\n+      if (supportsSegmentation) {\n+         characteristics.add(Characteristic.SEGMENTABLE);\n+      }\n+      return characteristics;\n    }\n \n    @Override\n-   public boolean isAvailable() {\n-      try {\n-         PingResponse pr = ((RemoteCacheImpl) remoteCache).ping();\n-         return pr.isSuccess();\n-      } catch (Exception e) {\n-         return false;\n-      }\n+   public CompletionStage<Void> stop() {\n+      return blockingManager.runBlocking(() -> remoteCacheManager.stop(), \"RemoteStore-stop\");\n    }\n \n    @Override\n-   public MarshallableEntry<K, V> get(int segment, Object key) {\n-      return loadEntry(key);\n+   public CompletionStage<Boolean> isAvailable() {\n+      return remoteCache.ping()\n+            .handle((v, t) -> t == null && v.isSuccess());\n    }\n \n    @Override\n-   public MarshallableEntry<K, V> loadEntry(Object key) throws PersistenceException {\n+   public CompletionStage<MarshallableEntry<K, V>> load(int segment, Object key) {\n       if (configuration.rawValues()) {\n-         Object unwrappedKey;\n-         if (key instanceof WrappedByteArray) {\n-            unwrappedKey = ((WrappedByteArray) key).getBytes();\n-         } else {\n-            unwrappedKey = key;\n-         }\n-         MetadataValue<?> value = remoteCache.getWithMetadata(unwrappedKey);\n-         if (value != null) {\n-            Metadata metadata = new EmbeddedMetadata.Builder()\n-                  .version(new NumericVersion(value.getVersion()))\n-                  .lifespan(value.getLifespan(), TimeUnit.SECONDS)\n-                  .maxIdle(value.getMaxIdle(), TimeUnit.SECONDS).build();\n-            long created = value.getCreated();\n-            long lastUsed = value.getLastUsed();\n-            Object realValue = value.getValue();\n-            if (realValue instanceof byte[]) {\n-               realValue = new WrappedByteArray((byte[]) realValue);\n+         Object unwrappedKey = unwrap(key);\n+         CompletableFuture<MetadataValue<Object>> valueStage = remoteCache.getWithMetadataAsync(unwrappedKey);", "originalCommit": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0Nzc3NA==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r467047774", "bodyText": "Sure.", "author": "wburns", "createdAt": "2020-08-07T13:41:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyNjY0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIzMTg2NA==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r466231864", "bodyText": "To improve readability we can just do long lifespan = metadata != null ? toSeconds(metadata.lifespan(), entry.getKey()) : -1;\nThe put call is then just:\n      return remoteCache.putAsync(key, value, lifespan, TimeUnit.SECONDS, maxIdle, TimeUnit.SECONDS)\n            .thenApply(CompletableFutures.toNullFunction());\nI'm also not sure that the current trace message of outputting the key is particularly useful, so we could simplify toSeconds by removing the key param.", "author": "ryanemerson", "createdAt": "2020-08-06T08:23:23Z", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -299,65 +332,61 @@ public void write(MarshallableEntry entry) throws PersistenceException {\n       Object key = getKey(entry);\n       Object value = getValue(entry);\n \n-      remoteCache.put(key, value, toSeconds(lifespan, entry.getKey(), LIFESPAN), TimeUnit.SECONDS,\n-            toSeconds(maxIdle, entry.getKey(), MAXIDLE), TimeUnit.SECONDS);\n+      return remoteCache.putAsync(key, value, toSeconds(lifespan, entry.getKey(), LIFESPAN), TimeUnit.SECONDS,", "originalCommit": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0ODkzNA==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r467048934", "bodyText": "Sure, I didn't think to reduce the existing code :)", "author": "wburns", "createdAt": "2020-08-07T13:43:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIzMTg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIzMjMxOQ==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r466232319", "bodyText": "sp -> Flowable.fromPublisher can be replaced with method references throughout.", "author": "ryanemerson", "createdAt": "2020-08-06T08:24:13Z", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -299,65 +332,61 @@ public void write(MarshallableEntry entry) throws PersistenceException {\n       Object key = getKey(entry);\n       Object value = getValue(entry);\n \n-      remoteCache.put(key, value, toSeconds(lifespan, entry.getKey(), LIFESPAN), TimeUnit.SECONDS,\n-            toSeconds(maxIdle, entry.getKey(), MAXIDLE), TimeUnit.SECONDS);\n+      return remoteCache.putAsync(key, value, toSeconds(lifespan, entry.getKey(), LIFESPAN), TimeUnit.SECONDS,\n+            toSeconds(maxIdle, entry.getKey(), MAXIDLE), TimeUnit.SECONDS)\n+            .thenApply(CompletableFutures.toNullFunction());\n    }\n \n    private Object getKey(MarshallableEntry entry) {\n-      Object key = entry.getKey();\n-      if (key instanceof WrappedByteArray)\n-         return ((WrappedByteArray) key).getBytes();\n-      return key;\n+      return unwrap(entry.getKey());\n    }\n \n    private Object getValue(MarshallableEntry entry) {\n       if (configuration.rawValues()) {\n-         Object value = entry.getValue();\n-         return value instanceof WrappedByteArray ? ((WrappedByteArray) value).getBytes() : value;\n+         return unwrap(entry.getValue());\n       }\n       return entry.getMarshalledValue();\n    }\n \n    @Override\n-   public CompletionStage<Void> bulkUpdate(Publisher<MarshallableEntry<? extends K, ? extends V>> publisher) {\n-      return Flowable.fromPublisher(publisher)\n-            .buffer(configuration.maxBatchSize())\n-            // TODO: this is blocking - when the full non blocking SPI is introduced this needs to chain returns\n-            // of the putAll to ensure that only a single batch is sent at a time\n-            .doOnNext(entries -> remoteCache.putAll(entries.stream().collect(Collectors.toMap(this::getKey, this::getValue))))\n-            .doOnError(PersistenceException::new)\n-            .ignoreElements()\n+   public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n+         Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n+      Completable removeCompletable = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp), publisherCount)", "originalCommit": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0NTk1OA==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r467045958", "bodyText": "\ud83d\udc4d", "author": "wburns", "createdAt": "2020-08-07T13:38:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIzMjMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIzMzIyMA==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r466233220", "bodyText": "Do we need to convert milliseconds to seconds here in the same manner as write()?", "author": "ryanemerson", "createdAt": "2020-08-06T08:25:42Z", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -299,65 +332,61 @@ public void write(MarshallableEntry entry) throws PersistenceException {\n       Object key = getKey(entry);\n       Object value = getValue(entry);\n \n-      remoteCache.put(key, value, toSeconds(lifespan, entry.getKey(), LIFESPAN), TimeUnit.SECONDS,\n-            toSeconds(maxIdle, entry.getKey(), MAXIDLE), TimeUnit.SECONDS);\n+      return remoteCache.putAsync(key, value, toSeconds(lifespan, entry.getKey(), LIFESPAN), TimeUnit.SECONDS,\n+            toSeconds(maxIdle, entry.getKey(), MAXIDLE), TimeUnit.SECONDS)\n+            .thenApply(CompletableFutures.toNullFunction());\n    }\n \n    private Object getKey(MarshallableEntry entry) {\n-      Object key = entry.getKey();\n-      if (key instanceof WrappedByteArray)\n-         return ((WrappedByteArray) key).getBytes();\n-      return key;\n+      return unwrap(entry.getKey());\n    }\n \n    private Object getValue(MarshallableEntry entry) {\n       if (configuration.rawValues()) {\n-         Object value = entry.getValue();\n-         return value instanceof WrappedByteArray ? ((WrappedByteArray) value).getBytes() : value;\n+         return unwrap(entry.getValue());\n       }\n       return entry.getMarshalledValue();\n    }\n \n    @Override\n-   public CompletionStage<Void> bulkUpdate(Publisher<MarshallableEntry<? extends K, ? extends V>> publisher) {\n-      return Flowable.fromPublisher(publisher)\n-            .buffer(configuration.maxBatchSize())\n-            // TODO: this is blocking - when the full non blocking SPI is introduced this needs to chain returns\n-            // of the putAll to ensure that only a single batch is sent at a time\n-            .doOnNext(entries -> remoteCache.putAll(entries.stream().collect(Collectors.toMap(this::getKey, this::getValue))))\n-            .doOnError(PersistenceException::new)\n-            .ignoreElements()\n+   public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n+         Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n+      Completable removeCompletable = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp), publisherCount)\n+            .map(RemoteStore::unwrap)\n+            .flatMapCompletable(key -> Completable.fromCompletionStage(remoteCache.removeAsync(key)), false, 10);\n+\n+      Completable putCompletable = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp), publisherCount)\n+            .groupBy(MarshallableEntry::getMetadata)\n+            .flatMapCompletable(meFlowable -> meFlowable.buffer(configuration.maxBatchSize())\n+                  .flatMapCompletable(meList -> {\n+                     Map<Object, Object> map = meList.stream().collect(Collectors.toMap(this::getKey, this::getValue));\n+\n+                     Metadata metadata = meFlowable.getKey();\n+                     long lifespan = metadata != null ? metadata.lifespan() : -1;\n+                     long maxIdle = metadata != null ? metadata.maxIdle() : -1;\n+\n+                     return Completable.fromCompletionStage(remoteCache.putAllAsync(map, lifespan, TimeUnit.SECONDS,", "originalCommit": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA1MDI5MA==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r467050290", "bodyText": "Yes, probably. I was fixing the bug that batch before didn't pay attention to metadata and didn't quite get it right \ud83d\udc4d", "author": "wburns", "createdAt": "2020-08-07T13:45:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIzMzIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc2MDE3Mw==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r467760173", "bodyText": "typo", "author": "gustavonalle", "createdAt": "2020-08-10T08:37:09Z", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec27.java", "diffHunk": "@@ -13,6 +13,8 @@\n  */\n public class Codec27 extends Codec26 {\n \n+   public static final String EMPTY_VAUE_CONVERTER = \"org.infinispan.server.hotrod.HotRodServer$ToEmptyBytesKeyValueFilterConverter\";", "originalCommit": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAyMDE0NQ==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r468020145", "bodyText": "Fixed.", "author": "wburns", "createdAt": "2020-08-10T16:12:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc2MDE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc2MjQyOQ==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r467762429", "bodyText": "Could you please check if https://github.com/infinispan/infinispan/blob/8aa30677362ea1befcb5b9a828008dd0bc69d857/documentation/src/main/asciidoc/topics/ref_rolling_upgrade_remote_store.adoc can be updated to remove those deprecated attributes?", "author": "gustavonalle", "createdAt": "2020-08-10T08:41:44Z", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/configuration/RemoteStoreConfiguration.java", "diffHunk": "@@ -145,6 +149,10 @@ public ProtocolVersion protocol() {\n       return protocolVersion.get();\n    }\n \n+   /**\n+    * @deprecated since 12.0 - This option can still be needed when retrieving from a preexisting remote cache\n+    */\n+   @Deprecated\n    public boolean rawValues() {", "originalCommit": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAyMDA2MA==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r468020060", "bodyText": "TBH, I need to think about it more. I would rather leave them alone for this PR as I am not certain yet. TBH we may not be able to remove raw values even, it needs more thought. I created https://issues.redhat.com/browse/ISPN-12209 to do this.", "author": "wburns", "createdAt": "2020-08-10T16:12:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc2MjQyOQ=="}], "type": "inlineReview"}, {"oid": "1305fabb677fe9490462f1afb7ddb32a53ffca9d", "url": "https://github.com/infinispan/infinispan/commit/1305fabb677fe9490462f1afb7ddb32a53ffca9d", "message": "more review changes", "committedDate": "2020-08-10T16:45:59Z", "type": "forcePushed"}, {"oid": "af7e39fe02a06b9edab45d6a8a0412df7bc26dcf", "url": "https://github.com/infinispan/infinispan/commit/af7e39fe02a06b9edab45d6a8a0412df7bc26dcf", "message": "ISPN-11992 Convert RemoteStore to use new SPI\n\n* Disabled segmentation support in RemoteStore", "committedDate": "2020-08-17T14:50:45Z", "type": "commit"}, {"oid": "d35978bb3bd46c64166a1a92de169a8de61dcf1c", "url": "https://github.com/infinispan/infinispan/commit/d35978bb3bd46c64166a1a92de169a8de61dcf1c", "message": "ISPN-12165 Change RemoteStore to handle media types and verify segments", "committedDate": "2020-08-17T14:51:02Z", "type": "commit"}, {"oid": "28dca8b3ec6703467f3977a52d92bb863ae39c5e", "url": "https://github.com/infinispan/infinispan/commit/28dca8b3ec6703467f3977a52d92bb863ae39c5e", "message": "ISPN-12174 Custom Store cannot configure segmented via xml", "committedDate": "2020-08-17T14:51:02Z", "type": "commit"}, {"oid": "28dca8b3ec6703467f3977a52d92bb863ae39c5e", "url": "https://github.com/infinispan/infinispan/commit/28dca8b3ec6703467f3977a52d92bb863ae39c5e", "message": "ISPN-12174 Custom Store cannot configure segmented via xml", "committedDate": "2020-08-17T14:51:02Z", "type": "forcePushed"}, {"oid": "f4724ac0d5768f4e942984055c4505f6f0b054ca", "url": "https://github.com/infinispan/infinispan/commit/f4724ac0d5768f4e942984055c4505f6f0b054ca", "message": "ISPN-12237 Add Blockhound exclusion for ForkJoinPool", "committedDate": "2020-08-18T17:09:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2MDIzMg==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462960232", "bodyText": "Should have @Override now", "author": "danberindei", "createdAt": "2020-07-30T12:28:44Z", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/RemoteCacheImpl.java", "diffHunk": "@@ -563,8 +563,8 @@ public void removeClientListener(Object listener) {\n       return result;\n    }\n \n-   public PingResponse ping() {\n-      return await(operationsFactory.newFaultTolerantPingOperation().execute());\n+   public CompletionStage<PingResponse> ping() {", "originalCommit": "e502b6565f3756083dd5d3b397f673a59a28f95c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk1NDA1NQ==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r464954055", "bodyText": "A bit off-topic, but from reading the code, I think a null value should be fine.", "author": "danberindei", "createdAt": "2020-08-04T10:28:10Z", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec27.java", "diffHunk": "@@ -23,7 +25,6 @@ public HeaderParams writeHeader(ByteBuf buf, HeaderParams params) {\n          IntSet segments, int batchSize) {\n       return new IteratorMapper<>(remoteCache.retrieveEntries(\n             // Use the ToEmptyBytesKeyValueFilterConverter to remove value payload\n-            \"org.infinispan.server.hotrod.HotRodServer$ToEmptyBytesKeyValueFilterConverter\", segments, batchSize),\n-            e -> (K) e.getKey());\n+            EMPTY_VAUE_CONVERTER, segments, batchSize), e -> (K) e.getKey());", "originalCommit": "0e898323311376a9aee0b42ed1ff32aa6d22af24", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk1NjI0Nw==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r464956247", "bodyText": "It's cheaper to write -1 with SignedNumeric when the segment is missing.\nIt's also cheaper when reading, because autoboxing won't have to look up the segment in the Integer cache.", "author": "danberindei", "createdAt": "2020-08-04T10:32:46Z", "path": "core/src/main/java/org/infinispan/commands/remote/ClusteredGetCommand.java", "diffHunk": "@@ -109,14 +116,22 @@ public byte getCommandId() {\n    @Override\n    public void writeTo(ObjectOutput output) throws IOException {\n       output.writeObject(key);\n-      UnsignedNumeric.writeUnsignedInt(output, segment);\n+      if (segment != null) {\n+         output.writeBoolean(true);\n+         UnsignedNumeric.writeUnsignedInt(output, segment);", "originalCommit": "0e898323311376a9aee0b42ed1ff32aa6d22af24", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAzMzE5OA==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r465033198", "bodyText": "Could we change parseStoreAttribute to parse the base store attributes and let the specific store methods parse the store-specific attributes?\nThere's a bit of duplication, and I'm not sure why so many attributes are parsed but ignored unless the \"custom\" store is a SingleFileStore.", "author": "danberindei", "createdAt": "2020-08-04T13:02:52Z", "path": "core/src/main/java/org/infinispan/configuration/parsing/Parser.java", "diffHunk": "@@ -2626,6 +2627,9 @@ private void parseCustomStore(final XMLExtendedStreamReader reader, final Config\n             case TRANSACTIONAL:\n                transactional = Boolean.parseBoolean(value);\n                break;\n+            case SEGMENTED:", "originalCommit": "0e898323311376a9aee0b42ed1ff32aa6d22af24", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTM5MDM1OQ==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r571390359", "bodyText": "The comment still references the class name, but that doesn't make sense now that the class name was moved to a constant. I suggest Use a converter to remove the value payload instead.", "author": "danberindei", "createdAt": "2021-02-06T09:11:58Z", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec27.java", "diffHunk": "@@ -23,7 +25,6 @@ public HeaderParams writeHeader(ByteBuf buf, HeaderParams params) {\n          IntSet segments, int batchSize) {\n       return new IteratorMapper<>(remoteCache.retrieveEntries(\n             // Use the ToEmptyBytesKeyValueFilterConverter to remove value payload\n-            \"org.infinispan.server.hotrod.HotRodServer$ToEmptyBytesKeyValueFilterConverter\", segments, batchSize),\n-            e -> (K) e.getKey());\n+            EMPTY_VALUE_CONVERTER, segments, batchSize), e -> (K) e.getKey());", "originalCommit": "f4724ac0d5768f4e942984055c4505f6f0b054ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTM5MDUwMQ==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r571390501", "bodyText": "\"does not have the SEGMENTABLE characteristic\" sounds better to me", "author": "danberindei", "createdAt": "2021-02-06T09:14:05Z", "path": "core/src/main/java/org/infinispan/util/logging/Log.java", "diffHunk": "@@ -2041,4 +2041,7 @@ CacheConfigurationException storeConfiguredHasBothReadAndWriteOnly(String storeC\n \n    @Message(value = \"Store %s cannot be configured to be shared as it does not contain the SHARED characteristic\", id = 600)\n    CacheConfigurationException storeConfiguredSharedButCharacteristicNotPresent(String storeClassName);\n+\n+   @Message(value = \"Store %s cannot be configured to be segmented as it does not contain the SEGMENTABLE characteristic\", id = 601)", "originalCommit": "f4724ac0d5768f4e942984055c4505f6f0b054ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTM5MTM0NQ==", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r571391345", "bodyText": "Why not throw an UnsupportedOperationException?", "author": "danberindei", "createdAt": "2021-02-06T09:22:09Z", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -451,7 +477,19 @@ public RemoteStoreConfiguration getConfiguration() {\n    }\n \n    @Override\n-   public boolean shouldWrite(long commandFlags) {\n-      return !EnumUtil.containsAny(FlagBitSets.ROLLING_UPGRADE, commandFlags);\n+   public boolean ignoreCommandWithFlags(long commandFlags) {\n+      return EnumUtil.containsAny(FlagBitSets.ROLLING_UPGRADE, commandFlags);\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> addSegments(IntSet segments) {\n+      // Here for documentation purposes. This method should never be invoked as we only support segmented when shared", "originalCommit": "f4724ac0d5768f4e942984055c4505f6f0b054ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}