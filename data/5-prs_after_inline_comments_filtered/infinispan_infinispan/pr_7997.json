{"pr_number": 7997, "pr_title": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking t\u2026", "pr_createdAt": "2020-03-04T21:00:03Z", "pr_url": "https://github.com/infinispan/infinispan/pull/7997", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyNDYzMg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r388224632", "bodyText": "@danberindei @wburns WDYT to adding a default implemntation to ReplicableCommand that returns false? It will remove a fair bit of boilerplate.", "author": "ryanemerson", "createdAt": "2020-03-05T11:06:07Z", "path": "core/src/main/java/org/infinispan/commands/functional/AbstractWriteManyCommand.java", "diffHunk": "@@ -88,7 +88,7 @@ public boolean isConditional() {\n \n    @Override\n    public boolean canBlock() {\n-      return true;\n+      return false;", "originalCommit": "75e1aa23af44388a3ba79e94f33f6c3ae072392b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMwMzg0NA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r388303844", "bodyText": "I had debated about it, but didn't try it. I can see how it feels. I was debating about even deprecating the method as well.", "author": "wburns", "createdAt": "2020-03-05T13:50:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyNDYzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ1MTYyMA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r388451620", "bodyText": "Deprecating it sounds good. At the very least it gives us the option to remove it in 12 even if we're not ready to do that.", "author": "ryanemerson", "createdAt": "2020-03-05T17:36:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyNDYzMg=="}], "type": "inlineReview"}, {"oid": "0574783db675921d696b4434abe2784dba696582", "url": "https://github.com/infinispan/infinispan/commit/0574783db675921d696b4434abe2784dba696582", "message": "test fixes", "committedDate": "2020-03-05T16:56:58Z", "type": "forcePushed"}, {"oid": "57a1afb12cb3453e6a61fcd43788102311d3ab3f", "url": "https://github.com/infinispan/infinispan/commit/57a1afb12cb3453e6a61fcd43788102311d3ab3f", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places", "committedDate": "2020-03-10T17:00:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyMTExMw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394121113", "bodyText": "Is this really needed? The configuration is in a string, so we shouldn't block to read it, and there's no resolver to allow includes from external resources.\nOff-topic, ParserRegistry.parse(String) could avoid wrapping the ByteArrayInputStream in a BufferedInputStream. I would have suggested using factory.createXMLStreamReader(new StringReader(configString)), but then I read its implementation and it would do even more extra work.", "author": "danberindei", "createdAt": "2020-03-18T05:58:46Z", "path": "core/src/main/java/org/infinispan/globalstate/impl/GlobalConfigurationManagerImpl.java", "diffHunk": "@@ -196,13 +198,16 @@ void start() {\n \n    CompletableFuture<Void> createCacheLocally(String name, CacheState state) {\n       log.debugf(\"Create cache %s\", name);\n-      Configuration configuration = buildConfiguration(name, state);\n-      return localConfigurationManager.createCache(name, state.getTemplate(), configuration, state.getFlags());\n+      CompletionStage<Configuration> configurationStage = buildConfiguration(name, state);\n+      return configurationStage.thenCompose(configuration -> localConfigurationManager.createCache(name, state.getTemplate(), configuration, state.getFlags()))\n+            .toCompletableFuture();\n    }\n \n-   private Configuration buildConfiguration(String name, CacheState state) {\n-      ConfigurationBuilderHolder builderHolder = parserRegistry.parse(state.getConfiguration());\n-      return builderHolder.getNamedConfigurationBuilders().get(name).build(configurationManager.getGlobalConfiguration());\n+   private CompletionStage<Configuration> buildConfiguration(String name, CacheState state) {\n+      return CompletableFuture.supplyAsync(() -> {\n+         ConfigurationBuilderHolder builderHolder = parserRegistry.parse(state.getConfiguration());\n+         return builderHolder.getNamedConfigurationBuilders().get(name).build(configurationManager.getGlobalConfiguration());\n+      }, blockingExecutor);", "originalCommit": "57a1afb12cb3453e6a61fcd43788102311d3ab3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMzNzg2Nw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394337867", "bodyText": "It was detected by block hound as blocking. I can take a closer look later today.", "author": "wburns", "createdAt": "2020-03-18T13:17:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyMTExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyMjIyNw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394122227", "bodyText": "Is/should there be a way to use the non-blocking executor for users of ClusterExecutor that know their callback is non-blocking? Maybe internal code should be sending commands anyway?", "author": "danberindei", "createdAt": "2020-03-18T06:02:55Z", "path": "core/src/main/java/org/infinispan/manager/DefaultCacheManager.java", "diffHunk": "@@ -1140,7 +1140,8 @@ public ClusterExecutor executor() {\n       if (transport != null) {\n          long time = configurationManager.getGlobalConfiguration().transport().distributedSyncTimeout();\n          return ClusterExecutors.allSubmissionExecutor(null, this, transport, time, TimeUnit.MILLISECONDS,\n-               globalComponentRegistry.getComponent(ExecutorService.class, KnownComponentNames.REMOTE_COMMAND_EXECUTOR),\n+               // This can run arbitrary code, including user - assume it is blocking\n+               globalComponentRegistry.getComponent(ExecutorService.class, KnownComponentNames.BLOCKING_EXECUTOR),", "originalCommit": "57a1afb12cb3453e6a61fcd43788102311d3ab3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0MjA1OA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394342058", "bodyText": "I was debating about this. We should probably do something though. I think having a separate JIRA is probably best. https://issues.redhat.com/browse/ISPN-11482", "author": "wburns", "createdAt": "2020-03-18T13:24:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyMjIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyMjkzNg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394122936", "bodyText": "I was hoping that the result of canBlock() would already be ignored, and it would be the command's job to submit a task to the blocking executor if needed. Maybe in the next version, then :)", "author": "danberindei", "createdAt": "2020-03-18T06:05:45Z", "path": "core/src/main/java/org/infinispan/manager/impl/ReplicableManagerFunctionCommand.java", "diffHunk": "@@ -61,6 +61,7 @@ public boolean isReturnValueExpected() {\n \n    @Override\n    public boolean canBlock() {\n+      // These commands can be arbitrary user commands - so be careful about them blocking", "originalCommit": "57a1afb12cb3453e6a61fcd43788102311d3ab3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0Mjg2OQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394342869", "bodyText": "Hrmm, I think I understand now. You mean inside the invokeAsync directly. I can make a new JIRA to do that as it will inflate this probably a bit.", "author": "wburns", "createdAt": "2020-03-18T13:25:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyMjkzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0NDcyMQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394344721", "bodyText": "https://issues.redhat.com/browse/ISPN-11483", "author": "wburns", "createdAt": "2020-03-18T13:28:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyMjkzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyNzE0Mg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394127142", "bodyText": "So we assume any ReplicableCommand is blocking?", "author": "danberindei", "createdAt": "2020-03-18T06:21:51Z", "path": "core/src/main/java/org/infinispan/remoting/inboundhandler/GlobalInboundInvocationHandler.java", "diffHunk": "@@ -135,7 +135,7 @@ private void handleReplicableCommand(Address origin, ReplicableCommand command,\n          //we must/can run in this thread\n          runnable.run();\n       } else {\n-         remoteCommandsExecutor.execute(runnable);\n+         blockingExecutor.execute(runnable);", "originalCommit": "57a1afb12cb3453e6a61fcd43788102311d3ab3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0NDk2NA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394344964", "bodyText": "Why do you say that, sorry? It should only do this if canBlock was true.", "author": "wburns", "createdAt": "2020-03-18T13:28:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyNzE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY5MDA0NQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394690045", "bodyText": "Sorry, I was only looking at the diff and I forgot that ReplicableCommand has canBlock(), I thought it was in CacheRpcCommand.", "author": "danberindei", "createdAt": "2020-03-18T23:09:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyNzE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyNzgyMQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394127821", "bodyText": "I would assume the unlock method can't block, so it's just for symmetry", "author": "danberindei", "createdAt": "2020-03-18T06:24:35Z", "path": "core/src/main/java/org/infinispan/topology/ClusterTopologyManagerImpl.java", "diffHunk": "@@ -179,17 +179,29 @@ public void start() {\n    @Stop(priority = 100)\n    public void stop() {\n       // Stop blocking cache topology commands.\n-      updateLock.lock();\n+      acquireUpdateLock();\n       try {\n          clusterManagerStatus = ClusterManagerStatus.STOPPING;\n          joinViewFuture.stop();\n       } finally {\n-         updateLock.unlock();\n+         releaseUpdateLock();\n       }\n \n       cacheManagerNotifier.removeListener(viewListener);\n    }\n \n+   // This method is here to augment with blockhound as we allow it to block, but don't want the calls\n+   // inside the lock to block - Do not move or rename without updating the reference\n+   private void acquireUpdateLock() {\n+      updateLock.lock();\n+   }\n+\n+   // This method is here to augment with blockhound as we allow it to block, but don't want the calls\n+   // inside the lock to block - Do not move or rename without updating the reference", "originalCommit": "57a1afb12cb3453e6a61fcd43788102311d3ab3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0NTY5NQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394345695", "bodyText": "Sure, let me try removing actually. I don't quite remember ;)", "author": "wburns", "createdAt": "2020-03-18T13:29:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyNzgyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY5MDMzNg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394690336", "bodyText": "I wanted to keep the method so acquire/release is symmetric, I just wanted to remove the comment and the exception in the blockhound integration.", "author": "danberindei", "createdAt": "2020-03-18T23:10:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyNzgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyODA4MA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394128080", "bodyText": "Doesn't add anything IMO", "author": "danberindei", "createdAt": "2020-03-18T06:25:30Z", "path": "core/src/main/java/org/infinispan/util/CoreBlockHoundIntegration.java", "diffHunk": "@@ -47,6 +48,10 @@ public void applyTo(BlockHound.Builder builder) {\n \n          // This shouldn't block long when held - but it is a write lock which can be delayed\n          builder.allowBlockingCallsInside(KeyAffinityServiceImpl.class.getName(), \"handleViewChange\");\n+\n+         // Let the lock acquisition be blocking", "originalCommit": "57a1afb12cb3453e6a61fcd43788102311d3ab3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0NTk4OQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394345989", "bodyText": "Okay.", "author": "wburns", "createdAt": "2020-03-18T13:30:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyODA4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEzMDkzMQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394130931", "bodyText": "Assuming this is just for the Thread.sleep() call, I think it would be better to add an executor parameter to TestingUtil.delayed() and to inject the non-blocking executor in ReplListenerInterceptor.", "author": "danberindei", "createdAt": "2020-03-18T06:35:57Z", "path": "core/src/test/java/org/infinispan/util/CoreTestBlockHoundIntegration.java", "diffHunk": "@@ -67,6 +73,10 @@ private static void allowTestsToBlock(BlockHound.Builder builder) {\n       CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, NotifierLatch.class);\n \n       CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, TestBlocking.class);\n+\n+      CommonsBlockHoundIntegration.allowMethodsToBlock(builder, Class.forName(ReplListener.class.getName() + \"$ReplListenerInterceptor\"), false);", "originalCommit": "57a1afb12cb3453e6a61fcd43788102311d3ab3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0ODczMA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394348730", "bodyText": "Actually am not sure why I didn't just add TestingUtil#sleepThread to the exception list. Let me try that instead.", "author": "wburns", "createdAt": "2020-03-18T13:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEzMDkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3NDIwNw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394474207", "bodyText": "Ah it was because of logCommand that acquires a lock. I think I will leave it as is for now.", "author": "wburns", "createdAt": "2020-03-18T16:20:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEzMDkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3NDQ1MA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394474450", "bodyText": "But I can also add TestingUtil#sleepThread as okay to block though too.", "author": "wburns", "createdAt": "2020-03-18T16:20:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEzMDkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4ODIxOA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394688218", "bodyText": "+1 to add TestingUtil#sleepThread", "author": "danberindei", "createdAt": "2020-03-18T23:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEzMDkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg5ODI0NA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395898244", "bodyText": "Seems to work fine without the ReplListenerInterceptor exception now.", "author": "danberindei", "createdAt": "2020-03-20T21:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEzMDkzMQ=="}], "type": "inlineReview"}, {"oid": "b3bd615b4121bde9fd9c99c662669841ac5a27d7", "url": "https://github.com/infinispan/infinispan/commit/b3bd615b4121bde9fd9c99c662669841ac5a27d7", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places", "committedDate": "2020-03-18T16:35:03Z", "type": "forcePushed"}, {"oid": "ad99dea5d1406aa6bf894efe861566804ae9f1e6", "url": "https://github.com/infinispan/infinispan/commit/ad99dea5d1406aa6bf894efe861566804ae9f1e6", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places", "committedDate": "2020-03-18T16:53:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NjI4NQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394686285", "bodyText": "No longer necessary?", "author": "danberindei", "createdAt": "2020-03-18T22:58:04Z", "path": "core/src/main/java/org/infinispan/manager/DefaultCacheManager.java", "diffHunk": "@@ -1139,11 +1138,14 @@ public ClusterExecutor executor() {\n       if (transport != null) {\n          long time = configurationManager.getGlobalConfiguration().transport().distributedSyncTimeout();\n          return ClusterExecutors.allSubmissionExecutor(null, this, transport, time, TimeUnit.MILLISECONDS,\n-               globalComponentRegistry.getComponent(ExecutorService.class, KnownComponentNames.REMOTE_COMMAND_EXECUTOR),\n+               // This can run arbitrary code, including user - such commands can block", "originalCommit": "4730be1a23e42918e2f831d1bbff89fd1f778649", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcwMDE2MQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394700161", "bodyText": "No, I more put it here because it can block :)", "author": "wburns", "createdAt": "2020-03-18T23:38:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NjI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEyMzU4MA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395123580", "bodyText": "Should it be using the non-blocking executor then?", "author": "danberindei", "createdAt": "2020-03-19T15:41:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NjI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEyNzg5NA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395127894", "bodyText": "Unfortunately until the other JIRA is fixed, we don't have a great solution. And cluster executor isn't that widely used afaik. But we should hopefully get it fixed before people use  it like this.", "author": "wburns", "createdAt": "2020-03-19T15:47:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NjI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU0NTM4Nw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395545387", "bodyText": "Unfortunately I think the few users of cluster executor may be doing exactly blocking cache operations, because there's no way to return a value asynchronously.\nI'm starting to think that the proper solution is\n\nchange PersistenceManagerImpl to detect if it is a blocking thread and run it inline and if non blocking thread to run the command in a blocking thread.\n\nIn fact, I would go even further, and change continueOnCPUExecutor to also continue on the caller thread if the caller thread was blocking. Otherwise, for cluster executor tasks doing cache.put(k1, v1), where the put requires 1 store operation to read the previous value and 1 store operation to store the value, the store read would happen on the task's initial blocking thread, but the store write would need another blocking thread. If the size of the blocking thread pool is N and you have N simultaneous tasks like this, there's no free thread to process the store writes.", "author": "danberindei", "createdAt": "2020-03-20T10:21:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NjI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc0ODAzNA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395748034", "bodyText": "Just an FYI but the only way currently we have to detect if it is a blocking thread is to check the thread name, which is quite brittle.\nAlso your put case, I don't see how the read and write would need concurrent blocking threads. The read would be done before then the write would be done afterwards, synchronously.", "author": "wburns", "createdAt": "2020-03-20T16:21:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NjI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNDU2NQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395824565", "bodyText": "Just an FYI but the only way currently we have to detect if it is a blocking thread is to check the thread name, which is quite brittle.\n\nCan't we do !(Thread.currentThread() instanceof ISPNNonBlockingThread)?\n\nAlso your put case, I don't see how the read and write would need concurrent blocking threads. The read would be done before then the write would be done afterwards, synchronously.\n\nIf the cluster executor task does a blocking cache.put(k, v), it needs a (blocking) thread for the entire duration of the cache operation. The read would run on the same thread, but then continueOnCPUExecutor() would submit a task to the non-blocking executor, and the next PersistenceManagerImpl call would submit a task to the blocking executor.", "author": "danberindei", "createdAt": "2020-03-20T18:38:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NjI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzNDM4Mw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395834383", "bodyText": "Can't we do !(Thread.currentThread() instanceof ISPNNonBlockingThread)?\n\nNo, unfortunately. This would include user threads, jgroups etc.\n\nIf the cluster executor task does a blocking cache.put(k, v), it needs a (blocking) thread for the entire duration of the cache operation. The read would run on the same thread, but then continueOnCPUExecutor() would submit a task to the non-blocking executor, and the next PersistenceManagerImpl call would submit a task to the blocking executor.\n\nOh, okay you were not referring to the read then write. I agree if a blocking operation is invoked on a blocking thread then yes it would use more than 1.", "author": "wburns", "createdAt": "2020-03-20T18:58:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NjI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NzIxOA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394687218", "bodyText": "Since you created a separate ISPN-11483, we should return true here for now.", "author": "danberindei", "createdAt": "2020-03-18T23:00:45Z", "path": "core/src/main/java/org/infinispan/manager/impl/ReplicableManagerFunctionCommand.java", "diffHunk": "@@ -61,6 +61,7 @@ public boolean isReturnValueExpected() {\n \n    @Override\n    public boolean canBlock() {\n-      return true;\n+      // Note that it is highly possible that a user command could block, and some internal Infinispan ones already do\n+      return false;", "originalCommit": "4730be1a23e42918e2f831d1bbff89fd1f778649", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcwMDE3OQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394700179", "bodyText": "The problem is we invoke some commands that invoke stores and it causes issues.", "author": "wburns", "createdAt": "2020-03-18T23:38:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NzIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEyNDM2MQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395124361", "bodyText": "Please add a comment to explain why you're returning false even though it can block.", "author": "danberindei", "createdAt": "2020-03-19T15:42:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NzIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEyNzUwNg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395127506", "bodyText": "Sure I forgot to put the JIRA in the comments.", "author": "wburns", "createdAt": "2020-03-19T15:46:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NzIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU2MTM0MA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395561340", "bodyText": "Maybe I'm missing something, but that JIRA is a bit confusing to me. The subject is \"Provide way for ClusterExecutor to use non blocking thread\", but we are already using a non-blocking thread by returning false here.", "author": "danberindei", "createdAt": "2020-03-20T10:54:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NzIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4Nzk5MQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394687991", "bodyText": "Temporary?", "author": "danberindei", "createdAt": "2020-03-18T23:03:04Z", "path": "core/src/test/java/org/infinispan/stream/DistributedSequentialNonRehashStreamTest.java", "diffHunk": "@@ -10,7 +10,7 @@\n  * Verifies stream tests work when rehash is disabled on a sequential stream\n  */\n @Test(groups = \"functional\", testName = \"streams.DistributedSequentialNonRehashStreamTest\")\n-@InCacheMode({ CacheMode.DIST_SYNC, CacheMode.SCATTERED_SYNC })\n+@InCacheMode({ /*CacheMode.DIST_SYNC,*/ CacheMode.SCATTERED_SYNC })", "originalCommit": "4730be1a23e42918e2f831d1bbff89fd1f778649", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY5OTkzMA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394699930", "bodyText": "I am not sure how this got in here.... I didn't even look at that class, lol.", "author": "wburns", "createdAt": "2020-03-18T23:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4Nzk5MQ=="}], "type": "inlineReview"}, {"oid": "bf6f39a2d3909b5ea4a8484447c8da5678e7f926", "url": "https://github.com/infinispan/infinispan/commit/bf6f39a2d3909b5ea4a8484447c8da5678e7f926", "message": "ISPN-11489 TransactionCoordinator updated for non blocking", "committedDate": "2020-03-19T15:50:32Z", "type": "forcePushed"}, {"oid": "5c0b1da5ebdf26ebdae76312f643f4c659c29e3b", "url": "https://github.com/infinispan/infinispan/commit/5c0b1da5ebdf26ebdae76312f643f4c659c29e3b", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places", "committedDate": "2020-03-19T18:13:38Z", "type": "forcePushed"}, {"oid": "ddd733c194568ba62d020813de25ad5507acdb8d", "url": "https://github.com/infinispan/infinispan/commit/ddd733c194568ba62d020813de25ad5507acdb8d", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places", "committedDate": "2020-03-19T19:02:46Z", "type": "forcePushed"}, {"oid": "97976107c069b2923c52a869eb6a0e60c53a4691", "url": "https://github.com/infinispan/infinispan/commit/97976107c069b2923c52a869eb6a0e60c53a4691", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread", "committedDate": "2020-03-20T04:15:07Z", "type": "forcePushed"}, {"oid": "5ae68c59a1ff3b403e6cd10242709031b2122866", "url": "https://github.com/infinispan/infinispan/commit/5ae68c59a1ff3b403e6cd10242709031b2122866", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread", "committedDate": "2020-03-20T04:22:12Z", "type": "forcePushed"}, {"oid": "21db4dfaa4eeca00d7ead811823205962d364414", "url": "https://github.com/infinispan/infinispan/commit/21db4dfaa4eeca00d7ead811823205962d364414", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread", "committedDate": "2020-03-20T04:40:16Z", "type": "forcePushed"}, {"oid": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "url": "https://github.com/infinispan/infinispan/commit/fdefde6f70556b8d6666f4038d0085bfadeffb0b", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread", "committedDate": "2020-03-20T12:42:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ2NjgzMg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395466832", "bodyText": "Still using ctx here", "author": "danberindei", "createdAt": "2020-03-20T07:14:55Z", "path": "core/src/main/java/org/infinispan/cache/impl/InvocationHelper.java", "diffHunk": "@@ -238,7 +248,7 @@ private Transaction getOngoingTransaction() {\n             throw CompletableFutures.asCompletionException(e);\n          }\n          return result;\n-      });\n+      }, blockingExecutor), nonBlockingExecutor, ctx).toCompletableFuture();", "originalCommit": "21db4dfaa4eeca00d7ead811823205962d364414", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc0MTU0Mw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395741543", "bodyText": "Yeah forgot to fix, I can change it.", "author": "wburns", "createdAt": "2020-03-20T16:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ2NjgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5NjI4NQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395596285", "bodyText": "I would prefer to make the prepare exception the cause and the rollback exception suppressed. I'd also rename innerT to rollbackThrowable and t to prepareThrowable.", "author": "danberindei", "createdAt": "2020-03-20T12:12:22Z", "path": "core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java", "diffHunk": "@@ -99,92 +107,121 @@ public PrepareCommand createPrepareCommand(GlobalTransaction gtx, List<WriteComm\n       }\n    }\n \n-   public final int prepare(LocalTransaction localTransaction) throws XAException {\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction) {\n       return prepare(localTransaction, false);\n    }\n \n-   public final int prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) throws XAException {\n-      validateNotMarkedForRollback(localTransaction);\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) {\n+      CompletionStage<Integer> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+      if (markRollbackStage != null) {\n+         return markRollbackStage;\n+      }\n \n       if (isOnePhaseCommit(localTransaction)) {\n          if (trace) log.tracef(\"Received prepare for tx: %s. Skipping call as 1PC will be used.\", localTransaction);\n-         return XA_OK;\n+         return XA_OKAY_STAGE;\n       }\n \n       PrepareCommand prepareCommand = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), localTransaction.getModifications(), false);\n       if (trace) log.tracef(\"Sending prepare command through the chain: %s\", prepareCommand);\n \n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       prepareCommand.setReplayEntryWrapping(replayEntryWrapping);\n-      try {\n-         invoker.running().invoke(ctx, prepareCommand);\n+      CompletionStage<Object> prepareStage = invoker.running().invokeAsync(ctx, prepareCommand);\n+      return CompletionStages.handleAndCompose(prepareStage, (ignore, t) -> {\n+         if (t != null) {\n+            if (shuttingDown)\n+               log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n+            else\n+               log.errorProcessingPrepare(t);\n+\n+            //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n+            //after prepare failed.\n+            return CompletionStages.handleAndCompose(rollback(localTransaction), (ignore2, innerT) -> {\n+               // XA_RBROLLBACK tells the TM that we've rolled back already: the TM shouldn't call rollback after this.\n+               XAException xe = new XAException(XAException.XA_RBROLLBACK);\n+               if (innerT != null) {\n+                  innerT.addSuppressed(t);\n+                  xe.initCause(innerT);", "originalCommit": "21db4dfaa4eeca00d7ead811823205962d364414", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc0MDk3Mg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395740972", "bodyText": "I am fine with renaming. Technically rollback would be suppressing the prepare if this was a try/finally block instead, which is why I did it like I did.", "author": "wburns", "createdAt": "2020-03-20T16:10:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5NjI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3NjI5Mw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395676293", "bodyText": "AFAICT handleRollbackFailure and handleCommitFailure don't need to return a CompletionStage", "author": "danberindei", "createdAt": "2020-03-20T14:33:00Z", "path": "core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java", "diffHunk": "@@ -99,92 +107,121 @@ public PrepareCommand createPrepareCommand(GlobalTransaction gtx, List<WriteComm\n       }\n    }\n \n-   public final int prepare(LocalTransaction localTransaction) throws XAException {\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction) {\n       return prepare(localTransaction, false);\n    }\n \n-   public final int prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) throws XAException {\n-      validateNotMarkedForRollback(localTransaction);\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) {\n+      CompletionStage<Integer> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+      if (markRollbackStage != null) {\n+         return markRollbackStage;\n+      }\n \n       if (isOnePhaseCommit(localTransaction)) {\n          if (trace) log.tracef(\"Received prepare for tx: %s. Skipping call as 1PC will be used.\", localTransaction);\n-         return XA_OK;\n+         return XA_OKAY_STAGE;\n       }\n \n       PrepareCommand prepareCommand = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), localTransaction.getModifications(), false);\n       if (trace) log.tracef(\"Sending prepare command through the chain: %s\", prepareCommand);\n \n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       prepareCommand.setReplayEntryWrapping(replayEntryWrapping);\n-      try {\n-         invoker.running().invoke(ctx, prepareCommand);\n+      CompletionStage<Object> prepareStage = invoker.running().invokeAsync(ctx, prepareCommand);\n+      return CompletionStages.handleAndCompose(prepareStage, (ignore, t) -> {\n+         if (t != null) {\n+            if (shuttingDown)\n+               log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n+            else\n+               log.errorProcessingPrepare(t);\n+\n+            //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n+            //after prepare failed.\n+            return CompletionStages.handleAndCompose(rollback(localTransaction), (ignore2, innerT) -> {\n+               // XA_RBROLLBACK tells the TM that we've rolled back already: the TM shouldn't call rollback after this.\n+               XAException xe = new XAException(XAException.XA_RBROLLBACK);\n+               if (innerT != null) {\n+                  innerT.addSuppressed(t);\n+                  xe.initCause(innerT);\n+               } else {\n+                  xe.initCause(t);\n+               }\n+               return CompletableFutures.completedExceptionFuture(xe);\n+            });\n+         }\n          if (localTransaction.isReadOnly()) {\n             if (trace) log.tracef(\"Readonly transaction: %s\", localTransaction.getGlobalTransaction());\n             // force a cleanup to release any objects held.  Some TMs don't call commit if it is a READ ONLY tx.  See ISPN-845\n-            commitInternal(ctx);\n-            return XA_RDONLY;\n+            return commitInternal(ctx)\n+                  .thenApply(XA_RDONLY_APPLY);\n          } else {\n             txTable.running().localTransactionPrepared(localTransaction);\n-            return XA_OK;\n+            return XA_OKAY_STAGE;\n          }\n-      } catch (Throwable e) {\n-         if (shuttingDown)\n-            log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n-         else\n-            log.errorProcessingPrepare(e);\n-\n-         //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n-         //after prepare failed.\n-         rollback(localTransaction);\n-         // XA_RBROLLBACK tells the TM that we've rolled back already: the TM shouldn't call rollback after this.\n-         XAException xe = new XAException(XAException.XA_RBROLLBACK);\n-         xe.initCause(e);\n-         throw xe;\n-      }\n+      });\n    }\n \n-   public boolean commit(LocalTransaction localTransaction, boolean isOnePhase) throws XAException {\n+   public CompletionStage<Boolean> commit(LocalTransaction localTransaction, boolean isOnePhase) {\n       if (trace) log.tracef(\"Committing transaction %s\", localTransaction.getGlobalTransaction());\n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       if (isOnePhaseCommit(localTransaction) || isOnePhase) {\n-         validateNotMarkedForRollback(localTransaction);\n+         CompletionStage<Boolean> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+         if (markRollbackStage != null) {\n+            return markRollbackStage;\n+         }\n \n          if (trace) log.trace(\"Doing an 1PC prepare call on the interceptor chain\");\n          List<WriteCommand> modifications = localTransaction.getModifications();\n          PrepareCommand command = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), modifications, true);\n          try {\n-            invoker.running().invoke(ctx, command);\n+            return CompletionStages.handleAndCompose(invoker.running().invokeAsync(ctx, command),\n+                  (ignore, t) -> {\n+                     if (t != null) {\n+                        return handleCommitFailure(t, true, ctx);\n+                     }\n+                     return CompletableFutures.completedTrue();\n+                  });\n          } catch (Throwable e) {\n-            handleCommitFailure(e, true, ctx);\n+            return handleCommitFailure(e, true, ctx);\n          }\n-         return true;\n       } else if (!localTransaction.isReadOnly()) {\n-         commitInternal(ctx);\n+         return commitInternal(ctx);\n       }\n-      return false;\n+      return CompletableFutures.completedFalse();\n    }\n \n-   public void rollback(LocalTransaction localTransaction) throws XAException {\n+   public CompletionStage<Void> rollback(LocalTransaction localTransaction) {\n       try {\n-         rollbackInternal(icf.running().createTxInvocationContext(localTransaction));\n+         return CompletionStages.handleAndCompose(rollbackInternal(icf.running().createTxInvocationContext(localTransaction)),\n+               (ignore, t) -> {\n+                  if (t != null) {\n+                     return handleRollbackFailure(t, localTransaction);\n+                  }\n+                  return CompletableFutures.completedNull();\n+               });\n+\n       } catch (Throwable e) {\n-         if (shuttingDown)\n-            log.trace(\"Exception while rolling back, probably because we're shutting down.\");\n-         else\n-            log.errorRollingBack(e);\n-\n-         final Transaction transaction = localTransaction.getTransaction();\n-         //this might be possible if the cache has stopped and TM still holds a reference to the XAResource\n-         if (transaction != null) {\n-            txTable.running().failureCompletingTransaction(transaction);\n-         }\n-         XAException xe = new XAException(XAException.XAER_RMERR);\n-         xe.initCause(e);\n-         throw xe;\n+         return handleRollbackFailure(e, localTransaction);\n+      }\n+   }\n+\n+   private <T> CompletionStage<T> handleRollbackFailure(Throwable t, LocalTransaction localTransaction) {", "originalCommit": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTczODEyOA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395738128", "bodyText": "They don't, but the users of it require it to be a CompletionStage, so less code overall. :)", "author": "wburns", "createdAt": "2020-03-20T16:05:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3NjI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNjE3MQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395826171", "bodyText": "If you return void and throw the exception directly, the callers can use handle instead of handleAndCompose", "author": "danberindei", "createdAt": "2020-03-20T18:42:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3NjI5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY4MjQ0Mw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395682443", "bodyText": "AsyncInterceptorChain.invokeAsync() catches exceptions, so we don't nee the try..catch any more.", "author": "danberindei", "createdAt": "2020-03-20T14:42:22Z", "path": "core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java", "diffHunk": "@@ -99,92 +107,121 @@ public PrepareCommand createPrepareCommand(GlobalTransaction gtx, List<WriteComm\n       }\n    }\n \n-   public final int prepare(LocalTransaction localTransaction) throws XAException {\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction) {\n       return prepare(localTransaction, false);\n    }\n \n-   public final int prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) throws XAException {\n-      validateNotMarkedForRollback(localTransaction);\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) {\n+      CompletionStage<Integer> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+      if (markRollbackStage != null) {\n+         return markRollbackStage;\n+      }\n \n       if (isOnePhaseCommit(localTransaction)) {\n          if (trace) log.tracef(\"Received prepare for tx: %s. Skipping call as 1PC will be used.\", localTransaction);\n-         return XA_OK;\n+         return XA_OKAY_STAGE;\n       }\n \n       PrepareCommand prepareCommand = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), localTransaction.getModifications(), false);\n       if (trace) log.tracef(\"Sending prepare command through the chain: %s\", prepareCommand);\n \n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       prepareCommand.setReplayEntryWrapping(replayEntryWrapping);\n-      try {\n-         invoker.running().invoke(ctx, prepareCommand);\n+      CompletionStage<Object> prepareStage = invoker.running().invokeAsync(ctx, prepareCommand);\n+      return CompletionStages.handleAndCompose(prepareStage, (ignore, t) -> {\n+         if (t != null) {\n+            if (shuttingDown)\n+               log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n+            else\n+               log.errorProcessingPrepare(t);\n+\n+            //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n+            //after prepare failed.\n+            return CompletionStages.handleAndCompose(rollback(localTransaction), (ignore2, innerT) -> {\n+               // XA_RBROLLBACK tells the TM that we've rolled back already: the TM shouldn't call rollback after this.\n+               XAException xe = new XAException(XAException.XA_RBROLLBACK);\n+               if (innerT != null) {\n+                  innerT.addSuppressed(t);\n+                  xe.initCause(innerT);\n+               } else {\n+                  xe.initCause(t);\n+               }\n+               return CompletableFutures.completedExceptionFuture(xe);\n+            });\n+         }\n          if (localTransaction.isReadOnly()) {\n             if (trace) log.tracef(\"Readonly transaction: %s\", localTransaction.getGlobalTransaction());\n             // force a cleanup to release any objects held.  Some TMs don't call commit if it is a READ ONLY tx.  See ISPN-845\n-            commitInternal(ctx);\n-            return XA_RDONLY;\n+            return commitInternal(ctx)\n+                  .thenApply(XA_RDONLY_APPLY);\n          } else {\n             txTable.running().localTransactionPrepared(localTransaction);\n-            return XA_OK;\n+            return XA_OKAY_STAGE;\n          }\n-      } catch (Throwable e) {\n-         if (shuttingDown)\n-            log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n-         else\n-            log.errorProcessingPrepare(e);\n-\n-         //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n-         //after prepare failed.\n-         rollback(localTransaction);\n-         // XA_RBROLLBACK tells the TM that we've rolled back already: the TM shouldn't call rollback after this.\n-         XAException xe = new XAException(XAException.XA_RBROLLBACK);\n-         xe.initCause(e);\n-         throw xe;\n-      }\n+      });\n    }\n \n-   public boolean commit(LocalTransaction localTransaction, boolean isOnePhase) throws XAException {\n+   public CompletionStage<Boolean> commit(LocalTransaction localTransaction, boolean isOnePhase) {\n       if (trace) log.tracef(\"Committing transaction %s\", localTransaction.getGlobalTransaction());\n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       if (isOnePhaseCommit(localTransaction) || isOnePhase) {\n-         validateNotMarkedForRollback(localTransaction);\n+         CompletionStage<Boolean> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+         if (markRollbackStage != null) {\n+            return markRollbackStage;\n+         }\n \n          if (trace) log.trace(\"Doing an 1PC prepare call on the interceptor chain\");\n          List<WriteCommand> modifications = localTransaction.getModifications();\n          PrepareCommand command = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), modifications, true);\n          try {\n-            invoker.running().invoke(ctx, command);\n+            return CompletionStages.handleAndCompose(invoker.running().invokeAsync(ctx, command),\n+                  (ignore, t) -> {\n+                     if (t != null) {\n+                        return handleCommitFailure(t, true, ctx);\n+                     }\n+                     return CompletableFutures.completedTrue();\n+                  });\n          } catch (Throwable e) {\n-            handleCommitFailure(e, true, ctx);\n+            return handleCommitFailure(e, true, ctx);\n          }\n-         return true;\n       } else if (!localTransaction.isReadOnly()) {\n-         commitInternal(ctx);\n+         return commitInternal(ctx);\n       }\n-      return false;\n+      return CompletableFutures.completedFalse();\n    }\n \n-   public void rollback(LocalTransaction localTransaction) throws XAException {\n+   public CompletionStage<Void> rollback(LocalTransaction localTransaction) {\n       try {", "originalCommit": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc1MTI2NA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395751264", "bodyText": "oh whoops meant to remove that. Trying to keep all the related exceptions in the CompletionStage chain.", "author": "wburns", "createdAt": "2020-03-20T16:26:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY4MjQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY4NTkxOA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395685918", "bodyText": "The exception will be wrapped in a CompletionException anyway, so I don't think we need this exceptionally call. Same for afterCompletion.", "author": "danberindei", "createdAt": "2020-03-20T14:47:32Z", "path": "core/src/main/java/org/infinispan/transaction/impl/TransactionTable.java", "diffHunk": "@@ -888,35 +892,31 @@ private void updateLastPrunedTxId(final long txId, Address address) {\n       }\n    }\n \n-   public int beforeCompletion(LocalTransaction localTransaction) {\n+   public CompletionStage<Integer> beforeCompletion(LocalTransaction localTransaction) {\n       if (trace)\n          log.tracef(\"beforeCompletion called for %s\", localTransaction);\n-      try {\n-         txCoordinator.prepare(localTransaction);\n-      } catch (XAException e) {\n-         throw new CacheException(\"Could not prepare. \", e);//todo shall we just swallow this exception?\n-      }\n-      return 0;\n+      return txCoordinator.prepare(localTransaction)\n+            .exceptionally(t -> {\n+                  throw new CacheException(\"Could not prepare. \", t);", "originalCommit": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc1MzgyNg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395753826", "bodyText": "I was trying to keep the exceptions the same as before. I wasn't sure if we unwrapped it and then checked it later.", "author": "wburns", "createdAt": "2020-03-20T16:30:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY4NTkxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc1Mzk5OQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395753999", "bodyText": "I think we can evaluate changing this later if we want to integrate this today.", "author": "wburns", "createdAt": "2020-03-20T16:30:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY4NTkxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg1MTA2NQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395851065", "bodyText": "Ok", "author": "danberindei", "createdAt": "2020-03-20T19:34:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY4NTkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY5NTI0OQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395695249", "bodyText": "Could use CompletableFutures.COMPLETED_NULL.thenComposeAsync(...) to avoid the double wrapping the result.\nMaybe it's worth adding a static method in CompletableFutures.", "author": "danberindei", "createdAt": "2020-03-20T15:00:44Z", "path": "core/src/main/java/org/infinispan/transaction/xa/TransactionXaAdapter.java", "diffHunk": "@@ -57,23 +66,23 @@ public TransactionXaAdapter(XaTransactionTable txTable) {\n     */\n    @Override\n    public int prepare(Xid externalXid) throws XAException {\n-      return txTable.prepare(externalXid);\n+      return joinAndRethrowXAException(CompletableFuture.supplyAsync(() -> txTable.prepare(externalXid), executor));", "originalCommit": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2MDYwOQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395760609", "bodyText": "Ah, good one. Yeah, I thought there was a better way. Let me fix this. We may want it in CompletionStages though.", "author": "wburns", "createdAt": "2020-03-20T16:42:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY5NTI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcwMjg5MQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395702891", "bodyText": "Nitpicking, but I would prefer wrapping before prepareStage, or even\n  return prepareStage.thenCompose(ignore -> txCoordinator.commit(localTransaction, false))\n                     .thenApply(committedInOnePhase -> {", "author": "danberindei", "createdAt": "2020-03-20T15:12:15Z", "path": "core/src/main/java/org/infinispan/transaction/xa/XaTransactionTable.java", "diffHunk": "@@ -100,32 +104,47 @@ public int getLocalTxCount() {\n       return xid2LocalTx.size();\n    }\n \n-   public int prepare(Xid externalXid) throws XAException {\n+   public CompletionStage<Integer> prepare(Xid externalXid) {\n       Xid xid = convertXid(externalXid);\n       LocalXaTransaction localTransaction = getLocalTransactionAndValidate(xid);\n+      if (localTransaction == null) {\n+         return CompletableFutures.completedExceptionFuture(new XAException(XAException.XAER_NOTA));\n+      }\n       return txCoordinator.prepare(localTransaction);\n    }\n \n-   public void commit(Xid externalXid, boolean isOnePhase) throws XAException {\n+   public CompletionStage<Void> commit(Xid externalXid, boolean isOnePhase) {\n       Xid xid = convertXid(externalXid);\n       LocalXaTransaction localTransaction = getLocalTransactionAndValidate(xid);\n-      boolean committedInOnePhase;\n+      if (localTransaction == null) {\n+         return CompletableFutures.completedExceptionFuture(new XAException(XAException.XAER_NOTA));\n+      }\n+      CompletionStage<?> prepareStage;\n       if (isOnePhase) {\n          //isOnePhase being true means that we're the only participant in the distributed transaction and TM does the\n          //1PC optimization. We run a 2PC though, as running only 1PC has a high chance of leaving the cluster in\n          //inconsistent state.\n-         txCoordinator.prepare(localTransaction);\n+         prepareStage = txCoordinator.prepare(localTransaction);\n+      } else {\n+         prepareStage = CompletableFutures.completedNull();\n       }\n-      committedInOnePhase = txCoordinator.commit(localTransaction, false);\n-      forgetSuccessfullyCompletedTransaction(recoveryManager, localTransaction.getXid(), localTransaction,\n-            committedInOnePhase);\n+      CompletionStage<Boolean> commitStage = prepareStage\n+            .thenCompose(ignore -> txCoordinator.commit(localTransaction, false));", "originalCommit": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2NTQ4Nw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395765487", "bodyText": "Changed to the suggested code.", "author": "wburns", "createdAt": "2020-03-20T16:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcwMjg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcwNjI1Mg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395706252", "bodyText": "Since we know 100% xe is not a CompletionException, I would find throw new CompletionException(xe) clearer.", "author": "danberindei", "createdAt": "2020-03-20T15:17:04Z", "path": "core/src/main/java/org/infinispan/transaction/xa/XaTransactionTable.java", "diffHunk": "@@ -153,23 +172,23 @@ void end(LocalXaTransaction localTransaction) {\n          log.tracef(\"end called on tx %s(%s)\", localTransaction.getGlobalTransaction(), cacheName);\n    }\n \n-   void forget(Xid externalXid) throws XAException {\n+   CompletionStage<Void> forget(Xid externalXid) {\n       Xid xid = convertXid(externalXid);\n       if (trace)\n          log.tracef(\"forget called for xid %s\", xid);\n-      try {\n-         if (isRecoveryEnabled()) {\n-            recoveryManager.removeRecoveryInformation(null, xid, true, null, false);\n-         } else {\n-            if (trace)\n-               log.trace(\"Recovery not enabled\");\n-         }\n-      } catch (Exception e) {\n-         log.warnExceptionRemovingRecovery(e);\n-         XAException xe = new XAException(XAException.XAER_RMERR);\n-         xe.initCause(e);\n-         throw xe;\n+      if (isRecoveryEnabled()) {\n+         return recoveryManager.removeRecoveryInformation(null, xid, null, false)\n+               .exceptionally(t -> {\n+                  log.warnExceptionRemovingRecovery(t);\n+                  XAException xe = new XAException(XAException.XAER_RMERR);\n+                  xe.initCause(t);\n+                  throw CompletableFutures.asCompletionException(xe);", "originalCommit": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2MDk3MQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395760971", "bodyText": "Okay.", "author": "wburns", "createdAt": "2020-03-20T16:42:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcwNjI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcwODEwOA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395708108", "bodyText": "The name is outdated, there's no validation, so I would suggest inlining the method.", "author": "danberindei", "createdAt": "2020-03-20T15:19:38Z", "path": "core/src/main/java/org/infinispan/transaction/xa/XaTransactionTable.java", "diffHunk": "@@ -180,20 +199,21 @@ private void forgetSuccessfullyCompletedTransaction(RecoveryManager recoveryMana\n          LocalXaTransaction localTransaction, boolean committedInOnePhase) {\n       final GlobalTransaction gtx = localTransaction.getGlobalTransaction();\n       if (isRecoveryEnabled()) {\n-         recoveryManager.removeRecoveryInformation(localTransaction.getRemoteLocksAcquired(), xid, false, gtx,\n+         // TODO: this should call a different method that doesn't receive an ack\n+         recoveryManager.removeRecoveryInformation(localTransaction.getRemoteLocksAcquired(), xid, gtx,\n                partitionHandlingManager.isTransactionPartiallyCommitted(gtx));\n          removeLocalTransaction(localTransaction);\n       } else {\n          releaseLocksForCompletedTransaction(localTransaction, committedInOnePhase);\n       }\n    }\n \n-   private LocalXaTransaction getLocalTransactionAndValidate(Xid xid) throws XAException {\n+   private LocalXaTransaction getLocalTransactionAndValidate(Xid xid) {", "originalCommit": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2MjI3Nw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395762277", "bodyText": "Sure.", "author": "wburns", "createdAt": "2020-03-20T16:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcwODEwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcxNDYyNg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395714626", "bodyText": "I think it's safe to remove the local recovery info in the caller thread and then return the stage.\nSlightly off-topic, I've been looking at RecoveryAwareTransactionTable.removeRemoteTransaction and it seems horribly inefficient. It should only iterate over the transactions when there the GlobalTransaction is not available.", "author": "danberindei", "createdAt": "2020-03-20T15:29:18Z", "path": "core/src/main/java/org/infinispan/transaction/xa/recovery/RecoveryManagerImpl.java", "diffHunk": "@@ -128,38 +130,43 @@ public RecoveryIterator getPreparedTransactionsFromCluster() {\n    }\n \n    @Override\n-   public void removeRecoveryInformation(Collection<Address> lockOwners, Xid xid, boolean sync, GlobalTransaction gtx,\n+   public CompletionStage<Void> removeRecoveryInformation(Collection<Address> lockOwners, Xid xid, GlobalTransaction gtx,\n                                          boolean fromCluster) {\n       log.tracef(\"Forgetting tx information for %s\", gtx);\n       //todo make sure this gets broad casted or at least flushed\n       if (rpcManager != null && !fromCluster) {\n          TxCompletionNotificationCommand ftc = commandFactory.buildTxCompletionNotificationCommand(xid, gtx);\n-         sendTxCompletionNotification(lockOwners, ftc, sync);\n+         return sendTxCompletionNotification(lockOwners, ftc)\n+               .thenRun(() -> removeRecoveryInformation(xid));", "originalCommit": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2NDQ1MQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395764451", "bodyText": "I can try that.", "author": "wburns", "createdAt": "2020-03-20T16:48:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcxNDYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcyNTAwNQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395725005", "bodyText": "IMO this is too abstract, it wouldn't be much longer if everything was inlined:\n      GlobalTransaction gtx = localTx.getGlobalTransaction();\n      if (commit) {\n         localTx.clearLookedUpEntries();\n         return txCoordinator.prepare(localTx, true)\n                             .thenCompose(ignore -> txCoordinator.commit(localTx, false))\n                             .thenCompose(ignore -> removeRecoveryInformation(null, xid, gtx, false))\n                             .thenApply(ignore -> \"Commit successful!\")\n                             .exceptionally(t -> {\n                                log.warnCouldNotCommitLocalTx(localTx, t);\n                                return \"Could not commit transaction \" + xid + \" : \" + t.getMessage();\n                             });\n      } else {\n         return txCoordinator.rollback(localTx)\n                             .thenCompose(ignore -> removeRecoveryInformation(null, xid, gtx, false))\n                             .thenApply(ignore -> \"Rollback successful\")\n                             .exceptionally(t -> {\n                                log.warnCouldNotRollbackLocalTx(localTx, t);\n                                return \"Could not rollback transaction \" + xid + \" : \" + t.getMessage();\n                             });\n      }", "author": "danberindei", "createdAt": "2020-03-20T15:45:29Z", "path": "core/src/main/java/org/infinispan/transaction/xa/recovery/RecoveryManagerImpl.java", "diffHunk": "@@ -305,26 +312,29 @@ public String forceTransactionCompletion(Xid xid, boolean commit) {\n       }\n    }\n \n-   private String completeTransaction(LocalTransaction localTx, boolean commit, Xid xid) {\n+   private CompletionStage<String> completeTransaction(LocalTransaction localTx, boolean commit, Xid xid) {\n+      CompletionStage<?> stage;\n+      Function<Throwable, String> errorTranslation;", "originalCommit": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2Mzk2MQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395763961", "bodyText": "Sure.", "author": "wburns", "createdAt": "2020-03-20T16:47:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcyNTAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTczMzQxNQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395733415", "bodyText": "It's so weird that it wasn't a problem before, I have to debug the test to see how it's passing on master :)", "author": "danberindei", "createdAt": "2020-03-20T15:58:10Z", "path": "core/src/test/java/org/infinispan/commands/GetAllCommandNodeCrashTest.java", "diffHunk": "@@ -41,6 +43,7 @@ public void test() throws Exception {\n       cache(2).put(key, \"value\");\n \n       ControlledRpcManager rpcManager = ControlledRpcManager.replaceRpcManager(cache(2));\n+      rpcManager.excludeCommands(StateResponseCommand.class, StateTransferStartCommand.class);", "originalCommit": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2MjkxMA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395762910", "bodyText": "Yeah, I agree. But I wasn't quite sure what was going on.", "author": "wburns", "createdAt": "2020-03-20T16:45:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTczMzQxNQ=="}], "type": "inlineReview"}, {"oid": "f1610673eb296c5cb60579b40ce1b024044ed2f4", "url": "https://github.com/infinispan/infinispan/commit/f1610673eb296c5cb60579b40ce1b024044ed2f4", "message": "rework comments", "committedDate": "2020-03-20T16:51:56Z", "type": "forcePushed"}, {"oid": "d02878704874e5aee0840e227a8a1d1d554321cd", "url": "https://github.com/infinispan/infinispan/commit/d02878704874e5aee0840e227a8a1d1d554321cd", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread", "committedDate": "2020-03-20T16:58:47Z", "type": "forcePushed"}, {"oid": "7010d9595ad27759c856085b70a23cdb08037080", "url": "https://github.com/infinispan/infinispan/commit/7010d9595ad27759c856085b70a23cdb08037080", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread", "committedDate": "2020-03-20T17:01:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNTIyNg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395825226", "bodyText": "No need for handleAndCompose", "author": "danberindei", "createdAt": "2020-03-20T18:40:04Z", "path": "core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java", "diffHunk": "@@ -99,92 +107,116 @@ public PrepareCommand createPrepareCommand(GlobalTransaction gtx, List<WriteComm\n       }\n    }\n \n-   public final int prepare(LocalTransaction localTransaction) throws XAException {\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction) {\n       return prepare(localTransaction, false);\n    }\n \n-   public final int prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) throws XAException {\n-      validateNotMarkedForRollback(localTransaction);\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) {\n+      CompletionStage<Integer> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+      if (markRollbackStage != null) {\n+         return markRollbackStage;\n+      }\n \n       if (isOnePhaseCommit(localTransaction)) {\n          if (trace) log.tracef(\"Received prepare for tx: %s. Skipping call as 1PC will be used.\", localTransaction);\n-         return XA_OK;\n+         return XA_OKAY_STAGE;\n       }\n \n       PrepareCommand prepareCommand = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), localTransaction.getModifications(), false);\n       if (trace) log.tracef(\"Sending prepare command through the chain: %s\", prepareCommand);\n \n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       prepareCommand.setReplayEntryWrapping(replayEntryWrapping);\n-      try {\n-         invoker.running().invoke(ctx, prepareCommand);\n+      CompletionStage<Object> prepareStage = invoker.running().invokeAsync(ctx, prepareCommand);\n+      return CompletionStages.handleAndCompose(prepareStage, (ignore, prepareThrowable) -> {\n+         if (prepareThrowable != null) {\n+            if (shuttingDown)\n+               log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n+            else\n+               log.errorProcessingPrepare(prepareThrowable);\n+\n+            //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n+            //after prepare failed.\n+            return CompletionStages.handleAndCompose(rollback(localTransaction), (ignore2, rollbackThrowable) -> {", "originalCommit": "7010d9595ad27759c856085b70a23cdb08037080", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzNTIyOQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395835229", "bodyText": "Not sure, why. We need to handle the case when it was not an error to wrap it with an XAException still. And we want to still catch the rollback exception to supress or rethrow that.", "author": "wburns", "createdAt": "2020-03-20T18:59:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNTIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg0MjIyMQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395842221", "bodyText": "Yes, but none of those need to return a CompletionStage, so you can use handle instead of handleAndCompose.", "author": "danberindei", "createdAt": "2020-03-20T19:14:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNTIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg0NTM3MA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395845370", "bodyText": "I was trying to keep all the exceptions as bare XAException. If I do the other I would have to use CompletionException wrapping XAException and all callers would have to pay attention to that including TransactionXAAdapter, but I can do that.", "author": "wburns", "createdAt": "2020-03-20T19:22:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNTIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg0ODMzMQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395848331", "bodyText": "Actually I don't feel comfortable changing this right now. I can revisit later if we need.", "author": "wburns", "createdAt": "2020-03-20T19:28:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNTIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg1MDQzOQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395850439", "bodyText": "I was trying to keep all the exceptions as bare XAException. If I do the other I would have to use CompletionException wrapping XAException and all callers would have to pay attention to that including TransactionXAAdapter, but I can do that.\n\nNot sure what you mean. When you do CompletableFuture.join() it will wrap the exception in a CompletionStage anyway, so you have to be prepared to extract the exception with CompletableFutures.extractException.\nBut I'm ok with revisiting this later.", "author": "danberindei", "createdAt": "2020-03-20T19:33:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNTIyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNTU5NQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395825595", "bodyText": "No need for try..catch", "author": "danberindei", "createdAt": "2020-03-20T18:40:46Z", "path": "core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java", "diffHunk": "@@ -99,92 +107,116 @@ public PrepareCommand createPrepareCommand(GlobalTransaction gtx, List<WriteComm\n       }\n    }\n \n-   public final int prepare(LocalTransaction localTransaction) throws XAException {\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction) {\n       return prepare(localTransaction, false);\n    }\n \n-   public final int prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) throws XAException {\n-      validateNotMarkedForRollback(localTransaction);\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) {\n+      CompletionStage<Integer> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+      if (markRollbackStage != null) {\n+         return markRollbackStage;\n+      }\n \n       if (isOnePhaseCommit(localTransaction)) {\n          if (trace) log.tracef(\"Received prepare for tx: %s. Skipping call as 1PC will be used.\", localTransaction);\n-         return XA_OK;\n+         return XA_OKAY_STAGE;\n       }\n \n       PrepareCommand prepareCommand = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), localTransaction.getModifications(), false);\n       if (trace) log.tracef(\"Sending prepare command through the chain: %s\", prepareCommand);\n \n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       prepareCommand.setReplayEntryWrapping(replayEntryWrapping);\n-      try {\n-         invoker.running().invoke(ctx, prepareCommand);\n+      CompletionStage<Object> prepareStage = invoker.running().invokeAsync(ctx, prepareCommand);\n+      return CompletionStages.handleAndCompose(prepareStage, (ignore, prepareThrowable) -> {\n+         if (prepareThrowable != null) {\n+            if (shuttingDown)\n+               log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n+            else\n+               log.errorProcessingPrepare(prepareThrowable);\n+\n+            //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n+            //after prepare failed.\n+            return CompletionStages.handleAndCompose(rollback(localTransaction), (ignore2, rollbackThrowable) -> {\n+               // XA_RBROLLBACK tells the TM that we've rolled back already: the TM shouldn't call rollback after this.\n+               XAException xe = new XAException(XAException.XA_RBROLLBACK);\n+               if (rollbackThrowable != null) {\n+                  rollbackThrowable.addSuppressed(prepareThrowable);\n+                  xe.initCause(rollbackThrowable);\n+               } else {\n+                  xe.initCause(prepareThrowable);\n+               }\n+               return CompletableFutures.completedExceptionFuture(xe);\n+            });\n+         }\n          if (localTransaction.isReadOnly()) {\n             if (trace) log.tracef(\"Readonly transaction: %s\", localTransaction.getGlobalTransaction());\n             // force a cleanup to release any objects held.  Some TMs don't call commit if it is a READ ONLY tx.  See ISPN-845\n-            commitInternal(ctx);\n-            return XA_RDONLY;\n+            return commitInternal(ctx)\n+                  .thenApply(XA_RDONLY_APPLY);\n          } else {\n             txTable.running().localTransactionPrepared(localTransaction);\n-            return XA_OK;\n+            return XA_OKAY_STAGE;\n          }\n-      } catch (Throwable e) {\n-         if (shuttingDown)\n-            log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n-         else\n-            log.errorProcessingPrepare(e);\n-\n-         //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n-         //after prepare failed.\n-         rollback(localTransaction);\n-         // XA_RBROLLBACK tells the TM that we've rolled back already: the TM shouldn't call rollback after this.\n-         XAException xe = new XAException(XAException.XA_RBROLLBACK);\n-         xe.initCause(e);\n-         throw xe;\n-      }\n+      });\n    }\n \n-   public boolean commit(LocalTransaction localTransaction, boolean isOnePhase) throws XAException {\n+   public CompletionStage<Boolean> commit(LocalTransaction localTransaction, boolean isOnePhase) {\n       if (trace) log.tracef(\"Committing transaction %s\", localTransaction.getGlobalTransaction());\n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       if (isOnePhaseCommit(localTransaction) || isOnePhase) {\n-         validateNotMarkedForRollback(localTransaction);\n+         CompletionStage<Boolean> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+         if (markRollbackStage != null) {\n+            return markRollbackStage;\n+         }\n \n          if (trace) log.trace(\"Doing an 1PC prepare call on the interceptor chain\");\n          List<WriteCommand> modifications = localTransaction.getModifications();\n          PrepareCommand command = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), modifications, true);\n          try {\n-            invoker.running().invoke(ctx, command);\n+            return CompletionStages.handleAndCompose(invoker.running().invokeAsync(ctx, command),\n+                  (ignore, t) -> {\n+                     if (t != null) {\n+                        return handleCommitFailure(t, true, ctx);\n+                     }\n+                     return CompletableFutures.completedTrue();\n+                  });\n          } catch (Throwable e) {\n-            handleCommitFailure(e, true, ctx);\n+            return handleCommitFailure(e, true, ctx);", "originalCommit": "7010d9595ad27759c856085b70a23cdb08037080", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzNTQ0MQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395835441", "bodyText": "+1, yeah I didn't go back and double check I removed all of them.", "author": "wburns", "createdAt": "2020-03-20T19:00:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNTU5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzMTkzMg==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395831932", "bodyText": "Could have moved more common code here, e.g.\n  return CompletionStages.join(CompletableFutures.completedNull()\n        .thenComposeAsync(consumer, executor));", "author": "danberindei", "createdAt": "2020-03-20T18:53:29Z", "path": "core/src/main/java/org/infinispan/transaction/xa/TransactionXaAdapter.java", "diffHunk": "@@ -177,4 +191,16 @@ public boolean equals(Object o) {\n    private boolean isFlag(int value, int flag) {\n       return (value & flag) != 0;\n    }\n+\n+   private <T> T joinAndRethrowXAException(CompletionStage<T> stage) throws XAException {\n+      try {\n+         return CompletionStages.join(stage);", "originalCommit": "7010d9595ad27759c856085b70a23cdb08037080", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzNTc0MQ==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395835741", "bodyText": "Sure.", "author": "wburns", "createdAt": "2020-03-20T19:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzMTkzMg=="}], "type": "inlineReview"}, {"oid": "3173ad9f37dea0b47869ebe53bfb4a52ad870b61", "url": "https://github.com/infinispan/infinispan/commit/3173ad9f37dea0b47869ebe53bfb4a52ad870b61", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread", "committedDate": "2020-03-20T19:09:21Z", "type": "forcePushed"}, {"oid": "514d861666a6c3e1d7f874a41c3abb8b6c1b38e8", "url": "https://github.com/infinispan/infinispan/commit/514d861666a6c3e1d7f874a41c3abb8b6c1b38e8", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread", "committedDate": "2020-03-20T19:11:06Z", "type": "forcePushed"}, {"oid": "6030cc125086a6b25768497a0e33d56fa849c4fe", "url": "https://github.com/infinispan/infinispan/commit/6030cc125086a6b25768497a0e33d56fa849c4fe", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread", "committedDate": "2020-03-20T19:12:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg0NTU4OA==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395845588", "bodyText": "Don't need to wait for the tx completion responses before removing the local info here either, although since removing the local info is expensive you could still send the command first.", "author": "danberindei", "createdAt": "2020-03-20T19:22:31Z", "path": "core/src/main/java/org/infinispan/transaction/xa/recovery/RecoveryManagerImpl.java", "diffHunk": "@@ -128,38 +129,43 @@ public RecoveryIterator getPreparedTransactionsFromCluster() {\n    }\n \n    @Override\n-   public void removeRecoveryInformation(Collection<Address> lockOwners, Xid xid, boolean sync, GlobalTransaction gtx,\n+   public CompletionStage<Void> removeRecoveryInformation(Collection<Address> lockOwners, Xid xid, GlobalTransaction gtx,\n                                          boolean fromCluster) {\n       log.tracef(\"Forgetting tx information for %s\", gtx);\n       //todo make sure this gets broad casted or at least flushed\n       if (rpcManager != null && !fromCluster) {\n          TxCompletionNotificationCommand ftc = commandFactory.buildTxCompletionNotificationCommand(xid, gtx);\n-         sendTxCompletionNotification(lockOwners, ftc, sync);\n+         removeRecoveryInformation(xid);\n+         return sendTxCompletionNotification(lockOwners, ftc);\n+      } else {\n+         removeRecoveryInformation(xid);\n+         return CompletableFutures.completedNull();\n       }\n-      removeRecoveryInformation(xid);\n    }\n \n    @Override\n-   public void removeRecoveryInformationFromCluster(Collection<Address> where, long internalId, boolean sync) {\n+   public CompletionStage<Void> removeRecoveryInformationFromCluster(Collection<Address> where, long internalId) {\n       if (rpcManager != null) {\n          TxCompletionNotificationCommand ftc = commandFactory.buildTxCompletionNotificationCommand(internalId);\n-         sendTxCompletionNotification(where, ftc, sync);\n+         CompletionStage<Void> stage = sendTxCompletionNotification(where, ftc);\n+         return stage.thenRun(() -> removeRecoveryInformation(internalId));", "originalCommit": "6030cc125086a6b25768497a0e33d56fa849c4fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg0Nzc4Nw==", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395847787", "bodyText": "Okay.", "author": "wburns", "createdAt": "2020-03-20T19:27:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg0NTU4OA=="}], "type": "inlineReview"}, {"oid": "553b36dca7563b374d719d761567263767d83f4b", "url": "https://github.com/infinispan/infinispan/commit/553b36dca7563b374d719d761567263767d83f4b", "message": "ISPN-11489 TransactionCoordinator updated for non blocking", "committedDate": "2020-03-20T20:54:58Z", "type": "commit"}, {"oid": "b352ff46b2be9073a02be60700a174287da92915", "url": "https://github.com/infinispan/infinispan/commit/b352ff46b2be9073a02be60700a174287da92915", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places", "committedDate": "2020-03-20T20:54:58Z", "type": "commit"}, {"oid": "0caa5b70c4753a36e746f2d70097f26e762a0fb6", "url": "https://github.com/infinispan/infinispan/commit/0caa5b70c4753a36e746f2d70097f26e762a0fb6", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread", "committedDate": "2020-03-20T20:54:59Z", "type": "commit"}, {"oid": "0caa5b70c4753a36e746f2d70097f26e762a0fb6", "url": "https://github.com/infinispan/infinispan/commit/0caa5b70c4753a36e746f2d70097f26e762a0fb6", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread", "committedDate": "2020-03-20T20:54:59Z", "type": "forcePushed"}]}