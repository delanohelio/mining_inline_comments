{"pr_number": 8400, "pr_title": "ISPN-10373 Store/Loader Non blocking SPI batch method", "pr_createdAt": "2020-05-27T17:24:41Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8400", "timeline": [{"oid": "ba4e1bc6a9b0f2541bcdd8fbc665449c4b6571d9", "url": "https://github.com/infinispan/infinispan/commit/ba4e1bc6a9b0f2541bcdd8fbc665449c4b6571d9", "message": "ISPN-10373 Store/Loader Non blocking SPI\n\n* Rework batch to allow for atomic write and remove", "committedDate": "2020-05-27T18:22:31Z", "type": "forcePushed"}, {"oid": "f920e997951c4a8a777a9b1e06adf722d7176f6d", "url": "https://github.com/infinispan/infinispan/commit/f920e997951c4a8a777a9b1e06adf722d7176f6d", "message": "ISPN-10373 Store/Loader Non blocking SPI\n\n* Rework batch to allow for atomic write and remove", "committedDate": "2020-05-29T13:27:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUwNjcwNA==", "url": "https://github.com/infinispan/infinispan/pull/8400#discussion_r432506704", "bodyText": "Shouldn't this be storeStatus.store.rollback?\nIt's worrying that this wasn't detected by our testsuite \ud83d\ude31", "author": "ryanemerson", "createdAt": "2020-05-29T14:08:30Z", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -885,55 +897,47 @@ private boolean shouldWrite(StoreStatus storeStatus, Predicate<? super StoreConf\n    }\n \n    @Override\n-   public CompletionStage<Void> prepareAllTxStores(Transaction transaction, BatchModification batchModification,\n+   public CompletionStage<Void> prepareAllTxStores(TxInvocationContext<AbstractCacheTransaction> txInvocationContext,\n          Predicate<? super StoreConfiguration> predicate) throws PersistenceException {\n-      return Completable.using(\n-            this::acquireReadLock,\n-            ignore -> {\n-               checkStoreAvailability();\n-               if (trace) {\n-                  log.tracef(\"Preparing batch for store: %s on transaction %s\", batchModification, transaction);\n-               }\n-               return Flowable.fromIterable(stores)\n-                     .filter(storeStatus -> shouldPerformTransactionOperation(storeStatus, predicate))\n-                     // Let the prepare work in parallel across the stores\n-                     .flatMapCompletable(storeStatus -> Completable.fromCompletionStage(storeStatus.store.prepareWithModifications(transaction, batchModification)));\n-            },\n-            this::releaseReadLock\n-      ).toCompletionStage(null);\n+      //noinspection unchecked\n+      return batchOperation(txInvocationContext, null, (stores, segmentCount, removeFlowable,\n+            putFlowable) -> stores.prepareWithModifications(txInvocationContext.getTransaction(), segmentCount, removeFlowable, putFlowable))\n+            .thenApply(CompletableFutures.toNullFunction());\n    }\n \n    @Override\n-   public CompletionStage<Void> commitAllTxStores(Transaction transaction, Predicate<? super StoreConfiguration> predicate) {\n+   public CompletionStage<Void> commitAllTxStores(TxInvocationContext<AbstractCacheTransaction> txInvocationContext,\n+         Predicate<? super StoreConfiguration> predicate) {\n       return Completable.using(\n             this::acquireReadLock,\n             ignore -> {\n                checkStoreAvailability();\n                if (trace) {\n-                  log.tracef(\"Committing transaction %s to stores\", transaction);\n+                  log.tracef(\"Committing transaction %s to stores\", txInvocationContext);\n                }\n                return Flowable.fromIterable(stores)\n                      .filter(storeStatus -> shouldPerformTransactionOperation(storeStatus, predicate))\n                      // Let the commit work in parallel across the stores\n-                     .flatMapCompletable(storeStatus -> Completable.fromCompletionStage(storeStatus.store.commit(transaction)));\n+                     .flatMapCompletable(storeStatus -> Completable.fromCompletionStage(storeStatus.store.commit(txInvocationContext.getTransaction())));\n             },\n             this::releaseReadLock\n       ).toCompletionStage(null);\n    }\n \n    @Override\n-   public CompletionStage<Void> rollbackAllTxStores(Transaction transaction, Predicate<? super StoreConfiguration> predicate) {\n+   public CompletionStage<Void> rollbackAllTxStores(TxInvocationContext<AbstractCacheTransaction> txInvocationContext,\n+         Predicate<? super StoreConfiguration> predicate) {\n       return Completable.using(\n             this::acquireReadLock,\n             ignore -> {\n                checkStoreAvailability();\n                if (trace) {\n-                  log.tracef(\"Rolling back transaction %s for stores\", transaction);\n+                  log.tracef(\"Rolling back transaction %s for stores\", txInvocationContext);\n                }\n                return Flowable.fromIterable(stores)\n                      .filter(storeStatus -> shouldPerformTransactionOperation(storeStatus, predicate))\n                      // Let the rollback work in parallel across the stores\n-                     .flatMapCompletable(storeStatus -> Completable.fromCompletionStage(storeStatus.store.commit(transaction)));\n+                     .flatMapCompletable(storeStatus -> Completable.fromCompletionStage(storeStatus.store.commit(txInvocationContext.getTransaction())));", "originalCommit": "f920e997951c4a8a777a9b1e06adf722d7176f6d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUxMTY5Mw==", "url": "https://github.com/infinispan/infinispan/pull/8400#discussion_r432511693", "bodyText": ":( My guess it the JDBC store just doesn't have great coverage around this case. I can fix this and I will log a JIRA to create a test case for JDBC store.", "author": "wburns", "createdAt": "2020-05-29T14:15:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUwNjcwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUxNTAyOQ==", "url": "https://github.com/infinispan/infinispan/pull/8400#discussion_r432515029", "bodyText": "Fixed the typo", "author": "wburns", "createdAt": "2020-05-29T14:19:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUwNjcwNA=="}], "type": "inlineReview"}, {"oid": "dfd39f54b5ec0076c694b151941b8699545e8d19", "url": "https://github.com/infinispan/infinispan/commit/dfd39f54b5ec0076c694b151941b8699545e8d19", "message": "ISPN-10373 Store/Loader Non blocking SPI\n\n* Rework batch to allow for atomic write and remove", "committedDate": "2020-05-29T14:19:05Z", "type": "commit"}, {"oid": "dfd39f54b5ec0076c694b151941b8699545e8d19", "url": "https://github.com/infinispan/infinispan/commit/dfd39f54b5ec0076c694b151941b8699545e8d19", "message": "ISPN-10373 Store/Loader Non blocking SPI\n\n* Rework batch to allow for atomic write and remove", "committedDate": "2020-05-29T14:19:05Z", "type": "forcePushed"}]}