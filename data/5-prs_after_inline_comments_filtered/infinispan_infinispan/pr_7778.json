{"pr_number": 7778, "pr_title": "ISPN-10898 Add Blockound to test suite to make sure cpu threads are n\u2026", "pr_createdAt": "2020-01-22T23:35:12Z", "pr_url": "https://github.com/infinispan/infinispan/pull/7778", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2NTY5Mg==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r369865692", "bodyText": "This shouldn't be true anymore afaik.", "author": "wburns", "createdAt": "2020-01-22T23:41:23Z", "path": "core/src/test/java/org/infinispan/test/AbstractInfinispanTest.java", "diffHunk": "@@ -72,6 +92,66 @@\n @TestSelector(interceptors = AbstractInfinispanTest.OrderByInstance.class)\n public abstract class AbstractInfinispanTest {\n \n+   static {\n+      BlockHound.builder().with(new RxJava2Integration()).with(builder -> {\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+         builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+         builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+         builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\n+\n+         builder.nonBlockingThreadPredicate(current -> current.or(thread -> thread instanceof NonBlockingThread));\n+         // SecureRandom reads from a socket\n+         builder.allowBlockingCallsInside(SecureRandom.class.getName(), \"nextBytes\");\n+         // UDP calls PlainDatagramSocketImpl#send which can block if OS buffer is full - but we just ignore\n+         builder.allowBlockingCallsInside(UDP.class.getName(), \"_send\");\n+         builder.allowBlockingCallsInside(FlowControl.class.getName(), \"adjustCredit\");\n+         // Random JGroups stuff\n+         builder.allowBlockingCallsInside(Table.class.getName(), \"add\");\n+         // Just assume all the thread pools don't block - not we check the rejected handler below though\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"getTask\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"processWorkerExit\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(ScheduledThreadPoolExecutor.class.getName(), \"schedule\");\n+\n+         // TODO: This can actually block us for a bit, we should really remove this!!!", "originalCommit": "1ef7d1dfde0062155be78112707b70b73a574a9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzUwMDA4NQ==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r373500085", "bodyText": "I need to update the comment, this was fixed in df4e357#diff-9d071c3a5e71e018abe6e735ec5a62fb. The problem prior was that the exclusive lock was held while purging store segments. This has been since fixed, so this method shouldn't block at all really.", "author": "wburns", "createdAt": "2020-01-31T14:16:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2NTY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2NjEzOA==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r369866138", "bodyText": "Maybe we should remove this or convert it to a different Assertion or something.", "author": "wburns", "createdAt": "2020-01-22T23:43:02Z", "path": "core/src/test/java/org/infinispan/test/AbstractInfinispanTest.java", "diffHunk": "@@ -72,6 +92,66 @@\n @TestSelector(interceptors = AbstractInfinispanTest.OrderByInstance.class)\n public abstract class AbstractInfinispanTest {\n \n+   static {\n+      BlockHound.builder().with(new RxJava2Integration()).with(builder -> {\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+         builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+         builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+         builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\n+\n+         builder.nonBlockingThreadPredicate(current -> current.or(thread -> thread instanceof NonBlockingThread));\n+         // SecureRandom reads from a socket\n+         builder.allowBlockingCallsInside(SecureRandom.class.getName(), \"nextBytes\");\n+         // UDP calls PlainDatagramSocketImpl#send which can block if OS buffer is full - but we just ignore\n+         builder.allowBlockingCallsInside(UDP.class.getName(), \"_send\");\n+         builder.allowBlockingCallsInside(FlowControl.class.getName(), \"adjustCredit\");\n+         // Random JGroups stuff\n+         builder.allowBlockingCallsInside(Table.class.getName(), \"add\");\n+         // Just assume all the thread pools don't block - not we check the rejected handler below though\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"getTask\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"processWorkerExit\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(ScheduledThreadPoolExecutor.class.getName(), \"schedule\");\n+\n+         // TODO: This can actually block us for a bit, we should really remove this!!!\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"acquireSharedTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"releaseSharedTopologyLock\");\n+\n+         // LimitedExecutor just submits a task to another thread pool\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"execute\");\n+\n+         // Some test utilities may block the cpu thread - which is fine\n+         builder.allowBlockingCallsInside(EvictionWithConcurrentOperationsTest.class.getName() + \"$Latch\", \"blockIfNeeded\");\n+         builder.allowBlockingCallsInside(CheckPoint.class.getName(), \"await\");\n+         builder.allowBlockingCallsInside(CheckPoint.class.getName(), \"trigger\");\n+         builder.allowBlockingCallsInside(BlockingInterceptor.class.getName(), \"blockIfNeeded\");\n+         builder.allowBlockingCallsInside(TestingUtil.class.getName(), \"sleepRandom\");\n+         builder.allowBlockingCallsInside(TestingUtil.class.getName(), \"sleepThread\");\n+\n+         // The blocking iterator locks to signal at the end - ignore\n+         builder.allowBlockingCallsInside(BlockingFlowableIterable.class.getName() + \"$BlockingFlowableIterator\", \"signalConsumer\");\n+\n+         // Allow logging to block\n+         builder.allowBlockingCallsInside(Logger.class.getName(), \"logf\");\n+         builder.allowBlockingCallsInside(java.util.logging.Logger.class.getName(), \"log\");\n+\n+         // Make sure our rejection handlers never block in a non blocking thread\n+         builder.disallowBlockingCallsInside(BlockingRejectedExecutionHandler.class.getName(), \"rejectedExecution\");\n+         builder.disallowBlockingCallsInside(NonBlockingRejectedExecutionHandler.class.getName(), \"rejectedExecution\");\n+\n+         builder.blockingMethodCallback(bm -> {\n+            throw new CacheException(String.format(\"Blocking call! %s on thread %s\", bm, Thread.currentThread()));", "originalCommit": "1ef7d1dfde0062155be78112707b70b73a574a9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzUxOTg3NA==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r373519874", "bodyText": "Will leave this for now.", "author": "wburns", "createdAt": "2020-01-31T14:54:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2NjEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA4NjM5MA==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r375086390", "bodyText": "AssertionError would be good, but I'd also report it as a failure directly in case the test expects an exception and doesn't bother to check the exception type.\nSomething like: \n  \n    \n      infinispan/commons-test/src/main/java/org/infinispan/commons/test/RunningTestsRegistry.java\n    \n    \n         Line 72\n      in\n      5bf7675\n    \n    \n    \n    \n\n        \n          \n           private static void writeJUnitReport(String testName, RuntimeException exception) {", "author": "danberindei", "createdAt": "2020-02-05T07:00:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2NjEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM1Njc1Ng==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r375356756", "bodyText": "Sure, let me look into this. It would be good because then I can explicitly say the method and test, where as currently it just shows in some tests as a timeout :(", "author": "wburns", "createdAt": "2020-02-05T16:16:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2NjEzOA=="}], "type": "inlineReview"}, {"oid": "76da66c8c00b0b838e04b90190ebe492b41fcb64", "url": "https://github.com/infinispan/infinispan/commit/76da66c8c00b0b838e04b90190ebe492b41fcb64", "message": "fix leak in block hound test", "committedDate": "2020-01-23T19:53:38Z", "type": "forcePushed"}, {"oid": "30a316010185a17a6f7b9ad9d8be53d8cb1262a0", "url": "https://github.com/infinispan/infinispan/commit/30a316010185a17a6f7b9ad9d8be53d8cb1262a0", "message": "ISPN-10898 Add Blockound to test suite to make sure cpu threads are never blocked", "committedDate": "2020-01-27T20:48:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ5NTg2NQ==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r373495865", "bodyText": "I don't want to nitpick, but should this be a separate JIRA for exposure?", "author": "ryanemerson", "createdAt": "2020-01-31T14:08:04Z", "path": "core/src/main/java/org/infinispan/globalstate/impl/GlobalConfigurationManagerImpl.java", "diffHunk": "@@ -54,8 +54,8 @@\n    @Inject ConfigurationManager configurationManager;\n    @Inject InternalCacheRegistry internalCacheRegistry;\n    @Inject GlobalComponentRegistry globalComponentRegistry;\n-   @Inject @ComponentName(KnownComponentNames.ASYNC_OPERATIONS_EXECUTOR)\n-   ExecutorService executorService;\n+   @Inject @ComponentName(KnownComponentNames.PERSISTENCE_EXECUTOR)\n+   ExecutorService blockingExecutor;", "originalCommit": "30a316010185a17a6f7b9ad9d8be53d8cb1262a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ5NzkwMw==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r373497903", "bodyText": "I can make a separate commit with it.", "author": "wburns", "createdAt": "2020-01-31T14:12:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ5NTg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzUyMjAyNA==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r373522024", "bodyText": "Unfortunately there is no great way to catch these types of errors. We have places where we ignore the error from a CompletionStage or Future. So this is attempting to print out those messages.", "author": "wburns", "createdAt": "2020-01-31T14:58:29Z", "path": "core/src/test/java/org/infinispan/test/AbstractInfinispanTest.java", "diffHunk": "@@ -72,6 +92,66 @@\n @TestSelector(interceptors = AbstractInfinispanTest.OrderByInstance.class)\n public abstract class AbstractInfinispanTest {\n \n+   static {\n+      BlockHound.builder().with(new RxJava2Integration()).with(builder -> {\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+         builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+         builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+         builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\n+\n+         builder.nonBlockingThreadPredicate(current -> current.or(thread -> thread instanceof NonBlockingThread));\n+         // SecureRandom reads from a socket\n+         builder.allowBlockingCallsInside(SecureRandom.class.getName(), \"nextBytes\");\n+         // UDP calls PlainDatagramSocketImpl#send which can block if OS buffer is full - but we just ignore\n+         builder.allowBlockingCallsInside(UDP.class.getName(), \"_send\");\n+         builder.allowBlockingCallsInside(FlowControl.class.getName(), \"adjustCredit\");\n+         // Random JGroups stuff\n+         builder.allowBlockingCallsInside(Table.class.getName(), \"add\");\n+         // Just assume all the thread pools don't block - not we check the rejected handler below though\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"getTask\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"processWorkerExit\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(ScheduledThreadPoolExecutor.class.getName(), \"schedule\");\n+\n+         // TODO: This can actually block us for a bit, we should really remove this!!!\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"acquireSharedTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"releaseSharedTopologyLock\");\n+\n+         // LimitedExecutor just submits a task to another thread pool\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"execute\");\n+\n+         // Some test utilities may block the cpu thread - which is fine\n+         builder.allowBlockingCallsInside(EvictionWithConcurrentOperationsTest.class.getName() + \"$Latch\", \"blockIfNeeded\");\n+         builder.allowBlockingCallsInside(CheckPoint.class.getName(), \"await\");\n+         builder.allowBlockingCallsInside(CheckPoint.class.getName(), \"trigger\");\n+         builder.allowBlockingCallsInside(BlockingInterceptor.class.getName(), \"blockIfNeeded\");\n+         builder.allowBlockingCallsInside(TestingUtil.class.getName(), \"sleepRandom\");\n+         builder.allowBlockingCallsInside(TestingUtil.class.getName(), \"sleepThread\");\n+\n+         // The blocking iterator locks to signal at the end - ignore\n+         builder.allowBlockingCallsInside(BlockingFlowableIterable.class.getName() + \"$BlockingFlowableIterator\", \"signalConsumer\");\n+\n+         // Allow logging to block\n+         builder.allowBlockingCallsInside(Logger.class.getName(), \"logf\");\n+         builder.allowBlockingCallsInside(java.util.logging.Logger.class.getName(), \"log\");\n+\n+         // Make sure our rejection handlers never block in a non blocking thread\n+         builder.disallowBlockingCallsInside(BlockingRejectedExecutionHandler.class.getName(), \"rejectedExecution\");\n+         builder.disallowBlockingCallsInside(NonBlockingRejectedExecutionHandler.class.getName(), \"rejectedExecution\");\n+\n+         builder.blockingMethodCallback(bm -> {\n+            throw new CacheException(String.format(\"Blocking call! %s on thread %s\", bm, Thread.currentThread()));\n+         });\n+      }).install();\n+\n+      Thread.setDefaultUncaughtExceptionHandler((thread, t) -> {\n+         t.printStackTrace();", "originalCommit": "30a316010185a17a6f7b9ad9d8be53d8cb1262a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA4NzIzMg==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r375087232", "bodyText": "I don't think we check the console output manually that often, so I'd suggest crafting a JUnit report here too.\nAlso it's enough to just log the exception with FATAL level, (part of) the stack trace will be printed on the console.", "author": "danberindei", "createdAt": "2020-02-05T07:03:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzUyMjAyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM1ODY3OA==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r375358678", "bodyText": "Yeah, I was just being overly cautious :)\nI will definitely look at the report.", "author": "wburns", "createdAt": "2020-02-05T16:19:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzUyMjAyNA=="}], "type": "inlineReview"}, {"oid": "b8385c288794f3d78fba04f52a6592d96c191518", "url": "https://github.com/infinispan/infinispan/commit/b8385c288794f3d78fba04f52a6592d96c191518", "message": "ISPN-11261 GlobalConfigurationManager should use blocking threads when starting caches", "committedDate": "2020-01-31T14:58:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA4NTI0Mw==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r375085243", "bodyText": "If you don't mind, please add a reference to https://issues.redhat.com/browse/ISPN-11279", "author": "danberindei", "createdAt": "2020-02-05T06:56:04Z", "path": "core/src/test/java/org/infinispan/test/AbstractInfinispanTest.java", "diffHunk": "@@ -72,6 +92,67 @@\n @TestSelector(interceptors = AbstractInfinispanTest.OrderByInstance.class)\n public abstract class AbstractInfinispanTest {\n \n+   static {\n+      BlockHound.builder().with(new RxJava2Integration()).with(builder -> {\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+         builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+         builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+         builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\n+\n+         builder.nonBlockingThreadPredicate(current -> current.or(thread -> thread instanceof NonBlockingThread));\n+         // SecureRandom reads from a socket\n+         builder.allowBlockingCallsInside(SecureRandom.class.getName(), \"nextBytes\");", "originalCommit": "b8385c288794f3d78fba04f52a6592d96c191518", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM1NjA1OQ==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r375356059", "bodyText": "I believe this actually came from JGroups not Infinispan, so unfortunately it won't completely solve it.", "author": "wburns", "createdAt": "2020-02-05T16:14:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA4NTI0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwNTc1NA==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r376305754", "bodyText": "Aha, ok", "author": "danberindei", "createdAt": "2020-02-07T09:57:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA4NTI0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA4ODgyMw==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r375088823", "bodyText": "One downside to putting this in AbstractInfinispanTest is that it can only be used in modules using TestNG.\nI guess you only care about core tests at this stage, but it's something to consider.", "author": "danberindei", "createdAt": "2020-02-05T07:09:34Z", "path": "core/src/test/java/org/infinispan/test/AbstractInfinispanTest.java", "diffHunk": "@@ -72,6 +92,67 @@\n @TestSelector(interceptors = AbstractInfinispanTest.OrderByInstance.class)\n public abstract class AbstractInfinispanTest {\n \n+   static {", "originalCommit": "b8385c288794f3d78fba04f52a6592d96c191518", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM1NTQxNA==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r375355414", "bodyText": "Yeah, I agree - I was going to move this elsewhere at some point. Wasn't quite sure yet though, so I just left it here to at least test core.", "author": "wburns", "createdAt": "2020-02-05T16:13:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA4ODgyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwNTU3OQ==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r376305579", "bodyText": "IMO it should be a separate class that AbstractInfinispanTest invokes in a static initializer, no point in putting all this code in AbstractInfinispanTest now just to move it later.\nA good place to call it might be \n  \n    \n      infinispan/commons-test/src/main/java/org/infinispan/commons/test/TestNGTestListener.java\n    \n    \n         Line 88\n      in\n      d2e95cb\n    \n    \n    \n    \n\n        \n          \n           public void onStart(ISuite suite) { \n        \n    \n  \n\n\nIt wouldn't run by default when running the tests in an IDE, but at least in IntelliJ it's very easy to add a listener once in the default TestNG run configuration, and it will run every time you run/debug a test.", "author": "danberindei", "createdAt": "2020-02-07T09:57:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA4ODgyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQwNDc4Mw==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r376404783", "bodyText": "Sure, I can try that out \ud83d\udc4d", "author": "wburns", "createdAt": "2020-02-07T14:02:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA4ODgyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ2NjM4OA==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r378466388", "bodyText": "The only problem about it being in this class is we can't reference the classes in other modules (unless I did something like a ServiceLoader to find things to register based on what modules are in the class path).", "author": "wburns", "createdAt": "2020-02-12T19:31:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA4ODgyMw=="}], "type": "inlineReview"}, {"oid": "fbe7300b2631520a166acbb51a4eb79abf60b491", "url": "https://github.com/infinispan/infinispan/commit/fbe7300b2631520a166acbb51a4eb79abf60b491", "message": "additional", "committedDate": "2020-02-05T23:15:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM3MDgyNg==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r376370826", "bodyText": "Couldn't you reference org.jgroups.Version here instead, so it's loaded before Blockhound is installed?", "author": "danberindei", "createdAt": "2020-02-07T12:42:11Z", "path": "core/src/test/java/org/infinispan/test/AbstractInfinispanTest.java", "diffHunk": "@@ -72,6 +113,191 @@\n @TestSelector(interceptors = AbstractInfinispanTest.OrderByInstance.class)\n public abstract class AbstractInfinispanTest {\n \n+   static {\n+      BlockHound.builder().with(new RxJava2Integration()).with(builder -> {\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+         builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+         builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+         builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\n+\n+         // Prevent people from calling into distributed streams\n+         builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"stream\", \"()Lorg/infinispan/CacheStream;\");\n+         builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"parallelStream\", \"()Lorg/infinispan/CacheStream;\");\n+\n+         builder.nonBlockingThreadPredicate(current -> current.or(thread -> thread instanceof NonBlockingThread));\n+\n+\n+         // SecureRandom reads from a socket\n+         builder.allowBlockingCallsInside(SecureRandom.class.getName(), \"nextBytes\");\n+\n+         // Just assume all the thread pools don't block - not we check the rejected handler below though\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"getTask\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"processWorkerExit\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(ScheduledThreadPoolExecutor.class.getName(), \"schedule\");\n+\n+         // Topology lock is very short lived - we assume these are okay\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"acquireSharedTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"releaseSharedTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"acquireExclusiveTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"releaseExclusiveTopologyLock\");\n+\n+         // This class tries to reduce blocking as much as possible and compute Function should be block free now\n+         registerAllPublicMethodsOnClass(builder, OffHeapConcurrentMap.class);\n+\n+         // LimitedExecutor just submits a task to another thread pool\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"removePermit\");\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"runTasks\");\n+         // This invokes the actual runnable - we have to make sure it doesn't block as normal\n+         builder.disallowBlockingCallsInside(LimitedExecutor.class.getName(), \"actualRun\");\n+         // This is invoked when cancelling a task - it locks a lock to update a queue, which shouldn't block\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"remove\");\n+\n+         // If shutting down a cache manager - don't worry if blocking\n+         builder.allowBlockingCallsInside(DefaultCacheManager.class.getName(), \"stop\");\n+\n+         // This method by design will never block; It may block very shortly if another thread is removing or adding\n+         // to the queue, but it will never block for an extended period by design as there will always be room\n+         builder.allowBlockingCallsInside(ClusterExpirationManager.class.getName(), \"addStageToPermits\");\n+\n+         // The blocking iterator locks to signal at the end - ignore\n+         builder.allowBlockingCallsInside(BlockingFlowableIterable.class.getName() + \"$BlockingFlowableIterator\", \"signalConsumer\");\n+\n+         // This shouldn't block long when held - but it is a write lock which can be delayed\n+         builder.allowBlockingCallsInside(KeyAffinityServiceImpl.class.getName(), \"handleViewChange\");\n+\n+         // The cache has to always be LOCAL and cannot be used with persistence\n+         builder.allowBlockingCallsInside(RecoveryManagerImpl.class.getName(), \"registerInDoubtTransaction\");\n+\n+         // Allow logging to block\n+         builder.allowBlockingCallsInside(Logger.class.getName(), \"logMessage\");\n+         builder.allowBlockingCallsInside(java.util.logging.Logger.class.getName(), \"log\");\n+\n+         // Make sure our rejection handlers never block in a non blocking thread\n+         builder.disallowBlockingCallsInside(BlockingRejectedExecutionHandler.class.getName(), \"rejectedExecution\");\n+\n+         builder.allowBlockingCallsInside(AbstractInfinispanTest.class.getName(), \"writeJUnitReport\");\n+\n+         methodsToBeRemoved(builder);\n+         jgroupsMethodsAllowedToBlock(builder);\n+\n+         questionableMethodsAllowedToBlock(builder);\n+\n+         allowTestsToBlock(builder);\n+\n+         builder.blockingMethodCallback(bm ->\n+            writeJUnitReport(new AssertionError(String.format(\"Blocking call! %s on thread %s\", bm, Thread.currentThread())), \"Blocking\"));\n+      }).install();\n+\n+      Thread.setDefaultUncaughtExceptionHandler((thread, t) -> {\n+         LogFactory.getLogger(\"Infinispan-TEST\").fatal(\"Throwable was not caught in thread \" + thread +\n+               \" - exception is: \" + t);\n+         // RxJava propagates via this and we don't want to worry about it\n+         if (!(t instanceof UndeliverableException)) {\n+            writeJUnitReport(t, \"Uncaught\");\n+         }\n+      });\n+   }\n+\n+   private static void methodsToBeRemoved(BlockHound.Builder builder) {\n+      // Total Order is to be removed!\n+      builder.allowBlockingCallsInside(StateConsumerImpl.class.getName(), \"awaitTotalOrderTransactions\");\n+\n+      // The internal map only supports local mode - we need to replace with Caffeine\n+      builder.allowBlockingCallsInside(RecoveryManagerImpl.class.getName(), \"registerInDoubtTransaction\");\n+   }\n+\n+   private static void jgroupsMethodsAllowedToBlock(BlockHound.Builder builder) {\n+      // UDP calls PlainDatagramSocketImpl#send which can block if OS buffer is full - but we just ignore\n+      builder.allowBlockingCallsInside(UDP.class.getName(), \"_send\");\n+      builder.allowBlockingCallsInside(FlowControl.class.getName(), \"adjustCredit\");\n+      builder.allowBlockingCallsInside(Table.class.getName(), \"add\");\n+      builder.allowBlockingCallsInside(Table.class.getName(), \"get\");\n+\n+      // THIS IS A VERY BAD HACK - because you can't instrument a static block of the class in jgroups Version class\n+      // which loads a properties file\n+      builder.allowBlockingCallsInside(Properties.class.getName(), \"load\");", "originalCommit": "fbe7300b2631520a166acbb51a4eb79abf60b491", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQwMDcxMQ==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r376400711", "bodyText": "I hadn't thought about this, but I like it. I can do that instead :)", "author": "wburns", "createdAt": "2020-02-07T13:54:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM3MDgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM3NTYzMA==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r376375630", "bodyText": "Minor nit: the default queue size is huge, so at least in the tests decrement should never actually await.\nYou're right about the lock though, it would be much cleaner if we could consider the JGroups threads \"blocking\", but switching to/from the non-blocking thread pool in order to do our processing would be really expensive.", "author": "danberindei", "createdAt": "2020-02-07T12:55:19Z", "path": "core/src/test/java/org/infinispan/test/AbstractInfinispanTest.java", "diffHunk": "@@ -72,6 +113,191 @@\n @TestSelector(interceptors = AbstractInfinispanTest.OrderByInstance.class)\n public abstract class AbstractInfinispanTest {\n \n+   static {\n+      BlockHound.builder().with(new RxJava2Integration()).with(builder -> {\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+         builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+         builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+         builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\n+\n+         // Prevent people from calling into distributed streams\n+         builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"stream\", \"()Lorg/infinispan/CacheStream;\");\n+         builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"parallelStream\", \"()Lorg/infinispan/CacheStream;\");\n+\n+         builder.nonBlockingThreadPredicate(current -> current.or(thread -> thread instanceof NonBlockingThread));\n+\n+\n+         // SecureRandom reads from a socket\n+         builder.allowBlockingCallsInside(SecureRandom.class.getName(), \"nextBytes\");\n+\n+         // Just assume all the thread pools don't block - not we check the rejected handler below though\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"getTask\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"processWorkerExit\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(ScheduledThreadPoolExecutor.class.getName(), \"schedule\");\n+\n+         // Topology lock is very short lived - we assume these are okay\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"acquireSharedTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"releaseSharedTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"acquireExclusiveTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"releaseExclusiveTopologyLock\");\n+\n+         // This class tries to reduce blocking as much as possible and compute Function should be block free now\n+         registerAllPublicMethodsOnClass(builder, OffHeapConcurrentMap.class);\n+\n+         // LimitedExecutor just submits a task to another thread pool\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"removePermit\");\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"runTasks\");\n+         // This invokes the actual runnable - we have to make sure it doesn't block as normal\n+         builder.disallowBlockingCallsInside(LimitedExecutor.class.getName(), \"actualRun\");\n+         // This is invoked when cancelling a task - it locks a lock to update a queue, which shouldn't block\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"remove\");\n+\n+         // If shutting down a cache manager - don't worry if blocking\n+         builder.allowBlockingCallsInside(DefaultCacheManager.class.getName(), \"stop\");\n+\n+         // This method by design will never block; It may block very shortly if another thread is removing or adding\n+         // to the queue, but it will never block for an extended period by design as there will always be room\n+         builder.allowBlockingCallsInside(ClusterExpirationManager.class.getName(), \"addStageToPermits\");\n+\n+         // The blocking iterator locks to signal at the end - ignore\n+         builder.allowBlockingCallsInside(BlockingFlowableIterable.class.getName() + \"$BlockingFlowableIterator\", \"signalConsumer\");\n+\n+         // This shouldn't block long when held - but it is a write lock which can be delayed\n+         builder.allowBlockingCallsInside(KeyAffinityServiceImpl.class.getName(), \"handleViewChange\");\n+\n+         // The cache has to always be LOCAL and cannot be used with persistence\n+         builder.allowBlockingCallsInside(RecoveryManagerImpl.class.getName(), \"registerInDoubtTransaction\");\n+\n+         // Allow logging to block\n+         builder.allowBlockingCallsInside(Logger.class.getName(), \"logMessage\");\n+         builder.allowBlockingCallsInside(java.util.logging.Logger.class.getName(), \"log\");\n+\n+         // Make sure our rejection handlers never block in a non blocking thread\n+         builder.disallowBlockingCallsInside(BlockingRejectedExecutionHandler.class.getName(), \"rejectedExecution\");\n+\n+         builder.allowBlockingCallsInside(AbstractInfinispanTest.class.getName(), \"writeJUnitReport\");\n+\n+         methodsToBeRemoved(builder);\n+         jgroupsMethodsAllowedToBlock(builder);\n+\n+         questionableMethodsAllowedToBlock(builder);\n+\n+         allowTestsToBlock(builder);\n+\n+         builder.blockingMethodCallback(bm ->\n+            writeJUnitReport(new AssertionError(String.format(\"Blocking call! %s on thread %s\", bm, Thread.currentThread())), \"Blocking\"));\n+      }).install();\n+\n+      Thread.setDefaultUncaughtExceptionHandler((thread, t) -> {\n+         LogFactory.getLogger(\"Infinispan-TEST\").fatal(\"Throwable was not caught in thread \" + thread +\n+               \" - exception is: \" + t);\n+         // RxJava propagates via this and we don't want to worry about it\n+         if (!(t instanceof UndeliverableException)) {\n+            writeJUnitReport(t, \"Uncaught\");\n+         }\n+      });\n+   }\n+\n+   private static void methodsToBeRemoved(BlockHound.Builder builder) {\n+      // Total Order is to be removed!\n+      builder.allowBlockingCallsInside(StateConsumerImpl.class.getName(), \"awaitTotalOrderTransactions\");\n+\n+      // The internal map only supports local mode - we need to replace with Caffeine\n+      builder.allowBlockingCallsInside(RecoveryManagerImpl.class.getName(), \"registerInDoubtTransaction\");\n+   }\n+\n+   private static void jgroupsMethodsAllowedToBlock(BlockHound.Builder builder) {\n+      // UDP calls PlainDatagramSocketImpl#send which can block if OS buffer is full - but we just ignore\n+      builder.allowBlockingCallsInside(UDP.class.getName(), \"_send\");\n+      builder.allowBlockingCallsInside(FlowControl.class.getName(), \"adjustCredit\");\n+      builder.allowBlockingCallsInside(Table.class.getName(), \"add\");\n+      builder.allowBlockingCallsInside(Table.class.getName(), \"get\");\n+\n+      // THIS IS A VERY BAD HACK - because you can't instrument a static block of the class in jgroups Version class\n+      // which loads a properties file\n+      builder.allowBlockingCallsInside(Properties.class.getName(), \"load\");\n+\n+      // The NonBlockingCreditMap being non blocking is a bit questionable as they hold the lock while doing a lot of\n+      // work - including acquiring other locks and possibly calling await\n+      builder.allowBlockingCallsInside(NonBlockingCreditMap.class.getName(), \"decrement\");", "originalCommit": "fbe7300b2631520a166acbb51a4eb79abf60b491", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQwMTA1NQ==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r376401055", "bodyText": "Yeah I am not sure exactly what to do with JGroups yet, that is my target after getting rid of all of the Infinispan thread pools :)", "author": "wburns", "createdAt": "2020-02-07T13:54:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM3NTYzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5MTUyMg==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r382091522", "bodyText": "I'll ignore this comment and pretend I always knew that the UFC_NB queue size is in bytes, not in elements ;)", "author": "danberindei", "createdAt": "2020-02-20T15:55:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM3NTYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM3NjgzNQ==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r376376835", "bodyText": "Not just that, but there are plenty of other protocols using locking in the JGroups stack...\nRunning with transfer-queue-bundler would remove the direct socket writes from sendCommand, but the bundler can still block writing to the limited queue.", "author": "danberindei", "createdAt": "2020-02-07T12:58:31Z", "path": "core/src/test/java/org/infinispan/test/AbstractInfinispanTest.java", "diffHunk": "@@ -72,6 +113,191 @@\n @TestSelector(interceptors = AbstractInfinispanTest.OrderByInstance.class)\n public abstract class AbstractInfinispanTest {\n \n+   static {\n+      BlockHound.builder().with(new RxJava2Integration()).with(builder -> {\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+         builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+         builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+         builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\n+\n+         // Prevent people from calling into distributed streams\n+         builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"stream\", \"()Lorg/infinispan/CacheStream;\");\n+         builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"parallelStream\", \"()Lorg/infinispan/CacheStream;\");\n+\n+         builder.nonBlockingThreadPredicate(current -> current.or(thread -> thread instanceof NonBlockingThread));\n+\n+\n+         // SecureRandom reads from a socket\n+         builder.allowBlockingCallsInside(SecureRandom.class.getName(), \"nextBytes\");\n+\n+         // Just assume all the thread pools don't block - not we check the rejected handler below though\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"getTask\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"processWorkerExit\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(ScheduledThreadPoolExecutor.class.getName(), \"schedule\");\n+\n+         // Topology lock is very short lived - we assume these are okay\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"acquireSharedTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"releaseSharedTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"acquireExclusiveTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"releaseExclusiveTopologyLock\");\n+\n+         // This class tries to reduce blocking as much as possible and compute Function should be block free now\n+         registerAllPublicMethodsOnClass(builder, OffHeapConcurrentMap.class);\n+\n+         // LimitedExecutor just submits a task to another thread pool\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"removePermit\");\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"runTasks\");\n+         // This invokes the actual runnable - we have to make sure it doesn't block as normal\n+         builder.disallowBlockingCallsInside(LimitedExecutor.class.getName(), \"actualRun\");\n+         // This is invoked when cancelling a task - it locks a lock to update a queue, which shouldn't block\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"remove\");\n+\n+         // If shutting down a cache manager - don't worry if blocking\n+         builder.allowBlockingCallsInside(DefaultCacheManager.class.getName(), \"stop\");\n+\n+         // This method by design will never block; It may block very shortly if another thread is removing or adding\n+         // to the queue, but it will never block for an extended period by design as there will always be room\n+         builder.allowBlockingCallsInside(ClusterExpirationManager.class.getName(), \"addStageToPermits\");\n+\n+         // The blocking iterator locks to signal at the end - ignore\n+         builder.allowBlockingCallsInside(BlockingFlowableIterable.class.getName() + \"$BlockingFlowableIterator\", \"signalConsumer\");\n+\n+         // This shouldn't block long when held - but it is a write lock which can be delayed\n+         builder.allowBlockingCallsInside(KeyAffinityServiceImpl.class.getName(), \"handleViewChange\");\n+\n+         // The cache has to always be LOCAL and cannot be used with persistence\n+         builder.allowBlockingCallsInside(RecoveryManagerImpl.class.getName(), \"registerInDoubtTransaction\");\n+\n+         // Allow logging to block\n+         builder.allowBlockingCallsInside(Logger.class.getName(), \"logMessage\");\n+         builder.allowBlockingCallsInside(java.util.logging.Logger.class.getName(), \"log\");\n+\n+         // Make sure our rejection handlers never block in a non blocking thread\n+         builder.disallowBlockingCallsInside(BlockingRejectedExecutionHandler.class.getName(), \"rejectedExecution\");\n+\n+         builder.allowBlockingCallsInside(AbstractInfinispanTest.class.getName(), \"writeJUnitReport\");\n+\n+         methodsToBeRemoved(builder);\n+         jgroupsMethodsAllowedToBlock(builder);\n+\n+         questionableMethodsAllowedToBlock(builder);\n+\n+         allowTestsToBlock(builder);\n+\n+         builder.blockingMethodCallback(bm ->\n+            writeJUnitReport(new AssertionError(String.format(\"Blocking call! %s on thread %s\", bm, Thread.currentThread())), \"Blocking\"));\n+      }).install();\n+\n+      Thread.setDefaultUncaughtExceptionHandler((thread, t) -> {\n+         LogFactory.getLogger(\"Infinispan-TEST\").fatal(\"Throwable was not caught in thread \" + thread +\n+               \" - exception is: \" + t);\n+         // RxJava propagates via this and we don't want to worry about it\n+         if (!(t instanceof UndeliverableException)) {\n+            writeJUnitReport(t, \"Uncaught\");\n+         }\n+      });\n+   }\n+\n+   private static void methodsToBeRemoved(BlockHound.Builder builder) {\n+      // Total Order is to be removed!\n+      builder.allowBlockingCallsInside(StateConsumerImpl.class.getName(), \"awaitTotalOrderTransactions\");\n+\n+      // The internal map only supports local mode - we need to replace with Caffeine\n+      builder.allowBlockingCallsInside(RecoveryManagerImpl.class.getName(), \"registerInDoubtTransaction\");\n+   }\n+\n+   private static void jgroupsMethodsAllowedToBlock(BlockHound.Builder builder) {\n+      // UDP calls PlainDatagramSocketImpl#send which can block if OS buffer is full - but we just ignore\n+      builder.allowBlockingCallsInside(UDP.class.getName(), \"_send\");\n+      builder.allowBlockingCallsInside(FlowControl.class.getName(), \"adjustCredit\");\n+      builder.allowBlockingCallsInside(Table.class.getName(), \"add\");\n+      builder.allowBlockingCallsInside(Table.class.getName(), \"get\");\n+\n+      // THIS IS A VERY BAD HACK - because you can't instrument a static block of the class in jgroups Version class\n+      // which loads a properties file\n+      builder.allowBlockingCallsInside(Properties.class.getName(), \"load\");\n+\n+      // The NonBlockingCreditMap being non blocking is a bit questionable as they hold the lock while doing a lot of\n+      // work - including acquiring other locks and possibly calling await\n+      builder.allowBlockingCallsInside(NonBlockingCreditMap.class.getName(), \"decrement\");\n+      builder.allowBlockingCallsInside(NonBlockingCreditMap.class.getName(), \"replenish\");\n+   }\n+\n+   private static void questionableMethodsAllowedToBlock(BlockHound.Builder builder) {\n+      // Component registry has a lock to protect its state - is short lived lock\n+      builder.allowBlockingCallsInside(BasicComponentRegistryImpl.class.getName(), \"prepareWrapperChange\");\n+\n+      // This one should probably not be allowed - it is waiting for another component to start\n+      // TODO: This might actually be a bug in the rewiring logic. (shows in StateTransferOverwritingValueTest)\n+      builder.allowBlockingCallsInside(BasicComponentRegistryImpl.class.getName(), \"awaitWrapperState\");\n+\n+      // Believe these can technically block for TCP when flushing to socket", "originalCommit": "fbe7300b2631520a166acbb51a4eb79abf60b491", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQwNDA0Nw==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r376404047", "bodyText": "Good to know, I think having a list of known protocols that can block would help figure out what to do possibly.", "author": "wburns", "createdAt": "2020-02-07T14:00:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM3NjgzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM4MDY0OA==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r376380648", "bodyText": "This doesn't look very scalable...\nSince you've had to debug all of these, I wonder how much work it would be to move the tests to either return a CompletionStage that's completed from the main thread or to wrap all the calls in something like TestingUtil.pretendItsNotBlocking(() -> blockingMethodCall()). Not in this PR, of course :)", "author": "danberindei", "createdAt": "2020-02-07T13:08:58Z", "path": "core/src/test/java/org/infinispan/test/AbstractInfinispanTest.java", "diffHunk": "@@ -72,6 +113,191 @@\n @TestSelector(interceptors = AbstractInfinispanTest.OrderByInstance.class)\n public abstract class AbstractInfinispanTest {\n \n+   static {\n+      BlockHound.builder().with(new RxJava2Integration()).with(builder -> {\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+         builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+         builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+         builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\n+\n+         // Prevent people from calling into distributed streams\n+         builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"stream\", \"()Lorg/infinispan/CacheStream;\");\n+         builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"parallelStream\", \"()Lorg/infinispan/CacheStream;\");\n+\n+         builder.nonBlockingThreadPredicate(current -> current.or(thread -> thread instanceof NonBlockingThread));\n+\n+\n+         // SecureRandom reads from a socket\n+         builder.allowBlockingCallsInside(SecureRandom.class.getName(), \"nextBytes\");\n+\n+         // Just assume all the thread pools don't block - not we check the rejected handler below though\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"getTask\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"processWorkerExit\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(ScheduledThreadPoolExecutor.class.getName(), \"schedule\");\n+\n+         // Topology lock is very short lived - we assume these are okay\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"acquireSharedTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"releaseSharedTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"acquireExclusiveTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"releaseExclusiveTopologyLock\");\n+\n+         // This class tries to reduce blocking as much as possible and compute Function should be block free now\n+         registerAllPublicMethodsOnClass(builder, OffHeapConcurrentMap.class);\n+\n+         // LimitedExecutor just submits a task to another thread pool\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"removePermit\");\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"runTasks\");\n+         // This invokes the actual runnable - we have to make sure it doesn't block as normal\n+         builder.disallowBlockingCallsInside(LimitedExecutor.class.getName(), \"actualRun\");\n+         // This is invoked when cancelling a task - it locks a lock to update a queue, which shouldn't block\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"remove\");\n+\n+         // If shutting down a cache manager - don't worry if blocking\n+         builder.allowBlockingCallsInside(DefaultCacheManager.class.getName(), \"stop\");\n+\n+         // This method by design will never block; It may block very shortly if another thread is removing or adding\n+         // to the queue, but it will never block for an extended period by design as there will always be room\n+         builder.allowBlockingCallsInside(ClusterExpirationManager.class.getName(), \"addStageToPermits\");\n+\n+         // The blocking iterator locks to signal at the end - ignore\n+         builder.allowBlockingCallsInside(BlockingFlowableIterable.class.getName() + \"$BlockingFlowableIterator\", \"signalConsumer\");\n+\n+         // This shouldn't block long when held - but it is a write lock which can be delayed\n+         builder.allowBlockingCallsInside(KeyAffinityServiceImpl.class.getName(), \"handleViewChange\");\n+\n+         // The cache has to always be LOCAL and cannot be used with persistence\n+         builder.allowBlockingCallsInside(RecoveryManagerImpl.class.getName(), \"registerInDoubtTransaction\");\n+\n+         // Allow logging to block\n+         builder.allowBlockingCallsInside(Logger.class.getName(), \"logMessage\");\n+         builder.allowBlockingCallsInside(java.util.logging.Logger.class.getName(), \"log\");\n+\n+         // Make sure our rejection handlers never block in a non blocking thread\n+         builder.disallowBlockingCallsInside(BlockingRejectedExecutionHandler.class.getName(), \"rejectedExecution\");\n+\n+         builder.allowBlockingCallsInside(AbstractInfinispanTest.class.getName(), \"writeJUnitReport\");\n+\n+         methodsToBeRemoved(builder);\n+         jgroupsMethodsAllowedToBlock(builder);\n+\n+         questionableMethodsAllowedToBlock(builder);\n+\n+         allowTestsToBlock(builder);\n+\n+         builder.blockingMethodCallback(bm ->\n+            writeJUnitReport(new AssertionError(String.format(\"Blocking call! %s on thread %s\", bm, Thread.currentThread())), \"Blocking\"));\n+      }).install();\n+\n+      Thread.setDefaultUncaughtExceptionHandler((thread, t) -> {\n+         LogFactory.getLogger(\"Infinispan-TEST\").fatal(\"Throwable was not caught in thread \" + thread +\n+               \" - exception is: \" + t);\n+         // RxJava propagates via this and we don't want to worry about it\n+         if (!(t instanceof UndeliverableException)) {\n+            writeJUnitReport(t, \"Uncaught\");\n+         }\n+      });\n+   }\n+\n+   private static void methodsToBeRemoved(BlockHound.Builder builder) {\n+      // Total Order is to be removed!\n+      builder.allowBlockingCallsInside(StateConsumerImpl.class.getName(), \"awaitTotalOrderTransactions\");\n+\n+      // The internal map only supports local mode - we need to replace with Caffeine\n+      builder.allowBlockingCallsInside(RecoveryManagerImpl.class.getName(), \"registerInDoubtTransaction\");\n+   }\n+\n+   private static void jgroupsMethodsAllowedToBlock(BlockHound.Builder builder) {\n+      // UDP calls PlainDatagramSocketImpl#send which can block if OS buffer is full - but we just ignore\n+      builder.allowBlockingCallsInside(UDP.class.getName(), \"_send\");\n+      builder.allowBlockingCallsInside(FlowControl.class.getName(), \"adjustCredit\");\n+      builder.allowBlockingCallsInside(Table.class.getName(), \"add\");\n+      builder.allowBlockingCallsInside(Table.class.getName(), \"get\");\n+\n+      // THIS IS A VERY BAD HACK - because you can't instrument a static block of the class in jgroups Version class\n+      // which loads a properties file\n+      builder.allowBlockingCallsInside(Properties.class.getName(), \"load\");\n+\n+      // The NonBlockingCreditMap being non blocking is a bit questionable as they hold the lock while doing a lot of\n+      // work - including acquiring other locks and possibly calling await\n+      builder.allowBlockingCallsInside(NonBlockingCreditMap.class.getName(), \"decrement\");\n+      builder.allowBlockingCallsInside(NonBlockingCreditMap.class.getName(), \"replenish\");\n+   }\n+\n+   private static void questionableMethodsAllowedToBlock(BlockHound.Builder builder) {\n+      // Component registry has a lock to protect its state - is short lived lock\n+      builder.allowBlockingCallsInside(BasicComponentRegistryImpl.class.getName(), \"prepareWrapperChange\");\n+\n+      // This one should probably not be allowed - it is waiting for another component to start\n+      // TODO: This might actually be a bug in the rewiring logic. (shows in StateTransferOverwritingValueTest)\n+      builder.allowBlockingCallsInside(BasicComponentRegistryImpl.class.getName(), \"awaitWrapperState\");\n+\n+      // Believe these can technically block for TCP when flushing to socket\n+      builder.allowBlockingCallsInside(JGroupsTransport.class.getName(), \"sendCommand\");\n+      builder.allowBlockingCallsInside(JGroupsTransport.class.getName(), \"sendResponse\");\n+\n+      // This method calls initCacheStatusIfAbsent which can invoke readScopedState which reads scope from a file that\n+      // can block the current thread while doing I/O\n+      builder.allowBlockingCallsInside(ClusterTopologyManagerImpl.class.getName(), \"prepareJoin\");\n+      builder.allowBlockingCallsInside(ClusterTopologyManagerImpl.class.getName(), \"updateClusterState\");\n+   }\n+\n+   private static void allowTestsToBlock(BlockHound.Builder builder) {\n+      builder.allowBlockingCallsInside(EvictionWithConcurrentOperationsTest.class.getName() + \"$Latch\", \"blockIfNeeded\");", "originalCommit": "fbe7300b2631520a166acbb51a4eb79abf60b491", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQwMDQwMA==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r376400400", "bodyText": "This is what the JREBlocking class was helping with. But I hadn't taken it as far as making it as abstract as a Callable or Runnable yet, but we could very easily do that.", "author": "wburns", "createdAt": "2020-02-07T13:53:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM4MDY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM4MTc1Ng==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r376381756", "bodyText": "Unused?", "author": "danberindei", "createdAt": "2020-02-07T13:11:58Z", "path": "core/src/test/java/org/infinispan/test/JREBlocking.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package org.infinispan.test;\n+\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.Exchanger;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class JREBlocking {", "originalCommit": "fbe7300b2631520a166acbb51a4eb79abf60b491", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM5OTkyNg==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r376399926", "bodyText": "I copied it from the other PR as I was adding stuff and thought I was using this class here now, but I guess not. I can just remove it until the next one.", "author": "wburns", "createdAt": "2020-02-07T13:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM4MTc1Ng=="}], "type": "inlineReview"}, {"oid": "c373302cf8425a44eb6002d12b14c087041e3331", "url": "https://github.com/infinispan/infinispan/commit/c373302cf8425a44eb6002d12b14c087041e3331", "message": "additional", "committedDate": "2020-02-12T17:40:19Z", "type": "forcePushed"}, {"oid": "536bbfd17c2c05745b467811e610d695b2b483ac", "url": "https://github.com/infinispan/infinispan/commit/536bbfd17c2c05745b467811e610d695b2b483ac", "message": "additional changes", "committedDate": "2020-02-18T19:08:52Z", "type": "forcePushed"}, {"oid": "fcabe83a5d2eb78973f614e1331ec93c4b117510", "url": "https://github.com/infinispan/infinispan/commit/fcabe83a5d2eb78973f614e1331ec93c4b117510", "message": "ISPN-11261 GlobalConfigurationManager should use blocking threads when starting caches", "committedDate": "2020-02-18T19:26:09Z", "type": "forcePushed"}, {"oid": "74e6f5f0dcf6f9e6b89b9e8a5d803d763cb80b28", "url": "https://github.com/infinispan/infinispan/commit/74e6f5f0dcf6f9e6b89b9e8a5d803d763cb80b28", "message": "ISPN-10898 Add Blockound to test suite to make sure cpu threads are never blocked", "committedDate": "2020-02-19T15:13:36Z", "type": "forcePushed"}, {"oid": "6ae5c3aebad0ecc51f859938438142e9b033219a", "url": "https://github.com/infinispan/infinispan/commit/6ae5c3aebad0ecc51f859938438142e9b033219a", "message": "ISPN-10898 Add Blockound to test suite to make sure cpu threads are never blocked", "committedDate": "2020-02-20T22:52:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5NTE1MA==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r382095150", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               // as commons doesn't rely on commons-test only the commons jar does\n          \n          \n            \n               // as commons doesn't rely on commons-test, only the commons test jar does", "author": "danberindei", "createdAt": "2020-02-20T16:00:37Z", "path": "commons-test/src/main/java/org/infinispan/commons/test/CommonsTestBlockHoundIntegration.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package org.infinispan.commons.test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.security.SecureRandom;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import org.kohsuke.MetaInfServices;\n+\n+import reactor.blockhound.BlockHound;\n+import reactor.blockhound.integration.BlockHoundIntegration;\n+\n+@SuppressWarnings(\"unused\")\n+@MetaInfServices\n+public class CommonsTestBlockHoundIntegration implements BlockHoundIntegration {\n+   @Override\n+   public void applyTo(BlockHound.Builder builder) {\n+      // SecureRandom reads from a socket\n+      builder.allowBlockingCallsInside(SecureRandom.class.getName(), \"nextBytes\");\n+\n+      // Just assume all the thread pools don't block in our test suite - NOTE rejection policy can still be an issue!\n+      CommonsTestBlockHoundIntegration.registerAllPublicMethodsOnClass(builder, ThreadPoolExecutor.class);\n+      CommonsTestBlockHoundIntegration.registerAllPublicMethodsOnClass(builder, ScheduledThreadPoolExecutor.class);\n+\n+      // Allow logging to block in our test suite\n+      builder.allowBlockingCallsInside(org.apache.logging.log4j.Logger.class.getName(), \"logMessage\");\n+      builder.allowBlockingCallsInside(java.util.logging.Logger.class.getName(), \"log\");\n+   }\n+\n+   // This is a duplicate of CommonsBlockHoundIntegration - but unfortunately neither can reference each other\n+   // as commons doesn't rely on commons-test only the commons jar does", "originalCommit": "74e6f5f0dcf6f9e6b89b9e8a5d803d763cb80b28", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2MDcyMg==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r382660722", "bodyText": "This looks incomplete :)", "author": "danberindei", "createdAt": "2020-02-21T15:56:23Z", "path": "core/src/main/java/org/infinispan/util/CoreBlockHoundIntegration.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.infinispan.util;\n+\n+import org.infinispan.affinity.impl.KeyAffinityServiceImpl;\n+import org.infinispan.cache.impl.CacheImpl;\n+import org.infinispan.commons.internal.CommonsBlockHoundIntegration;\n+import org.infinispan.container.offheap.OffHeapConcurrentMap;\n+import org.infinispan.executors.LimitedExecutor;\n+import org.infinispan.expiration.impl.ClusterExpirationManager;\n+import org.infinispan.factories.impl.BasicComponentRegistryImpl;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.remoting.transport.jgroups.JGroupsTransport;\n+import org.infinispan.statetransfer.StateTransferLockImpl;\n+import org.infinispan.topology.ClusterTopologyManagerImpl;\n+import org.infinispan.transaction.xa.recovery.RecoveryManagerImpl;\n+import org.jgroups.Version;\n+import org.jgroups.protocols.FlowControl;\n+import org.jgroups.protocols.UDP;\n+import org.jgroups.util.NonBlockingCreditMap;\n+import org.jgroups.util.Table;\n+import org.kohsuke.MetaInfServices;\n+\n+import io.reactivex.internal.operators.flowable.BlockingFlowableIterable;\n+import reactor.blockhound.BlockHound;\n+import reactor.blockhound.integration.BlockHoundIntegration;\n+\n+@SuppressWarnings(\"unused\")\n+@MetaInfServices\n+public class CoreBlockHoundIntegration implements BlockHoundIntegration {\n+   @Override\n+   public void applyTo(BlockHound.Builder builder) {\n+      registerBlockingMethods(builder);\n+\n+      // Block designates methods that should only hold a lock very briefly\n+      {\n+         CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, OffHeapConcurrentMap.class);\n+         CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, StateTransferLockImpl.class);\n+         CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, LimitedExecutor.class);\n+\n+         // This method by design will never block; It may block very shortly if another thread is removing or adding\n+         // to the queue, but it will never block for an extended period by design as there will always be room\n+         builder.allowBlockingCallsInside(ClusterExpirationManager.class.getName(), \"addStageToPermits\");\n+\n+         // This shouldn't block long when held - but it is a write lock which can be delayed\n+         builder.allowBlockingCallsInside(KeyAffinityServiceImpl.class.getName(), \"handleViewChange\");\n+      }\n+      // This invokes the actual runnable - we have to make sure it doesn't block as normal\n+      builder.disallowBlockingCallsInside(LimitedExecutor.class.getName(), \"actualRun\");\n+\n+      // If shutting down a cache manager - don't worry if blocking\n+      builder.allowBlockingCallsInside(DefaultCacheManager.class.getName(), \"stop\");\n+\n+      // The blocking iterator locks to signal at the end - ignore\n+      builder.allowBlockingCallsInside(BlockingFlowableIterable.class.getName() + \"$BlockingFlowableIterator\", \"signalConsumer\");\n+\n+      methodsToBeRemoved(builder);\n+\n+      jgroupsMethodsAllowedToBlock(builder);\n+\n+      questionableMethodsAllowedToBlock(builder);\n+   }\n+\n+   private static void methodsToBeRemoved(BlockHound.Builder builder) {\n+      // The internal map only supports local mode - we need to replace with Caffeine\n+      // https://issues.redhat.com/browse/ISPN-11272\n+      builder.allowBlockingCallsInside(RecoveryManagerImpl.class.getName(), \"registerInDoubtTransaction\");\n+   }\n+\n+   private static void registerBlockingMethods(BlockHound.Builder builder) {\n+      builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+      builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+      builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+      builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+      builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");", "originalCommit": "6ae5c3aebad0ecc51f859938438142e9b033219a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4MTIxMQ==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r382681211", "bodyText": "I just wanted to add a few of the more common ones. We can add more later if needed.", "author": "wburns", "createdAt": "2020-02-21T16:32:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2MDcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNTgzOA==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r382715838", "bodyText": "Yeah, in the future I would love it if users could also use BlockHound to see if they are calling blocking methods on Infinispan threads.", "author": "danberindei", "createdAt": "2020-02-21T17:41:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2MDcyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2MTY2MQ==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r382661661", "bodyText": "Please add the same for TCP, in case anyone runs the tests with -Dinfinispan.cluster.stack=tcp", "author": "danberindei", "createdAt": "2020-02-21T15:57:58Z", "path": "core/src/main/java/org/infinispan/util/CoreBlockHoundIntegration.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.infinispan.util;\n+\n+import org.infinispan.affinity.impl.KeyAffinityServiceImpl;\n+import org.infinispan.cache.impl.CacheImpl;\n+import org.infinispan.commons.internal.CommonsBlockHoundIntegration;\n+import org.infinispan.container.offheap.OffHeapConcurrentMap;\n+import org.infinispan.executors.LimitedExecutor;\n+import org.infinispan.expiration.impl.ClusterExpirationManager;\n+import org.infinispan.factories.impl.BasicComponentRegistryImpl;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.remoting.transport.jgroups.JGroupsTransport;\n+import org.infinispan.statetransfer.StateTransferLockImpl;\n+import org.infinispan.topology.ClusterTopologyManagerImpl;\n+import org.infinispan.transaction.xa.recovery.RecoveryManagerImpl;\n+import org.jgroups.Version;\n+import org.jgroups.protocols.FlowControl;\n+import org.jgroups.protocols.UDP;\n+import org.jgroups.util.NonBlockingCreditMap;\n+import org.jgroups.util.Table;\n+import org.kohsuke.MetaInfServices;\n+\n+import io.reactivex.internal.operators.flowable.BlockingFlowableIterable;\n+import reactor.blockhound.BlockHound;\n+import reactor.blockhound.integration.BlockHoundIntegration;\n+\n+@SuppressWarnings(\"unused\")\n+@MetaInfServices\n+public class CoreBlockHoundIntegration implements BlockHoundIntegration {\n+   @Override\n+   public void applyTo(BlockHound.Builder builder) {\n+      registerBlockingMethods(builder);\n+\n+      // Block designates methods that should only hold a lock very briefly\n+      {\n+         CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, OffHeapConcurrentMap.class);\n+         CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, StateTransferLockImpl.class);\n+         CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, LimitedExecutor.class);\n+\n+         // This method by design will never block; It may block very shortly if another thread is removing or adding\n+         // to the queue, but it will never block for an extended period by design as there will always be room\n+         builder.allowBlockingCallsInside(ClusterExpirationManager.class.getName(), \"addStageToPermits\");\n+\n+         // This shouldn't block long when held - but it is a write lock which can be delayed\n+         builder.allowBlockingCallsInside(KeyAffinityServiceImpl.class.getName(), \"handleViewChange\");\n+      }\n+      // This invokes the actual runnable - we have to make sure it doesn't block as normal\n+      builder.disallowBlockingCallsInside(LimitedExecutor.class.getName(), \"actualRun\");\n+\n+      // If shutting down a cache manager - don't worry if blocking\n+      builder.allowBlockingCallsInside(DefaultCacheManager.class.getName(), \"stop\");\n+\n+      // The blocking iterator locks to signal at the end - ignore\n+      builder.allowBlockingCallsInside(BlockingFlowableIterable.class.getName() + \"$BlockingFlowableIterator\", \"signalConsumer\");\n+\n+      methodsToBeRemoved(builder);\n+\n+      jgroupsMethodsAllowedToBlock(builder);\n+\n+      questionableMethodsAllowedToBlock(builder);\n+   }\n+\n+   private static void methodsToBeRemoved(BlockHound.Builder builder) {\n+      // The internal map only supports local mode - we need to replace with Caffeine\n+      // https://issues.redhat.com/browse/ISPN-11272\n+      builder.allowBlockingCallsInside(RecoveryManagerImpl.class.getName(), \"registerInDoubtTransaction\");\n+   }\n+\n+   private static void registerBlockingMethods(BlockHound.Builder builder) {\n+      builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+      builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+      builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+      builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+      builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\n+\n+      // Distributed streams are blocking!\n+      builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"stream\", \"()Lorg/infinispan/CacheStream;\");\n+      builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"parallelStream\", \"()Lorg/infinispan/CacheStream;\");\n+   }\n+\n+   private static void jgroupsMethodsAllowedToBlock(BlockHound.Builder builder) {\n+      // UDP calls PlainDatagramSocketImpl#send which can block if OS buffer is full - but we just ignore\n+      builder.allowBlockingCallsInside(UDP.class.getName(), \"_send\");", "originalCommit": "6ae5c3aebad0ecc51f859938438142e9b033219a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2NDIzNA==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r382664234", "bodyText": "Do we need to add all the individual JGroups protocol methods as well, if we have these 2, or even just JChannel#send?", "author": "danberindei", "createdAt": "2020-02-21T16:02:10Z", "path": "core/src/main/java/org/infinispan/util/CoreBlockHoundIntegration.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.infinispan.util;\n+\n+import org.infinispan.affinity.impl.KeyAffinityServiceImpl;\n+import org.infinispan.cache.impl.CacheImpl;\n+import org.infinispan.commons.internal.CommonsBlockHoundIntegration;\n+import org.infinispan.container.offheap.OffHeapConcurrentMap;\n+import org.infinispan.executors.LimitedExecutor;\n+import org.infinispan.expiration.impl.ClusterExpirationManager;\n+import org.infinispan.factories.impl.BasicComponentRegistryImpl;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.remoting.transport.jgroups.JGroupsTransport;\n+import org.infinispan.statetransfer.StateTransferLockImpl;\n+import org.infinispan.topology.ClusterTopologyManagerImpl;\n+import org.infinispan.transaction.xa.recovery.RecoveryManagerImpl;\n+import org.jgroups.Version;\n+import org.jgroups.protocols.FlowControl;\n+import org.jgroups.protocols.UDP;\n+import org.jgroups.util.NonBlockingCreditMap;\n+import org.jgroups.util.Table;\n+import org.kohsuke.MetaInfServices;\n+\n+import io.reactivex.internal.operators.flowable.BlockingFlowableIterable;\n+import reactor.blockhound.BlockHound;\n+import reactor.blockhound.integration.BlockHoundIntegration;\n+\n+@SuppressWarnings(\"unused\")\n+@MetaInfServices\n+public class CoreBlockHoundIntegration implements BlockHoundIntegration {\n+   @Override\n+   public void applyTo(BlockHound.Builder builder) {\n+      registerBlockingMethods(builder);\n+\n+      // Block designates methods that should only hold a lock very briefly\n+      {\n+         CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, OffHeapConcurrentMap.class);\n+         CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, StateTransferLockImpl.class);\n+         CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, LimitedExecutor.class);\n+\n+         // This method by design will never block; It may block very shortly if another thread is removing or adding\n+         // to the queue, but it will never block for an extended period by design as there will always be room\n+         builder.allowBlockingCallsInside(ClusterExpirationManager.class.getName(), \"addStageToPermits\");\n+\n+         // This shouldn't block long when held - but it is a write lock which can be delayed\n+         builder.allowBlockingCallsInside(KeyAffinityServiceImpl.class.getName(), \"handleViewChange\");\n+      }\n+      // This invokes the actual runnable - we have to make sure it doesn't block as normal\n+      builder.disallowBlockingCallsInside(LimitedExecutor.class.getName(), \"actualRun\");\n+\n+      // If shutting down a cache manager - don't worry if blocking\n+      builder.allowBlockingCallsInside(DefaultCacheManager.class.getName(), \"stop\");\n+\n+      // The blocking iterator locks to signal at the end - ignore\n+      builder.allowBlockingCallsInside(BlockingFlowableIterable.class.getName() + \"$BlockingFlowableIterator\", \"signalConsumer\");\n+\n+      methodsToBeRemoved(builder);\n+\n+      jgroupsMethodsAllowedToBlock(builder);\n+\n+      questionableMethodsAllowedToBlock(builder);\n+   }\n+\n+   private static void methodsToBeRemoved(BlockHound.Builder builder) {\n+      // The internal map only supports local mode - we need to replace with Caffeine\n+      // https://issues.redhat.com/browse/ISPN-11272\n+      builder.allowBlockingCallsInside(RecoveryManagerImpl.class.getName(), \"registerInDoubtTransaction\");\n+   }\n+\n+   private static void registerBlockingMethods(BlockHound.Builder builder) {\n+      builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+      builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+      builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+      builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+      builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\n+\n+      // Distributed streams are blocking!\n+      builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"stream\", \"()Lorg/infinispan/CacheStream;\");\n+      builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"parallelStream\", \"()Lorg/infinispan/CacheStream;\");\n+   }\n+\n+   private static void jgroupsMethodsAllowedToBlock(BlockHound.Builder builder) {\n+      // UDP calls PlainDatagramSocketImpl#send which can block if OS buffer is full - but we just ignore\n+      builder.allowBlockingCallsInside(UDP.class.getName(), \"_send\");\n+      builder.allowBlockingCallsInside(FlowControl.class.getName(), \"adjustCredit\");\n+      builder.allowBlockingCallsInside(Table.class.getName(), \"add\");\n+      builder.allowBlockingCallsInside(Table.class.getName(), \"get\");\n+\n+      // Force Version class to be loaded before installing block hound (eagerly runs class initializer which blocks)\n+      System.out.println(\"BlockHound in use with JGroups: \" + Version.printVersion());\n+\n+      // The NonBlockingCreditMap being non blocking is a bit questionable as they hold the lock while doing a lot of\n+      // work - including acquiring other locks and possibly calling await\n+      builder.allowBlockingCallsInside(NonBlockingCreditMap.class.getName(), \"decrement\");\n+      builder.allowBlockingCallsInside(NonBlockingCreditMap.class.getName(), \"replenish\");\n+   }\n+\n+   private static void questionableMethodsAllowedToBlock(BlockHound.Builder builder) {\n+      // Component registry has a lock to protect its state - is short lived lock\n+      builder.allowBlockingCallsInside(BasicComponentRegistryImpl.class.getName(), \"prepareWrapperChange\");\n+\n+      // This one should probably not be allowed - it is waiting for another component to start\n+      // TODO: This might actually be a bug in the rewiring logic. (shows in StateTransferOverwritingValueTest)\n+      builder.allowBlockingCallsInside(BasicComponentRegistryImpl.class.getName(), \"awaitWrapperState\");\n+\n+      // Believe these can technically block for TCP when flushing to socket\n+      builder.allowBlockingCallsInside(JGroupsTransport.class.getName(), \"sendCommand\");\n+      builder.allowBlockingCallsInside(JGroupsTransport.class.getName(), \"sendResponse\");", "originalCommit": "6ae5c3aebad0ecc51f859938438142e9b033219a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4MzUxOQ==", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r382683519", "bodyText": "Please also do a TestSuiteProgress.fakeTestFailure(testName, exception), I have a script that looks for those Test failed messages in the output when I run the tests locally :)", "author": "danberindei", "createdAt": "2020-02-21T16:36:44Z", "path": "core/src/test/java/org/infinispan/util/CoreTestBlockHoundIntegration.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package org.infinispan.util;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+\n+import org.infinispan.commons.internal.CommonsBlockHoundIntegration;\n+import org.infinispan.commons.test.PolarionJUnitXMLWriter;\n+import org.infinispan.distribution.BlockingInterceptor;\n+import org.infinispan.eviction.impl.EvictionWithConcurrentOperationsTest;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.test.concurrent.StateSequencer;\n+import org.infinispan.test.fwk.CheckPoint;\n+import org.infinispan.test.fwk.TestResourceTracker;\n+import org.infinispan.util.concurrent.ReclosableLatch;\n+import org.infinispan.util.logging.LogFactory;\n+import org.kohsuke.MetaInfServices;\n+\n+import io.reactivex.exceptions.UndeliverableException;\n+import reactor.blockhound.BlockHound;\n+import reactor.blockhound.integration.BlockHoundIntegration;\n+\n+@SuppressWarnings(\"unused\")\n+@MetaInfServices\n+public class CoreTestBlockHoundIntegration implements BlockHoundIntegration {\n+   @Override\n+   public void applyTo(BlockHound.Builder builder) {\n+      allowTestsToBlock(builder);\n+\n+      builder.allowBlockingCallsInside(CoreTestBlockHoundIntegration.class.getName(), \"writeJUnitReport\");\n+\n+      builder.blockingMethodCallback(bm ->\n+            writeJUnitReport(new AssertionError(String.format(\"Blocking call! %s on thread %s\", bm, Thread.currentThread())), \"Blocking\"));", "originalCommit": "6ae5c3aebad0ecc51f859938438142e9b033219a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "09c6405ada1f9d48e742fdf52993264d2c17aa17", "url": "https://github.com/infinispan/infinispan/commit/09c6405ada1f9d48e742fdf52993264d2c17aa17", "message": "ISPN-10898 Add Blockound to test suite to make sure cpu threads are never blocked", "committedDate": "2020-02-21T17:47:01Z", "type": "forcePushed"}, {"oid": "0f54dc101d0c739ded4b993402a18d999115341e", "url": "https://github.com/infinispan/infinispan/commit/0f54dc101d0c739ded4b993402a18d999115341e", "message": "make blockhound installation optional based on classpath", "committedDate": "2020-02-24T16:56:00Z", "type": "forcePushed"}, {"oid": "f6b4a2535891b7d49eb61421a428d6ca4e809193", "url": "https://github.com/infinispan/infinispan/commit/f6b4a2535891b7d49eb61421a428d6ca4e809193", "message": "ISPN-10898 Add Blockound to test suite to make sure cpu threads are never blocked", "committedDate": "2020-02-24T17:06:35Z", "type": "commit"}, {"oid": "f6b4a2535891b7d49eb61421a428d6ca4e809193", "url": "https://github.com/infinispan/infinispan/commit/f6b4a2535891b7d49eb61421a428d6ca4e809193", "message": "ISPN-10898 Add Blockound to test suite to make sure cpu threads are never blocked", "committedDate": "2020-02-24T17:06:35Z", "type": "forcePushed"}]}