{"pr_number": 8235, "pr_title": "ISPN-11624 Server Patch Tool", "pr_createdAt": "2020-04-23T14:37:47Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8235", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAyOTg2NQ==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r414029865", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (commons.length != 1) {\n          \n          \n            \n                  if (commons == null || commons.length != 1) {\n          \n      \n    \n    \n  \n\ncommons can be null if you set the wrong path it can't find the commons.", "author": "pruivo", "createdAt": "2020-04-23T18:32:47Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,470 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Properties targetProperties = getVersionProperties(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetProperties, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Properties targetProperties = getVersionProperties(target);\n+      String version = targetProperties.getProperty(\"infinispan.version\");\n+      String brandName = targetProperties.getProperty(\"infinispan.brand.name\");\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());\n+            return;\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();\n+      } catch (IOException e) {\n+         throw MSG.patchCannotRead(patchesFile, e);\n+      }\n+   }\n+\n+   private void writeInstalledPatches(Path target, List<PatchInfo> patches) {\n+      try (OutputStream os = Files.newOutputStream(Files.createDirectories(target.resolve(PATCHES_DIR)).resolve(PATCHES_FILE), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writeValue(os, patches);\n+      } catch (IOException e) {\n+         throw MSG.patchCannotWritePatchesFile(e);\n+      }\n+   }\n+\n+   private void createSinglePatch(String qualifier, Path source, Path target, Properties targetProperties, Map<Path, ServerFile> targetFiles, FileSystem zipfs) throws IOException {\n+      Properties sourceProperties = getVersionProperties(source);\n+\n+      // Ensure that the brand name coincides\n+      if (!sourceProperties.getProperty(\"infinispan.brand.name\").equals(targetProperties.getProperty(\"infinispan.brand.name\"))) {\n+         throw MSG.patchIncompatibleProduct(sourceProperties.getProperty(\"infinispan.brand.name\"), targetProperties.getProperty(\"infinispan.brand.name\"));\n+      }\n+\n+      PatchInfo patchInfo = new PatchInfo(sourceProperties.getProperty(\"infinispan.brand.name\"), sourceProperties.getProperty(\"infinispan.version\"), targetProperties.getProperty(\"infinispan.version\"), qualifier);\n+\n+      // Build a list of files in the old version\n+      Map<Path, ServerFile> v1Files = getServerFiles(source);\n+\n+      // Compare the two file lists, generating a list of upgrade instructions\n+      List<PatchOperation> operations = patchInfo.getOperations();\n+      v1Files.forEach((k1, v1File) -> {\n+         if (!targetFiles.containsKey(k1)) {\n+            operations.add(PatchOperation.remove(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions()));\n+         } else {\n+            ServerFile targetFile = targetFiles.get(k1);\n+            if (!v1File.getFilename().equals(targetFile.getFilename())) { // Different filename means upgrade\n+               operations.add(PatchOperation.upgrade(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            } else { // Check contents\n+               try {\n+                  if (!compareFileContents(source.resolve(v1File.getVersionedPath()), target.resolve(targetFile.getVersionedPath()))) {\n+                     operations.add(PatchOperation.replace(targetFile.isSoft(), targetFile.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getDigest(), targetFile.getPermissions()));\n+                     addFileToZip(zipfs, target, targetFile);\n+                  }\n+               } catch (IOException e) {\n+                  throw new RuntimeException(e);\n+               }\n+            }\n+         }\n+      });\n+      targetFiles.forEach((k2, targetFile) -> {\n+         if (!v1Files.containsKey(k2)) {\n+            operations.add(PatchOperation.add(targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+            addFileToZip(zipfs, target, targetFile);\n+         }\n+      });\n+\n+      // Write out the JSON patch file\n+      Path patchPath = zipfs.getPath(\"patch-\" + patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion() + \".json\");\n+      try (OutputStream os = Files.newOutputStream(patchPath, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writerWithDefaultPrettyPrinter().writeValue(os, patchInfo);\n+      }\n+   }\n+\n+   private Map<Path, ServerFile> getServerFiles(Path base) throws IOException {\n+      Pattern IGNORE = Pattern.compile(\"^(\\\\.patches/|server/data/|server/log/|server/lib/).*$\");\n+      Pattern SOFT_REPLACE_PATTERN = Pattern.compile(\"^server/conf/.*$\");\n+      Map<Path, ServerFile> files = new TreeMap<>();\n+      Files.walkFileTree(base, new SimpleFileVisitor<Path>() {\n+         @Override\n+         public FileVisitResult visitFile(Path oPath, BasicFileAttributes attrs) {\n+            Path rPath = base.relativize(oPath);\n+            String rPathName = rPath.toString();\n+            if (!IGNORE.matcher(rPathName).matches()) {\n+               ServerFile file = new ServerFile(rPath, sha256(oPath), getPermissions(oPath), SOFT_REPLACE_PATTERN.matcher(rPathName).matches());\n+               files.put(file.getUnversionedPath(), file);\n+            }\n+            return FileVisitResult.CONTINUE;\n+         }\n+      });\n+      return files;\n+   }\n+\n+   private static String getPermissions(Path path) {\n+      try {\n+         return PosixFilePermissions.toString(Files.getPosixFilePermissions(path));\n+      } catch (IOException e) {\n+         throw new RuntimeException(e);\n+      }\n+   }\n+\n+   private List<PatchInfo> getPatchInfos(FileSystem zipfs) throws IOException {\n+      List<Path> paths = Files.find(zipfs.getPath(\"/\"), 1,\n+            (p, a) -> a.isRegularFile() && p.getFileName().toString().startsWith(\"patch-\") && p.getFileName().toString().endsWith(\".json\")\n+      ).collect(Collectors.toList());\n+      List<PatchInfo> infos = new ArrayList<>(paths.size());\n+      for (Path path : paths) {\n+         try (InputStream is = Files.newInputStream(path, StandardOpenOption.READ)) {\n+            infos.add(mapper.readValue(is, PatchInfo.class));\n+         }\n+      }\n+      return infos;\n+   }\n+\n+   private Properties getVersionProperties(Path base) throws IOException {\n+      // Load the META-INF/infinispan-version.properties from the lib/infinispan-commons jar\n+      Path lib = base.resolve(\"lib\");\n+      File[] commons = lib.toFile().listFiles((dir, name) -> name.startsWith(\"infinispan-commons-\") && name.endsWith(\".jar\"));\n+      if (commons.length != 1) {", "originalCommit": "c605dc4b2fd321263528e2a4caf437ab822dc233", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8b81ee40e5c62da11e5104bbf304258e8f67e7e6", "url": "https://github.com/infinispan/infinispan/commit/8b81ee40e5c62da11e5104bbf304258e8f67e7e6", "message": "ISPN-11624 Server Patch Tool", "committedDate": "2020-04-27T09:06:12Z", "type": "forcePushed"}, {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4", "url": "https://github.com/infinispan/infinispan/commit/06934bfb7021035ccfd0eceb3c92579cc59063c4", "message": "ISPN-11624 Server Patch Tool", "committedDate": "2020-04-27T09:46:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyNDM0MA==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415724340", "bodyText": "why this change?", "author": "pruivo", "createdAt": "2020-04-27T11:14:53Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/CliCommand.java", "diffHunk": "@@ -28,7 +28,7 @@\n    public CommandResult execute(ContextAwareCommandInvocation invocation) throws CommandException {\n       if (help) {\n          invocation.println(invocation.getHelpInfo());\n-         return CommandResult.SUCCESS;\n+         return CommandResult.FAILURE;", "originalCommit": "06934bfb7021035ccfd0eceb3c92579cc59063c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc0Nzk3NA==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415747974", "bodyText": "My mistake. I thought Unix commands returned failures when invoked with the help switch. Instead they all return 0, so I'll revert this.", "author": "tristantarrant", "createdAt": "2020-04-27T11:54:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyNDM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyNDY4Mw==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415724683", "bodyText": "print help message?", "author": "pruivo", "createdAt": "2020-04-27T11:15:30Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/Patch.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package org.infinispan.cli.commands;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import org.aesh.command.Command;\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.impl.completer.FileOptionCompleter;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Arguments;\n+import org.aesh.command.option.Option;\n+import org.aesh.io.Resource;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.logging.Messages;\n+import org.infinispan.cli.patching.PatchTool;\n+import org.kohsuke.MetaInfServices;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+@MetaInfServices(Command.class)\n+@GroupCommandDefinition(name = Patch.CMD, description = \"Patch operations\", groupCommands = {Patch.Create.class, Patch.Describe.class, Patch.Install.class, Patch.Ls.class, Patch.Rollback.class})\n+public class Patch extends CliCommand {\n+\n+   public static final String CMD = \"patch\";\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation commandInvocation) {\n+      // This command serves only to wrap the sub-commands", "originalCommit": "06934bfb7021035ccfd0eceb3c92579cc59063c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc1MDg4OA==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415750888", "bodyText": "Only if you call it with -h", "author": "tristantarrant", "createdAt": "2020-04-27T11:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyNDY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgxMTQ5OQ==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415811499", "bodyText": "Actually, I'll do that", "author": "tristantarrant", "createdAt": "2020-04-27T13:27:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyNDY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyNjQ5NA==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415726494", "bodyText": "exception handling is missing in all subcommands", "author": "pruivo", "createdAt": "2020-04-27T11:18:36Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/Patch.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package org.infinispan.cli.commands;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import org.aesh.command.Command;\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.impl.completer.FileOptionCompleter;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Arguments;\n+import org.aesh.command.option.Option;\n+import org.aesh.io.Resource;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.logging.Messages;\n+import org.infinispan.cli.patching.PatchTool;\n+import org.kohsuke.MetaInfServices;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+@MetaInfServices(Command.class)\n+@GroupCommandDefinition(name = Patch.CMD, description = \"Patch operations\", groupCommands = {Patch.Create.class, Patch.Describe.class, Patch.Install.class, Patch.Ls.class, Patch.Rollback.class})\n+public class Patch extends CliCommand {\n+\n+   public static final String CMD = \"patch\";\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation commandInvocation) {\n+      // This command serves only to wrap the sub-commands\n+      return CommandResult.FAILURE;\n+   }\n+\n+   @CommandDefinition(name = Create.CMD, description = \"Creates a patch archive\")\n+   public static class Create extends CliCommand {\n+      public static final String CMD = \"create\";\n+\n+      @Option(defaultValue = \"\", shortName = 'q', description = \"A qualifier for this patch (e.g. `one-off`)\")\n+      String qualifier;\n+\n+      @Arguments(completer = FileOptionCompleter.class, description = \"The path to the patch archive, the path to the target server and one or more paths to the source servers\")\n+      List<Resource> paths;\n+\n+      @Override\n+      public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+         if (paths.size() < 3) {\n+            throw Messages.MSG.patchCreateArgumentsRequired();\n+         }\n+         PatchTool patchTool = new PatchTool(invocation.getShellOutput(), invocation.getShellError());\n+         try {\n+            Path patch = Paths.get(paths.get(0).getAbsolutePath());\n+            Path target = Paths.get(paths.get(1).getAbsolutePath());\n+            Path sources[] = new Path[paths.size() - 2];\n+            for (int i = 2; i < paths.size(); i++) {\n+               sources[i - 2] = Paths.get(paths.get(i).getAbsolutePath());\n+            }\n+            patchTool.createPatch(qualifier, patch, target, sources);\n+            return CommandResult.SUCCESS;\n+         } catch (IOException e) {\n+            throw new RuntimeException(e);", "originalCommit": "06934bfb7021035ccfd0eceb3c92579cc59063c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg5OTQyNA==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415899424", "bodyText": "Fixed", "author": "tristantarrant", "createdAt": "2020-04-27T15:13:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyNjQ5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczMDQwMw==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415730403", "bodyText": "print the errors? org.infinispan.cli.patching.PatchTool#installPatch() isn't printing the error list.", "author": "pruivo", "createdAt": "2020-04-27T11:24:56Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/logging/Messages.java", "diffHunk": "@@ -92,4 +95,64 @@\n \n    @Message(\"Invalid resource '%s'\")\n    IllegalArgumentException invalidResource(String name);\n+\n+   @Message(\"No patches installed\")\n+   String patchNoPatchesInstalled();\n+\n+   @Message(\"%s\")\n+   String patchInfo(PatchInfo patchInfo);\n+\n+   @Message(\"The supplied patch cannot be applied to %s %s\")\n+   IllegalStateException patchCannotApply(String brandName, String version);\n+\n+   @Message(\"File %s SHA mismatch. Expected = %s, Actual = %s\")\n+   String patchShaMismatch(Path path, String digest, String sha256);\n+\n+   @Message(\"The following errors were encountered while validating local installation:\")\n+   String patchValidationErrors();", "originalCommit": "06934bfb7021035ccfd0eceb3c92579cc59063c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg5OTMxMA==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415899310", "bodyText": "Fixed", "author": "tristantarrant", "createdAt": "2020-04-27T15:12:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczMDQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczMTYyNQ==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415731625", "bodyText": "maybe add the filename?", "author": "pruivo", "createdAt": "2020-04-27T11:26:58Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/logging/Messages.java", "diffHunk": "@@ -92,4 +95,64 @@\n \n    @Message(\"Invalid resource '%s'\")\n    IllegalArgumentException invalidResource(String name);\n+\n+   @Message(\"No patches installed\")\n+   String patchNoPatchesInstalled();\n+\n+   @Message(\"%s\")\n+   String patchInfo(PatchInfo patchInfo);\n+\n+   @Message(\"The supplied patch cannot be applied to %s %s\")\n+   IllegalStateException patchCannotApply(String brandName, String version);\n+\n+   @Message(\"File %s SHA mismatch. Expected = %s, Actual = %s\")\n+   String patchShaMismatch(Path path, String digest, String sha256);\n+\n+   @Message(\"The following errors were encountered while validating local installation:\")\n+   String patchValidationErrors();\n+\n+   @Message(\"No installed patches to roll back\")\n+   IllegalStateException patchNoPatchesInstalledToRollback();\n+\n+   @Message(\"Cannot find the infinispan-commons jar under %s\")\n+   IllegalStateException patchCannotFindCommons(Path lib);\n+\n+   @Message(\"Cannot create patch %s with patches for %s\")\n+   IllegalStateException patchIncompatibleProduct(String localBrand, String patchBrand);\n+\n+   @Message(\"Could not write patches file\")\n+   IllegalStateException patchCannotWritePatchesFile(@Cause IOException e);\n+\n+   @Message(\"Rolled back patch %s\")\n+   String patchRollback(PatchInfo patchInfo);\n+\n+   @Message(\"[Dry run] \")\n+   String patchDryRun();\n+\n+   @Message(\"Backing up '%s' to '%s'\")\n+   String patchBackup(Path from, Path to);\n+\n+   @Message(\"Error while creating patch\")\n+   RuntimeException patchCreateError(@Cause IOException e);", "originalCommit": "06934bfb7021035ccfd0eceb3c92579cc59063c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg2MjczOA==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415862738", "bodyText": "It's already in the exception message", "author": "tristantarrant", "createdAt": "2020-04-27T14:30:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczMTYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczMjA2Ng==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415732066", "bodyText": "maybe add the destination path?", "author": "pruivo", "createdAt": "2020-04-27T11:27:42Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/logging/Messages.java", "diffHunk": "@@ -92,4 +95,64 @@\n \n    @Message(\"Invalid resource '%s'\")\n    IllegalArgumentException invalidResource(String name);\n+\n+   @Message(\"No patches installed\")\n+   String patchNoPatchesInstalled();\n+\n+   @Message(\"%s\")\n+   String patchInfo(PatchInfo patchInfo);\n+\n+   @Message(\"The supplied patch cannot be applied to %s %s\")\n+   IllegalStateException patchCannotApply(String brandName, String version);\n+\n+   @Message(\"File %s SHA mismatch. Expected = %s, Actual = %s\")\n+   String patchShaMismatch(Path path, String digest, String sha256);\n+\n+   @Message(\"The following errors were encountered while validating local installation:\")\n+   String patchValidationErrors();\n+\n+   @Message(\"No installed patches to roll back\")\n+   IllegalStateException patchNoPatchesInstalledToRollback();\n+\n+   @Message(\"Cannot find the infinispan-commons jar under %s\")\n+   IllegalStateException patchCannotFindCommons(Path lib);\n+\n+   @Message(\"Cannot create patch %s with patches for %s\")\n+   IllegalStateException patchIncompatibleProduct(String localBrand, String patchBrand);\n+\n+   @Message(\"Could not write patches file\")\n+   IllegalStateException patchCannotWritePatchesFile(@Cause IOException e);", "originalCommit": "06934bfb7021035ccfd0eceb3c92579cc59063c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc2NTQ4Ng==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415765486", "bodyText": "unused", "author": "pruivo", "createdAt": "2020-04-27T12:22:19Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/completers/FileOptionCompleter.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.infinispan.cli.completers;\n+\n+import org.aesh.command.completer.CompleterInvocation;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class FileOptionCompleter extends org.aesh.command.impl.completer.FileOptionCompleter {", "originalCommit": "06934bfb7021035ccfd0eceb3c92579cc59063c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk2MjQxNg==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415962416", "bodyText": "Removed", "author": "tristantarrant", "createdAt": "2020-04-27T16:28:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc2NTQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc3NTY0NA==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415775644", "bodyText": "remove?", "author": "pruivo", "createdAt": "2020-04-27T12:37:56Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/ServerFile.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.infinispan.cli.patching;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class ServerFile implements Comparable<ServerFile> {\n+   private final Path directory;\n+   private final String filename;\n+   private final String basename;\n+   private final String digest;\n+   private final String permissions;\n+   private final boolean soft;\n+\n+   public ServerFile(Path path, String digest, String permissions, boolean soft) {\n+      this.directory = path.getParent();\n+      this.filename = path.getFileName().toString();\n+      this.basename = basename(filename);\n+      this.digest = digest;\n+      this.permissions = permissions;\n+      this.soft = soft;\n+   }\n+\n+   @Override\n+   public String toString() {\n+      return \"ServerFile{\" +\n+            \"directory=\" + directory +\n+            \", filename='\" + filename + '\\'' +\n+            \", basename='\" + basename + '\\'' +\n+            \", permissions='\" + permissions + '\\'' +\n+            \", soft=\" + soft +\n+            '}';\n+   }\n+\n+   private static String basename(String filename) {\n+      int l = filename.length();\n+      for (int i = 0; i < l; i++) {\n+         char c = filename.charAt(i);\n+         if (c == '-' && i < l - 1) {\n+            c = filename.charAt(i + 1);\n+            if (c >= '0' && c <= '9') {\n+               return filename.substring(0, i);\n+            }\n+         }\n+      }\n+      // Could not obtain an artifact\n+      return filename;\n+   }\n+\n+   public String getFilename() {\n+      return filename;\n+   }\n+\n+   public String getDigest() {\n+      return digest;\n+   }\n+\n+   public String getPermissions() {\n+      return permissions;\n+   }\n+\n+   Path getVersionedPath() {\n+      return directory != null ? directory.resolve(filename) : Paths.get(filename);\n+   }\n+\n+   Path getUnversionedPath() {\n+      return directory != null ? directory.resolve(basename) : Paths.get(basename);\n+   }\n+\n+   public boolean isSoft() {\n+      return soft;\n+   }\n+\n+   @Override\n+   public int compareTo(ServerFile other) {", "originalCommit": "06934bfb7021035ccfd0eceb3c92579cc59063c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk2MzMwOA==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415963308", "bodyText": "Done", "author": "tristantarrant", "createdAt": "2020-04-27T16:29:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc3NTY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc4NDM4Mg==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415784382", "bodyText": "may I suggest o open patch.json and validate if the content is correct?", "author": "pruivo", "createdAt": "2020-04-27T12:50:47Z", "path": "cli/cli-client/src/test/java/org/infinispan/cli/patching/PatchToolTest.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.BufferedWriter;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Collections;\n+import java.util.Properties;\n+\n+import org.infinispan.commons.test.CommonsTestingUtil;\n+import org.infinispan.commons.test.Exceptions;\n+import org.infinispan.commons.util.Util;\n+import org.junit.Test;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchToolTest {\n+\n+   @Test\n+   public void testPatchToolCreate() throws IOException {\n+      Path tmp = Paths.get(CommonsTestingUtil.tmpDirectory(PatchToolTest.class));\n+      Util.recursiveFileRemove(tmp.toFile());\n+      Files.createDirectories(tmp);\n+      Util.recursiveDirectoryCopy(new File(\"target/test-classes/patch\").toPath(), tmp);\n+\n+      // Create the infinispan-commons jars that identify a server's version\n+      Path v1 = tmp.resolve(\"v1\");\n+      createFakeInfinispanCommons(v1, \"Infinispan\", \"1.0.0.Final\");\n+      Path v2 = tmp.resolve(\"v2\");\n+      createFakeInfinispanCommons(v2, \"Infinispan\", \"1.0.1.Final\");\n+      Path v3 = tmp.resolve(\"v3\");\n+      createFakeInfinispanCommons(v3, \"Infinispan\", \"1.1.0.Final\");\n+\n+      ByteArrayOutputStream out = new ByteArrayOutputStream();\n+      ByteArrayOutputStream err = new ByteArrayOutputStream();\n+\n+      PatchTool patchTool = new PatchTool(new PrintStream(out), new PrintStream(err));\n+\n+      // List the installed patches on v1\n+      patchTool.listPatches(v1, false);\n+      assertContains(out, \"No patches installed\");\n+      assertEmpty(err);\n+      out.reset();\n+\n+      // Create a patch zip that can patch v1 and v2 to v3\n+      Path patch = Paths.get(\"target/patch.zip\");\n+      patch.toFile().delete();\n+      patchTool.createPatch(\"\", patch, v3, v1, v2);\n+      assertContains(out, \"Adding \");\n+      assertEmpty(err);\n+      out.reset();\n+\n+      // Attempting to create the patch file again should fail\n+      Exceptions.expectException(FileAlreadyExistsException.class, () -> patchTool.createPatch(\"\", patch, v3, v1, v2));\n+\n+      // Ensure the zip file does not contain the .patches directory IGNOREME.txt files", "originalCommit": "06934bfb7021035ccfd0eceb3c92579cc59063c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk2Mjc0Nw==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415962747", "bodyText": "I think it's better to trust patch ls for that", "author": "tristantarrant", "createdAt": "2020-04-27T16:28:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc4NDM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc4NzAzNQ==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415787035", "bodyText": "print errors?", "author": "pruivo", "createdAt": "2020-04-27T12:54:35Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());", "originalCommit": "06934bfb7021035ccfd0eceb3c92579cc59063c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk2Mjg4MQ==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415962881", "bodyText": "Fixed", "author": "tristantarrant", "createdAt": "2020-04-27T16:28:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc4NzAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc4OTIzNw==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415789237", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (installedPatches.size() == 0) {\n          \n          \n            \n                  if (installedPatches.isEmpty()) {", "author": "pruivo", "createdAt": "2020-04-27T12:57:29Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {", "originalCommit": "06934bfb7021035ccfd0eceb3c92579cc59063c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5MTExOQ==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415791119", "bodyText": "sha256 is null if the file doesn't exist.\nthe install should be aborted.", "author": "pruivo", "createdAt": "2020-04-27T13:00:06Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {", "originalCommit": "06934bfb7021035ccfd0eceb3c92579cc59063c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5MTUyOQ==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415791529", "bodyText": "check for null. sha256 is null if the file doesn't exist", "author": "pruivo", "createdAt": "2020-04-27T13:00:40Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());\n+            return;\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {", "originalCommit": "06934bfb7021035ccfd0eceb3c92579cc59063c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5MjQ3Mg==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415792472", "bodyText": "protect against null (as described above)", "author": "pruivo", "createdAt": "2020-04-27T13:01:58Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());\n+            return;\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256.equals(operation.getDigest())) {", "originalCommit": "06934bfb7021035ccfd0eceb3c92579cc59063c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5Mjk2Ng==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415792966", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     return new ArrayList<>();\n          \n          \n            \n                     return Collections.emptyList();", "author": "pruivo", "createdAt": "2020-04-27T13:02:42Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());\n+            return;\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();", "originalCommit": "06934bfb7021035ccfd0eceb3c92579cc59063c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMzg0NQ==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415833845", "bodyText": "Nope, because I need to manipulate the list in case of installation.", "author": "tristantarrant", "createdAt": "2020-04-27T13:55:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5Mjk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5Mzc5MA==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415793790", "bodyText": "not sure if the permission is needed.", "author": "pruivo", "createdAt": "2020-04-27T13:03:51Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());\n+            return;\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();\n+      } catch (IOException e) {\n+         throw MSG.patchCannotRead(patchesFile, e);\n+      }\n+   }\n+\n+   private void writeInstalledPatches(Path target, List<PatchInfo> patches) {\n+      try (OutputStream os = Files.newOutputStream(Files.createDirectories(target.resolve(PATCHES_DIR)).resolve(PATCHES_FILE), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writeValue(os, patches);\n+      } catch (IOException e) {\n+         throw MSG.patchCannotWritePatchesFile(e);\n+      }\n+   }\n+\n+   private void createSinglePatch(String qualifier, Path source, Path target, Version targetVersion, Map<Path, ServerFile> targetFiles, FileSystem zipfs) throws IOException {\n+      Version sourceVersion = getVersion(source);\n+\n+      // Ensure that the brand name coincides\n+      String sourceBrand = sourceVersion.brandName();\n+      String targetBrand = targetVersion.brandName();\n+      if (!sourceBrand.equals(targetBrand)) {\n+         throw MSG.patchIncompatibleProduct(sourceBrand, targetBrand);\n+      }\n+\n+      if (sourceVersion.version().equals(targetVersion.version())) {\n+         throw MSG.patchServerAndTargetMustBeDifferent(sourceVersion.version());\n+      }\n+\n+      PatchInfo patchInfo = new PatchInfo(sourceBrand, sourceVersion.version(), targetVersion.version(), qualifier);\n+\n+      // Build a list of files in the old version\n+      Map<Path, ServerFile> v1Files = getServerFiles(source);\n+\n+      // Compare the two file lists, generating a list of upgrade instructions\n+      List<PatchOperation> operations = patchInfo.getOperations();\n+      v1Files.forEach((k1, v1File) -> {\n+         if (!targetFiles.containsKey(k1)) {\n+            operations.add(PatchOperation.remove(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions()));", "originalCommit": "06934bfb7021035ccfd0eceb3c92579cc59063c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk2MzA5OA==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415963098", "bodyText": "I collect them all :)", "author": "tristantarrant", "createdAt": "2020-04-27T16:28:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5Mzc5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5NDMzMA==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415794330", "bodyText": "can't you just compare the digest instead of doing a binary check?", "author": "pruivo", "createdAt": "2020-04-27T13:04:41Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());\n+            return;\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();\n+      } catch (IOException e) {\n+         throw MSG.patchCannotRead(patchesFile, e);\n+      }\n+   }\n+\n+   private void writeInstalledPatches(Path target, List<PatchInfo> patches) {\n+      try (OutputStream os = Files.newOutputStream(Files.createDirectories(target.resolve(PATCHES_DIR)).resolve(PATCHES_FILE), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writeValue(os, patches);\n+      } catch (IOException e) {\n+         throw MSG.patchCannotWritePatchesFile(e);\n+      }\n+   }\n+\n+   private void createSinglePatch(String qualifier, Path source, Path target, Version targetVersion, Map<Path, ServerFile> targetFiles, FileSystem zipfs) throws IOException {\n+      Version sourceVersion = getVersion(source);\n+\n+      // Ensure that the brand name coincides\n+      String sourceBrand = sourceVersion.brandName();\n+      String targetBrand = targetVersion.brandName();\n+      if (!sourceBrand.equals(targetBrand)) {\n+         throw MSG.patchIncompatibleProduct(sourceBrand, targetBrand);\n+      }\n+\n+      if (sourceVersion.version().equals(targetVersion.version())) {\n+         throw MSG.patchServerAndTargetMustBeDifferent(sourceVersion.version());\n+      }\n+\n+      PatchInfo patchInfo = new PatchInfo(sourceBrand, sourceVersion.version(), targetVersion.version(), qualifier);\n+\n+      // Build a list of files in the old version\n+      Map<Path, ServerFile> v1Files = getServerFiles(source);\n+\n+      // Compare the two file lists, generating a list of upgrade instructions\n+      List<PatchOperation> operations = patchInfo.getOperations();\n+      v1Files.forEach((k1, v1File) -> {\n+         if (!targetFiles.containsKey(k1)) {\n+            operations.add(PatchOperation.remove(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions()));\n+         } else {\n+            ServerFile targetFile = targetFiles.get(k1);\n+            if (!v1File.getFilename().equals(targetFile.getFilename())) { // Different filename means upgrade\n+               operations.add(PatchOperation.upgrade(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            } else { // Check contents\n+               try {\n+                  if (!compareFileContents(source.resolve(v1File.getVersionedPath()), target.resolve(targetFile.getVersionedPath()))) {", "originalCommit": "06934bfb7021035ccfd0eceb3c92579cc59063c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzNjY2NQ==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415836665", "bodyText": "Very stupid of me :)", "author": "tristantarrant", "createdAt": "2020-04-27T13:59:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5NDMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5ODQ2Mg==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415798462", "bodyText": "unnecessary ;", "author": "pruivo", "createdAt": "2020-04-27T13:10:26Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());\n+            return;\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();\n+      } catch (IOException e) {\n+         throw MSG.patchCannotRead(patchesFile, e);\n+      }\n+   }\n+\n+   private void writeInstalledPatches(Path target, List<PatchInfo> patches) {\n+      try (OutputStream os = Files.newOutputStream(Files.createDirectories(target.resolve(PATCHES_DIR)).resolve(PATCHES_FILE), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writeValue(os, patches);\n+      } catch (IOException e) {\n+         throw MSG.patchCannotWritePatchesFile(e);\n+      }\n+   }\n+\n+   private void createSinglePatch(String qualifier, Path source, Path target, Version targetVersion, Map<Path, ServerFile> targetFiles, FileSystem zipfs) throws IOException {\n+      Version sourceVersion = getVersion(source);\n+\n+      // Ensure that the brand name coincides\n+      String sourceBrand = sourceVersion.brandName();\n+      String targetBrand = targetVersion.brandName();\n+      if (!sourceBrand.equals(targetBrand)) {\n+         throw MSG.patchIncompatibleProduct(sourceBrand, targetBrand);\n+      }\n+\n+      if (sourceVersion.version().equals(targetVersion.version())) {\n+         throw MSG.patchServerAndTargetMustBeDifferent(sourceVersion.version());\n+      }\n+\n+      PatchInfo patchInfo = new PatchInfo(sourceBrand, sourceVersion.version(), targetVersion.version(), qualifier);\n+\n+      // Build a list of files in the old version\n+      Map<Path, ServerFile> v1Files = getServerFiles(source);\n+\n+      // Compare the two file lists, generating a list of upgrade instructions\n+      List<PatchOperation> operations = patchInfo.getOperations();\n+      v1Files.forEach((k1, v1File) -> {\n+         if (!targetFiles.containsKey(k1)) {\n+            operations.add(PatchOperation.remove(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions()));\n+         } else {\n+            ServerFile targetFile = targetFiles.get(k1);\n+            if (!v1File.getFilename().equals(targetFile.getFilename())) { // Different filename means upgrade\n+               operations.add(PatchOperation.upgrade(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            } else { // Check contents\n+               try {\n+                  if (!compareFileContents(source.resolve(v1File.getVersionedPath()), target.resolve(targetFile.getVersionedPath()))) {\n+                     operations.add(PatchOperation.replace(targetFile.isSoft(), targetFile.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getDigest(), targetFile.getPermissions()));\n+                     addFileToZip(zipfs, target, targetFile);\n+                  }\n+               } catch (IOException e) {\n+                  throw new RuntimeException(e);\n+               }\n+            }\n+         }\n+      });\n+      targetFiles.forEach((k2, targetFile) -> {\n+         if (!v1Files.containsKey(k2)) {\n+            operations.add(PatchOperation.add(targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+            addFileToZip(zipfs, target, targetFile);\n+         }\n+      });\n+\n+      // Write out the JSON patch file\n+      Path patchPath = zipfs.getPath(\"patch-\" + patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion() + \".json\");\n+      try (OutputStream os = Files.newOutputStream(patchPath, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writerWithDefaultPrettyPrinter().writeValue(os, patchInfo);\n+      }\n+   }\n+\n+   private Map<Path, ServerFile> getServerFiles(Path base) throws IOException {\n+      Pattern IGNORE = Pattern.compile(\"^(\\\\.patches/|server/data/|server/log/|server/lib/).*$\");\n+      Pattern SOFT_REPLACE_PATTERN = Pattern.compile(\"^server/conf/.*$\");\n+      Map<Path, ServerFile> files = new TreeMap<>();\n+      Files.walkFileTree(base, new SimpleFileVisitor<Path>() {\n+         @Override\n+         public FileVisitResult visitFile(Path oPath, BasicFileAttributes attrs) {\n+            Path rPath = base.relativize(oPath);\n+            String rPathName = rPath.toString();\n+            if (!IGNORE.matcher(rPathName).matches()) {\n+               ServerFile file = new ServerFile(rPath, sha256(oPath), getPermissions(oPath), SOFT_REPLACE_PATTERN.matcher(rPathName).matches());\n+               files.put(file.getUnversionedPath(), file);\n+            }\n+            return FileVisitResult.CONTINUE;\n+         }\n+      });\n+      return files;\n+   }\n+\n+   private static String getPermissions(Path path) {\n+      try {\n+         return PosixFilePermissions.toString(Files.getPosixFilePermissions(path));\n+      } catch (IOException e) {\n+         throw new RuntimeException(e);\n+      }\n+   }\n+\n+   private List<PatchInfo> getPatchInfos(FileSystem zipfs) throws IOException {\n+      List<Path> paths = Files.find(zipfs.getPath(\"/\"), 1,\n+            (p, a) -> a.isRegularFile() && p.getFileName().toString().startsWith(\"patch-\") && p.getFileName().toString().endsWith(\".json\")\n+      ).collect(Collectors.toList());\n+      List<PatchInfo> infos = new ArrayList<>(paths.size());\n+      for (Path path : paths) {\n+         try (InputStream is = Files.newInputStream(path, StandardOpenOption.READ)) {\n+            infos.add(mapper.readValue(is, PatchInfo.class));\n+         }\n+      }\n+      return infos;\n+   }\n+\n+   private Version getVersion(Path base) throws IOException {\n+      // Load the META-INF/infinispan-version.properties from the lib/infinispan-commons jar\n+      Path lib = base.resolve(\"lib\");\n+      File[] commons = lib.toFile().listFiles((dir, name) -> name.startsWith(\"infinispan-commons-\") && name.endsWith(\".jar\"));\n+      if (commons == null || commons.length != 1) {\n+         throw MSG.patchCannotFindCommons(lib);\n+      }\n+      URI jarUri = URI.create(\"jar:\" + commons[0].toURI().toString());\n+      try (FileSystem zipfs = FileSystems.newFileSystem(jarUri, Collections.emptyMap()); InputStream in = Files.newInputStream(zipfs.getPath(\"META-INF\", \"infinispan-version.properties\"))) {\n+         return Version.from(in);\n+      }\n+   }\n+\n+\n+   private FileSystem getPatchFile(Path patch, boolean create) throws IOException {\n+      if (create && patch.toFile().exists()) {\n+         throw MSG.patchFileAlreadyExists(patch);\n+      }\n+      URI jarUri = URI.create(\"jar:\" + patch.toUri().toString());\n+      return FileSystems.newFileSystem(jarUri, create ? Collections.singletonMap(\"create\", \"true\") : Collections.emptyMap());\n+   }\n+\n+   private FileSystem getPatchFile(Path patch) throws IOException {\n+      return getPatchFile(patch, false);\n+   }\n+\n+   private void addFileToZip(FileSystem zipfs, Path basePath, ServerFile file) {\n+      try {\n+         Path target = zipfs.getPath(file.getVersionedPath().toString());\n+         out.println(MSG.patchCreateAdd(target));\n+         if (target.getParent() != null) {\n+            Files.createDirectories(target.getParent());\n+         }\n+         Files.copy(basePath.resolve(file.getVersionedPath()), target, StandardCopyOption.REPLACE_EXISTING);\n+      } catch (IOException e) {\n+         throw MSG.patchCreateError(e);\n+      }\n+   }\n+\n+   private static boolean compareFileContents(Path path, Path path2) throws IOException {\n+      if (Files.isSameFile(path, path2)) {\n+         return true;\n+      }\n+      byte[] buffer1 = new byte[BUFFER_SIZE];\n+      byte[] buffer2 = new byte[BUFFER_SIZE];\n+      try (InputStream in1 = Files.newInputStream(path);\n+           InputStream in2 = Files.newInputStream(path2);) {", "originalCommit": "06934bfb7021035ccfd0eceb3c92579cc59063c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgwMTc2MA==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415801760", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        digest.update(buffer);\n          \n          \n            \n                        digest.update(buffer, 0, read);", "author": "pruivo", "createdAt": "2020-04-27T13:14:43Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());\n+            return;\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();\n+      } catch (IOException e) {\n+         throw MSG.patchCannotRead(patchesFile, e);\n+      }\n+   }\n+\n+   private void writeInstalledPatches(Path target, List<PatchInfo> patches) {\n+      try (OutputStream os = Files.newOutputStream(Files.createDirectories(target.resolve(PATCHES_DIR)).resolve(PATCHES_FILE), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writeValue(os, patches);\n+      } catch (IOException e) {\n+         throw MSG.patchCannotWritePatchesFile(e);\n+      }\n+   }\n+\n+   private void createSinglePatch(String qualifier, Path source, Path target, Version targetVersion, Map<Path, ServerFile> targetFiles, FileSystem zipfs) throws IOException {\n+      Version sourceVersion = getVersion(source);\n+\n+      // Ensure that the brand name coincides\n+      String sourceBrand = sourceVersion.brandName();\n+      String targetBrand = targetVersion.brandName();\n+      if (!sourceBrand.equals(targetBrand)) {\n+         throw MSG.patchIncompatibleProduct(sourceBrand, targetBrand);\n+      }\n+\n+      if (sourceVersion.version().equals(targetVersion.version())) {\n+         throw MSG.patchServerAndTargetMustBeDifferent(sourceVersion.version());\n+      }\n+\n+      PatchInfo patchInfo = new PatchInfo(sourceBrand, sourceVersion.version(), targetVersion.version(), qualifier);\n+\n+      // Build a list of files in the old version\n+      Map<Path, ServerFile> v1Files = getServerFiles(source);\n+\n+      // Compare the two file lists, generating a list of upgrade instructions\n+      List<PatchOperation> operations = patchInfo.getOperations();\n+      v1Files.forEach((k1, v1File) -> {\n+         if (!targetFiles.containsKey(k1)) {\n+            operations.add(PatchOperation.remove(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions()));\n+         } else {\n+            ServerFile targetFile = targetFiles.get(k1);\n+            if (!v1File.getFilename().equals(targetFile.getFilename())) { // Different filename means upgrade\n+               operations.add(PatchOperation.upgrade(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            } else { // Check contents\n+               try {\n+                  if (!compareFileContents(source.resolve(v1File.getVersionedPath()), target.resolve(targetFile.getVersionedPath()))) {\n+                     operations.add(PatchOperation.replace(targetFile.isSoft(), targetFile.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getDigest(), targetFile.getPermissions()));\n+                     addFileToZip(zipfs, target, targetFile);\n+                  }\n+               } catch (IOException e) {\n+                  throw new RuntimeException(e);\n+               }\n+            }\n+         }\n+      });\n+      targetFiles.forEach((k2, targetFile) -> {\n+         if (!v1Files.containsKey(k2)) {\n+            operations.add(PatchOperation.add(targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+            addFileToZip(zipfs, target, targetFile);\n+         }\n+      });\n+\n+      // Write out the JSON patch file\n+      Path patchPath = zipfs.getPath(\"patch-\" + patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion() + \".json\");\n+      try (OutputStream os = Files.newOutputStream(patchPath, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writerWithDefaultPrettyPrinter().writeValue(os, patchInfo);\n+      }\n+   }\n+\n+   private Map<Path, ServerFile> getServerFiles(Path base) throws IOException {\n+      Pattern IGNORE = Pattern.compile(\"^(\\\\.patches/|server/data/|server/log/|server/lib/).*$\");\n+      Pattern SOFT_REPLACE_PATTERN = Pattern.compile(\"^server/conf/.*$\");\n+      Map<Path, ServerFile> files = new TreeMap<>();\n+      Files.walkFileTree(base, new SimpleFileVisitor<Path>() {\n+         @Override\n+         public FileVisitResult visitFile(Path oPath, BasicFileAttributes attrs) {\n+            Path rPath = base.relativize(oPath);\n+            String rPathName = rPath.toString();\n+            if (!IGNORE.matcher(rPathName).matches()) {\n+               ServerFile file = new ServerFile(rPath, sha256(oPath), getPermissions(oPath), SOFT_REPLACE_PATTERN.matcher(rPathName).matches());\n+               files.put(file.getUnversionedPath(), file);\n+            }\n+            return FileVisitResult.CONTINUE;\n+         }\n+      });\n+      return files;\n+   }\n+\n+   private static String getPermissions(Path path) {\n+      try {\n+         return PosixFilePermissions.toString(Files.getPosixFilePermissions(path));\n+      } catch (IOException e) {\n+         throw new RuntimeException(e);\n+      }\n+   }\n+\n+   private List<PatchInfo> getPatchInfos(FileSystem zipfs) throws IOException {\n+      List<Path> paths = Files.find(zipfs.getPath(\"/\"), 1,\n+            (p, a) -> a.isRegularFile() && p.getFileName().toString().startsWith(\"patch-\") && p.getFileName().toString().endsWith(\".json\")\n+      ).collect(Collectors.toList());\n+      List<PatchInfo> infos = new ArrayList<>(paths.size());\n+      for (Path path : paths) {\n+         try (InputStream is = Files.newInputStream(path, StandardOpenOption.READ)) {\n+            infos.add(mapper.readValue(is, PatchInfo.class));\n+         }\n+      }\n+      return infos;\n+   }\n+\n+   private Version getVersion(Path base) throws IOException {\n+      // Load the META-INF/infinispan-version.properties from the lib/infinispan-commons jar\n+      Path lib = base.resolve(\"lib\");\n+      File[] commons = lib.toFile().listFiles((dir, name) -> name.startsWith(\"infinispan-commons-\") && name.endsWith(\".jar\"));\n+      if (commons == null || commons.length != 1) {\n+         throw MSG.patchCannotFindCommons(lib);\n+      }\n+      URI jarUri = URI.create(\"jar:\" + commons[0].toURI().toString());\n+      try (FileSystem zipfs = FileSystems.newFileSystem(jarUri, Collections.emptyMap()); InputStream in = Files.newInputStream(zipfs.getPath(\"META-INF\", \"infinispan-version.properties\"))) {\n+         return Version.from(in);\n+      }\n+   }\n+\n+\n+   private FileSystem getPatchFile(Path patch, boolean create) throws IOException {\n+      if (create && patch.toFile().exists()) {\n+         throw MSG.patchFileAlreadyExists(patch);\n+      }\n+      URI jarUri = URI.create(\"jar:\" + patch.toUri().toString());\n+      return FileSystems.newFileSystem(jarUri, create ? Collections.singletonMap(\"create\", \"true\") : Collections.emptyMap());\n+   }\n+\n+   private FileSystem getPatchFile(Path patch) throws IOException {\n+      return getPatchFile(patch, false);\n+   }\n+\n+   private void addFileToZip(FileSystem zipfs, Path basePath, ServerFile file) {\n+      try {\n+         Path target = zipfs.getPath(file.getVersionedPath().toString());\n+         out.println(MSG.patchCreateAdd(target));\n+         if (target.getParent() != null) {\n+            Files.createDirectories(target.getParent());\n+         }\n+         Files.copy(basePath.resolve(file.getVersionedPath()), target, StandardCopyOption.REPLACE_EXISTING);\n+      } catch (IOException e) {\n+         throw MSG.patchCreateError(e);\n+      }\n+   }\n+\n+   private static boolean compareFileContents(Path path, Path path2) throws IOException {\n+      if (Files.isSameFile(path, path2)) {\n+         return true;\n+      }\n+      byte[] buffer1 = new byte[BUFFER_SIZE];\n+      byte[] buffer2 = new byte[BUFFER_SIZE];\n+      try (InputStream in1 = Files.newInputStream(path);\n+           InputStream in2 = Files.newInputStream(path2);) {\n+         while (true) {\n+            int n1 = in1.read(buffer1);\n+            int n2 = in2.read(buffer2);\n+            if (n1 != n2) {\n+               return false;\n+            }\n+            if (!Arrays.equals(buffer1, buffer2)) {\n+               return false;\n+            }\n+            if (n1 < BUFFER_SIZE) { // EOF and everything is equals\n+               return true;\n+            }\n+         }\n+      }\n+   }\n+\n+   static String sha256(Path path) {\n+      try (InputStream in = Files.newInputStream(path)) {\n+         MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n+         byte[] buffer = new byte[BUFFER_SIZE];\n+         int read = 0;\n+         do {\n+            read = in.read(buffer);\n+            digest.update(buffer);", "originalCommit": "06934bfb7021035ccfd0eceb3c92579cc59063c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgwNjIxNA==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415806214", "bodyText": "I guess you could use the MapByteBuffer directly since the files should be small, and do something like this:\n      try (FileChannel f = (FileChannel) Files.newByteChannel(path, StandardOpenOption.READ)) {\n         MappedByteBuffer byteBuffer = f.map(FileChannel.MapMode.READ_ONLY, 0, f.size());\n         MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n         digest.update(byteBuffer);\n         return Util.toHexString(digest.digest());\n      } catch (IOException | NoSuchAlgorithmException e) {\n         e.printStackTrace();\n      }", "author": "pruivo", "createdAt": "2020-04-27T13:20:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgwMTc2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzOTIyMw==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415839223", "bodyText": "Nice one", "author": "tristantarrant", "createdAt": "2020-04-27T14:02:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgwMTc2MA=="}], "type": "inlineReview"}, {"oid": "1a7a755941977b5fe35c4757ca99688b1ce3b219", "url": "https://github.com/infinispan/infinispan/commit/1a7a755941977b5fe35c4757ca99688b1ce3b219", "message": "ISPN-11624 Server Patch Tool", "committedDate": "2020-04-27T15:02:56Z", "type": "forcePushed"}, {"oid": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245", "url": "https://github.com/infinispan/infinispan/commit/9703bf5f43a9d021ff0b4bd6a9f11f00523b6245", "message": "ISPN-11624 Server Patch Tool", "committedDate": "2020-04-27T16:28:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4ODQxNw==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415988417", "bodyText": "well, I was expecting a new method in org.infinispan.cli.Context[Impl] with [1]  and just invoke invocation.getContext().new_method(e)... but I guess this works as well :)\nTerminalString error = new TerminalString(Util.getRootCause(e).getLocalizedMessage(), new TerminalColor(Color.RED, Color.DEFAULT, Color.Intensity.BRIGHT));\nshell.writeln(error.toString());", "author": "pruivo", "createdAt": "2020-04-27T17:02:02Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/CliCommand.java", "diffHunk": "@@ -30,7 +32,17 @@ public CommandResult execute(ContextAwareCommandInvocation invocation) throws Co\n          invocation.println(invocation.getHelpInfo());\n          return CommandResult.SUCCESS;\n       }\n-      return exec(invocation);\n+      try {\n+         return exec(invocation);\n+      } catch (CommandException e) {\n+         invocation.getShell().writeln(ANSI.YELLOW_TEXT + e.getLocalizedMessage() + ANSI.DEFAULT_TEXT);\n+         return CommandResult.FAILURE;\n+      } catch (Throwable e) {\n+         // These are unhandled, show them in red\n+         Throwable cause = Util.getRootCause(e);", "originalCommit": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5MDk0MA==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415990940", "bodyText": "I'm wondering if most of these methods should create a CommandException instead of IllegalStateException since we have descriptive messages... WDYT?\nThe exception class doesn't bring anything useful in this case:\n[disconnected]> patch rollback \njava.lang.IllegalStateException: No installed patches to roll back", "author": "pruivo", "createdAt": "2020-04-27T17:05:45Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/logging/Messages.java", "diffHunk": "@@ -92,4 +95,64 @@\n \n    @Message(\"Invalid resource '%s'\")\n    IllegalArgumentException invalidResource(String name);\n+\n+   @Message(\"No patches installed\")\n+   String patchNoPatchesInstalled();\n+\n+   @Message(\"%s\")\n+   String patchInfo(PatchInfo patchInfo);\n+\n+   @Message(\"The supplied patch cannot be applied to %s %s\")\n+   IllegalStateException patchCannotApply(String brandName, String version);", "originalCommit": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg2NzE5NQ==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416867195", "bodyText": "I wanted to keep the PatchTool class clean of aesh classes", "author": "tristantarrant", "createdAt": "2020-04-28T19:28:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5MDk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAwMDk5NQ==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416000995", "bodyText": "nitpick:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Path sources[] = new Path[paths.size() - 2];\n          \n          \n            \n                        Path[] sources = new Path[paths.size() - 2];", "author": "pruivo", "createdAt": "2020-04-27T17:20:14Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/Patch.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package org.infinispan.cli.commands;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import org.aesh.command.Command;\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandException;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.impl.completer.FileOptionCompleter;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Arguments;\n+import org.aesh.command.option.Option;\n+import org.aesh.io.Resource;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.logging.Messages;\n+import org.infinispan.cli.patching.PatchTool;\n+import org.kohsuke.MetaInfServices;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+@MetaInfServices(Command.class)\n+@GroupCommandDefinition(name = Patch.CMD, description = \"Patch operations\", groupCommands = {Patch.Create.class, Patch.Describe.class, Patch.Install.class, Patch.Ls.class, Patch.Rollback.class})\n+public class Patch extends CliCommand {\n+\n+   public static final String CMD = \"patch\";\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+      // This command serves only to wrap the sub-commands\n+      invocation.println(invocation.getHelpInfo());\n+      return CommandResult.SUCCESS;\n+   }\n+\n+   @CommandDefinition(name = Create.CMD, description = \"Creates a patch archive\")\n+   public static class Create extends CliCommand {\n+      public static final String CMD = \"create\";\n+\n+      @Option(defaultValue = \"\", shortName = 'q', description = \"A qualifier for this patch (e.g. `one-off`)\")\n+      String qualifier;\n+\n+      @Arguments(completer = FileOptionCompleter.class, description = \"The path to the patch archive, the path to the target server and one or more paths to the source servers\")\n+      List<Resource> paths;\n+\n+      @Override\n+      public CommandResult exec(ContextAwareCommandInvocation invocation) throws CommandException {\n+         if (paths == null || paths.size() < 3) {\n+            throw Messages.MSG.patchCreateArgumentsRequired();\n+         }\n+         PatchTool patchTool = new PatchTool(invocation.getShellOutput(), invocation.getShellError());\n+         try {\n+            Path patch = Paths.get(paths.get(0).getAbsolutePath());\n+            Path target = Paths.get(paths.get(1).getAbsolutePath());\n+            Path sources[] = new Path[paths.size() - 2];", "originalCommit": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAwMjQzOQ==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416002439", "bodyText": "unused", "author": "pruivo", "createdAt": "2020-04-27T17:22:23Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,444 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;", "originalCommit": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAwMjcxNQ==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416002715", "bodyText": "not used anymore, but I guess we can keep it... up to you.", "author": "pruivo", "createdAt": "2020-04-27T17:22:45Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,444 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;", "originalCommit": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM3OTA0Mw==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416379043", "bodyText": "Yes, I'm going to use it soon.", "author": "tristantarrant", "createdAt": "2020-04-28T07:06:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAwMjcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAxODE2NQ==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416018165", "bodyText": "shouldn't be compared with the \"new\" digest?\nwhat about the files that weren't replaced? The ones created by file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());.", "author": "pruivo", "createdAt": "2020-04-27T17:43:07Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,444 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            throw MSG.patchValidationErrors(String.join(\"\\n\", errors));\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256 != null && sha256.equals(operation.getDigest())) {", "originalCommit": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM3OTI1OQ==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416379259", "bodyText": "Well spotted. There was also a break missing from this switch.", "author": "tristantarrant", "createdAt": "2020-04-28T07:07:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAxODE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAxOTA3Mg==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416019072", "bodyText": "shouldn't the file be \"downgraded\"?", "author": "pruivo", "createdAt": "2020-04-27T17:44:23Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,444 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            throw MSG.patchValidationErrors(String.join(\"\\n\", errors));\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256 != null && sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);", "originalCommit": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM2NTg5Nw==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416365897", "bodyText": "Notice that it falls-through to the next case", "author": "tristantarrant", "createdAt": "2020-04-28T06:40:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAxOTA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAyMTIyOQ==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416021229", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                           if (v1File.getDigest() != targetFile.getDigest()) {\n          \n          \n            \n                           if (!v1File.getDigest().equals(targetFile.getDigest())) {", "author": "pruivo", "createdAt": "2020-04-27T17:47:18Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,444 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            throw MSG.patchValidationErrors(String.join(\"\\n\", errors));\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256 != null && sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();\n+      } catch (IOException e) {\n+         throw MSG.patchCannotRead(patchesFile, e);\n+      }\n+   }\n+\n+   private void writeInstalledPatches(Path target, List<PatchInfo> patches) {\n+      try (OutputStream os = Files.newOutputStream(Files.createDirectories(target.resolve(PATCHES_DIR)).resolve(PATCHES_FILE), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writeValue(os, patches);\n+      } catch (IOException e) {\n+         throw MSG.patchCannotWritePatchesFile(e);\n+      }\n+   }\n+\n+   private void createSinglePatch(String qualifier, Path source, Path target, Version targetVersion, Map<Path, ServerFile> targetFiles, FileSystem zipfs) throws IOException {\n+      Version sourceVersion = getVersion(source);\n+\n+      // Ensure that the brand name coincides\n+      String sourceBrand = sourceVersion.brandName();\n+      String targetBrand = targetVersion.brandName();\n+      if (!sourceBrand.equals(targetBrand)) {\n+         throw MSG.patchIncompatibleProduct(sourceBrand, targetBrand);\n+      }\n+\n+      if (sourceVersion.version().equals(targetVersion.version())) {\n+         throw MSG.patchServerAndTargetMustBeDifferent(sourceVersion.version());\n+      }\n+\n+      PatchInfo patchInfo = new PatchInfo(sourceBrand, sourceVersion.version(), targetVersion.version(), qualifier);\n+\n+      // Build a list of files in the old version\n+      Map<Path, ServerFile> v1Files = getServerFiles(source);\n+\n+      // Compare the two file lists, generating a list of upgrade instructions\n+      List<PatchOperation> operations = patchInfo.getOperations();\n+      v1Files.forEach((k1, v1File) -> {\n+         if (!targetFiles.containsKey(k1)) {\n+            operations.add(PatchOperation.remove(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions()));\n+         } else {\n+            ServerFile targetFile = targetFiles.get(k1);\n+            if (!v1File.getFilename().equals(targetFile.getFilename())) { // Different filename means upgrade\n+               operations.add(PatchOperation.upgrade(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            } else { // Check contents\n+               if (v1File.getDigest() != targetFile.getDigest()) {", "originalCommit": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAyMjY0Nw==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416022647", "bodyText": "nitpicl: } else if ... {", "author": "pruivo", "createdAt": "2020-04-27T17:49:23Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,444 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            throw MSG.patchValidationErrors(String.join(\"\\n\", errors));\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256 != null && sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();\n+      } catch (IOException e) {\n+         throw MSG.patchCannotRead(patchesFile, e);\n+      }\n+   }\n+\n+   private void writeInstalledPatches(Path target, List<PatchInfo> patches) {\n+      try (OutputStream os = Files.newOutputStream(Files.createDirectories(target.resolve(PATCHES_DIR)).resolve(PATCHES_FILE), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writeValue(os, patches);\n+      } catch (IOException e) {\n+         throw MSG.patchCannotWritePatchesFile(e);\n+      }\n+   }\n+\n+   private void createSinglePatch(String qualifier, Path source, Path target, Version targetVersion, Map<Path, ServerFile> targetFiles, FileSystem zipfs) throws IOException {\n+      Version sourceVersion = getVersion(source);\n+\n+      // Ensure that the brand name coincides\n+      String sourceBrand = sourceVersion.brandName();\n+      String targetBrand = targetVersion.brandName();\n+      if (!sourceBrand.equals(targetBrand)) {\n+         throw MSG.patchIncompatibleProduct(sourceBrand, targetBrand);\n+      }\n+\n+      if (sourceVersion.version().equals(targetVersion.version())) {\n+         throw MSG.patchServerAndTargetMustBeDifferent(sourceVersion.version());\n+      }\n+\n+      PatchInfo patchInfo = new PatchInfo(sourceBrand, sourceVersion.version(), targetVersion.version(), qualifier);\n+\n+      // Build a list of files in the old version\n+      Map<Path, ServerFile> v1Files = getServerFiles(source);\n+\n+      // Compare the two file lists, generating a list of upgrade instructions\n+      List<PatchOperation> operations = patchInfo.getOperations();\n+      v1Files.forEach((k1, v1File) -> {\n+         if (!targetFiles.containsKey(k1)) {\n+            operations.add(PatchOperation.remove(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions()));\n+         } else {\n+            ServerFile targetFile = targetFiles.get(k1);\n+            if (!v1File.getFilename().equals(targetFile.getFilename())) { // Different filename means upgrade\n+               operations.add(PatchOperation.upgrade(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            } else { // Check contents", "originalCommit": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "47f73d8d8301eff8f4c35ba37e6d9b005f524ae5", "url": "https://github.com/infinispan/infinispan/commit/47f73d8d8301eff8f4c35ba37e6d9b005f524ae5", "message": "ISPN-11624 Server Patch Tool", "committedDate": "2020-04-28T07:07:37Z", "type": "forcePushed"}, {"oid": "f686e0d75af76dc8e170685de2c3f96a920fdd97", "url": "https://github.com/infinispan/infinispan/commit/f686e0d75af76dc8e170685de2c3f96a920fdd97", "message": "ISPN-11624 Server Patch Tool", "committedDate": "2020-04-28T15:05:08Z", "type": "forcePushed"}, {"oid": "ed74f7cc9585d72efd96a12ff9de80f311a9c4ee", "url": "https://github.com/infinispan/infinispan/commit/ed74f7cc9585d72efd96a12ff9de80f311a9c4ee", "message": "ISPN-11624 Server Patch Tool", "committedDate": "2020-04-28T15:08:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgwMzQ3NA==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416803474", "bodyText": "you can use BUFFER_SIZE. it is already defined.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        ByteBuffer bb = ByteBuffer.allocate(4096);\n          \n          \n            \n                        ByteBuffer bb = ByteBuffer.allocate(BUFFER_SIZE);", "author": "pruivo", "createdAt": "2020-04-28T17:42:57Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.ByteChannel;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         // Scan the patch to ensure its contents match with the list of operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(zipfs.getPath(operation.getNewPath().toString()));\n+                  if (sha256 == null || !sha256.equals(operation.getNewDigest())) {\n+                     errors.add(MSG.patchCorruptArchive(operation));\n+                  }\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            throw MSG.patchValidationErrors(String.join(\"\\n\", errors));\n+         }\n+         // Scan the server files to ensure that the patch can be installed\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            throw MSG.patchValidationErrors(String.join(\"\\n\", errors));\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256 != null && sha256.equals(operation.getNewDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+               // We might have created a side-file, remove it\n+               file = target.resolve(operation.getNewPath());\n+               file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+               Files.deleteIfExists(file);\n+               break;\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();\n+      } catch (IOException e) {\n+         throw MSG.patchCannotRead(patchesFile, e);\n+      }\n+   }\n+\n+   private void writeInstalledPatches(Path target, List<PatchInfo> patches) {\n+      try (OutputStream os = Files.newOutputStream(Files.createDirectories(target.resolve(PATCHES_DIR)).resolve(PATCHES_FILE), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writeValue(os, patches);\n+      } catch (IOException e) {\n+         throw MSG.patchCannotWritePatchesFile(e);\n+      }\n+   }\n+\n+   private void createSinglePatch(String qualifier, Path source, Path target, Version targetVersion, Map<Path, ServerFile> targetFiles, FileSystem zipfs) throws IOException {\n+      Version sourceVersion = getVersion(source);\n+\n+      // Ensure that the brand name coincides\n+      String sourceBrand = sourceVersion.brandName();\n+      String targetBrand = targetVersion.brandName();\n+      if (!sourceBrand.equals(targetBrand)) {\n+         throw MSG.patchIncompatibleProduct(sourceBrand, targetBrand);\n+      }\n+\n+      if (sourceVersion.version().equals(targetVersion.version())) {\n+         throw MSG.patchServerAndTargetMustBeDifferent(sourceVersion.version());\n+      }\n+\n+      PatchInfo patchInfo = new PatchInfo(sourceBrand, sourceVersion.version(), targetVersion.version(), qualifier);\n+\n+      // Build a list of files in the old version\n+      Map<Path, ServerFile> v1Files = getServerFiles(source);\n+\n+      // Compare the two file lists, generating a list of upgrade instructions\n+      List<PatchOperation> operations = patchInfo.getOperations();\n+      v1Files.forEach((k1, v1File) -> {\n+         if (!targetFiles.containsKey(k1)) {\n+            operations.add(PatchOperation.remove(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions()));\n+         } else {\n+            ServerFile targetFile = targetFiles.get(k1);\n+            if (!v1File.getFilename().equals(targetFile.getFilename())) { // Different filename means upgrade\n+               operations.add(PatchOperation.upgrade(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            } else if (!v1File.getDigest().equals(targetFile.getDigest())) {\n+               // Check contents\n+               operations.add(PatchOperation.replace(targetFile.isSoft(), targetFile.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            }\n+         }\n+      });\n+      targetFiles.forEach((k2, targetFile) -> {\n+         if (!v1Files.containsKey(k2)) {\n+            operations.add(PatchOperation.add(targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+            addFileToZip(zipfs, target, targetFile);\n+         }\n+      });\n+\n+      // Write out the JSON patch file\n+      Path patchPath = zipfs.getPath(\"patch-\" + patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion() + \".json\");\n+      try (OutputStream os = Files.newOutputStream(patchPath, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writerWithDefaultPrettyPrinter().writeValue(os, patchInfo);\n+      }\n+   }\n+\n+   private Map<Path, ServerFile> getServerFiles(Path base) throws IOException {\n+      Pattern IGNORE = Pattern.compile(\"^(\\\\.patches/|server/data/|server/log/|server/lib/).*$\");\n+      Pattern SOFT_REPLACE_PATTERN = Pattern.compile(\"^server/conf/.*$\");\n+      Map<Path, ServerFile> files = new TreeMap<>();\n+      Files.walkFileTree(base, new SimpleFileVisitor<Path>() {\n+         @Override\n+         public FileVisitResult visitFile(Path oPath, BasicFileAttributes attrs) {\n+            Path rPath = base.relativize(oPath);\n+            String rPathName = rPath.toString();\n+            if (!IGNORE.matcher(rPathName).matches()) {\n+               ServerFile file = new ServerFile(rPath, sha256(oPath), getPermissions(oPath), SOFT_REPLACE_PATTERN.matcher(rPathName).matches());\n+               files.put(file.getUnversionedPath(), file);\n+            }\n+            return FileVisitResult.CONTINUE;\n+         }\n+      });\n+      return files;\n+   }\n+\n+   private static String getPermissions(Path path) {\n+      try {\n+         return PosixFilePermissions.toString(Files.getPosixFilePermissions(path));\n+      } catch (IOException e) {\n+         throw new RuntimeException(e);\n+      }\n+   }\n+\n+   private List<PatchInfo> getPatchInfos(FileSystem zipfs) throws IOException {\n+      List<Path> paths = Files.find(zipfs.getPath(\"/\"), 1,\n+            (p, a) -> a.isRegularFile() && p.getFileName().toString().startsWith(\"patch-\") && p.getFileName().toString().endsWith(\".json\")\n+      ).collect(Collectors.toList());\n+      List<PatchInfo> infos = new ArrayList<>(paths.size());\n+      for (Path path : paths) {\n+         try (InputStream is = Files.newInputStream(path, StandardOpenOption.READ)) {\n+            infos.add(mapper.readValue(is, PatchInfo.class));\n+         }\n+      }\n+      return infos;\n+   }\n+\n+   private Version getVersion(Path base) throws IOException {\n+      // Load the META-INF/infinispan-version.properties from the lib/infinispan-commons jar\n+      Path lib = base.resolve(\"lib\");\n+      File[] commons = lib.toFile().listFiles((dir, name) -> name.startsWith(\"infinispan-commons-\") && name.endsWith(\".jar\"));\n+      if (commons == null || commons.length != 1) {\n+         throw MSG.patchCannotFindCommons(lib);\n+      }\n+      URI jarUri = URI.create(\"jar:\" + commons[0].toURI().toString());\n+      try (FileSystem zipfs = FileSystems.newFileSystem(jarUri, Collections.emptyMap()); InputStream in = Files.newInputStream(zipfs.getPath(\"META-INF\", \"infinispan-version.properties\"))) {\n+         return Version.from(in);\n+      }\n+   }\n+\n+\n+   private FileSystem getPatchFile(Path patch, boolean create) throws IOException {\n+      if (create && patch.toFile().exists()) {\n+         throw MSG.patchFileAlreadyExists(patch);\n+      }\n+      URI jarUri = URI.create(\"jar:\" + patch.toUri().toString());\n+      return FileSystems.newFileSystem(jarUri, create ? Collections.singletonMap(\"create\", \"true\") : Collections.emptyMap());\n+   }\n+\n+   private FileSystem getPatchFile(Path patch) throws IOException {\n+      return getPatchFile(patch, false);\n+   }\n+\n+   private void addFileToZip(FileSystem zipfs, Path basePath, ServerFile file) {\n+      try {\n+         Path target = zipfs.getPath(file.getVersionedPath().toString());\n+         out.println(MSG.patchCreateAdd(target));\n+         if (target.getParent() != null) {\n+            Files.createDirectories(target.getParent());\n+         }\n+         Files.copy(basePath.resolve(file.getVersionedPath()), target, StandardCopyOption.REPLACE_EXISTING);\n+      } catch (IOException e) {\n+         throw MSG.patchCreateError(e);\n+      }\n+   }\n+\n+   static String sha256(Path path) {\n+      try (ByteChannel channel = Files.newByteChannel(path, StandardOpenOption.READ)) {\n+         MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n+         if (channel instanceof FileChannel) {\n+            FileChannel fileChannel = (FileChannel) channel;\n+            MappedByteBuffer byteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileChannel.size());\n+            digest.update(byteBuffer);\n+         } else {\n+            ByteBuffer bb = ByteBuffer.allocate(4096);", "originalCommit": "ed74f7cc9585d72efd96a12ff9de80f311a9c4ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgwMzkzOQ==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416803939", "bodyText": "I think you need to flip() the buffer before reading again\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                           digest.update(bb.flip());\n          \n          \n            \n                           bb.flip();\n          \n          \n            \n                           digest.update(bb);\n          \n          \n            \n                           bb.flip();", "author": "pruivo", "createdAt": "2020-04-28T17:43:41Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.ByteChannel;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         // Scan the patch to ensure its contents match with the list of operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(zipfs.getPath(operation.getNewPath().toString()));\n+                  if (sha256 == null || !sha256.equals(operation.getNewDigest())) {\n+                     errors.add(MSG.patchCorruptArchive(operation));\n+                  }\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            throw MSG.patchValidationErrors(String.join(\"\\n\", errors));\n+         }\n+         // Scan the server files to ensure that the patch can be installed\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            throw MSG.patchValidationErrors(String.join(\"\\n\", errors));\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256 != null && sha256.equals(operation.getNewDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+               // We might have created a side-file, remove it\n+               file = target.resolve(operation.getNewPath());\n+               file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+               Files.deleteIfExists(file);\n+               break;\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();\n+      } catch (IOException e) {\n+         throw MSG.patchCannotRead(patchesFile, e);\n+      }\n+   }\n+\n+   private void writeInstalledPatches(Path target, List<PatchInfo> patches) {\n+      try (OutputStream os = Files.newOutputStream(Files.createDirectories(target.resolve(PATCHES_DIR)).resolve(PATCHES_FILE), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writeValue(os, patches);\n+      } catch (IOException e) {\n+         throw MSG.patchCannotWritePatchesFile(e);\n+      }\n+   }\n+\n+   private void createSinglePatch(String qualifier, Path source, Path target, Version targetVersion, Map<Path, ServerFile> targetFiles, FileSystem zipfs) throws IOException {\n+      Version sourceVersion = getVersion(source);\n+\n+      // Ensure that the brand name coincides\n+      String sourceBrand = sourceVersion.brandName();\n+      String targetBrand = targetVersion.brandName();\n+      if (!sourceBrand.equals(targetBrand)) {\n+         throw MSG.patchIncompatibleProduct(sourceBrand, targetBrand);\n+      }\n+\n+      if (sourceVersion.version().equals(targetVersion.version())) {\n+         throw MSG.patchServerAndTargetMustBeDifferent(sourceVersion.version());\n+      }\n+\n+      PatchInfo patchInfo = new PatchInfo(sourceBrand, sourceVersion.version(), targetVersion.version(), qualifier);\n+\n+      // Build a list of files in the old version\n+      Map<Path, ServerFile> v1Files = getServerFiles(source);\n+\n+      // Compare the two file lists, generating a list of upgrade instructions\n+      List<PatchOperation> operations = patchInfo.getOperations();\n+      v1Files.forEach((k1, v1File) -> {\n+         if (!targetFiles.containsKey(k1)) {\n+            operations.add(PatchOperation.remove(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions()));\n+         } else {\n+            ServerFile targetFile = targetFiles.get(k1);\n+            if (!v1File.getFilename().equals(targetFile.getFilename())) { // Different filename means upgrade\n+               operations.add(PatchOperation.upgrade(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            } else if (!v1File.getDigest().equals(targetFile.getDigest())) {\n+               // Check contents\n+               operations.add(PatchOperation.replace(targetFile.isSoft(), targetFile.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            }\n+         }\n+      });\n+      targetFiles.forEach((k2, targetFile) -> {\n+         if (!v1Files.containsKey(k2)) {\n+            operations.add(PatchOperation.add(targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+            addFileToZip(zipfs, target, targetFile);\n+         }\n+      });\n+\n+      // Write out the JSON patch file\n+      Path patchPath = zipfs.getPath(\"patch-\" + patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion() + \".json\");\n+      try (OutputStream os = Files.newOutputStream(patchPath, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writerWithDefaultPrettyPrinter().writeValue(os, patchInfo);\n+      }\n+   }\n+\n+   private Map<Path, ServerFile> getServerFiles(Path base) throws IOException {\n+      Pattern IGNORE = Pattern.compile(\"^(\\\\.patches/|server/data/|server/log/|server/lib/).*$\");\n+      Pattern SOFT_REPLACE_PATTERN = Pattern.compile(\"^server/conf/.*$\");\n+      Map<Path, ServerFile> files = new TreeMap<>();\n+      Files.walkFileTree(base, new SimpleFileVisitor<Path>() {\n+         @Override\n+         public FileVisitResult visitFile(Path oPath, BasicFileAttributes attrs) {\n+            Path rPath = base.relativize(oPath);\n+            String rPathName = rPath.toString();\n+            if (!IGNORE.matcher(rPathName).matches()) {\n+               ServerFile file = new ServerFile(rPath, sha256(oPath), getPermissions(oPath), SOFT_REPLACE_PATTERN.matcher(rPathName).matches());\n+               files.put(file.getUnversionedPath(), file);\n+            }\n+            return FileVisitResult.CONTINUE;\n+         }\n+      });\n+      return files;\n+   }\n+\n+   private static String getPermissions(Path path) {\n+      try {\n+         return PosixFilePermissions.toString(Files.getPosixFilePermissions(path));\n+      } catch (IOException e) {\n+         throw new RuntimeException(e);\n+      }\n+   }\n+\n+   private List<PatchInfo> getPatchInfos(FileSystem zipfs) throws IOException {\n+      List<Path> paths = Files.find(zipfs.getPath(\"/\"), 1,\n+            (p, a) -> a.isRegularFile() && p.getFileName().toString().startsWith(\"patch-\") && p.getFileName().toString().endsWith(\".json\")\n+      ).collect(Collectors.toList());\n+      List<PatchInfo> infos = new ArrayList<>(paths.size());\n+      for (Path path : paths) {\n+         try (InputStream is = Files.newInputStream(path, StandardOpenOption.READ)) {\n+            infos.add(mapper.readValue(is, PatchInfo.class));\n+         }\n+      }\n+      return infos;\n+   }\n+\n+   private Version getVersion(Path base) throws IOException {\n+      // Load the META-INF/infinispan-version.properties from the lib/infinispan-commons jar\n+      Path lib = base.resolve(\"lib\");\n+      File[] commons = lib.toFile().listFiles((dir, name) -> name.startsWith(\"infinispan-commons-\") && name.endsWith(\".jar\"));\n+      if (commons == null || commons.length != 1) {\n+         throw MSG.patchCannotFindCommons(lib);\n+      }\n+      URI jarUri = URI.create(\"jar:\" + commons[0].toURI().toString());\n+      try (FileSystem zipfs = FileSystems.newFileSystem(jarUri, Collections.emptyMap()); InputStream in = Files.newInputStream(zipfs.getPath(\"META-INF\", \"infinispan-version.properties\"))) {\n+         return Version.from(in);\n+      }\n+   }\n+\n+\n+   private FileSystem getPatchFile(Path patch, boolean create) throws IOException {\n+      if (create && patch.toFile().exists()) {\n+         throw MSG.patchFileAlreadyExists(patch);\n+      }\n+      URI jarUri = URI.create(\"jar:\" + patch.toUri().toString());\n+      return FileSystems.newFileSystem(jarUri, create ? Collections.singletonMap(\"create\", \"true\") : Collections.emptyMap());\n+   }\n+\n+   private FileSystem getPatchFile(Path patch) throws IOException {\n+      return getPatchFile(patch, false);\n+   }\n+\n+   private void addFileToZip(FileSystem zipfs, Path basePath, ServerFile file) {\n+      try {\n+         Path target = zipfs.getPath(file.getVersionedPath().toString());\n+         out.println(MSG.patchCreateAdd(target));\n+         if (target.getParent() != null) {\n+            Files.createDirectories(target.getParent());\n+         }\n+         Files.copy(basePath.resolve(file.getVersionedPath()), target, StandardCopyOption.REPLACE_EXISTING);\n+      } catch (IOException e) {\n+         throw MSG.patchCreateError(e);\n+      }\n+   }\n+\n+   static String sha256(Path path) {\n+      try (ByteChannel channel = Files.newByteChannel(path, StandardOpenOption.READ)) {\n+         MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n+         if (channel instanceof FileChannel) {\n+            FileChannel fileChannel = (FileChannel) channel;\n+            MappedByteBuffer byteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileChannel.size());\n+            digest.update(byteBuffer);\n+         } else {\n+            ByteBuffer bb = ByteBuffer.allocate(4096);\n+            while (channel.read(bb) != -1) {\n+               digest.update(bb.flip());", "originalCommit": "ed74f7cc9585d72efd96a12ff9de80f311a9c4ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgxNjExOQ==", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416816119", "bodyText": "When rollback, the upgraded files are printed twice:\nRolling back file '/tmp/redhat-datagrid-8.0.0-server/lib/protostream-4.4.0.CD20200427-redhat-00001.jar'\nRolling back file '/tmp/redhat-datagrid-8.0.0-server/lib/protostream-4.3.2.Final-redhat-00002.jar'\n\nNot sure if intentional or not.", "author": "pruivo", "createdAt": "2020-04-28T18:02:35Z", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.ByteChannel;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         // Scan the patch to ensure its contents match with the list of operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(zipfs.getPath(operation.getNewPath().toString()));\n+                  if (sha256 == null || !sha256.equals(operation.getNewDigest())) {\n+                     errors.add(MSG.patchCorruptArchive(operation));\n+                  }\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            throw MSG.patchValidationErrors(String.join(\"\\n\", errors));\n+         }\n+         // Scan the server files to ensure that the patch can be installed\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            throw MSG.patchValidationErrors(String.join(\"\\n\", errors));\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256 != null && sha256.equals(operation.getNewDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+               // We might have created a side-file, remove it\n+               file = target.resolve(operation.getNewPath());\n+               file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+               Files.deleteIfExists(file);\n+               break;\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));", "originalCommit": "ed74f7cc9585d72efd96a12ff9de80f311a9c4ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d62d3e0b2839498d215fa5020754a56f02a37d08", "url": "https://github.com/infinispan/infinispan/commit/d62d3e0b2839498d215fa5020754a56f02a37d08", "message": "ISPN-11624 Server Patch Tool", "committedDate": "2020-04-28T19:30:37Z", "type": "commit"}, {"oid": "d62d3e0b2839498d215fa5020754a56f02a37d08", "url": "https://github.com/infinispan/infinispan/commit/d62d3e0b2839498d215fa5020754a56f02a37d08", "message": "ISPN-11624 Server Patch Tool", "committedDate": "2020-04-28T19:30:37Z", "type": "forcePushed"}]}