{"pr_number": 7722, "pr_title": "ISPN-11020 Max Idle Take 2", "pr_createdAt": "2020-01-08T15:11:04Z", "pr_url": "https://github.com/infinispan/infinispan/pull/7722", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDMzMTUyNA==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r364331524", "bodyText": "useless blank line", "author": "tristantarrant", "createdAt": "2020-01-08T16:44:45Z", "path": "core/src/main/java/org/infinispan/commands/write/TouchCommand.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package org.infinispan.commands.write;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import org.infinispan.commands.CommandInvocationId;\n+import org.infinispan.commands.Visitor;\n+import org.infinispan.commons.io.UnsignedNumeric;\n+import org.infinispan.context.InvocationContext;\n+import org.infinispan.context.impl.FlagBitSets;\n+\n+public class TouchCommand extends AbstractDataWriteCommand {\n+   public static final byte COMMAND_ID = 61;\n+\n+   public TouchCommand() {\n+   }\n+\n+   public TouchCommand(Object key, int segment, long flagsBitSet, CommandInvocationId commandInvocationId) {\n+      super(key, segment, flagsBitSet, commandInvocationId);\n+   }\n+\n+   @Override\n+   public byte getCommandId() {\n+      return COMMAND_ID;\n+   }\n+\n+   @Override\n+   public boolean isSuccessful() {\n+      return true;\n+   }\n+\n+   @Override\n+   public void writeTo(ObjectOutput output) throws IOException {\n+      output.writeObject(key);\n+      UnsignedNumeric.writeUnsignedInt(output, segment);\n+      output.writeLong(FlagBitSets.copyWithoutRemotableFlags(getFlagsBitSet()));\n+      CommandInvocationId.writeTo(output, commandInvocationId);\n+   }\n+\n+   @Override\n+   public void readFrom(ObjectInput input) throws IOException, ClassNotFoundException {\n+      key = input.readObject();\n+      segment = UnsignedNumeric.readUnsignedInt(input);\n+      setFlagsBitSet(input.readLong());\n+      commandInvocationId = CommandInvocationId.readFrom(input);\n+   }\n+\n+   @Override\n+   public boolean isConditional() {\n+      return false;\n+   }\n+\n+   @Override\n+   public ValueMatcher getValueMatcher() {\n+      return ValueMatcher.MATCH_NON_NULL;\n+   }\n+\n+   @Override\n+   public void setValueMatcher(ValueMatcher valueMatcher) {\n+", "originalCommit": "1b970affd9a25527dd7e266223aae75c7dc19a49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDMzMTU5Ng==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r364331596", "bodyText": "useless blank line", "author": "tristantarrant", "createdAt": "2020-01-08T16:44:54Z", "path": "core/src/main/java/org/infinispan/commands/write/TouchCommand.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package org.infinispan.commands.write;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import org.infinispan.commands.CommandInvocationId;\n+import org.infinispan.commands.Visitor;\n+import org.infinispan.commons.io.UnsignedNumeric;\n+import org.infinispan.context.InvocationContext;\n+import org.infinispan.context.impl.FlagBitSets;\n+\n+public class TouchCommand extends AbstractDataWriteCommand {\n+   public static final byte COMMAND_ID = 61;\n+\n+   public TouchCommand() {\n+   }\n+\n+   public TouchCommand(Object key, int segment, long flagsBitSet, CommandInvocationId commandInvocationId) {\n+      super(key, segment, flagsBitSet, commandInvocationId);\n+   }\n+\n+   @Override\n+   public byte getCommandId() {\n+      return COMMAND_ID;\n+   }\n+\n+   @Override\n+   public boolean isSuccessful() {\n+      return true;\n+   }\n+\n+   @Override\n+   public void writeTo(ObjectOutput output) throws IOException {\n+      output.writeObject(key);\n+      UnsignedNumeric.writeUnsignedInt(output, segment);\n+      output.writeLong(FlagBitSets.copyWithoutRemotableFlags(getFlagsBitSet()));\n+      CommandInvocationId.writeTo(output, commandInvocationId);\n+   }\n+\n+   @Override\n+   public void readFrom(ObjectInput input) throws IOException, ClassNotFoundException {\n+      key = input.readObject();\n+      segment = UnsignedNumeric.readUnsignedInt(input);\n+      setFlagsBitSet(input.readLong());\n+      commandInvocationId = CommandInvocationId.readFrom(input);\n+   }\n+\n+   @Override\n+   public boolean isConditional() {\n+      return false;\n+   }\n+\n+   @Override\n+   public ValueMatcher getValueMatcher() {\n+      return ValueMatcher.MATCH_NON_NULL;\n+   }\n+\n+   @Override\n+   public void setValueMatcher(ValueMatcher valueMatcher) {\n+\n+   }\n+\n+   @Override\n+   public void fail() {\n+", "originalCommit": "1b970affd9a25527dd7e266223aae75c7dc19a49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b1888638147bead249485fafa1934f42a39bf563", "url": "https://github.com/infinispan/infinispan/commit/b1888638147bead249485fafa1934f42a39bf563", "message": "Scattered cache should now be fixed as well", "committedDate": "2020-01-08T19:32:06Z", "type": "forcePushed"}, {"oid": "34151fbf91e83d4357cd45c08dbf9fb37908c87f", "url": "https://github.com/infinispan/infinispan/commit/34151fbf91e83d4357cd45c08dbf9fb37908c87f", "message": "ISPN-11020 Max Idle Take 2\n\n* Now send a touch command on every read for max idle entries", "committedDate": "2020-01-08T20:43:06Z", "type": "forcePushed"}, {"oid": "e40b3f37121be2447c82453c6c8f7df7e786f7ce", "url": "https://github.com/infinispan/infinispan/commit/e40b3f37121be2447c82453c6c8f7df7e786f7ce", "message": "Adding in failover tests and fixed a couple bugs\n\nHow do we handle pessimistic locking though?", "committedDate": "2020-01-09T05:52:19Z", "type": "forcePushed"}, {"oid": "9009240eff2612279ea4d2f8f91a5bc0749aa7b6", "url": "https://github.com/infinispan/infinispan/commit/9009240eff2612279ea4d2f8f91a5bc0749aa7b6", "message": "different touch approach", "committedDate": "2020-01-10T20:25:16Z", "type": "forcePushed"}, {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf", "url": "https://github.com/infinispan/infinispan/commit/59b1abc3f530e038139b47a0889f3a373d756dbf", "message": "ISPN-11020 Max Idle Take 2\n\n* Now send a touch command on every read for max idle entries", "committedDate": "2020-01-10T21:54:43Z", "type": "commit"}, {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf", "url": "https://github.com/infinispan/infinispan/commit/59b1abc3f530e038139b47a0889f3a373d756dbf", "message": "ISPN-11020 Max Idle Take 2\n\n* Now send a touch command on every read for max idle entries", "committedDate": "2020-01-10T21:54:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyOTQ2MQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365729461", "bodyText": "I'd call it canExpireMaxIdle() to match the existing method canExpire().", "author": "danberindei", "createdAt": "2020-01-13T10:22:59Z", "path": "core/src/main/java/org/infinispan/container/entries/InternalCacheEntry.java", "diffHunk": "@@ -24,6 +24,13 @@\n     */\n    boolean canExpire();\n \n+   /**\n+    * @return true if this entry can expire via max idle, false otherwise\n+    */\n+   default boolean isMaxIdleExpirable() {", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzMDc3Mw==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365830773", "bodyText": "Sure.", "author": "wburns", "createdAt": "2020-01-13T14:25:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyOTQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTczMDgxMg==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365730812", "bodyText": "Please inline the method and replace the if (expiredStage != null) check with if (ice.canExpire())", "author": "danberindei", "createdAt": "2020-01-13T10:26:04Z", "path": "core/src/main/java/org/infinispan/container/impl/EntryFactoryImpl.java", "diffHunk": "@@ -109,28 +109,9 @@ private void handleExpiredEntryContextAddition(Boolean expired, InvocationContex\n       }\n    }\n \n-   private CompletionStage<Boolean> handlePossibleExpiredEntry(InternalCacheEntry ice, boolean write) {\n+   private CompletionStage<Boolean> handlePossibleExpiredEntry(InternalCacheEntry ice, int segment, boolean isWrite) {", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNTI5OQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365835299", "bodyText": "Sure :)", "author": "wburns", "createdAt": "2020-01-13T14:33:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTczMDgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTczMTk5Mg==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365731992", "bodyText": "There's no point in having the parameters in the javadoc if they don't have a description, all we get is complaints from IntelliJ.", "author": "danberindei", "createdAt": "2020-01-13T10:28:52Z", "path": "core/src/main/java/org/infinispan/container/impl/InternalDataContainer.java", "diffHunk": "@@ -60,6 +60,15 @@\n     */\n    InternalCacheEntry<K, V> peek(int segment, Object k);\n \n+   /**\n+    *\n+    * @param segment\n+    * @param k\n+    * @param currentTimeMillis", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzOTQ3MQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365839471", "bodyText": "Updated, just didn't get around to it is all.", "author": "wburns", "createdAt": "2020-01-13T14:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTczMTk5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTczNDQ4OQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365734489", "bodyText": "I think you need CompletableFutures.extractException.\nAnd I'd merge thenApply and exceptionally into a single handle.", "author": "danberindei", "createdAt": "2020-01-13T10:34:36Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -412,58 +411,96 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long access = localLastAccess(key, value, segment);\n+   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry ice, int segment) {\n+      Object key = ice.getKey();\n+      return attemptTouch(key, segment)\n+            .thenApply((Function<Boolean, CompletionStage<Boolean>>) CompletableFuture::completedFuture)\n+            .exceptionally(t -> {\n+               if (t instanceof OutdatedTopologyException) {", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0Mzk4Mg==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365743982", "bodyText": "Should inline", "author": "danberindei", "createdAt": "2020-01-13T10:56:43Z", "path": "core/src/main/java/org/infinispan/factories/InternalCacheFactory.java", "diffHunk": "@@ -270,11 +296,48 @@ public boolean containsKey(Object key) {\n \n       @Override\n       public CompletableFuture<V> getAsync(K key) {\n-         try {\n-            return CompletableFuture.completedFuture(get(key));\n-         } catch (Throwable t) {\n-            return CompletableFutures.completedExceptionFuture(t);\n+         return getCacheEntryAsync(key)\n+               .thenApply(ice -> ice != null ? ice.getValue() : null);\n+      }\n+\n+      private InternalCacheEntry<K, V> internalPeekCacheEntry(Object key, int segment) {\n+         assertKeyNotNull(key);\n+         checkCanRun(cache, cache.getName());\n+         return getDataContainer().peek(segment, key);\n+      }\n+\n+      @Override\n+      public CacheEntry<K, V> getCacheEntry(Object key) {\n+         return syncGet(key);\n+      }\n+\n+      @Override\n+      public CompletableFuture<CacheEntry<K, V>> getCacheEntryAsync(Object key) {\n+         return asyncGet(key);", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NDI3MQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365744271", "bodyText": "Could inline syncGet() in getCacheEntry() and use that here.", "author": "danberindei", "createdAt": "2020-01-13T10:57:22Z", "path": "core/src/main/java/org/infinispan/factories/InternalCacheFactory.java", "diffHunk": "@@ -242,21 +250,39 @@ public void wireRealCache() {\n        */\n       protected void internalWire(T cache) {\n          componentRegistry = cache.componentRegistry;\n+         expirationManager = cache.expirationManager;\n+         keyPartitioner = cache.keyPartitioner;\n          wireRealCache();\n       }\n \n+      @Override\n+      public InternalDataContainer<K, V> getDataContainer() {\n+         return (InternalDataContainer<K, V>) super.getDataContainer();\n+      }\n+\n       @Override\n       public V get(Object key) {\n-         assertKeyNotNull(key);\n-         checkCanRun(cache, cache.getName());\n-         // TODO: what should we do here? - This needs to be fixed in https://issues.redhat.com/browse/ISPN-11124\n-         InternalCacheEntry<K, V> ice = getDataContainer().get(key);\n+         InternalCacheEntry<K, V> ice = syncGet(key);", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NTQxNQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365745415", "bodyText": "ice isn't modified, so you could move this if at the top", "author": "danberindei", "createdAt": "2020-01-13T11:00:10Z", "path": "core/src/main/java/org/infinispan/factories/InternalCacheFactory.java", "diffHunk": "@@ -270,11 +296,48 @@ public boolean containsKey(Object key) {\n \n       @Override\n       public CompletableFuture<V> getAsync(K key) {\n-         try {\n-            return CompletableFuture.completedFuture(get(key));\n-         } catch (Throwable t) {\n-            return CompletableFutures.completedExceptionFuture(t);\n+         return getCacheEntryAsync(key)\n+               .thenApply(ice -> ice != null ? ice.getValue() : null);\n+      }\n+\n+      private InternalCacheEntry<K, V> internalPeekCacheEntry(Object key, int segment) {\n+         assertKeyNotNull(key);\n+         checkCanRun(cache, cache.getName());\n+         return getDataContainer().peek(segment, key);\n+      }\n+\n+      @Override\n+      public CacheEntry<K, V> getCacheEntry(Object key) {\n+         return syncGet(key);\n+      }\n+\n+      @Override\n+      public CompletableFuture<CacheEntry<K, V>> getCacheEntryAsync(Object key) {\n+         return asyncGet(key);\n+      }\n+\n+      private CompletableFuture<CacheEntry<K, V>> asyncGet(Object key) {\n+         int segment = keyPartitioner.getSegment(key);\n+         InternalCacheEntry<K, V> ice = internalPeekCacheEntry(key, segment);\n+         if (ice != null) {\n+            if (ice.canExpire()) {\n+               CompletionStage<Boolean> stage = expirationManager.handlePossibleExpiration(ice, segment, false);\n+               if (CompletionStages.isCompletedSuccessfully(stage)) {\n+                  return CompletableFutures.completedNull();\n+               } else {\n+                  return stage.thenApply(expired -> {\n+                     if (expired == Boolean.TRUE) {\n+                        return null;\n+                     }\n+                     return (CacheEntry<K, V>) ice;\n+                  }).toCompletableFuture();\n+               }\n+            }\n+         }\n+         if (ice == null) {", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NjQ5Mg==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365746492", "bodyText": "Forgot to check if the entry was expired or not", "author": "danberindei", "createdAt": "2020-01-13T11:02:54Z", "path": "core/src/main/java/org/infinispan/factories/InternalCacheFactory.java", "diffHunk": "@@ -270,11 +296,48 @@ public boolean containsKey(Object key) {\n \n       @Override\n       public CompletableFuture<V> getAsync(K key) {\n-         try {\n-            return CompletableFuture.completedFuture(get(key));\n-         } catch (Throwable t) {\n-            return CompletableFutures.completedExceptionFuture(t);\n+         return getCacheEntryAsync(key)\n+               .thenApply(ice -> ice != null ? ice.getValue() : null);\n+      }\n+\n+      private InternalCacheEntry<K, V> internalPeekCacheEntry(Object key, int segment) {\n+         assertKeyNotNull(key);\n+         checkCanRun(cache, cache.getName());\n+         return getDataContainer().peek(segment, key);\n+      }\n+\n+      @Override\n+      public CacheEntry<K, V> getCacheEntry(Object key) {\n+         return syncGet(key);\n+      }\n+\n+      @Override\n+      public CompletableFuture<CacheEntry<K, V>> getCacheEntryAsync(Object key) {\n+         return asyncGet(key);\n+      }\n+\n+      private CompletableFuture<CacheEntry<K, V>> asyncGet(Object key) {\n+         int segment = keyPartitioner.getSegment(key);\n+         InternalCacheEntry<K, V> ice = internalPeekCacheEntry(key, segment);\n+         if (ice != null) {\n+            if (ice.canExpire()) {\n+               CompletionStage<Boolean> stage = expirationManager.handlePossibleExpiration(ice, segment, false);\n+               if (CompletionStages.isCompletedSuccessfully(stage)) {\n+                  return CompletableFutures.completedNull();", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MzQxOQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365843419", "bodyText": "Oops :)", "author": "wburns", "createdAt": "2020-01-13T14:48:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NjQ5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NzQ2OA==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365747468", "bodyText": "Maybe it's worth extracting some of this logic into a method createTouchResponseCollector(CacheMode, LocalizedCacheTopology)?", "author": "danberindei", "createdAt": "2020-01-13T11:05:28Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -412,58 +411,96 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long access = localLastAccess(key, value, segment);\n+   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry ice, int segment) {\n+      Object key = ice.getKey();\n+      return attemptTouch(key, segment)\n+            .thenApply((Function<Boolean, CompletionStage<Boolean>>) CompletableFuture::completedFuture)\n+            .exceptionally(t -> {\n+               if (t instanceof OutdatedTopologyException) {\n+                  if (trace) {\n+                     log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+                  }\n+                  return attemptTouch(key, segment);\n+               }\n+               return CompletableFutures.completedExceptionFuture(t);\n+            })\n+            .thenCompose(Function.identity());\n+   }\n \n-      LocalizedCacheTopology topology = distributionManager.getCacheTopology();\n-      DistributionInfo info = topology.getDistribution(key);\n+   private CompletionStage<Boolean> attemptTouch(Object key, int segment) {\n+      LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n+      DistributionInfo di = lct.getSegmentDistribution(segment);\n+\n+      boolean isScattered = configuration.clustering().cacheMode().isScattered();\n+      List<Address> owners =  isScattered ? lct.getActualMembers() : di.writeOwners();\n+      TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n+      touchCommand.setTopologyId(lct.getTopologyId());\n+      CompletionStage<Boolean> remoteStage = rpcManager.invokeCommand(owners, touchCommand,\n+            isScattered ? new ScatteredTouchResponseCollector() : new TouchResponseCollector(),", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MzgxMg==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365843812", "bodyText": "Sure, I can do that.", "author": "wburns", "createdAt": "2020-01-13T14:49:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NzQ2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0NDA4NQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365844085", "bodyText": "I will change it slightly though as I should be able to encapsulate everything returning a CompletionStage<Boolean> even.", "author": "wburns", "createdAt": "2020-01-13T14:49:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NzQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0ODI3OA==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365748278", "bodyText": "The first part is probably better suited in the super method's javadoc.", "author": "danberindei", "createdAt": "2020-01-13T11:07:38Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -412,58 +411,96 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long access = localLastAccess(key, value, segment);\n+   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry ice, int segment) {\n+      Object key = ice.getKey();\n+      return attemptTouch(key, segment)\n+            .thenApply((Function<Boolean, CompletionStage<Boolean>>) CompletableFuture::completedFuture)\n+            .exceptionally(t -> {\n+               if (t instanceof OutdatedTopologyException) {\n+                  if (trace) {\n+                     log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+                  }\n+                  return attemptTouch(key, segment);\n+               }\n+               return CompletableFutures.completedExceptionFuture(t);\n+            })\n+            .thenCompose(Function.identity());\n+   }\n \n-      LocalizedCacheTopology topology = distributionManager.getCacheTopology();\n-      DistributionInfo info = topology.getDistribution(key);\n+   private CompletionStage<Boolean> attemptTouch(Object key, int segment) {\n+      LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n+      DistributionInfo di = lct.getSegmentDistribution(segment);\n+\n+      boolean isScattered = configuration.clustering().cacheMode().isScattered();\n+      List<Address> owners =  isScattered ? lct.getActualMembers() : di.writeOwners();\n+      TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n+      touchCommand.setTopologyId(lct.getTopologyId());\n+      CompletionStage<Boolean> remoteStage = rpcManager.invokeCommand(owners, touchCommand,\n+            isScattered ? new ScatteredTouchResponseCollector() : new TouchResponseCollector(),\n+            rpcManager.getSyncRpcOptions());\n+      touchCommand.init(componentRegistry, false);\n+      CompletableFuture<Object> localStage = touchCommand.invokeAsync();\n+\n+      return remoteStage.thenCombine(localStage, (remoteTouch, localTouch) -> {\n+         // Response is whether the value should be treated as expired - thus if both local and remote were able to touch", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc1NDI5MA==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365754290", "bodyText": "If one of the backup owners dies, a rebalance is started, but for a while there are multiple owners.\nIf the primary owner dies, for a while there is no primary owner, then a new primary owner is selected and it backs up to the next node + invalidates the other owners.\nInvalidation commands triggered by regular writes are also sent asynchronously (and in batches), so it's quite common to have more than 1 backup owner.\nSee also the scattered package javadoc", "author": "danberindei", "createdAt": "2020-01-13T11:24:03Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -412,58 +411,96 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long access = localLastAccess(key, value, segment);\n+   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry ice, int segment) {\n+      Object key = ice.getKey();\n+      return attemptTouch(key, segment)\n+            .thenApply((Function<Boolean, CompletionStage<Boolean>>) CompletableFuture::completedFuture)\n+            .exceptionally(t -> {\n+               if (t instanceof OutdatedTopologyException) {\n+                  if (trace) {\n+                     log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+                  }\n+                  return attemptTouch(key, segment);\n+               }\n+               return CompletableFutures.completedExceptionFuture(t);\n+            })\n+            .thenCompose(Function.identity());\n+   }\n \n-      LocalizedCacheTopology topology = distributionManager.getCacheTopology();\n-      DistributionInfo info = topology.getDistribution(key);\n+   private CompletionStage<Boolean> attemptTouch(Object key, int segment) {\n+      LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n+      DistributionInfo di = lct.getSegmentDistribution(segment);\n+\n+      boolean isScattered = configuration.clustering().cacheMode().isScattered();\n+      List<Address> owners =  isScattered ? lct.getActualMembers() : di.writeOwners();\n+      TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n+      touchCommand.setTopologyId(lct.getTopologyId());\n+      CompletionStage<Boolean> remoteStage = rpcManager.invokeCommand(owners, touchCommand,\n+            isScattered ? new ScatteredTouchResponseCollector() : new TouchResponseCollector(),\n+            rpcManager.getSyncRpcOptions());\n+      touchCommand.init(componentRegistry, false);\n+      CompletableFuture<Object> localStage = touchCommand.invokeAsync();\n+\n+      return remoteStage.thenCombine(localStage, (remoteTouch, localTouch) -> {\n+         // Response is whether the value should be treated as expired - thus if both local and remote were able to touch\n+         // then the value is not expired\n+         if (remoteTouch == Boolean.TRUE && localTouch == Boolean.TRUE) {\n+            return Boolean.FALSE;\n+         }\n+         return Boolean.TRUE;\n+      });\n+   }\n \n-      if (trace) {\n-         log.tracef(\"Asking all read owners %s for key: %s - for latest access time\", info.readOwners(), key);\n+   private static abstract class AbstractTouchResponseCollector extends ValidResponseCollector<Boolean> {\n+      @Override\n+      protected Boolean addTargetNotFound(Address sender) {\n+         throw OutdatedTopologyException.RETRY_NEXT_TOPOLOGY;\n       }\n \n-      // Need to gather last access times\n-      RetrieveLastAccessCommand rlac = cf.running().buildRetrieveLastAccessCommand(key, value, segment);\n-      rlac.setTopologyId(topology.getTopologyId());\n-\n-      // In scattered cache read owners will only contain primary\n-      return rpcManager.invokeCommand(info.readOwners(), rlac, new MaxResponseCollector<>(access),\n-            rpcManager.getSyncRpcOptions()).toCompletableFuture();\n+      @Override\n+      protected Boolean addException(Address sender, Exception exception) {\n+         if (exception instanceof CacheException) {\n+            throw (CacheException) exception;\n+         }\n+         throw new CacheException(exception);\n+      }\n    }\n \n-   static class MaxResponseCollector<T extends Comparable<T>> extends ValidResponseCollector<T> {\n-      T highest;\n-\n-      MaxResponseCollector(T highest) {\n-         this.highest = highest;\n-      }\n+   private static class ScatteredTouchResponseCollector extends AbstractTouchResponseCollector {\n \n       @Override\n-      public T finish() {\n-         return highest;\n+      public Boolean finish() {\n+         // No other node was touched\n+         return Boolean.FALSE;\n       }\n \n       @Override\n-      protected T addValidResponse(Address sender, ValidResponse response) {\n-         T value = (T) response.getResponseValue();\n-         if (trace) {\n-            log.tracef(\"Received response %s from %s when requesting access time for max idle\", value, sender);\n-         }\n-         if (value != null && (highest == null || highest.compareTo(value) < 0)) {\n-            highest = value;\n+      protected Boolean addValidResponse(Address sender, ValidResponse response) {\n+         Boolean touched = (Boolean) response.getResponseValue();\n+         if (touched == Boolean.TRUE) {\n+            // Return early if any node touched the value - as SCATTERED only exists on a single backup!\n+            // TODO: what if the read was when one of the backups or primary died?", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2NDI0OQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365764249", "bodyText": "I'd rather not return early, because you'd leave touch commands floating around, making tests less deterministic, while the scenario is hopefully really uncommon.", "author": "danberindei", "createdAt": "2020-01-13T11:51:08Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -412,58 +411,96 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long access = localLastAccess(key, value, segment);\n+   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry ice, int segment) {\n+      Object key = ice.getKey();\n+      return attemptTouch(key, segment)\n+            .thenApply((Function<Boolean, CompletionStage<Boolean>>) CompletableFuture::completedFuture)\n+            .exceptionally(t -> {\n+               if (t instanceof OutdatedTopologyException) {\n+                  if (trace) {\n+                     log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+                  }\n+                  return attemptTouch(key, segment);\n+               }\n+               return CompletableFutures.completedExceptionFuture(t);\n+            })\n+            .thenCompose(Function.identity());\n+   }\n \n-      LocalizedCacheTopology topology = distributionManager.getCacheTopology();\n-      DistributionInfo info = topology.getDistribution(key);\n+   private CompletionStage<Boolean> attemptTouch(Object key, int segment) {\n+      LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n+      DistributionInfo di = lct.getSegmentDistribution(segment);\n+\n+      boolean isScattered = configuration.clustering().cacheMode().isScattered();\n+      List<Address> owners =  isScattered ? lct.getActualMembers() : di.writeOwners();\n+      TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n+      touchCommand.setTopologyId(lct.getTopologyId());\n+      CompletionStage<Boolean> remoteStage = rpcManager.invokeCommand(owners, touchCommand,\n+            isScattered ? new ScatteredTouchResponseCollector() : new TouchResponseCollector(),\n+            rpcManager.getSyncRpcOptions());\n+      touchCommand.init(componentRegistry, false);\n+      CompletableFuture<Object> localStage = touchCommand.invokeAsync();\n+\n+      return remoteStage.thenCombine(localStage, (remoteTouch, localTouch) -> {\n+         // Response is whether the value should be treated as expired - thus if both local and remote were able to touch\n+         // then the value is not expired\n+         if (remoteTouch == Boolean.TRUE && localTouch == Boolean.TRUE) {\n+            return Boolean.FALSE;\n+         }\n+         return Boolean.TRUE;\n+      });\n+   }\n \n-      if (trace) {\n-         log.tracef(\"Asking all read owners %s for key: %s - for latest access time\", info.readOwners(), key);\n+   private static abstract class AbstractTouchResponseCollector extends ValidResponseCollector<Boolean> {\n+      @Override\n+      protected Boolean addTargetNotFound(Address sender) {\n+         throw OutdatedTopologyException.RETRY_NEXT_TOPOLOGY;\n       }\n \n-      // Need to gather last access times\n-      RetrieveLastAccessCommand rlac = cf.running().buildRetrieveLastAccessCommand(key, value, segment);\n-      rlac.setTopologyId(topology.getTopologyId());\n-\n-      // In scattered cache read owners will only contain primary\n-      return rpcManager.invokeCommand(info.readOwners(), rlac, new MaxResponseCollector<>(access),\n-            rpcManager.getSyncRpcOptions()).toCompletableFuture();\n+      @Override\n+      protected Boolean addException(Address sender, Exception exception) {\n+         if (exception instanceof CacheException) {\n+            throw (CacheException) exception;\n+         }\n+         throw new CacheException(exception);\n+      }\n    }\n \n-   static class MaxResponseCollector<T extends Comparable<T>> extends ValidResponseCollector<T> {\n-      T highest;\n-\n-      MaxResponseCollector(T highest) {\n-         this.highest = highest;\n-      }\n+   private static class ScatteredTouchResponseCollector extends AbstractTouchResponseCollector {\n \n       @Override\n-      public T finish() {\n-         return highest;\n+      public Boolean finish() {\n+         // No other node was touched\n+         return Boolean.FALSE;\n       }\n \n       @Override\n-      protected T addValidResponse(Address sender, ValidResponse response) {\n-         T value = (T) response.getResponseValue();\n-         if (trace) {\n-            log.tracef(\"Received response %s from %s when requesting access time for max idle\", value, sender);\n-         }\n-         if (value != null && (highest == null || highest.compareTo(value) < 0)) {\n-            highest = value;\n+      protected Boolean addValidResponse(Address sender, ValidResponse response) {\n+         Boolean touched = (Boolean) response.getResponseValue();\n+         if (touched == Boolean.TRUE) {\n+            // Return early if any node touched the value - as SCATTERED only exists on a single backup!\n+            // TODO: what if the read was when one of the backups or primary died?\n+            return Boolean.TRUE;\n          }\n          return null;\n       }\n+   }\n \n+   private static class TouchResponseCollector extends AbstractTouchResponseCollector {\n       @Override\n-      protected T addTargetNotFound(Address sender) {\n-         // We don't care about a node leaving\n-         return null;\n+      public Boolean finish() {\n+         // If all were touched, then the value isn't expired\n+         return Boolean.TRUE;\n       }\n \n       @Override\n-      protected T addException(Address sender, Exception exception) {\n-         throw ResponseCollectors.wrapRemoteException(sender, exception);\n+      protected Boolean addValidResponse(Address sender, ValidResponse response) {\n+         Boolean touched = (Boolean) response.getResponseValue();\n+         if (touched == Boolean.FALSE) {\n+            // Return early if any value wasn't touched!", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0OTUxNA==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365849514", "bodyText": "which scenario? this would be quite common when using max idle with scattered cache.", "author": "wburns", "createdAt": "2020-01-13T14:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2NDI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg2MTYzNw==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365861637", "bodyText": "This is the disc response collector, not the scattered one.\nI was thinking it would be uncommon to have an operation that tries to expire an entry and finds another operation already expired/updated/removed the entry, because expirations themselves shouldn't be very common.", "author": "danberindei", "createdAt": "2020-01-13T15:22:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2NDI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg2MzY3Nw==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365863677", "bodyText": "To clarify this is ran on access, not expiration - so it would increase the frequency a bit more.\nThe other benefit of returning early is technically the collector is stateless, which would allow for a singleton impl, I just forgot to do that.", "author": "wburns", "createdAt": "2020-01-13T15:25:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2NDI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzMTk0Mg==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365931942", "bodyText": "True, you don't need two concurrent expirations to get a false, just one expiration and a regular read, but still I'm not 100% sold on having those touch commands floating around.", "author": "danberindei", "createdAt": "2020-01-13T17:32:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2NDI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2ODI0OQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365768249", "bodyText": "Please add a javadoc and explain the return value.", "author": "danberindei", "createdAt": "2020-01-13T12:01:58Z", "path": "core/src/main/java/org/infinispan/expiration/impl/TouchCommand.java", "diffHunk": "@@ -1,55 +1,44 @@\n-package org.infinispan.commands.remote.expiration;\n+package org.infinispan.expiration.impl;\n \n import java.io.IOException;\n import java.io.ObjectInput;\n import java.io.ObjectOutput;\n import java.util.concurrent.CompletableFuture;\n \n import org.infinispan.commands.InitializableCommand;\n-import org.infinispan.commands.SegmentSpecificCommand;\n import org.infinispan.commands.TopologyAffectedCommand;\n import org.infinispan.commands.remote.BaseRpcCommand;\n import org.infinispan.commons.io.UnsignedNumeric;\n-import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.commons.time.TimeService;\n import org.infinispan.container.impl.InternalDataContainer;\n+import org.infinispan.distribution.DistributionManager;\n import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.statetransfer.OutdatedTopologyException;\n import org.infinispan.util.ByteString;\n import org.infinispan.util.concurrent.CompletableFutures;\n \n-/**\n- * Command that will update the last access time for an entry given the specific time\n- * @author wburns\n- * @since 9.3\n- */\n-public class UpdateLastAccessCommand extends BaseRpcCommand implements InitializableCommand, TopologyAffectedCommand, SegmentSpecificCommand {\n+public class TouchCommand extends BaseRpcCommand implements InitializableCommand, TopologyAffectedCommand {", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3NTEwNQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365775105", "bodyText": "I'd expect TouchCommand and a method named touchEntry to use the same convention for the return value.\nI suggest moving thenApply(touched -> !touched) outside the method.", "author": "danberindei", "createdAt": "2020-01-13T12:20:46Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java", "diffHunk": "@@ -252,22 +260,36 @@ private void deleteFromStoresAndNotify(K key, V value, Metadata metadata) {\n             cacheNotifier.notifyCacheEntryExpired(key, value, metadata, null)));\n    }\n \n-   protected Long localLastAccess(Object key, Object value, int segment) {\n-      InternalCacheEntry ice = dataContainer.running().peek(segment, key);\n-      if (ice != null && (value == null || value.equals(ice.getValue())) &&\n-            !ice.isExpired(timeService.wallClockTime())) {\n-         return ice.getLastUsed();\n+   @Override\n+   public CompletionStage<Boolean> handlePossibleExpiration(InternalCacheEntry<K, V> ice, int segment, boolean isWrite) {\n+      long currentTime = timeService.wallClockTime();\n+      if (ice.isExpired(currentTime)) {\n+         if (trace) {\n+            log.tracef(\"Retrieved entry for key %s was expired locally, attempting expiration removal\", ice.getKey());\n+         }\n+         CompletableFuture<Boolean> expiredStage = entryExpiredInMemory(ice, currentTime, isWrite);\n+         if (trace) {\n+            expiredStage = expiredStage.thenApply(expired -> {\n+               if (expired == Boolean.FALSE) {\n+                  log.tracef(\"Retrieved entry for key %s was found to not be expired.\", ice.getKey());\n+               } else {\n+                  log.tracef(\"Retrieved entry for key %s was confirmed to be expired.\", ice.getKey());\n+               }\n+               return expired;\n+            });\n+         }\n+         return expiredStage;\n+      } else if (!isWrite && ice.isMaxIdleExpirable()) {\n+         return touchEntry(ice, segment);\n       }\n-      return null;\n+      return CompletableFutures.completedFalse();\n    }\n \n-   @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long lastAccess = localLastAccess(key, value, segment);\n-      if (lastAccess != null) {\n-         return CompletableFuture.completedFuture(lastAccess);\n-      }\n-      return CompletableFutures.completedNull();\n+   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry entry, int segment) {\n+      TouchCommand touchCommand = cf.running().buildTouchCommand(entry.getKey(), segment);\n+      touchCommand.init(componentRegistry, false);\n+      CompletableFuture<Boolean> future = (CompletableFuture) touchCommand.invokeAsync();\n+      return future.thenApply(touched -> !touched);", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg1MzM4Mg==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365853382", "bodyText": "I renamed the method.", "author": "wburns", "createdAt": "2020-01-13T15:07:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3NTEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3NTIyMA==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365775220", "bodyText": "Missing javadoc", "author": "danberindei", "createdAt": "2020-01-13T12:21:01Z", "path": "core/src/main/java/org/infinispan/expiration/impl/InternalExpirationManager.java", "diffHunk": "@@ -73,15 +73,5 @@ default void handleInStoreExpiration(MarshallableEntry<K, V> marshalledEntry) {\n       CompletionStages.join(handleInStoreExpirationInternal(marshalledEntry));\n    }\n \n-   /**\n-    * Retrieves the last access time for the given key in the data container if it is using max idle.\n-    * If the entry is not in the container or it is expired it will return null.\n-    * If the entry is present but cannot expire via max idle, it will return -1\n-    * If the entry is present and can expire via max idle but hasn't it will return a number > 0\n-    * @param key the key to retrieve the access time for\n-    * @param value the value to match if desired (this can be null)\n-    * @param segment the segment for the given key\n-    * @return the last access time if available\n-    */\n-   CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment);\n+   CompletionStage<Boolean> handlePossibleExpiration(InternalCacheEntry<K, V> entry, int segment, boolean isWrite);", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3NzQ5Nw==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365777497", "bodyText": "MultipleCacheManagersTest#getKeyForCache(org.infinispan.Cache<?,?>, org.infinispan.Cache<?,?>...)", "author": "danberindei", "createdAt": "2020-01-13T12:27:04Z", "path": "core/src/test/java/org/infinispan/expiration/impl/ClusterExpirationFunctionalTest.java", "diffHunk": "@@ -340,4 +341,49 @@ public void testWriteExpiredEntry() throws InterruptedException {\n          ts2.advance(secondOneMilliAdvanced);\n       }\n    }\n+\n+   public void testMaxIdleReadNodeDiesPrimary() {\n+      testMaxIdleNodeDies(c -> {\n+         if (cacheMode.isScattered()) {", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg3NzQ2OQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365877469", "bodyText": "Ah nice, wasn't aware of that.", "author": "wburns", "createdAt": "2020-01-13T15:50:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3NzQ5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3OTA2MA==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365779060", "bodyText": "killMember(3) calls waitForNoRebalance(caches), I think you need to block the rebalance and test expiration during the rebalance as well.", "author": "danberindei", "createdAt": "2020-01-13T12:30:54Z", "path": "core/src/test/java/org/infinispan/expiration/impl/ClusterExpirationFunctionalTest.java", "diffHunk": "@@ -340,4 +341,49 @@ public void testWriteExpiredEntry() throws InterruptedException {\n          ts2.advance(secondOneMilliAdvanced);\n       }\n    }\n+\n+   public void testMaxIdleReadNodeDiesPrimary() {\n+      testMaxIdleNodeDies(c -> {\n+         if (cacheMode.isScattered()) {\n+            return new MagicKey(c);\n+         }\n+         return new MagicKey(c, cache0);\n+      });\n+   }\n+\n+   public void testMaxIdleReadNodeDiesBackup() {\n+      testMaxIdleNodeDies(c -> {\n+         if (cacheMode.isScattered()) {\n+            return new MagicKey(cache0);\n+         }\n+         return new MagicKey(cache0, c);\n+      });\n+   }\n+\n+   private void testMaxIdleNodeDies(Function<Cache<?, ?>, MagicKey> keyToUseFunction) {\n+      addClusterEnabledCacheManager(TestDataSCI.INSTANCE, configurationBuilder);\n+      waitForClusterToForm();\n+\n+      Cache<Object, String> cache3 = cache(3);\n+\n+      ControlledTimeService ts4 = new ControlledTimeService();\n+      TestingUtil.replaceComponent(manager(3), TimeService.class, ts4, true);\n+\n+      MagicKey key = keyToUseFunction.apply(cache3);\n+\n+      // We always write to cache3 so that scattered uses it as a backup if the key isn't owned by it\n+      cache3.put(key, \"max-idle\", -1, TimeUnit.MILLISECONDS, 100, TimeUnit.MILLISECONDS);\n+\n+      long justbeforeExpiration = 99;\n+      incrementAllTimeServices(justbeforeExpiration, TimeUnit.MILLISECONDS);\n+      ts4.advance(justbeforeExpiration);\n+\n+      assertNotNull(cache3.get(key));\n+\n+      killMember(3);", "originalCommit": "59b1abc3f530e038139b47a0889f3a373d756dbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg3OTA5Nw==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365879097", "bodyText": "Yeah, this test wasn't trying to test that out yet. It was more to make sure after node failure that the timestamp is still good.", "author": "wburns", "createdAt": "2020-01-13T15:53:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3OTA2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg3OTM5Nw==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365879397", "bodyText": "@danberindei is there an example test I can use that you recommend that blocks rebalance? I find getting a test correct with that can be quite annoying.", "author": "wburns", "createdAt": "2020-01-13T15:53:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3OTA2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0NTE2MA==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365945160", "bodyText": "There are many tests that block a rebalance, in different ways, depending on the scenario they want to test.\nSome block the StateResponseCommand so that the they block the insertion of particular keys. Some only block the CacheTopologyControlCommand(REBALANCE_PHASE_CONFIRM) commands so the cache stays in a particular topology phase (usually READ_OLD_WRITE_ALL) after state transfer has finished.\nSome block the sender side, with ControlledRpcManager or ControlledTransport. Some block the receiver side, with many impls of InboundInvocationHandler, PerCacheInboundInvocationHandler, LocalTopologyManagerImpl, StateProviderImpl, or StateConsumerImpl.", "author": "danberindei", "createdAt": "2020-01-13T17:59:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3OTA2MA=="}], "type": "inlineReview"}, {"oid": "6d679ec786cf71ea2163fbd859004470d7aab136", "url": "https://github.com/infinispan/infinispan/commit/6d679ec786cf71ea2163fbd859004470d7aab136", "message": "some rework comments", "committedDate": "2020-01-13T15:54:26Z", "type": "commit"}, {"oid": "a3f4aed51defa848a5ffade45f95bda2c7fcc086", "url": "https://github.com/infinispan/infinispan/commit/a3f4aed51defa848a5ffade45f95bda2c7fcc086", "message": "hibernate fixes", "committedDate": "2020-01-13T17:08:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyNjA2NQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365926065", "bodyText": "I was thinking more along the lines of checkExpiredMaxIdle()", "author": "danberindei", "createdAt": "2020-01-13T17:19:36Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -412,58 +411,105 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long access = localLastAccess(key, value, segment);\n+   protected CompletionStage<Boolean> touchEntryAndReturnIfExpired(InternalCacheEntry ice, int segment) {", "originalCommit": "a3f4aed51defa848a5ffade45f95bda2c7fcc086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1MDMxMw==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r366950313", "bodyText": "Okay.", "author": "wburns", "createdAt": "2020-01-15T15:46:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyNjA2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyODQ2Ng==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365928466", "bodyText": "extra space", "author": "danberindei", "createdAt": "2020-01-13T17:24:50Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -412,58 +411,105 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long access = localLastAccess(key, value, segment);\n+   protected CompletionStage<Boolean> touchEntryAndReturnIfExpired(InternalCacheEntry ice, int segment) {\n+      Object key = ice.getKey();\n+      return attemptTouchAndReturnIfExpired(key, segment)\n+            .handle((expired, t) -> {\n+               if (t != null) {\n+                  Throwable innerT = CompletableFutures.extractException(t);\n+                  if (innerT instanceof OutdatedTopologyException) {\n+                     if (trace) {\n+                        log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+                     }\n+                     return attemptTouchAndReturnIfExpired(key, segment);\n+                  }\n+                  return CompletableFutures.<Boolean>completedExceptionFuture(t);\n+               } else {\n+                  return CompletableFuture.completedFuture(expired);\n+               }\n+            })\n+            .thenCompose(Function.identity());\n+   }\n \n-      LocalizedCacheTopology topology = distributionManager.getCacheTopology();\n-      DistributionInfo info = topology.getDistribution(key);\n+   private CompletionStage<Boolean> attemptTouchAndReturnIfExpired(Object key, int segment) {\n+      LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n \n-      if (trace) {\n-         log.tracef(\"Asking all read owners %s for key: %s - for latest access time\", info.readOwners(), key);\n-      }\n+      TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n+      touchCommand.setTopologyId(lct.getTopologyId());\n \n-      // Need to gather last access times\n-      RetrieveLastAccessCommand rlac = cf.running().buildRetrieveLastAccessCommand(key, value, segment);\n-      rlac.setTopologyId(topology.getTopologyId());\n+      CompletionStage<Boolean> remoteStage = invokeTouchCommandRemotely(touchCommand, lct, segment);\n+      touchCommand.init(componentRegistry, false);\n+      CompletableFuture<Object> localStage = touchCommand.invokeAsync();\n \n-      // In scattered cache read owners will only contain primary\n-      return rpcManager.invokeCommand(info.readOwners(), rlac, new MaxResponseCollector<>(access),\n-            rpcManager.getSyncRpcOptions()).toCompletableFuture();\n+      return remoteStage.thenCombine(localStage, (remoteTouch, localTouch) -> {\n+         if (remoteTouch == Boolean.TRUE && localTouch == Boolean.TRUE) {\n+            return Boolean.FALSE;\n+         }\n+         return Boolean.TRUE;\n+      });\n    }\n \n-   static class MaxResponseCollector<T extends Comparable<T>> extends ValidResponseCollector<T> {\n-      T highest;\n+   private CompletionStage<Boolean> invokeTouchCommandRemotely(TouchCommand touchCommand, LocalizedCacheTopology lct,\n+         int segment) {\n+      boolean isScattered = configuration.clustering().cacheMode().isScattered();\n+      DistributionInfo di = lct.getSegmentDistribution(segment);\n+      // Scattered any node could be a backup, so we have to touch all members\n+      List<Address> owners =  isScattered ? lct.getActualMembers() : di.writeOwners();", "originalCommit": "a3f4aed51defa848a5ffade45f95bda2c7fcc086", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzMzE3NA==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365933174", "bodyText": "Empty tags", "author": "danberindei", "createdAt": "2020-01-13T17:34:58Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java", "diffHunk": "@@ -252,22 +260,44 @@ private void deleteFromStoresAndNotify(K key, V value, Metadata metadata) {\n             cacheNotifier.notifyCacheEntryExpired(key, value, metadata, null)));\n    }\n \n-   protected Long localLastAccess(Object key, Object value, int segment) {\n-      InternalCacheEntry ice = dataContainer.running().peek(segment, key);\n-      if (ice != null && (value == null || value.equals(ice.getValue())) &&\n-            !ice.isExpired(timeService.wallClockTime())) {\n-         return ice.getLastUsed();\n+   @Override\n+   public CompletionStage<Boolean> handlePossibleExpiration(InternalCacheEntry<K, V> ice, int segment, boolean isWrite) {\n+      long currentTime = timeService.wallClockTime();\n+      if (ice.isExpired(currentTime)) {\n+         if (trace) {\n+            log.tracef(\"Retrieved entry for key %s was expired locally, attempting expiration removal\", ice.getKey());\n+         }\n+         CompletableFuture<Boolean> expiredStage = entryExpiredInMemory(ice, currentTime, isWrite);\n+         if (trace) {\n+            expiredStage = expiredStage.thenApply(expired -> {\n+               if (expired == Boolean.FALSE) {\n+                  log.tracef(\"Retrieved entry for key %s was found to not be expired.\", ice.getKey());\n+               } else {\n+                  log.tracef(\"Retrieved entry for key %s was confirmed to be expired.\", ice.getKey());\n+               }\n+               return expired;\n+            });\n+         }\n+         return expiredStage;\n+      } else if (!isWrite && ice.canExpireMaxIdle()) {\n+         return touchEntryAndReturnIfExpired(ice, segment);\n       }\n-      return null;\n+      return CompletableFutures.completedFalse();\n    }\n \n-   @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long lastAccess = localLastAccess(key, value, segment);\n-      if (lastAccess != null) {\n-         return CompletableFuture.completedFuture(lastAccess);\n-      }\n-      return CompletableFutures.completedNull();\n+   /**\n+    * Response is whether the value should be treated as expired - thus if both local and remote were able to touch\n+    * then the value is not expired. Note this is different then the touch command's response normally as that mentions\n+    * if it was touched or not\n+    * @param entry\n+    * @param segment\n+    * @return", "originalCommit": "a3f4aed51defa848a5ffade45f95bda2c7fcc086", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzMzU3MQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365933571", "bodyText": "IMO we shouldn't mention remote invocations here, just the first part, since ExpirationManagerImpl doesn't go remotely.", "author": "danberindei", "createdAt": "2020-01-13T17:35:43Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java", "diffHunk": "@@ -252,22 +260,44 @@ private void deleteFromStoresAndNotify(K key, V value, Metadata metadata) {\n             cacheNotifier.notifyCacheEntryExpired(key, value, metadata, null)));\n    }\n \n-   protected Long localLastAccess(Object key, Object value, int segment) {\n-      InternalCacheEntry ice = dataContainer.running().peek(segment, key);\n-      if (ice != null && (value == null || value.equals(ice.getValue())) &&\n-            !ice.isExpired(timeService.wallClockTime())) {\n-         return ice.getLastUsed();\n+   @Override\n+   public CompletionStage<Boolean> handlePossibleExpiration(InternalCacheEntry<K, V> ice, int segment, boolean isWrite) {\n+      long currentTime = timeService.wallClockTime();\n+      if (ice.isExpired(currentTime)) {\n+         if (trace) {\n+            log.tracef(\"Retrieved entry for key %s was expired locally, attempting expiration removal\", ice.getKey());\n+         }\n+         CompletableFuture<Boolean> expiredStage = entryExpiredInMemory(ice, currentTime, isWrite);\n+         if (trace) {\n+            expiredStage = expiredStage.thenApply(expired -> {\n+               if (expired == Boolean.FALSE) {\n+                  log.tracef(\"Retrieved entry for key %s was found to not be expired.\", ice.getKey());\n+               } else {\n+                  log.tracef(\"Retrieved entry for key %s was confirmed to be expired.\", ice.getKey());\n+               }\n+               return expired;\n+            });\n+         }\n+         return expiredStage;\n+      } else if (!isWrite && ice.canExpireMaxIdle()) {\n+         return touchEntryAndReturnIfExpired(ice, segment);\n       }\n-      return null;\n+      return CompletableFutures.completedFalse();\n    }\n \n-   @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long lastAccess = localLastAccess(key, value, segment);\n-      if (lastAccess != null) {\n-         return CompletableFuture.completedFuture(lastAccess);\n-      }\n-      return CompletableFutures.completedNull();\n+   /**\n+    * Response is whether the value should be treated as expired - thus if both local and remote were able to touch", "originalCommit": "a3f4aed51defa848a5ffade45f95bda2c7fcc086", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzNTUxNQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365935515", "bodyText": "I prefer saying a stage that will complete with {@code true} if the entry was expired and {@code false} otherwise.\nAlso duplicated in the main comment (The return stage will contain whether the entry was actually expired or not)", "author": "danberindei", "createdAt": "2020-01-13T17:39:47Z", "path": "core/src/main/java/org/infinispan/expiration/impl/InternalExpirationManager.java", "diffHunk": "@@ -74,14 +74,12 @@ default void handleInStoreExpiration(MarshallableEntry<K, V> marshalledEntry) {\n    }\n \n    /**\n-    * Retrieves the last access time for the given key in the data container if it is using max idle.\n-    * If the entry is not in the container or it is expired it will return null.\n-    * If the entry is present but cannot expire via max idle, it will return -1\n-    * If the entry is present and can expire via max idle but hasn't it will return a number > 0\n-    * @param key the key to retrieve the access time for\n-    * @param value the value to match if desired (this can be null)\n-    * @param segment the segment for the given key\n-    * @return the last access time if available\n+    * Handles processing for an entry that may be expired. This will remove the entry if it is expired, otherwise may\n+    * touch if it uses max idle. The return stage will contain whether the entry was actually expired or not\n+    * @param entry entry that may be expired\n+    * @param segment the segment of the entry\n+    * @param isWrite whether the command that saw the expired value was a write or not\n+    * @return a stage that when complete will return if the entry was expired", "originalCommit": "a3f4aed51defa848a5ffade45f95bda2c7fcc086", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzNzI0NA==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365937244", "bodyText": "can suggests to me that it is parametrized and can do each independently. I'd rather say\nThis command updates a cache entry's last access timestamp. If eviction is enabled, it will also update the recency information.", "author": "danberindei", "createdAt": "2020-01-13T17:43:23Z", "path": "core/src/main/java/org/infinispan/expiration/impl/TouchCommand.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package org.infinispan.expiration.impl;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.infinispan.commands.InitializableCommand;\n+import org.infinispan.commands.TopologyAffectedCommand;\n+import org.infinispan.commands.remote.BaseRpcCommand;\n+import org.infinispan.commons.io.UnsignedNumeric;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.container.impl.InternalDataContainer;\n+import org.infinispan.distribution.DistributionInfo;\n+import org.infinispan.distribution.DistributionManager;\n+import org.infinispan.distribution.LocalizedCacheTopology;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.statetransfer.OutdatedTopologyException;\n+import org.infinispan.util.ByteString;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+/**\n+ * This command can be invoked to update a cache entry's recent access. This can involve updating its last access", "originalCommit": "a3f4aed51defa848a5ffade45f95bda2c7fcc086", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzNzk1OQ==", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365937959", "bodyText": "I think you can answer the question now :)", "author": "danberindei", "createdAt": "2020-01-13T17:44:50Z", "path": "core/src/main/java/org/infinispan/expiration/impl/TouchCommand.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package org.infinispan.expiration.impl;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.infinispan.commands.InitializableCommand;\n+import org.infinispan.commands.TopologyAffectedCommand;\n+import org.infinispan.commands.remote.BaseRpcCommand;\n+import org.infinispan.commons.io.UnsignedNumeric;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.container.impl.InternalDataContainer;\n+import org.infinispan.distribution.DistributionInfo;\n+import org.infinispan.distribution.DistributionManager;\n+import org.infinispan.distribution.LocalizedCacheTopology;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.statetransfer.OutdatedTopologyException;\n+import org.infinispan.util.ByteString;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+/**\n+ * This command can be invoked to update a cache entry's recent access. This can involve updating its last access\n+ * with max idle as well as recent eviction access times.\n+ * <p>\n+ * This command returns a Boolean that is whether this command was able to touch the value or not.\n+ */\n+public class TouchCommand extends BaseRpcCommand implements InitializableCommand, TopologyAffectedCommand {\n+   public static final byte COMMAND_ID = 66;\n+\n+   private Object key;\n+   private int segment;\n+   private int topologyId = -1;\n+\n+   private InternalDataContainer internalDataContainer;\n+   private TimeService timeService;\n+   private DistributionManager distributionManager;\n+\n+   // Only here for CommandIdUniquenessTest\n+   private TouchCommand() { super(null); }\n+\n+   public TouchCommand(ByteString cacheName) {\n+      super(cacheName);\n+   }\n+\n+   public TouchCommand(ByteString cacheName, Object key, int segment) {\n+      super(cacheName);\n+      this.key = key;\n+      this.segment = segment;\n+   }\n+\n+   @Override\n+   public byte getCommandId() {\n+      return COMMAND_ID;\n+   }\n+\n+   @Override\n+   public boolean isReturnValueExpected() {\n+      return true;\n+   }\n+\n+   @Override\n+   public void writeTo(ObjectOutput output) throws IOException {\n+      output.writeObject(key);\n+      UnsignedNumeric.writeUnsignedInt(output, segment);\n+   }\n+\n+   @Override\n+   public void readFrom(ObjectInput input) throws IOException, ClassNotFoundException {\n+      key = input.readObject();\n+      segment = UnsignedNumeric.readUnsignedInt(input);\n+   }\n+\n+   @Override\n+   public void init(ComponentRegistry componentRegistry, boolean isRemote) {\n+      internalDataContainer = componentRegistry.getInternalDataContainer().running();\n+      timeService = componentRegistry.getTimeService();\n+      // Invalidation cache doesn't set topology id - so we don't want to throw OTE in invokeAsync\n+      if (!componentRegistry.getConfiguration().clustering().cacheMode().isInvalidation()) {\n+         distributionManager = componentRegistry.getDistributionManager();\n+      }\n+   }\n+\n+   @Override\n+   public int getTopologyId() {\n+      return topologyId;\n+   }\n+\n+   @Override\n+   public void setTopologyId(int topologyId) {\n+      this.topologyId = topologyId;\n+   }\n+\n+   @Override\n+   public CompletableFuture<Object> invokeAsync() {\n+      boolean touched = internalDataContainer.touch(segment, key, timeService.wallClockTime());\n+      // Hibernate currently disables clustered expiration manager, which means we can have a topology id of -1\n+      // when using a clustered cache mode\n+      if (distributionManager != null && topologyId != -1) {\n+         LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n+         int currentTopologyId = lct.getTopologyId();\n+         if (currentTopologyId != topologyId) {\n+            return CompletableFutures.completedExceptionFuture(OutdatedTopologyException.RETRY_NEXT_TOPOLOGY);\n+         }\n+         DistributionInfo di = lct.getSegmentDistribution(segment);\n+         // If our node is a write owner but not read owner, that means we may not have the value yet - so we just\n+         // say we were touched anyways\n+         // TODO: is this is an issue with concurrent state response and not touching the new value?", "originalCommit": "a3f4aed51defa848a5ffade45f95bda2c7fcc086", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}