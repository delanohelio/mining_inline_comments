{"pr_number": 8300, "pr_title": "ISPN-10446 Protobuf resource", "pr_createdAt": "2020-05-09T13:08:55Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8300", "timeline": [{"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "url": "https://github.com/infinispan/infinispan/commit/a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "message": "ISPN-10446 Protobuf Schema endpoint doc", "committedDate": "2020-05-11T22:05:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2NDMwMA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423564300", "bodyText": "This lookup should be done in the constructor, as it does not depend on the request: we are always returning in the same format", "author": "gustavonalle", "createdAt": "2020-05-12T08:42:44Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);", "originalCommit": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1NzcyOA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423857728", "bodyText": "it does depend when authz is enabled with the subject ...", "author": "karesti", "createdAt": "2020-05-12T16:10:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2NDMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2ODY4NQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423568685", "bodyText": "This should be non-blocking. I reckon it should be similar to \n  \n    \n      infinispan/server/rest/src/main/java/org/infinispan/rest/resources/CacheManagerResource.java\n    \n    \n         Line 221\n      in\n      1fc5a2e\n    \n    \n    \n    \n\n        \n          \n           return Flowable.fromIterable(cachesHealth.entrySet()) \n        \n    \n  \n\n or at least wrap it in an executor", "author": "gustavonalle", "createdAt": "2020-05-12T08:49:00Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      List<ProtoSchema> protoSchemas = cache.entrySet().stream()\n+            .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+            .map(cacheEntry -> {\n+               String error = (String) cache\n+                     .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               ProtoSchema protoSchema = new ProtoSchema();\n+               protoSchema.name = cacheEntry.getKey().toString();\n+               protoSchema.validation = error == null ? \"success\" : error;\n+               return protoSchema;\n+            })\n+            .collect(Collectors.toList());", "originalCommit": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1NzMyNQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r424257325", "bodyText": "done", "author": "karesti", "createdAt": "2020-05-13T08:19:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2ODY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxMTYzNg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r424411636", "bodyText": "This is not fixed yet. It needs to be done using the blocking executor, because this cache is persisted. To be honest (not for this PR) the server/rest module needs blockhound added to find these automatically.", "author": "wburns", "createdAt": "2020-05-13T12:51:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2ODY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NzMyNQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423577325", "bodyText": "The REST server should return code 204 (HttpResponseStatus.NO_CONTENT) for POST without a response body", "author": "gustavonalle", "createdAt": "2020-05-12T09:01:58Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      List<ProtoSchema> protoSchemas = cache.entrySet().stream()\n+            .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+            .map(cacheEntry -> {\n+               String error = (String) cache\n+                     .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               ProtoSchema protoSchema = new ProtoSchema();\n+               protoSchema.name = cacheEntry.getKey().toString();\n+               protoSchema.validation = error == null ? \"success\" : error;\n+               return protoSchema;\n+            })\n+            .collect(Collectors.toList());\n+\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+      try {\n+         responseBuilder\n+               .status(OK)\n+               .contentType(APPLICATION_JSON)\n+               .entity(invocationHelper.getMapper().writeValueAsBytes(protoSchemas));\n+      } catch (JsonProcessingException e) {\n+         responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+      }\n+\n+      return CompletableFuture.completedFuture(responseBuilder.build());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException();\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      builder.status(HttpResponseStatus.OK);", "originalCommit": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQwMjg5Mg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r424402892", "bodyText": "I have changed this dealing POST and PUT (create and update)", "author": "karesti", "createdAt": "2020-05-13T12:38:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NzMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3Nzg1NA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423577854", "bodyText": "No need to return a body if the validation is success: it should simply return code 204 (see above)", "author": "gustavonalle", "createdAt": "2020-05-12T09:02:50Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      List<ProtoSchema> protoSchemas = cache.entrySet().stream()\n+            .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+            .map(cacheEntry -> {\n+               String error = (String) cache\n+                     .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               ProtoSchema protoSchema = new ProtoSchema();\n+               protoSchema.name = cacheEntry.getKey().toString();\n+               protoSchema.validation = error == null ? \"success\" : error;\n+               return protoSchema;\n+            })\n+            .collect(Collectors.toList());\n+\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+      try {\n+         responseBuilder\n+               .status(OK)\n+               .contentType(APPLICATION_JSON)\n+               .entity(invocationHelper.getMapper().writeValueAsBytes(protoSchemas));\n+      } catch (JsonProcessingException e) {\n+         responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+      }\n+\n+      return CompletableFuture.completedFuture(responseBuilder.build());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException();\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      builder.status(HttpResponseStatus.OK);\n+      return cache.putAsync(schemaName, contents.asString())\n+            .thenCompose(r -> cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX))\n+            .thenApply(validationError -> {\n+               String validation = \"success\";", "originalCommit": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4MDE1Mw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423580153", "bodyText": "It'd be better to report errors in the same format as other resources. This is how query reports it:\n{\n    \"error\":{\n        \"message\":\"Invalid search request\",\n        \"cause\":\"org.infinispan.ParseException...\"\n    }\n}\nmessage is a user friendly description of the error and cause is the output of exception.stackTrace() where applicable.\nThere is already the class org.infinispan.query.remote.json.JsonQueryErrorResult for this format, I think we should move it to the rest module and reuse for non-query resources", "author": "gustavonalle", "createdAt": "2020-05-12T09:06:24Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      List<ProtoSchema> protoSchemas = cache.entrySet().stream()\n+            .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+            .map(cacheEntry -> {\n+               String error = (String) cache\n+                     .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               ProtoSchema protoSchema = new ProtoSchema();\n+               protoSchema.name = cacheEntry.getKey().toString();\n+               protoSchema.validation = error == null ? \"success\" : error;\n+               return protoSchema;\n+            })\n+            .collect(Collectors.toList());\n+\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+      try {\n+         responseBuilder\n+               .status(OK)\n+               .contentType(APPLICATION_JSON)\n+               .entity(invocationHelper.getMapper().writeValueAsBytes(protoSchemas));\n+      } catch (JsonProcessingException e) {\n+         responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+      }\n+\n+      return CompletableFuture.completedFuture(responseBuilder.build());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException();\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      builder.status(HttpResponseStatus.OK);\n+      return cache.putAsync(schemaName, contents.asString())\n+            .thenCompose(r -> cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX))\n+            .thenApply(validationError -> {\n+               String validation = \"success\";\n+               if(validationError != null) {\n+                  validation = validationError.toString();\n+                  builder.status(HttpResponseStatus.BAD_REQUEST);\n+               }\n+               String json = String.format(\"{validation:%s}\", validation);", "originalCommit": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxMTUyNg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r424411526", "bodyText": "ok", "author": "karesti", "createdAt": "2020-05-13T12:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4MDE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4MzcxMA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423583710", "bodyText": "Nitpick: \"accept\" header is not used in PUT requests", "author": "gustavonalle", "createdAt": "2020-05-12T09:12:02Z", "path": "server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.infinispan.rest.assertion.ResponseAssertion;\n+import org.testng.annotations.Test;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON_TYPE;\n+import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN_TYPE;\n+import static org.infinispan.commons.util.Util.getResourceAsString;\n+import static org.testng.AssertJUnit.assertEquals;\n+\n+@Test(groups = \"functional\", testName = \"rest.ProtobufResourceTest\")\n+public class ProtobufResourceTest extends AbstractRestResourceTest {\n+\n+   @Override\n+   public Object[] factory() {\n+      return new Object[]{\n+            new ProtobufResourceTest().withSecurity(false),\n+            new ProtobufResourceTest().withSecurity(true),\n+      };\n+   }\n+\n+   public void getEmptySchemas() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL)\n+            .method(HttpMethod.GET)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      JsonNode jsonNode = new ObjectMapper().readTree(response.getContentAsString());\n+      assertEquals(\"[ ]\", jsonNode.toPrettyString());\n+   }\n+\n+   @Test\n+   public void getNotFoundProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/coco\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isNotFound();\n+   }\n+\n+   @Test\n+   public void putAndGetWrongProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+      String errorProto = getResourceAsString(\"error.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/error\")\n+            .content(new StringContentProvider(errorProto))\n+            .header(\"Content-type\", \"text/plain; charset=utf-8\")\n+            .method(HttpMethod.PUT)\n+            .accept(APPLICATION_JSON_TYPE).send();", "originalCommit": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4NDA3MA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423584070", "bodyText": ".accept can be removed", "author": "gustavonalle", "createdAt": "2020-05-12T09:12:37Z", "path": "server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.infinispan.rest.assertion.ResponseAssertion;\n+import org.testng.annotations.Test;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON_TYPE;\n+import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN_TYPE;\n+import static org.infinispan.commons.util.Util.getResourceAsString;\n+import static org.testng.AssertJUnit.assertEquals;\n+\n+@Test(groups = \"functional\", testName = \"rest.ProtobufResourceTest\")\n+public class ProtobufResourceTest extends AbstractRestResourceTest {\n+\n+   @Override\n+   public Object[] factory() {\n+      return new Object[]{\n+            new ProtobufResourceTest().withSecurity(false),\n+            new ProtobufResourceTest().withSecurity(true),\n+      };\n+   }\n+\n+   public void getEmptySchemas() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL)\n+            .method(HttpMethod.GET)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      JsonNode jsonNode = new ObjectMapper().readTree(response.getContentAsString());\n+      assertEquals(\"[ ]\", jsonNode.toPrettyString());\n+   }\n+\n+   @Test\n+   public void getNotFoundProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/coco\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isNotFound();\n+   }\n+\n+   @Test\n+   public void putAndGetWrongProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+      String errorProto = getResourceAsString(\"error.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/error\")\n+            .content(new StringContentProvider(errorProto))\n+            .header(\"Content-type\", \"text/plain; charset=utf-8\")\n+            .method(HttpMethod.PUT)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      String validation = \"java.lang.IllegalStateException:\"\n+            + \" Syntax error in error.proto at 3:8: unexpected label: messoge\";\n+\n+      ResponseAssertion.assertThat(response).isBadRequest();\n+      ResponseAssertion.assertThat(response).hasReturnedText(\"{validation:\" + validation + \"}\");\n+\n+      checkListProtobufEndpointUrl(\"error.proto\", validation);\n+   }\n+\n+   @Test\n+   public void crudCorrectProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/person\")\n+            .content(new StringContentProvider(personProto))\n+            .header(\"Content-type\", \"text/plain; charset=utf-8\")\n+            .method(HttpMethod.PUT)\n+            .accept(APPLICATION_JSON_TYPE).send();", "originalCommit": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1ODgwNA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r424258804", "bodyText": "ok", "author": "karesti", "createdAt": "2020-05-13T08:21:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4NDA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4NzQ1MQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423587451", "bodyText": "PUT and POST should have different behaviours:  POST will return CONFLICT if the entity with the same name already exists, while PUT will replace the entity. Take a look at how the CacheResource handles both methods:\n\n  \n    \n      infinispan/server/rest/src/main/java/org/infinispan/rest/resources/BaseCacheResource.java\n    \n    \n         Line 82\n      in\n      6d78de6\n    \n    \n    \n    \n\n        \n          \n           CompletionStage<RestResponse> putValueToCache(RestRequest request) { \n        \n    \n  \n\n\nWe should either discern between the two verbs, or support just the PUT", "author": "gustavonalle", "createdAt": "2020-05-12T09:17:55Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)", "originalCommit": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxMTYyOQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r424411629", "bodyText": "I'm doing this", "author": "karesti", "createdAt": "2020-05-13T12:51:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4NzQ1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4OTIyNw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423589227", "bodyText": "I am conflicted between /v2/protobuf or /v2/schema for the REST endpoint path. WDYT @anistor?", "author": "gustavonalle", "createdAt": "2020-05-12T09:20:34Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)", "originalCommit": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5NzYwMw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423597603", "bodyText": "@gustavonalle I know the question isn't for me but I'd be in favour of /v2/schema for consistency with the CLI as that is the command you use to upload .proto files.", "author": "oraNod", "createdAt": "2020-05-12T09:33:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4OTIyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwOTcwNQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423609705", "bodyText": "Allright!!!", "author": "karesti", "createdAt": "2020-05-12T09:53:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4OTIyNw=="}], "type": "inlineReview"}, {"oid": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8", "url": "https://github.com/infinispan/infinispan/commit/5280cbfc7238abdbed852cd7cf8e9a80c824bbb8", "message": "ISPN-10446 Protobuf Schema endpoint doc", "committedDate": "2020-05-13T22:00:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r424954224", "bodyText": "@wburns this is not ok ?", "author": "karesti", "createdAt": "2020-05-14T08:19:50Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,229 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.query.remote.json.JsonQueryErrorResult;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return Flowable.fromIterable(cache.entrySet())", "originalCommit": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExMDE4OQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425110189", "bodyText": "No, unfortunately the iterator returned from cache.entrySet() is blocking. This is why normally the ClusterPublisher is used as it allows for non blocking \"iteration\". But unfortunately without the new API, there is no easy way to do it with media type conversions.\nI think the simplest way for now is just to delegate this call to the blocking thread pool.", "author": "wburns", "createdAt": "2020-05-14T12:50:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExMDU4Ng==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425110586", "bodyText": "That is unless the PROTOBUF_METADATA_CACHE_NAME cache doesn't do any media type conversions, then you can just use the ClusterPublisherManager directly.", "author": "wburns", "createdAt": "2020-05-14T12:51:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExMzE2MQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425113161", "bodyText": "ClusterPublisherManager does not work with EncoderCache instances?", "author": "gustavonalle", "createdAt": "2020-05-14T12:55:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExMzgxMg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425113812", "bodyText": "It is not exposed via an EncoderCache in any way. It is solely a component currently.", "author": "wburns", "createdAt": "2020-05-14T12:56:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExNTYxNg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425115616", "bodyText": "The problem is I was expecting to effectively expose this from the new API, so I didn't add anything for out internal use. Maybe we should add an internal method only somewhere. The issue with ClusterPublisherManager is that the API of it is probably unwieldy to power users and we normally hide a lot of that from the user.", "author": "wburns", "createdAt": "2020-05-14T12:59:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExNTk0MQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425115941", "bodyText": "So this one should be changed as well?\n\n  \n    \n      infinispan/server/rest/src/main/java/org/infinispan/rest/resources/CacheManagerResource.java\n    \n    \n         Line 221\n      in\n      1fc5a2e\n    \n    \n    \n    \n\n        \n          \n           return Flowable.fromIterable(cachesHealth.entrySet())", "author": "gustavonalle", "createdAt": "2020-05-14T12:59:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExNjYzNQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425116635", "bodyText": "So this one should be changed as well?\n\n  \n    \n      infinispan/server/rest/src/main/java/org/infinispan/rest/resources/CacheManagerResource.java\n    \n    \n         Line 221\n      in\n      1fc5a2e\n    \n    \n    \n    \n\n        \n          \n           return Flowable.fromIterable(cachesHealth.entrySet()) \n        \n    \n  \n\n\n\nI have to check the cachesHealth configuration. If it can be distributed or have a store, then yes it needs to be changed.", "author": "wburns", "createdAt": "2020-05-14T13:00:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExNzE4Nw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425117187", "bodyText": "Oh actually cachesHealth is just a HashMap :) However, \n  \n    \n      infinispan/server/rest/src/main/java/org/infinispan/rest/resources/CacheManagerResource.java\n    \n    \n         Line 214\n      in\n      1fc5a2e\n    \n    \n    \n    \n\n        \n          \n           cacheNames.removeAll(internalCacheRegistry.getInternalCacheNames()); \n        \n    \n  \n\n can block as mentioned in the comment.", "author": "wburns", "createdAt": "2020-05-14T13:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExNzM5Ng==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425117396", "bodyText": "As I mentioned if we add blockhound to server/rest we won't have to conjecture about these and it will just fail the test if it blocks :)", "author": "wburns", "createdAt": "2020-05-14T13:01:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUwNDU0OA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425504548", "bodyText": "Check out #8323", "author": "wburns", "createdAt": "2020-05-15T00:39:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}], "type": "inlineReview"}, {"oid": "e1840b65f3b8a36d580ed1b39f6b7b4df67ab906", "url": "https://github.com/infinispan/infinispan/commit/e1840b65f3b8a36d580ed1b39f6b7b4df67ab906", "message": "ISPN-10446 Protobuf Schema Resource docs", "committedDate": "2020-05-14T08:25:39Z", "type": "forcePushed"}, {"oid": "f3fcdcae4b986f3179ef1336635cc43558d6d91f", "url": "https://github.com/infinispan/infinispan/commit/f3fcdcae4b986f3179ef1336635cc43558d6d91f", "message": "ISPN-10446 Protobuf Schema Resource docs", "committedDate": "2020-05-15T08:22:57Z", "type": "forcePushed"}, {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589", "url": "https://github.com/infinispan/infinispan/commit/76cff2bac32cd828189959a2fa2caddd2b478589", "message": "ISPN-10446 Protobuf Schema Resource docs", "committedDate": "2020-05-15T14:00:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0MDY1NQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425940655", "bodyText": "Nitpick: extra spaces.", "author": "wburns", "createdAt": "2020-05-15T17:17:28Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3MTc3NQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426571775", "bodyText": "ok", "author": "karesti", "createdAt": "2020-05-18T11:57:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0MDY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0MzUzNw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425943537", "bodyText": "I find .collect(Collectors.toSet()) is more succinct.", "author": "wburns", "createdAt": "2020-05-15T17:23:28Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3MTQzNw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426571437", "bodyText": "ok", "author": "karesti", "createdAt": "2020-05-18T11:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0MzUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjEwNQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425946105", "bodyText": "This is another blocking call here. Unfortunately, the more I look at this it should really be done using BlockingManager#blockingPublisher on the Flowable.fromIterable(cache.entrySet()) and then doing non blocking calls aftwerds.", "author": "wburns", "createdAt": "2020-05-15T17:28:25Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk2MDkyNw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425960927", "bodyText": "But I guess we can leave this as is for now. This whole chunk will need to be redone to use a ClusterPublisher at some point anyways.", "author": "wburns", "createdAt": "2020-05-15T17:57:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjM1OQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425946359", "bodyText": "It appears we are never using the value, so just cache.keySet() should be good.", "author": "wburns", "createdAt": "2020-05-15T17:28:56Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU4MTEzMA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426581130", "bodyText": "ok", "author": "karesti", "createdAt": "2020-05-18T12:15:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjQ3OQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425946479", "bodyText": "This seems a bit odd that we are collecting into a Set to then sort and then collect it into a List. can we not just use http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Flowable.html#sorted-java.util.Comparator- and then collect that into a List that is finally mapped to the response?", "author": "wburns", "createdAt": "2020-05-15T17:29:11Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU4MzgzMA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426583830", "bodyText": "yes", "author": "karesti", "createdAt": "2020-05-18T12:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjU4OQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425946589", "bodyText": "Nitpick: extra spaces.", "author": "wburns", "createdAt": "2020-05-15T17:29:24Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425946917", "bodyText": "I am not sure how error handling is done on the rest side, but when returning a CompletionStage, I would normally expect this exception to be in the Stage.", "author": "wburns", "createdAt": "2020-05-15T17:30:04Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU4NTY0Nw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426585647", "bodyText": "the exception is catchd in the BaseHttpRequestHandler\nI'm following other examples\nwe should maybe talk about the overral design on this ?", "author": "karesti", "createdAt": "2020-05-18T12:23:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5ODUyMw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426698523", "bodyText": "Sorry I don't see how BaseHttpRequestHandler can be possibly handling this. The handleError is only invoked from 2 places checking CompletionStage results. If a method can return a CompletionStage, it should not be throwing an exception that is from user input. It should only be from bugs in our code.", "author": "wburns", "createdAt": "2020-05-18T15:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwNjAwNg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426706006", "bodyText": "It is caught at RestDispatcherImpl#dispatch btw.", "author": "wburns", "createdAt": "2020-05-18T15:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwNzY2MA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426707660", "bodyText": "can we deal this in another PR and talk about it with @gustavonalle ? because I'm not adding anything new and IMO this is another PR more global subject", "author": "karesti", "createdAt": "2020-05-18T15:24:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwODQ4Mw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426708483", "bodyText": "So I guess this code is okay, however it smells to me as we talked before at the F2F when the return type of a method is CompletionStage that any exceptions an invoker should be able to receive should be encapsulated in the Stage.", "author": "wburns", "createdAt": "2020-05-18T15:25:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc0MTIzMQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426741231", "bodyText": "BaseHttpRequestHandler#handleError should handle uncaught exceptions from the resources, and also log it\n\n  \n    \n      infinispan/server/rest/src/main/java/org/infinispan/rest/BaseHttpRequestHandler.java\n    \n    \n         Line 33\n      in\n      1f25924\n    \n    \n    \n    \n\n        \n          \n           getLogger().errorWhileResponding(responseException); \n        \n    \n  \n\n\nCould you please open a separate JIRA on how to align the error handling with what was discussed?", "author": "gustavonalle", "createdAt": "2020-05-18T16:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc1ODEzNw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426758137", "bodyText": "is this JIRA not enough ? https://issues.redhat.com/browse/ISPN-11853", "author": "karesti", "createdAt": "2020-05-18T16:40:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NzQyMQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425947421", "bodyText": "CompletableFutures.completedNull() instead.", "author": "wburns", "createdAt": "2020-05-15T17:31:02Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU4NjM3NQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426586375", "bodyText": "ok", "author": "karesti", "createdAt": "2020-05-18T12:25:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NzQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NzU2MQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425947561", "bodyText": "Nitpick: spacing on if blocks are missing here and a few below.", "author": "wburns", "createdAt": "2020-05-15T17:31:21Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU4NTkzOA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426585938", "bodyText": "ok", "author": "karesti", "createdAt": "2020-05-18T12:24:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NzU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjE1Mg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425952152", "bodyText": "Util.EMPTY_BYTE_ARRAY", "author": "wburns", "createdAt": "2020-05-15T17:40:20Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3ODcyMA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426578720", "bodyText": "k", "author": "karesti", "createdAt": "2020-05-18T12:10:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425952404", "bodyText": "Do we want to at least log the exception?", "author": "wburns", "createdAt": "2020-05-15T17:40:50Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3MzE3NA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426573174", "bodyText": "I change this launching an exception, but should not be happening\nit's uneven across resources now, sometimes we launch a throw new RestResponseException(e); and others just catch", "author": "karesti", "createdAt": "2020-05-18T12:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5NTU2OQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426695569", "bodyText": "I understand that different failures may be propagated. But I think we should at least log an exception instead of just catching it and making it impossible to debug.", "author": "wburns", "createdAt": "2020-05-18T15:07:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwNDA1OQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426704059", "bodyText": "And sorry the previous code doing this should at least log the error as a trace as well. We should not be swallowing exceptions, except for in very rare cases (especially when we can be reporting an error to the user).", "author": "wburns", "createdAt": "2020-05-18T15:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwOTI1MQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426709251", "bodyText": "there is a global issue concerning logging in the REST resources.\nCan we discuss this too with @gustavonalle so we can do some follow up PR on error handling and logging strategy, please?", "author": "karesti", "createdAt": "2020-05-18T15:26:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxMTc4Mg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426711782", "bodyText": "There is an error JSON document to report errors, the query endpoint is using it", "author": "gustavonalle", "createdAt": "2020-05-18T15:30:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxMzEyMA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426713120", "bodyText": "Some endpoints are not implementing this to handle JsonProcessingException as it is very unlikely (impossible?) this error would be thrown since the JSON is mapped via Jackson based on always the same class", "author": "gustavonalle", "createdAt": "2020-05-18T15:31:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjczMzA2OQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426733069", "bodyText": "I don't think just adding a single trace message needs another PR... And I have heard many a developer say something is very unlikely to impossible, including myself, and it ends up  happening. So I would rather have at least a trace message when I am completely ignoring a checked Exception.", "author": "wburns", "createdAt": "2020-05-18T16:00:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc0MzQ4OA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426743488", "bodyText": "Ok, I agree adding log won't hurt  \ud83d\ude04", "author": "gustavonalle", "createdAt": "2020-05-18T16:16:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MzcwMw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425953703", "bodyText": "Unfortunately this isn't quite a record class. Please make a constructor with final fields.", "author": "wburns", "createdAt": "2020-05-15T17:43:22Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return builder.contentType(APPLICATION_JSON).entity(detailsResponse).build();\n+               } else {\n+                  return builder.build();\n+               }\n+            });\n+   }\n+\n+   private boolean isOkOrCreated(NettyRestResponse.Builder builder) {\n+      return builder.getHttpStatus() == HttpResponseStatus.CREATED || builder.getHttpStatus() == HttpResponseStatus.OK;\n+   }\n+\n+   private CompletionStage<RestResponse> getSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      RestCacheManager<Object> restCacheManager = invocationHelper.getRestCacheManager();\n+      return restCacheManager.getPrivilegedInternalEntry(cache, schemaName, true).thenApply(entry -> {\n+         NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+         if(entry == null) {\n+            responseBuilder.status(HttpResponseStatus.NOT_FOUND.code());\n+         } else {\n+            responseBuilder.status(HttpResponseStatus.OK.code());\n+            responseBuilder.contentType(MediaType.TEXT_PLAIN);\n+            responseBuilder.entity(entry.getValue());\n+         }\n+         return responseBuilder.build();\n+      });\n+   }\n+\n+   private CompletionStage<RestResponse> deleteSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      RestCacheManager<Object> restCacheManager = invocationHelper.getRestCacheManager();\n+      AdvancedCache<Object, Object> protobufCache = restCacheManager.getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return restCacheManager.getPrivilegedInternalEntry(protobufCache, schemaName, true).thenCompose(entry -> {\n+         NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+         responseBuilder.status(HttpResponseStatus.NOT_FOUND);\n+\n+         if (entry instanceof InternalCacheEntry) {\n+               responseBuilder.status(HttpResponseStatus.NO_CONTENT.code());\n+               return restCacheManager.remove(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, schemaName,\n+                     MediaType.MATCH_ALL, request)\n+                     .thenApply(v -> responseBuilder.build());\n+         }\n+         return CompletableFuture.completedFuture(responseBuilder.build());\n+      });\n+   }\n+\n+   private ValidationError createErrorContent(String schemaName, String cause) {\n+      String message = \"Schema \" + schemaName + \" has errors\";\n+      ValidationError validationError = new ValidationError();\n+      validationError.message = message;\n+      validationError.cause = cause;\n+      return validationError;\n+   }\n+\n+   private String checkMandatorySchemaName(RestRequest request) {\n+      String schemaName = request.variables().get(\"schemaName\");\n+      if (schemaName == null)\n+         throw new NoKeyException(\"schemaName\");\n+      return schemaName.endsWith(ProtobufMetadataManager.PROTO_KEY_SUFFIX) ? schemaName : schemaName + ProtobufMetadataManager.PROTO_KEY_SUFFIX;\n+   }\n+\n+   static class ValidationError {", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk2MDA4NA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425960084", "bodyText": "Or does Jackson not like that?", "author": "wburns", "createdAt": "2020-05-15T17:55:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MzcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3NzcxNg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426577716", "bodyText": "all the other classes are done like this and I recall it is related", "author": "karesti", "createdAt": "2020-05-18T12:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MzcwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1NDEyMw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425954123", "bodyText": "Same here re: final and constructor.", "author": "wburns", "createdAt": "2020-05-15T17:44:12Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return builder.contentType(APPLICATION_JSON).entity(detailsResponse).build();\n+               } else {\n+                  return builder.build();\n+               }\n+            });\n+   }\n+\n+   private boolean isOkOrCreated(NettyRestResponse.Builder builder) {\n+      return builder.getHttpStatus() == HttpResponseStatus.CREATED || builder.getHttpStatus() == HttpResponseStatus.OK;\n+   }\n+\n+   private CompletionStage<RestResponse> getSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      RestCacheManager<Object> restCacheManager = invocationHelper.getRestCacheManager();\n+      return restCacheManager.getPrivilegedInternalEntry(cache, schemaName, true).thenApply(entry -> {\n+         NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+         if(entry == null) {\n+            responseBuilder.status(HttpResponseStatus.NOT_FOUND.code());\n+         } else {\n+            responseBuilder.status(HttpResponseStatus.OK.code());\n+            responseBuilder.contentType(MediaType.TEXT_PLAIN);\n+            responseBuilder.entity(entry.getValue());\n+         }\n+         return responseBuilder.build();\n+      });\n+   }\n+\n+   private CompletionStage<RestResponse> deleteSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      RestCacheManager<Object> restCacheManager = invocationHelper.getRestCacheManager();\n+      AdvancedCache<Object, Object> protobufCache = restCacheManager.getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return restCacheManager.getPrivilegedInternalEntry(protobufCache, schemaName, true).thenCompose(entry -> {\n+         NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+         responseBuilder.status(HttpResponseStatus.NOT_FOUND);\n+\n+         if (entry instanceof InternalCacheEntry) {\n+               responseBuilder.status(HttpResponseStatus.NO_CONTENT.code());\n+               return restCacheManager.remove(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, schemaName,\n+                     MediaType.MATCH_ALL, request)\n+                     .thenApply(v -> responseBuilder.build());\n+         }\n+         return CompletableFuture.completedFuture(responseBuilder.build());\n+      });\n+   }\n+\n+   private ValidationError createErrorContent(String schemaName, String cause) {\n+      String message = \"Schema \" + schemaName + \" has errors\";\n+      ValidationError validationError = new ValidationError();\n+      validationError.message = message;\n+      validationError.cause = cause;\n+      return validationError;\n+   }\n+\n+   private String checkMandatorySchemaName(RestRequest request) {\n+      String schemaName = request.variables().get(\"schemaName\");\n+      if (schemaName == null)\n+         throw new NoKeyException(\"schemaName\");\n+      return schemaName.endsWith(ProtobufMetadataManager.PROTO_KEY_SUFFIX) ? schemaName : schemaName + ProtobufMetadataManager.PROTO_KEY_SUFFIX;\n+   }\n+\n+   static class ValidationError {\n+      public String message;\n+      public String cause;\n+   }\n+   static class ProtoSchema {", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1OTkwNQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425959905", "bodyText": "Nitpick: Might as well put it on the line above to save some indention.", "author": "wburns", "createdAt": "2020-05-15T17:55:27Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {", "originalCommit": "76cff2bac32cd828189959a2fa2caddd2b478589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3ODQ0Nw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426578447", "bodyText": "ok", "author": "karesti", "createdAt": "2020-05-18T12:10:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1OTkwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5NjUwMw==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426696503", "bodyText": "This wasn't updated?", "author": "wburns", "createdAt": "2020-05-18T15:08:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1OTkwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwODE0Mg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426708142", "bodyText": "it was, but maybe I understood wrong what you meant by indention", "author": "karesti", "createdAt": "2020-05-18T15:24:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1OTkwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxMzQ1MA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426713450", "bodyText": "ok now I got it", "author": "karesti", "createdAt": "2020-05-18T15:32:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1OTkwNQ=="}], "type": "inlineReview"}, {"oid": "2fe5ecd91149890924a4f7dfe286a17608f9b185", "url": "https://github.com/infinispan/infinispan/commit/2fe5ecd91149890924a4f7dfe286a17608f9b185", "message": "ISPN-10446 Protobuf Schema Resource docs", "committedDate": "2020-05-18T11:54:28Z", "type": "forcePushed"}, {"oid": "c28e21067e37b189cc7afdf6fede99c4f9bf2a00", "url": "https://github.com/infinispan/infinispan/commit/c28e21067e37b189cc7afdf6fede99c4f9bf2a00", "message": "ISPN-10446 Protobuf Schema Resource", "committedDate": "2020-05-18T12:12:58Z", "type": "forcePushed"}, {"oid": "84f7a2ae2908befdcf8d86ed2bec21f139fd06ed", "url": "https://github.com/infinispan/infinispan/commit/84f7a2ae2908befdcf8d86ed2bec21f139fd06ed", "message": "ISPN-10446 Protobuf Schema Resource", "committedDate": "2020-05-18T12:25:42Z", "type": "forcePushed"}, {"oid": "c1b6422ae172d82d06ee66cbc4d8027ede610440", "url": "https://github.com/infinispan/infinispan/commit/c1b6422ae172d82d06ee66cbc4d8027ede610440", "message": "ISPN-10446 Protobuf Schema Resource", "committedDate": "2020-05-18T15:36:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjczMjA1OA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426732058", "bodyText": "This is more like what I would expect. However you didn't fix the indentation on the following lines as they can all now be moved 3 spaces to the left. Or however IntelliJ says the formatter wants :)", "author": "wburns", "createdAt": "2020-05-18T15:58:35Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,227 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import java.util.Comparator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.keySet())\n+               .filter(key -> !((String)key).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(key -> {\n+                  String error = (String) cache\n+                        .get(key + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = (String) key;\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .sorted(Comparator.comparing(s -> s.name))\n+                .collect(Collectors.toList())\n+                .map(protoSchemas -> {\n+                  try {\n+                     byte[] bytes = objectMapper.writeValueAsBytes(protoSchemas);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     throw new RestResponseException(e);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+      return putSchema.thenCompose(r -> {", "originalCommit": "c1b6422ae172d82d06ee66cbc4d8027ede610440", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc2MTUxMQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426761511", "bodyText": "ok", "author": "karesti", "createdAt": "2020-05-18T16:46:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjczMjA1OA=="}], "type": "inlineReview"}, {"oid": "2f8f983aa6ed9ebc9be583903a7b0f292b4ce285", "url": "https://github.com/infinispan/infinispan/commit/2f8f983aa6ed9ebc9be583903a7b0f292b4ce285", "message": "ISPN-10446 Protobuf Schema Resource", "committedDate": "2020-05-18T16:36:29Z", "type": "forcePushed"}, {"oid": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787", "url": "https://github.com/infinispan/infinispan/commit/c5a86f789fcfc4e127c7c6ff51afe9f69214f787", "message": "ISPN-10446 Protobuf Schema Resource", "committedDate": "2020-05-18T16:46:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExMzIwOQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427113209", "bodyText": "We need to rename this to /v2/schemas to conform with the other resources:\n/v2/counters/, /v2/caches/, /v2/tasks and so on.\n@oraNod also need to change all the doc references", "author": "gustavonalle", "createdAt": "2020-05-19T08:15:06Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import java.util.Comparator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)", "originalCommit": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3MDYwNQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427170605", "bodyText": "ok", "author": "karesti", "createdAt": "2020-05-19T09:43:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExMzIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExODU0NA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427118544", "bodyText": "This will cause a PUT for a totally new schema to return 404...\nPUT should create the schema if it does not exist or replace if it already exists.", "author": "gustavonalle", "createdAt": "2020-05-19T08:23:35Z", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import java.util.Comparator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.keySet())\n+               .filter(key -> !((String)key).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(key -> {\n+                  String error = (String) cache\n+                        .get(key + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = (String) key;\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .sorted(Comparator.comparing(s -> s.name))\n+                .collect(Collectors.toList())\n+                .map(protoSchemas -> {\n+                  try {\n+                     byte[] bytes = objectMapper.writeValueAsBytes(protoSchemas);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     throw new RestResponseException(e);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);", "originalCommit": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE2ODk2Mg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427168962", "bodyText": "but if someone has deleted the schema and you are creating it at the same time again ?", "author": "karesti", "createdAt": "2020-05-19T09:40:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExODU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3MDAzMQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427170031", "bodyText": "? You mean concurrent requests, one with PUT and another with DELETE?", "author": "gustavonalle", "createdAt": "2020-05-19T09:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExODU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4MDQ4NQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427180485", "bodyText": "for me you use POST to create a total new schema. And then put to modify schemas. this way the action from the user is clear. if you try to modify an already existing schema but the schema does not exist anymore, you get to know", "author": "karesti", "createdAt": "2020-05-19T10:00:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExODU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4NTMzMg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427185332", "bodyText": "nope, PUT should be like AddOrReplace", "author": "gustavonalle", "createdAt": "2020-05-19T10:08:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExODU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4NTg1MA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427185850", "bodyText": "More info: https://tools.ietf.org/html/rfc2616#page-55", "author": "gustavonalle", "createdAt": "2020-05-19T10:08:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExODU0NA=="}], "type": "inlineReview"}, {"oid": "97b1a46f3c2e3dc4354279def36838ff97bb58da", "url": "https://github.com/infinispan/infinispan/commit/97b1a46f3c2e3dc4354279def36838ff97bb58da", "message": "ISPN-10446 Protobuf Schema Resource", "committedDate": "2020-05-19T10:02:52Z", "type": "forcePushed"}, {"oid": "eecbb918fa56160b1f49d3d775065d8f27766f9a", "url": "https://github.com/infinispan/infinispan/commit/eecbb918fa56160b1f49d3d775065d8f27766f9a", "message": "ISPN-10446 Protobuf Schema Resource", "committedDate": "2020-05-19T15:39:01Z", "type": "forcePushed"}, {"oid": "65ca29e4bfb1a0dc07a9301ea15a7f5028fb180c", "url": "https://github.com/infinispan/infinispan/commit/65ca29e4bfb1a0dc07a9301ea15a7f5028fb180c", "message": "ISPN-10446 Protobuf Schema Resource", "committedDate": "2020-05-19T15:39:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxNTgzMQ==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427415831", "bodyText": "Should change the name of this method (and updateNonExistingSchema) considering that PUT now means \"create or update\". I'd just replace update with put.", "author": "danberindei", "createdAt": "2020-05-19T15:58:53Z", "path": "server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.rest.assertion.ResponseAssertion;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import javax.security.auth.Subject;\n+import java.security.PrivilegedAction;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON_TYPE;\n+import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN_TYPE;\n+import static org.infinispan.commons.util.Util.getResourceAsString;\n+import static org.testng.AssertJUnit.assertEquals;\n+\n+@Test(groups = \"functional\", testName = \"rest.ProtobufResourceTest\")\n+public class ProtobufResourceTest extends AbstractRestResourceTest {\n+\n+   @Override\n+   public Object[] factory() {\n+      return new Object[]{\n+            new ProtobufResourceTest().withSecurity(false),\n+            new ProtobufResourceTest().withSecurity(true),\n+      };\n+   }\n+\n+   @BeforeMethod(alwaysRun = true)\n+   @Override\n+   public void createBeforeMethod() {\n+      //Clear schema cache to avoid conflicts between methods\n+      Subject.doAs(ADMIN_USER, (PrivilegedAction<Void>) () -> {\n+         cacheManagers.get(0).getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME).clear();\n+         return null;\n+      });\n+   }\n+\n+   public void listSchemasWhenEmpty() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL)\n+            .method(HttpMethod.GET)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      JsonNode jsonNode = new ObjectMapper().readTree(response.getContentAsString());\n+      assertEquals(0, jsonNode.size());\n+   }\n+\n+   @Test\n+   public void getNotExistingSchema() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/coco\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isNotFound();\n+   }\n+\n+   @Test\n+   public void updateNonExistingSchema() throws Exception {\n+      String person = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = updateSchema(\"person\", person);\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+   }\n+\n+   @Test\n+   public void putAndGetWrongProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+\n+      String errorProto = getResourceAsString(\"error.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = addSchema(\"error\", errorProto);\n+\n+      String cause = \"java.lang.IllegalStateException:\"\n+            + \" Syntax error in error.proto at 3:8: unexpected label: messoge\";\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      JsonNode jsonNode = new ObjectMapper().readTree(response.getContent());\n+      assertEquals(\"error.proto\", jsonNode.get(\"name\").asText());\n+      assertEquals(\"Schema error.proto has errors\", jsonNode.get(\"error\").get(\"message\").asText());\n+      assertEquals(cause, jsonNode.get(\"error\").get(\"cause\").asText());\n+\n+      // Read adding .proto should also work\n+      response = client.newRequest(BASE_URL + \"/error\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+      ResponseAssertion.assertThat(response).isOk();\n+      ResponseAssertion.assertThat(response).hasContentEqualToFile(\"error.proto\");\n+\n+      checkListProtobufEndpointUrl(\"error.proto\", cause);\n+   }\n+\n+   @Test\n+   public void crudSchema() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+\n+      // Create\n+      ContentResponse response = addSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isOk();\n+      ObjectMapper objectMapper = new ObjectMapper();\n+      JsonNode jsonNode = objectMapper.readTree(response.getContent());\n+      assertEquals(\"null\", jsonNode.get(\"error\").asText());\n+\n+      // Read\n+      response = client.newRequest(BASE_URL + \"/person\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      ResponseAssertion.assertThat(response).hasContentEqualToFile(\"person.proto\");\n+\n+      // Read adding .proto should also work\n+      response = client.newRequest(BASE_URL + \"/person.proto\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+      ResponseAssertion.assertThat(response).isOk();\n+      ResponseAssertion.assertThat(response).hasContentEqualToFile(\"person.proto\");\n+\n+      // Update\n+      response = updateSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isOk();\n+\n+      // Delete\n+      response = client.newRequest(BASE_URL + \"/person\")\n+            .content(new StringContentProvider(personProto))\n+            .method(HttpMethod.DELETE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+\n+      response = client.newRequest(BASE_URL + \"/person\")\n+            .content(new StringContentProvider(personProto))\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isNotFound();\n+   }\n+\n+   @Test\n+   public void createTwiceSchema() throws Exception {\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+      ContentResponse response = addSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isOk();\n+      response = addSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isConflicted();\n+   }\n+\n+   @Test\n+   public void addAndGetListOrderedByName() throws Exception {\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+      addSchema(\"users\", personProto);\n+      addSchema(\"people\", personProto);\n+      addSchema(\"dancers\", personProto);\n+\n+      String url = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+      ContentResponse response = client.newRequest(url)\n+            .method(HttpMethod.GET)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      ObjectMapper objectMapper = new ObjectMapper();\n+      JsonNode jsonNode = objectMapper.readTree(response.getContent());\n+      assertEquals(3, jsonNode.size());\n+      assertEquals(\"dancers.proto\", jsonNode.get(0).get(\"name\").asText());\n+      assertEquals(\"people.proto\", jsonNode.get(1).get(\"name\").asText());\n+      assertEquals(\"users.proto\", jsonNode.get(2).get(\"name\").asText());\n+   }\n+\n+   private ContentResponse addSchema(String schemaName, String schemaContent)\n+         throws InterruptedException, TimeoutException, ExecutionException {\n+      return callAPI(schemaName, schemaContent, HttpMethod.POST);\n+   }\n+\n+   private ContentResponse updateSchema(String schemaName, String schemaContent)", "originalCommit": "65ca29e4bfb1a0dc07a9301ea15a7f5028fb180c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MzcxNg==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427443716", "bodyText": "ok", "author": "karesti", "createdAt": "2020-05-19T16:39:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxNTgzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU0MzI4NA==", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427543284", "bodyText": "I believe this was missed, however I won't stop this from integrating it.", "author": "wburns", "createdAt": "2020-05-19T19:21:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxNTgzMQ=="}], "type": "inlineReview"}, {"oid": "98a253cfb5a3e4d5f26835e50e462ccc9c296f81", "url": "https://github.com/infinispan/infinispan/commit/98a253cfb5a3e4d5f26835e50e462ccc9c296f81", "message": "ISPN-10446 Protobuf Schema Resource", "committedDate": "2020-05-19T16:38:58Z", "type": "commit"}, {"oid": "98a253cfb5a3e4d5f26835e50e462ccc9c296f81", "url": "https://github.com/infinispan/infinispan/commit/98a253cfb5a3e4d5f26835e50e462ccc9c296f81", "message": "ISPN-10446 Protobuf Schema Resource", "committedDate": "2020-05-19T16:38:58Z", "type": "forcePushed"}]}