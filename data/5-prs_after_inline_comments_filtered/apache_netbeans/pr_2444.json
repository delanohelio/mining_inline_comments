{"pr_number": 2444, "pr_title": "[NETBEANS-3588] Code Templates not working in Java Editor in for loops", "pr_createdAt": "2020-10-11T10:52:05Z", "pr_url": "https://github.com/apache/netbeans/pull/2444", "timeline": [{"oid": "3ae2bf61ad379ce28276b84e545f32dbae048f78", "url": "https://github.com/apache/netbeans/commit/3ae2bf61ad379ce28276b84e545f32dbae048f78", "message": "[NETBEANS-3588] Code Templates not working in Java Editor in for loops", "committedDate": "2020-10-12T06:55:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE4MDI0Mw==", "url": "https://github.com/apache/netbeans/pull/2444#discussion_r505180243", "bodyText": "CompilationInfo.getTokenHierarchy() is, as far as I know, based on an immutable copy of the Document's content. No need to Document.render.", "author": "jlahoda", "createdAt": "2020-10-15T05:52:54Z", "path": "java/java.editor/src/org/netbeans/modules/editor/java/JavaCodeTemplateFilter.java", "diffHunk": "@@ -72,88 +73,125 @@ private JavaCodeTemplateFilter(JTextComponent component, int offset) {\n             final Source source = Source.create(component.getDocument());\n             if (source != null) {\n                 final AtomicBoolean cancel = new AtomicBoolean();\n-                ProgressUtils.runOffEventDispatchThread(new Runnable() {\n-                    @Override\n-                    public void run() {\n-                        try {\n-                            ParserManager.parse(Collections.singleton(source), new UserTask() {\n-                                @Override\n-                                public void run(ResultIterator resultIterator) throws Exception {\n-                                    if (cancel.get()) {\n-                                        return;\n+                BaseProgressUtils.runOffEventDispatchThread(() -> {\n+                    try {\n+                        ParserManager.parse(Collections.singleton(source), new UserTask() {\n+                            @Override\n+                            public void run(ResultIterator resultIterator) throws Exception {\n+                                if (cancel.get()) {\n+                                    return;\n+                                }\n+                                Parser.Result result = resultIterator.getParserResult(startOffset);\n+                                CompilationController controller = result != null ? CompilationController.get(result) : null;\n+                                if (controller != null && Phase.PARSED.compareTo(controller.toPhase(Phase.PARSED)) <= 0) {\n+                                    TreeUtilities tu = controller.getTreeUtilities();\n+                                    int eo = endOffset;\n+                                    int so = startOffset;\n+                                    if (so >= 0) {\n+                                        so = result.getSnapshot().getEmbeddedOffset(startOffset);\n                                     }\n-                                    Parser.Result result = resultIterator.getParserResult(startOffset);\n-                                    CompilationController controller = result != null ? CompilationController.get(result) : null;\n-                                    if (controller != null && Phase.PARSED.compareTo(controller.toPhase(Phase.PARSED)) <= 0) {\n-                                        TreeUtilities tu = controller.getTreeUtilities();\n-                                        int eo = endOffset;\n-                                        int so = startOffset;\n-                                        if (so >= 0) {\n-                                            so = result.getSnapshot().getEmbeddedOffset(startOffset);\n-                                        }\n-                                        if (endOffset >= 0) {\n-                                            eo = result.getSnapshot().getEmbeddedOffset(endOffset);\n-                                            TokenSequence<JavaTokenId> ts = SourceUtils.getJavaTokenSequence(controller.getTokenHierarchy(), so);\n-                                            int delta = ts.move(so);\n+                                    if (endOffset >= 0) {\n+                                        eo = result.getSnapshot().getEmbeddedOffset(endOffset);\n+                                        TokenSequence<JavaTokenId> ts = SourceUtils.getJavaTokenSequence(controller.getTokenHierarchy(), so);\n+                                        int delta = ts.move(so);\n+                                        if (delta == 0 || ts.moveNext() && ts.token().id() == JavaTokenId.WHITESPACE) {\n+                                            delta = ts.move(eo);\n                                             if (delta == 0 || ts.moveNext() && ts.token().id() == JavaTokenId.WHITESPACE) {\n-                                                delta = ts.move(eo);\n-                                                if (delta == 0 || ts.moveNext() && ts.token().id() == JavaTokenId.WHITESPACE) {\n-                                                    String selectedText = controller.getText().substring(so, eo).trim();\n-                                                    SourcePositions[] sp = new SourcePositions[1];\n-                                                    ExpressionTree expr = selectedText.length() > 0 ? tu.parseExpression(selectedText, sp) : null;\n-                                                    if (expr != null && expr.getKind() != Tree.Kind.IDENTIFIER && !Utilities.containErrors(expr) && sp[0].getEndPosition(null, expr) >= selectedText.length()) {\n-                                                        stringCtx = EXPRESSION;\n-                                                    }\n+                                                String selectedText = controller.getText().substring(so, eo).trim();\n+                                                SourcePositions[] sp = new SourcePositions[1];\n+                                                ExpressionTree expr = selectedText.length() > 0 ? tu.parseExpression(selectedText, sp) : null;\n+                                                if (expr != null && expr.getKind() != Tree.Kind.IDENTIFIER && !Utilities.containErrors(expr) && sp[0].getEndPosition(null, expr) >= selectedText.length()) {\n+                                                    stringCtx = EXPRESSION;\n                                                 }\n                                             }\n                                         }\n-                                        Tree tree = tu.pathFor(so).getLeaf();\n-                                        if (eo >= 0 && so != eo) {\n-                                            if (tu.pathFor(eo).getLeaf() != tree) {\n-                                                return;\n-                                            }\n+                                    }\n+                                    Tree tree = tu.pathFor(so).getLeaf();\n+                                    if (eo >= 0 && so != eo) {\n+                                        if (tu.pathFor(eo).getLeaf() != tree) {\n+                                            return;\n                                         }\n-                                        treeKindCtx = tree.getKind();\n-                                        switch (treeKindCtx) {\n-                                            case CASE:\n-                                                if (so < controller.getTrees().getSourcePositions().getEndPosition(controller.getCompilationUnit(), ((CaseTree)tree).getExpression())) {\n-                                                    treeKindCtx = null;\n-                                                }\n-                                                break;\n-                                            case CLASS:\n-                                                SourcePositions sp = controller.getTrees().getSourcePositions();\n-                                                int startPos = (int)sp.getEndPosition(controller.getCompilationUnit(), ((ClassTree)tree).getModifiers());\n-                                                if (startPos <= 0) {\n-                                                    startPos = (int)sp.getStartPosition(controller.getCompilationUnit(), tree);\n-                                                }\n-                                                String headerText = controller.getText().substring(startPos, so);\n-                                                int idx = headerText.indexOf('{'); //NOI18N\n-                                                if (idx < 0) {\n-                                                    treeKindCtx = null;\n-                                                    stringCtx = CLASS_HEADER;\n-                                                }\n-                                                break;\n-                                            case FOR_LOOP:\n-                                            case ENHANCED_FOR_LOOP:\n-                                            case WHILE_LOOP:\n-                                                sp = controller.getTrees().getSourcePositions();\n+                                    }\n+                                    treeKindCtx = tree.getKind();\n+                                    switch (treeKindCtx) {\n+                                        case CASE:\n+                                            if (so < controller.getTrees().getSourcePositions().getEndPosition(controller.getCompilationUnit(), ((CaseTree)tree).getExpression())) {\n+                                                treeKindCtx = null;\n+                                            }\n+                                            break;\n+                                        case CLASS:\n+                                            SourcePositions sp = controller.getTrees().getSourcePositions();\n+                                            int startPos = (int)sp.getEndPosition(controller.getCompilationUnit(), ((ClassTree)tree).getModifiers());\n+                                            if (startPos <= 0) {\n                                                 startPos = (int)sp.getStartPosition(controller.getCompilationUnit(), tree);\n-                                                String text = controller.getText().substring(startPos, so);\n-                                                if (!text.trim().endsWith(\")\")) {\n-                                                    treeKindCtx = null;\n+                                            }\n+                                            String headerText = controller.getText().substring(startPos, so);\n+                                            int idx = headerText.indexOf('{'); //NOI18N\n+                                            if (idx < 0) {\n+                                                treeKindCtx = null;\n+                                                stringCtx = CLASS_HEADER;\n+                                            }\n+                                            break;\n+                                        case FOR_LOOP:\n+                                        case ENHANCED_FOR_LOOP:\n+                                            if (!isRightParenthesisOfLoopPresent(component, controller)) {\n+                                                 treeKindCtx = null;\n+                                            }\n+                                            break;\n+                                        case PARENTHESIZED:\n+                                            if (isPartOfWhileLoop(component, controller)) {\n+                                                if (!isRightParenthesisOfLoopPresent(component, controller)) {\n+                                                        treeKindCtx = null;\n                                                 }\n-                                        }\n+                                            }\n+                                            break;\n                                     }\n                                 }\n-                            });\n-                        } catch (ParseException ex) {\n-                            Exceptions.printStackTrace(ex);\n-                        }\n+                            }\n+                        });\n+                    } catch (ParseException ex) {\n+                        Exceptions.printStackTrace(ex);\n                     }\n                 }, NbBundle.getMessage(JavaCodeTemplateProcessor.class, \"JCT-init\"), cancel, false); //NOI18N\n             }\n         }\n     }\n+    \n+    private boolean isPartOfWhileLoop(JTextComponent component, CompilationController controller) {\n+        TreeUtilities treeUtilities = controller.getTreeUtilities();\n+        TreePath currentPath = treeUtilities.pathFor(component.getCaretPosition());\n+        TreePath parentPath = treeUtilities.getPathElementOfKind(Tree.Kind.WHILE_LOOP, currentPath);\n+        return parentPath != null;\n+    }\n+    \n+    private boolean isRightParenthesisOfLoopPresent(JTextComponent component, CompilationController controller) {\n+        AtomicBoolean result = new AtomicBoolean(true);\n+        Document document = component.getDocument();\n+        document.render(() -> {\n+            TokenHierarchy<?> tokenHierarchy = controller.getTokenHierarchy();", "originalCommit": "3ae2bf61ad379ce28276b84e545f32dbae048f78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE4MTI1NA==", "url": "https://github.com/apache/netbeans/pull/2444#discussion_r505181254", "bodyText": "This code runs outside of the AWT event dispatch thread, so calling getCaretPosition() seems somewhat dangerous. There are various offsets available inside the task, is there some that could be used. For example \"so\" looks like a potential candidate?", "author": "jlahoda", "createdAt": "2020-10-15T05:55:46Z", "path": "java/java.editor/src/org/netbeans/modules/editor/java/JavaCodeTemplateFilter.java", "diffHunk": "@@ -72,88 +73,125 @@ private JavaCodeTemplateFilter(JTextComponent component, int offset) {\n             final Source source = Source.create(component.getDocument());\n             if (source != null) {\n                 final AtomicBoolean cancel = new AtomicBoolean();\n-                ProgressUtils.runOffEventDispatchThread(new Runnable() {\n-                    @Override\n-                    public void run() {\n-                        try {\n-                            ParserManager.parse(Collections.singleton(source), new UserTask() {\n-                                @Override\n-                                public void run(ResultIterator resultIterator) throws Exception {\n-                                    if (cancel.get()) {\n-                                        return;\n+                BaseProgressUtils.runOffEventDispatchThread(() -> {\n+                    try {\n+                        ParserManager.parse(Collections.singleton(source), new UserTask() {\n+                            @Override\n+                            public void run(ResultIterator resultIterator) throws Exception {\n+                                if (cancel.get()) {\n+                                    return;\n+                                }\n+                                Parser.Result result = resultIterator.getParserResult(startOffset);\n+                                CompilationController controller = result != null ? CompilationController.get(result) : null;\n+                                if (controller != null && Phase.PARSED.compareTo(controller.toPhase(Phase.PARSED)) <= 0) {\n+                                    TreeUtilities tu = controller.getTreeUtilities();\n+                                    int eo = endOffset;\n+                                    int so = startOffset;\n+                                    if (so >= 0) {\n+                                        so = result.getSnapshot().getEmbeddedOffset(startOffset);\n                                     }\n-                                    Parser.Result result = resultIterator.getParserResult(startOffset);\n-                                    CompilationController controller = result != null ? CompilationController.get(result) : null;\n-                                    if (controller != null && Phase.PARSED.compareTo(controller.toPhase(Phase.PARSED)) <= 0) {\n-                                        TreeUtilities tu = controller.getTreeUtilities();\n-                                        int eo = endOffset;\n-                                        int so = startOffset;\n-                                        if (so >= 0) {\n-                                            so = result.getSnapshot().getEmbeddedOffset(startOffset);\n-                                        }\n-                                        if (endOffset >= 0) {\n-                                            eo = result.getSnapshot().getEmbeddedOffset(endOffset);\n-                                            TokenSequence<JavaTokenId> ts = SourceUtils.getJavaTokenSequence(controller.getTokenHierarchy(), so);\n-                                            int delta = ts.move(so);\n+                                    if (endOffset >= 0) {\n+                                        eo = result.getSnapshot().getEmbeddedOffset(endOffset);\n+                                        TokenSequence<JavaTokenId> ts = SourceUtils.getJavaTokenSequence(controller.getTokenHierarchy(), so);\n+                                        int delta = ts.move(so);\n+                                        if (delta == 0 || ts.moveNext() && ts.token().id() == JavaTokenId.WHITESPACE) {\n+                                            delta = ts.move(eo);\n                                             if (delta == 0 || ts.moveNext() && ts.token().id() == JavaTokenId.WHITESPACE) {\n-                                                delta = ts.move(eo);\n-                                                if (delta == 0 || ts.moveNext() && ts.token().id() == JavaTokenId.WHITESPACE) {\n-                                                    String selectedText = controller.getText().substring(so, eo).trim();\n-                                                    SourcePositions[] sp = new SourcePositions[1];\n-                                                    ExpressionTree expr = selectedText.length() > 0 ? tu.parseExpression(selectedText, sp) : null;\n-                                                    if (expr != null && expr.getKind() != Tree.Kind.IDENTIFIER && !Utilities.containErrors(expr) && sp[0].getEndPosition(null, expr) >= selectedText.length()) {\n-                                                        stringCtx = EXPRESSION;\n-                                                    }\n+                                                String selectedText = controller.getText().substring(so, eo).trim();\n+                                                SourcePositions[] sp = new SourcePositions[1];\n+                                                ExpressionTree expr = selectedText.length() > 0 ? tu.parseExpression(selectedText, sp) : null;\n+                                                if (expr != null && expr.getKind() != Tree.Kind.IDENTIFIER && !Utilities.containErrors(expr) && sp[0].getEndPosition(null, expr) >= selectedText.length()) {\n+                                                    stringCtx = EXPRESSION;\n                                                 }\n                                             }\n                                         }\n-                                        Tree tree = tu.pathFor(so).getLeaf();\n-                                        if (eo >= 0 && so != eo) {\n-                                            if (tu.pathFor(eo).getLeaf() != tree) {\n-                                                return;\n-                                            }\n+                                    }\n+                                    Tree tree = tu.pathFor(so).getLeaf();\n+                                    if (eo >= 0 && so != eo) {\n+                                        if (tu.pathFor(eo).getLeaf() != tree) {\n+                                            return;\n                                         }\n-                                        treeKindCtx = tree.getKind();\n-                                        switch (treeKindCtx) {\n-                                            case CASE:\n-                                                if (so < controller.getTrees().getSourcePositions().getEndPosition(controller.getCompilationUnit(), ((CaseTree)tree).getExpression())) {\n-                                                    treeKindCtx = null;\n-                                                }\n-                                                break;\n-                                            case CLASS:\n-                                                SourcePositions sp = controller.getTrees().getSourcePositions();\n-                                                int startPos = (int)sp.getEndPosition(controller.getCompilationUnit(), ((ClassTree)tree).getModifiers());\n-                                                if (startPos <= 0) {\n-                                                    startPos = (int)sp.getStartPosition(controller.getCompilationUnit(), tree);\n-                                                }\n-                                                String headerText = controller.getText().substring(startPos, so);\n-                                                int idx = headerText.indexOf('{'); //NOI18N\n-                                                if (idx < 0) {\n-                                                    treeKindCtx = null;\n-                                                    stringCtx = CLASS_HEADER;\n-                                                }\n-                                                break;\n-                                            case FOR_LOOP:\n-                                            case ENHANCED_FOR_LOOP:\n-                                            case WHILE_LOOP:\n-                                                sp = controller.getTrees().getSourcePositions();\n+                                    }\n+                                    treeKindCtx = tree.getKind();\n+                                    switch (treeKindCtx) {\n+                                        case CASE:\n+                                            if (so < controller.getTrees().getSourcePositions().getEndPosition(controller.getCompilationUnit(), ((CaseTree)tree).getExpression())) {\n+                                                treeKindCtx = null;\n+                                            }\n+                                            break;\n+                                        case CLASS:\n+                                            SourcePositions sp = controller.getTrees().getSourcePositions();\n+                                            int startPos = (int)sp.getEndPosition(controller.getCompilationUnit(), ((ClassTree)tree).getModifiers());\n+                                            if (startPos <= 0) {\n                                                 startPos = (int)sp.getStartPosition(controller.getCompilationUnit(), tree);\n-                                                String text = controller.getText().substring(startPos, so);\n-                                                if (!text.trim().endsWith(\")\")) {\n-                                                    treeKindCtx = null;\n+                                            }\n+                                            String headerText = controller.getText().substring(startPos, so);\n+                                            int idx = headerText.indexOf('{'); //NOI18N\n+                                            if (idx < 0) {\n+                                                treeKindCtx = null;\n+                                                stringCtx = CLASS_HEADER;\n+                                            }\n+                                            break;\n+                                        case FOR_LOOP:\n+                                        case ENHANCED_FOR_LOOP:\n+                                            if (!isRightParenthesisOfLoopPresent(component, controller)) {\n+                                                 treeKindCtx = null;\n+                                            }\n+                                            break;\n+                                        case PARENTHESIZED:\n+                                            if (isPartOfWhileLoop(component, controller)) {\n+                                                if (!isRightParenthesisOfLoopPresent(component, controller)) {\n+                                                        treeKindCtx = null;\n                                                 }\n-                                        }\n+                                            }\n+                                            break;\n                                     }\n                                 }\n-                            });\n-                        } catch (ParseException ex) {\n-                            Exceptions.printStackTrace(ex);\n-                        }\n+                            }\n+                        });\n+                    } catch (ParseException ex) {\n+                        Exceptions.printStackTrace(ex);\n                     }\n                 }, NbBundle.getMessage(JavaCodeTemplateProcessor.class, \"JCT-init\"), cancel, false); //NOI18N\n             }\n         }\n     }\n+    \n+    private boolean isPartOfWhileLoop(JTextComponent component, CompilationController controller) {\n+        TreeUtilities treeUtilities = controller.getTreeUtilities();\n+        TreePath currentPath = treeUtilities.pathFor(component.getCaretPosition());\n+        TreePath parentPath = treeUtilities.getPathElementOfKind(Tree.Kind.WHILE_LOOP, currentPath);\n+        return parentPath != null;\n+    }\n+    \n+    private boolean isRightParenthesisOfLoopPresent(JTextComponent component, CompilationController controller) {\n+        AtomicBoolean result = new AtomicBoolean(true);\n+        Document document = component.getDocument();\n+        document.render(() -> {\n+            TokenHierarchy<?> tokenHierarchy = controller.getTokenHierarchy();\n+            TokenSequence<?> tokenSequence = tokenHierarchy.tokenSequence();\n+            tokenSequence.move(component.getCaretPosition());", "originalCommit": "3ae2bf61ad379ce28276b84e545f32dbae048f78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwOTQ4Mw==", "url": "https://github.com/apache/netbeans/pull/2444#discussion_r506209483", "bodyText": "As far as I can tell from the line String text = controller.getText().substring(startPos, so); the wrong value of the end index of the substring is used, namely the start offset of the abbreviation, although (the end offset of the abbreviation + the number of spaces before the closing bracket, if any + 1) should be used to check for the presence of the right parenthesis (the problem is that the end offset of the abbreviation is not calculated before, at least in the  JavaCodeTemplateFilter class). Because of this, the treeKindCtx variable is always set to null and the code template for the for loop is rejected.\nIn addition, the code for the WHILE_LOOP case is never executed, because when the caret position is in parentheses that are part of a while loop, the leaf node for the tree path on which the caret is located is ParenthesizedTree, not WhileLoopTree. Because of this, the template for a while loop works even when there is no right parenthesis.", "author": "arsadykov", "createdAt": "2020-10-16T09:18:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE4MTI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMzNDY0NA==", "url": "https://github.com/apache/netbeans/pull/2444#discussion_r506334644", "bodyText": "@jlahoda Done as suggested. Please review.", "author": "arsadykov", "createdAt": "2020-10-16T11:50:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE4MTI1NA=="}], "type": "inlineReview"}, {"oid": "35bb857cc697e5f322c43ab2c02ba0f570df448f", "url": "https://github.com/apache/netbeans/commit/35bb857cc697e5f322c43ab2c02ba0f570df448f", "message": "[NETBEANS-3588] Code Templates not working in Java Editor in for loops", "committedDate": "2020-10-16T11:45:50Z", "type": "forcePushed"}, {"oid": "c1f511403f45ae9d5ca84c463bd6f87127f6d522", "url": "https://github.com/apache/netbeans/commit/c1f511403f45ae9d5ca84c463bd6f87127f6d522", "message": "[NETBEANS-3588] Code Templates not working in Java Editor in for loops", "committedDate": "2020-10-22T20:26:33Z", "type": "forcePushed"}, {"oid": "c3265e84b7ed436c63c8108690fa1a508f700299", "url": "https://github.com/apache/netbeans/commit/c3265e84b7ed436c63c8108690fa1a508f700299", "message": "[NETBEANS-3588] Code Templates not working in Java Editor in for loops", "committedDate": "2020-10-22T22:20:51Z", "type": "commit"}, {"oid": "5dacf0b8f64f134dbb367f1407f2ebd255456899", "url": "https://github.com/apache/netbeans/commit/5dacf0b8f64f134dbb367f1407f2ebd255456899", "message": "[NETBEANS-3588] Code Templates not working in Java Editor in for loops", "committedDate": "2020-10-22T22:20:51Z", "type": "commit"}, {"oid": "5dacf0b8f64f134dbb367f1407f2ebd255456899", "url": "https://github.com/apache/netbeans/commit/5dacf0b8f64f134dbb367f1407f2ebd255456899", "message": "[NETBEANS-3588] Code Templates not working in Java Editor in for loops", "committedDate": "2020-10-22T22:20:51Z", "type": "forcePushed"}]}