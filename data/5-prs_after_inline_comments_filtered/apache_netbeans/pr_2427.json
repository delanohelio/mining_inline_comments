{"pr_number": 2427, "pr_title": "Maven branding configuration API and robustness improvement", "pr_createdAt": "2020-10-08T12:59:21Z", "pr_url": "https://github.com/apache/netbeans/pull/2427", "timeline": [{"oid": "bac26b52b05f5ce83f34cd108ee61ce6da0608e7", "url": "https://github.com/apache/netbeans/commit/bac26b52b05f5ce83f34cd108ee61ce6da0608e7", "message": "Branding API to configure default value for output reuse and CoS", "committedDate": "2020-10-08T12:43:20Z", "type": "commit"}, {"oid": "68d7ceb99534a092d1bbee0240da02f813926347", "url": "https://github.com/apache/netbeans/commit/68d7ceb99534a092d1bbee0240da02f813926347", "message": "Keep one Maven JPDAStart instance per project and kill previous launch when new one is requested", "committedDate": "2020-10-08T12:46:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcwNzExMw==", "url": "https://github.com/apache/netbeans/pull/2427#discussion_r501707113", "bodyText": "May need some synchronization/flush when assigning to the shared field.", "author": "sdedic", "createdAt": "2020-10-08T13:10:32Z", "path": "java/maven/src/org/netbeans/modules/maven/debug/MavenJPDAStart.java", "diffHunk": "@@ -69,139 +72,126 @@\n     private ClassPath additionalSourcePath;\n     \n     \n-    private final Object[] lock = new Object[2];\n-    \n-    private Project project;\n-    private final String actionName;\n-    private final InputOutput io;\n+    private final Project project;\n+    private Future<?> lastFuture;\n+\n+    private MavenJPDAStart(Project p) {\n+        this.project = p;\n+    }\n \n-    JPDAStart(InputOutput inputOutput, String actionName) {\n-        io = inputOutput;\n-        this.actionName = actionName;\n+    /** Create and place into Project's Lookup.\n+     * @param p the project to associate this start with\n+     * @return new instance of the start infrastructure\n+     */\n+    public static MavenJPDAStart create(Project p) {\n+        return new MavenJPDAStart(p);\n     }\n     \n     /**\n      * returns the port/address that the debugger listens to..\n      */\n-    public String execute(Project project) throws Throwable {\n-        this.project = project;\n-        io.getOut().println(\"JPDA Listening Start...\"); //NOI18N\n-//            getLog().debug(\"Entering synch lock\"); //NOI18N\n-        synchronized (lock) {\n-//                getLog().debug(\"Entered synch lock\"); //NOI18N\n-            RP.post(this);\n-//                    getLog().debug(\"Entering wait\"); //NOI18N\n-            lock.wait();\n-//                    getLog().debug(\"Wait finished\"); //NOI18N\n-            if (lock[1] != null) {\n-                throw ((Throwable) lock[1]); //NOI18N\n+    public String execute(InputOutput io) throws Throwable {\n+        Future<?> prev = lastFuture;\n+        if (prev != null && !prev.isDone()) {\n+            io.getOut().print(\"Cancelling previous JPDA listening...\"); //NOI18N\n+            if (prev.cancel(true)) {\n+                io.getOut().println(\"done\"); //NOI18N\n+            } else {\n+                io.getOut().println(\"failed\"); //NOI18N\n             }\n         }\n-        return (String)lock[0];\n+        io.getOut().println(\"JPDA Listening Start...\"); //NOI18N\n+        Future<String> future = RP.submit(() -> {\n+            return startDebugger(io);\n+        });\n+        lastFuture = future;", "originalCommit": "68d7ceb99534a092d1bbee0240da02f813926347", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg4NDAyNQ==", "url": "https://github.com/apache/netbeans/pull/2427#discussion_r501884025", "bodyText": "Done in 0e6accd", "author": "JaroslavTulach", "createdAt": "2020-10-08T17:18:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcwNzExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcwODgwMA==", "url": "https://github.com/apache/netbeans/pull/2427#discussion_r501708800", "bodyText": "Flush the lastFuture to other threads, next execute will run in other than RP.", "author": "sdedic", "createdAt": "2020-10-08T13:13:03Z", "path": "java/maven/src/org/netbeans/modules/maven/debug/MavenJPDAStart.java", "diffHunk": "@@ -69,139 +72,126 @@\n     private ClassPath additionalSourcePath;\n     \n     \n-    private final Object[] lock = new Object[2];\n-    \n-    private Project project;\n-    private final String actionName;\n-    private final InputOutput io;\n+    private final Project project;\n+    private Future<?> lastFuture;\n+\n+    private MavenJPDAStart(Project p) {\n+        this.project = p;\n+    }\n \n-    JPDAStart(InputOutput inputOutput, String actionName) {\n-        io = inputOutput;\n-        this.actionName = actionName;\n+    /** Create and place into Project's Lookup.\n+     * @param p the project to associate this start with\n+     * @return new instance of the start infrastructure\n+     */\n+    public static MavenJPDAStart create(Project p) {\n+        return new MavenJPDAStart(p);\n     }\n     \n     /**\n      * returns the port/address that the debugger listens to..\n      */\n-    public String execute(Project project) throws Throwable {\n-        this.project = project;\n-        io.getOut().println(\"JPDA Listening Start...\"); //NOI18N\n-//            getLog().debug(\"Entering synch lock\"); //NOI18N\n-        synchronized (lock) {\n-//                getLog().debug(\"Entered synch lock\"); //NOI18N\n-            RP.post(this);\n-//                    getLog().debug(\"Entering wait\"); //NOI18N\n-            lock.wait();\n-//                    getLog().debug(\"Wait finished\"); //NOI18N\n-            if (lock[1] != null) {\n-                throw ((Throwable) lock[1]); //NOI18N\n+    public String execute(InputOutput io) throws Throwable {\n+        Future<?> prev = lastFuture;\n+        if (prev != null && !prev.isDone()) {\n+            io.getOut().print(\"Cancelling previous JPDA listening...\"); //NOI18N\n+            if (prev.cancel(true)) {\n+                io.getOut().println(\"done\"); //NOI18N\n+            } else {\n+                io.getOut().println(\"failed\"); //NOI18N\n             }\n         }\n-        return (String)lock[0];\n+        io.getOut().println(\"JPDA Listening Start...\"); //NOI18N\n+        Future<String> future = RP.submit(() -> {\n+            return startDebugger(io);\n+        });\n+        lastFuture = future;\n+        return future.get();\n     }\n     \n-    @Override\n-    public void run() {\n-        synchronized (lock) {\n-            \n-            try {\n-                \n-                ListeningConnector lc = null;\n-                Iterator i = Bootstrap.virtualMachineManager().\n-                        listeningConnectors().iterator();\n-                for (; i.hasNext();) {\n-                    lc = (ListeningConnector) i.next();\n-                    Transport t = lc.transport();\n-                    if (t != null && t.name().equals(getTransport())) {\n-                        break;\n-                    }\n-                }\n-                if (lc == null) {\n-                    throw new RuntimeException\n-                            (\"No trasports named \" + getTransport() + \" found!\"); //NOI18N\n-                }\n-                // TODO: revisit later when http://developer.java.sun.com/developer/bugParade/bugs/4932074.html gets integrated into JDK\n-                // This code parses the address string \"HOST:PORT\" to extract PORT and then point debugee to localhost:PORT\n-                // This is NOT a clean solution to the problem but it SHOULD work in 99% cases\n-                final Map args = lc.defaultArguments();\n-                String address = lc.startListening(args);\n-                try {\n-                    int port = Integer.parseInt(address.substring(address.indexOf(':') + 1));\n+    private String startDebugger(InputOutput io) throws IOException, IllegalConnectorArgumentsException {\n+        String portOrAddress;\n+        ListeningConnector lc = null;\n+        Iterator i = Bootstrap.virtualMachineManager().\n+                listeningConnectors().iterator();\n+        for (; i.hasNext();) {\n+            lc = (ListeningConnector) i.next();\n+            Transport t = lc.transport();\n+            if (t != null && t.name().equals(getTransport())) {\n+                break;\n+            }\n+        }\n+        if (lc == null) {\n+            throw new RuntimeException\n+                    (\"No trasports named \" + getTransport() + \" found!\"); //NOI18N\n+        }\n+        // TODO: revisit later when http://developer.java.sun.com/developer/bugParade/bugs/4932074.html gets integrated into JDK\n+        // This code parses the address string \"HOST:PORT\" to extract PORT and then point debugee to localhost:PORT\n+        // This is NOT a clean solution to the problem but it SHOULD work in 99% cases\n+        final Map args = lc.defaultArguments();\n+        String address = lc.startListening(args);\n+        try {\n+            int port = Integer.parseInt(address.substring(address.indexOf(':') + 1));\n //                    getProject ().setNewProperty (getAddressProperty (), \"localhost:\" + port);\n-                    Connector.IntegerArgument portArg = (Connector.IntegerArgument) args.get(\"port\"); //NOI18N\n-                    portArg.setValue(port);\n-                    lock[0] = Integer.toString(port);\n-                } catch (NumberFormatException e) {\n-                    // this address format is not known, use default\n+            Connector.IntegerArgument portArg = (Connector.IntegerArgument) args.get(\"port\"); //NOI18N\n+            portArg.setValue(port);\n+            portOrAddress = Integer.toString(port);\n+        } catch (NumberFormatException e) {\n+            // this address format is not known, use default\n //                    getProject ().setNewProperty (getAddressProperty (), address);\n-                    lock[0] = address;\n-                }\n-                io.getOut().println(\"JPDA Address: \" + address); //NOI18N\n-                io.getOut().println(\"Port:\" + lock[0]); //NOI18N\n-                \n-                ClassPath sourcePath = Utils.createSourcePath(project);\n-                if (getAdditionalSourcePath() != null) {\n-                    sourcePath = ClassPathSupport.createProxyClassPath(sourcePath, getAdditionalSourcePath());\n-                }\n-                ClassPath jdkSourcePath = Utils.createJDKSourcePath(project);\n-                \n-                if (getStopClassName() != null && getStopClassName().length() > 0) {\n-                    final MethodBreakpoint b = getStopMethod() != null ? Utils.createBreakpoint(getStopClassName(), getStopMethod()) : Utils.createBreakpoint(getStopClassName());\n-                    final Listener list = new Listener(b);\n-                    b.addPropertyChangeListener(MethodBreakpoint.PROP_VALIDITY, new PropertyChangeListener() {\n-                        @Override\n-                        public void propertyChange(PropertyChangeEvent pce) {\n-                            if (Breakpoint.VALIDITY.INVALID.equals(b.getValidity()) && getStopMethod() != null) {\n-                                //when the original method with method is not available (maybe defined in parent class?), replace it with a class breakpoint\n-                                DebuggerManager.getDebuggerManager().removeBreakpoint(b);\n-                                MethodBreakpoint b2 = Utils.createBreakpoint(getStopClassName());\n-                                list.replaceBreakpoint(b2);\n-                            }\n-                        }\n-                    });\n-                    DebuggerManager.getDebuggerManager().addDebuggerListener(\n-                            DebuggerManager.PROP_DEBUGGER_ENGINES,\n-                            list);\n-                }\n-                \n-                final Map properties = new HashMap();\n-                properties.put(\"sourcepath\", sourcePath); //NOI18N\n-                properties.put(\"name\", getName()); //NOI18N\n-                properties.put(\"jdksources\", jdkSourcePath); //NOI18N\n-                properties.put(\"baseDir\", FileUtil.toFile(project.getProjectDirectory())); // NOI18N\n-                if (RunUtils.isCompileOnSaveEnabled(project)) {\n-                    properties.put (\"listeningCP\", \"sourcepath\"); // NOI18N\n-                }\n-                \n-                final ListeningConnector flc = lc;\n-                RP.post(new Runnable() {\n+            portOrAddress = address;\n+        }\n+        io.getOut().println(\"JPDA Address: \" + address); //NOI18N\n+        io.getOut().println(\"Port:\" + portOrAddress); //NOI18N\n+\n+        ClassPath sourcePath = Utils.createSourcePath(project);\n+        if (getAdditionalSourcePath() != null) {\n+            sourcePath = ClassPathSupport.createProxyClassPath(sourcePath, getAdditionalSourcePath());\n+        }\n+        ClassPath jdkSourcePath = Utils.createJDKSourcePath(project);\n \n-                    @Override\n-                    public void run() {\n-                        try {\n-                            JPDADebugger.startListening(flc, args,\n-                                                        new Object[]{properties, project});\n-                        }\n-                        catch (DebuggerStartException ex) {\n-                            io.getErr().println(\"Debugger Start Error.\"); //NOI18N\n-                            Logger.getLogger(JPDAStart.class.getName()).log(Level.INFO, \"Debugger Start Error.\", ex);\n-                        }\n+        if (getStopClassName() != null && getStopClassName().length() > 0) {\n+            final MethodBreakpoint b = getStopMethod() != null ? Utils.createBreakpoint(getStopClassName(), getStopMethod()) : Utils.createBreakpoint(getStopClassName());\n+            final Listener list = new Listener(b);\n+            b.addPropertyChangeListener(MethodBreakpoint.PROP_VALIDITY, new PropertyChangeListener() {\n+                @Override\n+                public void propertyChange(PropertyChangeEvent pce) {\n+                    if (Breakpoint.VALIDITY.INVALID.equals(b.getValidity()) && getStopMethod() != null) {\n+                        //when the original method with method is not available (maybe defined in parent class?), replace it with a class breakpoint\n+                        DebuggerManager.getDebuggerManager().removeBreakpoint(b);\n+                        MethodBreakpoint b2 = Utils.createBreakpoint(getStopClassName());\n+                        list.replaceBreakpoint(b2);\n                     }\n-                });\n-            } catch (java.io.IOException ioex) {\n-                io.getErr().println(\"IO Error:\"); //NOI18N\n-//                org.openide.ErrorManager.getDefault().notify(ioex);\n-                lock[1] = ioex;\n-            } catch (com.sun.jdi.connect.IllegalConnectorArgumentsException icaex) {\n-                io.getErr().println(\"Illegal Connector\"); //NOI18N\n-                lock[1] = icaex;\n-            } finally {\n-                lock.notify();\n-            }\n+                }\n+            });\n+            DebuggerManager.getDebuggerManager().addDebuggerListener(\n+                    DebuggerManager.PROP_DEBUGGER_ENGINES,\n+                    list);\n         }\n+\n+        final Map properties = new HashMap();\n+        properties.put(\"sourcepath\", sourcePath); //NOI18N\n+        properties.put(\"name\", getName()); //NOI18N\n+        properties.put(\"jdksources\", jdkSourcePath); //NOI18N\n+        properties.put(\"baseDir\", FileUtil.toFile(project.getProjectDirectory())); // NOI18N\n+        if (RunUtils.isCompileOnSaveEnabled(project)) {\n+            properties.put (\"listeningCP\", \"sourcepath\"); // NOI18N\n+        }\n+\n+        final ListeningConnector flc = lc;\n         \n+        lastFuture = RP.submit(() -> {", "originalCommit": "68d7ceb99534a092d1bbee0240da02f813926347", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "869353cb9efa09a0fad0ecb7deb398b3085b166c", "url": "https://github.com/apache/netbeans/commit/869353cb9efa09a0fad0ecb7deb398b3085b166c", "message": "Fixing a typo", "committedDate": "2020-10-08T17:15:40Z", "type": "commit"}, {"oid": "0e6accddeec3dd288298c805fab54f2d553a884f", "url": "https://github.com/apache/netbeans/commit/0e6accddeec3dd288298c805fab54f2d553a884f", "message": "Make the among the threads shared field volatile", "committedDate": "2020-10-08T17:16:51Z", "type": "commit"}]}