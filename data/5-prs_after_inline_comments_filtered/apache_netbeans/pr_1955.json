{"pr_number": 1955, "pr_title": "Hook formating/rangeFormating into LSP Client", "pr_createdAt": "2020-02-19T21:07:28Z", "pr_url": "https://github.com/apache/netbeans/pull/1955", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1NDEzMA==", "url": "https://github.com/apache/netbeans/pull/1955#discussion_r381554130", "bodyText": "Better that getting the StreamDescriptionProperty is to use (org.netbeans.modules.editor.)NbEditorUtilities.getFileObject (less code and less error prone). We could also add LSPBindings.getBindings(Document), to simplify the code, but surely not urgent.", "author": "jlahoda", "createdAt": "2020-02-19T21:26:59Z", "path": "ide/lsp.client/src/org/netbeans/modules/lsp/client/bindings/Formatter.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.lsp.client.bindings;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.swing.text.BadLocationException;\n+import javax.swing.text.Document;\n+import org.eclipse.lsp4j.DocumentFormattingParams;\n+import org.eclipse.lsp4j.DocumentRangeFormattingParams;\n+import org.eclipse.lsp4j.FormattingOptions;\n+import org.eclipse.lsp4j.Range;\n+import org.eclipse.lsp4j.TextDocumentIdentifier;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.netbeans.api.editor.mimelookup.MimeRegistration;\n+import org.netbeans.modules.editor.indent.api.IndentUtils;\n+import org.netbeans.modules.editor.indent.spi.Context;\n+import org.netbeans.modules.editor.indent.spi.ExtraLock;\n+import org.netbeans.modules.editor.indent.spi.ReformatTask;\n+import org.netbeans.modules.lsp.client.LSPBindings;\n+import org.netbeans.modules.lsp.client.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.loaders.MultiDataObject;\n+\n+public class Formatter implements ReformatTask {\n+\n+    private static final Logger LOG = Logger.getLogger(Formatter.class.getName());\n+\n+    @MimeRegistration(mimeType = \"\", service = ReformatTask.Factory.class)\n+    public static class Factory implements ReformatTask.Factory {\n+\n+        @Override\n+        public ReformatTask createTask(Context context) {\n+            return new Formatter(context);\n+        }\n+\n+    }\n+\n+    private final Context ctx;\n+\n+    public Formatter(Context ctx) {\n+        this.ctx = ctx;\n+    }\n+\n+    @Override\n+    public void reformat() throws BadLocationException {\n+        Object stream = ctx.document().getProperty(Document.StreamDescriptionProperty);", "originalCommit": "b00592ee435cae20c56f953d12bdaf23ae02a19d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1NDY5OA==", "url": "https://github.com/apache/netbeans/pull/1955#discussion_r381554698", "bodyText": "Nit: might be better to use Collections.emptyList(), as using Collections.EMPTY_LIST leads to an unchecked cast (at least I believe so).", "author": "jlahoda", "createdAt": "2020-02-19T21:28:01Z", "path": "ide/lsp.client/src/org/netbeans/modules/lsp/client/bindings/Formatter.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.lsp.client.bindings;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.swing.text.BadLocationException;\n+import javax.swing.text.Document;\n+import org.eclipse.lsp4j.DocumentFormattingParams;\n+import org.eclipse.lsp4j.DocumentRangeFormattingParams;\n+import org.eclipse.lsp4j.FormattingOptions;\n+import org.eclipse.lsp4j.Range;\n+import org.eclipse.lsp4j.TextDocumentIdentifier;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.netbeans.api.editor.mimelookup.MimeRegistration;\n+import org.netbeans.modules.editor.indent.api.IndentUtils;\n+import org.netbeans.modules.editor.indent.spi.Context;\n+import org.netbeans.modules.editor.indent.spi.ExtraLock;\n+import org.netbeans.modules.editor.indent.spi.ReformatTask;\n+import org.netbeans.modules.lsp.client.LSPBindings;\n+import org.netbeans.modules.lsp.client.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.loaders.MultiDataObject;\n+\n+public class Formatter implements ReformatTask {\n+\n+    private static final Logger LOG = Logger.getLogger(Formatter.class.getName());\n+\n+    @MimeRegistration(mimeType = \"\", service = ReformatTask.Factory.class)\n+    public static class Factory implements ReformatTask.Factory {\n+\n+        @Override\n+        public ReformatTask createTask(Context context) {\n+            return new Formatter(context);\n+        }\n+\n+    }\n+\n+    private final Context ctx;\n+\n+    public Formatter(Context ctx) {\n+        this.ctx = ctx;\n+    }\n+\n+    @Override\n+    public void reformat() throws BadLocationException {\n+        Object stream = ctx.document().getProperty(Document.StreamDescriptionProperty);\n+        if(stream instanceof MultiDataObject) {\n+            MultiDataObject mdo = ((MultiDataObject) stream);\n+            FileObject fo = mdo.getPrimaryFile();\n+            LSPBindings bindings = LSPBindings.getBindings(fo);\n+            if (bindings != null) {\n+                Boolean documentFormatting = bindings.getInitResult().getCapabilities().getDocumentFormattingProvider();\n+                Boolean rangeFormatting = bindings.getInitResult().getCapabilities().getDocumentRangeFormattingProvider();\n+                if (rangeFormatting != null && rangeFormatting) {\n+                    rangeFormat(fo, bindings);\n+                } else if (documentFormatting != null && documentFormatting) {\n+                    documentFormat(fo, bindings);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void rangeFormat(FileObject fo, LSPBindings bindings) throws BadLocationException {\n+        DocumentRangeFormattingParams drfp = new DocumentRangeFormattingParams();\n+        drfp.setTextDocument(new TextDocumentIdentifier(Utils.toURI(fo)));\n+        drfp.setOptions(new FormattingOptions(\n+            IndentUtils.indentLevelSize(ctx.document()),\n+            IndentUtils.isExpandTabs(ctx.document())));\n+        drfp.setRange(new Range(\n+            Utils.createPosition(ctx.document(), ctx.startOffset()),\n+            Utils.createPosition(ctx.document(), ctx.endOffset())));\n+        List<? extends TextEdit> edits = Collections.EMPTY_LIST;", "originalCommit": "b00592ee435cae20c56f953d12bdaf23ae02a19d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1ODk4NA==", "url": "https://github.com/apache/netbeans/pull/1955#discussion_r381558984", "bodyText": "Would it make sense to call Utils.applyEditsNoLock here? Could be a new overload taking \"start\" and \"end\" offsets; or a predicate like \"BiPredicate<Integer, Integer> acceptor\", which would then be used to filter out the interesting edits (although the latter feels fairly ugly). Would help in case we find a bug in the way the edits are applied.\n(the rangeReverseSort is a nicer variant of what is in Utils.applyEditsNoLock, so could be moved into Utils and be used instead of the current code.)", "author": "jlahoda", "createdAt": "2020-02-19T21:36:52Z", "path": "ide/lsp.client/src/org/netbeans/modules/lsp/client/bindings/Formatter.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.lsp.client.bindings;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.swing.text.BadLocationException;\n+import javax.swing.text.Document;\n+import org.eclipse.lsp4j.DocumentFormattingParams;\n+import org.eclipse.lsp4j.DocumentRangeFormattingParams;\n+import org.eclipse.lsp4j.FormattingOptions;\n+import org.eclipse.lsp4j.Range;\n+import org.eclipse.lsp4j.TextDocumentIdentifier;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.netbeans.api.editor.mimelookup.MimeRegistration;\n+import org.netbeans.modules.editor.indent.api.IndentUtils;\n+import org.netbeans.modules.editor.indent.spi.Context;\n+import org.netbeans.modules.editor.indent.spi.ExtraLock;\n+import org.netbeans.modules.editor.indent.spi.ReformatTask;\n+import org.netbeans.modules.lsp.client.LSPBindings;\n+import org.netbeans.modules.lsp.client.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.loaders.MultiDataObject;\n+\n+public class Formatter implements ReformatTask {\n+\n+    private static final Logger LOG = Logger.getLogger(Formatter.class.getName());\n+\n+    @MimeRegistration(mimeType = \"\", service = ReformatTask.Factory.class)\n+    public static class Factory implements ReformatTask.Factory {\n+\n+        @Override\n+        public ReformatTask createTask(Context context) {\n+            return new Formatter(context);\n+        }\n+\n+    }\n+\n+    private final Context ctx;\n+\n+    public Formatter(Context ctx) {\n+        this.ctx = ctx;\n+    }\n+\n+    @Override\n+    public void reformat() throws BadLocationException {\n+        Object stream = ctx.document().getProperty(Document.StreamDescriptionProperty);\n+        if(stream instanceof MultiDataObject) {\n+            MultiDataObject mdo = ((MultiDataObject) stream);\n+            FileObject fo = mdo.getPrimaryFile();\n+            LSPBindings bindings = LSPBindings.getBindings(fo);\n+            if (bindings != null) {\n+                Boolean documentFormatting = bindings.getInitResult().getCapabilities().getDocumentFormattingProvider();\n+                Boolean rangeFormatting = bindings.getInitResult().getCapabilities().getDocumentRangeFormattingProvider();\n+                if (rangeFormatting != null && rangeFormatting) {\n+                    rangeFormat(fo, bindings);\n+                } else if (documentFormatting != null && documentFormatting) {\n+                    documentFormat(fo, bindings);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void rangeFormat(FileObject fo, LSPBindings bindings) throws BadLocationException {\n+        DocumentRangeFormattingParams drfp = new DocumentRangeFormattingParams();\n+        drfp.setTextDocument(new TextDocumentIdentifier(Utils.toURI(fo)));\n+        drfp.setOptions(new FormattingOptions(\n+            IndentUtils.indentLevelSize(ctx.document()),\n+            IndentUtils.isExpandTabs(ctx.document())));\n+        drfp.setRange(new Range(\n+            Utils.createPosition(ctx.document(), ctx.startOffset()),\n+            Utils.createPosition(ctx.document(), ctx.endOffset())));\n+        List<? extends TextEdit> edits = Collections.EMPTY_LIST;\n+        try {\n+            edits = new ArrayList<>(bindings.getTextDocumentService().rangeFormatting(drfp).get());\n+        } catch (InterruptedException | ExecutionException ex) {\n+            LOG.log(Level.INFO,\n+                String.format(\"LSP document rangeFormat failed for {0}\", fo),\n+                ex);\n+        }\n+        Collections.sort(edits, rangeReverseSort);\n+\n+        applyTextEdits(edits);\n+    }\n+\n+    private void documentFormat(FileObject fo, LSPBindings bindings) throws BadLocationException {\n+        DocumentFormattingParams dfp = new DocumentFormattingParams();\n+        dfp.setTextDocument(new TextDocumentIdentifier(Utils.toURI(fo)));\n+        dfp.setOptions(new FormattingOptions(\n+            IndentUtils.indentLevelSize(ctx.document()),\n+            IndentUtils.isExpandTabs(ctx.document())));\n+        List<? extends TextEdit> edits = Collections.EMPTY_LIST;\n+        try {\n+            edits = new ArrayList<>(bindings.getTextDocumentService().formatting(dfp).get());\n+        } catch (InterruptedException | ExecutionException ex) {\n+            LOG.log(Level.INFO,\n+                String.format(\"LSP document format failed for {0}\", fo),\n+                ex);\n+        }\n+        applyTextEdits(edits);\n+    }\n+\n+    private void applyTextEdits(List<? extends TextEdit> edits) throws BadLocationException {\n+        Collections.sort(edits, rangeReverseSort);", "originalCommit": "b00592ee435cae20c56f953d12bdaf23ae02a19d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c464af06b7a0b94f65fa8cdd5d2533863a9746a3", "url": "https://github.com/apache/netbeans/commit/c464af06b7a0b94f65fa8cdd5d2533863a9746a3", "message": "Hook formating/rangeFormating into LSP Client", "committedDate": "2020-02-28T16:14:12Z", "type": "commit"}, {"oid": "c464af06b7a0b94f65fa8cdd5d2533863a9746a3", "url": "https://github.com/apache/netbeans/commit/c464af06b7a0b94f65fa8cdd5d2533863a9746a3", "message": "Hook formating/rangeFormating into LSP Client", "committedDate": "2020-02-28T16:14:12Z", "type": "forcePushed"}]}