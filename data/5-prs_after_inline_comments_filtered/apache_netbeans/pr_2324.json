{"pr_number": 2324, "pr_title": "Adding support for workspace/symbol to both the LSP client and Java LSP server.", "pr_createdAt": "2020-08-22T20:00:29Z", "pr_url": "https://github.com/apache/netbeans/pull/2324", "timeline": [{"oid": "142b5936916b3027295ad889f232770b00870ff4", "url": "https://github.com/apache/netbeans/commit/142b5936916b3027295ad889f232770b00870ff4", "message": "Adding support for workspace/symbol to both the LSP client and Java LSP server.\nNeeds to eagerly start the servers (so that they can provide outputs).", "committedDate": "2020-08-22T06:48:20Z", "type": "commit"}, {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "url": "https://github.com/apache/netbeans/commit/38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "message": "Removing unnecessary import.", "committedDate": "2020-08-22T19:59:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDg5Nw==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134897", "bodyText": "Jackpot:\nwarning: Passing possible null to not-null argument", "author": "jlahoda-jackpot", "createdAt": "2020-08-22T20:21:12Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/workspace/WorkspaceServiceImpl.java", "diffHunk": "@@ -18,23 +18,215 @@\n  */\n package org.netbeans.modules.java.lsp.server.workspace;\n \n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.TypeElement;\n import org.eclipse.lsp4j.DidChangeConfigurationParams;\n import org.eclipse.lsp4j.DidChangeWatchedFilesParams;\n+import org.eclipse.lsp4j.Location;\n import org.eclipse.lsp4j.SymbolInformation;\n import org.eclipse.lsp4j.WorkspaceSymbolParams;\n import org.eclipse.lsp4j.services.WorkspaceService;\n+import org.netbeans.api.annotations.common.NonNull;\n+import org.netbeans.api.annotations.common.NullAllowed;\n+import org.netbeans.api.java.source.ClasspathInfo;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementHandle;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.JavaSource.Phase;\n+import org.netbeans.api.java.source.SourceUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider.ResultHandler;\n+import org.netbeans.modules.java.source.usages.ClassIndexImpl;\n+import org.netbeans.modules.parsing.lucene.support.Queries;\n+import org.netbeans.spi.jumpto.type.SearchType;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.Pair;\n+import org.openide.util.RequestProcessor;\n \n /**\n  *\n  * @author lahvac\n  */\n public class WorkspaceServiceImpl implements WorkspaceService {\n \n+    private static final RequestProcessor WORKER = new RequestProcessor(WorkspaceServiceImpl.class.getName(), 1, false, false);\n+\n     @Override\n-    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams arg0) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams params) {\n+        String query = params.getQuery();\n+        if (query.isEmpty()) {\n+            //cannot query \"all\":\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+        System.err.println(\"query=\" + query);\n+        boolean exact = false;\n+        if (query.endsWith(\" \")) {\n+            query = query.substring(0, query.length() - 1);\n+            exact = true;\n+        }\n+        String queryFin = query;\n+        boolean exactFin = exact;\n+        AtomicBoolean cancel = new AtomicBoolean();\n+        CompletableFuture<List<? extends SymbolInformation>> result = new CompletableFuture<List<? extends SymbolInformation>>() {\n+            @Override\n+            public boolean cancel(boolean mayInterruptIfRunning) {\n+                cancel.set(mayInterruptIfRunning);\n+                return super.cancel(mayInterruptIfRunning);\n+            }\n+        };\n+        WORKER.post(() -> {\n+            try {\n+                List<SymbolInformation> symbols = new ArrayList<>();\n+                ResultHandler handler = new ResultHandler() {\n+                    @Override\n+                    public void setHighlightText(String text) {\n+                    }\n+\n+                    private Map<ElementHandle<TypeElement>, List<String>> type2Idents;\n+\n+                    @Override\n+                    public void runRoot(FileObject root, ClassIndexImpl ci, Exec exec) throws IOException, InterruptedException {\n+                        ClasspathInfo cpInfo = ClasspathInfo.create(root);\n+                        try {\n+                            type2Idents = new HashMap<>();\n+                            exec.run();\n+                            Map<FileObject, Map<ElementHandle<TypeElement>, List<String>>> sources = new HashMap<>();\n+                            for (Entry<ElementHandle<TypeElement>, List<String>> e : type2Idents.entrySet()) {\n+                                FileObject sourceFile = SourceUtils.getFile(e.getKey(), cpInfo);\n+                                sources.computeIfAbsent(sourceFile, s -> new HashMap<>())\n+                                       .put(e.getKey(), e.getValue());\n+                            }\n+                            if (!sources.isEmpty()) {\n+                                JavaSource.create(cpInfo, sources.keySet())\n+                                          .runUserActionTask(cc -> {\n+                                              if (Phase.ELEMENTS_RESOLVED.compareTo(cc.toPhase(Phase.ELEMENTS_RESOLVED))> 0) {\n+                                                  return ;\n+                                              }\n+                                              for (Entry<ElementHandle<TypeElement>, List<String>> e : sources.get(cc.getFileObject()).entrySet()) {\n+                                                  TypeElement te = e.getKey().resolve(cc);\n+\n+                                                  for (String ident : e.getValue()) {\n+                                                      if (ident.equals(getSimpleName(te, null, false))) {", "originalCommit": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE3OTE4MA==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r489179180", "bodyText": "Shall be fixed.", "author": "jlahoda", "createdAt": "2020-09-16T05:52:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDg5OQ==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134899", "bodyText": "Jackpot:\nwarning: Can use functional operations", "author": "jlahoda-jackpot", "createdAt": "2020-08-22T20:21:13Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/workspace/WorkspaceServiceImpl.java", "diffHunk": "@@ -18,23 +18,215 @@\n  */\n package org.netbeans.modules.java.lsp.server.workspace;\n \n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.TypeElement;\n import org.eclipse.lsp4j.DidChangeConfigurationParams;\n import org.eclipse.lsp4j.DidChangeWatchedFilesParams;\n+import org.eclipse.lsp4j.Location;\n import org.eclipse.lsp4j.SymbolInformation;\n import org.eclipse.lsp4j.WorkspaceSymbolParams;\n import org.eclipse.lsp4j.services.WorkspaceService;\n+import org.netbeans.api.annotations.common.NonNull;\n+import org.netbeans.api.annotations.common.NullAllowed;\n+import org.netbeans.api.java.source.ClasspathInfo;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementHandle;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.JavaSource.Phase;\n+import org.netbeans.api.java.source.SourceUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider.ResultHandler;\n+import org.netbeans.modules.java.source.usages.ClassIndexImpl;\n+import org.netbeans.modules.parsing.lucene.support.Queries;\n+import org.netbeans.spi.jumpto.type.SearchType;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.Pair;\n+import org.openide.util.RequestProcessor;\n \n /**\n  *\n  * @author lahvac\n  */\n public class WorkspaceServiceImpl implements WorkspaceService {\n \n+    private static final RequestProcessor WORKER = new RequestProcessor(WorkspaceServiceImpl.class.getName(), 1, false, false);\n+\n     @Override\n-    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams arg0) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams params) {\n+        String query = params.getQuery();\n+        if (query.isEmpty()) {\n+            //cannot query \"all\":\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+        System.err.println(\"query=\" + query);\n+        boolean exact = false;\n+        if (query.endsWith(\" \")) {\n+            query = query.substring(0, query.length() - 1);\n+            exact = true;\n+        }\n+        String queryFin = query;\n+        boolean exactFin = exact;\n+        AtomicBoolean cancel = new AtomicBoolean();\n+        CompletableFuture<List<? extends SymbolInformation>> result = new CompletableFuture<List<? extends SymbolInformation>>() {\n+            @Override\n+            public boolean cancel(boolean mayInterruptIfRunning) {\n+                cancel.set(mayInterruptIfRunning);\n+                return super.cancel(mayInterruptIfRunning);\n+            }\n+        };\n+        WORKER.post(() -> {\n+            try {\n+                List<SymbolInformation> symbols = new ArrayList<>();\n+                ResultHandler handler = new ResultHandler() {\n+                    @Override\n+                    public void setHighlightText(String text) {\n+                    }\n+\n+                    private Map<ElementHandle<TypeElement>, List<String>> type2Idents;\n+\n+                    @Override\n+                    public void runRoot(FileObject root, ClassIndexImpl ci, Exec exec) throws IOException, InterruptedException {\n+                        ClasspathInfo cpInfo = ClasspathInfo.create(root);\n+                        try {\n+                            type2Idents = new HashMap<>();\n+                            exec.run();\n+                            Map<FileObject, Map<ElementHandle<TypeElement>, List<String>>> sources = new HashMap<>();\n+                            for (Entry<ElementHandle<TypeElement>, List<String>> e : type2Idents.entrySet()) {", "originalCommit": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE2NTMyOA==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r489165328", "bodyText": "Could, but no.", "author": "jlahoda", "createdAt": "2020-09-16T05:06:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDkwMQ==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134901", "bodyText": "Jackpot:\nwarning: Can use functional operations", "author": "jlahoda-jackpot", "createdAt": "2020-08-22T20:21:15Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/workspace/WorkspaceServiceImpl.java", "diffHunk": "@@ -18,23 +18,215 @@\n  */\n package org.netbeans.modules.java.lsp.server.workspace;\n \n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.TypeElement;\n import org.eclipse.lsp4j.DidChangeConfigurationParams;\n import org.eclipse.lsp4j.DidChangeWatchedFilesParams;\n+import org.eclipse.lsp4j.Location;\n import org.eclipse.lsp4j.SymbolInformation;\n import org.eclipse.lsp4j.WorkspaceSymbolParams;\n import org.eclipse.lsp4j.services.WorkspaceService;\n+import org.netbeans.api.annotations.common.NonNull;\n+import org.netbeans.api.annotations.common.NullAllowed;\n+import org.netbeans.api.java.source.ClasspathInfo;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementHandle;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.JavaSource.Phase;\n+import org.netbeans.api.java.source.SourceUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider.ResultHandler;\n+import org.netbeans.modules.java.source.usages.ClassIndexImpl;\n+import org.netbeans.modules.parsing.lucene.support.Queries;\n+import org.netbeans.spi.jumpto.type.SearchType;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.Pair;\n+import org.openide.util.RequestProcessor;\n \n /**\n  *\n  * @author lahvac\n  */\n public class WorkspaceServiceImpl implements WorkspaceService {\n \n+    private static final RequestProcessor WORKER = new RequestProcessor(WorkspaceServiceImpl.class.getName(), 1, false, false);\n+\n     @Override\n-    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams arg0) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams params) {\n+        String query = params.getQuery();\n+        if (query.isEmpty()) {\n+            //cannot query \"all\":\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+        System.err.println(\"query=\" + query);\n+        boolean exact = false;\n+        if (query.endsWith(\" \")) {\n+            query = query.substring(0, query.length() - 1);\n+            exact = true;\n+        }\n+        String queryFin = query;\n+        boolean exactFin = exact;\n+        AtomicBoolean cancel = new AtomicBoolean();\n+        CompletableFuture<List<? extends SymbolInformation>> result = new CompletableFuture<List<? extends SymbolInformation>>() {\n+            @Override\n+            public boolean cancel(boolean mayInterruptIfRunning) {\n+                cancel.set(mayInterruptIfRunning);\n+                return super.cancel(mayInterruptIfRunning);\n+            }\n+        };\n+        WORKER.post(() -> {\n+            try {\n+                List<SymbolInformation> symbols = new ArrayList<>();\n+                ResultHandler handler = new ResultHandler() {\n+                    @Override\n+                    public void setHighlightText(String text) {\n+                    }\n+\n+                    private Map<ElementHandle<TypeElement>, List<String>> type2Idents;\n+\n+                    @Override\n+                    public void runRoot(FileObject root, ClassIndexImpl ci, Exec exec) throws IOException, InterruptedException {\n+                        ClasspathInfo cpInfo = ClasspathInfo.create(root);\n+                        try {\n+                            type2Idents = new HashMap<>();\n+                            exec.run();\n+                            Map<FileObject, Map<ElementHandle<TypeElement>, List<String>>> sources = new HashMap<>();\n+                            for (Entry<ElementHandle<TypeElement>, List<String>> e : type2Idents.entrySet()) {\n+                                FileObject sourceFile = SourceUtils.getFile(e.getKey(), cpInfo);\n+                                sources.computeIfAbsent(sourceFile, s -> new HashMap<>())\n+                                       .put(e.getKey(), e.getValue());\n+                            }\n+                            if (!sources.isEmpty()) {\n+                                JavaSource.create(cpInfo, sources.keySet())\n+                                          .runUserActionTask(cc -> {\n+                                              if (Phase.ELEMENTS_RESOLVED.compareTo(cc.toPhase(Phase.ELEMENTS_RESOLVED))> 0) {\n+                                                  return ;\n+                                              }\n+                                              for (Entry<ElementHandle<TypeElement>, List<String>> e : sources.get(cc.getFileObject()).entrySet()) {", "originalCommit": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE2NTM4MQ==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r489165381", "bodyText": "Could, but no.", "author": "jlahoda", "createdAt": "2020-09-16T05:06:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDkwNA==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134904", "bodyText": "Jackpot:\nwarning: Can use functional operations", "author": "jlahoda-jackpot", "createdAt": "2020-08-22T20:21:17Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/workspace/WorkspaceServiceImpl.java", "diffHunk": "@@ -18,23 +18,215 @@\n  */\n package org.netbeans.modules.java.lsp.server.workspace;\n \n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.TypeElement;\n import org.eclipse.lsp4j.DidChangeConfigurationParams;\n import org.eclipse.lsp4j.DidChangeWatchedFilesParams;\n+import org.eclipse.lsp4j.Location;\n import org.eclipse.lsp4j.SymbolInformation;\n import org.eclipse.lsp4j.WorkspaceSymbolParams;\n import org.eclipse.lsp4j.services.WorkspaceService;\n+import org.netbeans.api.annotations.common.NonNull;\n+import org.netbeans.api.annotations.common.NullAllowed;\n+import org.netbeans.api.java.source.ClasspathInfo;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementHandle;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.JavaSource.Phase;\n+import org.netbeans.api.java.source.SourceUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider.ResultHandler;\n+import org.netbeans.modules.java.source.usages.ClassIndexImpl;\n+import org.netbeans.modules.parsing.lucene.support.Queries;\n+import org.netbeans.spi.jumpto.type.SearchType;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.Pair;\n+import org.openide.util.RequestProcessor;\n \n /**\n  *\n  * @author lahvac\n  */\n public class WorkspaceServiceImpl implements WorkspaceService {\n \n+    private static final RequestProcessor WORKER = new RequestProcessor(WorkspaceServiceImpl.class.getName(), 1, false, false);\n+\n     @Override\n-    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams arg0) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams params) {\n+        String query = params.getQuery();\n+        if (query.isEmpty()) {\n+            //cannot query \"all\":\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+        System.err.println(\"query=\" + query);\n+        boolean exact = false;\n+        if (query.endsWith(\" \")) {\n+            query = query.substring(0, query.length() - 1);\n+            exact = true;\n+        }\n+        String queryFin = query;\n+        boolean exactFin = exact;\n+        AtomicBoolean cancel = new AtomicBoolean();\n+        CompletableFuture<List<? extends SymbolInformation>> result = new CompletableFuture<List<? extends SymbolInformation>>() {\n+            @Override\n+            public boolean cancel(boolean mayInterruptIfRunning) {\n+                cancel.set(mayInterruptIfRunning);\n+                return super.cancel(mayInterruptIfRunning);\n+            }\n+        };\n+        WORKER.post(() -> {\n+            try {\n+                List<SymbolInformation> symbols = new ArrayList<>();\n+                ResultHandler handler = new ResultHandler() {\n+                    @Override\n+                    public void setHighlightText(String text) {\n+                    }\n+\n+                    private Map<ElementHandle<TypeElement>, List<String>> type2Idents;\n+\n+                    @Override\n+                    public void runRoot(FileObject root, ClassIndexImpl ci, Exec exec) throws IOException, InterruptedException {\n+                        ClasspathInfo cpInfo = ClasspathInfo.create(root);\n+                        try {\n+                            type2Idents = new HashMap<>();\n+                            exec.run();\n+                            Map<FileObject, Map<ElementHandle<TypeElement>, List<String>>> sources = new HashMap<>();\n+                            for (Entry<ElementHandle<TypeElement>, List<String>> e : type2Idents.entrySet()) {\n+                                FileObject sourceFile = SourceUtils.getFile(e.getKey(), cpInfo);\n+                                sources.computeIfAbsent(sourceFile, s -> new HashMap<>())\n+                                       .put(e.getKey(), e.getValue());\n+                            }\n+                            if (!sources.isEmpty()) {\n+                                JavaSource.create(cpInfo, sources.keySet())\n+                                          .runUserActionTask(cc -> {\n+                                              if (Phase.ELEMENTS_RESOLVED.compareTo(cc.toPhase(Phase.ELEMENTS_RESOLVED))> 0) {\n+                                                  return ;\n+                                              }\n+                                              for (Entry<ElementHandle<TypeElement>, List<String>> e : sources.get(cc.getFileObject()).entrySet()) {\n+                                                  TypeElement te = e.getKey().resolve(cc);\n+\n+                                                  for (String ident : e.getValue()) {", "originalCommit": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE2NjAyMQ==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r489166021", "bodyText": "Could, but no.", "author": "jlahoda", "createdAt": "2020-09-16T05:08:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDkwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDkwNw==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134907", "bodyText": "Jackpot:\nwarning: Can use functional operations", "author": "jlahoda-jackpot", "createdAt": "2020-08-22T20:21:18Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/workspace/WorkspaceServiceImpl.java", "diffHunk": "@@ -18,23 +18,215 @@\n  */\n package org.netbeans.modules.java.lsp.server.workspace;\n \n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.TypeElement;\n import org.eclipse.lsp4j.DidChangeConfigurationParams;\n import org.eclipse.lsp4j.DidChangeWatchedFilesParams;\n+import org.eclipse.lsp4j.Location;\n import org.eclipse.lsp4j.SymbolInformation;\n import org.eclipse.lsp4j.WorkspaceSymbolParams;\n import org.eclipse.lsp4j.services.WorkspaceService;\n+import org.netbeans.api.annotations.common.NonNull;\n+import org.netbeans.api.annotations.common.NullAllowed;\n+import org.netbeans.api.java.source.ClasspathInfo;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementHandle;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.JavaSource.Phase;\n+import org.netbeans.api.java.source.SourceUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider.ResultHandler;\n+import org.netbeans.modules.java.source.usages.ClassIndexImpl;\n+import org.netbeans.modules.parsing.lucene.support.Queries;\n+import org.netbeans.spi.jumpto.type.SearchType;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.Pair;\n+import org.openide.util.RequestProcessor;\n \n /**\n  *\n  * @author lahvac\n  */\n public class WorkspaceServiceImpl implements WorkspaceService {\n \n+    private static final RequestProcessor WORKER = new RequestProcessor(WorkspaceServiceImpl.class.getName(), 1, false, false);\n+\n     @Override\n-    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams arg0) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams params) {\n+        String query = params.getQuery();\n+        if (query.isEmpty()) {\n+            //cannot query \"all\":\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+        System.err.println(\"query=\" + query);\n+        boolean exact = false;\n+        if (query.endsWith(\" \")) {\n+            query = query.substring(0, query.length() - 1);\n+            exact = true;\n+        }\n+        String queryFin = query;\n+        boolean exactFin = exact;\n+        AtomicBoolean cancel = new AtomicBoolean();\n+        CompletableFuture<List<? extends SymbolInformation>> result = new CompletableFuture<List<? extends SymbolInformation>>() {\n+            @Override\n+            public boolean cancel(boolean mayInterruptIfRunning) {\n+                cancel.set(mayInterruptIfRunning);\n+                return super.cancel(mayInterruptIfRunning);\n+            }\n+        };\n+        WORKER.post(() -> {\n+            try {\n+                List<SymbolInformation> symbols = new ArrayList<>();\n+                ResultHandler handler = new ResultHandler() {\n+                    @Override\n+                    public void setHighlightText(String text) {\n+                    }\n+\n+                    private Map<ElementHandle<TypeElement>, List<String>> type2Idents;\n+\n+                    @Override\n+                    public void runRoot(FileObject root, ClassIndexImpl ci, Exec exec) throws IOException, InterruptedException {\n+                        ClasspathInfo cpInfo = ClasspathInfo.create(root);\n+                        try {\n+                            type2Idents = new HashMap<>();\n+                            exec.run();\n+                            Map<FileObject, Map<ElementHandle<TypeElement>, List<String>>> sources = new HashMap<>();\n+                            for (Entry<ElementHandle<TypeElement>, List<String>> e : type2Idents.entrySet()) {\n+                                FileObject sourceFile = SourceUtils.getFile(e.getKey(), cpInfo);\n+                                sources.computeIfAbsent(sourceFile, s -> new HashMap<>())\n+                                       .put(e.getKey(), e.getValue());\n+                            }\n+                            if (!sources.isEmpty()) {\n+                                JavaSource.create(cpInfo, sources.keySet())\n+                                          .runUserActionTask(cc -> {\n+                                              if (Phase.ELEMENTS_RESOLVED.compareTo(cc.toPhase(Phase.ELEMENTS_RESOLVED))> 0) {\n+                                                  return ;\n+                                              }\n+                                              for (Entry<ElementHandle<TypeElement>, List<String>> e : sources.get(cc.getFileObject()).entrySet()) {\n+                                                  TypeElement te = e.getKey().resolve(cc);\n+\n+                                                  for (String ident : e.getValue()) {\n+                                                      if (ident.equals(getSimpleName(te, null, false))) {\n+                                                          TreePath path = cc.getTrees().getPath(te);\n+\n+                                                          if (path != null) {\n+                                                              final String symbolName = te.getSimpleName().toString();\n+                                                              final ElementKind kind = te.getKind();\n+                                                              SymbolInformation symbol = new SymbolInformation(symbolName, Utils.elementKind2SymbolKind(kind), tree2Location(cc, path), te.getQualifiedName().toString());\n+\n+                                                              symbol.setDeprecated(false);\n+                                                              symbols.add(symbol);\n+                                                          }\n+                                                      }\n+                                                      for (Element ne : te.getEnclosedElements()) {", "originalCommit": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE2NTQwOA==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r489165408", "bodyText": "Could, but no.", "author": "jlahoda", "createdAt": "2020-09-16T05:06:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDkyMw==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134923", "bodyText": "Jackpot:\nwarning: Dereferencing possible null pointer", "author": "jlahoda-jackpot", "createdAt": "2020-08-22T20:21:30Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/workspace/WorkspaceServiceImpl.java", "diffHunk": "@@ -18,23 +18,215 @@\n  */\n package org.netbeans.modules.java.lsp.server.workspace;\n \n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.TypeElement;\n import org.eclipse.lsp4j.DidChangeConfigurationParams;\n import org.eclipse.lsp4j.DidChangeWatchedFilesParams;\n+import org.eclipse.lsp4j.Location;\n import org.eclipse.lsp4j.SymbolInformation;\n import org.eclipse.lsp4j.WorkspaceSymbolParams;\n import org.eclipse.lsp4j.services.WorkspaceService;\n+import org.netbeans.api.annotations.common.NonNull;\n+import org.netbeans.api.annotations.common.NullAllowed;\n+import org.netbeans.api.java.source.ClasspathInfo;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementHandle;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.JavaSource.Phase;\n+import org.netbeans.api.java.source.SourceUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider.ResultHandler;\n+import org.netbeans.modules.java.source.usages.ClassIndexImpl;\n+import org.netbeans.modules.parsing.lucene.support.Queries;\n+import org.netbeans.spi.jumpto.type.SearchType;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.Pair;\n+import org.openide.util.RequestProcessor;\n \n /**\n  *\n  * @author lahvac\n  */\n public class WorkspaceServiceImpl implements WorkspaceService {\n \n+    private static final RequestProcessor WORKER = new RequestProcessor(WorkspaceServiceImpl.class.getName(), 1, false, false);\n+\n     @Override\n-    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams arg0) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams params) {\n+        String query = params.getQuery();\n+        if (query.isEmpty()) {\n+            //cannot query \"all\":\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+        System.err.println(\"query=\" + query);\n+        boolean exact = false;\n+        if (query.endsWith(\" \")) {\n+            query = query.substring(0, query.length() - 1);\n+            exact = true;\n+        }\n+        String queryFin = query;\n+        boolean exactFin = exact;\n+        AtomicBoolean cancel = new AtomicBoolean();\n+        CompletableFuture<List<? extends SymbolInformation>> result = new CompletableFuture<List<? extends SymbolInformation>>() {\n+            @Override\n+            public boolean cancel(boolean mayInterruptIfRunning) {\n+                cancel.set(mayInterruptIfRunning);\n+                return super.cancel(mayInterruptIfRunning);\n+            }\n+        };\n+        WORKER.post(() -> {\n+            try {\n+                List<SymbolInformation> symbols = new ArrayList<>();\n+                ResultHandler handler = new ResultHandler() {\n+                    @Override\n+                    public void setHighlightText(String text) {\n+                    }\n+\n+                    private Map<ElementHandle<TypeElement>, List<String>> type2Idents;\n+\n+                    @Override\n+                    public void runRoot(FileObject root, ClassIndexImpl ci, Exec exec) throws IOException, InterruptedException {\n+                        ClasspathInfo cpInfo = ClasspathInfo.create(root);\n+                        try {\n+                            type2Idents = new HashMap<>();\n+                            exec.run();\n+                            Map<FileObject, Map<ElementHandle<TypeElement>, List<String>>> sources = new HashMap<>();\n+                            for (Entry<ElementHandle<TypeElement>, List<String>> e : type2Idents.entrySet()) {\n+                                FileObject sourceFile = SourceUtils.getFile(e.getKey(), cpInfo);\n+                                sources.computeIfAbsent(sourceFile, s -> new HashMap<>())\n+                                       .put(e.getKey(), e.getValue());\n+                            }\n+                            if (!sources.isEmpty()) {\n+                                JavaSource.create(cpInfo, sources.keySet())\n+                                          .runUserActionTask(cc -> {\n+                                              if (Phase.ELEMENTS_RESOLVED.compareTo(cc.toPhase(Phase.ELEMENTS_RESOLVED))> 0) {\n+                                                  return ;\n+                                              }\n+                                              for (Entry<ElementHandle<TypeElement>, List<String>> e : sources.get(cc.getFileObject()).entrySet()) {\n+                                                  TypeElement te = e.getKey().resolve(cc);\n+\n+                                                  for (String ident : e.getValue()) {\n+                                                      if (ident.equals(getSimpleName(te, null, false))) {\n+                                                          TreePath path = cc.getTrees().getPath(te);\n+\n+                                                          if (path != null) {\n+                                                              final String symbolName = te.getSimpleName().toString();", "originalCommit": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE3OTEyOQ==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r489179129", "bodyText": "Shall be fixed.", "author": "jlahoda", "createdAt": "2020-09-16T05:52:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDkyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDkyNQ==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134925", "bodyText": "Jackpot:\nwarning: Dereferencing possible null pointer", "author": "jlahoda-jackpot", "createdAt": "2020-08-22T20:21:31Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/workspace/WorkspaceServiceImpl.java", "diffHunk": "@@ -18,23 +18,215 @@\n  */\n package org.netbeans.modules.java.lsp.server.workspace;\n \n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.TypeElement;\n import org.eclipse.lsp4j.DidChangeConfigurationParams;\n import org.eclipse.lsp4j.DidChangeWatchedFilesParams;\n+import org.eclipse.lsp4j.Location;\n import org.eclipse.lsp4j.SymbolInformation;\n import org.eclipse.lsp4j.WorkspaceSymbolParams;\n import org.eclipse.lsp4j.services.WorkspaceService;\n+import org.netbeans.api.annotations.common.NonNull;\n+import org.netbeans.api.annotations.common.NullAllowed;\n+import org.netbeans.api.java.source.ClasspathInfo;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementHandle;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.JavaSource.Phase;\n+import org.netbeans.api.java.source.SourceUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider.ResultHandler;\n+import org.netbeans.modules.java.source.usages.ClassIndexImpl;\n+import org.netbeans.modules.parsing.lucene.support.Queries;\n+import org.netbeans.spi.jumpto.type.SearchType;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.Pair;\n+import org.openide.util.RequestProcessor;\n \n /**\n  *\n  * @author lahvac\n  */\n public class WorkspaceServiceImpl implements WorkspaceService {\n \n+    private static final RequestProcessor WORKER = new RequestProcessor(WorkspaceServiceImpl.class.getName(), 1, false, false);\n+\n     @Override\n-    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams arg0) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams params) {\n+        String query = params.getQuery();\n+        if (query.isEmpty()) {\n+            //cannot query \"all\":\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+        System.err.println(\"query=\" + query);\n+        boolean exact = false;\n+        if (query.endsWith(\" \")) {\n+            query = query.substring(0, query.length() - 1);\n+            exact = true;\n+        }\n+        String queryFin = query;\n+        boolean exactFin = exact;\n+        AtomicBoolean cancel = new AtomicBoolean();\n+        CompletableFuture<List<? extends SymbolInformation>> result = new CompletableFuture<List<? extends SymbolInformation>>() {\n+            @Override\n+            public boolean cancel(boolean mayInterruptIfRunning) {\n+                cancel.set(mayInterruptIfRunning);\n+                return super.cancel(mayInterruptIfRunning);\n+            }\n+        };\n+        WORKER.post(() -> {\n+            try {\n+                List<SymbolInformation> symbols = new ArrayList<>();\n+                ResultHandler handler = new ResultHandler() {\n+                    @Override\n+                    public void setHighlightText(String text) {\n+                    }\n+\n+                    private Map<ElementHandle<TypeElement>, List<String>> type2Idents;\n+\n+                    @Override\n+                    public void runRoot(FileObject root, ClassIndexImpl ci, Exec exec) throws IOException, InterruptedException {\n+                        ClasspathInfo cpInfo = ClasspathInfo.create(root);\n+                        try {\n+                            type2Idents = new HashMap<>();\n+                            exec.run();\n+                            Map<FileObject, Map<ElementHandle<TypeElement>, List<String>>> sources = new HashMap<>();\n+                            for (Entry<ElementHandle<TypeElement>, List<String>> e : type2Idents.entrySet()) {\n+                                FileObject sourceFile = SourceUtils.getFile(e.getKey(), cpInfo);\n+                                sources.computeIfAbsent(sourceFile, s -> new HashMap<>())\n+                                       .put(e.getKey(), e.getValue());\n+                            }\n+                            if (!sources.isEmpty()) {\n+                                JavaSource.create(cpInfo, sources.keySet())\n+                                          .runUserActionTask(cc -> {\n+                                              if (Phase.ELEMENTS_RESOLVED.compareTo(cc.toPhase(Phase.ELEMENTS_RESOLVED))> 0) {\n+                                                  return ;\n+                                              }\n+                                              for (Entry<ElementHandle<TypeElement>, List<String>> e : sources.get(cc.getFileObject()).entrySet()) {\n+                                                  TypeElement te = e.getKey().resolve(cc);\n+\n+                                                  for (String ident : e.getValue()) {\n+                                                      if (ident.equals(getSimpleName(te, null, false))) {\n+                                                          TreePath path = cc.getTrees().getPath(te);\n+\n+                                                          if (path != null) {\n+                                                              final String symbolName = te.getSimpleName().toString();\n+                                                              final ElementKind kind = te.getKind();\n+                                                              SymbolInformation symbol = new SymbolInformation(symbolName, Utils.elementKind2SymbolKind(kind), tree2Location(cc, path), te.getQualifiedName().toString());\n+\n+                                                              symbol.setDeprecated(false);\n+                                                              symbols.add(symbol);\n+                                                          }\n+                                                      }\n+                                                      for (Element ne : te.getEnclosedElements()) {", "originalCommit": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE3OTEwNw==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r489179107", "bodyText": "Shall be fixed.", "author": "jlahoda", "createdAt": "2020-09-16T05:52:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDkyOA==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134928", "bodyText": "Jackpot:\nwarning: Unused Import", "author": "jlahoda-jackpot", "createdAt": "2020-08-22T20:21:34Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/Utils.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server;\n+\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.LineMap;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.util.TreePath;", "originalCommit": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDkzMQ==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134931", "bodyText": "Jackpot:\nwarning: toString is never used", "author": "jlahoda-jackpot", "createdAt": "2020-08-22T20:21:38Z", "path": "java/java.lsp.server/test/unit/src/org/netbeans/modules/java/lsp/server/ServerTest.java", "diffHunk": "@@ -848,6 +869,71 @@ public void logMessage(MessageParams arg0) {\n         assertEquals(2, codeActions.size());\n     }\n \n+    public void testWorkspaceSymbols() throws Exception {\n+        File src = new File(getWorkDir(), \"Test.java\");\n+        src.getParentFile().mkdirs();\n+        try (Writer w = new FileWriter(new File(src.getParentFile(), \".test-project\"))) {}\n+        String code = \"public class Test {\\n\" +\n+                      \"    public static class TestNested {}\\n\" +\n+                      \"    public static void testMethod() {}\\n\" +\n+                      \"}\\n\";\n+        try (Writer w = new FileWriter(src)) {\n+            w.write(code);\n+        }\n+        CountDownLatch indexingComplete = new CountDownLatch(1);\n+        Launcher<LanguageServer> serverLauncher = LSPLauncher.createClientLauncher(new LanguageClient() {\n+            @Override\n+            public void telemetryEvent(Object arg0) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+\n+            @Override\n+            public void publishDiagnostics(PublishDiagnosticsParams params) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+\n+            @Override\n+            public void showMessage(MessageParams params) {\n+                if (Server.INDEXING_COMPLETED.equals(params.getMessage())) {\n+                    indexingComplete.countDown();\n+                } else {\n+                    throw new UnsupportedOperationException(\"Unexpected message.\");\n+                }\n+            }\n+\n+            @Override\n+            public CompletableFuture<MessageActionItem> showMessageRequest(ShowMessageRequestParams arg0) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+\n+            @Override\n+            public void logMessage(MessageParams arg0) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+        }, client.getInputStream(), client.getOutputStream());\n+        serverLauncher.startListening();\n+        LanguageServer server = serverLauncher.getRemoteProxy();\n+        InitializeParams initParams = new InitializeParams();\n+        initParams.setRootUri(getWorkDir().toURI().toString());\n+        InitializeResult result = server.initialize(initParams).get();\n+        indexingComplete.await();\n+        List<? extends SymbolInformation> symbols = server.getWorkspaceService().symbol(new WorkspaceSymbolParams(\"Tes\")).get();\n+        List<String> actual = symbols.stream().map(si -> si.getKind() + \":\" + si.getName() + \":\" + si.getContainerName() + \":\" + si.getDeprecated() + \":\" + toString(si.getLocation())).collect(Collectors.toList());\n+        assertEquals(Arrays.asList(\"Class:Test:Test:false:Test.java:0:0-3:1\",\n+                                   \"Constructor:():Test:false:Test.java:0:7-0:7\",\n+                                   \"Method:():Test:false:Test.java:2:4-2:38\",\n+                                   \"Class:TestNested:Test.TestNested:false:Test.java:1:4-1:37\",\n+                                   \"Constructor:():Test.TestNested:false:Test.java:1:18-1:18\"),\n+                     actual);\n+    }\n+\n+    private String toString(Location location) {", "originalCommit": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE2NzA5MA==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r489167090", "bodyText": "The method is used (a few lines up) - probably a bug in the checker?", "author": "jlahoda", "createdAt": "2020-09-16T05:12:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDk1Ng==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134956", "bodyText": "Jackpot:\nwarning: Variable w is never read", "author": "jlahoda-jackpot", "createdAt": "2020-08-22T20:21:50Z", "path": "java/java.lsp.server/test/unit/src/org/netbeans/modules/java/lsp/server/ServerTest.java", "diffHunk": "@@ -848,6 +869,71 @@ public void logMessage(MessageParams arg0) {\n         assertEquals(2, codeActions.size());\n     }\n \n+    public void testWorkspaceSymbols() throws Exception {\n+        File src = new File(getWorkDir(), \"Test.java\");\n+        src.getParentFile().mkdirs();\n+        try (Writer w = new FileWriter(new File(src.getParentFile(), \".test-project\"))) {}", "originalCommit": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE3OTAzOA==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r489179038", "bodyText": "Keeping as it is right now. We might think of tweaking the hint to not warn for cases like this, but unsure.", "author": "jlahoda", "createdAt": "2020-09-16T05:51:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDk1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDk1OA==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134958", "bodyText": "Jackpot:\nwarning: Variable result is never read", "author": "jlahoda-jackpot", "createdAt": "2020-08-22T20:21:52Z", "path": "java/java.lsp.server/test/unit/src/org/netbeans/modules/java/lsp/server/ServerTest.java", "diffHunk": "@@ -848,6 +869,71 @@ public void logMessage(MessageParams arg0) {\n         assertEquals(2, codeActions.size());\n     }\n \n+    public void testWorkspaceSymbols() throws Exception {\n+        File src = new File(getWorkDir(), \"Test.java\");\n+        src.getParentFile().mkdirs();\n+        try (Writer w = new FileWriter(new File(src.getParentFile(), \".test-project\"))) {}\n+        String code = \"public class Test {\\n\" +\n+                      \"    public static class TestNested {}\\n\" +\n+                      \"    public static void testMethod() {}\\n\" +\n+                      \"}\\n\";\n+        try (Writer w = new FileWriter(src)) {\n+            w.write(code);\n+        }\n+        CountDownLatch indexingComplete = new CountDownLatch(1);\n+        Launcher<LanguageServer> serverLauncher = LSPLauncher.createClientLauncher(new LanguageClient() {\n+            @Override\n+            public void telemetryEvent(Object arg0) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+\n+            @Override\n+            public void publishDiagnostics(PublishDiagnosticsParams params) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+\n+            @Override\n+            public void showMessage(MessageParams params) {\n+                if (Server.INDEXING_COMPLETED.equals(params.getMessage())) {\n+                    indexingComplete.countDown();\n+                } else {\n+                    throw new UnsupportedOperationException(\"Unexpected message.\");\n+                }\n+            }\n+\n+            @Override\n+            public CompletableFuture<MessageActionItem> showMessageRequest(ShowMessageRequestParams arg0) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+\n+            @Override\n+            public void logMessage(MessageParams arg0) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+        }, client.getInputStream(), client.getOutputStream());\n+        serverLauncher.startListening();\n+        LanguageServer server = serverLauncher.getRemoteProxy();\n+        InitializeParams initParams = new InitializeParams();\n+        initParams.setRootUri(getWorkDir().toURI().toString());\n+        InitializeResult result = server.initialize(initParams).get();", "originalCommit": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE3ODgxMQ==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r489178811", "bodyText": "Right, not used, intentional here. Keeping as it is right now.", "author": "jlahoda", "createdAt": "2020-09-16T05:51:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDk2MA==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134960", "bodyText": "Jackpot:\nwarning: Use Utilities API for URI/File conversion", "author": "jlahoda-jackpot", "createdAt": "2020-08-22T20:21:53Z", "path": "java/java.lsp.server/test/unit/src/org/netbeans/modules/java/lsp/server/ServerTest.java", "diffHunk": "@@ -848,6 +869,71 @@ public void logMessage(MessageParams arg0) {\n         assertEquals(2, codeActions.size());\n     }\n \n+    public void testWorkspaceSymbols() throws Exception {\n+        File src = new File(getWorkDir(), \"Test.java\");\n+        src.getParentFile().mkdirs();\n+        try (Writer w = new FileWriter(new File(src.getParentFile(), \".test-project\"))) {}\n+        String code = \"public class Test {\\n\" +\n+                      \"    public static class TestNested {}\\n\" +\n+                      \"    public static void testMethod() {}\\n\" +\n+                      \"}\\n\";\n+        try (Writer w = new FileWriter(src)) {\n+            w.write(code);\n+        }\n+        CountDownLatch indexingComplete = new CountDownLatch(1);\n+        Launcher<LanguageServer> serverLauncher = LSPLauncher.createClientLauncher(new LanguageClient() {\n+            @Override\n+            public void telemetryEvent(Object arg0) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+\n+            @Override\n+            public void publishDiagnostics(PublishDiagnosticsParams params) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+\n+            @Override\n+            public void showMessage(MessageParams params) {\n+                if (Server.INDEXING_COMPLETED.equals(params.getMessage())) {\n+                    indexingComplete.countDown();\n+                } else {\n+                    throw new UnsupportedOperationException(\"Unexpected message.\");\n+                }\n+            }\n+\n+            @Override\n+            public CompletableFuture<MessageActionItem> showMessageRequest(ShowMessageRequestParams arg0) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+\n+            @Override\n+            public void logMessage(MessageParams arg0) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+        }, client.getInputStream(), client.getOutputStream());\n+        serverLauncher.startListening();\n+        LanguageServer server = serverLauncher.getRemoteProxy();\n+        InitializeParams initParams = new InitializeParams();\n+        initParams.setRootUri(getWorkDir().toURI().toString());", "originalCommit": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE3ODYzMw==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r489178633", "bodyText": "Right - fixed (by also introducing a utility in the test).", "author": "jlahoda", "createdAt": "2020-09-16T05:50:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDk2NQ==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134965", "bodyText": "Jackpot:\nwarning: Can use functional operations", "author": "jlahoda-jackpot", "createdAt": "2020-08-22T20:21:55Z", "path": "java/java.sourceui/src/org/netbeans/modules/java/source/ui/JavaSymbolProvider.java", "diffHunk": "@@ -117,145 +119,187 @@ public void computeSymbolNames(final Context context, final Result result) {\n             final Cache cache = scanInProgress ?\n                 Cache.create(textToSearch, st) :\n                 null;\n-            String prefix = null;\n-            final int dotIndex = textToSearch.lastIndexOf('.'); //NOI18N\n-            if (dotIndex > 0 && dotIndex != textToSearch.length()-1) {\n-                prefix = textToSearch.substring(0, dotIndex);\n-                textToSearch = textToSearch.substring(dotIndex+1);\n-            }\n-            final String textToHighLight = textToSearch;\n-            ClassIndex.NameKind _kind;\n-            boolean _caseSensitive;\n-            switch (st) {\n-                case PREFIX:\n-                    _kind = ClassIndex.NameKind.PREFIX;\n-                    _caseSensitive = true;\n-                    break;\n-                case REGEXP:\n-                    _kind = ClassIndex.NameKind.REGEXP;\n-                    textToSearch = NameMatcherFactory.wildcardsToRegexp(\n-                            removeNonJavaChars(textToSearch),\n-                            true);\n-                    _caseSensitive = true;\n-                    break;\n-                case CAMEL_CASE:\n-                    _kind = ClassIndex.NameKind.CAMEL_CASE;\n-                    _caseSensitive = true;\n-                    break;\n-                case CASE_INSENSITIVE_CAMEL_CASE:\n-                    _kind = ClassIndex.NameKind.CAMEL_CASE_INSENSITIVE;\n-                    _caseSensitive = false;\n-                    break;\n-                case EXACT_NAME:\n-                    _kind = ClassIndex.NameKind.SIMPLE_NAME;\n-                    _caseSensitive = true;\n-                    break;\n-                case CASE_INSENSITIVE_PREFIX:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_PREFIX;\n-                    _caseSensitive = false;\n-                    break;\n-                case CASE_INSENSITIVE_EXACT_NAME:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n-                    _caseSensitive = false;\n-                    break;\n-                case CASE_INSENSITIVE_REGEXP:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n-                    textToSearch = NameMatcherFactory.wildcardsToRegexp(\n-                            removeNonJavaChars(textToSearch),\n-                            true);\n-                    _caseSensitive = false;\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException();\n-            }\n-            final String ident = textToSearch;\n-            final ClassIndex.NameKind kind = _kind;\n-            final boolean caseSensitive = _caseSensitive;\n-            final Pair<NameMatcher,Boolean> restriction;\n-            if (prefix != null) {\n-                restriction = compileName(prefix,caseSensitive);\n-                result.setHighlightText(textToHighLight);\n-            } else {\n-                restriction = null;\n-            }\n-            try {\n-                final ClassIndexManager manager = ClassIndexManager.getDefault();\n-\n-                Collection<FileObject> roots = QuerySupport.findRoots(\n-                        (Project)null,\n-                        Collections.singleton(ClassPath.SOURCE),\n-                        Collections.<String>emptySet(),\n-                        Collections.<String>emptySet());\n-\n-                final Set<URL> rootUrls = new HashSet<>();\n-                for(FileObject root : roots) {\n-                    if (canceled) {\n-                        return;\n+            doComputeSymbols(st, textToSearch, new ResultHandler() {\n+                private FileObject root;\n+                private ProjectInformation projectInfo;\n+                private ClassIndexImpl ci;\n+                @Override\n+                public void setHighlightText(String text) {\n+                    result.setHighlightText(text);\n+                }\n+\n+                @Override\n+                public void runRoot(FileObject root, ClassIndexImpl ci, Exec exec) throws IOException, InterruptedException {\n+                    try {\n+                        Project project = FileOwnerQuery.getOwner(root);\n+\n+                        this.root = root;\n+                        this.projectInfo = project == null ?\n+                                null :\n+                                project.getLookup().lookup(ProjectInformation.class);   //Intentionally does not use ProjectUtils.getInformation() it does project icon annotation which is expensive\n+                        this.ci = ci;\n+                        exec.run();\n+                    } finally {\n+                        this.root = null;\n+                        this.projectInfo = null;\n+                        this.ci = null;\n                     }\n-                    rootUrls.add(root.toURL());\n                 }\n \n-                if (LOGGER.isLoggable(Level.FINE)) {\n-                    LOGGER.log(Level.FINE, \"Querying following roots:\"); //NOI18N\n-                    for (URL url : rootUrls) {\n-                        LOGGER.log(Level.FINE, \"  {0}\", url); //NOI18N\n+                @Override\n+                public void handleResult(ElementHandle<TypeElement> owner, String ident, boolean caseSensitive) {\n+                    final AsyncJavaSymbolDescriptor d = new AsyncJavaSymbolDescriptor(\n+                            projectInfo,\n+                            root,\n+                            ci,\n+                            owner,\n+                            ident,\n+                            caseSensitive);\n+                    result.addResult(d);\n+                    if (cache != null) {\n+                        cache.offer(d);\n                     }\n-                    LOGGER.log(Level.FINE, \"-------------------------\"); //NOI18N\n                 }\n-                //Perform all queries in single op\n-                IndexManager.priorityAccess(new IndexManager.Action<Void>() {\n-                    @Override\n-                    public Void run() throws IOException, InterruptedException {\n-                        for (URL url : rootUrls) {\n-                            if (canceled) {\n-                                return null;\n-                            }\n-                            final FileObject root = URLMapper.findFileObject(url);\n-                            if (root == null) {\n-                                continue;\n-                            }\n-\n-                            final Project project = FileOwnerQuery.getOwner(root);\n-                            final ProjectInformation projectInfo = project == null ?\n-                                    null :\n-                                    project.getLookup().lookup(ProjectInformation.class);   //Intentionally does not use ProjectUtils.getInformation() it does project icon annotation which is expensive\n-                            final ClassIndexImpl impl = manager.getUsagesQuery(root.toURL(), true);\n-                            if (impl != null) {\n+            }, true, canceled);\n+        } finally {\n+            clearCancel();\n+        }\n+    }\n+\n+    public static void doComputeSymbols(SearchType st, String textToSearch, ResultHandler handler, boolean async, AtomicBoolean canceled) {\n+        String prefix = null;\n+        final int dotIndex = textToSearch.lastIndexOf('.'); //NOI18N\n+        if (dotIndex > 0 && dotIndex != textToSearch.length()-1) {\n+            prefix = textToSearch.substring(0, dotIndex);\n+            textToSearch = textToSearch.substring(dotIndex+1);\n+        }\n+        final String textToHighLight = textToSearch;\n+        ClassIndex.NameKind _kind;\n+        boolean _caseSensitive;\n+        switch (st) {\n+            case PREFIX:\n+                _kind = ClassIndex.NameKind.PREFIX;\n+                _caseSensitive = true;\n+                break;\n+            case REGEXP:\n+                _kind = ClassIndex.NameKind.REGEXP;\n+                textToSearch = NameMatcherFactory.wildcardsToRegexp(\n+                        removeNonJavaChars(textToSearch),\n+                        true);\n+                _caseSensitive = true;\n+                break;\n+            case CAMEL_CASE:\n+                _kind = ClassIndex.NameKind.CAMEL_CASE;\n+                _caseSensitive = true;\n+                break;\n+            case CASE_INSENSITIVE_CAMEL_CASE:\n+                _kind = ClassIndex.NameKind.CAMEL_CASE_INSENSITIVE;\n+                _caseSensitive = false;\n+                break;\n+            case EXACT_NAME:\n+                _kind = ClassIndex.NameKind.SIMPLE_NAME;\n+                _caseSensitive = true;\n+                break;\n+            case CASE_INSENSITIVE_PREFIX:\n+                _kind = ClassIndex.NameKind.CASE_INSENSITIVE_PREFIX;\n+                _caseSensitive = false;\n+                break;\n+            case CASE_INSENSITIVE_EXACT_NAME:\n+                _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n+                _caseSensitive = false;\n+                break;\n+            case CASE_INSENSITIVE_REGEXP:\n+                _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n+                textToSearch = NameMatcherFactory.wildcardsToRegexp(\n+                        removeNonJavaChars(textToSearch),\n+                        true);\n+                _caseSensitive = false;\n+                break;\n+            default:\n+                throw new IllegalArgumentException();\n+        }\n+        final String ident = textToSearch;\n+        final ClassIndex.NameKind kind = _kind;\n+        final boolean caseSensitive = _caseSensitive;\n+        final Pair<NameMatcher,Boolean> restriction;\n+        if (prefix != null) {\n+            restriction = compileName(prefix,caseSensitive);\n+            handler.setHighlightText(textToHighLight);\n+        } else {\n+            restriction = null;\n+        }\n+        try {\n+            final ClassIndexManager manager = ClassIndexManager.getDefault();\n+\n+            Collection<FileObject> roots = QuerySupport.findRoots(\n+                    (Project)null,\n+                    Collections.singleton(ClassPath.SOURCE),\n+                    Collections.<String>emptySet(),\n+                    Collections.<String>emptySet());\n+\n+            final Set<URL> rootUrls = new HashSet<>();\n+            for(FileObject root : roots) {\n+                if (canceled.get()) {\n+                    return;\n+                }\n+                rootUrls.add(root.toURL());\n+            }\n+\n+            if (LOGGER.isLoggable(Level.FINE)) {\n+                LOGGER.log(Level.FINE, \"Querying following roots:\"); //NOI18N\n+                for (URL url : rootUrls) {", "originalCommit": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE2NTU0MQ==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r489165541", "bodyText": "Could, but no.", "author": "jlahoda", "createdAt": "2020-09-16T05:06:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDk2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDk3Ng==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134976", "bodyText": "Jackpot:\nwarning: Unused Import", "author": "jlahoda-jackpot", "createdAt": "2020-08-22T20:21:57Z", "path": "java/java.sourceui/src/org/netbeans/modules/java/source/ui/JavaSymbolProvider.java", "diffHunk": "@@ -29,6 +29,8 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;", "originalCommit": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDk3OA==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134978", "bodyText": "Jackpot:\nwarning: This anonymous inner class creation can be turned into a lambda expression.", "author": "jlahoda-jackpot", "createdAt": "2020-08-22T20:21:59Z", "path": "java/java.sourceui/src/org/netbeans/modules/java/source/ui/JavaSymbolProvider.java", "diffHunk": "@@ -117,145 +119,187 @@ public void computeSymbolNames(final Context context, final Result result) {\n             final Cache cache = scanInProgress ?\n                 Cache.create(textToSearch, st) :\n                 null;\n-            String prefix = null;\n-            final int dotIndex = textToSearch.lastIndexOf('.'); //NOI18N\n-            if (dotIndex > 0 && dotIndex != textToSearch.length()-1) {\n-                prefix = textToSearch.substring(0, dotIndex);\n-                textToSearch = textToSearch.substring(dotIndex+1);\n-            }\n-            final String textToHighLight = textToSearch;\n-            ClassIndex.NameKind _kind;\n-            boolean _caseSensitive;\n-            switch (st) {\n-                case PREFIX:\n-                    _kind = ClassIndex.NameKind.PREFIX;\n-                    _caseSensitive = true;\n-                    break;\n-                case REGEXP:\n-                    _kind = ClassIndex.NameKind.REGEXP;\n-                    textToSearch = NameMatcherFactory.wildcardsToRegexp(\n-                            removeNonJavaChars(textToSearch),\n-                            true);\n-                    _caseSensitive = true;\n-                    break;\n-                case CAMEL_CASE:\n-                    _kind = ClassIndex.NameKind.CAMEL_CASE;\n-                    _caseSensitive = true;\n-                    break;\n-                case CASE_INSENSITIVE_CAMEL_CASE:\n-                    _kind = ClassIndex.NameKind.CAMEL_CASE_INSENSITIVE;\n-                    _caseSensitive = false;\n-                    break;\n-                case EXACT_NAME:\n-                    _kind = ClassIndex.NameKind.SIMPLE_NAME;\n-                    _caseSensitive = true;\n-                    break;\n-                case CASE_INSENSITIVE_PREFIX:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_PREFIX;\n-                    _caseSensitive = false;\n-                    break;\n-                case CASE_INSENSITIVE_EXACT_NAME:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n-                    _caseSensitive = false;\n-                    break;\n-                case CASE_INSENSITIVE_REGEXP:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n-                    textToSearch = NameMatcherFactory.wildcardsToRegexp(\n-                            removeNonJavaChars(textToSearch),\n-                            true);\n-                    _caseSensitive = false;\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException();\n-            }\n-            final String ident = textToSearch;\n-            final ClassIndex.NameKind kind = _kind;\n-            final boolean caseSensitive = _caseSensitive;\n-            final Pair<NameMatcher,Boolean> restriction;\n-            if (prefix != null) {\n-                restriction = compileName(prefix,caseSensitive);\n-                result.setHighlightText(textToHighLight);\n-            } else {\n-                restriction = null;\n-            }\n-            try {\n-                final ClassIndexManager manager = ClassIndexManager.getDefault();\n-\n-                Collection<FileObject> roots = QuerySupport.findRoots(\n-                        (Project)null,\n-                        Collections.singleton(ClassPath.SOURCE),\n-                        Collections.<String>emptySet(),\n-                        Collections.<String>emptySet());\n-\n-                final Set<URL> rootUrls = new HashSet<>();\n-                for(FileObject root : roots) {\n-                    if (canceled) {\n-                        return;\n+            doComputeSymbols(st, textToSearch, new ResultHandler() {\n+                private FileObject root;\n+                private ProjectInformation projectInfo;\n+                private ClassIndexImpl ci;\n+                @Override\n+                public void setHighlightText(String text) {\n+                    result.setHighlightText(text);\n+                }\n+\n+                @Override\n+                public void runRoot(FileObject root, ClassIndexImpl ci, Exec exec) throws IOException, InterruptedException {\n+                    try {\n+                        Project project = FileOwnerQuery.getOwner(root);\n+\n+                        this.root = root;\n+                        this.projectInfo = project == null ?\n+                                null :\n+                                project.getLookup().lookup(ProjectInformation.class);   //Intentionally does not use ProjectUtils.getInformation() it does project icon annotation which is expensive\n+                        this.ci = ci;\n+                        exec.run();\n+                    } finally {\n+                        this.root = null;\n+                        this.projectInfo = null;\n+                        this.ci = null;\n                     }\n-                    rootUrls.add(root.toURL());\n                 }\n \n-                if (LOGGER.isLoggable(Level.FINE)) {\n-                    LOGGER.log(Level.FINE, \"Querying following roots:\"); //NOI18N\n-                    for (URL url : rootUrls) {\n-                        LOGGER.log(Level.FINE, \"  {0}\", url); //NOI18N\n+                @Override\n+                public void handleResult(ElementHandle<TypeElement> owner, String ident, boolean caseSensitive) {\n+                    final AsyncJavaSymbolDescriptor d = new AsyncJavaSymbolDescriptor(\n+                            projectInfo,\n+                            root,\n+                            ci,\n+                            owner,\n+                            ident,\n+                            caseSensitive);\n+                    result.addResult(d);\n+                    if (cache != null) {\n+                        cache.offer(d);\n                     }\n-                    LOGGER.log(Level.FINE, \"-------------------------\"); //NOI18N\n                 }\n-                //Perform all queries in single op\n-                IndexManager.priorityAccess(new IndexManager.Action<Void>() {\n-                    @Override\n-                    public Void run() throws IOException, InterruptedException {\n-                        for (URL url : rootUrls) {\n-                            if (canceled) {\n-                                return null;\n-                            }\n-                            final FileObject root = URLMapper.findFileObject(url);\n-                            if (root == null) {\n-                                continue;\n-                            }\n-\n-                            final Project project = FileOwnerQuery.getOwner(root);\n-                            final ProjectInformation projectInfo = project == null ?\n-                                    null :\n-                                    project.getLookup().lookup(ProjectInformation.class);   //Intentionally does not use ProjectUtils.getInformation() it does project icon annotation which is expensive\n-                            final ClassIndexImpl impl = manager.getUsagesQuery(root.toURL(), true);\n-                            if (impl != null) {\n+            }, true, canceled);\n+        } finally {\n+            clearCancel();\n+        }\n+    }\n+\n+    public static void doComputeSymbols(SearchType st, String textToSearch, ResultHandler handler, boolean async, AtomicBoolean canceled) {\n+        String prefix = null;\n+        final int dotIndex = textToSearch.lastIndexOf('.'); //NOI18N\n+        if (dotIndex > 0 && dotIndex != textToSearch.length()-1) {\n+            prefix = textToSearch.substring(0, dotIndex);\n+            textToSearch = textToSearch.substring(dotIndex+1);\n+        }\n+        final String textToHighLight = textToSearch;\n+        ClassIndex.NameKind _kind;\n+        boolean _caseSensitive;\n+        switch (st) {\n+            case PREFIX:\n+                _kind = ClassIndex.NameKind.PREFIX;\n+                _caseSensitive = true;\n+                break;\n+            case REGEXP:\n+                _kind = ClassIndex.NameKind.REGEXP;\n+                textToSearch = NameMatcherFactory.wildcardsToRegexp(\n+                        removeNonJavaChars(textToSearch),\n+                        true);\n+                _caseSensitive = true;\n+                break;\n+            case CAMEL_CASE:\n+                _kind = ClassIndex.NameKind.CAMEL_CASE;\n+                _caseSensitive = true;\n+                break;\n+            case CASE_INSENSITIVE_CAMEL_CASE:\n+                _kind = ClassIndex.NameKind.CAMEL_CASE_INSENSITIVE;\n+                _caseSensitive = false;\n+                break;\n+            case EXACT_NAME:\n+                _kind = ClassIndex.NameKind.SIMPLE_NAME;\n+                _caseSensitive = true;\n+                break;\n+            case CASE_INSENSITIVE_PREFIX:\n+                _kind = ClassIndex.NameKind.CASE_INSENSITIVE_PREFIX;\n+                _caseSensitive = false;\n+                break;\n+            case CASE_INSENSITIVE_EXACT_NAME:\n+                _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n+                _caseSensitive = false;\n+                break;\n+            case CASE_INSENSITIVE_REGEXP:\n+                _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n+                textToSearch = NameMatcherFactory.wildcardsToRegexp(\n+                        removeNonJavaChars(textToSearch),\n+                        true);\n+                _caseSensitive = false;\n+                break;\n+            default:\n+                throw new IllegalArgumentException();\n+        }\n+        final String ident = textToSearch;\n+        final ClassIndex.NameKind kind = _kind;\n+        final boolean caseSensitive = _caseSensitive;\n+        final Pair<NameMatcher,Boolean> restriction;\n+        if (prefix != null) {\n+            restriction = compileName(prefix,caseSensitive);\n+            handler.setHighlightText(textToHighLight);\n+        } else {\n+            restriction = null;\n+        }\n+        try {\n+            final ClassIndexManager manager = ClassIndexManager.getDefault();\n+\n+            Collection<FileObject> roots = QuerySupport.findRoots(\n+                    (Project)null,\n+                    Collections.singleton(ClassPath.SOURCE),\n+                    Collections.<String>emptySet(),\n+                    Collections.<String>emptySet());\n+\n+            final Set<URL> rootUrls = new HashSet<>();\n+            for(FileObject root : roots) {\n+                if (canceled.get()) {\n+                    return;\n+                }\n+                rootUrls.add(root.toURL());\n+            }\n+\n+            if (LOGGER.isLoggable(Level.FINE)) {\n+                LOGGER.log(Level.FINE, \"Querying following roots:\"); //NOI18N\n+                for (URL url : rootUrls) {\n+                    LOGGER.log(Level.FINE, \"  {0}\", url); //NOI18N\n+                }\n+                LOGGER.log(Level.FINE, \"-------------------------\"); //NOI18N\n+            }\n+            //Perform all queries in single op\n+            IndexManager.priorityAccess(new IndexManager.Action<Void>() {", "originalCommit": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE3ODQxNw==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r489178417", "bodyText": "It could, but the body is fairly long. Seems the anonymous class is a better fit here.", "author": "jlahoda", "createdAt": "2020-09-16T05:50:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDk3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDk5MA==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134990", "bodyText": "Jackpot:\nwarning: Use ProjectUtils API", "author": "jlahoda-jackpot", "createdAt": "2020-08-22T20:22:10Z", "path": "java/java.sourceui/src/org/netbeans/modules/java/source/ui/JavaSymbolProvider.java", "diffHunk": "@@ -117,145 +119,187 @@ public void computeSymbolNames(final Context context, final Result result) {\n             final Cache cache = scanInProgress ?\n                 Cache.create(textToSearch, st) :\n                 null;\n-            String prefix = null;\n-            final int dotIndex = textToSearch.lastIndexOf('.'); //NOI18N\n-            if (dotIndex > 0 && dotIndex != textToSearch.length()-1) {\n-                prefix = textToSearch.substring(0, dotIndex);\n-                textToSearch = textToSearch.substring(dotIndex+1);\n-            }\n-            final String textToHighLight = textToSearch;\n-            ClassIndex.NameKind _kind;\n-            boolean _caseSensitive;\n-            switch (st) {\n-                case PREFIX:\n-                    _kind = ClassIndex.NameKind.PREFIX;\n-                    _caseSensitive = true;\n-                    break;\n-                case REGEXP:\n-                    _kind = ClassIndex.NameKind.REGEXP;\n-                    textToSearch = NameMatcherFactory.wildcardsToRegexp(\n-                            removeNonJavaChars(textToSearch),\n-                            true);\n-                    _caseSensitive = true;\n-                    break;\n-                case CAMEL_CASE:\n-                    _kind = ClassIndex.NameKind.CAMEL_CASE;\n-                    _caseSensitive = true;\n-                    break;\n-                case CASE_INSENSITIVE_CAMEL_CASE:\n-                    _kind = ClassIndex.NameKind.CAMEL_CASE_INSENSITIVE;\n-                    _caseSensitive = false;\n-                    break;\n-                case EXACT_NAME:\n-                    _kind = ClassIndex.NameKind.SIMPLE_NAME;\n-                    _caseSensitive = true;\n-                    break;\n-                case CASE_INSENSITIVE_PREFIX:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_PREFIX;\n-                    _caseSensitive = false;\n-                    break;\n-                case CASE_INSENSITIVE_EXACT_NAME:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n-                    _caseSensitive = false;\n-                    break;\n-                case CASE_INSENSITIVE_REGEXP:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n-                    textToSearch = NameMatcherFactory.wildcardsToRegexp(\n-                            removeNonJavaChars(textToSearch),\n-                            true);\n-                    _caseSensitive = false;\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException();\n-            }\n-            final String ident = textToSearch;\n-            final ClassIndex.NameKind kind = _kind;\n-            final boolean caseSensitive = _caseSensitive;\n-            final Pair<NameMatcher,Boolean> restriction;\n-            if (prefix != null) {\n-                restriction = compileName(prefix,caseSensitive);\n-                result.setHighlightText(textToHighLight);\n-            } else {\n-                restriction = null;\n-            }\n-            try {\n-                final ClassIndexManager manager = ClassIndexManager.getDefault();\n-\n-                Collection<FileObject> roots = QuerySupport.findRoots(\n-                        (Project)null,\n-                        Collections.singleton(ClassPath.SOURCE),\n-                        Collections.<String>emptySet(),\n-                        Collections.<String>emptySet());\n-\n-                final Set<URL> rootUrls = new HashSet<>();\n-                for(FileObject root : roots) {\n-                    if (canceled) {\n-                        return;\n+            doComputeSymbols(st, textToSearch, new ResultHandler() {\n+                private FileObject root;\n+                private ProjectInformation projectInfo;\n+                private ClassIndexImpl ci;\n+                @Override\n+                public void setHighlightText(String text) {\n+                    result.setHighlightText(text);\n+                }\n+\n+                @Override\n+                public void runRoot(FileObject root, ClassIndexImpl ci, Exec exec) throws IOException, InterruptedException {\n+                    try {\n+                        Project project = FileOwnerQuery.getOwner(root);\n+\n+                        this.root = root;\n+                        this.projectInfo = project == null ?\n+                                null :\n+                                project.getLookup().lookup(ProjectInformation.class);   //Intentionally does not use ProjectUtils.getInformation() it does project icon annotation which is expensive", "originalCommit": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE2NTgxMQ==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r489165811", "bodyText": "Intentionally not using ProjectUtils at this place.", "author": "jlahoda", "createdAt": "2020-09-16T05:08:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDk5OQ==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134999", "bodyText": "Jackpot:\nwarning: Unnecessary return statement", "author": "jlahoda-jackpot", "createdAt": "2020-08-22T20:22:12Z", "path": "java/java.sourceui/src/org/netbeans/modules/java/source/ui/JavaSymbolProvider.java", "diffHunk": "@@ -117,145 +119,187 @@ public void computeSymbolNames(final Context context, final Result result) {\n             final Cache cache = scanInProgress ?\n                 Cache.create(textToSearch, st) :\n                 null;\n-            String prefix = null;\n-            final int dotIndex = textToSearch.lastIndexOf('.'); //NOI18N\n-            if (dotIndex > 0 && dotIndex != textToSearch.length()-1) {\n-                prefix = textToSearch.substring(0, dotIndex);\n-                textToSearch = textToSearch.substring(dotIndex+1);\n-            }\n-            final String textToHighLight = textToSearch;\n-            ClassIndex.NameKind _kind;\n-            boolean _caseSensitive;\n-            switch (st) {\n-                case PREFIX:\n-                    _kind = ClassIndex.NameKind.PREFIX;\n-                    _caseSensitive = true;\n-                    break;\n-                case REGEXP:\n-                    _kind = ClassIndex.NameKind.REGEXP;\n-                    textToSearch = NameMatcherFactory.wildcardsToRegexp(\n-                            removeNonJavaChars(textToSearch),\n-                            true);\n-                    _caseSensitive = true;\n-                    break;\n-                case CAMEL_CASE:\n-                    _kind = ClassIndex.NameKind.CAMEL_CASE;\n-                    _caseSensitive = true;\n-                    break;\n-                case CASE_INSENSITIVE_CAMEL_CASE:\n-                    _kind = ClassIndex.NameKind.CAMEL_CASE_INSENSITIVE;\n-                    _caseSensitive = false;\n-                    break;\n-                case EXACT_NAME:\n-                    _kind = ClassIndex.NameKind.SIMPLE_NAME;\n-                    _caseSensitive = true;\n-                    break;\n-                case CASE_INSENSITIVE_PREFIX:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_PREFIX;\n-                    _caseSensitive = false;\n-                    break;\n-                case CASE_INSENSITIVE_EXACT_NAME:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n-                    _caseSensitive = false;\n-                    break;\n-                case CASE_INSENSITIVE_REGEXP:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n-                    textToSearch = NameMatcherFactory.wildcardsToRegexp(\n-                            removeNonJavaChars(textToSearch),\n-                            true);\n-                    _caseSensitive = false;\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException();\n-            }\n-            final String ident = textToSearch;\n-            final ClassIndex.NameKind kind = _kind;\n-            final boolean caseSensitive = _caseSensitive;\n-            final Pair<NameMatcher,Boolean> restriction;\n-            if (prefix != null) {\n-                restriction = compileName(prefix,caseSensitive);\n-                result.setHighlightText(textToHighLight);\n-            } else {\n-                restriction = null;\n-            }\n-            try {\n-                final ClassIndexManager manager = ClassIndexManager.getDefault();\n-\n-                Collection<FileObject> roots = QuerySupport.findRoots(\n-                        (Project)null,\n-                        Collections.singleton(ClassPath.SOURCE),\n-                        Collections.<String>emptySet(),\n-                        Collections.<String>emptySet());\n-\n-                final Set<URL> rootUrls = new HashSet<>();\n-                for(FileObject root : roots) {\n-                    if (canceled) {\n-                        return;\n+            doComputeSymbols(st, textToSearch, new ResultHandler() {\n+                private FileObject root;\n+                private ProjectInformation projectInfo;\n+                private ClassIndexImpl ci;\n+                @Override\n+                public void setHighlightText(String text) {\n+                    result.setHighlightText(text);\n+                }\n+\n+                @Override\n+                public void runRoot(FileObject root, ClassIndexImpl ci, Exec exec) throws IOException, InterruptedException {\n+                    try {\n+                        Project project = FileOwnerQuery.getOwner(root);\n+\n+                        this.root = root;\n+                        this.projectInfo = project == null ?\n+                                null :\n+                                project.getLookup().lookup(ProjectInformation.class);   //Intentionally does not use ProjectUtils.getInformation() it does project icon annotation which is expensive\n+                        this.ci = ci;\n+                        exec.run();\n+                    } finally {\n+                        this.root = null;\n+                        this.projectInfo = null;\n+                        this.ci = null;\n                     }\n-                    rootUrls.add(root.toURL());\n                 }\n \n-                if (LOGGER.isLoggable(Level.FINE)) {\n-                    LOGGER.log(Level.FINE, \"Querying following roots:\"); //NOI18N\n-                    for (URL url : rootUrls) {\n-                        LOGGER.log(Level.FINE, \"  {0}\", url); //NOI18N\n+                @Override\n+                public void handleResult(ElementHandle<TypeElement> owner, String ident, boolean caseSensitive) {\n+                    final AsyncJavaSymbolDescriptor d = new AsyncJavaSymbolDescriptor(\n+                            projectInfo,\n+                            root,\n+                            ci,\n+                            owner,\n+                            ident,\n+                            caseSensitive);\n+                    result.addResult(d);\n+                    if (cache != null) {\n+                        cache.offer(d);\n                     }\n-                    LOGGER.log(Level.FINE, \"-------------------------\"); //NOI18N\n                 }\n-                //Perform all queries in single op\n-                IndexManager.priorityAccess(new IndexManager.Action<Void>() {\n-                    @Override\n-                    public Void run() throws IOException, InterruptedException {\n-                        for (URL url : rootUrls) {\n-                            if (canceled) {\n-                                return null;\n-                            }\n-                            final FileObject root = URLMapper.findFileObject(url);\n-                            if (root == null) {\n-                                continue;\n-                            }\n-\n-                            final Project project = FileOwnerQuery.getOwner(root);\n-                            final ProjectInformation projectInfo = project == null ?\n-                                    null :\n-                                    project.getLookup().lookup(ProjectInformation.class);   //Intentionally does not use ProjectUtils.getInformation() it does project icon annotation which is expensive\n-                            final ClassIndexImpl impl = manager.getUsagesQuery(root.toURL(), true);\n-                            if (impl != null) {\n+            }, true, canceled);\n+        } finally {\n+            clearCancel();\n+        }\n+    }\n+\n+    public static void doComputeSymbols(SearchType st, String textToSearch, ResultHandler handler, boolean async, AtomicBoolean canceled) {\n+        String prefix = null;\n+        final int dotIndex = textToSearch.lastIndexOf('.'); //NOI18N\n+        if (dotIndex > 0 && dotIndex != textToSearch.length()-1) {\n+            prefix = textToSearch.substring(0, dotIndex);\n+            textToSearch = textToSearch.substring(dotIndex+1);\n+        }\n+        final String textToHighLight = textToSearch;\n+        ClassIndex.NameKind _kind;\n+        boolean _caseSensitive;\n+        switch (st) {\n+            case PREFIX:\n+                _kind = ClassIndex.NameKind.PREFIX;\n+                _caseSensitive = true;\n+                break;\n+            case REGEXP:\n+                _kind = ClassIndex.NameKind.REGEXP;\n+                textToSearch = NameMatcherFactory.wildcardsToRegexp(\n+                        removeNonJavaChars(textToSearch),\n+                        true);\n+                _caseSensitive = true;\n+                break;\n+            case CAMEL_CASE:\n+                _kind = ClassIndex.NameKind.CAMEL_CASE;\n+                _caseSensitive = true;\n+                break;\n+            case CASE_INSENSITIVE_CAMEL_CASE:\n+                _kind = ClassIndex.NameKind.CAMEL_CASE_INSENSITIVE;\n+                _caseSensitive = false;\n+                break;\n+            case EXACT_NAME:\n+                _kind = ClassIndex.NameKind.SIMPLE_NAME;\n+                _caseSensitive = true;\n+                break;\n+            case CASE_INSENSITIVE_PREFIX:\n+                _kind = ClassIndex.NameKind.CASE_INSENSITIVE_PREFIX;\n+                _caseSensitive = false;\n+                break;\n+            case CASE_INSENSITIVE_EXACT_NAME:\n+                _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n+                _caseSensitive = false;\n+                break;\n+            case CASE_INSENSITIVE_REGEXP:\n+                _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n+                textToSearch = NameMatcherFactory.wildcardsToRegexp(\n+                        removeNonJavaChars(textToSearch),\n+                        true);\n+                _caseSensitive = false;\n+                break;\n+            default:\n+                throw new IllegalArgumentException();\n+        }\n+        final String ident = textToSearch;\n+        final ClassIndex.NameKind kind = _kind;\n+        final boolean caseSensitive = _caseSensitive;\n+        final Pair<NameMatcher,Boolean> restriction;\n+        if (prefix != null) {\n+            restriction = compileName(prefix,caseSensitive);\n+            handler.setHighlightText(textToHighLight);\n+        } else {\n+            restriction = null;\n+        }\n+        try {\n+            final ClassIndexManager manager = ClassIndexManager.getDefault();\n+\n+            Collection<FileObject> roots = QuerySupport.findRoots(\n+                    (Project)null,\n+                    Collections.singleton(ClassPath.SOURCE),\n+                    Collections.<String>emptySet(),\n+                    Collections.<String>emptySet());\n+\n+            final Set<URL> rootUrls = new HashSet<>();\n+            for(FileObject root : roots) {\n+                if (canceled.get()) {\n+                    return;\n+                }\n+                rootUrls.add(root.toURL());\n+            }\n+\n+            if (LOGGER.isLoggable(Level.FINE)) {\n+                LOGGER.log(Level.FINE, \"Querying following roots:\"); //NOI18N\n+                for (URL url : rootUrls) {\n+                    LOGGER.log(Level.FINE, \"  {0}\", url); //NOI18N\n+                }\n+                LOGGER.log(Level.FINE, \"-------------------------\"); //NOI18N\n+            }\n+            //Perform all queries in single op\n+            IndexManager.priorityAccess(new IndexManager.Action<Void>() {\n+                @Override\n+                public Void run() throws IOException, InterruptedException {\n+                    for (URL url : rootUrls) {\n+                        if (canceled.get()) {\n+                            return null;\n+                        }\n+                        final FileObject root = URLMapper.findFileObject(url);\n+                        if (root == null) {\n+                            continue;\n+                        }\n+\n+                        final ClassIndexImpl impl = manager.getUsagesQuery(root.toURL(), true);\n+                        if (impl != null) {\n+                            handler.runRoot(root, impl, () -> {\n                                 final Map<ElementHandle<TypeElement>,Set<String>> r = new HashMap<>();\n                                 impl.getDeclaredElements(ident, kind, DocumentUtil.typeElementConvertor(),r);\n                                 if (!r.isEmpty()) {\n                                     for (final Map.Entry<ElementHandle<TypeElement>,Set<String>> p : r.entrySet()) {\n                                         final ElementHandle<TypeElement> owner = p.getKey();\n                                         for (String symbol : p.getValue()) {\n                                             if (matchesRestrictions(owner.getQualifiedName(), symbol, restriction, caseSensitive)) {\n-                                                final AsyncJavaSymbolDescriptor d = new AsyncJavaSymbolDescriptor(\n-                                                        projectInfo,\n-                                                        root,\n-                                                        impl,\n-                                                        owner,\n-                                                        symbol,\n-                                                        caseSensitive);\n-                                                result.addResult(d);\n-                                                if (cache != null) {\n-                                                    cache.offer(d);\n-                                                }\n+                                                handler.handleResult(owner, symbol, caseSensitive);\n                                             }\n                                         }\n                                     }\n                                 }\n-                            }\n+                            });\n                         }\n-                        return null;\n                     }\n-                });\n-            } catch (IOException ioe) {\n-                Exceptions.printStackTrace(ioe);\n-            }\n-            catch (InterruptedException ie) {\n-                return;\n-            }\n-        } finally {\n-            clearCancel();\n+                    return null;\n+                }\n+            });\n+        } catch (IOException ioe) {\n+            Exceptions.printStackTrace(ioe);\n+        }\n+        catch (InterruptedException ie) {\n+            return;", "originalCommit": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNTAwNw==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475135007", "bodyText": "Jackpot:\nwarning: Field prj2Server can be final", "author": "jlahoda-jackpot", "createdAt": "2020-08-22T20:22:14Z", "path": "cpplite/cpplite.editor/src/org/netbeans/modules/cpplite/editor/lsp/LanguageServerImpl.java", "diffHunk": "@@ -64,9 +64,10 @@\n })\n public class LanguageServerImpl implements LanguageServerProvider {\n \n+    private static final boolean DEBUG = Boolean.getBoolean(\"cpplite.lsp.debug\");\n     private static final Logger LOG = Logger.getLogger(LanguageServerImpl.class.getName());\n \n-    private Map<Project, LanguageServerDescription> prj2Server = new HashMap<>();\n+    private static Map<Project, LanguageServerDescription> prj2Server = new HashMap<>();", "originalCommit": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNTAwOQ==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475135009", "bodyText": "Jackpot:\nwarning: Variable requiresCustomFiltering is never read", "author": "jlahoda-jackpot", "createdAt": "2020-08-22T20:22:16Z", "path": "ide/jumpto/src/org/netbeans/spi/jumpto/symbol/SymbolProvider.java", "diffHunk": "@@ -198,6 +198,7 @@ public void setSymbolProvider(SymbolDescriptor desc, SymbolProvider provider) {\n         private boolean dirty;\n         private boolean highlightTextAlreadySet;\n         private int retry;\n+        private boolean requiresCustomFiltering;", "originalCommit": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE3ODEyOQ==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r489178129", "bodyText": "Oops. Should be fixed now.", "author": "jlahoda", "createdAt": "2020-09-16T05:49:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNTAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNTAxMw==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475135013", "bodyText": "Jackpot:\nwarning: Add @OverRide Annotation", "author": "jlahoda-jackpot", "createdAt": "2020-08-22T20:22:19Z", "path": "ide/lsp.client/src/org/netbeans/modules/lsp/client/bindings/TypeProviderImpl.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.lsp.client.bindings;\n+\n+import java.util.EnumSet;\n+import java.util.Set;\n+import javax.swing.Icon;\n+import org.eclipse.lsp4j.SymbolInformation;\n+import org.eclipse.lsp4j.SymbolKind;\n+import org.netbeans.spi.jumpto.type.TypeDescriptor;\n+import org.netbeans.spi.jumpto.type.TypeProvider;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle.Messages;\n+import org.openide.util.lookup.ServiceProvider;\n+\n+/**\n+ *\n+ * @author lahvac\n+ */\n+@ServiceProvider(service=TypeProvider.class)\n+public class TypeProviderImpl extends BaseSymbolProvider implements TypeProvider {\n+\n+    private static final Set<SymbolKind> TYPE_KINDS = EnumSet.of(\n+            SymbolKind.Class, SymbolKind.Enum, SymbolKind.Interface,\n+            SymbolKind.Struct\n+    );\n+\n+    @Override\n+    @Messages(\"DN_TypeProviderImpl=Language Server Type Provider\")\n+    public String getDisplayName() {\n+        return Bundle.DN_TypeProviderImpl();\n+    }\n+\n+    @Override\n+    public void computeTypeNames(Context context, Result result) {\n+        computeSymbolNames(context.getSearchType(),\n+                           context.getText(),\n+                           (info, simpleName) -> {\n+                               if (TYPE_KINDS.contains(info.getKind())) {\n+                                   result.addResult(new TypeDescriptorImpl(info, simpleName));\n+                               }\n+                           });\n+    }\n+\n+    public static class TypeDescriptorImpl extends TypeDescriptor implements BaseSymbolDescriptor {\n+\n+        private final SymbolInformation info;\n+        private final String simpleName;\n+\n+        public TypeDescriptorImpl(SymbolInformation info, String simpleName) {\n+            this.info = info;\n+            this.simpleName = simpleName;\n+        }\n+\n+        public SymbolInformation getInfo() {", "originalCommit": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNTAzNQ==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475135035", "bodyText": "Jackpot:\nwarning: Can use functional operations", "author": "jlahoda-jackpot", "createdAt": "2020-08-22T20:22:33Z", "path": "ide/lsp.client/src/org/netbeans/modules/lsp/client/bindings/CustomIndexerImpl.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.lsp.client.bindings;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import org.netbeans.api.editor.mimelookup.MimeRegistration;\n+import org.netbeans.api.project.FileOwnerQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.modules.lsp.client.LSPBindings;\n+import org.netbeans.modules.parsing.spi.indexing.Context;\n+import org.netbeans.modules.parsing.spi.indexing.CustomIndexer;\n+import org.netbeans.modules.parsing.spi.indexing.CustomIndexerFactory;\n+import org.netbeans.modules.parsing.spi.indexing.Indexable;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.util.EditableProperties;\n+import org.openide.util.Exceptions;\n+import org.openide.util.RequestProcessor;\n+\n+/**\n+ *\n+ * @author lahvac\n+ */\n+public class CustomIndexerImpl extends CustomIndexer {\n+\n+    private static final RequestProcessor WORKER = new RequestProcessor(CustomIndexerImpl.class.getName(), 1, false, false);\n+\n+    @Override\n+    protected void index(Iterable<? extends Indexable> files, Context context) {\n+        handleStoredFiles(context, props -> {\n+            FileObject root = context.getRoot();\n+            for (Indexable i : files) {\n+                FileObject file = root.getFileObject(i.getRelativePath());\n+                if (file != null) {\n+                    props.setProperty(i.getRelativePath(), FileUtil.getMIMEType(file));\n+                }\n+            }\n+\n+            Set<String> mimeTypes = new HashSet<>(props.values());\n+            System.err.println(\"mimeTypes=\" + mimeTypes);\n+            Project prj = FileOwnerQuery.getOwner(root);\n+\n+            if (prj != null) {\n+                WORKER.post(() -> {\n+                    for (String mimeType : mimeTypes) {", "originalCommit": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE2NTkwNQ==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r489165905", "bodyText": "Could, but no.", "author": "jlahoda", "createdAt": "2020-09-16T05:08:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNTAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNTA0Nw==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475135047", "bodyText": "Jackpot:\nwarning: Add @OverRide Annotation", "author": "jlahoda-jackpot", "createdAt": "2020-08-22T20:22:36Z", "path": "ide/lsp.client/src/org/netbeans/modules/lsp/client/bindings/SymbolProviderImpl.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.lsp.client.bindings;\n+\n+import javax.swing.Icon;\n+import org.eclipse.lsp4j.SymbolInformation;\n+import org.netbeans.spi.jumpto.symbol.SymbolDescriptor;\n+import org.netbeans.spi.jumpto.symbol.SymbolProvider;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle.Messages;\n+import org.openide.util.lookup.ServiceProvider;\n+\n+/**\n+ *\n+ * @author lahvac\n+ */\n+@ServiceProvider(service=SymbolProvider.class)\n+public class SymbolProviderImpl extends BaseSymbolProvider implements SymbolProvider {\n+\n+    @Override\n+    @Messages(\"DN_getDisplayName=Language Server Symbol Provider\")\n+    public String getDisplayName() {\n+        return Bundle.DN_Symbols();\n+    }\n+\n+    @Override\n+    public void computeSymbolNames(Context context, Result result) {\n+        computeSymbolNames(context.getSearchType(), context.getText(), (info, simpleName) -> result.addResult(new SymbolDescriptorImpl(info, simpleName)));\n+    }\n+\n+    public static class SymbolDescriptorImpl extends SymbolDescriptor implements BaseSymbolDescriptor {\n+\n+        private final SymbolInformation info;\n+        private final String simpleName;\n+\n+        public SymbolDescriptorImpl(SymbolInformation info, String simpleName) {\n+            this.info = info;\n+            this.simpleName = simpleName;\n+        }\n+\n+        public SymbolInformation getInfo() {", "originalCommit": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c4da1314cf2b1d0fe35bfbac857436a6eadc40bc", "url": "https://github.com/apache/netbeans/commit/c4da1314cf2b1d0fe35bfbac857436a6eadc40bc", "message": "Fixing issues found by Jackpot.", "committedDate": "2020-09-16T05:48:47Z", "type": "commit"}, {"oid": "63465789eb24005fed6b624ebbc46e413caa5df4", "url": "https://github.com/apache/netbeans/commit/63465789eb24005fed6b624ebbc46e413caa5df4", "message": "Merge branch 'master' into workspace/symbol", "committedDate": "2020-09-16T20:05:24Z", "type": "commit"}, {"oid": "25b7c3ad8238775ba19f51dbd4174c9a2e4266a8", "url": "https://github.com/apache/netbeans/commit/25b7c3ad8238775ba19f51dbd4174c9a2e4266a8", "message": "Fixing problems in merge.", "committedDate": "2020-09-17T05:34:10Z", "type": "commit"}, {"oid": "9ce48689f69425a41589aa95b58a7d641cca16de", "url": "https://github.com/apache/netbeans/commit/9ce48689f69425a41589aa95b58a7d641cca16de", "message": "Merging master into workspace/symbol.", "committedDate": "2020-10-15T05:47:09Z", "type": "commit"}, {"oid": "48f32eb7d79074465559e5a4ce016a486c98c113", "url": "https://github.com/apache/netbeans/commit/48f32eb7d79074465559e5a4ce016a486c98c113", "message": "Fixing dependencies.", "committedDate": "2020-10-16T05:20:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMyOTM3NQ==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r511329375", "bodyText": "Using Logger would be more standard. See Logging in NetBeans document.", "author": "JaroslavTulach", "createdAt": "2020-10-24T06:52:05Z", "path": "cpplite/cpplite.editor/src/org/netbeans/modules/cpplite/editor/lsp/LanguageServerImpl.java", "diffHunk": "@@ -64,9 +64,10 @@\n })\n public class LanguageServerImpl implements LanguageServerProvider {\n \n+    private static final boolean DEBUG = Boolean.getBoolean(\"cpplite.lsp.debug\");", "originalCommit": "48f32eb7d79074465559e5a4ce016a486c98c113", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQyMjY1Nw==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r511422657", "bodyText": "The best we could do here is LOG.isLoggable(FINE) or alike instead of DEBUG - we need to print exactly what is in the streams (as often that shows some important piece of information), which, as far as I know, is not an ideal usecase for Loggers. (To use Loggers, we would need to send the information to the Logger in \"batches\", e.g. by lines, but that is often troublesome with this protocol.)", "author": "jlahoda", "createdAt": "2020-10-24T12:12:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMyOTM3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQzMzc5Ng==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r511433796", "bodyText": "LOG.isLoggable(FINE) would be more standard - at least it would be known how to configure it. If you insist on the property, document it in arch.xml as <api group=\"systemproperty\"/>.", "author": "JaroslavTulach", "createdAt": "2020-10-24T12:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMyOTM3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUwNTM5Mg==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r511505392", "bodyText": "Done.", "author": "jlahoda", "createdAt": "2020-10-24T19:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMyOTM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMyOTU2NA==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r511329564", "bodyText": "I see. This is the way to specify client capabilities! CCing @sdedic.", "author": "JaroslavTulach", "createdAt": "2020-10-24T06:54:32Z", "path": "ide/lsp.client/src/org/netbeans/modules/lsp/client/LSPBindings.java", "diffHunk": "@@ -232,6 +250,8 @@ private static InitializeResult initServer(Process p, LanguageServer server, Fil\n        wcc.setWorkspaceEdit(new WorkspaceEditCapabilities());\n        wcc.getWorkspaceEdit().setDocumentChanges(true);\n        wcc.getWorkspaceEdit().setResourceOperations(Arrays.asList(ResourceOperationKind.Create, ResourceOperationKind.Delete, ResourceOperationKind.Rename));\n+       SymbolCapabilities sc = new SymbolCapabilities(new SymbolKindCapabilities(Arrays.asList(SymbolKind.values())));\n+       wcc.setSymbol(sc);\n        initParams.setCapabilities(new ClientCapabilities(wcc, tdcc, null));", "originalCommit": "48f32eb7d79074465559e5a4ce016a486c98c113", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkwMTc3Ng==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r511901776", "bodyText": "The client capabilities should (?) be used for the standard ones - https://microsoft.github.io/language-server-protocol/specification except the experimental field, which is not well documented: could be a bag of capability objects or just the capability properties (?)\nI borrowed the implementation from here: https://github.com/eclipse/lemminx/blob/master/org.eclipse.lemminx/src/main/java/org/eclipse/lemminx/settings/capabilities/InitializationOptionsExtendedClientCapabilities.java\nbut it can be re-coded to read a bag in clientCapabiltiies.experimetnal, if it is the better way. @lahodaj  ?", "author": "sdedic", "createdAt": "2020-10-26T11:49:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMyOTU2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQzNjQ2Mw==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r512436463", "bodyText": "Not sure if that's better, but when I was experimenting with the semantic highlighting, it seemed there is a way to extend the protocol mostly transparently:\n-when sending data, just create a subclass of the class you want to send, and add annotated getters for the additional data you want to create\n-when receiving data, the main Gson instance need to create the extended subclass. One way I've found that could be used is to inject a different Gson while creating the LSPLauncher:\nLauncher<LanguageServer> launcher = LSPLauncher.createClientLauncher(lci, in, out);\n=>\n                                                       Launcher<LanguageServer> launcher = new LSPLauncher.Builder<LanguageServer>()\n                                                                                                          .setLocalService(lci)\n                                                                                                          .setRemoteInterface(LanguageServer.class)\n                                                                                                          .setInput(in)\n                                                                                                          .setOutput(out)\n                                                                                                          .configureGson(gson -> {\n                                                           gson.registerTypeAdapterFactory(new TypeAdapterFactory() {\n                                                               @Override\n                                                               public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> tt) {\n                                                                   if (tt.getRawType() == ServerCapabilities.class) {\n                                                                       return new TypeAdapter<T>() {\n                                                                           @Override\n                                                                           public void write(JsonWriter writer, T t) throws IOException {\n                                                                               throw new UnsupportedOperationException(\"Not supported.\");\n                                                                           }\n\n                                                                           @Override\n                                                                           public T read(JsonReader reader) throws IOException {\n                                                                               return gson.fromJson(reader, NBServerCapabilities.class);\n                                                                           }\n                                                                       };\n                                                                   }\n                                                                   return null;\n                                                               }\n                                                           });\n                                                       }).create();\n\n-to call additional methods/invocation points, use (I was only trying this on the client side so far):\nServiceEndpoints.toServiceObject(launcher.getRemoteEndpoint(), SemanticService.class)\n\nwhere:\n    public interface SemanticService {\n        @JsonRequest(\"textDocument/semanticTokens/full\")\n        public CompletableFuture<JsonObject> semanticTokensFull(SemanticTokensParams params);\n    }\n\nThis seemed to more or less work, but I didn't finish this work yet, so there may be a problem lurking somewhere.", "author": "jlahoda", "createdAt": "2020-10-27T06:07:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMyOTU2NA=="}], "type": "inlineReview"}, {"oid": "8db982b4378a52e2eef9a1d6ded6ea30f6106feb", "url": "https://github.com/apache/netbeans/commit/8db982b4378a52e2eef9a1d6ded6ea30f6106feb", "message": "Merging master into workspace/symbol.", "committedDate": "2020-10-24T12:00:38Z", "type": "commit"}, {"oid": "bc3b774488639391dabb8eb3eccbbcba92e18ed1", "url": "https://github.com/apache/netbeans/commit/bc3b774488639391dabb8eb3eccbbcba92e18ed1", "message": "Incrementing spec versions, as suggested.", "committedDate": "2020-10-24T12:06:15Z", "type": "commit"}, {"oid": "903433f01b1578cde184f6ea85f3c651e42b7e5f", "url": "https://github.com/apache/netbeans/commit/903433f01b1578cde184f6ea85f3c651e42b7e5f", "message": "Using Loggers instead of a system property.", "committedDate": "2020-10-24T19:17:34Z", "type": "commit"}, {"oid": "46b35977d414ccc8ef00a9261c84d88f0bdcc0be", "url": "https://github.com/apache/netbeans/commit/46b35977d414ccc8ef00a9261c84d88f0bdcc0be", "message": "Merging master into workspace/symbol", "committedDate": "2020-11-17T07:04:05Z", "type": "commit"}, {"oid": "d5f6e0b2bd161ead5a40381c9db28b415eb361d6", "url": "https://github.com/apache/netbeans/commit/d5f6e0b2bd161ead5a40381c9db28b415eb361d6", "message": "Cleanup.", "committedDate": "2020-11-17T07:05:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ0MDgzMw==", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r537440833", "bodyText": "@jlahoda We get this in an output window when we run a module.  What is this for?\nmimeTypes=[text/xml, text/x-properties, text/plain, text/x-diff, content/unknown, text/x-php5]\nmimeTypes=[text/xml, text/x-properties, text/plain, text/x-diff, content/unknown, text/x-php5]\nmimeTypes=[text/xml, text/x-properties, text/plain, text/x-diff, content/unknown, text/x-php5]\nmimeTypes=[text/xml, text/x-properties, text/plain, text/x-diff, content/unknown, text/x-php5]\nmimeTypes=[text/xml, text/x-properties, text/plain, text/x-diff, content/unknown, text/x-php5]\nmimeTypes=[text/xml, text/x-properties, text/plain, text/x-diff, content/unknown, text/x-php5]\nmimeTypes=[text/xml, text/x-properties, text/plain, text/x-diff, content/unknown, text/x-php5]\nINFO [org.netbeans.modules.bugtracking.BugtrackingManager]: Loading stored repositories took 47 millis.\nmimeTypes=[text/xml, text/x-properties, text/plain, text/x-diff, content/unknown, text/x-php5]\nmimeTypes=[text/xml, text/x-properties, text/plain, text/x-diff, content/unknown, text/x-php5]\nmimeTypes=[text/xml, text/x-properties, text/plain, text/x-diff, content/unknown, text/x-php5]\nmimeTypes=[text/xml, text/x-properties, text/plain, text/x-diff, content/unknown, text/x-php5]", "author": "junichi11", "createdAt": "2020-12-07T11:42:17Z", "path": "ide/lsp.client/src/org/netbeans/modules/lsp/client/bindings/CustomIndexerImpl.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.lsp.client.bindings;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import org.netbeans.api.editor.mimelookup.MimeRegistration;\n+import org.netbeans.api.project.FileOwnerQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.modules.lsp.client.LSPBindings;\n+import org.netbeans.modules.parsing.spi.indexing.Context;\n+import org.netbeans.modules.parsing.spi.indexing.CustomIndexer;\n+import org.netbeans.modules.parsing.spi.indexing.CustomIndexerFactory;\n+import org.netbeans.modules.parsing.spi.indexing.Indexable;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.util.EditableProperties;\n+import org.openide.util.Exceptions;\n+import org.openide.util.RequestProcessor;\n+\n+/**\n+ *\n+ * @author lahvac\n+ */\n+public class CustomIndexerImpl extends CustomIndexer {\n+\n+    private static final RequestProcessor WORKER = new RequestProcessor(CustomIndexerImpl.class.getName(), 1, false, false);\n+\n+    @Override\n+    protected void index(Iterable<? extends Indexable> files, Context context) {\n+        handleStoredFiles(context, props -> {\n+            FileObject root = context.getRoot();\n+            for (Indexable i : files) {\n+                FileObject file = root.getFileObject(i.getRelativePath());\n+                if (file != null) {\n+                    props.setProperty(i.getRelativePath(), FileUtil.getMIMEType(file));\n+                }\n+            }\n+\n+            Set<String> mimeTypes = new HashSet<>(props.values());\n+            System.err.println(\"mimeTypes=\" + mimeTypes);", "originalCommit": "d5f6e0b2bd161ead5a40381c9db28b415eb361d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}