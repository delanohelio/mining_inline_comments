{"pr_number": 2587, "pr_title": "Existing CodeGenerators exposed as CodeActions via LSP.", "pr_createdAt": "2020-12-11T16:30:36Z", "pr_url": "https://github.com/apache/netbeans/pull/2587", "timeline": [{"oid": "c321862f02ad666313ba35433539150a962c5ddf", "url": "https://github.com/apache/netbeans/commit/c321862f02ad666313ba35433539150a962c5ddf", "message": "Exisitng CodeGenerators exposed as CodeActions via LSP.", "committedDate": "2020-12-11T14:15:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjExMTY4Mw==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r542111683", "bodyText": "Great. This is the UI interaction I was dreaming of.", "author": "JaroslavTulach", "createdAt": "2020-12-14T04:56:35Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/NbCodeLanguageClient.java", "diffHunk": "@@ -40,7 +43,25 @@\n      */\n     @JsonNotification(\"window/showStatusBarMessage\")\n     public void showStatusBarMessage(@NonNull ShowStatusMessageParams params);\n-    \n+\n+    /**\n+     * Shows a selection list allowing multiple selections.\n+     *\n+     * @param params input parameters\n+     * @return selected items\n+     */\n+    @JsonRequest(\"window/showQuickPick\")\n+    public CompletableFuture<List<QuickPickItem>> showQuickPick(@NonNull ShowQuickPickParams params);", "originalCommit": "c321862f02ad666313ba35433539150a962c5ddf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjExNDEwOQ==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r542114109", "bodyText": "I guess this is the place that instructs VSCode to show the code generator actions.", "author": "JaroslavTulach", "createdAt": "2020-12-14T05:05:29Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/TextDocumentServiceImpl.java", "diffHunk": "@@ -1063,20 +1044,10 @@ protected void performRewrite(JavaFix.TransformationContext ctx) throws Exceptio\n         try {\n             js.runUserActionTask(cc -> {\n                 cc.toPhase(JavaSource.Phase.RESOLVED);\n-\n-                Pair<Set<VariableElement>, Set<VariableElement>> pair = GetterSetterGenerator.findMissingGettersSetters(cc, params.getRange(), false);\n-                boolean missingGetters = !pair.first().isEmpty();\n-                boolean missingSetters = !pair.second().isEmpty();\n-                String uri = toUri(cc.getFileObject());\n-\n-                if (missingGetters) {\n-                    result.add(Either.forRight(createCodeGeneratorAction(Bundle.DN_GenerateGetters(), Server.GENERATE_GETTERS, uri, params.getRange())));\n-                }\n-                if (missingSetters) {\n-                    result.add(Either.forRight(createCodeGeneratorAction(Bundle.DN_GenerateSetters(), Server.GENERATE_SETTERS, uri, params.getRange())));\n-                }\n-                if (missingGetters && missingSetters) {\n-                    result.add(Either.forRight(createCodeGeneratorAction(Bundle.DN_GenerateGettersSetters(), Server.GENERATE_GETTERS_SETTERS, uri, params.getRange())));\n+                for (CodeGenerator codeGenerator : Server.CODE_GENERATORS) {", "originalCommit": "c321862f02ad666313ba35433539150a962c5ddf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE3ODY4MA==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r542178680", "bodyText": "Yes.", "author": "dbalek", "createdAt": "2020-12-14T07:58:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjExNDEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjExNTY4Mw==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r542115683", "bodyText": "Using jar:file URLs is quite frequent and it would ge good to get it working more properly. There is a URLMapper in the file system API where one can request EXTERNAL URL. Wouldn't it be better to get it working for jar:file?", "author": "JaroslavTulach", "createdAt": "2020-12-14T05:10:47Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/CodeGenerator.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.sun.source.tree.LineMap;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.TypeParameterElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.ArrayType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.Command;\n+import org.eclipse.lsp4j.Position;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementHandle;\n+import org.netbeans.modules.editor.java.Utilities;\n+import org.netbeans.modules.java.source.ElementHandleAccessor;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.filesystems.URLMapper;\n+import org.openide.modules.Places;\n+import org.openide.util.Exceptions;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public abstract class CodeGenerator {\n+\n+    public static final String CODE_GENERATOR_KIND = \"source.generate\";\n+    protected static final String ERROR = \"<error>\"; //NOI18N\n+\n+    public abstract List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params);\n+\n+    public abstract Set<String> getCommands();\n+\n+    public abstract CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments);\n+\n+    protected static int getOffset(CompilationInfo info, Position pos) {\n+        LineMap lm = info.getCompilationUnit().getLineMap();\n+        return (int) lm.getPosition(pos.getLine() + 1, pos.getCharacter() + 1);\n+    }\n+\n+    protected static CodeAction createCodeAction(String name, String kind, String command, Object... args) {\n+        CodeAction action = new CodeAction(name);\n+        action.setKind(kind);\n+        action.setCommand(new Command(name, command, Arrays.asList(args)));\n+        return action;\n+    }\n+\n+    protected static String toUri(FileObject file) {\n+        if (FileUtil.isArchiveArtifact(file)) {\n+            //VS code cannot open jar:file: URLs, workaround:", "originalCommit": "c321862f02ad666313ba35433539150a962c5ddf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE3NzU5NQ==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r542177595", "bodyText": "Do we really need to have code generators working for sources that come from jar files?", "author": "dbalek", "createdAt": "2020-12-14T07:56:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjExNTY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA2Mzc3Mw==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543063773", "bodyText": "I cannot answer your question Du\u0161ane. I am just pointing out that rather than converting jar:file: URLs manually, we'd rather use exiting API for that. If it is not working properly, we'd rather invest in fixing it.\nNow I get that this code has been introduced during #2530. I find the code strange, but it is not a blocker.", "author": "JaroslavTulach", "createdAt": "2020-12-15T05:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjExNTY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA5MjExNg==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543092116", "bodyText": "I think it is a little misleading to say the code was introduced in #2530 - the code is there for years, see:\n6452108\nAnyway, to the merit: I assume you mean URLMapper.NETWORK, not EXTERNAL. As far as I can tall, EXTERNAL is still jar:file:. Anyway, I just tried with NETWORK (again), and VS Code still seems to reject it, at least in my setup. firefox started next to VS Code can access the URL just fine. It might be just an issue with rejecting http (and preferring https), although I am not sure of that. From the protocol, it is also not clear to me what types of URLs LSP clients are obliged to accept.\nRegarding this particular code - wouldn't it be better to use Utils.toUri? That would keep this code on one place, so that when Jaroslav fixes it, it will be automatically fixed on all places?", "author": "jlahoda", "createdAt": "2020-12-15T06:57:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjExNTY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1MzI1MA==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543153250", "bodyText": "Using Utils.toUri(...) and Utils.fromUri(...) as suggested.", "author": "dbalek", "createdAt": "2020-12-15T08:47:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjExNTY4Mw=="}], "type": "inlineReview"}, {"oid": "4165983e6b010879475ed67961486fe3b278e364", "url": "https://github.com/apache/netbeans/commit/4165983e6b010879475ed67961486fe3b278e364", "message": "Using Utils.toUri() in CodeGenerators.", "committedDate": "2020-12-15T08:44:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4ODc2OQ==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543188769", "bodyText": "Nitpick: isn't fieldType.getKind() == TypeKind.ERROR better ?\nQuestin (self-edu): what type field types are not primitive+array or DECLARED ?", "author": "sdedic", "createdAt": "2020-12-15T09:38:12Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/DelegateMethodGenerator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.tree.Scope;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.Trees;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementUtilities;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class DelegateMethodGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_DELEGATE_METHOD =  \"java.generate.delegateMethod\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_DELEGATE_METHOD);\n+    private final Gson gson = new Gson();\n+\n+    DelegateMethodGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateDelegateMethod=Generate Delegate Method...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass()) {\n+            return Collections.emptyList();\n+        }\n+        Elements elements = info.getElements();\n+        Trees trees = info.getTrees();\n+        Scope scope = trees.getScope(tp);\n+        List<QuickPickItem> fields = new ArrayList<>();\n+        TypeElement cls;\n+        while (scope != null && (cls = scope.getEnclosingClass()) != null) {\n+            DeclaredType type = (DeclaredType) cls.asType();\n+            for (VariableElement field : ElementFilter.fieldsIn(elements.getAllMembers(cls))) {\n+                TypeMirror fieldType = field.asType();\n+                if (!ERROR.contentEquals(field.getSimpleName()) && !fieldType.getKind().isPrimitive() && fieldType.getKind() != TypeKind.ARRAY", "originalCommit": "4165983e6b010879475ed67961486fe3b278e364", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMzODM4Mw==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543338383", "bodyText": "ERROR.contentEquals(field.getSimpleName()) filters out fields, that are not syntactically correct (e.g. situation, when you start typing a new field declaration in the editor and you haven't typed the field name yet, just a field type...).\nAs a field type, DECLARED types different form self type are required.", "author": "dbalek", "createdAt": "2020-12-15T13:25:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4ODc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4ODgyMQ==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543188821", "bodyText": "Q: shouldn't the server log a message, if client sends malformed msg (too few arguments) ?", "author": "sdedic", "createdAt": "2020-12-15T09:38:17Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/DelegateMethodGenerator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.tree.Scope;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.Trees;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementUtilities;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class DelegateMethodGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_DELEGATE_METHOD =  \"java.generate.delegateMethod\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_DELEGATE_METHOD);\n+    private final Gson gson = new Gson();\n+\n+    DelegateMethodGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateDelegateMethod=Generate Delegate Method...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass()) {\n+            return Collections.emptyList();\n+        }\n+        Elements elements = info.getElements();\n+        Trees trees = info.getTrees();\n+        Scope scope = trees.getScope(tp);\n+        List<QuickPickItem> fields = new ArrayList<>();\n+        TypeElement cls;\n+        while (scope != null && (cls = scope.getEnclosingClass()) != null) {\n+            DeclaredType type = (DeclaredType) cls.asType();\n+            for (VariableElement field : ElementFilter.fieldsIn(elements.getAllMembers(cls))) {\n+                TypeMirror fieldType = field.asType();\n+                if (!ERROR.contentEquals(field.getSimpleName()) && !fieldType.getKind().isPrimitive() && fieldType.getKind() != TypeKind.ARRAY\n+                        && (fieldType.getKind() != TypeKind.DECLARED || ((DeclaredType)fieldType).asElement() != cls) && trees.isAccessible(scope, field, type)) {\n+                    QuickPickItem item = new QuickPickItem(createLabel(info, field));\n+                    item.setUserData(new ElementData(field));\n+                    fields.add(item);\n+                }\n+            }\n+            scope = scope.getEnclosingScope();\n+        }\n+        if (fields.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+        String uri = Utils.toUri(info.getFileObject());\n+        QuickPickItem typeItem = new QuickPickItem(createLabel(info, typeElement));\n+        typeItem.setUserData(new ElementData(typeElement));\n+        return Collections.singletonList(createCodeAction(Bundle.DN_GenerateDelegateMethod(), CODE_GENERATOR_KIND, GENERATE_DELEGATE_METHOD, uri, offset, typeItem, fields));\n+    }\n+\n+    @Override\n+    public Set<String> getCommands() {\n+        return commands;\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_SelectDelegateMethodField=Select target field to generate delegates for\",\n+    })\n+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {\n+        if (arguments.size() > 3) {", "originalCommit": "4165983e6b010879475ed67961486fe3b278e364", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM0MDk1MQ==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543340951", "bodyText": "Client sends back the command and arguments received from the server as a part of CodeAction message. But OK, server should log a message if something went terribly bad.", "author": "dbalek", "createdAt": "2020-12-15T13:29:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4ODgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4ODg0NQ==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543188845", "bodyText": "Check for null.", "author": "sdedic", "createdAt": "2020-12-15T09:38:20Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/DelegateMethodGenerator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.tree.Scope;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.Trees;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementUtilities;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class DelegateMethodGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_DELEGATE_METHOD =  \"java.generate.delegateMethod\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_DELEGATE_METHOD);\n+    private final Gson gson = new Gson();\n+\n+    DelegateMethodGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateDelegateMethod=Generate Delegate Method...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass()) {\n+            return Collections.emptyList();\n+        }\n+        Elements elements = info.getElements();\n+        Trees trees = info.getTrees();\n+        Scope scope = trees.getScope(tp);\n+        List<QuickPickItem> fields = new ArrayList<>();\n+        TypeElement cls;\n+        while (scope != null && (cls = scope.getEnclosingClass()) != null) {\n+            DeclaredType type = (DeclaredType) cls.asType();\n+            for (VariableElement field : ElementFilter.fieldsIn(elements.getAllMembers(cls))) {\n+                TypeMirror fieldType = field.asType();\n+                if (!ERROR.contentEquals(field.getSimpleName()) && !fieldType.getKind().isPrimitive() && fieldType.getKind() != TypeKind.ARRAY\n+                        && (fieldType.getKind() != TypeKind.DECLARED || ((DeclaredType)fieldType).asElement() != cls) && trees.isAccessible(scope, field, type)) {\n+                    QuickPickItem item = new QuickPickItem(createLabel(info, field));\n+                    item.setUserData(new ElementData(field));\n+                    fields.add(item);\n+                }\n+            }\n+            scope = scope.getEnclosingScope();\n+        }\n+        if (fields.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+        String uri = Utils.toUri(info.getFileObject());\n+        QuickPickItem typeItem = new QuickPickItem(createLabel(info, typeElement));\n+        typeItem.setUserData(new ElementData(typeElement));\n+        return Collections.singletonList(createCodeAction(Bundle.DN_GenerateDelegateMethod(), CODE_GENERATOR_KIND, GENERATE_DELEGATE_METHOD, uri, offset, typeItem, fields));\n+    }\n+\n+    @Override\n+    public Set<String> getCommands() {\n+        return commands;\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_SelectDelegateMethodField=Select target field to generate delegates for\",\n+    })\n+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {\n+        if (arguments.size() > 3) {\n+            String uri = gson.fromJson(gson.toJson(arguments.get(0)), String.class);\n+            int offset = gson.fromJson(gson.toJson(arguments.get(1)), Integer.class);\n+            QuickPickItem type = gson.fromJson(gson.toJson(arguments.get(2)), QuickPickItem.class);\n+            List<QuickPickItem> fields = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(3)), QuickPickItem[].class));\n+            if (fields.size() == 1) {\n+                selectMethods(client, uri, offset, type, fields.get(0));\n+            } else {\n+                client.showQuickPick(new ShowQuickPickParams(Bundle.DN_SelectDelegateMethodField(), false, fields)).thenAccept(selected -> {\n+                    if (selected != null && !selected.isEmpty()) {\n+                        selectMethods(client, uri, offset, type, selected.get(0));\n+                    }\n+                });\n+            }\n+        }\n+        return CompletableFuture.completedFuture(true);\n+    }\n+\n+    @NbBundle.Messages({\n+        \"DN_SelectDelegateMethods=Select methods to generate delegates for\",\n+    })\n+    private void selectMethods(NbCodeLanguageClient client, String uri, int offset, QuickPickItem type, QuickPickItem selectedField) {\n+        try {\n+            FileObject file = Utils.fromUri(uri);\n+            JavaSource js = JavaSource.forFileObject(file);\n+            js.runUserActionTask(info -> {", "originalCommit": "4165983e6b010879475ed67961486fe3b278e364", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM1NjQwNw==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543356407", "bodyText": "Fixed.", "author": "dbalek", "createdAt": "2020-12-15T13:50:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4ODg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4ODg5NQ==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543188895", "bodyText": "Check origin / field for != null", "author": "sdedic", "createdAt": "2020-12-15T09:38:25Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/DelegateMethodGenerator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.tree.Scope;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.Trees;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementUtilities;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class DelegateMethodGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_DELEGATE_METHOD =  \"java.generate.delegateMethod\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_DELEGATE_METHOD);\n+    private final Gson gson = new Gson();\n+\n+    DelegateMethodGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateDelegateMethod=Generate Delegate Method...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass()) {\n+            return Collections.emptyList();\n+        }\n+        Elements elements = info.getElements();\n+        Trees trees = info.getTrees();\n+        Scope scope = trees.getScope(tp);\n+        List<QuickPickItem> fields = new ArrayList<>();\n+        TypeElement cls;\n+        while (scope != null && (cls = scope.getEnclosingClass()) != null) {\n+            DeclaredType type = (DeclaredType) cls.asType();\n+            for (VariableElement field : ElementFilter.fieldsIn(elements.getAllMembers(cls))) {\n+                TypeMirror fieldType = field.asType();\n+                if (!ERROR.contentEquals(field.getSimpleName()) && !fieldType.getKind().isPrimitive() && fieldType.getKind() != TypeKind.ARRAY\n+                        && (fieldType.getKind() != TypeKind.DECLARED || ((DeclaredType)fieldType).asElement() != cls) && trees.isAccessible(scope, field, type)) {\n+                    QuickPickItem item = new QuickPickItem(createLabel(info, field));\n+                    item.setUserData(new ElementData(field));\n+                    fields.add(item);\n+                }\n+            }\n+            scope = scope.getEnclosingScope();\n+        }\n+        if (fields.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+        String uri = Utils.toUri(info.getFileObject());\n+        QuickPickItem typeItem = new QuickPickItem(createLabel(info, typeElement));\n+        typeItem.setUserData(new ElementData(typeElement));\n+        return Collections.singletonList(createCodeAction(Bundle.DN_GenerateDelegateMethod(), CODE_GENERATOR_KIND, GENERATE_DELEGATE_METHOD, uri, offset, typeItem, fields));\n+    }\n+\n+    @Override\n+    public Set<String> getCommands() {\n+        return commands;\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_SelectDelegateMethodField=Select target field to generate delegates for\",\n+    })\n+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {\n+        if (arguments.size() > 3) {\n+            String uri = gson.fromJson(gson.toJson(arguments.get(0)), String.class);\n+            int offset = gson.fromJson(gson.toJson(arguments.get(1)), Integer.class);\n+            QuickPickItem type = gson.fromJson(gson.toJson(arguments.get(2)), QuickPickItem.class);\n+            List<QuickPickItem> fields = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(3)), QuickPickItem[].class));\n+            if (fields.size() == 1) {\n+                selectMethods(client, uri, offset, type, fields.get(0));\n+            } else {\n+                client.showQuickPick(new ShowQuickPickParams(Bundle.DN_SelectDelegateMethodField(), false, fields)).thenAccept(selected -> {\n+                    if (selected != null && !selected.isEmpty()) {\n+                        selectMethods(client, uri, offset, type, selected.get(0));\n+                    }\n+                });\n+            }\n+        }\n+        return CompletableFuture.completedFuture(true);\n+    }\n+\n+    @NbBundle.Messages({\n+        \"DN_SelectDelegateMethods=Select methods to generate delegates for\",\n+    })\n+    private void selectMethods(NbCodeLanguageClient client, String uri, int offset, QuickPickItem type, QuickPickItem selectedField) {\n+        try {\n+            FileObject file = Utils.fromUri(uri);\n+            JavaSource js = JavaSource.forFileObject(file);\n+            js.runUserActionTask(info -> {\n+                info.toPhase(JavaSource.Phase.RESOLVED);\n+                TypeElement origin = (TypeElement) gson.fromJson(gson.toJson(type.getUserData()), ElementData.class).resolve(info);\n+                VariableElement field = (VariableElement) gson.fromJson(gson.toJson(selectedField.getUserData()), ElementData.class).resolve(info);\n+                final ElementUtilities eu = info.getElementUtilities();", "originalCommit": "4165983e6b010879475ed67961486fe3b278e364", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM3NTQ4Nw==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543375487", "bodyText": "Fixed.", "author": "dbalek", "createdAt": "2020-12-15T14:12:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4ODg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4ODk0Ng==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543188946", "bodyText": "Nitpick: add braces or indent :)", "author": "sdedic", "createdAt": "2020-12-15T09:38:29Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/DelegateMethodGenerator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.tree.Scope;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.Trees;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementUtilities;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class DelegateMethodGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_DELEGATE_METHOD =  \"java.generate.delegateMethod\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_DELEGATE_METHOD);\n+    private final Gson gson = new Gson();\n+\n+    DelegateMethodGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateDelegateMethod=Generate Delegate Method...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass()) {\n+            return Collections.emptyList();\n+        }\n+        Elements elements = info.getElements();\n+        Trees trees = info.getTrees();\n+        Scope scope = trees.getScope(tp);\n+        List<QuickPickItem> fields = new ArrayList<>();\n+        TypeElement cls;\n+        while (scope != null && (cls = scope.getEnclosingClass()) != null) {\n+            DeclaredType type = (DeclaredType) cls.asType();\n+            for (VariableElement field : ElementFilter.fieldsIn(elements.getAllMembers(cls))) {\n+                TypeMirror fieldType = field.asType();\n+                if (!ERROR.contentEquals(field.getSimpleName()) && !fieldType.getKind().isPrimitive() && fieldType.getKind() != TypeKind.ARRAY\n+                        && (fieldType.getKind() != TypeKind.DECLARED || ((DeclaredType)fieldType).asElement() != cls) && trees.isAccessible(scope, field, type)) {\n+                    QuickPickItem item = new QuickPickItem(createLabel(info, field));\n+                    item.setUserData(new ElementData(field));\n+                    fields.add(item);\n+                }\n+            }\n+            scope = scope.getEnclosingScope();\n+        }\n+        if (fields.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+        String uri = Utils.toUri(info.getFileObject());\n+        QuickPickItem typeItem = new QuickPickItem(createLabel(info, typeElement));\n+        typeItem.setUserData(new ElementData(typeElement));\n+        return Collections.singletonList(createCodeAction(Bundle.DN_GenerateDelegateMethod(), CODE_GENERATOR_KIND, GENERATE_DELEGATE_METHOD, uri, offset, typeItem, fields));\n+    }\n+\n+    @Override\n+    public Set<String> getCommands() {\n+        return commands;\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_SelectDelegateMethodField=Select target field to generate delegates for\",\n+    })\n+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {\n+        if (arguments.size() > 3) {\n+            String uri = gson.fromJson(gson.toJson(arguments.get(0)), String.class);\n+            int offset = gson.fromJson(gson.toJson(arguments.get(1)), Integer.class);\n+            QuickPickItem type = gson.fromJson(gson.toJson(arguments.get(2)), QuickPickItem.class);\n+            List<QuickPickItem> fields = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(3)), QuickPickItem[].class));\n+            if (fields.size() == 1) {\n+                selectMethods(client, uri, offset, type, fields.get(0));\n+            } else {\n+                client.showQuickPick(new ShowQuickPickParams(Bundle.DN_SelectDelegateMethodField(), false, fields)).thenAccept(selected -> {\n+                    if (selected != null && !selected.isEmpty()) {\n+                        selectMethods(client, uri, offset, type, selected.get(0));\n+                    }\n+                });\n+            }\n+        }\n+        return CompletableFuture.completedFuture(true);\n+    }\n+\n+    @NbBundle.Messages({\n+        \"DN_SelectDelegateMethods=Select methods to generate delegates for\",\n+    })\n+    private void selectMethods(NbCodeLanguageClient client, String uri, int offset, QuickPickItem type, QuickPickItem selectedField) {\n+        try {\n+            FileObject file = Utils.fromUri(uri);\n+            JavaSource js = JavaSource.forFileObject(file);\n+            js.runUserActionTask(info -> {\n+                info.toPhase(JavaSource.Phase.RESOLVED);\n+                TypeElement origin = (TypeElement) gson.fromJson(gson.toJson(type.getUserData()), ElementData.class).resolve(info);\n+                VariableElement field = (VariableElement) gson.fromJson(gson.toJson(selectedField.getUserData()), ElementData.class).resolve(info);\n+                final ElementUtilities eu = info.getElementUtilities();\n+                final Trees trees = info.getTrees();\n+                final Scope scope = info.getTreeUtilities().scopeFor(offset);\n+                ElementUtilities.ElementAcceptor acceptor = new ElementUtilities.ElementAcceptor() {\n+                    @Override\n+                    public boolean accept(Element e, TypeMirror type) {\n+                        if (e.getKind() == ElementKind.METHOD && trees.isAccessible(scope, e, (DeclaredType)type)) {\n+                            Element impl = eu.getImplementationOf((ExecutableElement)e, origin);\n+                            return impl == null || (!impl.getModifiers().contains(Modifier.FINAL) && impl.getEnclosingElement() != origin);\n+                        }\n+                        return false;\n+                    }\n+                };\n+                List<QuickPickItem> methods = new ArrayList<>();\n+                for (ExecutableElement method : ElementFilter.methodsIn(eu.getMembers(field.asType(), acceptor))) {\n+                    QuickPickItem item = new QuickPickItem(String.format(\"%s.%s\", field.getSimpleName().toString(), createLabel(info, method)));\n+                    item.setUserData(new ElementData(method));\n+                    methods.add(item);\n+                }\n+                client.showQuickPick(new ShowQuickPickParams(Bundle.DN_SelectDelegateMethods(), true, methods)).thenAccept(selected -> {\n+                    if (selected != null && !selected.isEmpty())", "originalCommit": "4165983e6b010879475ed67961486fe3b278e364", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM1NzkyNg==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543357926", "bodyText": "Fixed.", "author": "dbalek", "createdAt": "2020-12-15T13:52:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4ODk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4OTAwOQ==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543189009", "bodyText": "Consider if TextEdit + error handling for generate could be centralized for all CodeGenerators.", "author": "sdedic", "createdAt": "2020-12-15T09:38:33Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/DelegateMethodGenerator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.tree.Scope;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.Trees;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementUtilities;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class DelegateMethodGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_DELEGATE_METHOD =  \"java.generate.delegateMethod\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_DELEGATE_METHOD);\n+    private final Gson gson = new Gson();\n+\n+    DelegateMethodGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateDelegateMethod=Generate Delegate Method...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass()) {\n+            return Collections.emptyList();\n+        }\n+        Elements elements = info.getElements();\n+        Trees trees = info.getTrees();\n+        Scope scope = trees.getScope(tp);\n+        List<QuickPickItem> fields = new ArrayList<>();\n+        TypeElement cls;\n+        while (scope != null && (cls = scope.getEnclosingClass()) != null) {\n+            DeclaredType type = (DeclaredType) cls.asType();\n+            for (VariableElement field : ElementFilter.fieldsIn(elements.getAllMembers(cls))) {\n+                TypeMirror fieldType = field.asType();\n+                if (!ERROR.contentEquals(field.getSimpleName()) && !fieldType.getKind().isPrimitive() && fieldType.getKind() != TypeKind.ARRAY\n+                        && (fieldType.getKind() != TypeKind.DECLARED || ((DeclaredType)fieldType).asElement() != cls) && trees.isAccessible(scope, field, type)) {\n+                    QuickPickItem item = new QuickPickItem(createLabel(info, field));\n+                    item.setUserData(new ElementData(field));\n+                    fields.add(item);\n+                }\n+            }\n+            scope = scope.getEnclosingScope();\n+        }\n+        if (fields.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+        String uri = Utils.toUri(info.getFileObject());\n+        QuickPickItem typeItem = new QuickPickItem(createLabel(info, typeElement));\n+        typeItem.setUserData(new ElementData(typeElement));\n+        return Collections.singletonList(createCodeAction(Bundle.DN_GenerateDelegateMethod(), CODE_GENERATOR_KIND, GENERATE_DELEGATE_METHOD, uri, offset, typeItem, fields));\n+    }\n+\n+    @Override\n+    public Set<String> getCommands() {\n+        return commands;\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_SelectDelegateMethodField=Select target field to generate delegates for\",\n+    })\n+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {\n+        if (arguments.size() > 3) {\n+            String uri = gson.fromJson(gson.toJson(arguments.get(0)), String.class);\n+            int offset = gson.fromJson(gson.toJson(arguments.get(1)), Integer.class);\n+            QuickPickItem type = gson.fromJson(gson.toJson(arguments.get(2)), QuickPickItem.class);\n+            List<QuickPickItem> fields = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(3)), QuickPickItem[].class));\n+            if (fields.size() == 1) {\n+                selectMethods(client, uri, offset, type, fields.get(0));\n+            } else {\n+                client.showQuickPick(new ShowQuickPickParams(Bundle.DN_SelectDelegateMethodField(), false, fields)).thenAccept(selected -> {\n+                    if (selected != null && !selected.isEmpty()) {\n+                        selectMethods(client, uri, offset, type, selected.get(0));\n+                    }\n+                });\n+            }\n+        }\n+        return CompletableFuture.completedFuture(true);\n+    }\n+\n+    @NbBundle.Messages({\n+        \"DN_SelectDelegateMethods=Select methods to generate delegates for\",\n+    })\n+    private void selectMethods(NbCodeLanguageClient client, String uri, int offset, QuickPickItem type, QuickPickItem selectedField) {\n+        try {\n+            FileObject file = Utils.fromUri(uri);\n+            JavaSource js = JavaSource.forFileObject(file);\n+            js.runUserActionTask(info -> {\n+                info.toPhase(JavaSource.Phase.RESOLVED);\n+                TypeElement origin = (TypeElement) gson.fromJson(gson.toJson(type.getUserData()), ElementData.class).resolve(info);\n+                VariableElement field = (VariableElement) gson.fromJson(gson.toJson(selectedField.getUserData()), ElementData.class).resolve(info);\n+                final ElementUtilities eu = info.getElementUtilities();\n+                final Trees trees = info.getTrees();\n+                final Scope scope = info.getTreeUtilities().scopeFor(offset);\n+                ElementUtilities.ElementAcceptor acceptor = new ElementUtilities.ElementAcceptor() {\n+                    @Override\n+                    public boolean accept(Element e, TypeMirror type) {\n+                        if (e.getKind() == ElementKind.METHOD && trees.isAccessible(scope, e, (DeclaredType)type)) {\n+                            Element impl = eu.getImplementationOf((ExecutableElement)e, origin);\n+                            return impl == null || (!impl.getModifiers().contains(Modifier.FINAL) && impl.getEnclosingElement() != origin);\n+                        }\n+                        return false;\n+                    }\n+                };\n+                List<QuickPickItem> methods = new ArrayList<>();\n+                for (ExecutableElement method : ElementFilter.methodsIn(eu.getMembers(field.asType(), acceptor))) {\n+                    QuickPickItem item = new QuickPickItem(String.format(\"%s.%s\", field.getSimpleName().toString(), createLabel(info, method)));\n+                    item.setUserData(new ElementData(method));\n+                    methods.add(item);\n+                }\n+                client.showQuickPick(new ShowQuickPickParams(Bundle.DN_SelectDelegateMethods(), true, methods)).thenAccept(selected -> {\n+                    if (selected != null && !selected.isEmpty())\n+                    generate(client, uri, offset, selectedField, selected);\n+                });\n+            }, true);\n+        } catch (IOException | IllegalArgumentException ex) {\n+            client.logMessage(new MessageParams(MessageType.Error, ex.getLocalizedMessage()));\n+        }\n+    }\n+\n+    private void generate(NbCodeLanguageClient client, String uri, int offset, QuickPickItem selectedField, List<QuickPickItem> selectedMethods) {\n+        try {\n+            FileObject file = Utils.fromUri(uri);\n+            JavaSource js = JavaSource.forFileObject(file);\n+            List<TextEdit> edits = TextDocumentServiceImpl.modify2TextEdits(js, wc -> {\n+                wc.toPhase(JavaSource.Phase.RESOLVED);\n+                TreePath tp = wc.getTreeUtilities().pathFor(offset);\n+                tp = wc.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+                if (tp != null) {\n+                    VariableElement field = (VariableElement) gson.fromJson(gson.toJson(selectedField.getUserData()), ElementData.class).resolve(wc);\n+                    List<ExecutableElement> methods = selectedMethods.stream().map(item -> {\n+                        ElementData data = gson.fromJson(gson.toJson(item.getUserData()), ElementData.class);\n+                        return (ExecutableElement)data.resolve(wc);\n+                    }).collect(Collectors.toList());\n+                    org.netbeans.modules.java.editor.codegen.DelegateMethodGenerator.generateDelegatingMethods(wc, tp, field, methods, -1);\n+                }\n+            });\n+            client.applyEdit(new ApplyWorkspaceEditParams(new WorkspaceEdit(Collections.singletonMap(uri, edits))));", "originalCommit": "4165983e6b010879475ed67961486fe3b278e364", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4OTE1Nw==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543189157", "bodyText": "Nitpick: the TypeMirror may be erroneous (TypeKind.ERROR)", "author": "sdedic", "createdAt": "2020-12-15T09:38:47Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/CodeGenerator.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.sun.source.tree.LineMap;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.TypeParameterElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.ArrayType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.Command;\n+import org.eclipse.lsp4j.Position;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementHandle;\n+import org.netbeans.modules.editor.java.Utilities;\n+import org.netbeans.modules.java.source.ElementHandleAccessor;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public abstract class CodeGenerator {\n+\n+    public static final String CODE_GENERATOR_KIND = \"source.generate\";\n+    protected static final String ERROR = \"<error>\"; //NOI18N\n+\n+    public abstract List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params);\n+\n+    public abstract Set<String> getCommands();\n+\n+    public abstract CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments);\n+\n+    protected static int getOffset(CompilationInfo info, Position pos) {\n+        LineMap lm = info.getCompilationUnit().getLineMap();\n+        return (int) lm.getPosition(pos.getLine() + 1, pos.getCharacter() + 1);\n+    }\n+\n+    protected static CodeAction createCodeAction(String name, String kind, String command, Object... args) {\n+        CodeAction action = new CodeAction(name);\n+        action.setKind(kind);\n+        action.setCommand(new Command(name, command, Arrays.asList(args)));\n+        return action;\n+    }\n+\n+    protected static String createLabel(CompilationInfo info, TypeElement e) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(e.getSimpleName());\n+        List<? extends TypeParameterElement> typeParams = e.getTypeParameters();\n+        if (typeParams != null && !typeParams.isEmpty()) {\n+            sb.append(\"<\"); // NOI18N\n+            for(Iterator<? extends TypeParameterElement> it = typeParams.iterator(); it.hasNext();) {\n+                TypeParameterElement tp = it.next();\n+                sb.append(tp.getSimpleName());\n+                List<? extends TypeMirror> bounds = tp.getBounds();\n+                if (!bounds.isEmpty()) {\n+                    if (bounds.size() > 1 || !\"java.lang.Object\".equals(bounds.get(0).toString())) { // NOI18N\n+                        sb.append(\" extends \"); // NOI18N\n+                        for (Iterator<? extends TypeMirror> bIt = bounds.iterator(); bIt.hasNext();) {", "originalCommit": "4165983e6b010879475ed67961486fe3b278e364", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4OTI1NQ==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543189255", "bodyText": "the branches seem to have the same effect; just ElementKind.ENUM with  exactly 1 constructor is skipped. OK ?", "author": "sdedic", "createdAt": "2020-12-15T09:38:55Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/ConstructorGenerator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.NestingKind;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.editor.codegen.GeneratorUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class ConstructorGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_CONSTRUCTOR =  \"java.generate.constructor\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_CONSTRUCTOR);\n+    private final Gson gson = new Gson();\n+\n+    ConstructorGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateConstructor=Generate Constructor...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass() || NestingKind.ANONYMOUS.equals(typeElement.getNestingKind())) {\n+            return Collections.emptyList();\n+        }\n+        final Set<? extends VariableElement> uninitializedFields = info.getTreeUtilities().getUninitializedFields(tp);\n+        final List<ExecutableElement> inheritedConstructors = new ArrayList<>();\n+        TypeMirror superClassType = typeElement.getSuperclass();\n+        if (superClassType.getKind() == TypeKind.DECLARED) {\n+            TypeElement superClass = (TypeElement) ((DeclaredType) superClassType).asElement();\n+            Elements elements = info.getElements();\n+            for (ExecutableElement executableElement : ElementFilter.constructorsIn(superClass.getEnclosedElements())) {\n+                PackageElement currentPackage = elements.getPackageOf(typeElement);\n+                PackageElement ctorPackage = elements.getPackageOf(executableElement);\n+                Set<Modifier> ctorMods = executableElement.getModifiers();\n+                if ((currentPackage != ctorPackage && !(ctorMods.contains(Modifier.PUBLIC) || ctorMods.contains(Modifier.PROTECTED)))\n+                        || ctorMods.contains(Modifier.PRIVATE)) {\n+                    continue;\n+                }\n+                inheritedConstructors.add(executableElement);\n+            }\n+        }\n+        List<QuickPickItem> constructors = null;\n+        if (typeElement.getKind() != ElementKind.ENUM && inheritedConstructors.size() == 1) {\n+            QuickPickItem item = new QuickPickItem(createLabel(info, inheritedConstructors.get(0)));", "originalCommit": "4165983e6b010879475ed67961486fe3b278e364", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4OTMxOA==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543189318", "bodyText": "Question: wouldn't it be more appropriate to return Future that describes command's completion (= the actual code generation termination) to the client ? This way it could be possible to reliably chain commands from the client.", "author": "sdedic", "createdAt": "2020-12-15T09:39:00Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/ConstructorGenerator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.NestingKind;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.editor.codegen.GeneratorUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class ConstructorGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_CONSTRUCTOR =  \"java.generate.constructor\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_CONSTRUCTOR);\n+    private final Gson gson = new Gson();\n+\n+    ConstructorGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateConstructor=Generate Constructor...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass() || NestingKind.ANONYMOUS.equals(typeElement.getNestingKind())) {\n+            return Collections.emptyList();\n+        }\n+        final Set<? extends VariableElement> uninitializedFields = info.getTreeUtilities().getUninitializedFields(tp);\n+        final List<ExecutableElement> inheritedConstructors = new ArrayList<>();\n+        TypeMirror superClassType = typeElement.getSuperclass();\n+        if (superClassType.getKind() == TypeKind.DECLARED) {\n+            TypeElement superClass = (TypeElement) ((DeclaredType) superClassType).asElement();\n+            Elements elements = info.getElements();\n+            for (ExecutableElement executableElement : ElementFilter.constructorsIn(superClass.getEnclosedElements())) {\n+                PackageElement currentPackage = elements.getPackageOf(typeElement);\n+                PackageElement ctorPackage = elements.getPackageOf(executableElement);\n+                Set<Modifier> ctorMods = executableElement.getModifiers();\n+                if ((currentPackage != ctorPackage && !(ctorMods.contains(Modifier.PUBLIC) || ctorMods.contains(Modifier.PROTECTED)))\n+                        || ctorMods.contains(Modifier.PRIVATE)) {\n+                    continue;\n+                }\n+                inheritedConstructors.add(executableElement);\n+            }\n+        }\n+        List<QuickPickItem> constructors = null;\n+        if (typeElement.getKind() != ElementKind.ENUM && inheritedConstructors.size() == 1) {\n+            QuickPickItem item = new QuickPickItem(createLabel(info, inheritedConstructors.get(0)));\n+            item.setUserData(new ElementData(inheritedConstructors.get(0)));\n+            constructors = Collections.singletonList(item);\n+        } else if (inheritedConstructors.size() > 1) {\n+            constructors = new ArrayList<>(inheritedConstructors.size());\n+            for (ExecutableElement constructorElement : inheritedConstructors) {\n+                QuickPickItem item = new QuickPickItem(createLabel(info, constructorElement));\n+                item.setUserData(new ElementData(constructorElement));\n+                constructors.add(item);\n+            }\n+        }\n+        List<QuickPickItem> fields = null;\n+        if (!uninitializedFields.isEmpty()) {\n+            fields = new ArrayList<>();\n+            for (VariableElement variableElement : uninitializedFields) {\n+                QuickPickItem item = new QuickPickItem(createLabel(info, variableElement));\n+                item.setUserData(new ElementData(variableElement));\n+                fields.add(item);\n+            }\n+        }\n+        if (constructors == null && fields == null) {\n+            return Collections.emptyList();\n+        }\n+        String uri = Utils.toUri(info.getFileObject());\n+        return Collections.singletonList(createCodeAction(Bundle.DN_GenerateConstructor(), CODE_GENERATOR_KIND, GENERATE_CONSTRUCTOR, uri, offset, constructors, fields));\n+    }\n+\n+    @Override\n+    public Set<String> getCommands() {\n+        return commands;\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_SelectSuperConstructor=Select super constructor\",\n+    })\n+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {\n+        if (arguments.size() > 3) {\n+            String uri = gson.fromJson(gson.toJson(arguments.get(0)), String.class);\n+            int offset = gson.fromJson(gson.toJson(arguments.get(1)), Integer.class);\n+            List<QuickPickItem> constructors = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(2)), QuickPickItem[].class));\n+            List<QuickPickItem> fields = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(3)), QuickPickItem[].class));\n+            if (constructors.size() < 2 && fields.isEmpty()) {\n+                generate(client, uri, offset, constructors, fields);\n+            } else {\n+                if (constructors.size() > 1) {\n+                    client.showQuickPick(new ShowQuickPickParams(Bundle.DN_SelectSuperConstructor(), true, constructors)).thenAccept(selected -> {", "originalCommit": "4165983e6b010879475ed67961486fe3b278e364", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4OTM4Nw==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543189387", "bodyText": "possibly check js for null", "author": "sdedic", "createdAt": "2020-12-15T09:39:05Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/ConstructorGenerator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.NestingKind;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.editor.codegen.GeneratorUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class ConstructorGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_CONSTRUCTOR =  \"java.generate.constructor\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_CONSTRUCTOR);\n+    private final Gson gson = new Gson();\n+\n+    ConstructorGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateConstructor=Generate Constructor...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass() || NestingKind.ANONYMOUS.equals(typeElement.getNestingKind())) {\n+            return Collections.emptyList();\n+        }\n+        final Set<? extends VariableElement> uninitializedFields = info.getTreeUtilities().getUninitializedFields(tp);\n+        final List<ExecutableElement> inheritedConstructors = new ArrayList<>();\n+        TypeMirror superClassType = typeElement.getSuperclass();\n+        if (superClassType.getKind() == TypeKind.DECLARED) {\n+            TypeElement superClass = (TypeElement) ((DeclaredType) superClassType).asElement();\n+            Elements elements = info.getElements();\n+            for (ExecutableElement executableElement : ElementFilter.constructorsIn(superClass.getEnclosedElements())) {\n+                PackageElement currentPackage = elements.getPackageOf(typeElement);\n+                PackageElement ctorPackage = elements.getPackageOf(executableElement);\n+                Set<Modifier> ctorMods = executableElement.getModifiers();\n+                if ((currentPackage != ctorPackage && !(ctorMods.contains(Modifier.PUBLIC) || ctorMods.contains(Modifier.PROTECTED)))\n+                        || ctorMods.contains(Modifier.PRIVATE)) {\n+                    continue;\n+                }\n+                inheritedConstructors.add(executableElement);\n+            }\n+        }\n+        List<QuickPickItem> constructors = null;\n+        if (typeElement.getKind() != ElementKind.ENUM && inheritedConstructors.size() == 1) {\n+            QuickPickItem item = new QuickPickItem(createLabel(info, inheritedConstructors.get(0)));\n+            item.setUserData(new ElementData(inheritedConstructors.get(0)));\n+            constructors = Collections.singletonList(item);\n+        } else if (inheritedConstructors.size() > 1) {\n+            constructors = new ArrayList<>(inheritedConstructors.size());\n+            for (ExecutableElement constructorElement : inheritedConstructors) {\n+                QuickPickItem item = new QuickPickItem(createLabel(info, constructorElement));\n+                item.setUserData(new ElementData(constructorElement));\n+                constructors.add(item);\n+            }\n+        }\n+        List<QuickPickItem> fields = null;\n+        if (!uninitializedFields.isEmpty()) {\n+            fields = new ArrayList<>();\n+            for (VariableElement variableElement : uninitializedFields) {\n+                QuickPickItem item = new QuickPickItem(createLabel(info, variableElement));\n+                item.setUserData(new ElementData(variableElement));\n+                fields.add(item);\n+            }\n+        }\n+        if (constructors == null && fields == null) {\n+            return Collections.emptyList();\n+        }\n+        String uri = Utils.toUri(info.getFileObject());\n+        return Collections.singletonList(createCodeAction(Bundle.DN_GenerateConstructor(), CODE_GENERATOR_KIND, GENERATE_CONSTRUCTOR, uri, offset, constructors, fields));\n+    }\n+\n+    @Override\n+    public Set<String> getCommands() {\n+        return commands;\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_SelectSuperConstructor=Select super constructor\",\n+    })\n+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {\n+        if (arguments.size() > 3) {\n+            String uri = gson.fromJson(gson.toJson(arguments.get(0)), String.class);\n+            int offset = gson.fromJson(gson.toJson(arguments.get(1)), Integer.class);\n+            List<QuickPickItem> constructors = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(2)), QuickPickItem[].class));\n+            List<QuickPickItem> fields = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(3)), QuickPickItem[].class));\n+            if (constructors.size() < 2 && fields.isEmpty()) {\n+                generate(client, uri, offset, constructors, fields);\n+            } else {\n+                if (constructors.size() > 1) {\n+                    client.showQuickPick(new ShowQuickPickParams(Bundle.DN_SelectSuperConstructor(), true, constructors)).thenAccept(selected -> {\n+                        if (selected != null) {\n+                            selectFields(client, uri, offset, selected, fields);\n+                        }\n+                    });\n+                } else {\n+                    selectFields(client, uri, offset, constructors, fields);\n+                }\n+            }\n+        }\n+        return CompletableFuture.completedFuture(true);\n+    }\n+\n+    @NbBundle.Messages({\n+        \"DN_SelectConstructorFields=Select fields to be initialized by constructor\",\n+    })\n+    private void selectFields(NbCodeLanguageClient client, String uri, int offset, List<QuickPickItem> constructors, List<QuickPickItem> fields) {\n+        if (!fields.isEmpty()) {\n+            client.showQuickPick(new ShowQuickPickParams(Bundle.DN_SelectConstructorFields(), true, fields)).thenAccept(selected -> {\n+                if (selected != null) {\n+                    generate(client, uri, offset, constructors, selected);\n+                }\n+            });\n+        } else {\n+            generate(client, uri, offset, constructors, fields);\n+        }\n+    }\n+\n+    private void generate(NbCodeLanguageClient client, String uri, int offset, List<QuickPickItem> constructors, List<QuickPickItem> fields) {\n+        try {\n+            FileObject file = Utils.fromUri(uri);\n+            JavaSource js = JavaSource.forFileObject(file);\n+            List<TextEdit> edits = TextDocumentServiceImpl.modify2TextEdits(js, wc -> {", "originalCommit": "4165983e6b010879475ed67961486fe3b278e364", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4OTQxNg==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543189416", "bodyText": "Maybe filter for null result of Handle.resolve, generateConstructors does not accept null list members.", "author": "sdedic", "createdAt": "2020-12-15T09:39:08Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/ConstructorGenerator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.NestingKind;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.editor.codegen.GeneratorUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class ConstructorGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_CONSTRUCTOR =  \"java.generate.constructor\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_CONSTRUCTOR);\n+    private final Gson gson = new Gson();\n+\n+    ConstructorGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateConstructor=Generate Constructor...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass() || NestingKind.ANONYMOUS.equals(typeElement.getNestingKind())) {\n+            return Collections.emptyList();\n+        }\n+        final Set<? extends VariableElement> uninitializedFields = info.getTreeUtilities().getUninitializedFields(tp);\n+        final List<ExecutableElement> inheritedConstructors = new ArrayList<>();\n+        TypeMirror superClassType = typeElement.getSuperclass();\n+        if (superClassType.getKind() == TypeKind.DECLARED) {\n+            TypeElement superClass = (TypeElement) ((DeclaredType) superClassType).asElement();\n+            Elements elements = info.getElements();\n+            for (ExecutableElement executableElement : ElementFilter.constructorsIn(superClass.getEnclosedElements())) {\n+                PackageElement currentPackage = elements.getPackageOf(typeElement);\n+                PackageElement ctorPackage = elements.getPackageOf(executableElement);\n+                Set<Modifier> ctorMods = executableElement.getModifiers();\n+                if ((currentPackage != ctorPackage && !(ctorMods.contains(Modifier.PUBLIC) || ctorMods.contains(Modifier.PROTECTED)))\n+                        || ctorMods.contains(Modifier.PRIVATE)) {\n+                    continue;\n+                }\n+                inheritedConstructors.add(executableElement);\n+            }\n+        }\n+        List<QuickPickItem> constructors = null;\n+        if (typeElement.getKind() != ElementKind.ENUM && inheritedConstructors.size() == 1) {\n+            QuickPickItem item = new QuickPickItem(createLabel(info, inheritedConstructors.get(0)));\n+            item.setUserData(new ElementData(inheritedConstructors.get(0)));\n+            constructors = Collections.singletonList(item);\n+        } else if (inheritedConstructors.size() > 1) {\n+            constructors = new ArrayList<>(inheritedConstructors.size());\n+            for (ExecutableElement constructorElement : inheritedConstructors) {\n+                QuickPickItem item = new QuickPickItem(createLabel(info, constructorElement));\n+                item.setUserData(new ElementData(constructorElement));\n+                constructors.add(item);\n+            }\n+        }\n+        List<QuickPickItem> fields = null;\n+        if (!uninitializedFields.isEmpty()) {\n+            fields = new ArrayList<>();\n+            for (VariableElement variableElement : uninitializedFields) {\n+                QuickPickItem item = new QuickPickItem(createLabel(info, variableElement));\n+                item.setUserData(new ElementData(variableElement));\n+                fields.add(item);\n+            }\n+        }\n+        if (constructors == null && fields == null) {\n+            return Collections.emptyList();\n+        }\n+        String uri = Utils.toUri(info.getFileObject());\n+        return Collections.singletonList(createCodeAction(Bundle.DN_GenerateConstructor(), CODE_GENERATOR_KIND, GENERATE_CONSTRUCTOR, uri, offset, constructors, fields));\n+    }\n+\n+    @Override\n+    public Set<String> getCommands() {\n+        return commands;\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_SelectSuperConstructor=Select super constructor\",\n+    })\n+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {\n+        if (arguments.size() > 3) {\n+            String uri = gson.fromJson(gson.toJson(arguments.get(0)), String.class);\n+            int offset = gson.fromJson(gson.toJson(arguments.get(1)), Integer.class);\n+            List<QuickPickItem> constructors = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(2)), QuickPickItem[].class));\n+            List<QuickPickItem> fields = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(3)), QuickPickItem[].class));\n+            if (constructors.size() < 2 && fields.isEmpty()) {\n+                generate(client, uri, offset, constructors, fields);\n+            } else {\n+                if (constructors.size() > 1) {\n+                    client.showQuickPick(new ShowQuickPickParams(Bundle.DN_SelectSuperConstructor(), true, constructors)).thenAccept(selected -> {\n+                        if (selected != null) {\n+                            selectFields(client, uri, offset, selected, fields);\n+                        }\n+                    });\n+                } else {\n+                    selectFields(client, uri, offset, constructors, fields);\n+                }\n+            }\n+        }\n+        return CompletableFuture.completedFuture(true);\n+    }\n+\n+    @NbBundle.Messages({\n+        \"DN_SelectConstructorFields=Select fields to be initialized by constructor\",\n+    })\n+    private void selectFields(NbCodeLanguageClient client, String uri, int offset, List<QuickPickItem> constructors, List<QuickPickItem> fields) {\n+        if (!fields.isEmpty()) {\n+            client.showQuickPick(new ShowQuickPickParams(Bundle.DN_SelectConstructorFields(), true, fields)).thenAccept(selected -> {\n+                if (selected != null) {\n+                    generate(client, uri, offset, constructors, selected);\n+                }\n+            });\n+        } else {\n+            generate(client, uri, offset, constructors, fields);\n+        }\n+    }\n+\n+    private void generate(NbCodeLanguageClient client, String uri, int offset, List<QuickPickItem> constructors, List<QuickPickItem> fields) {\n+        try {\n+            FileObject file = Utils.fromUri(uri);\n+            JavaSource js = JavaSource.forFileObject(file);\n+            List<TextEdit> edits = TextDocumentServiceImpl.modify2TextEdits(js, wc -> {\n+                wc.toPhase(JavaSource.Phase.RESOLVED);\n+                TreePath tp = wc.getTreeUtilities().pathFor(offset);\n+                tp = wc.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+                if (tp != null) {\n+                    List<ExecutableElement> selectedConstructors = constructors.stream().map(item -> {\n+                        ElementData data = gson.fromJson(gson.toJson(item.getUserData()), ElementData.class);\n+                        return (ExecutableElement)data.resolve(wc);\n+                    }).collect(Collectors.toList());", "originalCommit": "4165983e6b010879475ed67961486fe3b278e364", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE5NDE4Mg==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543194182", "bodyText": "Nitpick: document msg parameters.", "author": "sdedic", "createdAt": "2020-12-15T09:45:40Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/GetterSetterGenerator.java", "diffHunk": "@@ -18,58 +18,175 @@\n  */\n package org.netbeans.modules.java.lsp.server.protocol;\n \n+import com.google.gson.Gson;\n import com.sun.source.tree.ClassTree;\n-import com.sun.source.tree.LineMap;\n import com.sun.source.tree.Tree;\n import com.sun.source.util.TreePath;\n import java.io.IOException;\n-import java.net.MalformedURLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.element.VariableElement;\n import javax.lang.model.util.ElementFilter;\n import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n-import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n import org.eclipse.lsp4j.Range;\n import org.eclipse.lsp4j.TextEdit;\n import org.eclipse.lsp4j.WorkspaceEdit;\n-import org.eclipse.lsp4j.services.LanguageClient;\n import org.netbeans.api.java.source.CodeStyle;\n import org.netbeans.api.java.source.CompilationInfo;\n import org.netbeans.api.java.source.ElementUtilities;\n import org.netbeans.api.java.source.JavaSource;\n import org.netbeans.api.java.source.TreeUtilities;\n import org.netbeans.modules.java.editor.codegen.GeneratorUtils;\n-import static org.netbeans.modules.java.lsp.server.protocol.TextDocumentServiceImpl.fromUri;\n+import org.netbeans.modules.java.lsp.server.Utils;\n import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n import org.openide.util.Pair;\n \n /**\n  *\n  * @author lahvac\n  */\n-public class GetterSetterGenerator {\n+public final class GetterSetterGenerator extends CodeGenerator {\n \n-    private static final String ERROR = \"<error>\"; //NOI18N\n+    public static final String GENERATE_GETTERS =  \"java.generate.getters\";\n+    public static final String GENERATE_SETTERS =  \"java.generate.setters\";\n+    public static final String GENERATE_GETTERS_SETTERS =  \"java.generate.getters.setters\";\n \n-    public static Pair<Set<VariableElement>, Set<VariableElement>> findMissingGettersSetters(CompilationInfo info, Range range, boolean all) {\n-        TreePath tp = info.getTreeUtilities().pathFor(getOffset(info, range.getStart()));\n+    private final Set<String> commands = Collections.unmodifiableSet(new HashSet(Arrays.asList(GENERATE_GETTERS, GENERATE_SETTERS, GENERATE_GETTERS_SETTERS)));\n+    private final Gson gson = new Gson();\n+\n+    GetterSetterGenerator() {\n+    }\n \n-        while (tp != null && !TreeUtilities.CLASS_TREE_KINDS.contains(tp.getLeaf().getKind())) {\n-            tp = tp.getParentPath();\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateGetters=Generate Getters...\",\n+        \"DN_GenerateSetters=Generate Setters...\",\n+        \"DN_GenerateGettersSetters=Generate Getters and Setters...\",\n+        \"DN_GenerateGetterFor=Generate Getter for \\\"{0}\\\"\",", "originalCommit": "4165983e6b010879475ed67961486fe3b278e364", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE5Njc3MA==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543196770", "bodyText": "pair.first() may become empty after retainAll", "author": "sdedic", "createdAt": "2020-12-15T09:49:16Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/GetterSetterGenerator.java", "diffHunk": "@@ -18,58 +18,175 @@\n  */\n package org.netbeans.modules.java.lsp.server.protocol;\n \n+import com.google.gson.Gson;\n import com.sun.source.tree.ClassTree;\n-import com.sun.source.tree.LineMap;\n import com.sun.source.tree.Tree;\n import com.sun.source.util.TreePath;\n import java.io.IOException;\n-import java.net.MalformedURLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.element.VariableElement;\n import javax.lang.model.util.ElementFilter;\n import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n-import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n import org.eclipse.lsp4j.Range;\n import org.eclipse.lsp4j.TextEdit;\n import org.eclipse.lsp4j.WorkspaceEdit;\n-import org.eclipse.lsp4j.services.LanguageClient;\n import org.netbeans.api.java.source.CodeStyle;\n import org.netbeans.api.java.source.CompilationInfo;\n import org.netbeans.api.java.source.ElementUtilities;\n import org.netbeans.api.java.source.JavaSource;\n import org.netbeans.api.java.source.TreeUtilities;\n import org.netbeans.modules.java.editor.codegen.GeneratorUtils;\n-import static org.netbeans.modules.java.lsp.server.protocol.TextDocumentServiceImpl.fromUri;\n+import org.netbeans.modules.java.lsp.server.Utils;\n import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n import org.openide.util.Pair;\n \n /**\n  *\n  * @author lahvac\n  */\n-public class GetterSetterGenerator {\n+public final class GetterSetterGenerator extends CodeGenerator {\n \n-    private static final String ERROR = \"<error>\"; //NOI18N\n+    public static final String GENERATE_GETTERS =  \"java.generate.getters\";\n+    public static final String GENERATE_SETTERS =  \"java.generate.setters\";\n+    public static final String GENERATE_GETTERS_SETTERS =  \"java.generate.getters.setters\";\n \n-    public static Pair<Set<VariableElement>, Set<VariableElement>> findMissingGettersSetters(CompilationInfo info, Range range, boolean all) {\n-        TreePath tp = info.getTreeUtilities().pathFor(getOffset(info, range.getStart()));\n+    private final Set<String> commands = Collections.unmodifiableSet(new HashSet(Arrays.asList(GENERATE_GETTERS, GENERATE_SETTERS, GENERATE_GETTERS_SETTERS)));\n+    private final Gson gson = new Gson();\n+\n+    GetterSetterGenerator() {\n+    }\n \n-        while (tp != null && !TreeUtilities.CLASS_TREE_KINDS.contains(tp.getLeaf().getKind())) {\n-            tp = tp.getParentPath();\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateGetters=Generate Getters...\",\n+        \"DN_GenerateSetters=Generate Setters...\",\n+        \"DN_GenerateGettersSetters=Generate Getters and Setters...\",\n+        \"DN_GenerateGetterFor=Generate Getter for \\\"{0}\\\"\",\n+        \"DN_GenerateSetterFor=Generate Setter for \\\"{0}\\\"\",\n+        \"DN_GenerateGetterSetterFor=Generate Getter and Setter for \\\"{0}\\\"\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        boolean all = only != null && only.contains(CodeActionKind.Source);\n+        Pair<Set<VariableElement>, Set<VariableElement>> pair = findMissingGettersSetters(info, params.getRange(), all);\n+        boolean missingGetters = !pair.first().isEmpty();\n+        boolean missingSetters = !pair.second().isEmpty();\n+        String uri = Utils.toUri(info.getFileObject());\n+        int offset = getOffset(info, params.getRange().getStart());\n+        List<CodeAction> result = new ArrayList<>();\n+        if (missingGetters) {\n+            String name = pair.first().size() == 1 ? Bundle.DN_GenerateGetterFor(pair.first().iterator().next().getSimpleName().toString()) : Bundle.DN_GenerateGetters();\n+            result.add(createCodeAction(name, all ? CODE_GENERATOR_KIND : CodeActionKind.QuickFix, GENERATE_GETTERS, uri, offset, all, pair.first().stream().map(variableElement -> {\n+                QuickPickItem item = new QuickPickItem(createLabel(info, variableElement));\n+                item.setUserData(new ElementData(variableElement));\n+                return item;\n+            }).collect(Collectors.toList())));\n+        }\n+        if (missingSetters) {\n+            String name = pair.second().size() == 1 ? Bundle.DN_GenerateSetterFor(pair.second().iterator().next().getSimpleName().toString()) : Bundle.DN_GenerateSetters();\n+            result.add(createCodeAction(name, all ? CODE_GENERATOR_KIND : CodeActionKind.QuickFix, GENERATE_SETTERS, uri, offset, all, pair.second().stream().map(variableElement -> {\n+                QuickPickItem item = new QuickPickItem(createLabel(info, variableElement));\n+                item.setUserData(new ElementData(variableElement));\n+                return item;\n+            }).collect(Collectors.toList())));\n         }\n+        if (missingGetters && missingSetters) {\n+            pair.first().retainAll(pair.second());\n+            String name = pair.first().size() == 1 ? Bundle.DN_GenerateGetterSetterFor(pair.first().iterator().next().getSimpleName().toString()) : Bundle.DN_GenerateGettersSetters();", "originalCommit": "4165983e6b010879475ed67961486fe3b278e364", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIwNTY5NQ==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543205695", "bodyText": "The other generators bailed out if only != null, but did not contain CodeActionKind.Source; this seem to process all eligible fields later in processCommand. Right now just QuickFix is declared (in addition to Source), but better check explicitly so it own't break when the set of CodeActionKinds expand later.", "author": "sdedic", "createdAt": "2020-12-15T10:01:21Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/GetterSetterGenerator.java", "diffHunk": "@@ -18,58 +18,175 @@\n  */\n package org.netbeans.modules.java.lsp.server.protocol;\n \n+import com.google.gson.Gson;\n import com.sun.source.tree.ClassTree;\n-import com.sun.source.tree.LineMap;\n import com.sun.source.tree.Tree;\n import com.sun.source.util.TreePath;\n import java.io.IOException;\n-import java.net.MalformedURLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.element.VariableElement;\n import javax.lang.model.util.ElementFilter;\n import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n-import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n import org.eclipse.lsp4j.Range;\n import org.eclipse.lsp4j.TextEdit;\n import org.eclipse.lsp4j.WorkspaceEdit;\n-import org.eclipse.lsp4j.services.LanguageClient;\n import org.netbeans.api.java.source.CodeStyle;\n import org.netbeans.api.java.source.CompilationInfo;\n import org.netbeans.api.java.source.ElementUtilities;\n import org.netbeans.api.java.source.JavaSource;\n import org.netbeans.api.java.source.TreeUtilities;\n import org.netbeans.modules.java.editor.codegen.GeneratorUtils;\n-import static org.netbeans.modules.java.lsp.server.protocol.TextDocumentServiceImpl.fromUri;\n+import org.netbeans.modules.java.lsp.server.Utils;\n import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n import org.openide.util.Pair;\n \n /**\n  *\n  * @author lahvac\n  */\n-public class GetterSetterGenerator {\n+public final class GetterSetterGenerator extends CodeGenerator {\n \n-    private static final String ERROR = \"<error>\"; //NOI18N\n+    public static final String GENERATE_GETTERS =  \"java.generate.getters\";\n+    public static final String GENERATE_SETTERS =  \"java.generate.setters\";\n+    public static final String GENERATE_GETTERS_SETTERS =  \"java.generate.getters.setters\";\n \n-    public static Pair<Set<VariableElement>, Set<VariableElement>> findMissingGettersSetters(CompilationInfo info, Range range, boolean all) {\n-        TreePath tp = info.getTreeUtilities().pathFor(getOffset(info, range.getStart()));\n+    private final Set<String> commands = Collections.unmodifiableSet(new HashSet(Arrays.asList(GENERATE_GETTERS, GENERATE_SETTERS, GENERATE_GETTERS_SETTERS)));\n+    private final Gson gson = new Gson();\n+\n+    GetterSetterGenerator() {\n+    }\n \n-        while (tp != null && !TreeUtilities.CLASS_TREE_KINDS.contains(tp.getLeaf().getKind())) {\n-            tp = tp.getParentPath();\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateGetters=Generate Getters...\",\n+        \"DN_GenerateSetters=Generate Setters...\",\n+        \"DN_GenerateGettersSetters=Generate Getters and Setters...\",\n+        \"DN_GenerateGetterFor=Generate Getter for \\\"{0}\\\"\",\n+        \"DN_GenerateSetterFor=Generate Setter for \\\"{0}\\\"\",\n+        \"DN_GenerateGetterSetterFor=Generate Getter and Setter for \\\"{0}\\\"\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        boolean all = only != null && only.contains(CodeActionKind.Source);", "originalCommit": "4165983e6b010879475ed67961486fe3b278e364", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIwNzc1Mw==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543207753", "bodyText": "I'd check the field's type TypeMirror for not being erroneous. Strange things may happen when generating incomplete types into getter / setter declartions.", "author": "sdedic", "createdAt": "2020-12-15T10:04:14Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/GetterSetterGenerator.java", "diffHunk": "@@ -18,58 +18,175 @@\n  */\n package org.netbeans.modules.java.lsp.server.protocol;\n \n+import com.google.gson.Gson;\n import com.sun.source.tree.ClassTree;\n-import com.sun.source.tree.LineMap;\n import com.sun.source.tree.Tree;\n import com.sun.source.util.TreePath;\n import java.io.IOException;\n-import java.net.MalformedURLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.element.VariableElement;\n import javax.lang.model.util.ElementFilter;\n import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n-import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n import org.eclipse.lsp4j.Range;\n import org.eclipse.lsp4j.TextEdit;\n import org.eclipse.lsp4j.WorkspaceEdit;\n-import org.eclipse.lsp4j.services.LanguageClient;\n import org.netbeans.api.java.source.CodeStyle;\n import org.netbeans.api.java.source.CompilationInfo;\n import org.netbeans.api.java.source.ElementUtilities;\n import org.netbeans.api.java.source.JavaSource;\n import org.netbeans.api.java.source.TreeUtilities;\n import org.netbeans.modules.java.editor.codegen.GeneratorUtils;\n-import static org.netbeans.modules.java.lsp.server.protocol.TextDocumentServiceImpl.fromUri;\n+import org.netbeans.modules.java.lsp.server.Utils;\n import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n import org.openide.util.Pair;\n \n /**\n  *\n  * @author lahvac\n  */\n-public class GetterSetterGenerator {\n+public final class GetterSetterGenerator extends CodeGenerator {\n \n-    private static final String ERROR = \"<error>\"; //NOI18N\n+    public static final String GENERATE_GETTERS =  \"java.generate.getters\";\n+    public static final String GENERATE_SETTERS =  \"java.generate.setters\";\n+    public static final String GENERATE_GETTERS_SETTERS =  \"java.generate.getters.setters\";\n \n-    public static Pair<Set<VariableElement>, Set<VariableElement>> findMissingGettersSetters(CompilationInfo info, Range range, boolean all) {\n-        TreePath tp = info.getTreeUtilities().pathFor(getOffset(info, range.getStart()));\n+    private final Set<String> commands = Collections.unmodifiableSet(new HashSet(Arrays.asList(GENERATE_GETTERS, GENERATE_SETTERS, GENERATE_GETTERS_SETTERS)));\n+    private final Gson gson = new Gson();\n+\n+    GetterSetterGenerator() {\n+    }\n \n-        while (tp != null && !TreeUtilities.CLASS_TREE_KINDS.contains(tp.getLeaf().getKind())) {\n-            tp = tp.getParentPath();\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateGetters=Generate Getters...\",\n+        \"DN_GenerateSetters=Generate Setters...\",\n+        \"DN_GenerateGettersSetters=Generate Getters and Setters...\",\n+        \"DN_GenerateGetterFor=Generate Getter for \\\"{0}\\\"\",\n+        \"DN_GenerateSetterFor=Generate Setter for \\\"{0}\\\"\",\n+        \"DN_GenerateGetterSetterFor=Generate Getter and Setter for \\\"{0}\\\"\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        boolean all = only != null && only.contains(CodeActionKind.Source);\n+        Pair<Set<VariableElement>, Set<VariableElement>> pair = findMissingGettersSetters(info, params.getRange(), all);\n+        boolean missingGetters = !pair.first().isEmpty();\n+        boolean missingSetters = !pair.second().isEmpty();\n+        String uri = Utils.toUri(info.getFileObject());\n+        int offset = getOffset(info, params.getRange().getStart());\n+        List<CodeAction> result = new ArrayList<>();\n+        if (missingGetters) {\n+            String name = pair.first().size() == 1 ? Bundle.DN_GenerateGetterFor(pair.first().iterator().next().getSimpleName().toString()) : Bundle.DN_GenerateGetters();\n+            result.add(createCodeAction(name, all ? CODE_GENERATOR_KIND : CodeActionKind.QuickFix, GENERATE_GETTERS, uri, offset, all, pair.first().stream().map(variableElement -> {\n+                QuickPickItem item = new QuickPickItem(createLabel(info, variableElement));\n+                item.setUserData(new ElementData(variableElement));\n+                return item;\n+            }).collect(Collectors.toList())));\n+        }\n+        if (missingSetters) {\n+            String name = pair.second().size() == 1 ? Bundle.DN_GenerateSetterFor(pair.second().iterator().next().getSimpleName().toString()) : Bundle.DN_GenerateSetters();\n+            result.add(createCodeAction(name, all ? CODE_GENERATOR_KIND : CodeActionKind.QuickFix, GENERATE_SETTERS, uri, offset, all, pair.second().stream().map(variableElement -> {\n+                QuickPickItem item = new QuickPickItem(createLabel(info, variableElement));\n+                item.setUserData(new ElementData(variableElement));\n+                return item;\n+            }).collect(Collectors.toList())));\n         }\n+        if (missingGetters && missingSetters) {\n+            pair.first().retainAll(pair.second());\n+            String name = pair.first().size() == 1 ? Bundle.DN_GenerateGetterSetterFor(pair.first().iterator().next().getSimpleName().toString()) : Bundle.DN_GenerateGettersSetters();\n+            result.add(createCodeAction(name, all ? CODE_GENERATOR_KIND : CodeActionKind.QuickFix, GENERATE_GETTERS_SETTERS, uri, offset, all, pair.first().stream().map(variableElement -> {\n+                QuickPickItem item = new QuickPickItem(createLabel(info, variableElement));\n+                item.setUserData(new ElementData(variableElement));\n+                return item;\n+            }).collect(Collectors.toList())));\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Set<String> getCommands() {\n+        return commands;\n+    }\n \n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_SelectGetters=Select fields to generate getters for\",\n+        \"DN_SelectSetters=Select fields to generate setters for\",\n+        \"DN_SelectGettersSetters=Select fields to generate getters and setters for\",\n+    })\n+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {\n+        if (arguments.size() > 3) {\n+            String uri = gson.fromJson(gson.toJson(arguments.get(0)), String.class);\n+            int offset = gson.fromJson(gson.toJson(arguments.get(1)), Integer.class);\n+            boolean all = gson.fromJson(gson.toJson(arguments.get(2)), boolean.class);\n+            List<QuickPickItem> fields = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(3)), QuickPickItem[].class));\n+            int kind;\n+            String text;\n+            switch (command) {\n+                case GENERATE_GETTERS: kind = GeneratorUtils.GETTERS_ONLY; text = Bundle.DN_SelectGetters(); break;\n+                case GENERATE_SETTERS: kind = GeneratorUtils.SETTERS_ONLY; text = Bundle.DN_SelectSetters(); break;\n+                default: kind = 0; text = Bundle.DN_SelectGettersSetters(); break;\n+            }\n+            if (all && fields.size() > 1) {\n+                client.showQuickPick(new ShowQuickPickParams(text, true, fields)).thenAccept(selected -> {\n+                    if (selected != null) {\n+                        generate(client, kind, uri, offset, selected);\n+                    }\n+                });\n+            } else {\n+                generate(client, kind, uri, offset, fields);\n+            }\n+        }\n+        return CompletableFuture.completedFuture(true);\n+    }\n+\n+    private void generate(NbCodeLanguageClient client, int kind, String uri, int offset, List<QuickPickItem> fields) throws IllegalArgumentException {\n+        try {\n+            FileObject file = Utils.fromUri(uri);\n+            JavaSource js = JavaSource.forFileObject(file);\n+            List<TextEdit> edits = TextDocumentServiceImpl.modify2TextEdits(js, wc -> {\n+                wc.toPhase(JavaSource.Phase.RESOLVED);\n+                if (!fields.isEmpty()) {\n+                    TreePath tp = wc.getTreeUtilities().pathFor(offset);\n+                    tp = wc.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+                    if (tp != null) {", "originalCommit": "4165983e6b010879475ed67961486fe3b278e364", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIxNTUzMw==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543215533", "bodyText": "&& !selected.isEmpty()", "author": "sdedic", "createdAt": "2020-12-15T10:15:08Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/ImplementOverrideMethodGenerator.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementUtilities;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.editor.codegen.GeneratorUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class ImplementOverrideMethodGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_IMPLEMENT_METHOD =  \"java.generate.implementMethod\";\n+    public static final String GENERATE_OVERRIDE_METHOD =  \"java.generate.overrideMethod\";\n+\n+    private final Set<String> commands = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(GENERATE_IMPLEMENT_METHOD, GENERATE_OVERRIDE_METHOD)));\n+    private final Gson gson = new Gson();\n+\n+    ImplementOverrideMethodGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateImplementMethod=Generate Implement Method...\",\n+        \"DN_GenerateOverrideMethod=Generate Override Method...\",\n+        \"DN_From=(from {0})\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || typeElement.getKind() == ElementKind.ANNOTATION_TYPE) {\n+            return Collections.emptyList();\n+        }\n+        List<CodeAction> result = new ArrayList<>();\n+        String uri = Utils.toUri(info.getFileObject());\n+        ElementUtilities eu = info.getElementUtilities();\n+        if (typeElement.getKind().isClass() || typeElement.getKind().isInterface() && SourceVersion.RELEASE_8.compareTo(info.getSourceVersion()) <= 0) {\n+            List<QuickPickItem> implementMethods = new ArrayList<>();\n+            for (ExecutableElement method : eu.findUnimplementedMethods(typeElement, true)) {\n+                boolean mustImplement = !method.getModifiers().contains(Modifier.DEFAULT);\n+                Element enclosingElement = method.getEnclosingElement();\n+                String enclosingTypeName = enclosingElement.getKind().isClass() || enclosingElement.getKind().isInterface() ? Bundle.DN_From(((TypeElement)enclosingElement).getQualifiedName().toString()) : null;\n+                implementMethods.add(new QuickPickItem(createLabel(info, method), enclosingTypeName, null, mustImplement, new ElementData(method)));\n+            }\n+            if (!implementMethods.isEmpty()) {\n+                result.add(createCodeAction(Bundle.DN_GenerateImplementMethod(), CODE_GENERATOR_KIND, GENERATE_IMPLEMENT_METHOD, uri, offset, implementMethods));\n+            }\n+        }\n+        if (typeElement.getKind().isClass() || typeElement.getKind().isInterface()) {\n+            List<QuickPickItem> overrideMethods = new ArrayList<>();\n+            for (ExecutableElement method : eu.findOverridableMethods(typeElement)) {\n+                Element enclosingElement = method.getEnclosingElement();\n+                String enclosingTypeName = enclosingElement.getKind().isClass() || enclosingElement.getKind().isInterface() ? Bundle.DN_From(((TypeElement) enclosingElement).getQualifiedName().toString()) : null;\n+                QuickPickItem item = new QuickPickItem(createLabel(info, method));\n+                if (enclosingTypeName != null) {\n+                    item.setDescription(enclosingTypeName);\n+                }\n+                item.setUserData(new ElementData(method));\n+                overrideMethods.add(item);\n+            }\n+            if (!overrideMethods.isEmpty()) {\n+                result.add(createCodeAction(Bundle.DN_GenerateOverrideMethod(), CODE_GENERATOR_KIND, GENERATE_OVERRIDE_METHOD, uri, offset, overrideMethods));\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Set<String> getCommands() {\n+        return commands;\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_SelectImplementMethod=Select methods to implement\",\n+        \"DN_SelectOverrideMethod=Select methods to override\",\n+    })\n+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {\n+        if (arguments.size() > 2) {\n+            String uri = gson.fromJson(gson.toJson(arguments.get(0)), String.class);\n+            int offset = gson.fromJson(gson.toJson(arguments.get(1)), Integer.class);\n+            List<QuickPickItem> methods = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(2)), QuickPickItem[].class));\n+            String text = command == GENERATE_IMPLEMENT_METHOD ? Bundle.DN_SelectImplementMethod() : Bundle.DN_SelectOverrideMethod();\n+            boolean isImplement = command == GENERATE_IMPLEMENT_METHOD;\n+            client.showQuickPick(new ShowQuickPickParams(text, true, methods)).thenAccept(selected -> {\n+                if (selected != null) {", "originalCommit": "4165983e6b010879475ed67961486fe3b278e364", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM2MzgxNA==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543363814", "bodyText": "Fixed.", "author": "dbalek", "createdAt": "2020-12-15T14:00:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIxNTUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIxOTM3MQ==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543219371", "bodyText": "I am not sure what GenreratorUtils.generateMethodOverrides does when overriding method in the interface type for Java < 8, where default modified is not allowed.", "author": "sdedic", "createdAt": "2020-12-15T10:20:42Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/ImplementOverrideMethodGenerator.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementUtilities;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.editor.codegen.GeneratorUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class ImplementOverrideMethodGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_IMPLEMENT_METHOD =  \"java.generate.implementMethod\";\n+    public static final String GENERATE_OVERRIDE_METHOD =  \"java.generate.overrideMethod\";\n+\n+    private final Set<String> commands = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(GENERATE_IMPLEMENT_METHOD, GENERATE_OVERRIDE_METHOD)));\n+    private final Gson gson = new Gson();\n+\n+    ImplementOverrideMethodGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateImplementMethod=Generate Implement Method...\",\n+        \"DN_GenerateOverrideMethod=Generate Override Method...\",\n+        \"DN_From=(from {0})\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || typeElement.getKind() == ElementKind.ANNOTATION_TYPE) {\n+            return Collections.emptyList();\n+        }\n+        List<CodeAction> result = new ArrayList<>();\n+        String uri = Utils.toUri(info.getFileObject());\n+        ElementUtilities eu = info.getElementUtilities();\n+        if (typeElement.getKind().isClass() || typeElement.getKind().isInterface() && SourceVersion.RELEASE_8.compareTo(info.getSourceVersion()) <= 0) {\n+            List<QuickPickItem> implementMethods = new ArrayList<>();\n+            for (ExecutableElement method : eu.findUnimplementedMethods(typeElement, true)) {\n+                boolean mustImplement = !method.getModifiers().contains(Modifier.DEFAULT);\n+                Element enclosingElement = method.getEnclosingElement();\n+                String enclosingTypeName = enclosingElement.getKind().isClass() || enclosingElement.getKind().isInterface() ? Bundle.DN_From(((TypeElement)enclosingElement).getQualifiedName().toString()) : null;\n+                implementMethods.add(new QuickPickItem(createLabel(info, method), enclosingTypeName, null, mustImplement, new ElementData(method)));\n+            }\n+            if (!implementMethods.isEmpty()) {\n+                result.add(createCodeAction(Bundle.DN_GenerateImplementMethod(), CODE_GENERATOR_KIND, GENERATE_IMPLEMENT_METHOD, uri, offset, implementMethods));\n+            }\n+        }\n+        if (typeElement.getKind().isClass() || typeElement.getKind().isInterface()) {", "originalCommit": "4165983e6b010879475ed67961486fe3b278e364", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM2NzUxMA==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543367510", "bodyText": "CodeAction is not available in interfaces for Java < 8 (see getCodeActions(...) method).", "author": "dbalek", "createdAt": "2020-12-15T14:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIxOTM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIyMTgxMg==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543221812", "bodyText": "This may suggest to create Logger, even if one is present, but not resolved (i.e. missing import).", "author": "sdedic", "createdAt": "2020-12-15T10:24:02Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/LoggerGenerator.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.logging.Logger;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.GeneratorUtilities;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class LoggerGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_LOGGER =  \"java.generate.logger\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_LOGGER);\n+    private final Gson gson = new Gson();\n+\n+    LoggerGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateLogger=Generate Logger...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass()) {\n+            return Collections.emptyList();\n+        }\n+        for (VariableElement ve : ElementFilter.fieldsIn(typeElement.getEnclosedElements())) {\n+            TypeMirror type = ve.asType();\n+            if (type.getKind() == TypeKind.DECLARED && ((TypeElement)((DeclaredType)type).asElement()).getQualifiedName().contentEquals(Logger.class.getName())) {\n+                return Collections.emptyList();\n+            }\n+        }\n+        String uri = Utils.toUri(info.getFileObject());", "originalCommit": "4165983e6b010879475ed67961486fe3b278e364", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM4OTI2Mw==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543389263", "bodyText": "Fixed.", "author": "dbalek", "createdAt": "2020-12-15T14:23:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIyMTgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIyMzU0MQ==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543223541", "bodyText": "Maybe check for value to be a valid identifier ?", "author": "sdedic", "createdAt": "2020-12-15T10:26:20Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/LoggerGenerator.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.logging.Logger;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.GeneratorUtilities;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class LoggerGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_LOGGER =  \"java.generate.logger\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_LOGGER);\n+    private final Gson gson = new Gson();\n+\n+    LoggerGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateLogger=Generate Logger...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass()) {\n+            return Collections.emptyList();\n+        }\n+        for (VariableElement ve : ElementFilter.fieldsIn(typeElement.getEnclosedElements())) {\n+            TypeMirror type = ve.asType();\n+            if (type.getKind() == TypeKind.DECLARED && ((TypeElement)((DeclaredType)type).asElement()).getQualifiedName().contentEquals(Logger.class.getName())) {\n+                return Collections.emptyList();\n+            }\n+        }\n+        String uri = Utils.toUri(info.getFileObject());\n+        return Collections.singletonList(createCodeAction(Bundle.DN_GenerateLogger(), CODE_GENERATOR_KIND, GENERATE_LOGGER, uri, offset));\n+    }\n+\n+    @Override\n+    public Set<String> getCommands() {\n+        return commands;\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_SelectLoggerName=Logger field name\",\n+    })\n+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {\n+        if (arguments.size() > 1) {\n+            String uri = gson.fromJson(gson.toJson(arguments.get(0)), String.class);\n+            int offset = gson.fromJson(gson.toJson(arguments.get(1)), Integer.class);\n+            client.showInputBox(new ShowInputBoxParams(Bundle.DN_SelectLoggerName(), \"LOG\")).thenAccept(value -> {\n+                if (value != null) {", "originalCommit": "4165983e6b010879475ed67961486fe3b278e364", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM4OTA2OQ==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543389069", "bodyText": "Fixed.", "author": "dbalek", "createdAt": "2020-12-15T14:23:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIyMzU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIyNzM4MQ==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543227381", "bodyText": "We should invent some 'registration', i.e. using @ServiceProvider, when expanding code gens next time.", "author": "sdedic", "createdAt": "2020-12-15T10:31:44Z", "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/Server.java", "diffHunk": "@@ -332,12 +338,19 @@ protected LanguageClient client() {\n     \n     public static final String JAVA_BUILD_WORKSPACE =  \"java.build.workspace\";\n     public static final String GRAALVM_PAUSE_SCRIPT =  \"graalvm.pause.script\";\n-    public static final String GENERATE_GETTERS =  \"java.generate.getters\";\n-    public static final String GENERATE_SETTERS =  \"java.generate.setters\";\n-    public static final String GENERATE_GETTERS_SETTERS =  \"java.generate.getters.setters\";\n     static final String INDEXING_COMPLETED = \"Indexing completed.\";\n     static final String NO_JAVA_SUPPORT = \"Cannot initialize Java support on JDK \";\n-    \n+\n+    static final CodeGenerator[] CODE_GENERATORS = new CodeGenerator[] {", "originalCommit": "4165983e6b010879475ed67961486fe3b278e364", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQxMDc2MA==", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543410760", "bodyText": "Done.", "author": "dbalek", "createdAt": "2020-12-15T14:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIyNzM4MQ=="}], "type": "inlineReview"}, {"oid": "11d0a382dbbae490c6f18c43b5ce243942b50907", "url": "https://github.com/apache/netbeans/commit/11d0a382dbbae490c6f18c43b5ce243942b50907", "message": "CodeGenerators modified bas on review.", "committedDate": "2020-12-15T14:50:28Z", "type": "commit"}]}