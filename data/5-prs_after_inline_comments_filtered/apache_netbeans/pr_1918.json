{"pr_number": 1918, "pr_title": "[NETBEANS-3785] Implement simplified HeapView widget", "pr_createdAt": "2020-02-04T12:10:06Z", "pr_url": "https://github.com/apache/netbeans/pull/1918", "timeline": [{"oid": "0e0d715c8271cda6867e5acb26dca7452195941b", "url": "https://github.com/apache/netbeans/commit/0e0d715c8271cda6867e5acb26dca7452195941b", "message": "Implement simplified HeapView widget\n\nThis fixes the appearance of the HeapView widget on HiDPI displays\n\nSee bug NETBEANS-3785", "committedDate": "2020-02-04T10:28:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5NjExOA==", "url": "https://github.com/apache/netbeans/pull/1918#discussion_r374796118", "bodyText": "You(?) mentioned earlier the idea of \"using the cheap & cheerful way of drawing the text twice, the first time displaced and in a darker colour\". Perhaps it would be good to include this to create a little contrast between the text and the graph below? E.g.:\ng.setColor(Color.BLACK);\ng.drawString(text, x + 1, y + 1);\ng.setColor(TEXT_COLOR);\ng.drawString(text, x, y);", "author": "eirikbakke", "createdAt": "2020-02-04T16:55:31Z", "path": "platform/openide.actions/src/org/openide/actions/HeapView.java", "diffHunk": "@@ -465,526 +225,174 @@ private void updateTextWidth() {\n      *\n      * @param e the MouseEvent\n      */\n-    @Override protected void processMouseEvent(MouseEvent e) {\n+    @Override\n+    protected void processMouseEvent(MouseEvent e) {\n         super.processMouseEvent(e);\n         if (!e.isConsumed()) {\n             if (e.isPopupTrigger()) {\n                 // Show a popup allowing to configure the various options\n                 showPopup(e.getX(), e.getY());\n-            }  else if (e.getID() == MouseEvent.MOUSE_ENTERED) {\n-                containsMouse = true;\n-                cachedBorderVaild = false;\n-                repaint();\n-            } else if (e.getID() == MouseEvent.MOUSE_EXITED) {\n-                containsMouse = false;\n-                cachedBorderVaild = false;\n-                repaint();\n             }\n+        }\n \n-        } \n-        \n-        if (e.getID() == MouseEvent.MOUSE_CLICKED &&\n-                SwingUtilities.isLeftMouseButton(e) && \n-                e.getClickCount() == 1) {\n+        if (e.getID() == MouseEvent.MOUSE_CLICKED\n+                && SwingUtilities.isLeftMouseButton(e)\n+                && e.getClickCount() == 1) {\n             // Trigger a gc\n-            GarbageCollectAction.get(GarbageCollectAction.class).performAction();;\n+            GarbageCollectAction.get(GarbageCollectAction.class).performAction();\n         }\n     }\n \n     /**\n-     * Shows a popup at the specified location that allows you to configure\n-     * the various options.\n+     * Shows a popup at the specified location that allows you to configure the\n+     * various options.\n      */\n     private void showPopup(int x, int y) {\n         JPopupMenu popup = new JPopupMenu();\n         JCheckBoxMenuItem cbmi = new JCheckBoxMenuItem(NbBundle.getMessage(HeapView.class, \"LBL_ShowText\"));\n         cbmi.setSelected(getShowText());\n         cbmi.addActionListener(new ActionListener() {\n             public void actionPerformed(ActionEvent e) {\n-                setShowText(((JCheckBoxMenuItem)e.getSource()).\n+                setShowText(((JCheckBoxMenuItem) e.getSource()).\n                         isSelected());\n             }\n         });\n         popup.add(cbmi);\n-        cbmi = new JCheckBoxMenuItem(NbBundle.getMessage(HeapView.class, \"LBL_DropShadow\"));\n-        cbmi.setSelected(getShowDropShadow());\n-        cbmi.addActionListener(new ActionListener() {\n-            public void actionPerformed(ActionEvent e) {\n-                setShowDropShadow(((JCheckBoxMenuItem)e.getSource()).\n-                        isSelected());\n-            }\n-        });\n-        popup.add(cbmi);\n-        cbmi = new JCheckBoxMenuItem(NbBundle.getMessage(HeapView.class, \"LBL_OverlayGrid\"));\n-        cbmi.setSelected(getTickStyle() == STYLE_OVERLAY);\n-        cbmi.addActionListener(new ActionListener() {\n-            public void actionPerformed(ActionEvent e) {\n-                int style = ((JCheckBoxMenuItem)e.getSource()).\n-                        isSelected() ? STYLE_OVERLAY : STYLE_DEFAULT;\n-                setTickStyle(style);\n-            }\n-        });\n-        popup.add(cbmi);\n         popup.show(this, x, y);\n     }\n \n-    /**\n-     * Returns the first index to start rendering from.\n-     */\n-    private int getGraphStartIndex() {\n-        if (graphFilled) {\n-            return graphIndex;\n-        } else {\n-            return 0;\n-        }\n-    }\n-\n     /**\n      * Paints the component.\n      */\n-    @Override protected void paintComponent(Graphics g) {\n-        Graphics2D g2 = (Graphics2D)g;\n+    @Override\n+    protected void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n         int width = getWidth();\n         int height = getHeight();\n-        if (width - BORDER_W > 0 && height - BORDER_H > 0) {\n+\n+        if (width > 0 && height > 0) {\n             startTimerIfNecessary();\n-            updateCacheIfNecessary(width, height);\n-            paintCachedBackground(g2, width, height);\n-            g.translate(1, 2);\n-            if (containsMouse) {\n-                g.clipRect(1, 0, width - 4, height - 4);\n-            }\n-            else {\n-                g.clipRect(0, 0, width - 2, height - 4);\n-            }\n-            int innerW = width - BORDER_W;\n-            int innerH = height - BORDER_H;\n-            if (heapGrowTimer != null) {\n-                // Render the heap growing animation.\n-                Composite lastComposite = ((Graphics2D)g).getComposite();\n-                float percent = 1f - heapGrowTimer.getPercent();\n-                ((Graphics2D)g).setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, percent));\n-                g.drawImage(heapGrowTimer.image, 0, 0, null);\n-                ((Graphics2D)g).setComposite(lastComposite);\n-            }\n-            paintTicks(g2, innerW, innerH);\n-            if (getTickStyle() == STYLE_OVERLAY) {\n-                g2.drawImage(getGridOverlayImage(), 0, 0, null);\n-            }\n+            Graphics2D g2 = (Graphics2D) g;\n+            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n+            // Fill background\n+            g2.setPaint(BACKGROUND_COLOR);\n+            g2.fillRect(0, 0, width + 1, height + 1);\n+            // Draw samples\n+            g2.setPaint(CHART_COLOR);\n+            paintSamples(g2, width, height);\n+            // Draw text if enabled\n             if (getShowText()) {\n-                if (getShowDropShadow()) {\n-                    paintDropShadowText(g, innerW, innerH);\n-                } else {\n-                    g.setColor(textColor);\n-                    paintText(g, innerW, innerH);\n-                }\n+                paintText(g2, width, height);\n             }\n-            g.translate(-1, -2);\n         } else {\n             stopTimerIfNecessary();\n-            // To honor opaque contract, fill in the background\n-            g.setColor(getBackground());\n-            g.fillRect(0, 0, width, height);\n-        }\n-    }\n-    \n-    private void paintTicks(Graphics2D g, int width, int height) {\n-        if (graphIndex > 0 || graphFilled) {\n-            int index = getGraphStartIndex();\n-            int x = 0;\n-            if (!graphFilled) {\n-                x = width - graphIndex;\n-            }\n-            float[] localGraph = graph;\n-            if (localGraph == null) {\n-                return;\n-            }\n-            float min = localGraph[index];\n-            index = (index + 1) % localGraph.length;\n-            while (index != graphIndex) {\n-                min = Math.min(min, localGraph[index]);\n-                index = (index + 1) % localGraph.length;\n-            }\n-            int minHeight = (int)(min * (float)height);\n-            if (minHeight > 0) {\n-               g.drawImage(tickGradientImage, x, height - minHeight, width, height,\n-                        x, height - minHeight, width, height, null);\n-            }\n-            index = getGraphStartIndex();\n-            do {\n-                int tickHeight = (int)(localGraph[index] * (float)height);\n-                if (tickHeight > minHeight) {\n-                    g.drawImage(tickGradientImage, x, height - tickHeight, x + 1, height - minHeight,\n-                            x, height - tickHeight, x + 1, height - minHeight, null);\n-                }\n-                index = (index + 1) % localGraph.length;\n-                x++;\n-            } while (index != graphIndex);\n         }\n     }\n \n     /**\n-     * Renders the text.\n+     * Renders the text using an optional drop shadow.\n      */\n-    private void paintText(Graphics g, int w, int h) {\n+    private void paintText(Graphics2D g, int w, int h) {\n         g.setFont(getFont());\n         String text = getHeapSizeText();\n         FontMetrics fm = g.getFontMetrics();\n         int textWidth = fm.stringWidth(text);\n-        g.drawString(text, (w - maxTextWidth) / 2 + (maxTextWidth - textWidth), \n-                h / 2 + fm.getAscent() / 2 - 2);\n+        int x = (w - maxTextWidth) / 2 + (maxTextWidth - textWidth);\n+        int y = h / 2 + fm.getAscent() / 2 - 2;\n+        g.setColor(TEXT_COLOR);\n+        g.drawString(text, x, y);", "originalCommit": "0e0d715c8271cda6867e5acb26dca7452195941b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkxMzMyMg==", "url": "https://github.com/apache/netbeans/pull/1918#discussion_r374913322", "bodyText": "It was me.. I had that and took it out because it didn't seem to add much to the clarity in the original scheme. Here it is with/without drop shadow, using your theme colours of 0x2e90e8/0xCEDBE6\n\n\nI think there is insufficient contrast between white text and the pale blue, even with the drop shadow. May be better to go black text, what do you think?", "author": "pedro-w", "createdAt": "2020-02-04T20:46:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5NjExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkyMzAzNg==", "url": "https://github.com/apache/netbeans/pull/1918#discussion_r374923036", "bodyText": "I think black is too much, makes it look more important than all the other buttons on the ribbon.\n\nHow about #404040?\n\nOr even not bold?\n\nSorry for bike shedding!", "author": "pedro-w", "createdAt": "2020-02-04T21:07:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5NjExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkyNzYwOQ==", "url": "https://github.com/apache/netbeans/pull/1918#discussion_r374927609", "bodyText": "Perhaps try black at 85% alpha. Would be good to take out the bold, too, yes.\nI also experimented (in Photoshop) with adding a semitransparent dark border (black at 25% alpha) to make the background go better with the surroundings. See screenshot. Though it's a little tricky to paint borders that don't become blurry on fractional HiDPI scalings (o.n.swing.plaf/src/org/netbeans/swing/plaf/windows8/DPIUnscaledBorder.java  shows an example), so that can be postponed...", "author": "eirikbakke", "createdAt": "2020-02-04T21:17:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5NjExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIwNjg3OA==", "url": "https://github.com/apache/netbeans/pull/1918#discussion_r375206878", "bodyText": "I did some more experiments and it seemed that the dark gray was legible without being too prominent. Rendering with alpha didn't seem to make it better. Agree on the border looking good but please can we defer this for the next version!", "author": "pedro-w", "createdAt": "2020-02-05T11:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5NjExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5Mjc5NQ==", "url": "https://github.com/apache/netbeans/pull/1918#discussion_r375392795", "bodyText": "Yes, happy to defer further improvements! I might look into adding a DPI-safe border myself at some point, after these bigger changes are merged.", "author": "eirikbakke", "createdAt": "2020-02-05T17:15:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5NjExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5ODIxMg==", "url": "https://github.com/apache/netbeans/pull/1918#discussion_r374798212", "bodyText": "Perfect--this seems like exactly the right way to draw this, with anti-aliased lines and everything.", "author": "eirikbakke", "createdAt": "2020-02-04T16:58:54Z", "path": "platform/openide.actions/src/org/openide/actions/HeapView.java", "diffHunk": "@@ -465,526 +225,174 @@ private void updateTextWidth() {\n      *\n      * @param e the MouseEvent\n      */\n-    @Override protected void processMouseEvent(MouseEvent e) {\n+    @Override\n+    protected void processMouseEvent(MouseEvent e) {\n         super.processMouseEvent(e);\n         if (!e.isConsumed()) {\n             if (e.isPopupTrigger()) {\n                 // Show a popup allowing to configure the various options\n                 showPopup(e.getX(), e.getY());\n-            }  else if (e.getID() == MouseEvent.MOUSE_ENTERED) {\n-                containsMouse = true;\n-                cachedBorderVaild = false;\n-                repaint();\n-            } else if (e.getID() == MouseEvent.MOUSE_EXITED) {\n-                containsMouse = false;\n-                cachedBorderVaild = false;\n-                repaint();\n             }\n+        }\n \n-        } \n-        \n-        if (e.getID() == MouseEvent.MOUSE_CLICKED &&\n-                SwingUtilities.isLeftMouseButton(e) && \n-                e.getClickCount() == 1) {\n+        if (e.getID() == MouseEvent.MOUSE_CLICKED\n+                && SwingUtilities.isLeftMouseButton(e)\n+                && e.getClickCount() == 1) {\n             // Trigger a gc\n-            GarbageCollectAction.get(GarbageCollectAction.class).performAction();;\n+            GarbageCollectAction.get(GarbageCollectAction.class).performAction();\n         }\n     }\n \n     /**\n-     * Shows a popup at the specified location that allows you to configure\n-     * the various options.\n+     * Shows a popup at the specified location that allows you to configure the\n+     * various options.\n      */\n     private void showPopup(int x, int y) {\n         JPopupMenu popup = new JPopupMenu();\n         JCheckBoxMenuItem cbmi = new JCheckBoxMenuItem(NbBundle.getMessage(HeapView.class, \"LBL_ShowText\"));\n         cbmi.setSelected(getShowText());\n         cbmi.addActionListener(new ActionListener() {\n             public void actionPerformed(ActionEvent e) {\n-                setShowText(((JCheckBoxMenuItem)e.getSource()).\n+                setShowText(((JCheckBoxMenuItem) e.getSource()).\n                         isSelected());\n             }\n         });\n         popup.add(cbmi);\n-        cbmi = new JCheckBoxMenuItem(NbBundle.getMessage(HeapView.class, \"LBL_DropShadow\"));\n-        cbmi.setSelected(getShowDropShadow());\n-        cbmi.addActionListener(new ActionListener() {\n-            public void actionPerformed(ActionEvent e) {\n-                setShowDropShadow(((JCheckBoxMenuItem)e.getSource()).\n-                        isSelected());\n-            }\n-        });\n-        popup.add(cbmi);\n-        cbmi = new JCheckBoxMenuItem(NbBundle.getMessage(HeapView.class, \"LBL_OverlayGrid\"));\n-        cbmi.setSelected(getTickStyle() == STYLE_OVERLAY);\n-        cbmi.addActionListener(new ActionListener() {\n-            public void actionPerformed(ActionEvent e) {\n-                int style = ((JCheckBoxMenuItem)e.getSource()).\n-                        isSelected() ? STYLE_OVERLAY : STYLE_DEFAULT;\n-                setTickStyle(style);\n-            }\n-        });\n-        popup.add(cbmi);\n         popup.show(this, x, y);\n     }\n \n-    /**\n-     * Returns the first index to start rendering from.\n-     */\n-    private int getGraphStartIndex() {\n-        if (graphFilled) {\n-            return graphIndex;\n-        } else {\n-            return 0;\n-        }\n-    }\n-\n     /**\n      * Paints the component.\n      */\n-    @Override protected void paintComponent(Graphics g) {\n-        Graphics2D g2 = (Graphics2D)g;\n+    @Override\n+    protected void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n         int width = getWidth();\n         int height = getHeight();\n-        if (width - BORDER_W > 0 && height - BORDER_H > 0) {\n+\n+        if (width > 0 && height > 0) {\n             startTimerIfNecessary();\n-            updateCacheIfNecessary(width, height);\n-            paintCachedBackground(g2, width, height);\n-            g.translate(1, 2);\n-            if (containsMouse) {\n-                g.clipRect(1, 0, width - 4, height - 4);\n-            }\n-            else {\n-                g.clipRect(0, 0, width - 2, height - 4);\n-            }\n-            int innerW = width - BORDER_W;\n-            int innerH = height - BORDER_H;\n-            if (heapGrowTimer != null) {\n-                // Render the heap growing animation.\n-                Composite lastComposite = ((Graphics2D)g).getComposite();\n-                float percent = 1f - heapGrowTimer.getPercent();\n-                ((Graphics2D)g).setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, percent));\n-                g.drawImage(heapGrowTimer.image, 0, 0, null);\n-                ((Graphics2D)g).setComposite(lastComposite);\n-            }\n-            paintTicks(g2, innerW, innerH);\n-            if (getTickStyle() == STYLE_OVERLAY) {\n-                g2.drawImage(getGridOverlayImage(), 0, 0, null);\n-            }\n+            Graphics2D g2 = (Graphics2D) g;\n+            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n+            // Fill background\n+            g2.setPaint(BACKGROUND_COLOR);\n+            g2.fillRect(0, 0, width + 1, height + 1);\n+            // Draw samples\n+            g2.setPaint(CHART_COLOR);\n+            paintSamples(g2, width, height);\n+            // Draw text if enabled\n             if (getShowText()) {\n-                if (getShowDropShadow()) {\n-                    paintDropShadowText(g, innerW, innerH);\n-                } else {\n-                    g.setColor(textColor);\n-                    paintText(g, innerW, innerH);\n-                }\n+                paintText(g2, width, height);\n             }\n-            g.translate(-1, -2);\n         } else {\n             stopTimerIfNecessary();\n-            // To honor opaque contract, fill in the background\n-            g.setColor(getBackground());\n-            g.fillRect(0, 0, width, height);\n-        }\n-    }\n-    \n-    private void paintTicks(Graphics2D g, int width, int height) {\n-        if (graphIndex > 0 || graphFilled) {\n-            int index = getGraphStartIndex();\n-            int x = 0;\n-            if (!graphFilled) {\n-                x = width - graphIndex;\n-            }\n-            float[] localGraph = graph;\n-            if (localGraph == null) {\n-                return;\n-            }\n-            float min = localGraph[index];\n-            index = (index + 1) % localGraph.length;\n-            while (index != graphIndex) {\n-                min = Math.min(min, localGraph[index]);\n-                index = (index + 1) % localGraph.length;\n-            }\n-            int minHeight = (int)(min * (float)height);\n-            if (minHeight > 0) {\n-               g.drawImage(tickGradientImage, x, height - minHeight, width, height,\n-                        x, height - minHeight, width, height, null);\n-            }\n-            index = getGraphStartIndex();\n-            do {\n-                int tickHeight = (int)(localGraph[index] * (float)height);\n-                if (tickHeight > minHeight) {\n-                    g.drawImage(tickGradientImage, x, height - tickHeight, x + 1, height - minHeight,\n-                            x, height - tickHeight, x + 1, height - minHeight, null);\n-                }\n-                index = (index + 1) % localGraph.length;\n-                x++;\n-            } while (index != graphIndex);\n         }\n     }\n \n     /**\n-     * Renders the text.\n+     * Renders the text using an optional drop shadow.\n      */\n-    private void paintText(Graphics g, int w, int h) {\n+    private void paintText(Graphics2D g, int w, int h) {\n         g.setFont(getFont());\n         String text = getHeapSizeText();\n         FontMetrics fm = g.getFontMetrics();\n         int textWidth = fm.stringWidth(text);\n-        g.drawString(text, (w - maxTextWidth) / 2 + (maxTextWidth - textWidth), \n-                h / 2 + fm.getAscent() / 2 - 2);\n+        int x = (w - maxTextWidth) / 2 + (maxTextWidth - textWidth);\n+        int y = h / 2 + fm.getAscent() / 2 - 2;\n+        g.setColor(TEXT_COLOR);\n+        g.drawString(text, x, y);\n     }\n \n-    /**\n-     * Renders the text using a drop shadow.\n-     */\n-    private void paintDropShadowText(Graphics g, final int w, final int h) {\n-        BufferedImage dsi = dropShadowImage;\n-        BufferedImage tsi = textImage;\n-        if (dsi != null && tsi != null) {\n-            // And finally copy it.\n-            Graphics2D blurryImageG = dsi.createGraphics();\n-            blurryImageG.setComposite(AlphaComposite.Clear);\n-            blurryImageG.fillRect(0, 0, w, h);\n-            blurryImageG.setComposite(AlphaComposite.SrcOver);\n-            blurryImageG.drawImage(tsi, blur, SHIFT_X, SHIFT_Y);\n-            blurryImageG.setColor(textColor);\n-            blurryImageG.setFont(getFont());\n-\n-            // Step 3: render the text again on top.\n-            paintText(blurryImageG, w, h);\n-            blurryImageG.dispose();\n-            g.drawImage(dsi, 0, 0, null);\n-        } else {\n-            class InitTextAndDropShadow implements Runnable {\n-                @Override\n-                public void run() {\n-                    BufferedImage ti = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n-                    BufferedImage ds = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n-                    // Step 1: render the text.\n-                    Graphics2D textImageG = ti.createGraphics();\n-                    textImageG.setComposite(AlphaComposite.Clear);\n-                    textImageG.fillRect(0, 0, w, h);\n-                    textImageG.setComposite(AlphaComposite.SrcOver);\n-                    textImageG.setColor(textBlurColor);\n-                    paintText(textImageG, w, h);\n-                    textImageG.dispose();\n-\n-                    textImage = ti;\n-                    dropShadowImage = ds;\n-                    repaint();\n-                }\n-            }\n-            RP.post(new InitTextAndDropShadow());\n-        }\n-    }\n-    \n     private String getHeapSizeText() {\n         return heapSizeText;\n     }\n-    \n-    /**\n-     * Paints the grid on top of the ticks.\n-     */\n-    private void paintGridOverlay(Graphics2D g, int w, int h) {\n-        int numCells = GRID_COLORS.length / 2;\n-        int cellSize = (h - numCells - 1) / numCells;\n-        int c1 = 0xD0CCBC;\n-        int c2 = 0xEAE7D7;\n-        g.setPaint(new GradientPaint(\n-                0, 0, new Color((c1 >> 16) & 0xFF, (c1 >> 8) & 0xFF, c1 & 0xFF, 0x30),\n-                0, h, new Color((c2 >> 16) & 0xFF, (c2 >> 8) & 0xFF, c2 & 0xFF, 0x40)));\n-        for (int x = 0; x < w; x += cellSize + 1) {\n-            g.fillRect(x, 0, 1, h);\n-        }\n-        for (int y = h - cellSize - 1; y >= 0; y -= (cellSize + 1)) {\n-            g.fillRect(0, y, w, 1);\n-        }\n-    }\n \n-    private void paintCachedBackground(Graphics2D g, int w, int h) {\n-        if (bgImage != null) {\n-            g.drawImage(bgImage, 0, 0, null);\n-        }\n-    }\n-    \n-    private void paintBackgroundTiles(Graphics2D g, int w, int h) {\n-        g.translate(1, 2);\n-        w -= BORDER_W;\n-        h -= BORDER_H;\n-        int numCells = GRID_COLORS.length / 2;\n-        int cellSize = (h - numCells - 1) / numCells;\n-        for (int i = 0; i < numCells; i++) {\n-            int colorIndex = i;\n-            int y = h - cellSize * (i + 1) - i;\n-            int x = 1;\n-            g.setPaint(new GradientPaint(0, y, GRID_COLORS[colorIndex * 2],\n-                    0, y + cellSize - 1, GRID_COLORS[colorIndex * 2 + 1]));\n-            while (x < w) {\n-                int endX = Math.min(w, x + cellSize);\n-                g.fillRect(x, y, endX - x, cellSize);\n-                x = endX + 1;\n-            }\n-            y += cellSize + 1;\n-        }\n-        g.translate(-1, -2);\n-    }\n-    \n-    private void paintBackground(Graphics2D g, int w, int h) {\n-        g.setPaint(new GradientPaint(0, 0, background1Color,\n-                0, h, background2Color));\n-        g.fillRect(0, 0, w, h);\n-    }\n-    \n-    private void paintBorder(Graphics g, int w, int h) {\n-        // Draw the border\n-        if (containsMouse) {\n-            g.setColor(border3Color);\n-            g.drawRect(0, 0, w - 1, h - 1);\n-            g.drawRect(1, 1, w - 3, h - 3);\n-        }\n-        else {\n-            g.setColor(border1Color);\n-            g.drawRect(0, 0, w - 1, h - 2);\n-            g.setColor(border2Color);\n-            g.fillRect(1, 1, w - 2, 1);\n-            g.setColor(border3Color);\n-            g.fillRect(0, h - 1, w, 1);\n-        }\n-    }\n-    \n-    private void updateCacheIfNecessary(int w, int h) {\n-        if (cachedWidth != w || cachedHeight != h || !cachedBorderVaild) {\n-            cachedWidth = w;\n-            cachedHeight = h;\n-            cachedBorderVaild = true;\n-            updateCache(w, h);\n-        }\n-    }\n-    \n-    private Image getGridOverlayImage() {\n-        if (gridOverlayImage == null) {\n-            gridOverlayImage = new BufferedImage(\n-                    getInnerWidth(), getInnerHeight(),\n-                    BufferedImage.TYPE_INT_ARGB);\n-            Graphics2D g = gridOverlayImage.createGraphics();\n-            paintGridOverlay(g, getInnerWidth(), getInnerHeight());\n-            g.dispose();\n-        }\n-        return gridOverlayImage;\n-    }\n-\n-    /**\n-     * Recreates the various state information needed for rendering.\n-     */\n-    private void updateCache(int w, int h) {\n-        disposeImages();\n-        textImage = null;\n-        dropShadowImage = null;\n-        bgImage = createImage(w, h);\n-        if (bgImage == null) {\n-            return;\n-        }\n-        Graphics2D imageG = (Graphics2D)bgImage.getGraphics();\n-        paintBackground(imageG, w, h);\n-        paintBackgroundTiles(imageG, w, h);\n-        paintBorder(imageG, w, h);\n-        imageG.dispose();\n-        w -= BORDER_W;\n-        h -= BORDER_H;\n-        if (graph == null || graph.length != w) {\n-            graph = new float[w];\n-            graphFilled = false;\n-            graphIndex = 0;\n-        }\n-        GradientPaint tickGradient = new GradientPaint(0, h, minTickColor,\n-                w, 0, maxTickColor);\n-        tickGradientImage = createImage(w, h);\n-        imageG = (Graphics2D)tickGradientImage.getGraphics();\n-        imageG.setPaint(tickGradient);\n-        imageG.fillRect(0, 0, w, h);\n-        imageG.dispose();\n-        if (gridOverlayImage != null) {\n-            gridOverlayImage.flush();\n-            gridOverlayImage = null;\n-        }\n-    }\n-    \n     /**\n      * Invoked when component removed from a heavy weight parent. Stops the\n      * timer.\n      */\n-    @Override public void removeNotify() {\n+    @Override\n+    public void removeNotify() {\n         super.removeNotify();\n         stopTimerIfNecessary();\n     }\n-    \n+\n     /**\n      * Restarts the timer.\n      */\n     private void startTimerIfNecessary() {\n-        if (!AUTOMATIC_REFRESH)\n+        if (!AUTOMATIC_REFRESH) {\n             return;\n-        \n+        }\n         if (updateTimer == null) {\n-            updateTimer = new Timer(TICK, new ActionHandler());\n+            updateTimer = new Timer(TICK, new ActionListener() {\n+                @Override\n+                public void actionPerformed(ActionEvent e) {\n+                    update();\n+                }\n+            });\n             updateTimer.setRepeats(true);\n             updateTimer.start();\n         }\n     }\n-    \n+\n     /**\n      * Stops the timer.\n      */\n     private void stopTimerIfNecessary() {\n         if (updateTimer != null) {\n-            graph = null;\n-            graphFilled = false;\n             updateTimer.stop();\n             updateTimer = null;\n             lastTotal = 0;\n-            disposeImages();\n-            cachedHeight = cachedHeight = -1;\n-            if (heapGrowTimer != null) {\n-                heapGrowTimer.stop();\n-                heapGrowTimer = null;\n-            }\n+            Arrays.fill(graph, 0);\n+            heapSizeText = \"\";\n         }\n     }\n \n-    private void disposeImages() {\n-        if (bgImage != null) {\n-            bgImage.flush();\n-            bgImage = null;\n-        }\n-        if (textImage != null) {\n-            textImage.flush();\n-            textImage = null;\n-        }\n-        if (dropShadowImage != null) {\n-            dropShadowImage.flush();\n-            dropShadowImage = null;\n-        }\n-        if (tickGradientImage != null) {\n-            tickGradientImage.flush();\n-            tickGradientImage = null;\n-        }\n-        if (gridOverlayImage != null) {\n-            gridOverlayImage.flush();\n-            gridOverlayImage = null;\n-        }\n-    }\n-    \n     /**\n      * Invoked when the update timer fires. Updates the necessary data\n      * structures and triggers repaints.\n      */\n     private void update() {\n-        if (!isShowing()) {\n+        if (isShowing()) {\n+            Runtime r = Runtime.getRuntime();\n+            long total = r.totalMemory();\n+            long used = total - r.freeMemory();\n+            graph[graphIndex] = used;\n+            lastTotal = total;\n+            ++graphIndex;\n+            if (graphIndex >= GRAPH_COUNT) {\n+                graphIndex = 0;\n+            }\n+            heapSizeText = format.format(\n+                    new Object[]{(double) used / (1024.0 * 1024.0), (double) total / (1024.0 * 1024.0)});\n+            repaint();\n+        } else {\n             // Either we've become invisible, or one of our ancestors has.\n             // Stop the timer and bale. Next paint will trigger timer to\n             // restart.\n             stopTimerIfNecessary();\n-            return;\n-        }\n-        Runtime r = Runtime.getRuntime();\n-        long total = r.totalMemory();\n-        float[] localGraph = graph;\n-        if (localGraph == null) {\n-            return;\n-        }\n-        if (total != lastTotal) {\n-            if (lastTotal != 0) {\n-                // Total heap size has changed, start an animation.\n-                startHeapAnimate();\n-                // Readjust the graph size based on the new max.\n-                int index = getGraphStartIndex();\n-                do {\n-                    localGraph[index] = (float)(((double)localGraph[index] *\n-                            (double)lastTotal) / (double)total);\n-                    index = (index + 1) % localGraph.length;\n-                } while (index != graphIndex);\n-            }\n-            lastTotal = total;\n-        }\n-        if (heapGrowTimer == null) {\n-            // Not animating a heap size change, update the graph data and text.\n-            long used = total - r.freeMemory();\n-            localGraph[graphIndex] = (float)((double)used / (double)total);\n-            graphIndex = (graphIndex + 1) % localGraph.length;\n-            if (graphIndex == 0) {\n-                graphFilled = true;\n-            }\n-            heapSizeText = format.format(\n-                    new Object[] { new Double((double)used / 1024 / 1024),\n-                                   new Double((double)total / 1024 / 1024) });\n-        }\n-        repaint();\n-    }\n-    \n-    private void startHeapAnimate() {\n-        if (heapGrowTimer == null) {\n-            heapGrowTimer = new HeapGrowTimer();\n-            heapGrowTimer.start();\n-        }\n-    }\n-    \n-    private void stopHeapAnimate() {\n-        if (heapGrowTimer != null) {\n-            heapGrowTimer.stop();\n-            heapGrowTimer = null;\n         }\n     }\n \n-    private int getInnerWidth() {\n-        return getWidth() - BORDER_W;\n-    }\n-\n-    private int getInnerHeight() {\n-        return getHeight() - BORDER_H;\n-    }\n-\n-    \n-    private final class ActionHandler implements ActionListener {\n-        public void actionPerformed(ActionEvent e) {\n-            update();\n-        }\n-    }\n-    \n-    \n-    private final class HeapGrowTimer extends Timer {\n-        private final long startTime;\n-        private float percent;\n-        BufferedImage image;\n-        \n-        HeapGrowTimer() {\n-            super(30, null);\n-            setRepeats(true);\n-            startTime = System.currentTimeMillis();\n-            percent = 0f;\n-            int w = getWidth() - BORDER_W;\n-            int h = getHeight() - BORDER_H;\n-            image = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n-            Graphics2D g = image.createGraphics();\n-            paintTicks(g, w, h);\n-            g.dispose();\n-        }\n-        \n-        public float getPercent() {\n-            return percent;\n-        }\n-        \n-        @Override protected void fireActionPerformed(ActionEvent e) {\n-            long time = System.currentTimeMillis();\n-            long delta = Math.max(0L, time - startTime);\n-            if (delta > HEAP_GROW_ANIMATE_TIME) {\n-                stopHeapAnimate();\n-            } else {\n-                percent = (float)delta / (float)HEAP_GROW_ANIMATE_TIME;\n-                repaint();\n-            }\n-        }\n+    /**\n+     * Draw the graph with the heap samples. It is a simple area chart.\n+     *\n+     * @param g Where to draw\n+     * @param width The width of the chart\n+     * @param height The height of the chart\n+     */\n+    private void paintSamples(Graphics2D g, int width, int height) {\n+        Path2D path = new Path2D.Double();\n+        path.moveTo(0, height);\n+        for (int i = 0; i < GRAPH_COUNT; ++i) {\n+            int index = (i + graphIndex) % GRAPH_COUNT;\n+            double x = (double) i / (double) (GRAPH_COUNT - 1) * (double) width;\n+            double y = (double) height * (1.0 - (double) graph[index] / (double) lastTotal);\n+            path.lineTo(x, y);\n+        }\n+        path.lineTo(width, height);\n+        path.closePath();\n+        g.fill(path);", "originalCommit": "0e0d715c8271cda6867e5acb26dca7452195941b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwMTk1OA==", "url": "https://github.com/apache/netbeans/pull/1918#discussion_r374801958", "bodyText": "For this one, trying using 0x2e90e8 instead. That's the lighter blue color from the NetBeans logo cube. (Might also want to grep the codebase for customizations of nb.heapview.maxtick.color, and change it there as well.)", "author": "eirikbakke", "createdAt": "2020-02-04T17:05:18Z", "path": "platform/openide.actions/src/org/openide/actions/HeapView.java", "diffHunk": "@@ -47,301 +42,104 @@\n import javax.swing.UIManager;\n import org.openide.util.NbBundle;\n import org.openide.util.NbPreferences;\n-import org.openide.util.RequestProcessor;\n \n /**\n  *\n  * @author sky, radim\n  */\n class HeapView extends JComponent {\n+\n     private static final boolean AUTOMATIC_REFRESH = System.getProperty(\"org.netbeans.log.startup\") == null;\n \n-    /**\n-     * Style for overlay on top of grid.\n-     */\n-    private static final int STYLE_DEFAULT = 0;\n-    \n-    /**\n-     * Grid overlayed on top of heap. This is the default.\n-     */\n-    private static final int STYLE_OVERLAY = 1;\n-    \n     /*\n      * How often the display is updated.\n      */\n     private static final int TICK = 1500;\n-    \n-    /**\n-     * Time (in ms) to animate heap growing.\n-     */\n-    private static final int HEAP_GROW_ANIMATE_TIME = 1000;\n-    \n-    /**\n-     * Width of the border.\n-     */\n-    private static final int BORDER_W = 2;\n-    \n-    /**\n-     * Height of the border area.\n-     */\n-    private static final int BORDER_H = 4;\n-    \n-    /**\n-     * Colors for the grid. This is alternating pairs for a linear gradient.\n-     */\n-    private static final Color[] GRID_COLORS = new Color[8];\n-    \n-    /**\n-     * Border color.\n-     */\n-    private static Color border1Color;\n \n     /**\n-     * Border color of line below the top.\n+     * Foreground color for the chart.\n      */\n-    private static Color border2Color;\n+    private static final Color CHART_COLOR;\n \n-    private static Color border3Color;\n-    \n     /**\n-     * Start color for the tick gradient.\n+     * Color for text.\n      */\n-    private static Color minTickColor;\n+    private static final Color TEXT_COLOR;\n \n     /**\n-     * End color for the tick gradient.\n+     * Color for the background.\n      */\n-    private static Color maxTickColor;\n+    private static final Color BACKGROUND_COLOR;\n \n     /**\n-     * Color for the text before blurred.\n+     * Number of samples to retain in history.\n      */\n-    private static Color textBlurColor;\n+    private static final int GRAPH_COUNT = 100;\n     \n     /**\n-     * Color for text drawn on top of blurred text.\n+     * Key for the Show Text preference.\n      */\n-    private static Color textColor;\n-\n-    /**\n-     * Start color for the background gradient.\n-     */\n-    private static Color background1Color;\n-\n-    /**\n-     * End color for the background gradient.\n-     */\n-    private static Color background2Color;\n-    \n-    /**\n-     * Size used for Kernel used to generate drop shadow.\n-     */\n-    private static final int KERNEL_SIZE = 3;\n-\n-    /**\n-     * Factor used for Kernel used to generate drop shadow.\n-     */\n-    private static final float BLUR_FACTOR = 0.1f;\n-    \n-    /**\n-     * How far to shift the drop shadow along the horizontal axis.\n-     */\n-    private static final int SHIFT_X = 0;\n-\n-    /**\n-     * How far to shift the drop shadow along the vertical axis.\n-     */\n-    private static final int SHIFT_Y = 1;\n+    private static final String SHOW_TEXT = \"showText\";\n \n     static {\n         //init colors\n-        Color c = UIManager.getColor( \"nb.heapview.border1\" ); //NOI18N\n-        if( null == c )\n-            c = new Color(0xA6A295);\n-        border1Color = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.border2\" ); //NOI18N\n-        if( null == c )\n-            c = new Color(0xC0BCAD);\n-        border2Color = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.border3\" ); //NOI18N\n-        if( null == c )\n-            c = Color.WHITE;\n-        border3Color = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.mintick.color\" ); //NOI18N\n-        if( null == c )\n-            c = new Color(0xC7D6AD);\n-        minTickColor = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.maxtick.color\" ); //NOI18N\n-        if( null == c )\n+        Color c = UIManager.getColor(\"nb.heapview.maxtick.color\"); //NOI18N\n+        if (null == c) {\n             c = new Color(0x615d0f);", "originalCommit": "0e0d715c8271cda6867e5acb26dca7452195941b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwMzE5OA==", "url": "https://github.com/apache/netbeans/pull/1918#discussion_r374803198", "bodyText": "For this one, use 0xCEDBE6 instead. That will go well with the other suggested color change. (It's the light blueish shadow in the NetBeans logo cube.)\nPerhaps also rename this one to nb.heapview.background (without the 1 at the end). This will nullify any LAF customizations from the past, but with the updated branding-consistent colors, that should be fine. New tweaks can be made e.g. for FlatLAF based on the blueish on-brand colors.", "author": "eirikbakke", "createdAt": "2020-02-04T17:07:30Z", "path": "platform/openide.actions/src/org/openide/actions/HeapView.java", "diffHunk": "@@ -47,301 +42,104 @@\n import javax.swing.UIManager;\n import org.openide.util.NbBundle;\n import org.openide.util.NbPreferences;\n-import org.openide.util.RequestProcessor;\n \n /**\n  *\n  * @author sky, radim\n  */\n class HeapView extends JComponent {\n+\n     private static final boolean AUTOMATIC_REFRESH = System.getProperty(\"org.netbeans.log.startup\") == null;\n \n-    /**\n-     * Style for overlay on top of grid.\n-     */\n-    private static final int STYLE_DEFAULT = 0;\n-    \n-    /**\n-     * Grid overlayed on top of heap. This is the default.\n-     */\n-    private static final int STYLE_OVERLAY = 1;\n-    \n     /*\n      * How often the display is updated.\n      */\n     private static final int TICK = 1500;\n-    \n-    /**\n-     * Time (in ms) to animate heap growing.\n-     */\n-    private static final int HEAP_GROW_ANIMATE_TIME = 1000;\n-    \n-    /**\n-     * Width of the border.\n-     */\n-    private static final int BORDER_W = 2;\n-    \n-    /**\n-     * Height of the border area.\n-     */\n-    private static final int BORDER_H = 4;\n-    \n-    /**\n-     * Colors for the grid. This is alternating pairs for a linear gradient.\n-     */\n-    private static final Color[] GRID_COLORS = new Color[8];\n-    \n-    /**\n-     * Border color.\n-     */\n-    private static Color border1Color;\n \n     /**\n-     * Border color of line below the top.\n+     * Foreground color for the chart.\n      */\n-    private static Color border2Color;\n+    private static final Color CHART_COLOR;\n \n-    private static Color border3Color;\n-    \n     /**\n-     * Start color for the tick gradient.\n+     * Color for text.\n      */\n-    private static Color minTickColor;\n+    private static final Color TEXT_COLOR;\n \n     /**\n-     * End color for the tick gradient.\n+     * Color for the background.\n      */\n-    private static Color maxTickColor;\n+    private static final Color BACKGROUND_COLOR;\n \n     /**\n-     * Color for the text before blurred.\n+     * Number of samples to retain in history.\n      */\n-    private static Color textBlurColor;\n+    private static final int GRAPH_COUNT = 100;\n     \n     /**\n-     * Color for text drawn on top of blurred text.\n+     * Key for the Show Text preference.\n      */\n-    private static Color textColor;\n-\n-    /**\n-     * Start color for the background gradient.\n-     */\n-    private static Color background1Color;\n-\n-    /**\n-     * End color for the background gradient.\n-     */\n-    private static Color background2Color;\n-    \n-    /**\n-     * Size used for Kernel used to generate drop shadow.\n-     */\n-    private static final int KERNEL_SIZE = 3;\n-\n-    /**\n-     * Factor used for Kernel used to generate drop shadow.\n-     */\n-    private static final float BLUR_FACTOR = 0.1f;\n-    \n-    /**\n-     * How far to shift the drop shadow along the horizontal axis.\n-     */\n-    private static final int SHIFT_X = 0;\n-\n-    /**\n-     * How far to shift the drop shadow along the vertical axis.\n-     */\n-    private static final int SHIFT_Y = 1;\n+    private static final String SHOW_TEXT = \"showText\";\n \n     static {\n         //init colors\n-        Color c = UIManager.getColor( \"nb.heapview.border1\" ); //NOI18N\n-        if( null == c )\n-            c = new Color(0xA6A295);\n-        border1Color = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.border2\" ); //NOI18N\n-        if( null == c )\n-            c = new Color(0xC0BCAD);\n-        border2Color = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.border3\" ); //NOI18N\n-        if( null == c )\n-            c = Color.WHITE;\n-        border3Color = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.mintick.color\" ); //NOI18N\n-        if( null == c )\n-            c = new Color(0xC7D6AD);\n-        minTickColor = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.maxtick.color\" ); //NOI18N\n-        if( null == c )\n+        Color c = UIManager.getColor(\"nb.heapview.maxtick.color\"); //NOI18N\n+        if (null == c) {\n             c = new Color(0x615d0f);\n-        maxTickColor = c;\n+        }\n+        CHART_COLOR = c;\n \n-        c = UIManager.getColor( \"nb.heapview.textblur\" ); //NOI18N\n-        if( null == c )\n+        c = UIManager.getColor(\"nb.heapview.foreground\"); //NOI18N\n+        if (null == c) {\n             c = Color.WHITE;\n-        textBlurColor = c;\n+        }\n+        TEXT_COLOR = c;\n \n-        c = UIManager.getColor( \"nb.heapview.foreground\" ); //NOI18N\n-        if( null == c )\n-            c = Color.WHITE;\n-        textColor = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.background1\" ); //NOI18N\n-        if( null == c )\n-            c = new Color(0xD0CCBC);\n-        background1Color = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.background2\" ); //NOI18N\n-        if( null == c )\n-            c = new Color(0xEAE7D7);\n-        background2Color = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.grid1.start\" );\n-        if( null == c )\n-            c = new Color(0xE3DFCF);\n-        GRID_COLORS[0] = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.grid1.end\" );\n-        if( null == c )\n-            c = new Color(0xE7E4D3);\n-        GRID_COLORS[1] = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.grid2.start\" );\n-        if( null == c )\n-            c = new Color(0xDAD7C6);\n-        GRID_COLORS[2] = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.grid2.end\" );\n-        if( null == c )\n-            c = new Color(0xDFDCCB);\n-        GRID_COLORS[3] = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.grid3.start\" );\n-        if( null == c )\n-            c = new Color(0xD3CFBF);\n-        GRID_COLORS[4] = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.grid3.end\" );\n-        if( null == c )\n-            c = new Color(0xD7D3C3);\n-        GRID_COLORS[5] = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.grid4.start\" );\n-        if( null == c )\n-            c = new Color(0xCECABA);\n-        GRID_COLORS[6] = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.grid4.end\" );\n-        if( null == c )\n-            c = new Color(0xD0CCBC);\n-        GRID_COLORS[7] = c;\n+        c = UIManager.getColor(\"nb.heapview.background1\"); //NOI18N\n+        if (null == c) {\n+            c = new Color(0xC0BCAC);", "originalCommit": "0e0d715c8271cda6867e5acb26dca7452195941b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkxNTY3OQ==", "url": "https://github.com/apache/netbeans/pull/1918#discussion_r374915679", "bodyText": "Probably better use UIManager.getFont(\"Label.font\") instead of new JLabel().getFont().", "author": "DevCharly", "createdAt": "2020-02-04T20:51:55Z", "path": "platform/openide.actions/src/org/openide/actions/HeapView.java", "diffHunk": "@@ -350,60 +148,39 @@ public HeapView() {\n         setToolTipText(NbBundle.getMessage(GarbageCollectAction.class, \"CTL_GC\"));\n         updateUI();\n     }\n-    \n+\n     /**\n-     * Overriden to return true, GCComponent paints in its entire bounds in\n-     * an opaque manner.\n+     * Overridden to return true, GCComponent paints in its entire bounds in an\n+     * opaque manner.\n      */\n-    @Override public boolean isOpaque() {\n+    @Override\n+    public boolean isOpaque() {\n         return true;\n     }\n-    \n+\n     /**\n      * Updates the look and feel for this component.\n      */\n-    @Override public void updateUI() {\n-        Font f = new JLabel().getFont();\n-        f = new Font(f.getName(), Font.BOLD, f.getSize());\n+    @Override\n+    public void updateUI() {\n+        Font f = new JLabel().getFont().deriveFont(Font.BOLD);", "originalCommit": "0e0d715c8271cda6867e5acb26dca7452195941b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkyMDk2Mg==", "url": "https://github.com/apache/netbeans/pull/1918#discussion_r374920962", "bodyText": "Makes sense. While we're at it, is this the correct use of the updateUI method? The comments on JComponent::updateUI say:\n     * Resets the UI property to a value from the current look and feel.\n     * <code>JComponent</code> subclasses must override this method\n     * like this:\n     * <pre>\n     *   public void updateUI() {\n     *      setUI((SliderUI)UIManager.getUI(this);\n     *   }\n     *  </pre>\n\nwhich I don't really understand.", "author": "pedro-w", "createdAt": "2020-02-04T21:02:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkxNTY3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk0NTE4MQ==", "url": "https://github.com/apache/netbeans/pull/1918#discussion_r374945181", "bodyText": "In this custom component it is OK. I think you could remove invocation of revalidate() and repaint() from updateUI(). Does not make any sense IMHO.\nJComponent::updateUI is usually invoked from two places:\n\nthe component constructor and\nwhen switching look and feel without restart, which is currently not supported by NB\n\nsetUI() and UIManager.getUI() are used if the component has a UI delegate, which is another class that implements painting, listeners, etc. E.g. UI delegate for JLabel is class javax.swing.plaf.LabelUI, which is sub-classed by LaFs.\nHeapView does not have/need a UI delegate. You could even remove HeapView.updateUI() and initialize the font in the constructor. But maybe NB supports LaF switching in the future. Then it is good to have it because the label font may be different in various LaFs.", "author": "DevCharly", "createdAt": "2020-02-04T21:55:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkxNTY3OQ=="}], "type": "inlineReview"}, {"oid": "f7136ca96c0a40f7ad86e897ba51d455c6feb39c", "url": "https://github.com/apache/netbeans/commit/f7136ca96c0a40f7ad86e897ba51d455c6feb39c", "message": "Make changes identified in code review", "committedDate": "2020-02-05T10:25:36Z", "type": "commit"}, {"oid": "f45c592ba8d5189812c194acc23eb5be47d28c6d", "url": "https://github.com/apache/netbeans/commit/f45c592ba8d5189812c194acc23eb5be47d28c6d", "message": "Update keys for LAF properties\n\nRenamed background1 to background.\nRenamed maxtick.color to chart.\nRemoved unused properties.\nAdded a class comment to list the properties.", "committedDate": "2020-02-05T11:15:18Z", "type": "commit"}]}