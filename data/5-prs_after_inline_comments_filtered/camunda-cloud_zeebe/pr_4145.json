{"pr_number": 4145, "pr_title": "Add feel expressions for timer events", "pr_createdAt": "2020-03-27T16:15:25Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4145", "timeline": [{"oid": "91eee1d94e6729b6c5b4c3b7d0db32181f284e79", "url": "https://github.com/camunda-cloud/zeebe/commit/91eee1d94e6729b6c5b4c3b7d0db32181f284e79", "message": "chore(engine): support feel expressions for timer catch events", "committedDate": "2020-03-30T12:24:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY0MTI0Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r400641243", "bodyText": "I think we can delete this class for now.", "author": "saig0", "createdAt": "2020-03-31T04:48:51Z", "path": "bpmn-model/src/main/java/io/zeebe/model/bpmn/validation/zeebe/TimerEventDefinitionValidator.java", "diffHunk": "@@ -65,28 +61,31 @@ public void validate(\n \n   private void validateTimeDate(\n       final TimeDate timeDate, final ValidationResultCollector validationResultCollector) {\n-    try {\n-      TimeDateTimer.parse(timeDate.getTextContent());\n-    } catch (final DateTimeParseException e) {\n-      validationResultCollector.addError(0, \"Time date is invalid\");\n-    }\n+    //    try {\n+    //      TimeDateTimer.parse(timeDate.getTextContent());\n+    //    } catch (final DateTimeParseException e) {\n+    //      validationResultCollector.addError(0, \"Time date is invalid\");\n+    //      // TODO re-enable validation\n+    //    }", "originalCommit": "a934815f35cd448207ddacfa46521ac14c947e27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxMjg3NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r401412875", "bodyText": "@saig0 There is also the validation to make sure only 1 of the timer definitions is filled. I think we do need to keep that", "author": "korthout", "createdAt": "2020-04-01T07:37:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY0MTI0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY2OTY1NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r400669654", "bodyText": "Since this calling the timerFactory may throw an exception, we should handle this case and reject the deployment.", "author": "saig0", "createdAt": "2020-03-31T06:24:40Z", "path": "engine/src/main/java/io/zeebe/engine/processor/workflow/deployment/TransformingDeploymentCreateProcessor.java", "diffHunk": "@@ -96,12 +102,14 @@ private void createTimerIfTimerStartEvent(\n         if (startEvent.isTimer()) {\n           hasAtLeastOneTimer = true;\n \n+          final Timer timer =\n+              startEvent.getTimerFactory().apply(expressionProcessor, record.getKey());", "originalCommit": "a934815f35cd448207ddacfa46521ac14c947e27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY4ODAyOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r400688028", "bodyText": "This is not the key you are looking for. While transforming the workflow, we don't have a scope key to resolve the expression. Instead, we should have a way to evaluate the expression without a variable context.", "author": "saig0", "createdAt": "2020-03-31T07:09:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY2OTY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY4MjQ2Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r400682466", "bodyText": "Code style: instead of the switch statement in the lambda, we can create the factory functions in the upper if statement. So, we don't need the enum and the default case.", "author": "saig0", "createdAt": "2020-03-31T06:56:51Z", "path": "engine/src/main/java/io/zeebe/engine/processor/workflow/deployment/model/transformer/CatchEventTransformer.java", "diffHunk": "@@ -74,22 +80,51 @@ private void transformMessageEventDefinition(\n   }\n \n   private void transformTimerEventDefinition(\n+      final ExpressionLanguage expressionLanguage,\n       final ExecutableCatchEventElement executableElement,\n       final TimerEventDefinition timerEventDefinition) {\n-    final Timer timer;\n \n+    final Expression expression;\n+    final TimerType type;\n     if (timerEventDefinition.getTimeDuration() != null) {\n       final String duration = timerEventDefinition.getTimeDuration().getTextContent();\n-      timer = new RepeatingInterval(1, Interval.parse(duration));\n+      expression = expressionLanguage.parseExpression(duration);\n+      type = TimerType.DURATION;\n     } else if (timerEventDefinition.getTimeCycle() != null) {\n       final String cycle = timerEventDefinition.getTimeCycle().getTextContent();\n-      timer = RepeatingInterval.parse(cycle);\n+      expression = expressionLanguage.parseExpression(cycle);\n+      type = TimerType.CYCLE;\n     } else {\n       final String timeDate = timerEventDefinition.getTimeDate().getTextContent();\n-      timer = TimeDateTimer.parse(timeDate);\n+      expression = expressionLanguage.parseExpression(timeDate);\n+      type = TimerType.TIME_DATE;\n     }\n \n-    executableElement.setTimer(timer);\n+    executableElement.setTimerFactory(\n+        (expressionProcessor, scopeKey) -> {\n+          switch (type) {\n+            case DURATION:\n+              return Optional.of(\n+                      expressionProcessor.evaluateIntervalExpression(expression, scopeKey))\n+                  .map(right -> new RepeatingInterval(1, right))\n+                  .orElseThrow();\n+            case CYCLE:\n+              return Optional.of(expressionProcessor.evaluateStringExpression(expression, scopeKey))\n+                  .map(BufferUtil::bufferAsString)\n+                  .map(RepeatingInterval::parse)\n+                  .orElseThrow();\n+            case TIME_DATE:\n+              return Optional.of(expressionProcessor.evaluateStringExpression(expression, scopeKey))\n+                  .map(BufferUtil::bufferAsString)\n+                  .map(TimeDateTimer::parse)\n+                  .orElseThrow();\n+            default:\n+              final var expectedTypes =\n+                  List.of(TimerType.DURATION, TimerType.CYCLE, TimerType.TIME_DATE);\n+              throw new IllegalStateException(\n+                  \"Unexpected timer type '\" + type + \"'; expected one of \" + expectedTypes);\n+          }", "originalCommit": "a934815f35cd448207ddacfa46521ac14c947e27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY5NzYwMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r400697601", "bodyText": "It is a bit confusing to wrap the evaluation results into an Optional because the methods don't return null. Instead, they throw an exception.", "author": "saig0", "createdAt": "2020-03-31T07:28:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY4MjQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY5MTIxMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r400691213", "bodyText": "The caller expects a string instead of a buffer.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public DirectBuffer evaluateStringExpression(final Expression expression, final long scopeKey) {\n          \n          \n            \n              public String evaluateStringExpression(final Expression expression, final long scopeKey) {", "author": "saig0", "createdAt": "2020-03-31T07:16:22Z", "path": "engine/src/main/java/io/zeebe/engine/processor/workflow/ExpressionProcessor.java", "diffHunk": "@@ -58,6 +59,31 @@ public ExpressionProcessor(\n         .map(this::wrapResult);\n   }\n \n+  /**\n+   * Evaluates the given expression and returns the result as string wrapped in {@link\n+   * DirectBuffer}. If the evaluation fails or the result is not a string then an exception is\n+   * thrown.\n+   *\n+   * @param expression the expression to evaluate\n+   * @param scopeKey the scope to load the variables from\n+   * @return the evaluation result as buffer\n+   * @throws EvaluationException if expression evaluation failed\n+   */\n+  public DirectBuffer evaluateStringExpression(final Expression expression, final long scopeKey) {", "originalCommit": "a934815f35cd448207ddacfa46521ac14c947e27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY5NDIwMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r400694203", "bodyText": "We should also support FEEL date-time expressions. For example: date and time(\"2015-09-18T10:31:10+01:00\"), date and time(x) + duration(\"PT1H\").", "author": "saig0", "createdAt": "2020-03-31T07:22:20Z", "path": "engine/src/main/java/io/zeebe/engine/processor/workflow/deployment/model/transformer/CatchEventTransformer.java", "diffHunk": "@@ -74,22 +80,51 @@ private void transformMessageEventDefinition(\n   }\n \n   private void transformTimerEventDefinition(\n+      final ExpressionLanguage expressionLanguage,\n       final ExecutableCatchEventElement executableElement,\n       final TimerEventDefinition timerEventDefinition) {\n-    final Timer timer;\n \n+    final Expression expression;\n+    final TimerType type;\n     if (timerEventDefinition.getTimeDuration() != null) {\n       final String duration = timerEventDefinition.getTimeDuration().getTextContent();\n-      timer = new RepeatingInterval(1, Interval.parse(duration));\n+      expression = expressionLanguage.parseExpression(duration);\n+      type = TimerType.DURATION;\n     } else if (timerEventDefinition.getTimeCycle() != null) {\n       final String cycle = timerEventDefinition.getTimeCycle().getTextContent();\n-      timer = RepeatingInterval.parse(cycle);\n+      expression = expressionLanguage.parseExpression(cycle);\n+      type = TimerType.CYCLE;\n     } else {\n       final String timeDate = timerEventDefinition.getTimeDate().getTextContent();\n-      timer = TimeDateTimer.parse(timeDate);\n+      expression = expressionLanguage.parseExpression(timeDate);\n+      type = TimerType.TIME_DATE;\n     }\n \n-    executableElement.setTimer(timer);\n+    executableElement.setTimerFactory(\n+        (expressionProcessor, scopeKey) -> {\n+          switch (type) {\n+            case DURATION:\n+              return Optional.of(\n+                      expressionProcessor.evaluateIntervalExpression(expression, scopeKey))\n+                  .map(right -> new RepeatingInterval(1, right))\n+                  .orElseThrow();\n+            case CYCLE:\n+              return Optional.of(expressionProcessor.evaluateStringExpression(expression, scopeKey))\n+                  .map(BufferUtil::bufferAsString)\n+                  .map(RepeatingInterval::parse)\n+                  .orElseThrow();\n+            case TIME_DATE:\n+              return Optional.of(expressionProcessor.evaluateStringExpression(expression, scopeKey))", "originalCommit": "a934815f35cd448207ddacfa46521ac14c947e27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY5NDg1MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r400694850", "bodyText": "We should also support FEEL expressions using a cycle function. For example: cycle(3, duration(\"PT1H\"))", "author": "saig0", "createdAt": "2020-03-31T07:23:35Z", "path": "engine/src/main/java/io/zeebe/engine/processor/workflow/deployment/model/transformer/CatchEventTransformer.java", "diffHunk": "@@ -74,22 +80,51 @@ private void transformMessageEventDefinition(\n   }\n \n   private void transformTimerEventDefinition(\n+      final ExpressionLanguage expressionLanguage,\n       final ExecutableCatchEventElement executableElement,\n       final TimerEventDefinition timerEventDefinition) {\n-    final Timer timer;\n \n+    final Expression expression;\n+    final TimerType type;\n     if (timerEventDefinition.getTimeDuration() != null) {\n       final String duration = timerEventDefinition.getTimeDuration().getTextContent();\n-      timer = new RepeatingInterval(1, Interval.parse(duration));\n+      expression = expressionLanguage.parseExpression(duration);\n+      type = TimerType.DURATION;\n     } else if (timerEventDefinition.getTimeCycle() != null) {\n       final String cycle = timerEventDefinition.getTimeCycle().getTextContent();\n-      timer = RepeatingInterval.parse(cycle);\n+      expression = expressionLanguage.parseExpression(cycle);\n+      type = TimerType.CYCLE;\n     } else {\n       final String timeDate = timerEventDefinition.getTimeDate().getTextContent();\n-      timer = TimeDateTimer.parse(timeDate);\n+      expression = expressionLanguage.parseExpression(timeDate);\n+      type = TimerType.TIME_DATE;\n     }\n \n-    executableElement.setTimer(timer);\n+    executableElement.setTimerFactory(\n+        (expressionProcessor, scopeKey) -> {\n+          switch (type) {\n+            case DURATION:\n+              return Optional.of(\n+                      expressionProcessor.evaluateIntervalExpression(expression, scopeKey))\n+                  .map(right -> new RepeatingInterval(1, right))\n+                  .orElseThrow();\n+            case CYCLE:\n+              return Optional.of(expressionProcessor.evaluateStringExpression(expression, scopeKey))", "originalCommit": "a934815f35cd448207ddacfa46521ac14c947e27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcwNDAxOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r400704019", "bodyText": "Instead of throwing an exception, we should create an incident if the evaluation fails. However, this can be done in a follow-up issue.", "author": "saig0", "createdAt": "2020-03-31T07:40:40Z", "path": "engine/src/main/java/io/zeebe/engine/processor/workflow/timer/TriggerTimerProcessor.java", "diffHunk": "@@ -123,27 +130,30 @@ private boolean shouldReschedule(final TimerRecord timer) {\n \n   private void rescheduleTimer(\n       final TimerRecord record, final TypedStreamWriter writer, final ExecutableCatchEvent event) {\n-    if (event.getTimer() == null) {\n+    final Timer timer;\n+    try {\n+      timer = event.getTimerFactory().apply(expressionProcessor, record.getElementInstanceKey());\n+    } catch (Exception e) {\n       final String message =\n           String.format(\n               \"Expected to reschedule repeating timer for element with id '%s', but no timer definition was found\",\n               BufferUtil.bufferAsString(event.getId()));\n-      throw new IllegalStateException(message);\n+      throw new IllegalStateException(message, e);", "originalCommit": "a934815f35cd448207ddacfa46521ac14c947e27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUxODc1OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r401518759", "bodyText": "@saig0 The original implementation already throws an Exception. Is that a bug? Can you explain the behaviour differences between an exception and an incident in this situation?", "author": "korthout", "createdAt": "2020-04-01T10:37:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcwNDAxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU0MTY2OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r401541668", "bodyText": "An incident is created to indicate a problem to the user and it can be resolved when the problem is solved by the user.\nIf an exception is thrown in this processor then the whole workflow instance is added to the \"backlist\". No further event/command is applied to this instance. It can not be repaired.\nPreviously, the exception would be only thrown if there was a bug in the processor or state - it was just to prevent an NPE. But now, an evaluation could fail on rescheduling if a variable has changed.\nSaying that I realize that the incident could not be resolved by the current implementation \ud83e\udd14 It just works for jobs or workflow instance-related events /https://github.com/zeebe-io/zeebe/blob/develop/engine/src/main/java/io/zeebe/engine/processor/workflow/incident/ResolveIncidentProcessor.java#L69).\nSo, we have two options: don't evaluate the expression or extend the incident logic. I would prefer the first option for now. Let's try to avoid throwing an exception if possible.", "author": "saig0", "createdAt": "2020-04-01T11:22:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcwNDAxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY1ODc2OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r401658768", "bodyText": "See #4208", "author": "korthout", "createdAt": "2020-04-01T14:28:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcwNDAxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjMwMTE2MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r402301161", "bodyText": "I see that the other test case does the same but we should not use System.currentTimeMillis() \ud83d\ude05 Instead, we should use the clock from the engine: engine.getClock().\nAlso, this check might be flaky if we are slow and the due time is over before reaching the assertion. We could increase the duration to 10s.", "author": "saig0", "createdAt": "2020-04-02T13:12:37Z", "path": "engine/src/test/java/io/zeebe/engine/processor/workflow/timer/TimerStartEventTest.java", "diffHunk": "@@ -99,6 +107,34 @@ public void shouldCreateTimer() {\n     assertThat(timerRecord.getDueDate()).isBetween(now, now + 1000L);\n   }\n \n+  @Test\n+  public void shouldCreateTimerFromFeelExpression() {\n+    // when\n+    final DeployedWorkflow deployedWorkflow =\n+        engine\n+            .deployment()\n+            .withXmlResource(FEEL_EXPRESSION_MODEL)\n+            .deploy()\n+            .getValue()\n+            .getDeployedWorkflows()\n+            .get(0);\n+\n+    // then\n+    final TimerRecordValue timerRecord =\n+        RecordingExporter.timerRecords(TimerIntent.CREATED)\n+            .withWorkflowKey(deployedWorkflow.getWorkflowKey())\n+            .getFirst()\n+            .getValue();\n+\n+    Assertions.assertThat(timerRecord)\n+        .hasWorkflowInstanceKey(TimerInstance.NO_ELEMENT_INSTANCE)\n+        .hasTargetElementId(\"start_5\")\n+        .hasElementInstanceKey(TimerInstance.NO_ELEMENT_INSTANCE);\n+\n+    final long now = System.currentTimeMillis();\n+    assertThat(timerRecord.getDueDate()).isBetween(now, now + 1000L);", "originalCommit": "ee19b1e2686429a662df357064f803c54fc00889", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjMxNjAwNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r402316007", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        System.currentTimeMillis(),\n          \n          \n            \n                        ENGINE.getClock().getCurrentTimeInMillis(),", "author": "saig0", "createdAt": "2020-04-02T13:33:50Z", "path": "engine/src/test/java/io/zeebe/engine/processor/workflow/timer/TimerCatchEventTest.java", "diffHunk": "@@ -160,6 +160,42 @@ public void shouldCreateTimer() {\n             createdEvent.getTimestamp() + Duration.ofSeconds(10).toMillis());\n   }\n \n+  @Test\n+  public void shouldCreateTimerFromFeelExpression() {\n+    // given\n+    final BpmnModelInstance workflow =\n+        Bpmn.createExecutableProcess(\"shouldCreateTimer\")\n+            .startEvent()\n+            .intermediateCatchEvent(\"timer\", c -> c.timerWithDurationExpression(\"\\\"PT10S\\\"\"))\n+            .endEvent()\n+            .done();\n+\n+    ENGINE.deployment().withXmlResource(workflow).deploy();\n+    workflowInstanceKey = ENGINE.workflowInstance().ofBpmnProcessId(\"shouldCreateTimer\").create();\n+\n+    // when\n+    final Record<WorkflowInstanceRecordValue> activatedEvent =\n+        RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_ACTIVATED)\n+            .withWorkflowInstanceKey(workflowInstanceKey)\n+            .withElementId(\"timer\")\n+            .getFirst();\n+\n+    // then\n+    final Record<TimerRecordValue> createdEvent =\n+        RecordingExporter.timerRecords(TimerIntent.CREATED)\n+            .withWorkflowInstanceKey(workflowInstanceKey)\n+            .getFirst();\n+\n+    Assertions.assertThat(createdEvent.getValue())\n+        .hasElementInstanceKey(activatedEvent.getKey())\n+        .hasWorkflowInstanceKey(workflowInstanceKey);\n+\n+    assertThat(createdEvent.getValue().getDueDate())\n+        .isBetween(\n+            System.currentTimeMillis(),", "originalCommit": "2a1f17f3777488623d9499799354e3bafa1cfde3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjMyNjYyMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r402326623", "bodyText": "What happens if we call .toBuffer() on a duration or period result? For example, when we want to store the evaluation result to a variable that should be used later in the workflow for a timer catch event.", "author": "saig0", "createdAt": "2020-04-02T13:48:09Z", "path": "expression-language/src/test/java/io/zeebe/el/EvaluationResultTest.java", "diffHunk": "@@ -62,10 +70,38 @@ public void booleanExpression() {\n     assertThat(evaluationResult.getBoolean()).isTrue();\n     assertThat(evaluationResult.getString()).isNull();\n     assertThat(evaluationResult.getNumber()).isNull();\n+    assertThat(evaluationResult.getPeriod()).isNull();\n+    assertThat(evaluationResult.getDuration()).isNull();\n     assertThat(evaluationResult.toBuffer()).isEqualTo(asMsgPack(\"true\"));\n     assertThat(evaluationResult.getList()).isNull();\n   }\n \n+  @Test\n+  public void durationExpression() {\n+    final var evaluationResult = evaluateExpression(\"=duration(\\\"PT2H\\\")\");\n+\n+    assertThat(evaluationResult.getType()).isEqualTo(ResultType.DURATION);\n+    assertThat(evaluationResult.getDuration()).isEqualTo(Duration.ofHours(2));\n+    assertThat(evaluationResult.getPeriod()).isNull();\n+    assertThat(evaluationResult.getBoolean()).isNull();\n+    assertThat(evaluationResult.getString()).isNull();\n+    assertThat(evaluationResult.getNumber()).isNull();\n+    assertThat(evaluationResult.getList()).isNull();\n+  }\n+\n+  @Test\n+  public void periodExpression() {\n+    final var evaluationResult = evaluateExpression(\"=duration(\\\"P2M\\\")\");\n+\n+    assertThat(evaluationResult.getType()).isEqualTo(ResultType.PERIOD);\n+    assertThat(evaluationResult.getDuration()).isNull();\n+    assertThat(evaluationResult.getPeriod()).isEqualTo(Period.ofMonths(2));\n+    assertThat(evaluationResult.getBoolean()).isNull();\n+    assertThat(evaluationResult.getString()).isNull();\n+    assertThat(evaluationResult.getNumber()).isNull();\n+    assertThat(evaluationResult.getList()).isNull();\n+  }", "originalCommit": "4aac743d058788d61cf565a55ec903b7e4b64e02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM0ODgzMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r402348833", "bodyText": "The deployment is rejected after it is created. See the following records:\n16:15:34.490 [] INFO  io.zeebe.test.records - {\"valueType\":\"DEPLOYMENT\",\"key\":-1,\"position\":4294967296,\"timestamp\":1585836934179,\"recordType\":\"COMMAND\",\"intent\":\"CREATE\",\"partitionId\":1,\"rejectionType\":\"NULL_VAL\",\"rejectionReason\":\"\",\"value\":{\"resources\":[{\"resource\":\"\n16:15:34.492 [] INFO  io.zeebe.test.records - {\"valueType\":\"DEPLOYMENT\",\"key\":2251799813685250,\"position\":4294968664,\"timestamp\":1585836934421,\"recordType\":\"EVENT\",\"intent\":\"CREATED\",\"partitionId\":1,\"rejectionType\":\"NULL_VAL\",\"rejectionReason\":\"\",\"value\":{\"resources\":[{\"resource\":\"\n16:15:34.493 [] INFO  io.zeebe.test.records - {\"valueType\":\"DEPLOYMENT\",\"key\":-1,\"position\":4294970104,\"timestamp\":1585836934421,\"recordType\":\"COMMAND_REJECTION\",\"intent\":\"CREATE\",\"partitionId\":1,\"rejectionType\":\"PROCESSING_ERROR\",\"rejectionReason\":\"Expected to create timer for start event, but encountered the following error: failed to evaluate expression 'INVALID_CYCLE_EXPRESSION': no variable found for name 'INVALID_CYCLE_EXPRESSION'\",\"value\":{\"resources\":[{\"resource\":\"", "author": "saig0", "createdAt": "2020-04-02T14:17:51Z", "path": "engine/src/main/java/io/zeebe/engine/processor/workflow/deployment/TransformingDeploymentCreateProcessor.java", "diffHunk": "@@ -70,7 +72,12 @@ public void processRecord(\n         responseWriter.writeEventOnCommand(key, DeploymentIntent.CREATED, deploymentEvent, command);\n         streamWriter.appendFollowUpEvent(key, DeploymentIntent.CREATED, deploymentEvent);\n \n-        createTimerIfTimerStartEvent(command, streamWriter);\n+        try {\n+          createTimerIfTimerStartEvent(command, streamWriter);\n+        } catch (RuntimeException e) {\n+          final String reason = String.format(COULD_NOT_CREATE_TIMER_MESSAGE, e.getMessage());\n+          streamWriter.appendRejection(command, RejectionType.PROCESSING_ERROR, reason);\n+        }", "originalCommit": "f79c0e05765398a73a4a20b764579414440a252d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMzEyNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r402733127", "bodyText": "What happens if we have multiple timer/message subscriptions and one of the timer expressions fails?\nIf an incident is created then no other action should be applied to the workflow instance (e.g. don't open other subscriptions, don't go to ELEMENT_ACTIVATED state)", "author": "saig0", "createdAt": "2020-04-03T04:40:52Z", "path": "engine/src/main/java/io/zeebe/engine/processor/workflow/CatchEventBehavior.java", "diffHunk": "@@ -83,12 +83,13 @@ public void subscribeToEvents(\n     // if all subscriptions are valid then open the subscriptions\n     for (final ExecutableCatchEvent event : events) {\n       if (event.isTimer()) {\n+        final Timer timer = event.getTimerFactory().apply(expressionProcessor, context.getKey());", "originalCommit": "f81ca00fb0a7a4b76f8fe5005859a217b14e84ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0MzY1MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r403843650", "bodyText": "We should reject the deployment before workflowState.putDeployment(key, deploymentEvent). Otherwise, this workflow is stored in the state and is used as the latest version \ud83d\ude05", "author": "saig0", "createdAt": "2020-04-06T05:51:57Z", "path": "engine/src/main/java/io/zeebe/engine/processor/workflow/deployment/TransformingDeploymentCreateProcessor.java", "diffHunk": "@@ -69,15 +69,16 @@ public void processRecord(\n     if (accepted) {\n       final long key = keyGenerator.nextKey();\n       if (workflowState.putDeployment(key, deploymentEvent)) {\n-        responseWriter.writeEventOnCommand(key, DeploymentIntent.CREATED, deploymentEvent, command);\n-        streamWriter.appendFollowUpEvent(key, DeploymentIntent.CREATED, deploymentEvent);\n-\n         try {\n           createTimerIfTimerStartEvent(command, streamWriter);\n         } catch (RuntimeException e) {\n           final String reason = String.format(COULD_NOT_CREATE_TIMER_MESSAGE, e.getMessage());\n+          responseWriter.writeRejectionOnCommand(command, RejectionType.PROCESSING_ERROR, reason);", "originalCommit": "67b6bf9fc72d53c8770dfdb168746ecc16707f04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEwMjk5Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r404102992", "bodyText": "Discussed. Fixed for now by validating the timer start event expressions, such that this situation cannot occur.", "author": "korthout", "createdAt": "2020-04-06T13:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0MzY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg1NjAwNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r403856006", "bodyText": "Scheduling a timer for the year 3978 sounds very optimistic \ud83d\ude02", "author": "saig0", "createdAt": "2020-04-06T06:30:43Z", "path": "engine/src/test/java/io/zeebe/engine/processor/workflow/timer/TimerStartEventTest.java", "diffHunk": "@@ -56,14 +60,22 @@\n \n   private static final BpmnModelInstance MULTI_TIMER_START_MODEL = createMultipleTimerStartModel();\n \n-  private static final BpmnModelInstance FEEL_EXPRESSION_MODEL =\n+  private static final BpmnModelInstance FEEL_DATE_TIME_EXPRESSION_MODEL =\n       Bpmn.createExecutableProcess(\"process_5\")\n           .startEvent(\"start_5\")\n-          .timerWithCycleExpression(\"cycle(duration(\\\"PT1S\\\"))\")\n+          .timerWithDateExpression(\"date and time(date(\\\"3978-11-25\\\"),time(\\\"T00:00:00@UTC\\\"))\")", "originalCommit": "7cd6c589e329305a049380401a946b26119f5d11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEwNDE5Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r404104193", "bodyText": "Psst: duck/google it", "author": "korthout", "createdAt": "2020-04-06T13:48:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg1NjAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg2MDc3Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r403860772", "bodyText": "Please add another test case to verify that a local date-time is transformed into a zoned date-time.", "author": "saig0", "createdAt": "2020-04-06T06:43:28Z", "path": "expression-language/src/test/java/io/zeebe/el/EvaluationResultTest.java", "diffHunk": "@@ -102,6 +104,23 @@ public void periodExpression() {\n     assertThat(evaluationResult.getList()).isNull();\n   }\n \n+  @Test\n+  public void dateTimeExpression() {\n+    final var evaluationResult = evaluateExpression(\n+        \"=date and time(\\\"2020-04-01T10:31:10@Europe/Berlin\\\")\");", "originalCommit": "831a2488bb46f37cd87c2a846531895fc9b66ad8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d60e3402878f1eb997ea52ec61caca3f475ea493", "url": "https://github.com/camunda-cloud/zeebe/commit/d60e3402878f1eb997ea52ec61caca3f475ea493", "message": "chore(engine): support feel expressions for timer catch events\n\nchore(engine): fix spotbugs problems (null not allowed)\n\nchore(engine): add feel expressions for timer start events\n\nchore(engine): add test feel expression for timer start event\n\nchore(engine): add test feel expression for timer catch event\n\nchore(engine): add test for period and duration expressions\n\nchore(engine): apply review comments\n\n- date time feel functions\n- timer start event cannot have a scope key\n- code style in CatchEventTransformer\n\nchore(engine): add test to deal with wrong timer start event expression\n\nchore(engine): apple review comments\n\n- remove unused validation checks for timers\n- remove unnecessary wrapping of string in buffer\n\nchore(engine): fix TimeDateTimer test\n\nchore(engine): add custom feel function for cycle\n\nchore(engine): apply formatting\n\nchore(engine): fix built-in feel expressions test\n\nchore(engine): add timer incident tests\n\nand fix associated problems\n\nchore(engine): refer todo to issue #4208\n\nchore(engine): improve timer start event tests\n\nUse the clock of the engine to determine time at particular moments.\n\nchore(engine): improve timer catch event test\n\nUse clock of the engine instead of the system clock to determine time at\nspecific moments.\n\nchore(engine): add test for date time expression eval results\n\nfix(engine): only write rejected or created event\n\nPreviously both could be written to the logstream/response at the same\ntime.\n\nfix(engine): fail early when a timer cannot be evaluated\n\nchore(engine): apply formatting rules\n\nchore(engine): use new feel cycle function in a test\n\nchore(engine): add test for date time start event\n\nchore(engine): add tests for timer feel expressions\n\ntest that:\n- feel duration expression can be used as timer boundary event\n- feel cycle expression can be used as timer boundary event\n- incident is thrown when cycle expression fails\n\nchore(engine): apply formatting rules\n\nchore(engine): improve error message for custom feel functions\n\nThe error message did not show clearly the parameters with which the\nfunction was called, but rather the args with which the function\nprovider handles the evaluation of the function. This commit adds\nadditional error cases where we can provide more comprehensive error\nmessages.\n\nchore(engine): fix failing test\n\nchore(engine): remove redundant test", "committedDate": "2020-04-06T12:40:42Z", "type": "commit"}, {"oid": "d60e3402878f1eb997ea52ec61caca3f475ea493", "url": "https://github.com/camunda-cloud/zeebe/commit/d60e3402878f1eb997ea52ec61caca3f475ea493", "message": "chore(engine): support feel expressions for timer catch events\n\nchore(engine): fix spotbugs problems (null not allowed)\n\nchore(engine): add feel expressions for timer start events\n\nchore(engine): add test feel expression for timer start event\n\nchore(engine): add test feel expression for timer catch event\n\nchore(engine): add test for period and duration expressions\n\nchore(engine): apply review comments\n\n- date time feel functions\n- timer start event cannot have a scope key\n- code style in CatchEventTransformer\n\nchore(engine): add test to deal with wrong timer start event expression\n\nchore(engine): apple review comments\n\n- remove unused validation checks for timers\n- remove unnecessary wrapping of string in buffer\n\nchore(engine): fix TimeDateTimer test\n\nchore(engine): add custom feel function for cycle\n\nchore(engine): apply formatting\n\nchore(engine): fix built-in feel expressions test\n\nchore(engine): add timer incident tests\n\nand fix associated problems\n\nchore(engine): refer todo to issue #4208\n\nchore(engine): improve timer start event tests\n\nUse the clock of the engine to determine time at particular moments.\n\nchore(engine): improve timer catch event test\n\nUse clock of the engine instead of the system clock to determine time at\nspecific moments.\n\nchore(engine): add test for date time expression eval results\n\nfix(engine): only write rejected or created event\n\nPreviously both could be written to the logstream/response at the same\ntime.\n\nfix(engine): fail early when a timer cannot be evaluated\n\nchore(engine): apply formatting rules\n\nchore(engine): use new feel cycle function in a test\n\nchore(engine): add test for date time start event\n\nchore(engine): add tests for timer feel expressions\n\ntest that:\n- feel duration expression can be used as timer boundary event\n- feel cycle expression can be used as timer boundary event\n- incident is thrown when cycle expression fails\n\nchore(engine): apply formatting rules\n\nchore(engine): improve error message for custom feel functions\n\nThe error message did not show clearly the parameters with which the\nfunction was called, but rather the args with which the function\nprovider handles the evaluation of the function. This commit adds\nadditional error cases where we can provide more comprehensive error\nmessages.\n\nchore(engine): fix failing test\n\nchore(engine): remove redundant test", "committedDate": "2020-04-06T12:40:42Z", "type": "forcePushed"}, {"oid": "8d7b7ce876eb96ee7a2fc36cf3aa42596a8cd9a4", "url": "https://github.com/camunda-cloud/zeebe/commit/8d7b7ce876eb96ee7a2fc36cf3aa42596a8cd9a4", "message": "chore(engine): add test for localdatetime expression to zoneddatetime", "committedDate": "2020-04-06T13:58:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDExMDA1Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4145#discussion_r404110052", "bodyText": "please do \ud83d\ude02", "author": "saig0", "createdAt": "2020-04-06T13:55:54Z", "path": "engine/src/main/java/io/zeebe/engine/processor/workflow/deployment/model/validation/ProcessTimerStartEventExpressionValidator.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor.workflow.deployment.model.validation;\n+\n+import io.zeebe.el.Expression;\n+import io.zeebe.el.ExpressionLanguage;\n+import io.zeebe.engine.processor.workflow.ExpressionProcessor;\n+import io.zeebe.model.bpmn.instance.Process;\n+import io.zeebe.model.bpmn.instance.StartEvent;\n+import io.zeebe.model.bpmn.instance.TimerEventDefinition;\n+import io.zeebe.model.bpmn.util.time.RepeatingInterval;\n+import io.zeebe.model.bpmn.util.time.TimeDateTimer;\n+import io.zeebe.model.bpmn.util.time.Timer;\n+import org.camunda.bpm.model.xml.validation.ModelElementValidator;\n+import org.camunda.bpm.model.xml.validation.ValidationResultCollector;\n+\n+public class ProcessTimerStartEventExpressionValidator\n+    implements ModelElementValidator<StartEvent> {\n+\n+  private static final String ERROR_MESSAGE_TEMPLATE =\n+      \"Expected a valid timer expression for start event, but encountered the following error: %s\";\n+  private final ExpressionLanguage expressionLanguage;\n+  private final ExpressionProcessor expressionProcessor;\n+\n+  public ProcessTimerStartEventExpressionValidator(\n+      final ExpressionLanguage expressionLanguage, final ExpressionProcessor expressionProcessor) {\n+    this.expressionLanguage = expressionLanguage;\n+    this.expressionProcessor = expressionProcessor;\n+  }\n+\n+  @Override\n+  public Class<StartEvent> getElementType() {\n+    return StartEvent.class;\n+  }\n+\n+  @Override\n+  public void validate(\n+      final StartEvent element, final ValidationResultCollector validationResultCollector) {\n+    if (!(element.getScope() instanceof Process)) {\n+      return;\n+    }\n+    element.getEventDefinitions().stream()\n+        .filter(TimerEventDefinition.class::isInstance)\n+        .map(TimerEventDefinition.class::cast)\n+        .forEach(definition -> validation(definition, validationResultCollector));\n+  }\n+\n+  private void validation(\n+      final TimerEventDefinition timerEventDefinition,\n+      final ValidationResultCollector validationResultCollector) {\n+    try {\n+      final var timer = tryEvaluateTimer(timerEventDefinition);\n+    } catch (RuntimeException e) {\n+      validationResultCollector.addError(0, String.format(ERROR_MESSAGE_TEMPLATE, e.getMessage()));\n+    }\n+  }\n+\n+  /**\n+   * Try to create a timer from the timer event definition by evaluating its time expression.\n+   *\n+   * @param timerEventDefinition The definition specifying the timer expression to evaluate\n+   * @throws RuntimeException when the expression could not be evaluated or when the expression\n+   *     result could not be used to create a timer.\n+   */\n+  private Timer tryEvaluateTimer(final TimerEventDefinition timerEventDefinition) {\n+    final Expression expression;\n+    final long scopeKey = -1; // todo: explaim", "originalCommit": "2ff5ae46892c4230f44317d56e4252c8b24459ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "343e20a1bc67b12d2f4b806d2d7c0a44eabe23f0", "url": "https://github.com/camunda-cloud/zeebe/commit/343e20a1bc67b12d2f4b806d2d7c0a44eabe23f0", "message": "chore(engine): validate timer start event expressions", "committedDate": "2020-04-06T14:22:10Z", "type": "commit"}, {"oid": "343e20a1bc67b12d2f4b806d2d7c0a44eabe23f0", "url": "https://github.com/camunda-cloud/zeebe/commit/343e20a1bc67b12d2f4b806d2d7c0a44eabe23f0", "message": "chore(engine): validate timer start event expressions", "committedDate": "2020-04-06T14:22:10Z", "type": "forcePushed"}]}