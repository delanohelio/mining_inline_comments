{"pr_number": 4009, "pr_title": "chore(logstream): enable health check on logstorage appender", "pr_createdAt": "2020-03-09T16:15:49Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4009", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEwNTIzOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4009#discussion_r390105238", "bodyText": "should we maybe complete  this future exceptionally?", "author": "Zelldon", "createdAt": "2020-03-10T05:43:14Z", "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStorageAppender.java", "diffHunk": "@@ -130,6 +139,30 @@ protected void onActorStarting() {\n     actor.consume(writeBufferSubscription, this::onWriteBufferAvailable);\n   }\n \n+  @Override\n+  protected void onActorClosed() {\n+    closeFuture.complete(null);\n+  }\n+\n+  @Override\n+  public ActorFuture<Void> closeAsync() {\n+    if (actor.isClosed()) {\n+      return closeFuture;\n+    }\n+    super.closeAsync();\n+    return closeFuture;\n+  }\n+\n+  @Override\n+  protected void handleFailure(final Exception failure) {\n+    onFailure(failure);\n+  }\n+\n+  @Override\n+  public void onActorFailed() {\n+    closeFuture.complete(null);", "originalCommit": "f0be716e3cd59e6d209f58fab4532e02b0f6e88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAzMDM4OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4009#discussion_r391030389", "bodyText": "Sorry, didn't notice this comment. Not sure if we should complete it exceptionally. Even if it is failed, it has closed and did all cleanup (if necessary) successfully, right?", "author": "deepthidevaki", "createdAt": "2020-03-11T14:54:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEwNTIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEwNTg0NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4009#discussion_r390105845", "bodyText": "I have the feeling you have a different formating setting then we do \ud83e\udd14 It is really hard to see the diff when the methods are reordered \ud83d\ude05", "author": "Zelldon", "createdAt": "2020-03-10T05:46:04Z", "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java", "diffHunk": "@@ -101,63 +104,47 @@ public String getLogName() {\n   }\n \n   @Override\n-  public String getName() {\n-    return actorName;\n-  }\n-\n-  @Override\n-  public void close() {\n-    closeAsync().join();\n+  public ActorFuture<Long> getCommitPositionAsync() {", "originalCommit": "f0be716e3cd59e6d209f58fab4532e02b0f6e88b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEwNjY2Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4009#discussion_r390106662", "bodyText": "Is it possible to recover? \ud83d\ude05 I mean the actor is closed right? Seems that the appender has not implement this method?", "author": "Zelldon", "createdAt": "2020-03-10T05:49:38Z", "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java", "diffHunk": "@@ -335,13 +339,38 @@ private int determineInitialPartitionId() {\n       final long lastPosition = logReader.seekToEnd();\n \n       // dispatcher needs to generate positions greater than the last position\n-      int partitionId = 0;\n+      int segmentPartitionId = 0;\n \n       if (lastPosition > 0) {\n-        partitionId = PositionUtil.partitionId(lastPosition);\n+        segmentPartitionId = PositionUtil.partitionId(lastPosition);\n       }\n \n-      return partitionId;\n+      return segmentPartitionId;\n+    }\n+  }\n+\n+  @Override\n+  public HealthStatus getHealthStatus() {\n+    return actor.isClosed() ? HealthStatus.UNHEALTHY : HealthStatus.HEALTHY;\n+  }\n+\n+  @Override\n+  public void addFailureListener(final FailureListener failureListener) {\n+    actor.run(() -> this.failureListener = failureListener);\n+  }\n+\n+  @Override\n+  public void onFailure() {\n+    if (failureListener != null) {\n+      failureListener.onFailure();\n+    }\n+    closeAsync();\n+  }\n+\n+  @Override\n+  public void onRecovered() {", "originalCommit": "f0be716e3cd59e6d209f58fab4532e02b0f6e88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4ODgzNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4009#discussion_r390288836", "bodyText": "Appender cannot recover now. But if it can recover, it should notify LogStreamImpl.", "author": "deepthidevaki", "createdAt": "2020-03-10T12:49:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEwNjY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEwODcxMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4009#discussion_r390108711", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private void onFailure(final Throwable error) {\n          \n          \n            \n              private void onFailure(final Exception exception) {", "author": "Zelldon", "createdAt": "2020-03-10T05:59:03Z", "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStorageAppender.java", "diffHunk": "@@ -152,6 +185,24 @@ private Positions readPositions(final ByteBuffer buffer) {\n     return positions;\n   }\n \n+  @Override\n+  public HealthStatus getHealthStatus() {\n+    return actor.isClosed() ? HealthStatus.UNHEALTHY : HealthStatus.HEALTHY;\n+  }\n+\n+  @Override\n+  public void addFailureListener(final FailureListener failureListener) {\n+    actor.run(() -> this.failureListener = failureListener);\n+  }\n+\n+  private void onFailure(final Throwable error) {", "originalCommit": "f0be716e3cd59e6d209f58fab4532e02b0f6e88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI5MzMyOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4009#discussion_r390293329", "bodyText": "AppendListener:onWriteError also calls this method and  passes  a Throwable. So this has to be Throwable, I guess? Or wrap it into an exception in the listener.", "author": "deepthidevaki", "createdAt": "2020-03-10T12:58:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEwODcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDExMDM1MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4009#discussion_r390110351", "bodyText": "So the actor can decide whether he wants to fail ?", "author": "Zelldon", "createdAt": "2020-03-10T06:06:16Z", "path": "util/src/main/java/io/zeebe/util/sched/ActorTask.java", "diffHunk": "@@ -294,9 +294,7 @@ public void onFailure(final Throwable failure) {\n         break;\n \n       default:\n-        Loggers.ACTOR_LOGGER.error(\n-            \"Actor failed in phase '{}'. Continue with next job.\", lifecyclePhase, failure);\n-\n+        actor.handleFailure(failure);", "originalCommit": "f0be716e3cd59e6d209f58fab4532e02b0f6e88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI5MDI5NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4009#discussion_r390290294", "bodyText": "Yes. Previous behavior is that actor never fails and continue with next job. So I kept it as the default behavior. The actors (mostly the ones that allows health check) can then decide to fail.", "author": "deepthidevaki", "createdAt": "2020-03-10T12:52:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDExMDM1MQ=="}], "type": "inlineReview"}, {"oid": "dca1d4d31b78fb155b00c6ae489724664318cbef", "url": "https://github.com/camunda-cloud/zeebe/commit/dca1d4d31b78fb155b00c6ae489724664318cbef", "message": "chore(util): do not catch throwable from an actor job", "committedDate": "2020-03-11T14:26:40Z", "type": "commit"}, {"oid": "eee759e72dd82e3e25077670bcd037e5d4faaf15", "url": "https://github.com/camunda-cloud/zeebe/commit/eee759e72dd82e3e25077670bcd037e5d4faaf15", "message": "chore(util): allow actor specific exception handling", "committedDate": "2020-03-11T14:26:40Z", "type": "commit"}, {"oid": "2cc4c8ab8d6151d94b1e3f52702d4c02d8634120", "url": "https://github.com/camunda-cloud/zeebe/commit/2cc4c8ab8d6151d94b1e3f52702d4c02d8634120", "message": "chore(logstream): enable health check on logstream and logstorage appender", "committedDate": "2020-03-11T14:44:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk4MzAyMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4009#discussion_r392983023", "bodyText": "Could we also check/test the happy path please", "author": "Zelldon", "createdAt": "2020-03-16T12:29:04Z", "path": "logstreams/src/test/java/io/zeebe/logstreams/impl/log/LogStorageAppenderHealthTest.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.logstreams.impl.log;\n+\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static io.zeebe.util.buffer.BufferUtil.wrapString;\n+\n+import io.zeebe.dispatcher.Dispatcher;\n+import io.zeebe.dispatcher.Dispatchers;\n+import io.zeebe.logstreams.spi.LogStorage;\n+import io.zeebe.logstreams.spi.LogStorageReader;\n+import io.zeebe.util.ByteValue;\n+import io.zeebe.util.health.HealthStatus;\n+import io.zeebe.util.sched.testing.ActorSchedulerRule;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.function.BiConsumer;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public final class LogStorageAppenderHealthTest {\n+\n+  private static final int MAX_FRAGMENT_SIZE = 1024;\n+  private static final int PARTITION_ID = 0;\n+\n+  @Rule public final ActorSchedulerRule schedulerRule = new ActorSchedulerRule();\n+\n+  private Dispatcher dispatcher;\n+  private ControllableLogStorage failingLogStorage;\n+  private LogStorageAppender appender;\n+  private LogStreamWriterImpl writer;\n+\n+  @Before\n+  public void setUp() {\n+    failingLogStorage = new ControllableLogStorage();\n+\n+    dispatcher =\n+        Dispatchers.create(\"0\")\n+            .actorScheduler(schedulerRule.get())\n+            .bufferSize((int) ByteValue.ofMegabytes(100 * MAX_FRAGMENT_SIZE))\n+            .maxFragmentLength(MAX_FRAGMENT_SIZE)\n+            .initialPartitionId(0)\n+            .build();\n+    final var subscription = dispatcher.openSubscription(\"log\");\n+\n+    appender =\n+        new LogStorageAppender(\n+            \"appender\", PARTITION_ID, failingLogStorage, subscription, MAX_FRAGMENT_SIZE);\n+    writer = new LogStreamWriterImpl(PARTITION_ID, dispatcher);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    appender.close();\n+    dispatcher.close();\n+  }\n+\n+  @Test\n+  public void shouldFailActorWhenWriteFails() {\n+    // given\n+    failingLogStorage.onNextAppend(\n+        (pos, listener) -> listener.onWriteError(new RuntimeException(\"foo\")));\n+\n+    // when\n+    writer.value(wrapString(\"value\")).tryWrite();\n+    schedulerRule.submitActor(appender).join();\n+\n+    // then\n+    waitUntil(() -> appender.getHealthStatus() == HealthStatus.UNHEALTHY);", "originalCommit": "2cc4c8ab8d6151d94b1e3f52702d4c02d8634120", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e82920fb868b842af141e4f4eb9b5ac8456e7edd", "url": "https://github.com/camunda-cloud/zeebe/commit/e82920fb868b842af141e4f4eb9b5ac8456e7edd", "message": "chore(logstream): enable health check on logstream and logstorage appender", "committedDate": "2020-03-16T13:07:55Z", "type": "commit"}, {"oid": "e82920fb868b842af141e4f4eb9b5ac8456e7edd", "url": "https://github.com/camunda-cloud/zeebe/commit/e82920fb868b842af141e4f4eb9b5ac8456e7edd", "message": "chore(logstream): enable health check on logstream and logstorage appender", "committedDate": "2020-03-16T13:07:55Z", "type": "forcePushed"}]}