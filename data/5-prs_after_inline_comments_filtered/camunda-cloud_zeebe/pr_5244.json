{"pr_number": 5244, "pr_title": "Prepare 0.24 for rolling upgrade", "pr_createdAt": "2020-08-26T15:19:48Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/5244", "timeline": [{"oid": "159a323f4e24df2a009a9503aba69dafd5ad430b", "url": "https://github.com/camunda-cloud/zeebe/commit/159a323f4e24df2a009a9503aba69dafd5ad430b", "message": "chore(atomix): disable Kryo logs", "committedDate": "2020-08-27T11:26:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0ODIzNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5244#discussion_r478348235", "bodyText": "It would be good not to tie implementation with the interface. So I would move this method out and put it in the NamespaceImpl.", "author": "deepthidevaki", "createdAt": "2020-08-27T11:32:32Z", "path": "atomix/utils/src/main/java/io/atomix/utils/serializer/Namespace.java", "diffHunk": "@@ -260,388 +64,16 @@ public void serialize(final Object obj, final OutputStream stream, final int buf\n    * @param <T> deserialized Object type\n    * @return deserialized Object\n    */\n-  public <T> T deserialize(final ByteBuffer buffer) {\n-    final Kryo kryo = borrow();\n-    try (final ByteBufferInput in = new ByteBufferInput(buffer)) {\n-      @SuppressWarnings(\"unchecked\")\n-      final T obj = (T) kryo.readClassAndObject(in);\n-      return obj;\n-    } finally {\n-      release(kryo);\n-    }\n-  }\n-\n-  /**\n-   * Deserializes given InputStream to an Object using Kryo instance in pool.\n-   *\n-   * @param stream input stream\n-   * @param <T> deserialized Object type\n-   * @return deserialized Object\n-   */\n-  public <T> T deserialize(final InputStream stream) {\n-    return deserialize(stream, DEFAULT_BUFFER_SIZE);\n-  }\n+  <T> T deserialize(final ByteBuffer buffer);\n \n-  /**\n-   * Deserializes given InputStream to an Object using Kryo instance in pool.\n-   *\n-   * @param stream input stream\n-   * @param <T> deserialized Object type\n-   * @param bufferSize size of the buffer in front of the stream\n-   * @return deserialized Object\n-   */\n-  public <T> T deserialize(final InputStream stream, final int bufferSize) {\n-    final Kryo kryo = borrow();\n-    try (final ByteBufferInput in = new ByteBufferInput(stream, bufferSize)) {\n-      @SuppressWarnings(\"unchecked\")\n-      final T obj = (T) kryo.readClassAndObject(in);\n-      return obj;\n-    } finally {\n-      release(kryo);\n-    }\n-  }\n-\n-  private String friendlyName() {\n-    return friendlyName;\n-  }\n+  ImmutableList<RegistrationBlock> getRegisteredBlocks();\n \n   /**\n-   * Gets the number of classes registered in this Kryo namespace.\n-   *\n-   * @return size of namespace\n-   */\n-  public int size() {\n-    return (int) registeredBlocks.stream().flatMap(block -> block.types().stream()).count();\n-  }\n-\n-  /**\n-   * Creates a Kryo instance.\n-   *\n-   * @return Kryo instance\n-   */\n-  @Override\n-  public Kryo create() {\n-    LOGGER.trace(\"Creating Kryo instance for {}\", this);\n-    final Kryo kryo = new Kryo();\n-    kryo.setClassLoader(classLoader);\n-    kryo.setRegistrationRequired(registrationRequired);\n-\n-    // If compatible serialization is enabled, override the default serializer.\n-    if (compatible) {\n-      kryo.setDefaultSerializer(CompatibleFieldSerializer::new);\n-    }\n-\n-    // TODO rethink whether we want to use StdInstantiatorStrategy\n-    kryo.setInstantiatorStrategy(\n-        new Kryo.DefaultInstantiatorStrategy(new StdInstantiatorStrategy()));\n-\n-    for (final RegistrationBlock block : registeredBlocks) {\n-      int id = block.begin();\n-      if (id == FLOATING_ID) {\n-        id = kryo.getNextRegistrationId();\n-      }\n-      for (final Pair<Class<?>[], Serializer<?>> entry : block.types()) {\n-        register(kryo, entry.getLeft(), entry.getRight(), id++);\n-      }\n-    }\n-    return kryo;\n-  }\n-\n-  /**\n-   * Register {@code type} and {@code serializer} to {@code kryo} instance.\n+   * Creates a new {@link Namespace} builder.\n    *\n-   * @param kryo Kryo instance\n-   * @param types types to register\n-   * @param serializer Specific serializer to register or null to use default.\n-   * @param id type registration id to use\n+   * @return builder\n    */\n-  private void register(\n-      final Kryo kryo, final Class<?>[] types, final Serializer<?> serializer, final int id) {\n-    final Registration existing = kryo.getRegistration(id);\n-    if (existing != null) {\n-      boolean matches = false;\n-      for (final Class<?> type : types) {\n-        if (existing.getType() == type) {\n-          matches = true;\n-          break;\n-        }\n-      }\n-\n-      if (!matches) {\n-        LOGGER.error(\n-            \"{}: Failed to register {} as {}, {} was already registered.\",\n-            friendlyName(),\n-            types,\n-            id,\n-            existing.getType());\n-\n-        throw new IllegalStateException(\n-            String.format(\n-                \"Failed to register %s as %s, %s was already registered.\",\n-                Arrays.toString(types), id, existing.getType()));\n-      }\n-      // falling through to register call for now.\n-      // Consider skipping, if there's reasonable\n-      // way to compare serializer equivalence.\n-    }\n-\n-    for (final Class<?> type : types) {\n-      Registration r = null;\n-      if (serializer == null) {\n-        r = kryo.register(type, id);\n-      } else if (type.isInterface()) {\n-        kryo.addDefaultSerializer(type, serializer);\n-      } else {\n-        r = kryo.register(type, serializer, id);\n-      }\n-      if (r != null) {\n-        if (r.getId() != id) {\n-          LOGGER.debug(\n-              \"{}: {} already registered as {}. Skipping {}.\",\n-              friendlyName(),\n-              r.getType(),\n-              r.getId(),\n-              id);\n-        }\n-        LOGGER.trace(\"{} registered as {}\", r.getType(), r.getId());\n-      }\n-    }\n-  }\n-\n-  @Override\n-  public Kryo borrow() {\n-    return kryoPool.borrow();\n-  }\n-\n-  @Override\n-  public void release(final Kryo kryo) {\n-    kryoPool.release(kryo);\n-  }\n-\n-  @Override\n-  public <T> T run(final KryoCallback<T> callback) {\n-    return kryoPool.run(callback);\n-  }\n-\n-  @Override\n-  public String toString() {\n-    if (!friendlyName.equals(NO_NAME)) {\n-      return MoreObjects.toStringHelper(getClass())\n-          .omitNullValues()\n-          .add(\"friendlyName\", friendlyName)\n-          // omit lengthy detail, when there's a name\n-          .toString();\n-    }\n-    return MoreObjects.toStringHelper(getClass())\n-        .add(\"registeredBlocks\", registeredBlocks)\n-        .toString();\n-  }\n-\n-  /** KryoNamespace builder. */\n-  // @NotThreadSafe\n-  public static final class Builder {\n-    private int blockHeadId = INITIAL_ID;\n-    private List<Pair<Class<?>[], Serializer<?>>> types = new ArrayList<>();\n-    private final List<RegistrationBlock> blocks = new ArrayList<>();\n-    private ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n-    private boolean registrationRequired = true;\n-    private boolean compatible = false;\n-\n-    /**\n-     * Builds a {@link Namespace} instance.\n-     *\n-     * @return KryoNamespace\n-     */\n-    public Namespace build() {\n-      return build(NO_NAME);\n-    }\n-\n-    /**\n-     * Builds a {@link Namespace} instance.\n-     *\n-     * @param friendlyName friendly name for the namespace\n-     * @return KryoNamespace\n-     */\n-    public Namespace build(final String friendlyName) {\n-      if (!types.isEmpty()) {\n-        blocks.add(new RegistrationBlock(this.blockHeadId, types));\n-      }\n-      return new Namespace(blocks, classLoader, registrationRequired, compatible, friendlyName)\n-          .populate(1);\n-    }\n-\n-    /**\n-     * Sets the next Kryo registration Id for following register entries.\n-     *\n-     * @param id Kryo registration Id\n-     * @return this\n-     * @see Kryo#register(Class, Serializer, int)\n-     */\n-    public Builder nextId(final int id) {\n-      if (!types.isEmpty()) {\n-        if (id != FLOATING_ID && id < blockHeadId + types.size()) {\n-\n-          if (LOGGER.isWarnEnabled()) {\n-            LOGGER.warn(\n-                \"requested nextId {} could potentially overlap \"\n-                    + \"with existing registrations {}+{} \",\n-                id,\n-                blockHeadId,\n-                types.size(),\n-                new RuntimeException());\n-          }\n-        }\n-        blocks.add(new RegistrationBlock(this.blockHeadId, types));\n-        types = new ArrayList<>();\n-      }\n-      this.blockHeadId = id;\n-      return this;\n-    }\n-\n-    /**\n-     * Registers classes to be serialized using Kryo default serializer.\n-     *\n-     * @param expectedTypes list of classes\n-     * @return this\n-     */\n-    public Builder register(final Class<?>... expectedTypes) {\n-      for (final Class<?> clazz : expectedTypes) {\n-        types.add(Pair.of(new Class<?>[] {clazz}, null));\n-      }\n-      return this;\n-    }\n-\n-    /**\n-     * Registers serializer for the given set of classes.\n-     *\n-     * <p>When multiple classes are registered with an explicitly provided serializer, the namespace\n-     * guarantees all instances will be serialized with the same type ID.\n-     *\n-     * @param classes list of classes to register\n-     * @param serializer serializer to use for the class\n-     * @return this\n-     */\n-    public Builder register(final Serializer<?> serializer, final Class<?>... classes) {\n-      types.add(Pair.of(classes, checkNotNull(serializer)));\n-      return this;\n-    }\n-\n-    private Builder register(final RegistrationBlock block) {\n-      if (block.begin() != FLOATING_ID) {\n-        // flush pending types\n-        nextId(block.begin());\n-        blocks.add(block);\n-        nextId(block.begin() + block.types().size());\n-      } else {\n-        // flush pending types\n-        final int addedBlockBegin = blockHeadId + types.size();\n-        nextId(addedBlockBegin);\n-        blocks.add(new RegistrationBlock(addedBlockBegin, block.types()));\n-        nextId(addedBlockBegin + block.types().size());\n-      }\n-      return this;\n-    }\n-\n-    /**\n-     * Registers all the class registered to given KryoNamespace.\n-     *\n-     * @param ns KryoNamespace\n-     * @return this\n-     */\n-    public Builder register(final Namespace ns) {\n-\n-      if (blocks.containsAll(ns.registeredBlocks)) {\n-        // Everything was already registered.\n-        LOGGER.debug(\"Ignoring {}, already registered.\", ns);\n-        return this;\n-      }\n-      for (final RegistrationBlock block : ns.registeredBlocks) {\n-        this.register(block);\n-      }\n-      return this;\n-    }\n-\n-    /**\n-     * Sets the namespace class loader.\n-     *\n-     * @param classLoader the namespace class loader\n-     * @return the namespace builder\n-     */\n-    public Builder setClassLoader(final ClassLoader classLoader) {\n-      this.classLoader = classLoader;\n-      return this;\n-    }\n-\n-    /**\n-     * Sets whether backwards/forwards compatible versioned serialization is enabled.\n-     *\n-     * <p>When compatible serialization is enabled, the {@link CompatibleFieldSerializer} will be\n-     * set as the default serializer for types that do not otherwise explicitly specify a\n-     * serializer.\n-     *\n-     * @param compatible whether versioned serialization is enabled\n-     * @return this\n-     */\n-    public Builder setCompatible(final boolean compatible) {\n-      this.compatible = compatible;\n-      return this;\n-    }\n-\n-    /**\n-     * Sets the registrationRequired flag.\n-     *\n-     * @param registrationRequired Kryo's registrationRequired flag\n-     * @return this\n-     * @see Kryo#setRegistrationRequired(boolean)\n-     */\n-    public Builder setRegistrationRequired(final boolean registrationRequired) {\n-      this.registrationRequired = registrationRequired;\n-      return this;\n-    }\n-  }\n-\n-  static final class RegistrationBlock {\n-    private final int begin;\n-    private final ImmutableList<Pair<Class<?>[], Serializer<?>>> types;\n-\n-    RegistrationBlock(final int begin, final List<Pair<Class<?>[], Serializer<?>>> types) {\n-      this.begin = begin;\n-      this.types = ImmutableList.copyOf(types);\n-    }\n-\n-    public int begin() {\n-      return begin;\n-    }\n-\n-    public ImmutableList<Pair<Class<?>[], Serializer<?>>> types() {\n-      return types;\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      return types.hashCode();\n-    }\n-\n-    // Only the registered types are used for equality.\n-    @Override\n-    public boolean equals(final Object obj) {\n-      if (this == obj) {\n-        return true;\n-      }\n-\n-      if (obj instanceof RegistrationBlock) {\n-        final RegistrationBlock that = (RegistrationBlock) obj;\n-        return Objects.equals(this.types, that.types);\n-      }\n-      return false;\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return MoreObjects.toStringHelper(getClass())\n-          .add(\"begin\", begin)\n-          .add(\"types\", types)\n-          .toString();\n-    }\n+  static NamespaceImpl.Builder builder() {\n+    return new NamespaceImpl.Builder();", "originalCommit": "159a323f4e24df2a009a9503aba69dafd5ad430b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0OTY0Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/5244#discussion_r478349646", "bodyText": "A broker running this version always serialize with fallback, but deserialize with the new one. Is that ideal? A cluster running with all 0.24.x broker then always have to fallback when deserializing. Not sure how much performance impact it will have.", "author": "deepthidevaki", "createdAt": "2020-08-27T11:35:32Z", "path": "atomix/utils/src/main/java/io/atomix/utils/serializer/FallbackNamespace.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.utils.serializer;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.atomix.utils.serializer.NamespaceImpl.Builder;\n+import io.atomix.utils.serializer.NamespaceImpl.RegistrationBlock;\n+import java.nio.ByteBuffer;\n+import org.slf4j.Logger;\n+\n+public class FallbackNamespace implements Namespace {\n+\n+  private static final Logger LOG = getLogger(FallbackNamespace.class);\n+  private static final String DESERIALIZE_ERROR =\n+      \"Deserialization failed with both the versioned and fallback serializers. The fallback serializer failed with:\\n %s\";\n+  private final Namespace fallback;\n+  private final Namespace namespace;\n+\n+  FallbackNamespace(final Namespace fallback, final Namespace namespace) {\n+    this.fallback = fallback;\n+    this.namespace = namespace;\n+  }\n+\n+  public FallbackNamespace(final NamespaceImpl.Builder builder) {\n+    final Builder copy = builder.copy();\n+    this.fallback = builder.build();\n+    this.namespace = copy.name(copy.getName() + \"-compatible\").setCompatible(true).build();\n+  }\n+\n+  /**\n+   * Serializes given object to byte array using Kryo instance in pool.\n+   *\n+   * <p>Note: Serialized bytes must be smaller than {@link NamespaceImpl#MAX_BUFFER_SIZE}.\n+   *\n+   * @param obj Object to serialize\n+   * @return serialized bytes\n+   */\n+  public byte[] serialize(final Object obj) {\n+    return fallback.serialize(obj);\n+  }\n+\n+  /**\n+   * Serializes given object to byte array using Kryo instance in pool.\n+   *\n+   * @param obj Object to serialize\n+   * @param bufferSize maximum size of serialized bytes\n+   * @return serialized bytes\n+   */\n+  public byte[] serialize(final Object obj, final int bufferSize) {\n+    return fallback.serialize(obj, bufferSize);\n+  }\n+\n+  /**\n+   * Serializes given object to byte buffer using Kryo instance in pool.\n+   *\n+   * @param obj Object to serialize\n+   * @param buffer to write to\n+   */\n+  public void serialize(final Object obj, final ByteBuffer buffer) {\n+    fallback.serialize(obj, buffer);\n+  }\n+\n+  /**\n+   * Deserializes given byte array to Object using Kryo instance in pool.\n+   *\n+   * @param bytes serialized bytes\n+   * @param <T> deserialized Object type\n+   * @return deserialized Object\n+   */\n+  public <T> T deserialize(final byte[] bytes) {\n+    try {\n+      return namespace.deserialize(bytes);", "originalCommit": "159a323f4e24df2a009a9503aba69dafd5ad430b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1MDY1MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5244#discussion_r478350651", "bodyText": "I think that namespace should be the current one and fallback should be the new one because we have to use fallback only during rolling upgrade to 0.25.x.", "author": "deepthidevaki", "createdAt": "2020-08-27T11:37:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0OTY0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2MDAyOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5244#discussion_r478360028", "bodyText": "That was the original idea but some objects serialized with the CompatibleSerializer didn't fail when being deserialized with the FieldSerializer, instead being deserialized to a bad object which caused NPEs. So I had to switch the order. I realize it's not the ideal path but at least I didn't see a meaningful impact in the benchmark I ran", "author": "MiguelPires", "createdAt": "2020-08-27T11:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0OTY0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2MjM4Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5244#discussion_r478362387", "bodyText": "Ok \ud83d\udc4d", "author": "deepthidevaki", "createdAt": "2020-08-27T11:58:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0OTY0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1NDI2MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5244#discussion_r478354261", "bodyText": "Why is this required?", "author": "deepthidevaki", "createdAt": "2020-08-27T11:44:06Z", "path": "broker/src/test/java/io/zeebe/broker/logstreams/AtomixLogDeletionServiceTest.java", "diffHunk": "@@ -147,7 +147,7 @@ private void createSnapshot(final long index) {\n     try {\n       return builder\n           // hardcode max segment size to allow a single entry only\n-          .withMaxSegmentSize(JournalSegmentDescriptor.BYTES + 8 * Integer.BYTES)\n+          .withMaxSegmentSize(JournalSegmentDescriptor.BYTES + 9 * Integer.BYTES)", "originalCommit": "159a323f4e24df2a009a9503aba69dafd5ad430b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2MzI0OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5244#discussion_r478363248", "bodyText": "That was necessary in the 0.25 changes because the serialized entry was bigger with the new serializer but here we're still using the old one so it shouldn't be necessary. I just forgot to remove it", "author": "MiguelPires", "createdAt": "2020-08-27T11:59:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1NDI2MQ=="}], "type": "inlineReview"}, {"oid": "b3f1b79f5e7277e791c7a8ed553245340560dded", "url": "https://github.com/camunda-cloud/zeebe/commit/b3f1b79f5e7277e791c7a8ed553245340560dded", "message": "chore(atomix): prepare 0.24 for rolling upgrade", "committedDate": "2020-08-27T12:26:40Z", "type": "commit"}, {"oid": "1e546940a59eaa7eb43f42e148d1240fba259f28", "url": "https://github.com/camunda-cloud/zeebe/commit/1e546940a59eaa7eb43f42e148d1240fba259f28", "message": "chore(atomix): disable Kryo logs", "committedDate": "2020-08-27T12:26:42Z", "type": "commit"}, {"oid": "1e546940a59eaa7eb43f42e148d1240fba259f28", "url": "https://github.com/camunda-cloud/zeebe/commit/1e546940a59eaa7eb43f42e148d1240fba259f28", "message": "chore(atomix): disable Kryo logs", "committedDate": "2020-08-27T12:26:42Z", "type": "forcePushed"}]}