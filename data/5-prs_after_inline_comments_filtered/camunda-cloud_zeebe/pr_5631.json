{"pr_number": 5631, "pr_title": "Fix concurrent partition closing", "pr_createdAt": "2020-10-19T14:35:46Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/5631", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwOTAyNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508209026", "bodyText": "We may want to align the names with the other tests.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                final NoopPartitionStep firstComponent = spy(new NoopPartitionStep());\n          \n          \n            \n                final NoopPartitionStep secondComponent = spy(new NoopPartitionStep());\n          \n          \n            \n                final NoopPartitionStep leaderComponent = spy(new NoopPartitionStep());\n          \n          \n            \n                final NoopPartitionStep followerComponent = spy(new NoopPartitionStep());", "author": "saig0", "createdAt": "2020-10-20T04:56:06Z", "path": "broker/src/test/java/io/zeebe/broker/system/partitions/impl/PartitionTransitionTest.java", "diffHunk": "@@ -73,6 +73,210 @@ public void shouldCloseInOppositeOrderOfOpen() {\n     order.verify(firstComponent).close(ctx);\n   }\n \n+  @Test\n+  public void shouldTransitionFromLeaderToFollowerInSequence() {\n+    // given\n+    final NoopPartitionStep firstComponent = spy(new NoopPartitionStep());\n+    final NoopPartitionStep secondComponent = spy(new NoopPartitionStep());", "originalCommit": "f356b398501baa4f66027551b4a00ee95cb5be41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwOTcwNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508209706", "bodyText": "I'm not sure if it is necessary to expose the current future. We can store the future in ZeebePartition itself when calling transition.toLeader() etc.", "author": "saig0", "createdAt": "2020-10-20T04:58:47Z", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionTransitionImpl.java", "diffHunk": "@@ -41,27 +41,48 @@ public PartitionTransitionImpl(\n   @Override\n   public ActorFuture<Void> toFollower() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, followerSteps));\n+    enqueueTransition(future, followerSteps);\n     return future;\n   }\n \n   @Override\n   public ActorFuture<Void> toLeader() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, leaderSteps));\n+    enqueueTransition(future, leaderSteps);\n     return future;\n   }\n \n   @Override\n   public ActorFuture<Void> toInactive() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, EMPTY_LIST));\n+    enqueueTransition(future, EMPTY_LIST);\n     return future;\n   }\n \n+  /**\n+   * This method allows to enqueue the next transition, such that the transitions are executed in\n+   * order. Previous we had the issue that all transitions have subscribe to the current transition,\n+   * which lead to undefined behavior.\n+   *\n+   * @param nextTransitionFuture the future of the next transition\n+   * @param partitionStepList the steps which should be installed on the transition\n+   */\n+  private void enqueueTransition(\n+      final CompletableActorFuture<Void> nextTransitionFuture,\n+      final List<PartitionStep> partitionStepList) {\n+    final var nextCurrentTransition = currentTransitionFuture();\n+    currentTransition = nextTransitionFuture;\n+    nextCurrentTransition.onComplete(\n+        (nothing, err) -> transition(nextTransitionFuture, partitionStepList));\n+  }\n+\n+  @Override\n+  public ActorFuture<Void> currentTransitionFuture() {\n+    return currentTransition;\n+  }", "originalCommit": "f356b398501baa4f66027551b4a00ee95cb5be41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODMwODAyOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508308029", "bodyText": "I agree with this. It'd be good to use the last returned future instead of adding more methods to the interface", "author": "MiguelPires", "createdAt": "2020-10-20T08:28:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwOTcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM3NjE5Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508376196", "bodyText": "What I didn't like on this suggestion is that we need to keep and maintain the same state in the ZeebePartition as we already have in the Transition. I have the feeling that this is a bit unstable, but I change it for now.", "author": "Zelldon", "createdAt": "2020-10-20T10:08:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwOTcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxMDM4OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508210389", "bodyText": "We may want to synchronize this method to be safe. Just in case.", "author": "saig0", "createdAt": "2020-10-20T05:01:00Z", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionTransitionImpl.java", "diffHunk": "@@ -41,27 +41,48 @@ public PartitionTransitionImpl(\n   @Override\n   public ActorFuture<Void> toFollower() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, followerSteps));\n+    enqueueTransition(future, followerSteps);\n     return future;\n   }\n \n   @Override\n   public ActorFuture<Void> toLeader() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, leaderSteps));\n+    enqueueTransition(future, leaderSteps);\n     return future;\n   }\n \n   @Override\n   public ActorFuture<Void> toInactive() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, EMPTY_LIST));\n+    enqueueTransition(future, EMPTY_LIST);\n     return future;\n   }\n \n+  /**\n+   * This method allows to enqueue the next transition, such that the transitions are executed in\n+   * order. Previous we had the issue that all transitions have subscribe to the current transition,\n+   * which lead to undefined behavior.\n+   *\n+   * @param nextTransitionFuture the future of the next transition\n+   * @param partitionStepList the steps which should be installed on the transition\n+   */\n+  private void enqueueTransition(\n+      final CompletableActorFuture<Void> nextTransitionFuture,\n+      final List<PartitionStep> partitionStepList) {\n+    final var nextCurrentTransition = currentTransitionFuture();\n+    currentTransition = nextTransitionFuture;\n+    nextCurrentTransition.onComplete(\n+        (nothing, err) -> transition(nextTransitionFuture, partitionStepList));\n+  }", "originalCommit": "f356b398501baa4f66027551b4a00ee95cb5be41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxNDU1NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508214554", "bodyText": "Locking \ud83d\udc40 really? This is a component by an actor right? Why we should access this by multiple threads?", "author": "Zelldon", "createdAt": "2020-10-20T05:16:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxMDM4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODMwODEzOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508308138", "bodyText": "After discussion we decided to keep it as it is, since it is currently only use by the same actor and multi thread solution is not necessary here.", "author": "Zelldon", "createdAt": "2020-10-20T08:28:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxMDM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxMjU3NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508212575", "bodyText": "Do we really want to wait until the current transition is done? I'm not sure how long this can take \ud83e\udd14\nSince we want to close the partition, it may be faster to interrupt the current transition.", "author": "saig0", "createdAt": "2020-10-20T05:09:12Z", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -203,6 +208,28 @@ protected void onActorStarted() {\n         .registerComponent(zeebePartitionHealth.getName(), zeebePartitionHealth);\n   }\n \n+  @Override\n+  public ActorFuture<Void> closeAsync() {\n+    if (closeFuture != null) {\n+      return closeFuture;\n+    }\n+\n+    closeFuture = new CompletableActorFuture<>();\n+\n+    actor.call(\n+        () ->\n+            // allows to await current transition to avoid concurrent modifications and\n+            // transitioning\n+            currentTransition()\n+                .onComplete(\n+                    (nothing, err) -> {\n+                      LOG.debug(\"Closing Zeebe Partition {}.\", context.getPartitionId());\n+                      super.closeAsync();\n+                    }));", "originalCommit": "f356b398501baa4f66027551b4a00ee95cb5be41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxNDI1Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508214256", "bodyText": "This is not safe and not easy to do so. We talking about a graceful shutdown, then I think we should close everything we have opened otherwise we might end up in an inconsistent state, as we did. How long do you think it will take and why? In all our qa tests we doing a normal close and it worked right?", "author": "Zelldon", "createdAt": "2020-10-20T05:15:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxMjU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI4NTQ3OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508285479", "bodyText": "My only issue is that this will wait for all the enqueued transitions instead of just the one currently running. During normal operations we probably won't have many transitions but if we do then we'll take a long time to close. One alternative would be to store the \"new\" futures in a list when we transition instead of replacing the current future with them. We'd only replace the current one when the current finishes. This would then allow us to \"jump\" the queue when closing it, just wait for the current one and close after that one. However, it adds complexity to the PartitionTransition behavior and it's less elegant than the current solution, so I like it the way it is. Still, I thought it was worth discussing. Thoughts?", "author": "MiguelPires", "createdAt": "2020-10-20T07:54:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxMjU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODMwNTg2Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508305862", "bodyText": "I discussed this with @saig0 . We decided to keep it that way for now, since it is safe and simple. If we see any issues regarding closing time we can investigate here further how to interrupt or close faster. Personally I think it might be dangerous to do that or at least it needs more effort to do it right.", "author": "Zelldon", "createdAt": "2020-10-20T08:25:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxMjU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI3ODU3NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508278575", "bodyText": "You can move the creation of this future into the enqueueTransition method and simply return it from there. That would reduce each of these methods to a single return statement.", "author": "korthout", "createdAt": "2020-10-20T07:43:45Z", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionTransitionImpl.java", "diffHunk": "@@ -41,27 +41,48 @@ public PartitionTransitionImpl(\n   @Override\n   public ActorFuture<Void> toFollower() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, followerSteps));\n+    enqueueTransition(future, followerSteps);\n     return future;\n   }\n \n   @Override\n   public ActorFuture<Void> toLeader() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, leaderSteps));\n+    enqueueTransition(future, leaderSteps);\n     return future;\n   }\n \n   @Override\n   public ActorFuture<Void> toInactive() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();", "originalCommit": "f356b398501baa4f66027551b4a00ee95cb5be41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b8a720b21d8c61a7fe22b9ba0ab1dbe50fe5ff5c", "url": "https://github.com/camunda-cloud/zeebe/commit/b8a720b21d8c61a7fe22b9ba0ab1dbe50fe5ff5c", "message": "fix(borker): fix concurrent partition closing\n\nAllows to close and transition inorder. Previous multiple transitions\nand closing have worked against each other, which means it can lead to\nunexepected out comes or dead locks.\n\nTransitions are now executed in a sequential order. The closing will\nawait the current transition, before starting the next transition and\nclosing all resources.\n\nAdd new tests for transition from different Role and to close the\npartition when currently an transition is on going", "committedDate": "2020-10-20T11:34:11Z", "type": "commit"}, {"oid": "b8a720b21d8c61a7fe22b9ba0ab1dbe50fe5ff5c", "url": "https://github.com/camunda-cloud/zeebe/commit/b8a720b21d8c61a7fe22b9ba0ab1dbe50fe5ff5c", "message": "fix(borker): fix concurrent partition closing\n\nAllows to close and transition inorder. Previous multiple transitions\nand closing have worked against each other, which means it can lead to\nunexepected out comes or dead locks.\n\nTransitions are now executed in a sequential order. The closing will\nawait the current transition, before starting the next transition and\nclosing all resources.\n\nAdd new tests for transition from different Role and to close the\npartition when currently an transition is on going", "committedDate": "2020-10-20T11:34:11Z", "type": "forcePushed"}]}