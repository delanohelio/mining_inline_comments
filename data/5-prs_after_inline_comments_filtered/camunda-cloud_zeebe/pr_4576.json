{"pr_number": 4576, "pr_title": "chore(engine): migrate sequence flow processor", "pr_createdAt": "2020-05-22T08:09:40Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4576", "timeline": [{"oid": "8ef83e94d9e5bfe900d96286ed082a64acab96ea", "url": "https://github.com/camunda-cloud/zeebe/commit/8ef83e94d9e5bfe900d96286ed082a64acab96ea", "message": "chore(engine): migrate sequence flow processor\n\n* mock a BPMN element processor to simplify the implementation\n* join incoming sequence flows on parallel gateway\n* remove unused handlers", "committedDate": "2020-05-22T08:09:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE5NzE0Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4576#discussion_r429197142", "bodyText": "Considering our little thought experiment regarding a different way to deal with sequence flow processing, I would like to use onActivated here. That would then be the state in which the flow is actually taken (while activating is the step in which the condition could be checked.", "author": "korthout", "createdAt": "2020-05-22T11:39:25Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/BpmnStreamProcessor.java", "diffHunk": "@@ -142,6 +142,11 @@ private void processEvent(\n       case ELEMENT_TERMINATED:\n         processor.onTerminated(element, context);\n         break;\n+      case SEQUENCE_FLOW_TAKEN:\n+        // in order to keep the implementation simple, a sequence flow acts as an element that can\n+        // process `activating`\n+        processor.onActivating(element, context);", "originalCommit": "8ef83e94d9e5bfe900d96286ed082a64acab96ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTczODg5MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4576#discussion_r429738890", "bodyText": "I chose activating because it is the initial step of a processor. But I have no strong option on it \ud83d\ude05", "author": "saig0", "createdAt": "2020-05-25T05:38:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE5NzE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE5ODM3Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4576#discussion_r429198376", "bodyText": "\ud83d\udc7e", "author": "korthout", "createdAt": "2020-05-22T11:42:34Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/sequenceflow/SequenceFlowProcessor.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.sequenceflow;\n+\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.nwe.BpmnElementProcessor;\n+import io.zeebe.engine.nwe.behavior.BpmnBehaviors;\n+import io.zeebe.engine.nwe.behavior.BpmnDeferredRecordsBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateTransitionBehavior;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableFlowNode;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableSequenceFlow;\n+import io.zeebe.engine.state.instance.IndexedRecord;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A sequence flow doesn't have a proper lifecycle as the other BPMN elements. It can only be taken.\n+ * However, it implements the same interface to keep the rest of implementation simple. But only the\n+ * method {@link #onActivating(ExecutableSequenceFlow, BpmnElementContext)} perform the action.\n+ * Calling other methods causes an exception.\n+ */\n+public final class SequenceFlowProcessor implements BpmnElementProcessor<ExecutableSequenceFlow> {\n+\n+  private final BpmnStateTransitionBehavior stateTransitionBehavior;\n+  private final BpmnStateBehavior stateBehavior;\n+  private final BpmnDeferredRecordsBehavior deferredRecordsBehavior;\n+\n+  public SequenceFlowProcessor(final BpmnBehaviors bpmnBehaviors) {\n+    stateTransitionBehavior = bpmnBehaviors.stateTransitionBehavior();\n+    stateBehavior = bpmnBehaviors.stateBehavior();\n+    deferredRecordsBehavior = bpmnBehaviors.deferredRecordsBehavior();\n+  }\n+\n+  @Override\n+  public Class<ExecutableSequenceFlow> getType() {\n+    return ExecutableSequenceFlow.class;\n+  }\n+\n+  @Override\n+  public void onActivating(final ExecutableSequenceFlow element, final BpmnElementContext context) {\n+    onSequenceFlowTaken(element, context);\n+  }\n+\n+  @Override\n+  public void onActivated(final ExecutableSequenceFlow element, final BpmnElementContext context) {\n+    throw new UnsupportedSequenceFlowOperationException(context);\n+  }\n+\n+  @Override\n+  public void onCompleting(final ExecutableSequenceFlow element, final BpmnElementContext context) {\n+    throw new UnsupportedSequenceFlowOperationException(context);\n+  }\n+\n+  @Override\n+  public void onCompleted(final ExecutableSequenceFlow element, final BpmnElementContext context) {\n+    throw new UnsupportedSequenceFlowOperationException(context);\n+  }\n+\n+  @Override\n+  public void onTerminating(\n+      final ExecutableSequenceFlow element, final BpmnElementContext context) {\n+    throw new UnsupportedSequenceFlowOperationException(context);\n+  }\n+\n+  @Override\n+  public void onTerminated(final ExecutableSequenceFlow element, final BpmnElementContext context) {\n+    throw new UnsupportedSequenceFlowOperationException(context);\n+  }\n+\n+  @Override\n+  public void onEventOccurred(\n+      final ExecutableSequenceFlow element, final BpmnElementContext context) {\n+    throw new UnsupportedSequenceFlowOperationException(context);\n+  }\n+\n+  private void onSequenceFlowTaken(\n+      final ExecutableSequenceFlow element, final BpmnElementContext context) {\n+\n+    final var targetElement = element.getTarget();\n+\n+    if (targetElement.getElementType() == BpmnElementType.PARALLEL_GATEWAY) {\n+      joinOnParallelGateway(targetElement, context);\n+\n+    } else {\n+      stateTransitionBehavior.activateElementInstanceInFlowScope(context, targetElement);\n+    }\n+  }\n+\n+  private void joinOnParallelGateway(\n+      final ExecutableFlowNode parallelGateway, final BpmnElementContext context) {\n+\n+    // before the parallel gateway is activated, each incoming sequence flow of the gateway must be\n+    // taken (at least once)\n+\n+    // if a sequence flow is taken more than once then the redundant token remains for the next\n+    // activation of the gateway (Tetris principle)\n+\n+    final var flowScopeContext = stateBehavior.getFlowScopeContext(context);\n+\n+    // store which sequence flows are taken as deferred records\n+    deferredRecordsBehavior.deferNewRecord(\n+        flowScopeContext,\n+        context.getElementInstanceKey(),\n+        context.getRecordValue(),\n+        context.getIntent());\n+\n+    final var tokensBySequenceFlow =\n+        deferredRecordsBehavior.getDeferredRecords(flowScopeContext).stream()\n+            .filter(record -> record.getState() == WorkflowInstanceIntent.SEQUENCE_FLOW_TAKEN)\n+            .filter(record -> isIncomingSequenceFlow(record, parallelGateway))\n+            .collect(Collectors.groupingBy(record -> record.getValue().getElementIdBuffer()));\n+\n+    if (tokensBySequenceFlow.size() == parallelGateway.getIncoming().size()) {\n+      // all incoming sequence flows are taken, so the gateway can be activated\n+\n+      final var flowScopeInstance = stateBehavior.getFlowScopeInstance(context);\n+\n+      // consume one token per sequence flow\n+      tokensBySequenceFlow.forEach(\n+          (sequenceFlow, tokens) -> {\n+            final var firstToken = tokens.get(0);\n+            deferredRecordsBehavior.removeDeferredRecord(flowScopeContext, firstToken);\n+\n+            flowScopeInstance.consumeToken();\n+          });\n+\n+      // spawn a new token for the activated gateway\n+      flowScopeInstance.spawnToken();\n+      stateBehavior.updateElementInstance(flowScopeInstance);\n+\n+      stateTransitionBehavior.activateElementInstanceInFlowScope(context, parallelGateway);\n+    }\n+  }\n+\n+  private boolean isIncomingSequenceFlow(\n+      final IndexedRecord record, final ExecutableFlowNode parallelGateway) {\n+    final var elementId = record.getValue().getElementIdBuffer();\n+\n+    for (final ExecutableSequenceFlow incomingSequenceFlow : parallelGateway.getIncoming()) {\n+      if (elementId.equals(incomingSequenceFlow.getId())) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static final class UnsupportedSequenceFlowOperationException\n+      extends UnsupportedOperationException {\n+\n+    private static final String MESSAGE =\n+        \"This is not the method you're looking for. [context: %s]\";", "originalCommit": "8ef83e94d9e5bfe900d96286ed082a64acab96ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwMTUwOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4576#discussion_r429201508", "bodyText": "This method is quite similar to BpmnStateTransitionBehavior#takeSequenceFlow, but there we also do:\nstateBehavior.spawnToken(context);\n\nShould we do that here too?", "author": "korthout", "createdAt": "2020-05-22T11:50:23Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/BpmnStateTransitionBehavior.java", "diffHunk": "@@ -154,6 +154,25 @@ public ElementInstance activateChildInstance(\n     return stateBehavior.createChildElementInstance(context, childInstanceKey, childInstanceRecord);\n   }\n \n+  public void activateElementInstanceInFlowScope(\n+      final BpmnElementContext context, final ExecutableFlowElement element) {\n+\n+    final var elementInstanceRecord =\n+        context\n+            .getRecordValue()\n+            .setFlowScopeKey(context.getFlowScopeKey())\n+            .setElementId(element.getId())\n+            .setBpmnElementType(element.getElementType());\n+\n+    final var elementInstanceKey = keyGenerator.nextKey();\n+\n+    streamWriter.appendNewEvent(\n+        elementInstanceKey, WorkflowInstanceIntent.ELEMENT_ACTIVATING, elementInstanceRecord);\n+\n+    stateBehavior.createElementInstanceInFlowScope(\n+        context, elementInstanceKey, elementInstanceRecord);", "originalCommit": "8ef83e94d9e5bfe900d96286ed082a64acab96ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc0MDkyOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4576#discussion_r429740928", "bodyText": "Currently, the token is spawned before. So, we would need to consume it first. I would continue with this state for now and review it later when we implemented more processors.", "author": "saig0", "createdAt": "2020-05-25T05:47:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwMTUwOA=="}], "type": "inlineReview"}]}