{"pr_number": 4682, "pr_title": "Migrate call activity processor", "pr_createdAt": "2020-06-08T15:35:29Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4682", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIwMTI5NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4682#discussion_r439201295", "bodyText": "Maybe, we can avoid the string wrapping in the method. Usually, we are using DirectBuffer in this case.\nWe should think about the method name because it is not obvious that it returns the latest version of the workflow.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public Optional<DeployedWorkflow> getWorkflow(final String processId) {\n          \n          \n            \n                final var workflow = workflowState.getLatestWorkflowVersionByProcessId(wrapString(processId));\n          \n          \n            \n                return Optional.ofNullable(workflow);\n          \n          \n            \n              }\n          \n          \n            \n              public Optional<DeployedWorkflow> getWorkflow(final DirectBuffer processId) {\n          \n          \n            \n                final var workflow = workflowState.getLatestWorkflowVersionByProcessId(processId);\n          \n          \n            \n                return Optional.ofNullable(workflow);\n          \n          \n            \n              }", "author": "saig0", "createdAt": "2020-06-12T04:32:46Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/BpmnStateBehavior.java", "diffHunk": "@@ -189,4 +201,21 @@ public BpmnElementContext getParentElementInstanceContext(final BpmnElementConte\n         parentElementInstance.getValue(),\n         parentElementInstance.getState());\n   }\n+\n+  public Optional<DeployedWorkflow> getWorkflow(final String processId) {\n+    final var workflow = workflowState.getLatestWorkflowVersionByProcessId(wrapString(processId));\n+    return Optional.ofNullable(workflow);\n+  }", "originalCommit": "715cc15b735d8373afa10872ed1ad8c3a2984c7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0NTI5Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4682#discussion_r439245293", "bodyText": "Good points \ud83d\udc4d", "author": "korthout", "createdAt": "2020-06-12T07:07:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIwMTI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIwNDQwMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4682#discussion_r439204401", "bodyText": "Using the workflow key instead of the BPMN process id to avoid that we are using a newer version of the workflow.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (flowScope != null) {\n          \n          \n            \n                  containerContext = stateBehavior.getFlowScopeContext(childContext);\n          \n          \n            \n                  containerProcessor = processorLookUp.apply(flowScope.getElementType());\n          \n          \n            \n                  containerScope = flowScope;\n          \n          \n            \n                } else {\n          \n          \n            \n                  // no flowscope, assume this is called from a parent workflow\n          \n          \n            \n                  containerContext = stateBehavior.getParentElementInstanceContext(childContext);\n          \n          \n            \n                  containerProcessor = processorLookUp.apply(containerContext.getBpmnElementType());\n          \n          \n            \n                  final var processId = containerContext.getBpmnProcessId();\n          \n          \n            \n                  containerScope =\n          \n          \n            \n                      stateBehavior\n          \n          \n            \n                          .getWorkflow(BufferUtil.bufferAsString(processId))\n          \n          \n            \n                          .orElseThrow(\n          \n          \n            \n                              () ->\n          \n          \n            \n                                  new BpmnProcessingException(\n          \n          \n            \n                                      childContext, String.format(NO_WORKFLOW_FOUND_MESSAGE, processId)))\n          \n          \n            \n                          .getWorkflow()\n          \n          \n            \n                          .getElementById(containerContext.getElementId(), ExecutableCallActivity.class);\n          \n          \n            \n                }\n          \n          \n            \n                containerProcessor.onChildTerminated(containerScope, containerContext, childContext);\n          \n          \n            \n                if (flowScope != null) {\n          \n          \n            \n                  containerContext = stateBehavior.getFlowScopeContext(childContext);\n          \n          \n            \n                  containerScope = flowScope;\n          \n          \n            \n                } else {\n          \n          \n            \n                  // no flowscope, assume this is called from a parent workflow\n          \n          \n            \n                  containerContext = stateBehavior.getParentElementInstanceContext(childContext);\n          \n          \n            \n                  containerScope =\n          \n          \n            \n                      stateBehavior\n          \n          \n            \n                          .getWorkflow(containerContext.getWorkflowKey())\n          \n          \n            \n                          .map(DeployedWorkflow::getWorkflow)\n          \n          \n            \n                          .map(workflow -> workflow.getElementById(containerContext.getElementId(), ExecutableCallActivity.class))\n          \n          \n            \n                          .orElseThrow(\n          \n          \n            \n                              () ->\n          \n          \n            \n                                  new BpmnProcessingException(\n          \n          \n            \n                                      childContext, String.format(NO_WORKFLOW_FOUND_MESSAGE, workflowKey)\n          \n          \n            \n                }\n          \n          \n            \n                final var containerProcessor = processorLookUp.apply(containerContext.getBpmnElementType());\n          \n          \n            \n                containerProcessor.onChildTerminated(containerScope, containerContext, childContext);", "author": "saig0", "createdAt": "2020-06-12T04:47:01Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/BpmnStateTransitionBehavior.java", "diffHunk": "@@ -228,11 +234,71 @@ public void onElementCompleted(\n \n   public void onElementTerminated(\n       final ExecutableFlowElement element, final BpmnElementContext childContext) {\n-\n+    final BpmnElementContainerProcessor<ExecutableFlowElement> containerProcessor;\n+    final ExecutableFlowElement containerScope;\n+    final BpmnElementContext containerContext;\n     final var flowScope = element.getFlowScope();\n-    final var flowScopeProcessor = processorLookUp.apply(flowScope.getElementType());\n-    final var flowScopeContext = stateBehavior.getFlowScopeContext(childContext);\n+    if (flowScope != null) {\n+      containerContext = stateBehavior.getFlowScopeContext(childContext);\n+      containerProcessor = processorLookUp.apply(flowScope.getElementType());\n+      containerScope = flowScope;\n+    } else {\n+      // no flowscope, assume this is called from a parent workflow\n+      containerContext = stateBehavior.getParentElementInstanceContext(childContext);\n+      containerProcessor = processorLookUp.apply(containerContext.getBpmnElementType());\n+      final var processId = containerContext.getBpmnProcessId();\n+      containerScope =\n+          stateBehavior\n+              .getWorkflow(BufferUtil.bufferAsString(processId))\n+              .orElseThrow(\n+                  () ->\n+                      new BpmnProcessingException(\n+                          childContext, String.format(NO_WORKFLOW_FOUND_MESSAGE, processId)))\n+              .getWorkflow()\n+              .getElementById(containerContext.getElementId(), ExecutableCallActivity.class);\n+    }\n+    containerProcessor.onChildTerminated(containerScope, containerContext, childContext);", "originalCommit": "715cc15b735d8373afa10872ed1ad8c3a2984c7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIwNjgyMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4682#discussion_r439206820", "bodyText": "It would be nice to use transitionToTerminating(childInstanceContext) here too.", "author": "saig0", "createdAt": "2020-06-12T04:58:22Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/BpmnStateTransitionBehavior.java", "diffHunk": "@@ -228,11 +234,71 @@ public void onElementCompleted(\n \n   public void onElementTerminated(\n       final ExecutableFlowElement element, final BpmnElementContext childContext) {\n-\n+    final BpmnElementContainerProcessor<ExecutableFlowElement> containerProcessor;\n+    final ExecutableFlowElement containerScope;\n+    final BpmnElementContext containerContext;\n     final var flowScope = element.getFlowScope();\n-    final var flowScopeProcessor = processorLookUp.apply(flowScope.getElementType());\n-    final var flowScopeContext = stateBehavior.getFlowScopeContext(childContext);\n+    if (flowScope != null) {\n+      containerContext = stateBehavior.getFlowScopeContext(childContext);\n+      containerProcessor = processorLookUp.apply(flowScope.getElementType());\n+      containerScope = flowScope;\n+    } else {\n+      // no flowscope, assume this is called from a parent workflow\n+      containerContext = stateBehavior.getParentElementInstanceContext(childContext);\n+      containerProcessor = processorLookUp.apply(containerContext.getBpmnElementType());\n+      final var processId = containerContext.getBpmnProcessId();\n+      containerScope =\n+          stateBehavior\n+              .getWorkflow(BufferUtil.bufferAsString(processId))\n+              .orElseThrow(\n+                  () ->\n+                      new BpmnProcessingException(\n+                          childContext, String.format(NO_WORKFLOW_FOUND_MESSAGE, processId)))\n+              .getWorkflow()\n+              .getElementById(containerContext.getElementId(), ExecutableCallActivity.class);\n+    }\n+    containerProcessor.onChildTerminated(containerScope, containerContext, childContext);\n+  }\n+\n+  public long createChildProcessInstance(\n+      final DeployedWorkflow workflow, final BpmnElementContext context) {\n+\n+    final var workflowInstanceKey = keyGenerator.nextKey();\n \n-    flowScopeProcessor.onChildTerminated(flowScope, flowScopeContext, childContext);\n+    childInstanceRecord.reset();\n+    childInstanceRecord\n+        .setBpmnProcessId(workflow.getBpmnProcessId())\n+        .setVersion(workflow.getVersion())\n+        .setWorkflowKey(workflow.getKey())\n+        .setWorkflowInstanceKey(workflowInstanceKey)\n+        .setParentWorkflowInstanceKey(context.getWorkflowInstanceKey())\n+        .setParentElementInstanceKey(context.getElementInstanceKey())\n+        .setElementId(workflow.getWorkflow().getId())\n+        .setBpmnElementType(workflow.getWorkflow().getElementType());\n+\n+    streamWriter.appendFollowUpEvent(\n+        workflowInstanceKey, WorkflowInstanceIntent.ELEMENT_ACTIVATING, childInstanceRecord);\n+\n+    stateBehavior.createElementInstance(workflowInstanceKey, childInstanceRecord);\n+\n+    return workflowInstanceKey;\n+  }\n+\n+  public void terminateChildProcessInstance(final BpmnElementContext context) {\n+    final var elementInstance = stateBehavior.getElementInstance(context);\n+    final var childInstanceKey = elementInstance.getCalledChildInstanceKey();\n+    final var optionalChildInstance = stateBehavior.getCalledChildInstance(context);\n+    optionalChildInstance\n+        .filter(ElementInstance::canTerminate)\n+        .ifPresentOrElse(\n+            childInstance -> {\n+              childInstance.setState(WorkflowInstanceIntent.ELEMENT_TERMINATING);\n+              stateBehavior.updateElementInstance(childInstance);\n+              streamWriter.appendFollowUpEvent(\n+                  childInstanceKey,\n+                  WorkflowInstanceIntent.ELEMENT_TERMINATING,\n+                  childInstance.getValue());", "originalCommit": "715cc15b735d8373afa10872ed1ad8c3a2984c7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIwNzkwNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4682#discussion_r439207904", "bodyText": "\ud83d\udc4d\nWe should also call onElementCompleted() in onCompleted().", "author": "saig0", "createdAt": "2020-06-12T05:03:35Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/container/ProcessProcessor.java", "diffHunk": "@@ -143,16 +143,7 @@ public void onTerminated(\n \n     if (parentWorkflowInstanceKey > 0) {\n       // workflow instance is created by a call activity\n-\n-      // TODO (saig0): move responsibility to call activity (#4473)\n-      final var parentElementInstance = stateBehavior.getParentElementInstanceContext(context);\n-\n-      if (parentElementInstance != null\n-          && parentElementInstance.getIntent() == WorkflowInstanceIntent.ELEMENT_TERMINATING) {\n-        // terminate the corresponding call activity\n-\n-        stateTransitionBehavior.transitionToTerminated(parentElementInstance);\n-      }\n+      stateTransitionBehavior.onElementTerminated(element, context);", "originalCommit": "715cc15b735d8373afa10872ed1ad8c3a2984c7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM4ODU0OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4682#discussion_r439388548", "bodyText": "We shouldn't directly, it already calls takeOutgoingSequenceFlows() which in turn also calls onElementCompleted() if there are no outgoing sequence flows. So indirectly we already do", "author": "korthout", "createdAt": "2020-06-12T12:28:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIwNzkwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzMTUyMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4682#discussion_r439931521", "bodyText": "I'm sorry for the confusion \ud83d\ude05\nI mean that there is a remaining TODO in ProcessProcessor#onComplete(). I think that CallActivityProcessor#onChildCompleted() is currently no called.", "author": "saig0", "createdAt": "2020-06-15T05:03:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIwNzkwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIwOTQ0Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4682#discussion_r439209443", "bodyText": "I would move the writing of the activated event before the activating of the child workflow instance. Otherwise, we change the order of the events and for me, it feels more intuitive the other way around :)", "author": "saig0", "createdAt": "2020-06-12T05:09:48Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/container/CallActivityProcessor.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.container;\n+\n+import io.zeebe.engine.nwe.BpmnElementContainerProcessor;\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.nwe.BpmnProcessingException;\n+import io.zeebe.engine.nwe.behavior.BpmnBehaviors;\n+import io.zeebe.engine.nwe.behavior.BpmnEventSubscriptionBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnIncidentBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateTransitionBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnVariableMappingBehavior;\n+import io.zeebe.engine.processor.Failure;\n+import io.zeebe.engine.processor.workflow.ExpressionProcessor;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableCallActivity;\n+import io.zeebe.engine.state.deployment.DeployedWorkflow;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.ErrorType;\n+import io.zeebe.util.Either;\n+import io.zeebe.util.buffer.BufferUtil;\n+\n+public final class CallActivityProcessor\n+    implements BpmnElementContainerProcessor<ExecutableCallActivity> {\n+\n+  private static final String UNABLE_TO_COMPLETE_FROM_STATE_MESSAGE =\n+      \"Expected to complete call activity after child completed, but call activity cannot be completed from state '%s'\";\n+  private static final String UNABLE_TO_TERMINATE_FROM_STATE_MESSAGE =\n+      \"Expected to terminate call activity after child terminated, but call activity cannot be terminated from state '%s'\";\n+\n+  private final ExpressionProcessor expressionProcessor;\n+  private final BpmnStateTransitionBehavior stateTransitionBehavior;\n+  private final BpmnStateBehavior stateBehavior;\n+  private final BpmnIncidentBehavior incidentBehavior;\n+  private final BpmnEventSubscriptionBehavior eventSubscriptionBehavior;\n+  private final BpmnVariableMappingBehavior variableMappingBehavior;\n+\n+  public CallActivityProcessor(final BpmnBehaviors bpmnBehaviors) {\n+    expressionProcessor = bpmnBehaviors.expressionBehavior();\n+    stateTransitionBehavior = bpmnBehaviors.stateTransitionBehavior();\n+    stateBehavior = bpmnBehaviors.stateBehavior();\n+    incidentBehavior = bpmnBehaviors.incidentBehavior();\n+    eventSubscriptionBehavior = bpmnBehaviors.eventSubscriptionBehavior();\n+    variableMappingBehavior = bpmnBehaviors.variableMappingBehavior();\n+  }\n+\n+  @Override\n+  public Class<ExecutableCallActivity> getType() {\n+    return ExecutableCallActivity.class;\n+  }\n+\n+  @Override\n+  public void onActivating(final ExecutableCallActivity element, final BpmnElementContext context) {\n+    variableMappingBehavior\n+        .applyInputMappings(context, element)\n+        .flatMap(ok -> eventSubscriptionBehavior.subscribeToEvents(element, context))\n+        .flatMap(ok -> evaluateProcessId(context, element))\n+        .flatMap(this::getWorkflowForProcessId)\n+        .flatMap(this::checkWorkflowHasNoneStartEvent)\n+        .ifRightOrLeft(\n+            workflow -> {\n+              final var childWorkflowInstanceKey =\n+                  stateTransitionBehavior.createChildProcessInstance(workflow, context);\n+\n+              final var callActivityInstance = stateBehavior.getElementInstance(context);\n+              callActivityInstance.setCalledChildInstanceKey(childWorkflowInstanceKey);\n+              stateBehavior.updateElementInstance(callActivityInstance);\n+\n+              final var callActivityInstanceKey = context.getElementInstanceKey();\n+              stateBehavior.copyVariables(\n+                  callActivityInstanceKey, childWorkflowInstanceKey, workflow);\n+\n+              stateTransitionBehavior.transitionToActivated(context);", "originalCommit": "715cc15b735d8373afa10872ed1ad8c3a2984c7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzMDAyNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4682#discussion_r439930027", "bodyText": "Looking at the code, it is easy to oversee that either terminating is written for the child instance or terminated for the call activity. Maybe, we can improve it a bit.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void terminateChildProcessInstance(final BpmnElementContext context) {\n          \n          \n            \n                stateBehavior\n          \n          \n            \n                    .getCalledChildInstance(context)\n          \n          \n            \n                    .filter(ElementInstance::canTerminate)\n          \n          \n            \n                    .map(instance -> context.copy(instance.getKey(), instance.getValue(), instance.getState()))\n          \n          \n            \n                    .ifPresentOrElse(this::transitionToTerminating, () -> transitionToTerminated(context));\n          \n          \n            \n              public void terminateChildProcessInstance(final BpmnElementContext containerContext) {\n          \n          \n            \n                stateBehavior\n          \n          \n            \n                    .getCalledChildInstance(containerContext)\n          \n          \n            \n                    .filter(ElementInstance::canTerminate)\n          \n          \n            \n                    .map(instance -> context.copy(instance.getKey(), instance.getValue(), instance.getState()))\n          \n          \n            \n                    .ifPresentOrElse(\n          \n          \n            \n                      childInstanceContext -> transitionToTerminating(childInstanceContext), \n          \n          \n            \n                      () -> transitionToTerminated(containerContext));", "author": "saig0", "createdAt": "2020-06-15T04:55:54Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/BpmnStateTransitionBehavior.java", "diffHunk": "@@ -228,11 +233,64 @@ public void onElementCompleted(\n \n   public void onElementTerminated(\n       final ExecutableFlowElement element, final BpmnElementContext childContext) {\n-\n+    final ExecutableFlowElement containerScope;\n+    final BpmnElementContext containerContext;\n     final var flowScope = element.getFlowScope();\n-    final var flowScopeProcessor = processorLookUp.apply(flowScope.getElementType());\n-    final var flowScopeContext = stateBehavior.getFlowScopeContext(childContext);\n+    if (flowScope != null) {\n+      containerContext = stateBehavior.getFlowScopeContext(childContext);\n+      containerScope = flowScope;\n+    } else {\n+      // no flowscope, assume this is called from a parent workflow\n+      containerContext = stateBehavior.getParentElementInstanceContext(childContext);\n+      containerScope = getParentWorkflowScope(containerContext, childContext);\n+    }\n+    final var containerProcessor = processorLookUp.apply(containerContext.getBpmnElementType());\n+    containerProcessor.onChildTerminated(containerScope, containerContext, childContext);\n+  }\n+\n+  private ExecutableCallActivity getParentWorkflowScope(\n+      final BpmnElementContext callActivityContext, final BpmnElementContext childContext) {\n+    final var workflowKey = callActivityContext.getWorkflowKey();\n+    final var elementId = callActivityContext.getElementId();\n+    return stateBehavior\n+        .getWorkflow(workflowKey)\n+        .map(DeployedWorkflow::getWorkflow)\n+        .map(workflow -> workflow.getElementById(elementId, ExecutableCallActivity.class))\n+        .orElseThrow(\n+            () ->\n+                new BpmnProcessingException(\n+                    childContext, String.format(NO_WORKFLOW_FOUND_MESSAGE, workflowKey)));\n+  }\n+\n+  public long createChildProcessInstance(\n+      final DeployedWorkflow workflow, final BpmnElementContext context) {\n+\n+    final var workflowInstanceKey = keyGenerator.nextKey();\n+\n+    childInstanceRecord.reset();\n+    childInstanceRecord\n+        .setBpmnProcessId(workflow.getBpmnProcessId())\n+        .setVersion(workflow.getVersion())\n+        .setWorkflowKey(workflow.getKey())\n+        .setWorkflowInstanceKey(workflowInstanceKey)\n+        .setParentWorkflowInstanceKey(context.getWorkflowInstanceKey())\n+        .setParentElementInstanceKey(context.getElementInstanceKey())\n+        .setElementId(workflow.getWorkflow().getId())\n+        .setBpmnElementType(workflow.getWorkflow().getElementType());\n+\n+    streamWriter.appendFollowUpEvent(\n+        workflowInstanceKey, WorkflowInstanceIntent.ELEMENT_ACTIVATING, childInstanceRecord);\n+\n+    stateBehavior.createElementInstance(workflowInstanceKey, childInstanceRecord);\n+\n+    return workflowInstanceKey;\n+  }\n \n-    flowScopeProcessor.onChildTerminated(flowScope, flowScopeContext, childContext);\n+  public void terminateChildProcessInstance(final BpmnElementContext context) {\n+    stateBehavior\n+        .getCalledChildInstance(context)\n+        .filter(ElementInstance::canTerminate)\n+        .map(instance -> context.copy(instance.getKey(), instance.getValue(), instance.getState()))\n+        .ifPresentOrElse(this::transitionToTerminating, () -> transitionToTerminated(context));", "originalCommit": "d53f0707fc60c06c43497b046997a57284591959", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NjkyNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4682#discussion_r439976926", "bodyText": "I thought about this before, and I'm not sure that I like that better. There's more other characters in those lines of code leading further away from the difference in state and more towards which context is being transitioned.\nI thought about using something like transitionTo(<one-of-the-contexts>, TERMINATING/TERMINATED) to be more explicit, but transitionTo already is an existing method in this class, that does less then the transitionToTerminating and transitionToTerminated methods.\nLet's discuss during our next f2f.", "author": "korthout", "createdAt": "2020-06-15T07:23:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzMDAyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzMjA0Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4682#discussion_r439932046", "bodyText": "To avoid the creation of a new buffer, the method evaluateStringExpression() could return the buffer directly. There is a method in the expression processor that is not migrated yet.", "author": "saig0", "createdAt": "2020-06-15T05:05:46Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/container/CallActivityProcessor.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.container;\n+\n+import io.zeebe.engine.nwe.BpmnElementContainerProcessor;\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.nwe.BpmnProcessingException;\n+import io.zeebe.engine.nwe.behavior.BpmnBehaviors;\n+import io.zeebe.engine.nwe.behavior.BpmnEventSubscriptionBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnIncidentBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateTransitionBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnVariableMappingBehavior;\n+import io.zeebe.engine.processor.Failure;\n+import io.zeebe.engine.processor.workflow.ExpressionProcessor;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableCallActivity;\n+import io.zeebe.engine.state.deployment.DeployedWorkflow;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.ErrorType;\n+import io.zeebe.util.Either;\n+import io.zeebe.util.buffer.BufferUtil;\n+import org.agrona.DirectBuffer;\n+\n+public final class CallActivityProcessor\n+    implements BpmnElementContainerProcessor<ExecutableCallActivity> {\n+\n+  private static final String UNABLE_TO_COMPLETE_FROM_STATE_MESSAGE =\n+      \"Expected to complete call activity after child completed, but call activity cannot be completed from state '%s'\";\n+  private static final String UNABLE_TO_TERMINATE_FROM_STATE_MESSAGE =\n+      \"Expected to terminate call activity after child terminated, but call activity cannot be terminated from state '%s'\";\n+\n+  private final ExpressionProcessor expressionProcessor;\n+  private final BpmnStateTransitionBehavior stateTransitionBehavior;\n+  private final BpmnStateBehavior stateBehavior;\n+  private final BpmnIncidentBehavior incidentBehavior;\n+  private final BpmnEventSubscriptionBehavior eventSubscriptionBehavior;\n+  private final BpmnVariableMappingBehavior variableMappingBehavior;\n+\n+  public CallActivityProcessor(final BpmnBehaviors bpmnBehaviors) {\n+    expressionProcessor = bpmnBehaviors.expressionBehavior();\n+    stateTransitionBehavior = bpmnBehaviors.stateTransitionBehavior();\n+    stateBehavior = bpmnBehaviors.stateBehavior();\n+    incidentBehavior = bpmnBehaviors.incidentBehavior();\n+    eventSubscriptionBehavior = bpmnBehaviors.eventSubscriptionBehavior();\n+    variableMappingBehavior = bpmnBehaviors.variableMappingBehavior();\n+  }\n+\n+  @Override\n+  public Class<ExecutableCallActivity> getType() {\n+    return ExecutableCallActivity.class;\n+  }\n+\n+  @Override\n+  public void onActivating(final ExecutableCallActivity element, final BpmnElementContext context) {\n+    variableMappingBehavior\n+        .applyInputMappings(context, element)\n+        .flatMap(ok -> eventSubscriptionBehavior.subscribeToEvents(element, context))\n+        .flatMap(ok -> evaluateProcessId(context, element))\n+        .flatMap(this::getWorkflowForProcessId)\n+        .flatMap(this::checkWorkflowHasNoneStartEvent)\n+        .ifRightOrLeft(\n+            workflow -> {\n+              stateTransitionBehavior.transitionToActivated(context);\n+\n+              final var childWorkflowInstanceKey =\n+                  stateTransitionBehavior.createChildProcessInstance(workflow, context);\n+\n+              final var callActivityInstance = stateBehavior.getElementInstance(context);\n+              callActivityInstance.setCalledChildInstanceKey(childWorkflowInstanceKey);\n+              stateBehavior.updateElementInstance(callActivityInstance);\n+\n+              final var callActivityInstanceKey = context.getElementInstanceKey();\n+              stateBehavior.copyVariables(\n+                  callActivityInstanceKey, childWorkflowInstanceKey, workflow);\n+            },\n+            failure -> incidentBehavior.createIncident(failure, context));\n+  }\n+\n+  @Override\n+  public void onActivated(final ExecutableCallActivity element, final BpmnElementContext context) {\n+    // Nothing to do but wait until the child process has completed\n+  }\n+\n+  @Override\n+  public void onCompleting(final ExecutableCallActivity element, final BpmnElementContext context) {\n+    variableMappingBehavior\n+        .applyOutputMappings(context, element)\n+        .ifRightOrLeft(\n+            ok -> {\n+              eventSubscriptionBehavior.unsubscribeFromEvents(context);\n+              stateTransitionBehavior.transitionToCompleted(context);\n+            },\n+            failure -> incidentBehavior.createIncident(failure, context));\n+  }\n+\n+  @Override\n+  public void onCompleted(final ExecutableCallActivity element, final BpmnElementContext context) {\n+    stateTransitionBehavior.takeOutgoingSequenceFlows(element, context);\n+    stateBehavior.consumeToken(context);\n+    stateBehavior.removeElementInstance(context);\n+  }\n+\n+  @Override\n+  public void onTerminating(\n+      final ExecutableCallActivity element, final BpmnElementContext context) {\n+    stateTransitionBehavior.terminateChildProcessInstance(context);\n+    eventSubscriptionBehavior.unsubscribeFromEvents(context);\n+  }\n+\n+  @Override\n+  public void onTerminated(final ExecutableCallActivity element, final BpmnElementContext context) {\n+    eventSubscriptionBehavior.publishTriggeredBoundaryEvent(context);\n+    incidentBehavior.resolveIncidents(context);\n+    stateTransitionBehavior.onElementTerminated(element, context);\n+    stateBehavior.consumeToken(context);\n+    stateBehavior.removeElementInstance(context);\n+  }\n+\n+  @Override\n+  public void onEventOccurred(\n+      final ExecutableCallActivity element, final BpmnElementContext context) {\n+    eventSubscriptionBehavior.triggerBoundaryEvent(element, context);\n+  }\n+\n+  @Override\n+  public void onChildCompleted(\n+      final ExecutableCallActivity element,\n+      final BpmnElementContext callActivityContext,\n+      final BpmnElementContext childContext) {\n+    final var currentState = callActivityContext.getIntent();\n+    switch (currentState) {\n+      case ELEMENT_ACTIVATED:\n+        stateTransitionBehavior.transitionToCompleting(callActivityContext);\n+        break;\n+      case ELEMENT_TERMINATING:\n+        // the call activity is already terminating, it doesn't matter that the child completed\n+        // do nothing\n+        break;\n+      default:\n+        final var message = String.format(UNABLE_TO_COMPLETE_FROM_STATE_MESSAGE, currentState);\n+        throw new BpmnProcessingException(callActivityContext, message);\n+    }\n+  }\n+\n+  @Override\n+  public void onChildTerminated(\n+      final ExecutableCallActivity element,\n+      final BpmnElementContext callActivityContext,\n+      final BpmnElementContext childContext) {\n+    final var currentState = callActivityContext.getIntent();\n+    if (currentState == WorkflowInstanceIntent.ELEMENT_TERMINATING) {\n+      stateTransitionBehavior.transitionToTerminated(callActivityContext);\n+    } else {\n+      final var message = String.format(UNABLE_TO_TERMINATE_FROM_STATE_MESSAGE, currentState);\n+      throw new BpmnProcessingException(callActivityContext, message);\n+    }\n+  }\n+\n+  private Either<Failure, DirectBuffer> evaluateProcessId(\n+      final BpmnElementContext context, final ExecutableCallActivity element) {\n+    final var processIdExpression = element.getCalledElementProcessId();\n+    final var scopeKey = context.getElementInstanceKey();\n+    return expressionProcessor\n+        .evaluateStringExpression(processIdExpression, scopeKey)\n+        .map(BufferUtil::wrapString);", "originalCommit": "d53f0707fc60c06c43497b046997a57284591959", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8b270530acc646213453c7e48e179ca466b2893e", "url": "https://github.com/camunda-cloud/zeebe/commit/8b270530acc646213453c7e48e179ca466b2893e", "message": "chore(engine): migrate call activity processor", "committedDate": "2020-06-15T11:20:51Z", "type": "commit"}, {"oid": "daa125b26c0b1c0b9d15536077a6353a4b622ecf", "url": "https://github.com/camunda-cloud/zeebe/commit/daa125b26c0b1c0b9d15536077a6353a4b622ecf", "message": "chore(git): add jenv local config to gitignore", "committedDate": "2020-06-15T11:21:12Z", "type": "commit"}, {"oid": "daa125b26c0b1c0b9d15536077a6353a4b622ecf", "url": "https://github.com/camunda-cloud/zeebe/commit/daa125b26c0b1c0b9d15536077a6353a4b622ecf", "message": "chore(git): add jenv local config to gitignore", "committedDate": "2020-06-15T11:21:12Z", "type": "forcePushed"}]}