{"pr_number": 3928, "pr_title": "Introduce new ZeebeIndex", "pr_createdAt": "2020-02-26T14:35:03Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/3928", "timeline": [{"oid": "ffdb780c8c6be420caba4d029001b8d3ea9d5065", "url": "https://github.com/camunda-cloud/zeebe/commit/ffdb780c8c6be420caba4d029001b8d3ea9d5065", "message": "chore(logstreams): introduce new ZeebeIndex\n\n In order to improve seek performance and reduce log deletion time,\n we introducing a new ZeebeIndex. This index wraps the Atomix\n SparseJournalIndex and builds an own map of position to index.\n\n With this index it is easily and in a performant way possible to look\n up an index/address for a given position. This look up is used\n for example on deletion instead of the old seek strategy. This treats\n time against space, which means we need to use more space in memory but\n are fast to find an index/position.\n\n The ZeebeIndex is on startup injected into the RaftPartition such that\n is filled on leader and follower on appending new entries.\n\n The underlying data structure needs to be thread safe, since we access\n it on different threads.", "committedDate": "2020-02-28T06:55:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzExMjY1Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r387112656", "bodyText": "Can use floorEntry()\n   public long lookupPosition(final long position) {\n    final var lowerEntry = positionIndexMapping.floorEntry(position);\n    if (lowerEntry != null) {\n      return lowerEntry.getValue();\n    }\n    return -1;\n  }", "author": "deepthidevaki", "createdAt": "2020-03-03T15:50:22Z", "path": "logstreams/src/main/java/io/zeebe/logstreams/storage/atomix/ZeebeIndexAdapter.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.logstreams.storage.atomix;\n+\n+import io.atomix.protocols.raft.zeebe.ZeebeEntry;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.index.JournalIndex;\n+import io.atomix.storage.journal.index.Position;\n+import io.atomix.storage.journal.index.SparseJournalIndex;\n+import java.util.concurrent.ConcurrentNavigableMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+\n+public final class ZeebeIndexAdapter implements JournalIndex, ZeebeIndexMapping {\n+\n+  private final ConcurrentNavigableMap<Long, Long> positionIndexMapping =\n+      new ConcurrentSkipListMap<>();\n+  private final ConcurrentNavigableMap<Long, Long> indexPositionMapping =\n+      new ConcurrentSkipListMap<>();\n+  private final SparseJournalIndex sparseJournalIndex;\n+  private final int density;\n+\n+  private ZeebeIndexAdapter(int density) {\n+    this.density = density;\n+    sparseJournalIndex = new SparseJournalIndex(density);\n+  }\n+\n+  public static ZeebeIndexAdapter ofDensity(int density) {\n+    return new ZeebeIndexAdapter(density);\n+  }\n+\n+  @Override\n+  public void index(final Indexed indexedEntry, final int position) {\n+    final var index = indexedEntry.index();\n+    if (index % density == 0) {\n+      if (indexedEntry.type() == ZeebeEntry.class) {\n+        final ZeebeEntry zeebeEntry = (ZeebeEntry) indexedEntry.entry();\n+        final var lowestPosition = zeebeEntry.lowestPosition();\n+\n+        positionIndexMapping.put(lowestPosition, index);\n+        indexPositionMapping.put(index, lowestPosition);\n+      }\n+    }\n+\n+    sparseJournalIndex.index(indexedEntry, position);\n+  }\n+\n+  @Override\n+  public long lookupPosition(final long position) {\n+    var index = positionIndexMapping.getOrDefault(position, -1L);", "originalCommit": "ffdb780c8c6be420caba4d029001b8d3ea9d5065", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzExNjY0OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r387116648", "bodyText": "Just for completeness may be test one at exact position.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertThat(zeebeIndexAdapter.lookupPosition(21)).isEqualTo(5);\n          \n          \n            \n                assertThat(zeebeIndexAdapter.lookupPosition(20)).isEqualTo(5);", "author": "deepthidevaki", "createdAt": "2020-03-03T15:56:02Z", "path": "logstreams/src/test/java/io/zeebe/logstreams/storage/atomix/ZeebeIndexTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.logstreams.storage.atomix;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.protocols.raft.storage.log.entry.InitializeEntry;\n+import io.atomix.protocols.raft.zeebe.ZeebeEntry;\n+import io.atomix.storage.journal.Indexed;\n+import java.nio.ByteBuffer;\n+import org.junit.Test;\n+\n+public class ZeebeIndexTest {\n+\n+  @Test\n+  public void shouldNotFindIndexWhenNotReachedDensity() {\n+    // given - every 5 index is added\n+    final ZeebeIndexAdapter zeebeIndexAdapter = ZeebeIndexAdapter.ofDensity(5);\n+\n+    // when\n+    final var index = zeebeIndexAdapter.lookupPosition(1L);\n+\n+    // then\n+    assertThat(index).isEqualTo(-1);\n+  }\n+\n+  @Test\n+  public void shouldFindIndexWhenReachedDensity() {\n+    // given - every 5 index is added\n+    final ZeebeIndexAdapter zeebeIndexAdapter = ZeebeIndexAdapter.ofDensity(5);\n+\n+    // when\n+    zeebeIndexAdapter.index(asZeebeEntry(1, 1), 2);\n+    zeebeIndexAdapter.index(asZeebeEntry(2, 5), 4);\n+    zeebeIndexAdapter.index(asZeebeEntry(3, 10), 6);\n+    zeebeIndexAdapter.index(asZeebeEntry(4, 15), 8);\n+    zeebeIndexAdapter.index(asZeebeEntry(5, 20), 10);\n+\n+    // then\n+    assertThat(zeebeIndexAdapter.lookupPosition(1)).isEqualTo(-1);\n+    assertThat(zeebeIndexAdapter.lookupPosition(16)).isEqualTo(-1);\n+    assertThat(zeebeIndexAdapter.lookupPosition(21)).isEqualTo(5);", "originalCommit": "ffdb780c8c6be420caba4d029001b8d3ea9d5065", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzODcyNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r387138724", "bodyText": "Can we use atomixLogStorage.newReader()?", "author": "deepthidevaki", "createdAt": "2020-03-03T16:26:13Z", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -312,8 +316,10 @@ private StateSnapshotController createSnapshotController() {\n   }\n \n   private SnapshotStorage createSnapshotStorage() {\n+\n     final var reader =\n-        new AtomixLogStorageReader(atomixRaftPartition.getServer().openReader(-1, Mode.COMMITS));\n+        new AtomixLogStorageReader(\n+            zeebeIndexMapping, atomixRaftPartition.getServer().openReader(-1, Mode.COMMITS));", "originalCommit": "ffdb780c8c6be420caba4d029001b8d3ea9d5065", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI4MTk2NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388281964", "bodyText": "Actually here I was not 100% sure, since it used a different index as on newReader. Might that @npepinpe knows.", "author": "Zelldon", "createdAt": "2020-03-05T13:09:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzODcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI4OTI3Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388289273", "bodyText": "Hm, I guess we could use it, don't see any reason why not - the goal is just that it starts at the beginning.", "author": "npepinpe", "createdAt": "2020-03-05T13:23:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzODcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI4OTg0NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388289845", "bodyText": "newReader uses index zero or 1 and this one -1 \ud83e\udd37\u200d\u2642\ufe0f", "author": "Zelldon", "createdAt": "2020-03-05T13:24:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzODcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5MDI2NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388290265", "bodyText": "Yeah, doesn't really matter I think, just that it starts at the beginning, as far as I remember. Just try it and see, should be fine", "author": "npepinpe", "createdAt": "2020-03-05T13:25:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzODcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQxMzUwMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388413502", "bodyText": "I have approved the PR. You can change to atomixLogStorage.newReader() if you think it wouldn't break anything.", "author": "deepthidevaki", "createdAt": "2020-03-05T16:34:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzODcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQ3Njc3Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r389476776", "bodyText": "We currently need the implementation class in the AtomixRecordSupplier. I will leave it for now.", "author": "Zelldon", "createdAt": "2020-03-09T06:09:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzODcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MDI0Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r387140247", "bodyText": "This returns an address <= the current address, right? It will be better explained in the doc.", "author": "deepthidevaki", "createdAt": "2020-03-03T16:28:14Z", "path": "logstreams/src/main/java/io/zeebe/logstreams/log/LogStreamReader.java", "diffHunk": "@@ -64,14 +64,14 @@\n   long getPosition();\n \n   /**\n-   * The last log storage address, from which the last block of events was read.\n-   *\n-   * <p>Useful if you want to found out the related block address, then just seek to a given\n-   * position and call this method.\n+   * Look up the nearest log storage address, where the entry with the given position can be found.\n+   * The implementation do not need to provide the exact log event address, it is more about an\n+   * approximation, which can then be used to find the entry.\n    *\n    * <p>*Note:* The returned address is not the exact log event address.\n    *\n-   * @return the last log storage address, from which the last block of events was read.\n+   * @param position the position, for which the look up should made\n+   * @return the approximated address in the log storage\n    */\n-  long lastReadAddress();\n+  long lookupAddress(long position);", "originalCommit": "ffdb780c8c6be420caba4d029001b8d3ea9d5065", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI4MzUxNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388283514", "bodyText": "What do you mean with the current address? Which current? \ud83d\ude05 It just checks the index.", "author": "Zelldon", "createdAt": "2020-03-05T13:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MDI0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5MDc0Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388290746", "bodyText": "Sorry. I mean it returns an index corresponding to a pos <= given position.", "author": "deepthidevaki", "createdAt": "2020-03-05T13:26:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MDI0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5MTMxNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388291316", "bodyText": "Ok I think I get it :D", "author": "Zelldon", "createdAt": "2020-03-05T13:27:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MDI0Nw=="}], "type": "inlineReview"}, {"oid": "fa169cc18a4dd3f295d681a9f9baa507df61d968", "url": "https://github.com/camunda-cloud/zeebe/commit/fa169cc18a4dd3f295d681a9f9baa507df61d968", "message": "chore(util): set cause exception", "committedDate": "2020-03-05T13:15:04Z", "type": "commit"}, {"oid": "fb6187c9a99fceba0ea1afd2aba537b19cfea4ae", "url": "https://github.com/camunda-cloud/zeebe/commit/fb6187c9a99fceba0ea1afd2aba537b19cfea4ae", "message": "chore(logstreams): introduce new ZeebeIndex\n\n In order to improve seek performance and reduce log deletion time,\n we introducing a new ZeebeIndex. This index wraps the Atomix\n SparseJournalIndex and builds an own map of position to index.\n\n With this index it is easily and in a performant way possible to look\n up an index/address for a given position. This look up is used\n for example on deletion instead of the old seek strategy. This treats\n time against space, which means we need to use more space in memory but\n are fast to find an index/position.\n\n The ZeebeIndex is on startup injected into the RaftPartition such that\n is filled on leader and follower on appending new entries.\n\n The underlying data structure needs to be thread safe, since we access\n it on different threads.", "committedDate": "2020-03-05T13:16:37Z", "type": "commit"}, {"oid": "564a742c87161fbd8a5491480321edd381ae5d14", "url": "https://github.com/camunda-cloud/zeebe/commit/564a742c87161fbd8a5491480321edd381ae5d14", "message": "chore(logstreams): follow review hints", "committedDate": "2020-03-05T13:16:37Z", "type": "commit"}, {"oid": "564a742c87161fbd8a5491480321edd381ae5d14", "url": "https://github.com/camunda-cloud/zeebe/commit/564a742c87161fbd8a5491480321edd381ae5d14", "message": "chore(logstreams): follow review hints", "committedDate": "2020-03-05T13:16:37Z", "type": "forcePushed"}]}