{"pr_number": 4717, "pr_title": "Ensure log consistency", "pr_createdAt": "2020-06-12T15:54:00Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4717", "timeline": [{"oid": "dd1334b5fab43ef2b657ec25e3ef4a913738044f", "url": "https://github.com/camunda-cloud/zeebe/commit/dd1334b5fab43ef2b657ec25e3ef4a913738044f", "message": "fix(benchmarks): fix profiler script", "committedDate": "2020-06-13T09:11:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxNTEzNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441315134", "bodyText": "Why you switched to exceptions instead of return just an boolean? It looks from the api perspecitve a bit weird to call a validate method which returns nothing. I would expect it would return a boolean which indicates valid or not. These are the two expected cases, right? Thats why I'm not sure whether throwing exception in the impl of the listener makes sense. If not valid, which means the result is false then I might be ok with throwing a exception but not in the validator. Maybe we can also create a separate interface for the validation?", "author": "Zelldon", "createdAt": "2020-06-17T06:43:39Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/LeaderRole.java", "diffHunk": "@@ -710,9 +710,12 @@ private boolean isEntryConsistent(final long newEntryPosition) {\n       } while (index > 0 && lastEntry != null && lastEntry.type() != ZeebeEntry.class);\n     }\n \n-    return lastEntry == null\n-        || lastEntry.type() != ZeebeEntry.class\n-        || newEntryPosition > ((ZeebeEntry) lastEntry.entry()).highestPosition();\n+    long lastPosition = -1;\n+    if (lastEntry != null && lastEntry.type() == ZeebeEntry.class) {\n+      lastPosition = ((ZeebeEntry) lastEntry.entry()).highestPosition();\n+    }\n+\n+    listener.validatePositions(lastPosition, entry);", "originalCommit": "dd1334b5fab43ef2b657ec25e3ef4a913738044f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM0NDk1Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441344957", "bodyText": "I switched to the exception so we can build it in the validating function and give it more information about the failure. We can say \"we tried appending entry X and there was a gap\" but we can't say there was a gap between X and X+2. The gap might be between the last entry's highest position and the current entry's lowest or it might be that the a gap is detected but the current entry has the correct positions but in the wrong order. These are different situations and a more descriptive log can provide useful context. But maybe we can do this in a better way", "author": "MiguelPires", "createdAt": "2020-06-17T07:41:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxNTEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0MzUyNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r442643526", "bodyText": "You could also have a validation result object which contains an valid (true/false) property and an description of the error. I think this is normally the way.", "author": "Zelldon", "createdAt": "2020-06-19T05:49:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxNTEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0NDA4NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r442644085", "bodyText": "Example https://medium.com/@aleksanderkolata/java-tips-01-handle-validation-in-an-elegant-manner-using-chain-of-responsibility-design-pattern-ad3dcc22479e", "author": "Zelldon", "createdAt": "2020-06-19T05:51:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxNTEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1NDkyNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r442654925", "bodyText": "Sounds good, I'll do that", "author": "MiguelPires", "createdAt": "2020-06-19T06:28:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxNTEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxNjMyOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441316329", "bodyText": "Why the asserts before If you anyway throw an exception?", "author": "Zelldon", "createdAt": "2020-06-17T06:46:35Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/roles/LeaderRoleTest.java", "diffHunk": "@@ -431,12 +456,24 @@ public void onCommit(final Indexed<ZeebeEntry> indexed) {}\n \n           @Override\n           public void onCommitError(final Indexed<ZeebeEntry> indexed, final Throwable error) {}\n+\n+          @Override\n+          public void validatePositions(final long lastPosition, final ZeebeEntry entry) {\n+            assertThat(lastPosition).isEqualTo(7);\n+            assertThat(entry.lowestPosition()).isEqualTo(9);\n+            assertThat(entry.highestPosition()).isEqualTo(9);\n+            entry.data().rewind();\n+            data.rewind();\n+            assertThat(entry.data()).isEqualTo(data);\n+\n+            throw new IllegalStateException(\"expected\");", "originalCommit": "dd1334b5fab43ef2b657ec25e3ef4a913738044f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM1MDAzNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441350034", "bodyText": "This tests checks the validation from a LeaderRole perspective (there's other tests which test the listener specifically) so it tests that we get the correct data and that, if we throw an exception, the expected behavior happens (i.e., we don't appending, write error is returned, step down to follower)", "author": "MiguelPires", "createdAt": "2020-06-17T07:50:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxNjMyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0NDIwMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r442644203", "bodyText": "What if the assert fails? The test will still be green right?", "author": "Zelldon", "createdAt": "2020-06-19T05:52:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxNjMyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1NDg0Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r442654843", "bodyText": "No, if the assert fails the test also fails", "author": "MiguelPires", "createdAt": "2020-06-19T06:28:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxNjMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxNzc2MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441317761", "bodyText": "magic ?", "author": "Zelldon", "createdAt": "2020-06-17T06:49:46Z", "path": "dispatcher/src/main/java/io/zeebe/dispatcher/Dispatcher.java", "diffHunk": "@@ -142,6 +145,7 @@ public long claim(final ClaimedFragment claim, final int length, final int strea\n         (partition, activePartitionId) ->\n             logAppender.claim(\n                 partition, activePartitionId, claim, length, streamId, onClaimComplete),\n+        1,", "originalCommit": "dd1334b5fab43ef2b657ec25e3ef4a913738044f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM1MTg2OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441351868", "bodyText": "The offer method takes the fragment count. A batch fragment can have multiple fragments but this method is for a single fragment so the fragment count is 1. I can add a claimedFragment.getCount() but it seems silly since it can only be 1.", "author": "MiguelPires", "createdAt": "2020-06-17T07:53:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxNzc2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0NDQzNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r442644436", "bodyText": "maybe logAppender.claimSingleFragment() for this case to make it a bit clearer.", "author": "Zelldon", "createdAt": "2020-06-19T05:53:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxNzc2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxODA2Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441318066", "bodyText": "what do you mean with this comment?", "author": "Zelldon", "createdAt": "2020-06-17T06:50:23Z", "path": "dispatcher/src/main/java/io/zeebe/dispatcher/Dispatcher.java", "diffHunk": "@@ -191,10 +198,12 @@ private long offer(\n \n         newPosition = updatePublisherPosition(activePartitionId, newOffset);\n \n-        if (publisherPosition.proposeMaxOrdered(newPosition)) {\n-          LOG.trace(\"Updated publisher position to {}\", newPosition);\n+        // if successful, replace position with simple counter", "originalCommit": "dd1334b5fab43ef2b657ec25e3ef4a913738044f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM1NDA2MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441354061", "bodyText": "If we don't want to return -1 or -2 (because we're at the end of the partition for instance), then instead of returning a position based on the partitionId and the partitionOffset, we return a positions that's simply a count of records until now. How can I improve this? Or do you think it can be remove altogether?", "author": "MiguelPires", "createdAt": "2020-06-17T07:57:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxODA2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0NDY3OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r442644679", "bodyText": "I was not sure whether this is an todo or it is related to the code. I think the comment is more confusing then helpful.", "author": "Zelldon", "createdAt": "2020-06-19T05:53:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxODA2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA3ODI5OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444078298", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // if successful, replace position with simple counter\n          \n          \n            \n                    // if successful, replace internal publisher position with simple counter which will be returned", "author": "Zelldon", "createdAt": "2020-06-23T09:10:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxODA2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxODQ2Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441318466", "bodyText": "shouldn't this be volatile or an atomic long?", "author": "Zelldon", "createdAt": "2020-06-17T06:51:10Z", "path": "dispatcher/src/main/java/io/zeebe/dispatcher/Dispatcher.java", "diffHunk": "@@ -35,12 +35,13 @@\n \n   private final AtomicPosition publisherLimit;\n   private final AtomicPosition publisherPosition;\n+  private long recordPosition;", "originalCommit": "dd1334b5fab43ef2b657ec25e3ef4a913738044f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM1NDgzNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441354835", "bodyText": "The only accesses already have to be synchronized so I replaced the AtomicLong with a normal long. You mention the synchronize in the comment below so I'll write explain my position there", "author": "MiguelPires", "createdAt": "2020-06-17T07:58:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxODQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxOTAwNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441319006", "bodyText": "I think you could use a atomic long and do here an compare and set or something similar then we probably don't need this synchronize", "author": "Zelldon", "createdAt": "2020-06-17T06:52:27Z", "path": "dispatcher/src/main/java/io/zeebe/dispatcher/Dispatcher.java", "diffHunk": "@@ -191,10 +198,12 @@ private long offer(\n \n         newPosition = updatePublisherPosition(activePartitionId, newOffset);\n \n-        if (publisherPosition.proposeMaxOrdered(newPosition)) {\n-          LOG.trace(\"Updated publisher position to {}\", newPosition);\n+        // if successful, replace position with simple counter\n+        if (newPosition > 0) {\n+          newPosition = recordPosition;\n+          recordPosition += fragmentCount;", "originalCommit": "dd1334b5fab43ef2b657ec25e3ef4a913738044f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM2MDk1MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441360950", "bodyText": "If we remove the synchronize and make the recordPosition an atomicLong, we have a race condition between claiming the fragments and getting/updating the recordPosition. We didn't have to do this previously because by claiming the fragments we got the position implicitly. Without synchronizing, two concurrent threads can claim two fragments and then the second fragment gets the an earlier position and the first gets a later position.", "author": "MiguelPires", "createdAt": "2020-06-17T08:09:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxOTAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0NTg0Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r442645846", "bodyText": "we can use a lock-free approach, which looks like this\ndo {\ncurrentPosition =   position.get()\nnextPosition += fragmentCount;\n } while (!position.cas(currentPosition, nextPosition))\n\nExample https://github.com/zeebe-io/zeebe/blob/develop/util/src/main/java/io/zeebe/util/sched/channel/ActorConditions.java#L33", "author": "Zelldon", "createdAt": "2020-06-19T05:58:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxOTAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg3NDQyMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r442874422", "bodyText": "Follow up issue to investigate the performance impact: #4774", "author": "MiguelPires", "createdAt": "2020-06-19T14:31:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxOTAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxOTYzMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441319633", "bodyText": "Why is this necessary now? \ud83d\udc40", "author": "Zelldon", "createdAt": "2020-06-17T06:53:49Z", "path": "dispatcher/src/main/java/io/zeebe/dispatcher/Dispatcher.java", "diffHunk": "@@ -207,18 +216,22 @@ private long updatePublisherPosition(final int activePartitionId, final int newO\n     if (newOffset > 0) {\n       newPosition = position(activePartitionId, newOffset);\n     } else if (newOffset == RESULT_PADDING_AT_END_OF_PARTITION) {\n-      logBuffer.onActiveParitionFilled(activePartitionId);\n+      logBuffer.onActivePartitionFilled(activePartitionId);\n       newPosition = -2;\n     }\n \n+    if (publisherPosition.proposeMaxOrdered(newPosition)) {", "originalCommit": "dd1334b5fab43ef2b657ec25e3ef4a913738044f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM2NDE2Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441364166", "bodyText": "It was always necessary, I just moved it inside the function. The function is is called updatePublisherPosition so I thought it made sense to update the publisher position instead of us having to do that outside", "author": "MiguelPires", "createdAt": "2020-06-17T08:13:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxOTYzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0NTkzMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r442645931", "bodyText": "ok thanks", "author": "Zelldon", "createdAt": "2020-06-19T05:58:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxOTYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyMDU5OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441320598", "bodyText": "Why this was removed?", "author": "Zelldon", "createdAt": "2020-06-17T06:55:38Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/zeebe/ZeebeLogAppenderTest.java", "diffHunk": "@@ -103,24 +103,6 @@ public void shouldNotifyOnError() {\n     assertEquals(0L, appenderListener.getCommitted().size());\n   }\n \n-  @Test(timeout = 5000)\n-  public void shouldNotAppendInconsistent() {", "originalCommit": "dd1334b5fab43ef2b657ec25e3ef4a913738044f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM3NTQ2MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441375460", "bodyText": "Because it was replaced by better tests. The check depends on the listener so now we have tests to test this from the listener perspective (LogStorageAppenderTest) and also from the LeadeRole perspective (LeaderRoleTest). The new tests actually write a Zeebe record, intercept it and then corrupt its position, so we not only test that the appender checks the lowest/highest positions but that it reads them, detects a gap, writes an error message, etc.", "author": "MiguelPires", "createdAt": "2020-06-17T08:32:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyMDU5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0NjA0MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r442646040", "bodyText": "ok thanks", "author": "Zelldon", "createdAt": "2020-06-19T05:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyMDU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyMDc2MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441320761", "bodyText": "And these?", "author": "Zelldon", "createdAt": "2020-06-17T06:55:56Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/zeebe/ZeebeTest.java", "diffHunk": "@@ -260,79 +258,6 @@ public void shouldNotifyCommitListeners() {\n     }\n   }\n \n-  @Test\n-  public void shouldBeConsistentAfterFailOver() {", "originalCommit": "dd1334b5fab43ef2b657ec25e3ef4a913738044f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM3NTY1OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441375659", "bodyText": "Same reasoning as comment above #4717 (comment)", "author": "MiguelPires", "createdAt": "2020-06-17T08:32:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyMDc2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyMjE3NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441322174", "bodyText": "If we separate the interface I think all these other method implementations would not necessary. Maybe the validator can be registered at the beginning. No need to give it on each append right?", "author": "Zelldon", "createdAt": "2020-06-17T06:58:56Z", "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/Listener.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.logstreams.impl.log;\n+\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.zeebe.logstreams.spi.LogStorage.AppendListener;\n+import java.util.NoSuchElementException;\n+import org.agrona.concurrent.UnsafeBuffer;\n+\n+public final class Listener implements AppendListener {\n+\n+  private final LogStorageAppender appender;\n+  private final long highestPosition;\n+  private final UnsafeBuffer reader;\n+\n+  public Listener(\n+      final LogStorageAppender appender, final long highestPosition, final UnsafeBuffer reader) {\n+    this.appender = appender;\n+    this.highestPosition = highestPosition;\n+    this.reader = reader;\n+  }\n+\n+  @Override\n+  public void onWrite(final long address) {}\n+\n+  @Override\n+  public void onWriteError(final Throwable error) {\n+    LogStorageAppender.LOG.error(\n+        \"Failed to append block with last event position {}.\", highestPosition, error);\n+    if (error instanceof NoSuchElementException) {\n+      // Not a failure. It is probably during transition to follower.\n+      return;\n+    }\n+\n+    appender.runOnFailure(error);\n+  }\n+\n+  @Override\n+  public void onCommit(final long address) {\n+    releaseBackPressure();\n+  }\n+\n+  @Override\n+  public void onCommitError(final long address, final Throwable error) {\n+    LogStorageAppender.LOG.error(\n+        \"Failed to commit block with last event position {}.\", highestPosition, error);\n+    releaseBackPressure();\n+    appender.runOnFailure(error);\n+  }\n+\n+  @Override\n+  public void validatePositions(long lastPosition, final ZeebeEntry entry) {", "originalCommit": "dd1334b5fab43ef2b657ec25e3ef4a913738044f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQzNDY0Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441434642", "bodyText": "I don't know if I'm envisioning that implementation correctly, I'd like to understand it better. The leader role and the listener are already pretty coupled so adding one method to the listener doesn't add much additional mess there. We just add some empty methods in test implementations in addition to empty methods that were already there. I see a few suppliers and etc between the LogStorageAppender and the LeaderRole so it seems like registering a validator wouldn't be very clean.", "author": "MiguelPires", "createdAt": "2020-06-17T10:07:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyMjE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyMzQ2MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441323460", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private Tuple<Long, Long> readMinMax(final ByteBuffer buffer) {\n          \n          \n            \n              private Tuple<Long, Long> readLowestHighestPosition(final ByteBuffer buffer) {", "author": "Zelldon", "createdAt": "2020-06-17T07:01:32Z", "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStorageAppender.java", "diffHunk": "@@ -172,13 +168,16 @@ private void onWriteBufferAvailable() {\n     }\n   }\n \n-  private Positions readPositions(final ByteBuffer buffer) {\n+  private Tuple<Long, Long> readMinMax(final ByteBuffer buffer) {", "originalCommit": "dd1334b5fab43ef2b657ec25e3ef4a913738044f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNDIwOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441324209", "bodyText": "didn't you wrote an test in the dispatcher where the claim returned the the position based on the fragment count?", "author": "Zelldon", "createdAt": "2020-06-17T07:03:03Z", "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamBatchWriterImpl.java", "diffHunk": "@@ -197,11 +196,12 @@ public long tryWrite() {\n       copyExistingEventToBuffer();\n     }\n \n-    long result = claimBatchForEvents();\n-    if (result >= 0) {\n+    long position = claimBatchForEvents();\n+    if (position >= 0) {\n       try {\n         // return position of last event\n-        result = writeEventsToBuffer(claimedBatch.getBuffer());\n+        writeEventsToBuffer(claimedBatch.getBuffer(), position);\n+        position += eventCount - 1;", "originalCommit": "dd1334b5fab43ef2b657ec25e3ef4a913738044f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNDY5OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441324699", "bodyText": "So I think claim will return already the last position? ANd you then add again the event count?", "author": "Zelldon", "createdAt": "2020-06-17T07:04:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNDIwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM4Nzk5Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441387993", "bodyText": "Not quite. The Dispatcher tests verify that the next position increases based on the current fragment count. Claim returns the position of the first record. I think it makes more sense than returning the updated publisher position and then calculating the initial in the writers. The single writer had to subtract a frame length from the claimedPosition to get the actual position and the batch writer was replacing the position anyway using the position returned from ClaimedFragmentBatch#nextFragment.", "author": "MiguelPires", "createdAt": "2020-06-17T08:52:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNDIwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA4MDgzMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444080833", "bodyText": "I have the feeling the api can still be improved. We dont need to do that now but just an Idea.\nWe could return a list of claimed fragments. The ClaimedFragment holds and buffer and a position, which the write can use. You can then iterate over the list write in each fragment the corresponding data and the related position and dont need to recalculate it by yourself. wdyt?", "author": "Zelldon", "createdAt": "2020-06-23T09:14:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNDIwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEwNDQzMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444104430", "bodyText": "I'm not sure I understand the goal. We used to do the same things in the writers, except in a more complicated way. Previously, the position returned by the Dispatcher was not useful for the batch writer (it was not being used except as a success/fail flag) and was overwritten by the last calculated position. It was also not directly used by the single writer since we had to subtract a frame length to get the actual position of the fragment. Now the single writer uses the position returned by the Dispatcher as is and, since we want to return last event's position in the batch writer, we do that by taking into account the number of events in the batch.\nI might be misunderstanding the idea but returning a list of claimed fragment is different than a batch fragment, if we wrote the first fragment and failed in the second, the first fragment wouldn't be aborted. That gives us different semantics in writing. Maybe we could write some additional logic to get around this somehow but I'm not sure I understand why we would. To avoid doing position += eventCount - 1? I'm not sure I see the benefit, but I might not be seeing the full picture.", "author": "MiguelPires", "createdAt": "2020-06-23T09:54:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNDIwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDExMDcyMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444110723", "bodyText": "I think you misunderstood me. What I would like to have as an API where I not care where the position came from and how it is calculated.\nWhat we currently doing is to claim a batch, which is just a buffer and go over our to write events and write them in the buffer we got. We calculating the position then based on index and the returned position. On claiming we already give to the claimed batched how many fragments/events we will write.\nWhat I like to have is the following:\nfor (ClaimedFragment fragment : claimedBatch.getFragments) {\n\n writeDateInto(fragment.buffer);\n setPositionForEvent(fragment.position)\n\n}\n\n\nor\nvar iter = claimedBatch.iterator()\nwhile (iter.hasNext()) {\n var fragment = iter.next()\n  \n writeDateInto(fragment.buffer);\n setPositionForEvent(fragment.position)\n}", "author": "Zelldon", "createdAt": "2020-06-23T10:05:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNDIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNzE0Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441327146", "bodyText": "Hm this makes me thinking that this setup here is not ideal, since we now actually test this code and not the code in the Raft appender. It is easy that they drift away when we change something here or there. Any idea how we could use the actual code, which we use in production?", "author": "Zelldon", "createdAt": "2020-06-17T07:09:08Z", "path": "logstreams/src/test/java/io/zeebe/logstreams/util/AtomixLogStorageRule.java", "diffHunk": "@@ -87,12 +89,25 @@ public void appendEntry(\n       final long highestPosition,\n       final ByteBuffer data,\n       final AppendListener listener) {\n-    final Indexed<ZeebeEntry> entry =\n-        raftLog\n-            .writer()\n-            .append(\n-                new ZeebeEntry(\n-                    0, System.currentTimeMillis(), lowestPosition, highestPosition, data));\n+    final ZeebeEntry zbEntry =\n+        new ZeebeEntry(0, System.currentTimeMillis(), lowestPosition, highestPosition, data);", "originalCommit": "dd1334b5fab43ef2b657ec25e3ef4a913738044f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM5MTAyNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441391025", "bodyText": "I agree, I tried to do that but eventually gave up \ud83d\ude1b it's not ideal but idk of a good way to improve this without a lot of work for something so small", "author": "MiguelPires", "createdAt": "2020-06-17T08:56:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNzE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA4MTk1OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444081959", "bodyText": "Maybe we can use the LeaderAppender somehow", "author": "Zelldon", "createdAt": "2020-06-23T09:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNzE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA4MjAyOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444082029", "bodyText": "Follow up issue?", "author": "Zelldon", "createdAt": "2020-06-23T09:16:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNzE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA3MTExMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444071111", "bodyText": "Maybe it makes more sense to just keep the last append entry in memory (e.g. as a field) and then give it to the next append validation as last appended entry. In the validation we then get the last and the new and check the positions. I would like not to couple the position and index here to much. Currently the LeaderRole knows me to much about the entry.", "author": "Zelldon", "createdAt": "2020-06-23T08:58:46Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/LeaderRole.java", "diffHunk": "@@ -710,9 +710,12 @@ private boolean isEntryConsistent(final long newEntryPosition) {\n       } while (index > 0 && lastEntry != null && lastEntry.type() != ZeebeEntry.class);\n     }\n \n-    return lastEntry == null\n-        || lastEntry.type() != ZeebeEntry.class\n-        || newEntryPosition > ((ZeebeEntry) lastEntry.entry()).highestPosition();\n+    long lastPosition = -1;", "originalCommit": "95fcf77eff628120328bd9dafba03f71803120f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEwOTYzMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444109632", "bodyText": "We can pass the last entry to the validator instead of the last position but I we just use what's in memory, the validation won't work after a leader election, right? I agree that the Raft impl knows too much about zeebe but I think that's a consequence of mixing both as this issue does explicitly.", "author": "MiguelPires", "createdAt": "2020-06-23T10:03:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA3MTExMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDExMjk5NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444112994", "bodyText": "The followers are also appending; furthermore on opening/restart we going through the entire log to build the index", "author": "Zelldon", "createdAt": "2020-06-23T10:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA3MTExMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDExNjg1OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444116858", "bodyText": "The follower role just appends entries without knowing the type of entries it's appending, right? We still have to check if the entry is a zeebe entry before setting it so that coupling is still there. But I'll make that change", "author": "MiguelPires", "createdAt": "2020-06-23T10:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA3MTExMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDExOTExMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444119113", "bodyText": "We could do a pair programming session today to finish this topic", "author": "Zelldon", "createdAt": "2020-06-23T10:20:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA3MTExMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA3MTgxNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444071814", "bodyText": "I like that", "author": "Zelldon", "createdAt": "2020-06-23T08:59:45Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/LeaderRole.java", "diffHunk": "@@ -664,11 +667,10 @@ private void safeAppendEntry(\n       return;\n     }\n \n-    if (!isEntryConsistent(lowestPosition)) {\n-      appendListener.onWriteError(\n-          new IllegalStateException(\"New entry has lower Zeebe log position than last entry.\"));\n+    final ValidationResult result = validateEntryConsistency(entry, appendListener);", "originalCommit": "95fcf77eff628120328bd9dafba03f71803120f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA3NTg3Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444075876", "bodyText": "Still I think this doesn't need to be part of the Listener.\nI think what we can do is to create a Validator on Broker start and put it on the Atomix configuration, then it is added to the RaftContext and can be used in the LeaderAppender. There is no need that this logic is here, since it just checks the incoming parameters no other context is needed.\nShould I prepare something to show that as example?!", "author": "Zelldon", "createdAt": "2020-06-23T09:06:13Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/zeebe/ZeebeLogAppender.java", "diffHunk": "@@ -71,5 +71,16 @@ void appendEntry(\n      * @param error the error that occurred\n      */\n     void onCommitError(Indexed<ZeebeEntry> indexed, Throwable error);\n+\n+    /**\n+     * Called before writing to validated that the entry to be appended will not make the log\n+     * inconsistent.\n+     *\n+     * @param lastPosition the highest position of the previous entry\n+     * @param entry current to append\n+     * @return a ValidationResult containing the validation result and an error message, if it\n+     *     failed\n+     */\n+    ValidationResult validatePositions(long lastPosition, ZeebeEntry entry);", "originalCommit": "95fcf77eff628120328bd9dafba03f71803120f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA3NjQwOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444076409", "bodyText": "This would make the other code more cleaner since you dont need to implement the method everywhere else", "author": "Zelldon", "createdAt": "2020-06-23T09:07:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA3NTg3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEyMDk2Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444120967", "bodyText": "Should I prepare something to show that as example?!\n\nNo, I think I got it.", "author": "MiguelPires", "createdAt": "2020-06-23T10:23:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA3NTg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA4MTM0OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444081349", "bodyText": "Why we need this class actually?", "author": "Zelldon", "createdAt": "2020-06-23T09:15:19Z", "path": "logstreams/src/main/java/io/zeebe/logstreams/storage/atomix/AtomixAppendListenerAdapter.java", "diffHunk": "@@ -38,4 +39,9 @@ public void onCommit(final Indexed<ZeebeEntry> indexed) {\n   public void onCommitError(final Indexed<ZeebeEntry> indexed, final Throwable error) {\n     delegate.onCommitError(indexed.index(), error);\n   }\n+\n+  @Override", "originalCommit": "95fcf77eff628120328bd9dafba03f71803120f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c59fbe08251435f3d23a750a62c4ee040b931c48", "url": "https://github.com/camunda-cloud/zeebe/commit/c59fbe08251435f3d23a750a62c4ee040b931c48", "message": "chore(atomix): keep last entry in memory", "committedDate": "2020-06-23T21:02:01Z", "type": "forcePushed"}, {"oid": "402150e0aaafcddf8e70486ce5c83c65e6c5a89e", "url": "https://github.com/camunda-cloud/zeebe/commit/402150e0aaafcddf8e70486ce5c83c65e6c5a89e", "message": "chore(atomix): keep last ZeebeEntry in memory", "committedDate": "2020-06-24T15:13:48Z", "type": "forcePushed"}, {"oid": "a272c22c2271d810314b05a7312cc347739aa467", "url": "https://github.com/camunda-cloud/zeebe/commit/a272c22c2271d810314b05a7312cc347739aa467", "message": "chore(atomix): keep last ZeebeEntry in memory", "committedDate": "2020-06-24T15:17:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM0MDc5Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r445340793", "bodyText": "\ud83c\udf89", "author": "Zelldon", "createdAt": "2020-06-25T06:46:29Z", "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/ZeebeEntryValidator.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.logstreams.impl.log;\n+\n+import io.atomix.raft.zeebe.EntryValidator;\n+import io.atomix.raft.zeebe.ValidationResult;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import org.agrona.concurrent.UnsafeBuffer;\n+\n+public class ZeebeEntryValidator implements EntryValidator {", "originalCommit": "cdcf9c9c9989d96c4392d5014cc7a5811b4cc1ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM0MDk4NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r445340984", "bodyText": "Why this class was added again?", "author": "Zelldon", "createdAt": "2020-06-25T06:46:59Z", "path": "atomix/core/src/test/java/io/atomix/core/AbstractAtomixTest.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright 2017-present Open Networking Foundation\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.core;\n+\n+import io.atomix.cluster.Node;\n+import io.atomix.cluster.discovery.BootstrapDiscoveryProvider;\n+import io.atomix.cluster.discovery.MulticastDiscoveryProvider;\n+import io.atomix.utils.net.Address;\n+import io.zeebe.test.util.socket.SocketUtil;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.rules.TemporaryFolder;\n+\n+/** Base Atomix test. */\n+public abstract class AbstractAtomixTest {", "originalCommit": "cdcf9c9c9989d96c4392d5014cc7a5811b4cc1ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAwNjA0OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r446006049", "bodyText": "Ah it was probably when rebasing on develop. Must have added it by mistake.", "author": "MiguelPires", "createdAt": "2020-06-26T07:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM0MDk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM0NzMyMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r445347320", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Called before writing to validated that the entry to be appended will not make the log\n          \n          \n            \n               * inconsistent.\n          \n          \n            \n               Validates the current entry, which should be append to the log and compares it with the last already appended entry to ensure consistency.\n          \n          \n            \n               The ValidationResult reflects the outcome of the validation and holds an error message when the validation fails.", "author": "Zelldon", "createdAt": "2020-06-25T07:02:53Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/zeebe/EntryValidator.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft.zeebe;\n+\n+@FunctionalInterface\n+public interface EntryValidator {\n+\n+  /**\n+   * Called before writing to validated that the entry to be appended will not make the log\n+   * inconsistent.", "originalCommit": "cdcf9c9c9989d96c4392d5014cc7a5811b4cc1ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM0OTEzMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r445349132", "bodyText": "Do we even need that?", "author": "Zelldon", "createdAt": "2020-06-25T07:07:12Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java", "diffHunk": "@@ -678,6 +680,9 @@ private boolean appendEntry(\n       final CompletableFuture<AppendResponse> future) {\n     try {\n       final Indexed<RaftLogEntry> indexed = writer.append(entry);\n+      if (indexed.type() == ZeebeEntry.class) {\n+        lastZbEntry = ((ZeebeEntry) indexed.entry());", "originalCommit": "a272c22c2271d810314b05a7312cc347739aa467", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM0OTM1NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r445349355", "bodyText": "I think we only validate in leader role right? So for followers we probably dont need that. Or what do you think?", "author": "Zelldon", "createdAt": "2020-06-25T07:07:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM0OTEzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxMDE2Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r446010167", "bodyText": "The idea was to also keep in the follower so we could check it after being elected but I switched to a more robust way of doing it so it's no longer necessary.", "author": "MiguelPires", "createdAt": "2020-06-26T07:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM0OTEzMg=="}], "type": "inlineReview"}, {"oid": "c73738adf3b8e4be59cd69cf81f38baa95195b32", "url": "https://github.com/camunda-cloud/zeebe/commit/c73738adf3b8e4be59cd69cf81f38baa95195b32", "message": "chore(logstreams): check records are consistently appended\n  * positions are now consecutive (they increase by 1)\n  * before appending, we check that there are no gaps between records", "committedDate": "2020-06-26T11:37:23Z", "type": "commit"}, {"oid": "c73738adf3b8e4be59cd69cf81f38baa95195b32", "url": "https://github.com/camunda-cloud/zeebe/commit/c73738adf3b8e4be59cd69cf81f38baa95195b32", "message": "chore(logstreams): check records are consistently appended\n  * positions are now consecutive (they increase by 1)\n  * before appending, we check that there are no gaps between records", "committedDate": "2020-06-26T11:37:23Z", "type": "forcePushed"}]}